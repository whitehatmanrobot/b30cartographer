define IDS_MH_FILE_LINK                (IDS_MH_FSIDM_FIRST + SHARED_FILE_LINK)
#define IDS_MH_FILE_RENAME              (IDS_MH_FSIDM_FIRST + SHARED_FILE_RENAME)

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        126
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\sfolder.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       sfolder.cxx
//
//  Contents:   Implementation of IShellFolder
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dutil.hxx"
#include "enum.hxx"
#include "menuutil.hxx"
#include "menu.hxx"
#include "menusp.hxx"
#include "menubg.hxx"
#include "sdetails.hxx"
#include "sfolder.hxx"
#include "shares.h"
#include "shares.hxx"
#include "util.hxx"
#include "xicon.hxx"
#include "resource.h"
#include "strsafe.h"

//////////////////////////////////////////////////////////////////////////////

void
FSSetStatusText(
    HWND hwndOwner,
    LPTSTR* ppszText,
    int iStart,
    int iEnd);

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesSF::ParseDisplayName(
    HWND hwndOwner,
    LPBC pbc,
    LPOLESTR lpszDisplayName,
    ULONG* pchEaten,
    LPITEMIDLIST* ppidlOutm,
    ULONG* pdwAttributes
    )
{
    return E_NOTIMPL;
}


STDMETHODIMP
CSharesSF::GetAttributesOf(
    UINT cidl,
    LPCITEMIDLIST* apidl,
    ULONG* pdwInOut
    )
{
    // There are four types of object: New object, View NetWare, View Mac,
    // and regular share. If there is a single selection, then the operations
    // possible are:
    //      New share:      open, create shortcut
    //      View NetWare:   open, create shortcut
    //      View Mac:       open, create shortcut
    //      a share:        delete, properties
    // If there are different types of objects multiply selected, then
    // the items must all be shares, or there are no allowed operations.
    // For shares, the only multiple-select operation allowed is delete.

    ULONG fMask = 0;

    if (cidl == 0)
    {
        // What things in general can be done in the folder? Return a
        // mask of everything possible.
        fMask = SFGAO_CANDELETE | SFGAO_HASPROPSHEET | SFGAO_CANRENAME | SFGAO_LINK;
    }
    else if (cidl == 1)
    {
        LPIDSHARE pids = (LPIDSHARE)apidl[0];
        if (Share_IsShare(pids))
        {
            fMask = SFGAO_CANDELETE | SFGAO_HASPROPSHEET;
            if (!(Share_GetType(pids) & STYPE_SPECIAL))
            {
                fMask |= SFGAO_CANRENAME;
            }
        }
        else
        {
            fMask = SFGAO_CANLINK;
        }
    }
    else if (cidl > 1)
    {
        UINT i;
        for (i = 0; i < cidl; i++)
        {
            LPIDSHARE pids = (LPIDSHARE)apidl[i];
            if (!Share_IsShare(pids))
            {
                break;
            }
        }

        if (i == cidl)
        {
            fMask |= SFGAO_CANDELETE;
        }
    }

    *pdwInOut &= fMask;
    return S_OK;
}


STDMETHODIMP
CSharesSF::GetUIObjectOf(
    HWND hwndOwner,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    REFIID riid,
    UINT* prgfInOut,
    LPVOID* ppvOut
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    HRESULT hr = E_NOINTERFACE;

    *ppvOut = NULL;

    if (cidl == 1 && IsEqualIID(riid, IID_IExtractIcon))
    {
        LPIDSHARE pids = (LPIDSHARE)apidl[0];

        CSharesEI* pObj = new CSharesEI(Share_GetFlags(pids), Share_GetType(pids));
        if (NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }

        hr = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }
#ifdef UNICODE
    else if (cidl == 1 && IsEqualIID(riid, IID_IExtractIconA))
    {
        LPIDSHARE pids = (LPIDSHARE)apidl[0];

        CSharesEIA* pObj = new CSharesEIA(Share_GetFlags(pids), Share_GetType(pids));
        if (NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }

        hr = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }
#endif // UNICODE
    else if (cidl > 0 && IsEqualIID(riid, IID_IContextMenu))
    {
        // Create a context menu for selected items. If there is only one
        // item, then the context menu is based on that object and is
        // CSharesCM for shares and CSharesCMSpecial for special objects.
        // If there is a multiple selection, then the selection must all be
        // shares, in which case the context-menu is CSharesCM, else there
        // is no context menu!

        if (This->m_level < 2)
        {
            // user has insufficient privilege to perform any operations.
            return E_NOINTERFACE;
        }

        IUnknown* punk = NULL;
        if (cidl == 1)
        {
            LPIDSHARE pids = (LPIDSHARE)apidl[0];
            if (Share_IsShare(pids))
            {
                CSharesCM* pObj = new CSharesCM(hwndOwner);
                if (NULL == pObj)
                {
                    return E_OUTOFMEMORY;
                }

                hr = pObj->InitInstance(This->m_pszMachine, cidl, apidl, this);
                if (FAILED(hr))
                {
                    return hr;
                }

                punk = (IUnknown*)pObj;
            }
#ifdef WIZARDS
            else
            {
                CSharesCMSpecial* pObj = new CSharesCMSpecial(hwndOwner);
                if (NULL == pObj)
                {
                    return E_OUTOFMEMORY;
                }

                hr = pObj->InitInstance(This->m_pszMachine, apidl[0], this);
                if (FAILED(hr))
                {
                    return hr;
                }

                punk = (IUnknown*)pObj;
            }
#endif // WIZARDS
        }
        else if (cidl > 1)
        {
            UINT i;
            for (i = 0; i < cidl; i++)
            {
                LPIDSHARE pids = (LPIDSHARE)apidl[i];
                if (!Share_IsShare(pids))
                {
                    break;
                }
            }

            if (i == cidl)
            {
                CSharesCM* pObj = new CSharesCM(hwndOwner);
                if (NULL == pObj)
                {
                    return E_OUTOFMEMORY;
                }

                hr = pObj->InitInstance(This->m_pszMachine, cidl, apidl, this);
                if (FAILED(hr))
                {
                    delete pObj; // 692939-2002/08/23-JonN PREFIX
                    return hr;
                }

                punk = (IUnknown*)pObj;
            }
            else
            {
                return E_FAIL;
            }
        }

        appAssert(NULL != punk);
        hr = punk->QueryInterface(riid, ppvOut);
        punk->Release();
    }
    else if (cidl > 0 && IsEqualIID(riid, IID_IDataObject))
    {
        hr = CIDLData_CreateFromIDArray(
                        This->m_pidl,
                        cidl,
                        apidl,
                        (LPDATAOBJECT *)ppvOut);
    }

    return hr;
}


STDMETHODIMP
CSharesSF::EnumObjects(
    HWND hwndOwner,
    DWORD grfFlags,
    LPENUMIDLIST* ppenumUnknown
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    HRESULT hr = E_FAIL;

    *ppenumUnknown = NULL;

    if (!(grfFlags & SHCONTF_NONFOLDERS))
    {
        return hr;
    }

    appAssert(0 != This->m_level);
    CSharesEnum* pEnum = new CSharesEnum(This->m_pszMachine, This->m_level);
    if (NULL == pEnum)
    {
        return E_OUTOFMEMORY;
    }

    hr = pEnum->Init(grfFlags);
    if (FAILED(hr))
    {
        delete pEnum; // 693233-2002/08/23-JonN PREFIX
        return hr;
    }

    hr = pEnum->QueryInterface(IID_IEnumIDList, (LPVOID*)ppenumUnknown);
    pEnum->Release();
    return hr;
}


STDMETHODIMP
CSharesSF::BindToObject(
    LPCITEMIDLIST pidl,
    LPBC pbc,
    REFIID riid,
    LPVOID* ppvOut
    )
{
    //
    // Shares folder doesn't contain sub-folders
    //

    *ppvOut = NULL;
    return E_FAIL;
}


// not used in Win95
STDMETHODIMP
CSharesSF::BindToStorage(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID* ppvOut
    )
{
    *ppvOut = NULL;
    return E_NOTIMPL;
}

#define PlusMinus(x) (((x) < 0) ? -1 : ( ((x) > 0) ? 1 : 0 ))

int
CSharesSF::_CompareOne(
    DWORD iCol,
    LPIDSHARE pids1,
    LPIDSHARE pids2
    )
{
    switch (iCol)
    {
    case ICOL2_NAME:
        return lstrcmpi(Share_GetName(pids1), Share_GetName(pids2));

    case ICOL2_COMMENT:
        return lstrcmpi(Share_GetComment(pids1), Share_GetComment(pids2));

    case ICOL2_PATH:
        return lstrcmpi(Share_GetPath(pids1), Share_GetPath(pids2));

    case ICOL2_MAXUSES:
    {
        DWORD max1 = Share_GetMaxUses(pids1);
        DWORD max2 = Share_GetMaxUses(pids2);
        if (max1 == SHI_USES_UNLIMITED && max2 == SHI_USES_UNLIMITED)
        {
            return 0;
        }
        else if (max1 == SHI_USES_UNLIMITED)
        {
            return 1;
        }
        else if (max2 == SHI_USES_UNLIMITED)
        {
            return -1;
        }
        else
        {
            return max1 - max2;
        }
    }

    default: appAssert(!"Illegal column"); return 0;
    }
}

STDMETHODIMP
CSharesSF::CompareIDs(
    LPARAM iCol,
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);

    // If one item is a special item, then put it ahead of the other one.
    // If they are both special items, sort on name.

    LPIDSHARE pids1 = (LPIDSHARE)pidl1;
    LPIDSHARE pids2 = (LPIDSHARE)pidl2;
    int iCmp;

#ifdef WIZARDS
    if (Share_IsSpecial(pids1))
    {
        if (Share_IsSpecial(pids2))
        {
            // both special; sort on name
            return ResultFromShort(lstrcmpi(Share_GetName(pids1),
                                            Share_GetName(pids2)));
        }
        else
        {
            return ResultFromShort(-1);
        }
    }
    else if (Share_IsSpecial(pids2))
    {
        return ResultFromShort(1);
    }
#endif // WIZARDS

    // Documentation says iCol is always zero, but that is wrong! It will
    // be non-zero in case the user has clicked on a column heading to sort
    // the column. In general, we want the entire item to be equal before we
    // return 0 for equality. To do this, we first check the chosen element.
    // If it is not equal, return the value. Otherwise, check all elements in
    // this standard order:
    //      name
    //      comment
    //      path
    //      max uses
    //      current uses
    // Only after all these checks return 0 (equality) do we return 0 (equality)

    iCmp = _CompareOne((ULONG)iCol, pids1, pids2);
    if (iCmp != 0)
    {
        return ResultFromShort(PlusMinus(iCmp));
    }

    // now, check each in turn

    iCmp = _CompareOne(ICOL2_NAME, pids1, pids2);
    if (iCmp != 0)
    {
        return ResultFromShort(PlusMinus(iCmp));
    }

    iCmp = _CompareOne(ICOL2_COMMENT, pids1, pids2);
    if (iCmp != 0)
    {
        return ResultFromShort(PlusMinus(iCmp));
    }

    if (This->m_level == 2)
    {
        iCmp = _CompareOne(ICOL2_PATH, pids1, pids2);
        if (iCmp != 0)
        {
            return ResultFromShort(PlusMinus(iCmp));
        }

        iCmp = _CompareOne(ICOL2_MAXUSES, pids1, pids2);
        if (iCmp != 0)
        {
            return ResultFromShort(PlusMinus(iCmp));
        }
    }

    return 0;   // the same!
}


STDMETHODIMP
CSharesSF::CreateViewObject(
    HWND hwnd,
    REFIID riid,
    LPVOID* ppvOut
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    HRESULT hr = E_NOINTERFACE;

    *ppvOut = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        CSFV csfv =
        {
            sizeof(CSFV),         // cbSize
            (IShellFolder*)this,  // pshf
            NULL,                 // psvOuter
            NULL,                 // pidl to monitor (NULL == all)
            SHCNE_NETSHARE | SHCNE_NETUNSHARE | SHCNE_UPDATEITEM, // events
            _SFVCallBack,         // pfnCallback
            FVM_DETAILS
        };

        hr = SHCreateShellFolderViewEx(&csfv, (LPSHELLVIEW *)ppvOut);
    }
    else if (IsEqualIID(riid, IID_IShellDetails))
    {
        appAssert(This->m_level != 0);
        CSharesSD* pObj = new CSharesSD(hwnd, This->m_level);
        if (NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }

        hr = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        // Create a context menu for the background
        CSharesCMBG* pObj = new CSharesCMBG(hwnd, This->m_pszMachine, This->m_level);
        if (NULL == pObj)
        {
            return E_OUTOFMEMORY;
        }

        hr = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }

    return hr;
}


STDMETHODIMP
CSharesSF::GetDisplayNameOf(
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);

    LPIDSHARE pids = (LPIDSHARE)pidl;
    if (uFlags == SHGDN_FORPARSING)
    {
        return E_NOTIMPL;   // don't support parsing.
    }
    else if (uFlags == SHGDN_INFOLDER)
    {
        return STRRETCopy(Share_GetName(pids), lpName);
    }
    else if (uFlags == SHGDN_NORMAL)
    {
        if (NULL == This->m_pszMachine)
        {
            return STRRETCopy(Share_GetName(pids), lpName);
        }
        else
        {
            LPWSTR pszMachine = This->m_pszMachine;
            if (pszMachine[0] == TEXT('\\') && pszMachine[1] == TEXT('\\'))
            {
                pszMachine += 2;
            }

            WCHAR szBuf[MAX_PATH];
            szBuf[0] = L'\0';
            MyFormatMessage(
                    MSG_TEMPLATE_WITH_ON,
                    szBuf,
                    ARRAYLEN(szBuf),
                    pszMachine,
                    Share_GetName(pids));
#ifdef UNICODE
            int cchCopy = lstrlen(szBuf)+1;
            LPTSTR pszCopy = (LPTSTR)SHAlloc(cchCopy * sizeof(TCHAR));
            if (pszCopy)
            {
                StringCchCopy(pszCopy, cchCopy, szBuf);
                lpName->uType = STRRET_OLESTR;
                lpName->pOleStr = pszCopy;
            }
            else
            {
                lpName->uType = STRRET_CSTR;
                lpName->cStr[0] = '\0';
            }
#else
            lpName->uType = STRRET_CSTR;
            StringCchCopy(lpName->cStr, ARRAYSIZE(lpName->cStr), szBuf);
            SHFree(pszRet);
#endif

            return S_OK;
        }
    }
    else
    {
        return E_INVALIDARG;
    }
}


STDMETHODIMP
CSharesSF::SetNameOf(
    HWND hwndOwner,
    LPCITEMIDLIST pidl,
    LPCOLESTR lpszName,
    DWORD uFlags,
    LPITEMIDLIST* ppidlOut
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);

    if (uFlags != SHGDN_INFOLDER)
    {
        return E_NOTIMPL;
    }

    if (NULL == lpszName || L'\0' == *lpszName)
    {
        // can't change name to nothing
        MessageBeep(0);
        return E_FAIL;
    }

    NET_API_STATUS ret;
    WCHAR szBuf[MAX_PATH];
    LPSHARE_INFO_502 pInfo;
    LPIDSHARE pids = (LPIDSHARE)pidl;

    // Get information about the existing share before deleting it.
    ret = NetShareGetInfo(This->m_pszMachine, Share_GetName(pids), 502, (LPBYTE*)&pInfo);
    if (ret != NERR_Success)
    {
        DisplayError(hwndOwner, IERR_CANT_DEL_SHARE, ret, Share_GetName(pids));
        return HRESULT_FROM_WIN32(ret);
    }

    // Validate the new share name

    // Trying to create a reserved share?
    if (   (0 == _wcsicmp(g_szIpcShare,   lpszName))
        || (0 == _wcsicmp(g_szAdminShare, lpszName)))
    {
        MyErrorDialog(hwndOwner, MSG_ADDSPECIAL2);
        NetApiBufferFree(pInfo);
        return E_FAIL;
    }

    HRESULT hrTemp;
    if (!IsValidShareName(lpszName, &hrTemp))
    {
        MyErrorDialog(hwndOwner, hrTemp);
        NetApiBufferFree(pInfo);
        return E_FAIL;
    }

    // Check to see that the same share isn't already used, for either the
    // same path or for another path.

    SHARE_INFO_2* pInfo2;
    ret = NetShareGetInfo(This->m_pszMachine, (LPWSTR)lpszName, 2, (LPBYTE*)&pInfo2);
    if (ret == NERR_Success)
    {
        // Is it already shared for the same path?
        if (0 == _wcsicmp(pInfo2->shi2_path, pInfo->shi502_path))
        {
            MyErrorDialog(hwndOwner, IERR_AlreadyExists, lpszName);
            NetApiBufferFree(pInfo);
            NetApiBufferFree(pInfo2);
            return TRUE;
        }

        // Shared for a different path. Ask the user if they wish to delete
        // the old share and create the new one using the name.

        DWORD id = ConfirmReplaceShare(hwndOwner, lpszName, pInfo2->shi2_path, pInfo->shi502_path);
        if (id == IDNO || id == IDCANCEL)   // FEATURE: should be only yes/no
        {
            NetApiBufferFree(pInfo);
            NetApiBufferFree(pInfo2);
            return E_FAIL;
        }

        // User said to replace the old share. Do it.
        ret = NetShareDel(This->m_pszMachine, (LPWSTR)lpszName, 0);
        if (ret != NERR_Success)
        {
            DisplayError(hwndOwner, IERR_CANT_DEL_SHARE, ret, (LPWSTR)lpszName);
            NetApiBufferFree(pInfo);
            NetApiBufferFree(pInfo2);
            return FALSE;
        }
        else
        {
            SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, pInfo2->shi2_path, NULL);
        }

        NetApiBufferFree(pInfo2);
    }

    // Check for downlevel accessibility
    ULONG nType;
    if (NERR_Success != NetpPathType(NULL, (LPWSTR)lpszName, &nType, INPT_FLAGS_OLDPATHS))
    {
        DWORD id = MyConfirmationDialog(
                        hwndOwner,
                        IERR_InaccessibleByDos,
                        MB_YESNO | MB_ICONEXCLAMATION,
                        lpszName);
        if (id == IDNO)
        {
            return TRUE;
        }
    }

    // delete the existing share
    ret = NetShareDel(This->m_pszMachine, Share_GetName(pids), 0);
    if (ret != NERR_Success)
    {
        NetApiBufferFree(pInfo);
        DisplayError(hwndOwner, IERR_CANT_DEL_SHARE, ret, Share_GetName(pids));
        return HRESULT_FROM_WIN32(ret);
    }

    // Create a new share with the new name.
    LPWSTR ptmp = pInfo->shi502_netname;
    pInfo->shi502_netname = (LPWSTR)lpszName;   // cast away const
    ret = NetShareAdd(This->m_pszMachine, 502, (LPBYTE)pInfo, NULL);
    if (ret != NERR_Success)
    {
        pInfo->shi502_netname = ptmp;
        NetApiBufferFree(pInfo);
        DisplayError(hwndOwner, IERR_CANT_ADD_SHARE, ret, (LPWSTR)lpszName); // cast away const
        return HRESULT_FROM_WIN32(ret);
    }

    // Ok, now I've renamed it. So, fill an ID list with the new guy, and
    // return it in *ppidlOut.

    HRESULT hr = S_OK;
    if (NULL != ppidlOut)
    {
        IDSHARE ids;
        FillID2(&ids, (LPSHARE_INFO_2)pInfo); // ignore security at end of level 502

        *ppidlOut = ILClone((LPCITEMIDLIST)(&ids));
        if (NULL == *ppidlOut)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // force a view refresh
    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, NULL, 0);

    pInfo->shi502_netname = ptmp;
    NetApiBufferFree(pInfo);
    return hr;
}


//
// Callback from SHCreateShellFolderViewEx
//

HRESULT CALLBACK
CSharesSF::_SFVCallBack(
    LPSHELLVIEW psvOuter,
    LPSHELLFOLDER psf,
    HWND hwndOwner,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CShares* This = IMPL(CShares,m_ShellFolder,psf);
    HRESULT hr = S_OK;     // assume no error

    switch (uMsg)
    {
    case DVM_UPDATESTATUSBAR:
    {
        IShellBrowser* psb = FileCabinet_GetIShellBrowser(hwndOwner);
        UINT cidl = ShellFolderView_GetSelectedCount(hwndOwner);
        if (cidl == 1)
        {
            LPITEMIDLIST *apidl;
            LPIDSHARE pids;
            LPTSTR lpsz = TEXT("");

            ShellFolderView_GetSelectedObjects(hwndOwner, &apidl);
            if (apidl)
            {
                pids = (LPIDSHARE)apidl[0];
                if (Share_IsShare(pids))
                {
                    lpsz = Share_GetComment(pids);
                }
                FSSetStatusText(hwndOwner, &lpsz, 0, 0);
                LocalFree(apidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }
        break;
    }

    case DVM_MERGEMENU:
    {
        appDebugOut((DEB_TRACE, "DVM_MERGEMENU\n"));
        appAssert(This->m_pMenuBg == NULL);
        hr = psf->CreateViewObject(hwndOwner, IID_IContextMenu, (LPVOID*)&This->m_pMenuBg);
        if (SUCCEEDED(hr))
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;
            hr = This->m_pMenuBg->QueryContextMenu(
                                    pqcm->hmenu,
                                    pqcm->indexMenu,
                                    pqcm->idCmdFirst,
                                    pqcm->idCmdLast,
                                    CMF_DVFILE);
        }
        break;
    }

    case DVM_UNMERGEMENU:
    {
        appDebugOut((DEB_TRACE, "DVM_UNMERGEMENU\n"));
        if (NULL != This->m_pMenuBg)
        {
            This->m_pMenuBg->Release();
            This->m_pMenuBg = NULL;
        }
        break;
    }

    case DVM_INVOKECOMMAND:
    {
        appDebugOut((DEB_TRACE, "DVM_INVOKECOMMAND\n"));
        appAssert(This->m_pMenuBg != NULL);
        CMINVOKECOMMANDINFO ici =
        {
            sizeof(ici),
            0,  // mask
            hwndOwner,
            (LPCSTR)wParam,
            NULL,
            NULL,
            0,
            0,
            NULL
        };
        hr = This->m_pMenuBg->InvokeCommand(&ici);
        break;
    }

    case DVM_GETHELPTEXT:
    {
        appDebugOut((DEB_TRACE, "DVM_GETHELPTEXT\n"));
        hr = This->m_pMenuBg->GetCommandString(LOWORD(wParam), GCS_HELPTEXT, NULL, (LPSTR)lParam, HIWORD(wParam));
        break;
    }

    case DVM_DEFITEMCOUNT:
        //
        // If DefView times out enumerating items, let it know we probably only
        // have about 20 items
        //

        *(int *)lParam = 20;
        break;

    case DVM_FSNOTIFY:
    {
        LPCITEMIDLIST* ppidl = (LPCITEMIDLIST*)wParam;

        switch (lParam)
        {
        case SHCNE_NETSHARE:
        case SHCNE_NETUNSHARE:
            // a share was added, removed, or changed. Force a view refresh.
//            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, NULL, 0);
            return S_OK;
        }
        break;
    }

    default:
        hr = E_FAIL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\sdetails.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       sdetails.cxx
//
//  Contents:   Implementation of IShellDetails
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "sdetails.hxx"
#include "shares.h"
#include "shares.hxx"
#include "resource.h"
#include "util.hxx"
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////////////

//
// Define the columns that we know about...
//

struct COL_INFO
{
    UINT idString;
    int  fmt;
    UINT cxChar;
};

const COL_INFO c_ColumnHeaders1[] =
{
    {IDS_NAME,    LVCFMT_LEFT, 25},
    {IDS_COMMENT, LVCFMT_LEFT, 30},
};

const COL_INFO c_ColumnHeaders2[] =
{
    {IDS_NAME,    LVCFMT_LEFT, 25},
    {IDS_COMMENT, LVCFMT_LEFT, 30},
    {IDS_PATH,    LVCFMT_LEFT, 30},
    {IDS_MAXUSES, LVCFMT_LEFT, 15},
};

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesSD::GetDetailsOf(
    LPCITEMIDLIST pidl,
    UINT iColumn,
    LPSHELLDETAILS lpDetails
    )
{
    switch (m_level)
    {
    case 1: return GetDetailsOf1(pidl, iColumn, lpDetails);
    case 2: return GetDetailsOf2(pidl, iColumn, lpDetails);
    default: appAssert(FALSE); return E_FAIL;
    }
}

STDMETHODIMP
CSharesSD::GetDetailsOf1(
    LPCITEMIDLIST pidl,
    UINT iColumn,
    LPSHELLDETAILS lpDetails
    )
{
    if (iColumn >= ICOL1_MAX)
    {
        return E_NOTIMPL;
    }

    HRESULT hr;
    LPIDSHARE pids = (LPIDSHARE)pidl;
    if (NULL == pids)
    {
        hr = STRRETLoadString(c_ColumnHeaders1[iColumn].idString, &lpDetails->str);
        if (FAILED(hr))
        {
            return hr;
        }

        lpDetails->fmt    = c_ColumnHeaders1[iColumn].fmt;
        lpDetails->cxChar = c_ColumnHeaders1[iColumn].cxChar;
        return NOERROR;
    }

#ifdef WIZARDS

    if (   Share_IsNewShareWizard(pids)
        || Share_IsNetWareWizard(pids)
        || Share_IsMacWizard(pids)
        )
    {
        switch (iColumn)
        {
        case ICOL1_NAME:
            hr = STRRETCopy(Share_GetName(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL1_COMMENT:
            lpDetails->str.uType = STRRET_CSTR;
            lpDetails->str.cStr[0] = '\0';
            break;
        }
    }
    else
#endif // WIZARDS
    {
        appAssert(Share_GetLevel(pids) == 1);

        switch (iColumn)
        {
        case ICOL1_NAME:
            hr = STRRETCopy(Share_GetName(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL1_COMMENT:
            hr = STRRETCopy(Share_GetComment(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;
        }
    }

    return NOERROR;
}

STDMETHODIMP
CSharesSD::GetDetailsOf2(
    LPCITEMIDLIST pidl,
    UINT iColumn,
    LPSHELLDETAILS lpDetails
    )
{
    if (iColumn >= ICOL2_MAX)
    {
        return E_NOTIMPL;
    }

    HRESULT hr;
    LPIDSHARE pids = (LPIDSHARE)pidl;
    if (NULL == pids)
    {
        hr = STRRETLoadString(c_ColumnHeaders2[iColumn].idString, &lpDetails->str);
        if (FAILED(hr))
        {
            return hr;
        }

        lpDetails->fmt    = c_ColumnHeaders2[iColumn].fmt;
        lpDetails->cxChar = c_ColumnHeaders2[iColumn].cxChar;
        return NOERROR;
    }

#ifdef WIZARDS
    if (   Share_IsNewShareWizard(pids)
        || Share_IsNetWareWizard(pids)
        || Share_IsMacWizard(pids)
        )
    {
        switch (iColumn)
        {
        case ICOL2_NAME:
            hr = STRRETCopy(Share_GetName(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL2_COMMENT:
            lpDetails->str.uType = STRRET_CSTR;
            lpDetails->str.cStr[0] = '\0';
            break;
        }
    }
    else
#endif // WIZARDS
    {
        appAssert(Share_GetLevel(pids) == 2);

        switch (iColumn)
        {
        case ICOL2_NAME:
            hr = STRRETCopy(Share_GetName(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL2_COMMENT:
            hr = STRRETCopy(Share_GetComment(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL2_PATH:
            hr = STRRETCopy(Share_GetPath(pids), &lpDetails->str);
            if (FAILED(hr))
            {
                return hr;
            }
            break;

        case ICOL2_MAXUSES:
        {
            DWORD maxuses = Share_GetMaxUses(pids);
            if (maxuses == SHI_USES_UNLIMITED)
            {
                hr = STRRETLoadString(IDS_UNLIMITED, &lpDetails->str);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            else
            {
                TCHAR szTemp[MAX_PATH];
                StringCchPrintf(szTemp, ARRAYLEN(szTemp), TEXT("%d"), maxuses);
                hr = STRRETCopy(szTemp, &lpDetails->str);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            break;
        }

        }
    }

    return NOERROR;
}

STDMETHODIMP
CSharesSD::ColumnClick(
    UINT iColumn
    )
{
    ShellFolderView_ReArrange(m_hwnd, iColumn);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\permpage.cxx ===
// PermPage.cxx : Implementation ACL Editor classes
// jonn 7/14/97 copied from \nt\private\windows\shell\lmui\ntshrui\permpage.cpp

#include "headers.hxx"
#pragma hdrstop

#include "acl.hxx"
#include "resource.h" // IDS_SHAREPERM_*

// definition in headers.hxx conflicts with stddef.h (atlbase.h)
#undef offsetof

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

// need IID_ISecurityInformation
#define INITGUID
#include <initguid.h>
#include <aclui.h>

//
// I define my own implementation of ISecurityInformation
//

class CSecurityInformation : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo ) = 0;
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) = 0;
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags,
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess );
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask);
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes );
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

protected:
	HRESULT NewDefaultDescriptor(
		PSECURITY_DESCRIPTOR* ppsd,
		SECURITY_INFORMATION RequestedInformation
		);

	HRESULT MakeSelfRelativeCopy(
		PSECURITY_DESCRIPTOR  psdOriginal,
		PSECURITY_DESCRIPTOR* ppsdNew );
};

class CShareSecurityInformation : public CSecurityInformation
{
private:
	LPWSTR m_strMachineName;
	LPWSTR m_strShareName;
public:
	void SetMachineName( LPWSTR pszMachineName )
	{
		m_strMachineName = pszMachineName;
	}
	void SetShareName( LPWSTR pszShareName )
	{
		m_strShareName = pszShareName;
	}
	// note: these should be LPCTSTR but are left this way for convenience
	LPWSTR QueryMachineName()
	{
		return m_strMachineName;
	}
	LPWSTR QueryShareName()
	{
		return m_strShareName;
	}

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
};

class CSMBSecurityInformation : public CShareSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
public:
	PSECURITY_DESCRIPTOR m_pInitialDescriptor;
	PSECURITY_DESCRIPTOR* m_ppCurrentDescriptor;
	CSMBSecurityInformation();
	~CSMBSecurityInformation();
};



// ISecurityInformation interface implementation

SI_ACCESS siShareAccesses[] =
{
    { &GUID_NULL, FILE_ALL_ACCESS,             MAKEINTRESOURCE(IDS_SHAREPERM_ALL),    SI_ACCESS_GENERAL },
    { &GUID_NULL, FILE_GENERIC_WRITE | DELETE, MAKEINTRESOURCE(IDS_SHAREPERM_MODIFY), SI_ACCESS_GENERAL },
    { &GUID_NULL, FILE_GENERIC_READ,           MAKEINTRESOURCE(IDS_SHAREPERM_READ),   SI_ACCESS_GENERAL }
};
#define iShareDefAccess      2   // FILE_GEN_READ
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

STDMETHODIMP CSecurityInformation::GetAccessRights (
                            const GUID* pguidObjectType,
                            DWORD dwFlags,
                            PSI_ACCESS *ppAccess,
                            ULONG *pcAccesses,
                            ULONG *piDefaultAccess )
{
    appAssert(ppAccess != NULL);
    appAssert(pcAccesses != NULL);
    appAssert(piDefaultAccess != NULL);

    *ppAccess = siShareAccesses;
    *pcAccesses = ARRAYSIZE(siShareAccesses);
    *piDefaultAccess = iShareDefAccess;

    return S_OK;
}

// This is consistent with the NETUI code
GENERIC_MAPPING ShareMap =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

STDMETHODIMP CSecurityInformation::MapGeneric (
                       const GUID *pguidObjectType,
                       UCHAR *pAceFlags,
                       ACCESS_MASK *pMask)
{
    appAssert(pMask != NULL);

    MapGenericMask(pMask, &ShareMap);

    return S_OK;
}

STDMETHODIMP CSecurityInformation::GetInheritTypes (
                            PSI_INHERIT_TYPE *ppInheritTypes,
                            ULONG *pcInheritTypes )
{
    appAssert(FALSE);
    return E_NOTIMPL;
}
STDMETHODIMP CSecurityInformation::PropertySheetPageCallback(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage )
{
    return S_OK;
}

/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP CShareSecurityInformation::GetObjectInformation (
    PSI_OBJECT_INFO pObjectInfo )
{
    appAssert(pObjectInfo != NULL &&
           !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

    pObjectInfo->dwFlags = SI_EDIT_ALL | SI_NO_ACL_PROTECT;
    pObjectInfo->hInstance = g_hInstance;
    pObjectInfo->pszServerName = QueryMachineName();
    pObjectInfo->pszObjectName = QueryShareName();

    return S_OK;
}

//
// original code from \\marsslm\backup\src\ncpmgr\ncpmgr\shareacl.cxx
// ACL-wrangling templated from \net\ui\common\src\lmobj\lmobj\security.cxx
//
// caller must free using LocalFree()
//
HRESULT CSecurityInformation::NewDefaultDescriptor(
	PSECURITY_DESCRIPTOR* ppsd,
	SECURITY_INFORMATION RequestedInformation
	)
{
	*ppsd = NULL;
	PSID psidWorld = NULL;
	PSID psidAdmins = NULL;
	ACCESS_ALLOWED_ACE* pace = NULL;
	ACL* pacl = NULL;
	SECURITY_DESCRIPTOR sd;
	HRESULT hr = S_OK;
	do { // false loop
		// build World SID
		SID_IDENTIFIER_AUTHORITY IDAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;
		if ( !::AllocateAndInitializeSid(
			&IDAuthorityWorld,
			1,
			SECURITY_WORLD_RID,
			0,0,0,0,0,0,0,
			&psidWorld ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

		// build Admins SID
		SID_IDENTIFIER_AUTHORITY IDAuthorityNT = SECURITY_NT_AUTHORITY;
		if ( !::AllocateAndInitializeSid(
			&IDAuthorityNT,
			2,
			SECURITY_BUILTIN_DOMAIN_RID,
			DOMAIN_ALIAS_RID_ADMINS,
			0,0,0,0,0,0,
			&psidAdmins ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

		// build ACE
		DWORD cbSid = ::GetLengthSid(psidWorld);
		if ( 0 == cbSid )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}
		INT cbAce = sizeof(ACCESS_ALLOWED_ACE) + cbSid;
		pace = reinterpret_cast<ACCESS_ALLOWED_ACE*>(new BYTE[ cbAce+10 ]);
		if ( NULL == pace )
		{
			appAssert( FALSE );
			hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			break;
		}
		::memset((BYTE*)pace,0,cbAce+10);
		pace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;   // SetType()
		pace->Header.AceFlags = 0;                        // SetInheritFlags()
		pace->Header.AceSize = (WORD)cbAce;               // SetSize() (in SetSID())
		pace->Mask = GENERIC_ALL;                         // SetAccessMask()
		::memcpy( &(pace->SidStart), psidWorld, cbSid );  // SetSID()

		// build ACL
		DWORD cbAcl = sizeof(ACL) + cbAce + 10;
		pacl = reinterpret_cast<ACL*>(new BYTE[ cbAcl ]);
		if ( NULL == pacl )
		{
			appAssert( FALSE );
			hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			break;
		}
		::memset((BYTE*)pacl,0,cbAcl);
		if ( !::InitializeAcl( pacl, cbAcl, ACL_REVISION2 ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}
		if ( !::AddAce( pacl, ACL_REVISION2, 0, pace, cbAce ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

		// build security descriptor in absolute format
		if ( !::InitializeSecurityDescriptor(
			&sd,
			SECURITY_DESCRIPTOR_REVISION ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}
		if (   !::SetSecurityDescriptorOwner( &sd, psidAdmins, FALSE )
			|| !::SetSecurityDescriptorGroup( &sd, psidAdmins, FALSE )
			|| !::SetSecurityDescriptorDacl(  &sd, TRUE, pacl, FALSE )
		   )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

		// convert security descriptor to self-relative format
		DWORD cbSD = 0;
		// this call should fail and set cbSD to the correct size
		if ( ::MakeSelfRelativeSD( &sd, NULL, &cbSD ) || 0 == cbSD )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}
		*ppsd = reinterpret_cast<PSECURITY_DESCRIPTOR>(
			::LocalAlloc( LMEM_ZEROINIT, cbSD + 20 ) );

        if (!*ppsd)
        {
			hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			break;
		}
        ::memset( (BYTE*)*ppsd, 0, cbSD + 20 );
		if ( !::MakeSelfRelativeSD( &sd, *ppsd, &cbSD ) )
		{
			appAssert( FALSE );
			hr = E_UNEXPECTED;
			break;
		}

	} while (FALSE); // false loop

	// clean up
	if ( NULL != psidWorld ) {
		(void)::FreeSid( psidWorld );
	}
	if ( NULL != psidAdmins ) {
		(void)::FreeSid( psidAdmins );
	}
	delete pace;
	delete pacl;

	return hr;
}

HRESULT CSecurityInformation::MakeSelfRelativeCopy(
	PSECURITY_DESCRIPTOR  psdOriginal,
	PSECURITY_DESCRIPTOR* ppsdNew )
{
	appAssert( NULL != psdOriginal );

	// we have to find out whether the original is already self-relative
	SECURITY_DESCRIPTOR_CONTROL sdc = 0;
	DWORD dwRevision = 0;
	if ( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) )
	{
		appAssert( FALSE );
		DWORD err = ::GetLastError();
		return HRESULT_FROM_WIN32( err );
	}

	DWORD cb = ::GetSecurityDescriptorLength( psdOriginal ) + 20;
	PSECURITY_DESCRIPTOR psdSelfRelativeCopy = reinterpret_cast<PSECURITY_DESCRIPTOR>(
		::LocalAlloc(LMEM_ZEROINIT, cb) );
	if (NULL == psdSelfRelativeCopy)
	{
		return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}

	if ( sdc & SE_SELF_RELATIVE )
	// the original is in self-relative format, just byte-copy it
	{
		::memcpy( psdSelfRelativeCopy, psdOriginal, cb - 20 );
	}
	else if ( !::MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) )
	// the original is in absolute format, convert-copy it
	{
		appAssert( FALSE );
		if( NULL != ::LocalFree( psdSelfRelativeCopy ) )
		{
			appAssert(FALSE);
		}
		DWORD err = ::GetLastError();
		return HRESULT_FROM_WIN32( err );
	}
	*ppsdNew = psdSelfRelativeCopy;
	return S_OK;
}

CSMBSecurityInformation::CSMBSecurityInformation()
: CShareSecurityInformation()
, m_pInitialDescriptor( NULL )
, m_ppCurrentDescriptor( NULL )
{
}

CSMBSecurityInformation::~CSMBSecurityInformation()
{
}

STDMETHODIMP CSMBSecurityInformation::GetSecurity (
                        SECURITY_INFORMATION RequestedInformation,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL fDefault )
{
	appAssert( NULL != m_ppCurrentDescriptor );

	// NOTE: we allow NULL == ppSecurityDescriptor, see SetSecurity
    if (0 == RequestedInformation )
    {
        appAssert(FALSE);
        return E_INVALIDARG;
    }

    if (fDefault)
        return E_NOTIMPL;

	if ( NULL == ppSecurityDescriptor )
		return S_OK;

	*ppSecurityDescriptor = NULL;

	HRESULT hr = S_OK;
	if (NULL != *m_ppCurrentDescriptor)
	{
		hr = MakeSelfRelativeCopy(
			*m_ppCurrentDescriptor,
			ppSecurityDescriptor );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	else if (NULL != m_pInitialDescriptor)
	{
		hr = MakeSelfRelativeCopy(
			m_pInitialDescriptor,
			ppSecurityDescriptor );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	else
	{
		hr = NewDefaultDescriptor(
			ppSecurityDescriptor,
			RequestedInformation );
		appAssert( SUCCEEDED(hr) && NULL != *ppSecurityDescriptor );
	}
	return hr;
}

STDMETHODIMP CSMBSecurityInformation::SetSecurity (
                        SECURITY_INFORMATION SecurityInformation,
                        PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
	appAssert( NULL != m_ppCurrentDescriptor );

	if (NULL != *m_ppCurrentDescriptor)
	{
		::LocalFree(*m_ppCurrentDescriptor);
		*m_ppCurrentDescriptor = NULL;
	}
	HRESULT hr = MakeSelfRelativeCopy(
		pSecurityDescriptor,
		m_ppCurrentDescriptor );
	appAssert( SUCCEEDED(hr) && NULL != *m_ppCurrentDescriptor );
	return hr;
}

HMODULE g_hlibACLUI = NULL;
typedef BOOL (*EDIT_SECURITY_PROC) ( HWND, LPSECURITYINFO );
EDIT_SECURITY_PROC g_pfnEditSecurityProc;

LONG
EditShareAcl(
    IN HWND                      hwndParent,
    IN LPWSTR                    pszServerName,
    IN TCHAR *                   pszShareName,
    IN PSECURITY_DESCRIPTOR      pSecDesc,
    OUT BOOL*                    pfSecDescModified,
    OUT PSECURITY_DESCRIPTOR*    ppSecDesc
	)
{
	appAssert( ppSecDesc != NULL );
	*ppSecDesc = NULL;

	if (NULL == g_hlibACLUI)
	{
		g_hlibACLUI = ::LoadLibrary(L"ACLUI.DLL");
		if (NULL == g_hlibACLUI)
		{
			appAssert(FALSE); // ACLUI.DLL isn't installed?
			return 0;
		}
	}

	if (NULL == g_pfnEditSecurityProc)
	{
		g_pfnEditSecurityProc = reinterpret_cast<EDIT_SECURITY_PROC>(
			::GetProcAddress(g_hlibACLUI,"EditSecurity") );
		if (NULL == g_pfnEditSecurityProc)
		{
			appAssert(FALSE); // ACLUI.DLL is invalid?
			return 0;
		}
	}

	CComObject<CSMBSecurityInformation>* psecinfo = NULL;
	HRESULT hRes = CComObject<CSMBSecurityInformation>::CreateInstance(&psecinfo);
	if ( FAILED(hRes) )
		return 0;

	psecinfo->AddRef();
	psecinfo->SetMachineName( pszServerName );
	psecinfo->SetShareName( pszShareName );
	psecinfo->m_pInitialDescriptor = pSecDesc;
	psecinfo->m_ppCurrentDescriptor = ppSecDesc;
	(g_pfnEditSecurityProc)(hwndParent,psecinfo);

	if (NULL != pfSecDescModified)
		*pfSecDescModified = (NULL != *ppSecDesc);

	psecinfo->Release();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\shares.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       shares.h
//
//  Contents:   Definition of the shell IDLIST type for Shares
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#ifndef __SHARES_H__
#define __SHARES_H__

struct IDSHARE
{
    USHORT  cb;
    BYTE    bFlags;
    BYTE    bReserved;          // for alignment
    DWORD   type;               // shiX_type field
    DWORD   maxUses;            // only valid for SHID_SHARE_2
    USHORT  oPath;              // only valid for SHID_SHARE_2: cBuf[oPath] is start of path
    USHORT  oComment;           // cBuf[oComment] is start of comment
    TCHAR   cBuf[MAX_PATH*3];   // cBuf[0] is the start of name
};
typedef IDSHARE* LPIDSHARE;

#define SHID_SHARE_1    0x50    // Net share info level 1
#define SHID_SHARE_2    0x51    // Net share info level 2
#ifdef WIZARDS
#define SHID_SHARE_ALL  0x5c    // "all" shares wizard
#define SHID_SHARE_NW   0x5d    // NetWare shares wizard
#define SHID_SHARE_MAC  0x5e    // Mac shares wizard
#define SHID_SHARE_NEW  0x5f    // New Share wizard
#endif // WIZARDS

#define Share_GetFlags(pidl)        (pidl->bFlags)
#define Share_GetName(pidl)         (pidl->cBuf)
#define Share_GetComment(pidl)      (&(pidl->cBuf[pidl->oComment]))
#define Share_GetPath(pidl)         (&(pidl->cBuf[pidl->oPath]))
#define Share_GetType(pidl)         (pidl->type)
#define Share_GetMaxUses(pidl)      (pidl->maxUses)

#ifdef WIZARDS
#define Share_IsAllWizard(pidl)         (pidl->bFlags == SHID_SHARE_ALL)
#define Share_IsNetWareWizard(pidl)     (pidl->bFlags == SHID_SHARE_NW)
#define Share_IsMacWizard(pidl)         (pidl->bFlags == SHID_SHARE_MAC)
#define Share_IsNewShareWizard(pidl)    (pidl->bFlags == SHID_SHARE_NEW)
#define Share_IsSpecial(pidl)           (Share_IsNetWareWizard(pidl) || Share_IsMacWizard(pidl) || Share_IsNewShareWizard(pidl))
#endif // WIZARDS

#define Share_IsShare(pidl)         (pidl->bFlags == SHID_SHARE_1 || pidl->bFlags == SHID_SHARE_2)
#define Share_GetLevel(pidl)        (appAssert(Share_IsShare(pidl)), pidl->bFlags - SHID_SHARE_1 + 1)

#define Share_GetNameOffset(pidl)    offsetof(IDSHARE, cBuf)
#define Share_GetCommentOffset(pidl) (offsetof(IDSHARE, cBuf) + pidl->oComment * sizeof(TCHAR))
#define Share_GetPathOffset(pidl)    (offsetof(IDSHARE, cBuf) + pidl->oPath * sizeof(TCHAR))

#endif // __SHARES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\shrpage.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       shrpage.cxx
//
//  Contents:   "Sharing" shell property page extension
//
//  History:    6-Apr-95        BruceFo     Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "dlgnew.hxx"
#include "acl.hxx"
#include "shrinfo.hxx"
#include "shrpage.hxx"
#include "util.hxx"

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::DlgProcPage, static public
//
//  Synopsis:   Dialog Procedure for all CSharingPropertyPage
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CSharingPropertyPage::DlgProcPage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CSharingPropertyPage* pThis = NULL;

    if (msg==WM_INITDIALOG)
    {
        SHARE_PROPSHEETPAGE* sprop = (SHARE_PROPSHEETPAGE*)lParam;
        pThis = new CSharingPropertyPage(hwnd, sprop->pszMachine, sprop->pszShareName);
        if (NULL != pThis)
        {
            if (FAILED(pThis->InitInstance()))
            {
                delete pThis;
                pThis = NULL;
            }
        }

        SetWindowLongPtr(hwnd,GWLP_USERDATA,(LPARAM)pThis);
    }
    else
    {
        pThis = (CSharingPropertyPage*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
    }

    if (pThis != NULL)
    {
        return pThis->_PageProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CSharingPropertyPage::SizeWndProc, public
//
//  Synopsis:   "allow" edit window subclass proc to disallow non-numeric
//              characters.
//
//  History:    5-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
CSharingPropertyPage::SizeWndProc(
    IN HWND hwnd,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (wMsg)
    {
    case WM_CHAR:
    {
        WCHAR chCharCode = (WCHAR)wParam;
        if (   (chCharCode == TEXT('\t'))
            || (chCharCode == TEXT('\b'))
            || (chCharCode == TEXT('\n'))
//          || (chCharCode == TEXT('\x1b')) // ESCAPE key
            )
        {
            break;
        }

        if (chCharCode < TEXT('0') || chCharCode > TEXT('9'))
        {
            // bad key: ignore it
            MessageBeep(0xffffffff);    // let user know it's an illegal char
            return FALSE;
        }

        break;
    }
    } // end of switch

    CSharingPropertyPage* pThis = (CSharingPropertyPage*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
    appAssert(NULL != pThis);
    appAssert(NULL != pThis->_pfnAllowProc);
    return CallWindowProc(pThis->_pfnAllowProc, hwnd, wMsg, wParam, lParam);
}


//+--------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::CSharingPropertyPage, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CSharingPropertyPage::CSharingPropertyPage(
    IN HWND hwndPage,
    IN PWSTR pszMachine,
    IN PWSTR pszShare
    )
    :
    _hwndPage(hwndPage),
    _pszMachine(pszMachine),
    _pszShare(pszShare),
    _bDirty(FALSE),
    _bShareNameChanged(FALSE),
    _bPathChanged(FALSE),
    _bCommentChanged(FALSE),
    _bUserLimitChanged(FALSE),
    _bSecDescChanged(FALSE),
    _wMaxUsers(DEFAULT_MAX_USERS),
    _pCurInfo(NULL),
    _pszReplacePath(NULL),
    _pfnAllowProc(NULL)
{
    INIT_SIG(CSharingPropertyPage);
    appAssert(NULL != _pszShare);
}


//+--------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::~CSharingPropertyPage, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CSharingPropertyPage::~CSharingPropertyPage()
{
    CHECK_SIG(CSharingPropertyPage);

    delete _pCurInfo;
    _pCurInfo = NULL;

    delete[] _pszReplacePath;
    _pszReplacePath = NULL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::InitInstance, public
//
//  Synopsis:   Part II of the constuctor process
//
//  Notes:      We don't want to handle any errors in constuctor, so this
//              method is necessary for the second phase error detection.
//
//--------------------------------------------------------------------------

HRESULT
CSharingPropertyPage::InitInstance(
    VOID
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appDebugOut((DEB_ITRACE, "CSharingPropertyPage::InitInstance\n"));

    SHARE_INFO_502* info502;
    NET_API_STATUS ret = NetShareGetInfo(_pszMachine, _pszShare, 502, (LPBYTE*)&info502);
    if (ret == NERR_Success)
    {
        _pCurInfo = new CShareInfo(info502);
        if (NULL == _pCurInfo)
        {
            return E_OUTOFMEMORY;
        }

        if (!_pCurInfo->TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        NetApiBufferFree(info502);
    }
    else
    {
        appDebugOut((DEB_ERROR, "Couldn't get info\n"));
        return HRESULT_FROM_WIN32(ret);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

INT_PTR
CSharingPropertyPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CSharingPropertyPage);

    static DWORD aHelpIds[] =
    {
        IDC_SHARE_SHARENAME,        HC_SHARE_SHARENAME,
        IDC_SHARE_PATH,             HC_SHARE_PATH,
        IDC_SHARE_COMMENT,          HC_SHARE_COMMENT,
        IDC_SHARE_MAXIMUM,          HC_SHARE_MAXIMUM,
        IDC_SHARE_ALLOW,            HC_SHARE_ALLOW,
        IDC_SHARE_ALLOW_VALUE,      HC_SHARE_ALLOW_VALUE,
        IDC_SHARE_PERMISSIONS,      HC_SHARE_PERMISSIONS,

        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(hwnd, (HWND)wParam, lParam);

    case WM_COMMAND:
        return _OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_NOTIFY:
        return _OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);

    case WM_VSCROLL:
        // The up/down control changed the edit control: select it again
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        return TRUE;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD_PTR)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD_PTR)aHelpIds);
        break;
    }

    case WM_CLOSE:
        // BUGBUG: There is a bug where hitting "ESCAPE" with the focus on the
        // MLE for the "allow" text doesn't kill the property sheet unless we
        // forward the WM_CLOSE message on to the property sheet root dialog.
        return SendMessage(GetParent(hwnd), msg, wParam, lParam);

    case WM_DESTROY:
        // restore original subclass to window.
        appAssert(NULL != GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE));
        SetWindowLongPtr(GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE), GWLP_WNDPROC, (LONG_PTR)_pfnAllowProc);
        break;

    case WM_NCDESTROY:
        return _OnNcDestroy(hwnd);

    } // end switch (msg)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lInitParam
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    SetDialogIconBig(_GetFrameWindow(), IDI_SHARESFLD);

    // Subclass allow edit control to disallow non-positive numbers
    _pfnAllowProc = (WNDPROC)SetWindowLongPtr(
                                    GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE),
                                    GWLP_WNDPROC,
                                    (LONG_PTR)&SizeWndProc);

    // use LanMan API constants to set maximum share name & comment lengths
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_PATH,      EM_LIMITTEXT, MAX_PATH-1, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_COMMENT,   EM_LIMITTEXT, MAXCOMMENTSZ, 0L);

    _InitializeControls(hwnd);

// #if DBG == 1
//  Dump(L"_OnInitDialog finished");
// #endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CSharingPropertyPage);

    switch (wID)
    {

//
// Notifications
//

    case IDC_SHARE_SHARENAME:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bShareNameChanged = TRUE;
                _MarkItemDirty();
            }
        }
        return TRUE;
    }

    case IDC_SHARE_PATH:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bPathChanged = TRUE;
                _MarkItemDirty();
            }
        }
        return TRUE;
    }

    case IDC_SHARE_COMMENT:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bCommentChanged = TRUE;
                _MarkItemDirty();
            }
        }
        return TRUE;
    }

    case IDC_SHARE_MAXIMUM:
        if (BN_CLICKED == wNotifyCode)
        {
            // Take away WS_TABSTOP from the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) & ~WS_TABSTOP);

            _CacheMaxUses(hwnd);
            SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

    case IDC_SHARE_ALLOW:
        if (BN_CLICKED == wNotifyCode)
        {
            // Give WS_TABSTOP to the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) | WS_TABSTOP);

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

    case IDC_SHARE_ALLOW_VALUE:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }

        if (EN_SETFOCUS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }

        if (EN_KILLFOCUS == wNotifyCode)
        {
            _CacheMaxUses(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_ALLOW_SPIN:
        if (UDN_DELTAPOS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

//
// Commands
//

    case IDC_SHARE_PERMISSIONS:
        return _OnPermissions(hwnd);

    default:
        break;
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnNotify(
    IN HWND hwnd,
    IN int idCtrl,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CSharingPropertyPage);

    // assume a property sheet notification
    return _OnPropertySheetNotify(hwnd, phdr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnPropertySheetNotify, private
//
//  Synopsis:   WM_NOTIFY handler for the property sheet notification
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnPropertySheetNotify(
    IN HWND hwnd,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CSharingPropertyPage);

    switch (phdr->code)
    {
    case PSN_RESET:         // cancel
        if (_DoCancel(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE); // go away
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
        }
        return TRUE;

    case PSN_KILLACTIVE:    // change to another page
        if (_ValidatePage(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            return FALSE;
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }

    case PSN_APPLY:
        if (_DoApply(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE); // go away
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
        }
        return TRUE;

    } // end switch (phdr->code)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnNcDestroy, private
//
//  Synopsis:   WM_NCDESTROY handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnNcDestroy(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    delete this;    // do this LAST!
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnPermissions, private
//
//  Synopsis:   WM_COMMAND handler: the permissions button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnPermissions(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(NULL != _pCurInfo);

    if (STYPE_SPECIAL & _pCurInfo->GetType())
    {
        MyErrorDialog(hwnd, IERR_AdminShare);
        return TRUE;
    }

    WCHAR szShareName[NNLEN + 1];
    GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
    // don't trim spaces, this might be an existing share with spaces in its name

    PSECURITY_DESCRIPTOR pNewSecDesc = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = _pCurInfo->GetSecurityDescriptor();
    appAssert(NULL == pSecDesc || IsValidSecurityDescriptor(pSecDesc));

    BOOL bSecDescChanged;
    LONG err = EditShareAcl(
                        hwnd,
                        _pszMachine,
                        szShareName,
                        pSecDesc,
                        &bSecDescChanged,
                        &pNewSecDesc);

    if (bSecDescChanged)
    {
        _bSecDescChanged = TRUE;

        appAssert(IsValidSecurityDescriptor(pNewSecDesc));
        _pCurInfo->TransferSecurityDescriptor(pNewSecDesc);
        _MarkItemDirty();
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_InitializeControls, private
//
//  Synopsis:   Initialize the controls from scratch
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_InitializeControls(
    IN HWND hwnd
    )
{
    _SetControlsToDefaults(hwnd);
    _SetControlsFromData(hwnd);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_SetControlsToDefaults, private
//
//  Synopsis:   Set all the controls on the page to their default values
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetControlsToDefaults(
    IN HWND hwnd
    )
{
    _fInitializingPage = TRUE;

    // Make "Maximum" the default number of users, and clear the value field
    // (which the spin button set on creation?).

    CheckRadioButton(
            hwnd,
            IDC_SHARE_MAXIMUM,
            IDC_SHARE_ALLOW,
            IDC_SHARE_MAXIMUM);

    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    // set the spin control range: 1 <--> large number
    SendDlgItemMessage(
            hwnd,
            IDC_SHARE_ALLOW_SPIN,
            UDM_SETRANGE,
            0,
            MAKELONG(g_uiMaxUsers, 1));

    SetDlgItemText(hwnd, IDC_SHARE_SHARENAME,   L"");
    SetDlgItemText(hwnd, IDC_SHARE_PATH,        L"");
    SetDlgItemText(hwnd, IDC_SHARE_COMMENT,     L"");
    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    _fInitializingPage = FALSE;
}



//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::SetControlsFromData, private
//
//  Synopsis:   From the class variables and current state of the radio
//              buttons, set the enabled/disabled state of the buttons, as
//              well as filling the controls with the appropriate values.
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetControlsFromData(
    IN HWND hwnd
    )
{
    appAssert(NULL != _pCurInfo);

    _fInitializingPage = TRUE;

    SetDlgItemText(hwnd, IDC_SHARE_SHARENAME, _pCurInfo->GetNetname());
    SetDlgItemText(hwnd, IDC_SHARE_PATH,      _pCurInfo->GetPath());
    SetDlgItemText(hwnd, IDC_SHARE_COMMENT,   _pCurInfo->GetRemark());

    DWORD dwLimit = _pCurInfo->GetMaxUses();
    if (dwLimit == SHI_USES_UNLIMITED)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        appDebugOut((DEB_ITRACE, "_SetControlsFromData: unlimited users\n"));

        CheckRadioButton(
                hwnd,
                IDC_SHARE_MAXIMUM,
                IDC_SHARE_ALLOW,
                IDC_SHARE_MAXIMUM);

        SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");
    }
    else
    {
        _wMaxUsers = (WORD)dwLimit;

        appDebugOut((DEB_ITRACE,
            "_SetControlsFromData: max users = %d\n",
            _wMaxUsers));

        CheckRadioButton(
                hwnd,
                IDC_SHARE_MAXIMUM,
                IDC_SHARE_ALLOW,
                IDC_SHARE_ALLOW);

        // let the spin control set the edit control
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));

        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }

    // Managine a special share?
    if (_pCurInfo->GetType() & STYPE_SPECIAL)
    {
        // Can't change the path or the name
        // Making it read-only makes it easier to read than if it were disabled
        SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_SETREADONLY, (WPARAM)(BOOL)TRUE, 0);
        SendDlgItemMessage(hwnd, IDC_SHARE_PATH,      EM_SETREADONLY, (WPARAM)(BOOL)TRUE, 0);
    }

    _fInitializingPage = FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_MarkItemDirty, private
//
//  Synopsis:   A change has made such that the current item (and page)
//              is now dirty
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_MarkItemDirty(
    VOID
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (!_fInitializingPage)
    {
        if (!_bDirty)
        {
            appDebugOut((DEB_ITRACE, "Marking Sharing page dirty\n"));
            _bDirty = TRUE;
            PropSheet_Changed(_GetFrameWindow(),_hwndPage);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_ValidatePage, private
//
//  Synopsis:   Return TRUE if the current page is valid
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_ValidatePage(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(NULL != _pCurInfo);

    if (!_bDirty)
    {
        // nothing to validate
        return TRUE;
    }

    if (!_bShareNameChanged)
    {
        appDebugOut((DEB_ITRACE, "_ValidatePage: share name not changed!\n"));

        return TRUE;
    }

    delete[] _pszReplacePath;
    _pszReplacePath = NULL;

    WCHAR szShareName[MAX_PATH];
    GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
    TrimLeadingAndTrailingSpaces(szShareName);

    WCHAR szPath[MAX_PATH];
    GetDlgItemText(hwnd, IDC_SHARE_PATH, szPath, ARRAYLEN(szPath));

    // Validate the share

    if (0 == wcslen(szShareName))
    {
        MyErrorDialog(hwnd, IERR_BlankShareName);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return FALSE;
    }

    HRESULT uTemp;
    if (!IsValidShareName(szShareName, &uTemp))
    {
        MyErrorDialog(hwnd, uTemp);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return FALSE;
    }

    // Trying to create a reserved share?
    if (   (0 == _wcsicmp(g_szIpcShare,   szShareName))
        || (0 == _wcsicmp(g_szAdminShare, szShareName)))
    {
        MyErrorDialog(hwnd, IERR_SpecialShare);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return FALSE;
    }

    // If the user entered some ACL, warn them that we're going to nuke
    // it and let the system use its default (since special shares can't
    // have their security set).
    if (DriveLetterShare(szShareName))
    {
        if (_bSecDescChanged)
        {
            DWORD id = MyConfirmationDialog(
                            hwnd,
                            MSG_NOSECURITYONSPECIAL,
                            MB_YESNO | MB_ICONEXCLAMATION);
            if (id == IDNO)
            {
                SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
                return FALSE;
            }
            _pCurInfo->TransferSecurityDescriptor(NULL);
        }
    }

    // Check for downlevel accessibility
    // CODEWORK we should really get rid of this at some point -- JonN 7/18/97
    ULONG nType;
    if (NERR_Success != NetpPathType(NULL, szShareName, &nType, INPT_FLAGS_OLDPATHS))
    {
        DWORD id = MyConfirmationDialog(
                        hwnd,
                        IERR_InaccessibleByDos,
                        MB_YESNO | MB_ICONEXCLAMATION,
                        szShareName);
        if (id == IDNO)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }
    }

    // Check to see that the same share isn't already used, for either the
    // same path or for another path.

    SHARE_INFO_502* info502;
    NET_API_STATUS ret = NetShareGetInfo(_pszMachine, szShareName, 502, (LPBYTE*)&info502);
    if (ret == NERR_Success)
    {
        // It is already shared. Same path?

        if (0 == _wcsicmp(info502->shi502_path, szPath))
        {
            MyErrorDialog(hwnd, IERR_AlreadyExists, szShareName);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info502);
            return FALSE;
        }

        // Shared for a different path. Ask the user if they wish to delete
        // the old share and create the new one using the name.

        DWORD id = ConfirmReplaceShare(hwnd, szShareName, info502->shi502_path, szPath);
        if (id == IDNO)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info502);
            return FALSE;
        }
        else if (id == IDCANCEL)
        {
            // EndDialog(hwnd, FALSE);  // BUGBUG: nuke page
            NetApiBufferFree(info502);
            return TRUE;
        }
        else
        {
            _pszReplacePath = NewDup(info502->shi502_path);
            if (NULL == _pszReplacePath)
            {
                NetApiBufferFree(info502);
                MyErrorDialog(hwnd, E_OUTOFMEMORY);
                return FALSE;
            }
        }

        NetApiBufferFree(info502);
    }
    else
    {
        // NetShareGetInfo failed. This is probably because there
        // is no share by this name, in which case it is a pure rename.

        appDebugOut((DEB_TRACE,
            "NetShareGetInfo failed, 0x%08lx\n",
            ret));
    }

#if DBG == 1
    Dump(L"_ValidatePage finished");
#endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_DoApply, public
//
//  Synopsis:   If anything has changed, apply the data
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_DoApply(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (_bDirty)
    {
        appAssert(NULL != _pCurInfo);

        NET_API_STATUS ret;
        HRESULT hr;

        // If either the share name changed or the path changed, we need
        // to delete the old share. If the share name changed, it is
        // because the user is renaming the share. If the path changed,
        // it is because the LanMan APIs don't allow a NetShareSetInfo
        // to change the shared path.

        if (_bShareNameChanged)
        {
            // The share name was changed. This is either a pure rename, in
            // which case the old share should be deleted and a share with
            // the new name created, or the user changed the share name to
            // the name of an already existing share, in which case both the
            // current share name as well as the share to be replaced must be
            // deleted.

            if (NULL != _pszReplacePath)
            {
                // user said to replace an existing share
        		WCHAR szShareName[NNLEN + 1];
                GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
                TrimLeadingAndTrailingSpaces(szShareName);

                ret = NetShareDel(_pszMachine, szShareName, 0);
                if (ret != NERR_Success)
                {
                    DisplayError(hwnd, IERR_CANT_DEL_SHARE, ret, szShareName);
                    delete[] _pszReplacePath;
                    _pszReplacePath = NULL;
                    return FALSE;
                }
                else
                {
                    SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, _pszReplacePath, NULL);
                }

                delete[] _pszReplacePath;
                _pszReplacePath = NULL;
            }
        }

        if (_bShareNameChanged || _bPathChanged)
        {
            // delete the existing share
            ret = NetShareDel(_pszMachine, _pCurInfo->GetNetname(), 0);
            if (ret != NERR_Success)
            {
                DisplayError(hwnd, IERR_CANT_DEL_SHARE, ret, _pCurInfo->GetNetname());
                return FALSE;
            }
            else
            {
                // Only if the path changed in the rename should the shell
                // be notified
                if (_bPathChanged)
                {
                    SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, _pCurInfo->GetPath(), NULL);
                }
            }
        }

        if (_bShareNameChanged)
        {
            // User wants to rename the share.
        	WCHAR szShareName[NNLEN + 1];
            _pCurInfo->SetDirtyFlag(SHARE_FLAG_ADDED);   // special case
            GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
            TrimLeadingAndTrailingSpaces(szShareName);
            _pCurInfo->SetNetname(szShareName);
        }

        if (_bPathChanged)
        {
			WCHAR szPath[MAX_PATH];
            _pCurInfo->SetDirtyFlag(SHARE_FLAG_ADDED);   // special case
            GetDlgItemText(hwnd, IDC_SHARE_PATH, szPath, ARRAYLEN(szPath));
            _pCurInfo->SetPath(szPath);
        }

        if (_bCommentChanged)
        {
        	WCHAR szComment[MAXCOMMENTSZ + 1];
            GetDlgItemText(hwnd, IDC_SHARE_COMMENT, szComment, ARRAYLEN(szComment));
            _pCurInfo->SetRemark(szComment);
        }

        if (_bUserLimitChanged)
        {
            if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_MAXIMUM))
            {
                _pCurInfo->SetMaxUses(SHI_USES_UNLIMITED);
            }
            else if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                _CacheMaxUses(hwnd);
                _pCurInfo->SetMaxUses(_wMaxUsers);
            }
        }

        //
        // Commit the changes!
        //

        ret = _pCurInfo->Commit(_pszMachine);
        if (ret != NERR_Success)
        {
            HRESULT hrMsg = 0;
            switch (_pCurInfo->GetFlag())
            {
            case SHARE_FLAG_ADDED:  hrMsg = IERR_CANT_ADD_SHARE;    break;
            case SHARE_FLAG_MODIFY: hrMsg = IERR_CANT_MODIFY_SHARE; break;
            default:
                appAssert(!"Illegal flag for a failed commit!");
            }
            DisplayError(hwnd, hrMsg, ret, _pCurInfo->GetNetname());
        }
        else
        {
            _pCurInfo->SetDirtyFlag(0);  // clear flag on success
        }

        _bDirty = FALSE;
        _bShareNameChanged = FALSE;
        _bPathChanged = FALSE;
        _bCommentChanged = FALSE;
        _bUserLimitChanged = FALSE;
        _bSecDescChanged = FALSE;
        PropSheet_UnChanged(_GetFrameWindow(),_hwndPage);

        SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, _pCurInfo->GetPath(), NULL);

        _InitializeControls(hwnd);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_DoCancel, public
//
//  Synopsis:   Do whatever is necessary to cancel the changes
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_DoCancel(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (_bDirty)
    {
        _bDirty = FALSE;
        _bShareNameChanged = FALSE;
        _bPathChanged = FALSE;
        _bCommentChanged = FALSE;
        _bUserLimitChanged = FALSE;
        _bSecDescChanged = FALSE;
        PropSheet_UnChanged(_GetFrameWindow(),_hwndPage);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_CacheMaxUses, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_CacheMaxUses(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    DWORD dwRet = (DWORD)SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_GETPOS, 0, 0);
    if (HIWORD(dwRet) != 0)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        // Reset the edit control to the new value
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }
    else
    {
        _wMaxUsers = LOWORD(dwRet);
    }
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::Dump, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CSharingPropertyPage::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CSharingPropertyPage);

    appDebugOut((DEB_TRACE,
        "CSharingPropertyPage::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t            This: 0x%08lx\n"
"\t            Page: 0x%08lx\n"
"\t   Initializing?: %ws\n"
"\t          Dirty?: %ws\n"
"\t  Share changed?: %ws\n"
"\t   Path changed?: %ws\n"
"\tComment changed?: %ws\n"
"\tUsr Lim changed?: %ws\n"
"\t        Max uses: %d\n"
"\t       _pCurInfo: 0x%08lx\n"
,
this,
_hwndPage,
_fInitializingPage ? L"yes" : L"no",
_bDirty            ? L"yes" : L"no",
_bShareNameChanged ? L"yes" : L"no",
_bPathChanged      ? L"yes" : L"no",
_bCommentChanged   ? L"yes" : L"no",
_bUserLimitChanged ? L"yes" : L"no",
_wMaxUsers,
_pCurInfo
));

    _pCurInfo->Dump(L"Current");
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\gradient.c ===
#include <windows.h>
#include <stdio.h>
#include "shmgdefs.h"

#undef COLOR_MAX

#define COLOR_MAX (COLOR_GRADIENTINACTIVECAPTION + 1)
#define COLOR_MAX_NT4 (COLOR_INFOBK + 1)
#define SCHEME_MAX 27

CONST TCHAR* rgpszSchemes[SCHEME_MAX] = {
    TEXT("High Contrast Black (EL)"),       // 0
    TEXT("High Contrast White (EL)"),       // 1
    TEXT("Brick"),                          // 2
    TEXT("Desert"),                         // 3
    TEXT("Eggplant"),                       // 4
    TEXT("High Contrast Black"),            // 5
    TEXT("High Contrast White"),            // 6
    TEXT("Lilac"),                          // 7
    TEXT("Marine (HC)"),                    // 8
    TEXT("Plum (HC)"),                      // 9
    TEXT("Pumpkin (L)"),                    // 10
    TEXT("Rainy Day"),                      // 11
    TEXT("Red, White, and Blue (VGA)"),     // 12
    TEXT("Rose"),                           // 13
    TEXT("Slate"),                          // 14
    TEXT("Spruce"),                         // 15
    TEXT("Storm (VGA)"),                    // 16
    TEXT("Teal (VGA)"),                     // 17
    TEXT("Windows Standard"),               // 18
    TEXT("Rose (large)"),                   // 19
    TEXT("High Contrast Black (L)"),        // 20
    TEXT("High Contrast White (L)"),        // 21
    TEXT("Lilac (large)"),                  // 22
    TEXT("Windows Standard (EL)"),          // 23
    TEXT("Windows Standard (L)"),           // 24
    TEXT("Maple"),                          // 25
    TEXT("Wheat)")                          // 26
};

CONST TCHAR* rgpsz[COLOR_MAX] = {
    TEXT("Scrollbar"),
    TEXT("Background"),
    TEXT("ActiveTitle"),
    TEXT("InactiveTitle"),
    TEXT("Menu"),
    TEXT("Window"),
    TEXT("WindowFrame"),
    TEXT("MenuText"),
    TEXT("WindowText"),
    TEXT("TitleText"),
    TEXT("ActiveBorder"),
    TEXT("InactiveBorder"),
    TEXT("AppWorkspace"),
    TEXT("Hilight"),
    TEXT("HilightText"),
    TEXT("ButtonFace"),
    TEXT("ButtonShadow"),
    TEXT("GrayText"),
    TEXT("ButtonText"),
    TEXT("InactiveTitleText"),
    TEXT("ButtonHilight"),
    TEXT("ButtonDkShadow"),
    TEXT("ButtonLight"),
    TEXT("InfoText"),
    TEXT("InfoWindow"),
    TEXT("ButtonAlternateFace"),
    TEXT("HotTracking"),
    TEXT("GradientActiveTitle"),
    TEXT("GradientInactiveTitle")
};

COLORREF rgcr[SCHEME_MAX][COLOR_MAX] = {
{0x02000000,0x02000000,0x02800080,0x02008000,0x02000000,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x0200FFFF,0x02008000,0x02000000,0x02800080,0x02FFFFFF,0x02000000,0x02808080,0x0200FF00,0x02FFFFFF,0x02FFFFFF,0x02C0C0C0,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x02800080,0x02800080,0x02800080,0x02008000},
{0x02FFFFFF,0x02FFFFFF,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02808080,0x02C0C0C0,0x02808080,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02808080,0x0200FF00,0x02000000,0x02000000,0x02C0C0C0,0x02000000,0x02C0C0C0,0x02000000,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF},
{0x02D2E0E1,0x00000042,0x02000080,0x0261898D,0x02A5BFC2,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02D2E0E1,0x02A5BFC2,0x02A5BFC2,0x02D2E0E1,0x0261898D,0x02FFFFFF,0x02A5BFC2,0x0261898D,0x0261898D,0x02000000,0x02D2E0E1,0x02D2E0E1,0x02000000,0x02A5BFC2,0x02000080,0x02D2E0E1,0x00C0C0C0,0x02000080,0x004074B0,0x0270B8C8},
{0x02DDE6EA,0x02688DA2,0x02808000,0x02688DA2,0x02BBCCD5,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02BBCCD5,0x02BBCCD5,0x02688DA2,0x02808000,0x02FFFFFF,0x02BBCCD5,0x02688DA2,0x02688DA2,0x02000000,0x02FFFFFF,0x02DDE6EA,0x02000000,0x02BBCCD5,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02808000,0x00AABD84,0x0280D0E8},
{0x02A8B090,0x00400040,0x02788058,0x02A8B090,0x02A8B090,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02A8B090,0x02A8B090,0x02808080,0x02788058,0x02FFFFFF,0x02A8B090,0x02788058,0x02788058,0x02000000,0x02788058,0x02D8D8C8,0x02000000,0x02A8B090,0x02800080,0x02FFFFFF,0x00C0C0C0,0x02788058,0x00834B83,0x00D2BDCB},
{0x02000000,0x02000000,0x02800080,0x02008000,0x02000000,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x0200FFFF,0x02008000,0x02000000,0x02800080,0x02FFFFFF,0x02000000,0x02808080,0x0200FF00,0x02FFFFFF,0x02FFFFFF,0x02C0C0C0,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x00C0C0C0,0x02800080,0x02D88CC8,0x0012B42B},
{0x02FFFFFF,0x02FFFFFF,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02808080,0x02C0C0C0,0x02808080,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02808080,0x0200FF00,0x02000000,0x02000000,0x02C0C0C0,0x02000000,0x02C0C0C0,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02000000,0x02A09CA0,0x02D8D4D8},
{0x02D9A8AE,0x02000000,0x02B14E5A,0x02808080,0x02D9A8AE,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02D9A8AE,0x02D9A8AE,0x02B14E5A,0x02B14E5A,0x02FFFFFF,0x02D9A8AE,0x02B14E5A,0x02B14E5A,0x02000000,0x02FFFFFF,0x02ECD5D8,0x02000000,0x02D9A8AE,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02B14E5A,0x02CB8FB6,0x02D0B4B8},
{0x02D8E0C8,0x00474E2C,0x02800000,0x02889048,0x02B8C088,0x02D8E0C8,0x02000000,0x02000000,0x02000000,0x02C0C0C0,0x02B8C088,0x02B8C088,0x00848D4B,0x02800000,0x02FFFFFF,0x02B8C088,0x02889048,0x02889048,0x02000000,0x02C0C0C0,0x02D8E0C8,0x02000000,0x02B8C088,0x02000000,0x02D8E0C8,0x00C0C0C0,0x02800000,0x02C0B418,0x02D8CC78},
{0x00C8D0D8,0x00402840,0x00604048,0x00586078,0x009098A8,0x00C8D0D8,0x00000000,0x00000000,0x00000000,0x00C8D0D8,0x009098A8,0x009098A8,0x005A6374,0x00484828,0x00C8D0D8,0x009098A8,0x00586078,0x00586078,0x00000000,0x009098A8,0x00C8D0D8,0x00000000,0x009098A8,0x00580030,0x00C8CCD5,0x00C0C0C0,0x00604048,0x00B884A0,0x007898A8},
{0x02CFEAF5,0x00420042,0x022FA5D7,0x02A4A0A0,0x029DD5EC,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x029DD5EC,0x029DD5EC,0x02CFEAF5,0x02800080,0x02FFFFFF,0x029DD5EC,0x022FA5D7,0x022FA5D7,0x02000000,0x02CFEAF5,0x02CFEAF5,0x02000000,0x029DD5EC,0x02800080,0x02FFFFFF,0x00C0C0C0,0x022FA5D7,0x0288CCE0,0x0290CCD0},
{0x02D9CCC1,0x02000000,0x027D654F,0x02808080,0x02B19983,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02B19983,0x02B19983,0x02808080,0x027D654F,0x02FFFFFF,0x02B19983,0x027D654F,0x027D654F,0x02000000,0x02D9CCC1,0x02D9CCC1,0x02000000,0x02B19983,0x02000000,0x02FFFFFF,0x00C0C0C0,0x027D654F,0x02D0B480,0x02D0BCB0},
{0x02C0C0C0,0x00420000,0x02000080,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02FFFFFF,0x02000080,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02C0C0C0,0x02800000,0x02FFFFFF,0x00C0C0C0,0x02000080,0x02A81000,0x00C9BEBA},
{0x02B7AFCF,0x02808080,0x0270609F,0x02A4A0A0,0x02B7AFCF,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02B7AFCF,0x02B7AFCF,0x0270609F,0x0270609F,0x02FFFFFF,0x02B7AFCF,0x0270609F,0x0270609F,0x02000000,0x02000000,0x02DCD8E7,0x02000000,0x02B7AFCF,0x02000000,0x02FFFFFF,0x00C0C0C0,0x0270609F,0x02D0CCD8,0x02D0D4D0},
{0x02E3DCCE,0x00414141,0x02978055,0x02808080,0x02C8B99D,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C8B99D,0x02C8B99D,0x00424242,0x02978055,0x02FFFFFF,0x02C8B99D,0x02978055,0x02978055,0x02000000,0x02C0C0C0,0x02E3DCCE,0x02000000,0x02C8B99D,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02978055,0x02D8B888,0x02C8BCA0},
{0x02D3E3D0,0x00213F21,0x02649759,0x02808080,0x02A9C8A2,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02A9C8A2,0x02A9C8A2,0x02D3E3D0,0x02649759,0x02FFFFFF,0x02A9C8A2,0x02649759,0x02649759,0x02000000,0x02D3E3D0,0x02D3E3D0,0x02000000,0x02A9C8A2,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02649759,0x02E8C898,0x02B0CCA8},
{0x02C0C0C0,0x02000000,0x02800080,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02808080,0x02800080,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02000000,0x02FFFFFF,0x02000000,0x02C0C0C0,0x02800080,0x02FFFFFF,0x00C0C0C0,0x02800080,0x02B08C38,0x02A8ACA8},
{0x02C0C0C0,0x00404000,0x02808000,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02808080,0x02808000,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02F0FBFF,0x02FFFFFF,0x02000000,0x02C0C0C0,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02808000,0x00D8CC00,0x02B8C898},
{0x00C0C0C0,0x00808000,0x00800000,0x00808080,0x00C0C0C0,0x00FFFFFF,0x00000000,0x00000000,0x00000000,0x00FFFFFF,0x00C0C0C0,0x00C0C0C0,0x00808080,0x00800000,0x00FFFFFF,0x00C0C0C0,0x00808080,0x00808080,0x00000000,0x00C0C0C0,0x00FFFFFF,0x00000000,0x00C0C0C0,0x00000000,0x00E1FFFF,0x00C0C0C0,0x00800000,0x00D08410,0x00B5B5B5},
{0x02C0C0C0,0x02808080,0x027060A0,0x02A4A0A0,0x02B8B0D0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02B8B0D0,0x02B8B0D0,0x02E0D8E8,0x027060A0,0x02FFFFFF,0x02B8B0D0,0x027060A0,0x027060A0,0x02000000,0x027D7D7D,0x02E0D8E8,0x02000000,0x02B8B0D0,0x02000000,0x02FFFFFF,0x00C0C0C0,0x027060A0,0x02D0CCD8,0x02D0D4D0},
{0x02000000,0x02000000,0x02800080,0x02008000,0x02000000,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x0200FFFF,0x02008000,0x02000000,0x02800080,0x02FFFFFF,0x02000000,0x02808080,0x0200FF00,0x02FFFFFF,0x02FFFFFF,0x02C0C0C0,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x00C0C0C0,0x02800080,0x00800080,0x00008000},
{0x02FFFFFF,0x02FFFFFF,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02808080,0x02C0C0C0,0x02808080,0x02000000,0x02FFFFFF,0x02FFFFFF,0x02808080,0x0200FF00,0x02000000,0x02000000,0x02C0C0C0,0x02000000,0x02C0C0C0,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02000000,0x00000000,0x00FFFFFF},
{0x02D9A8AE,0x02000000,0x02B14E5A,0x02808080,0x02D9A8AE,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02D9A8AE,0x02D9A8AE,0x02B14E5A,0x02B14E5A,0x02FFFFFF,0x02D9A8AE,0x02B14E5A,0x02B14E5A,0x02000000,0x02FFFFFF,0x02ECD5D8,0x02000000,0x02D9A8AE,0x02000000,0x02FFFFFF,0x00C0C0C0,0x02B14E5A,0x02CB8FB6,0x02D0B4B8},
{0x02C0C0C0,0x02808000,0x02800000,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02808080,0x02800000,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02DFDFDF,0x02000000,0x00E1FFFF,0x00C0C0C0,0x02800000,0x02D08410,0x02B5B5B5},
{0x02C0C0C0,0x02808000,0x02800000,0x02808080,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02C0C0C0,0x02808080,0x02800000,0x02FFFFFF,0x02C0C0C0,0x02808080,0x02808080,0x02000000,0x02C0C0C0,0x02FFFFFF,0x02000000,0x02DFDFDF,0x02000000,0x02E1FFFF,0x00C0C0C0,0x02800000,0x02D08410,0x02B5B5B5},
{0x02D7ECF2,0x02000000,0x0246A6C6,0x02A4A0A0,0x02AED8E6,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02AED8E6,0x02AED8E6,0x02D7ECF2,0x0246A6C6,0x02000000,0x02AED8E6,0x0246A6C6,0x0246A6C6,0x02000000,0x02D7ECF2,0x02D7ECF2,0x02000000,0x02AED8E6,0x02000000,0x02FFFFFF,0x02C0C0C0,0x0246A6C6,0x02389CC0,0x0288C8E0},
{0x02D0EEEE,0x021D4000,0x02008080,0x0241BCBC,0x02A0DEDE,0x02FFFFFF,0x02000000,0x02000000,0x02000000,0x02FFFFFF,0x02A0DEDE,0x02A0DEDE,0x02D0EEEE,0x02008080,0x02FFFFFF,0x02A0DEDE,0x0241BCBC,0x0241BCBC,0x02000000,0x02FFFFFF,0x02D0EEEE,0x02000000,0x02A0DEDE,0x02000000,0x02FFFFFF,0x02C0C0C0,0x02008080,0x0248B0C8,0x0280B8B8},
};

void SetColor(HKEY hkey, int iColor, COLORREF cr)
{
    TCHAR sz[16];
    if (SUCCEEDED(StringCchPrintf(sz, ARRAYSIZE(sz), TEXT("%d %d %d"), GetRValue(cr), GetGValue(cr), GetBValue(cr))))
    {
        RegSetValueEx(hkey, rgpsz[iColor], 0, REG_SZ, (LPBYTE)sz, (wcslen(sz) + 1) * sizeof(TCHAR));
    }
}

void SetGradient(HKEY hkey, int iScheme)
{
    SetColor(hkey, COLOR_GRADIENTACTIVECAPTION, rgcr[iScheme][COLOR_GRADIENTACTIVECAPTION]);
    SetColor(hkey, COLOR_GRADIENTINACTIVECAPTION, rgcr[iScheme][COLOR_GRADIENTINACTIVECAPTION]);
}

void SetDesktop(HKEY hkey)
{
    SetColor(hkey, COLOR_DESKTOP, 0x00A56E3A);
}

#if DBG
#define DebugOut fwprintf
#else
#define DebugOut
#endif

void FixGradientColors(void)
{
    COLORREF cr, rgcrCurrent[COLOR_MAX] = {0x00C0C0C0,0x00808000,0x00800000,0x00808080,0x00C0C0C0,0x00FFFFFF,0x00000000,0x00000000,0x00000000,0x00FFFFFF,0x00C0C0C0,0x00C0C0C0,0x00808080,0x00800000,0x00FFFFFF,0x00C0C0C0,0x00808080,0x00808080,0x00000000,0x00C0C0C0,0x00FFFFFF,0x00000000,0x00C0C0C0,0x00000000,0x00E1FFFF,0x00C0C0C0,0x00800000,0x00800000,0x00808080};
    HKEY hkey;
    DWORD dwSize;
    int i, j;
    TCHAR szColor[16];
    DWORD dwR, dwG, dwB;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_SET_VALUE, &hkey) == ERROR_SUCCESS) {
        RegDeleteValue(hkey, TEXT("UserPreferencesMask"));
        RegCloseKey(hkey);
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Colors"), 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkey) != ERROR_SUCCESS)
        return;

    for (i = 0; i < sizeof(rgpsz) / sizeof(rgpsz[0]); i++) {

        dwSize = sizeof(szColor);

        if (SHRegGetValue(hkey, NULL, rgpsz[i], SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL, szColor, &dwSize) == ERROR_SUCCESS) {
            if (3 == swscanf(szColor, TEXT("%d %d %d"), &dwR, &dwG, &dwB)) {
                rgcrCurrent[i] = RGB(dwR, dwG, dwB);
            }
        }
    }

    for (i = 0; i < SCHEME_MAX; i++) {

        for (j = 0; j < COLOR_MAX_NT4; j++) {
            cr = (rgcr[i][j] & 0x00FFFFFF);
            if (rgcrCurrent[j] != cr) {
                break;
            }
        }

        if (j == COLOR_MAX_NT4) {
            break;
        }
    }

    if (j == COLOR_MAX_NT4) {
        DebugOut(stderr, TEXT("Upgrading NT4 color scheme %s\n"), rgpszSchemes[i]);
        SetGradient(hkey, i);

        /*
         * For Windows Standard, WS EL, WS L, update the desktop color.
         */
        if (i == 18 || i == 23 || i == 24) {
            DebugOut(stderr, TEXT("Updating %s desktop color\n"), rgpszSchemes[i]);
            SetDesktop(hkey);
        }

    } else {
        DebugOut(stderr, TEXT("No matching NT4 scheme found\n"));
    }

    RegCloseKey(hkey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       util.cxx
//
//  Contents:   Misc helper functions
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "shares.h"
#include "util.hxx"
#include "shrpage.hxx"
#include "dlgnew.hxx"
#include "strsafe.h"
#include "ccstock.h"

//////////////////////////////////////////////////////////////////////////////

DECLARE_INFOLEVEL(Sharing)

#define NETMSG_DLL TEXT("netmsg.dll")

#ifdef WIZARDS
TCHAR g_szShareWizardCmd[] = TEXT("ShrPubW.exe"); // The Share Publishing Wizard
TCHAR g_szShareWizardArg[] = TEXT("/folder "); // The Share Publishing Wizard
TCHAR g_szSfm[]  = TEXT("/sfm ");   // Services For Macintosh
TCHAR g_szFpnw[] = TEXT("/fpnw ");  // File and Print Services for NetWare
TCHAR g_szAll[]  = TEXT("/all ");   // all services
#endif // WIZARDS

//--------------------------------------------------------------------------
// Globals used elsewhere

UINT        g_NonOLEDLLRefs = 0;
HINSTANCE   g_hInstance = NULL;
UINT        g_uiMaxUsers = 0;   // max number of users based on product type
WCHAR       g_szAdminShare[] = L"ADMIN$";
WCHAR       g_szIpcShare[]   = L"IPC$";
UINT        g_cfHIDA = 0;

//////////////////////////////////////////////////////////////////////////////

DWORD
ConfirmStopShare(
    IN HWND hwnd,
    IN LPWSTR pszShare
    );

NET_API_STATUS
ShareConnectionInfo(
    IN LPWSTR pszShare,
    OUT LPDWORD pcConns,
    OUT LPDWORD pcOpens
    );

//////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        StringCchPrintf(pszBuffer, dwBufferSize, szText, dwMsgId);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessage
//
//  Synopsis:
//
//  Note:
//
//--------------------------------------------------------------------------
VOID
MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    )
{
    va_list arglist;
    va_start(arglist, dwBufferSize);
    MyFormatMessageText(dwMsgId, pszBuffer, dwBufferSize, &arglist);
    va_end(arglist);
}


//+-------------------------------------------------------------------------
//
//  Function:   MyCommonDialog
//
//  Synopsis:   Common popup dialog routine - stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyCommonDialog(
    IN HWND    hwnd,
    IN HRESULT dwMsgCode,
    IN PWSTR   pszCaption,
    IN DWORD   dwFlags,
    IN va_list arglist
    )
{
    WCHAR szMsgBuf[500];

    MyFormatMessageText(dwMsgCode, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    return MessageBox(hwnd, szMsgBuf, pszCaption, dwFlags);
}


//+-------------------------------------------------------------------------
//
//  Function:   MyConfirmationDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyConfirmationDialog(
    IN HWND hwnd,
    IN HRESULT dwMsgCode,
    IN DWORD dwFlags,
    ...
    )
{
    WCHAR szCaption[100];
    DWORD dwReturn;
    va_list arglist;

    va_start(arglist, dwFlags);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    dwReturn = MyCommonDialog(hwnd, dwMsgCode, szCaption, dwFlags, arglist);
    va_end(arglist);

    return dwReturn;
}


//+-------------------------------------------------------------------------
//
//  Function:   MyErrorDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
VOID
MyErrorDialog(
    IN HWND hwnd,
    IN HRESULT dwErrorCode,
    ...
    )
{
    WCHAR szCaption[100];
    va_list arglist;

    va_start(arglist, dwErrorCode);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    MyCommonDialog(hwnd, dwErrorCode, szCaption, MB_ICONSTOP | MB_OK, arglist);

    va_end(arglist);
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        appDebugOut((DEB_IERROR,"Illegal string to duplicate: NULL\n"));
        return NULL;
    }

    int cchRet = wcslen(psz) + 1;
    PWSTR pszRet = new WCHAR[cchRet];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    StringCchCopy(pszRet, cchRet, psz);
    return pszRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetResourceString
//
//  Synopsis:   Load a resource string, are return a "new"ed copy
//
//  Arguments:  [dwId] -- a resource string ID
//
//  Returns:    new memory copy of a string
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
    IN DWORD dwId
    )
{
    WCHAR sz[50];
    if (0 == LoadString(g_hInstance, dwId, sz, ARRAYLEN(sz)))
    {
        return NULL;
    }
    else
    {
        return NewDup(sz);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CopySecurityDescriptor, public
//
//  Synopsis:   Copy an NT security descriptor. The security descriptor must
//              be in self-relative (not absolute) form. Delete the result
//              using LocalFree().
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    appDebugOut((DEB_ITRACE, "CopySecurityDescriptor, pSecDesc = 0x%08lx\n", pSecDesc));

    if (NULL == pSecDesc)
    {
        return NULL;
    }

    appAssert(IsValidSecurityDescriptor(pSecDesc));

    DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
    PSECURITY_DESCRIPTOR pSelfSecDesc = reinterpret_cast<PSECURITY_DESCRIPTOR>(
		::LocalAlloc(LMEM_ZEROINIT, dwLen) );
    if (NULL == pSelfSecDesc)
    {
        appDebugOut((DEB_ERROR, "new SECURITY_DESCRIPTOR (2) failed\n"));
        return NULL;    // actually, should probably return an error
    }

    DWORD cbSelfSecDesc = dwLen;
    if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
    {
        appDebugOut((DEB_TRACE, "MakeSelfRelativeSD failed, 0x%08lx\n", GetLastError()));

        // assume it failed because it was already self-relative
        CopyMemory(pSelfSecDesc, pSecDesc, dwLen);
    }

    appAssert(IsValidSecurityDescriptor(pSelfSecDesc));

    return pSelfSecDesc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DisplayError
//
//  Synopsis:   Display an error message
//
//  History:    24-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
DisplayError(
    IN HWND           hwnd,
    IN HRESULT        dwErrorCode, // message file number. not really an HRESULT
    IN NET_API_STATUS err,
    IN PWSTR          pszShare
    )
{
    if (   err < MIN_LANMAN_MESSAGE_ID
        || err > MAX_LANMAN_MESSAGE_ID
        )
    {
        // a Win32 error?

        WCHAR szMsg[500];
        DWORD dwReturn = FormatMessage(
                                 FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 err,
                                 LANG_USER_DEFAULT,
                                 szMsg,
                                 ARRAYLEN(szMsg),
                                 NULL);
        if (0 == dwReturn)   // couldn't find message
        {
            appDebugOut((DEB_IERROR,
                "FormatMessage (from system) failed, 0x%08lx\n",
                GetLastError()));

            MyErrorDialog(hwnd, IERR_UNKNOWN, err);
        }
        else
        {
            MyErrorDialog(hwnd, dwErrorCode, pszShare, szMsg);
        }
    }
    else
    {
        DisplayLanmanError(hwnd, dwErrorCode, err, pszShare);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   DisplayLanmanError
//
//  Synopsis:   Display an error message from a LanMan error.
//
//  History:    24-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
DisplayLanmanError(
    IN HWND           hwnd,
    IN HRESULT        dwErrorCode, // message file number. not really an HRESULT
    IN NET_API_STATUS err,
    IN PWSTR          pszShare
    )
{
    if (   err < MIN_LANMAN_MESSAGE_ID
        || err > MAX_LANMAN_MESSAGE_ID
        )
    {
        MyErrorDialog(hwnd, IERR_UNKNOWN, err);
        return;
    }

    WCHAR szCaption[100];
    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));

    //
    // get LanMan message from system message file.
    //

    WCHAR szNetMsg[500];
    WCHAR szBuf[500];

    HINSTANCE hInstanceNetMsg = LoadLibrary(NETMSG_DLL);
    if (NULL == hInstanceNetMsg)
    {
        appDebugOut((DEB_IERROR,
            "LoadLibrary(netmsg.dll) failed, 0x%08lx\n",
            GetLastError()));

        LoadString(g_hInstance, IDS_NO_NET_MSG, szBuf, ARRAYLEN(szBuf));
        MessageBox(hwnd, szBuf, szCaption, MB_ICONSTOP | MB_OK);
        return;
    }

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             hInstanceNetMsg,
                             err,
                             LANG_USER_DEFAULT,
                             szNetMsg,
                             ARRAYLEN(szNetMsg),
                             NULL);
    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        LoadString(g_hInstance, IDS_NET_MSG_NOT_FOUND, szBuf, ARRAYLEN(szBuf));
        StringCchPrintf(szNetMsg, ARRAYSIZE(szNetMsg), szBuf, GetLastError());
        MessageBox(hwnd, szNetMsg, szCaption, MB_ICONSTOP | MB_OK);
    }
    else
    {
        MyErrorDialog(hwnd, dwErrorCode, pszShare, szNetMsg);
    }

    FreeLibrary(hInstanceNetMsg);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsValidShareName
//
//  Synopsis:   Checks if the proposed share name is valid or not. If not,
//              it will return a message id for the reason why.
//
//  Arguments:  [pszShareName] - Proposed share name
//              [puId] - If name is invalid, this will contain the reason why.
//
//  Returns:    TRUE if name is valid, else FALSE.
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

BOOL
IsValidShareName(
    IN  PCWSTR pszShareName,
    OUT HRESULT* uId
    )
{
    if (NetpNameValidate(NULL, (PWSTR)pszShareName, NAMETYPE_SHARE, 0L) != NERR_Success)
    {
        *uId = IERR_InvalidShareName;
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetErrorFocus
//
//  Synopsis:   Set focus to an edit control and select its text.
//
//  Arguments:  [hwnd] - dialog window
//              [idCtrl] - edit control to set focus to (and select)
//
//  Returns:    nothing
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
SetErrorFocus(
    IN HWND hwnd,
    IN UINT idCtrl
    )
{
    HWND hCtrl = ::GetDlgItem(hwnd, idCtrl);
    ::SetFocus(hCtrl);
    ::SendMessage(hCtrl, EM_SETSEL, 0, -1);
}


//+-------------------------------------------------------------------------
//
//  Function:   ConfirmReplaceShare
//
//  Synopsis:   Display confirmations for replacing an existing share
//
//  Arguments:  [hwnd] - dialog window
//              [pszShareName] - name of share being replaced
//              [pszOldPath] - current path for the share
//              [pszNewPath] - directory the user's trying to share
//
//  Returns:    Returns IDYES, IDNO, or IDCANCEL
//
//  History:    4-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

DWORD
ConfirmReplaceShare(
    IN HWND hwnd,
    IN PCWSTR pszShareName,
    IN PCWSTR pszOldPath,
    IN PCWSTR pszNewPath
    )
{
    DWORD id = MyConfirmationDialog(
                    hwnd,
                    MSG_RESHARENAMECONFIRM,
                    MB_YESNO | MB_ICONEXCLAMATION,
                    pszOldPath,
                    pszShareName,
                    pszNewPath);
    if (id != IDYES)
    {
        return id;
    }

    return ConfirmStopShare(hwnd, (PWSTR)pszShareName);
}

//+-------------------------------------------------------------------------
//
//  Member:     ConfirmStopShare, public
//
//  Synopsis:   Display the appropriate confirmations when stopping a share.
//
//  Arguments:  [hwnd] - parent window handle for messages
//              [pszShare] - ptr to affected share name
//
//  Returns:    IDYES if share should be deleted, IDNO if we don't want to
//              delete, but keep going, IDCANCEL to stop going.
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

DWORD
ConfirmStopShare(
    IN HWND hwnd,
    IN LPWSTR pszShare
    )
{
    DWORD cConns, cOpens;
    NET_API_STATUS err = ShareConnectionInfo(pszShare, &cConns, &cOpens);
    if (err != NERR_Success)
    {
        DisplayError(hwnd, IERR_CANT_DEL_SHARE, err, pszShare);
        return IDYES;   // allow the stop anyway
    }

    if (cConns != 0)
    {
        // If there are any open files, just give the more detailed
        // message about there being open files. Otherwise, just say how
        // many connections there are.

        if (cOpens != 0)
        {
            return MyConfirmationDialog(
                        hwnd,
                        MSG_STOPSHAREOPENS,
                        MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                        cOpens,
                        cConns,
                        pszShare);
        }
        else
        {
            return MyConfirmationDialog(
                        hwnd,
                        MSG_STOPSHARECONNS,
                        MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                        cConns,
                        pszShare);
        }
    }

    return IDYES;           /* OK to delete */
}



//+-------------------------------------------------------------------------
//
//  Member:     ShareConnectionInfo, public
//
//  Synopsis:   Determine how many connections and file opens exist for a
//              share, for use by confirmation dialogs.
//
//  Arguments:  [pszShare] - ptr to affected share name
//              [pcConns]  - *pcConns get the number of connections
//              [pcOpens]  - *pcOpens get the number of file opens
//
//  Returns:    standard net api code, NERR_Success if everything ok.
//
//  History:    19-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

NET_API_STATUS
ShareConnectionInfo(
    IN LPWSTR pszShare,
    OUT LPDWORD pcConns,
    OUT LPDWORD pcOpens
    )
{
    CONNECTION_INFO_1* pBuf;

    DWORD iEntry, iTotal;
    NET_API_STATUS err = NetConnectionEnum(
                            NULL,
                            pszShare,
                            1,
                            (LPBYTE*)&pBuf,
                            0xffffffff,     // no buffer limit; get them all!
                            &iEntry,
                            &iTotal,
                            NULL);

   if ((err == NERR_Success) || (err == ERROR_MORE_DATA))
   {
      int iConnections = 0;
      for (DWORD i = 0; i < iEntry; i++)
      {
          iConnections += pBuf[i].coni1_num_opens;
      }

      *pcConns = iTotal;
      *pcOpens = iConnections;
      err = NERR_Success;
   }
   else
   {
      *pcConns = 0;
      *pcOpens = 0;
   }
   NetApiBufferFree(pBuf);

   appDebugOut((DEB_ITRACE,"Share '%ws' has %d connections and %d opens\n", pszShare, *pcConns, *pcOpens));

   return err;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsWorkstationProduct
//
//  Synopsis:   Determines the NT product type (server or workstation),
//              and returns TRUE if it is workstation.
//
//  Arguments:  (none)
//
//  Returns:    TRUE if running on workstation products
//
//  History:    11-Sep-95 BruceFo   Created
//
//----------------------------------------------------------------------------

BOOL
IsWorkstationProduct(
    VOID
    )
{
    //
    // Determine whether this is the workstation or server product by looking
    // at HKEY_LOCAL_MACHINE, System\CurrentControlSet\Control\ProductOptions.
    // The ProductType value therein is interpreted as follows:
    //
    // LanmanNt -- server product, running as domain controller
    // ServerNt -- server product, not a domain controller
    // WinNT    -- workstation product
    //

    LONG    ec;
    HKEY    hkey;
    DWORD   type;
    DWORD   size;
    UCHAR   buf[100];
    BOOL    fIsWorkstation = TRUE;

    ec = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                0,
                KEY_QUERY_VALUE,
                &hkey
                );

    if (ec == NO_ERROR)
    {
        size = sizeof(buf);
        ec = RegQueryValueEx(hkey,
                             TEXT("ProductType"),
                             NULL,
                             &type,
                             buf,
                             &size);

        if ((ec == NO_ERROR) && (type == REG_SZ))
        {
            if (0 == lstrcmpi((LPTSTR)buf, TEXT("lanmannt")))
            {
                fIsWorkstation = FALSE;
            }

            if (0 == lstrcmpi((LPTSTR)buf, TEXT("servernt")))
            {
                fIsWorkstation = FALSE;
            }
        }

        RegCloseKey(hkey);
    }

    return fIsWorkstation;
}

BOOL
DriveLetterShare(
    PWSTR pszShareName
    )
{
    if (NULL == pszShareName || lstrlen(pszShareName) != 2)
    {
        return FALSE;
    }

    // BUGBUG: what about non-English char sets?
    return (   ((pszShareName[0] >= TEXT('a')) && pszShareName[0] <= TEXT('z'))
            || ((pszShareName[0] >= TEXT('A')) && pszShareName[0] <= TEXT('Z'))
            )
           && (pszShareName[1] == TEXT('$'))
           ;
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   DumpNetEnum
//
//  Synopsis:   Dumps an array of SHARE_INFO_1 structures.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

VOID
DumpNetEnum(
    IN LPVOID pBufShares,
    IN ULONG entriesRead
    )
{
    SHARE_INFO_1* pBase = (SHARE_INFO_1*) pBufShares;

    appDebugOut((DEB_TRACE,
        "DumpNetEnum: %d entries\n",
        entriesRead));

    for (ULONG i = 0; i < entriesRead; i++)
    {
        SHARE_INFO_1* p = &(pBase[i]);

        appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t Share name: %ws\n"
"\t       Type: %d (0x%08lx)\n"
"\t    Comment: %ws\n"
"\n"
,
p->shi1_netname,
p->shi1_type, p->shi1_type,
p->shi1_remark
));

    }
}

#endif // DBG == 1

struct SHARE_PROPERTIES_DATA
{
    IUnknown* punk;
    LPTSTR    pszMachine;
    LPTSTR    pszShareName;
};

DWORD CALLBACK
SharePropertiesThreadProc(
    LPVOID lpThreadParameter
    )
{
    SHARE_PROPERTIES_DATA* pData = (SHARE_PROPERTIES_DATA*)lpThreadParameter;
    if (NULL == pData)
    {
        appAssert(!"Unexpected properties thread data");
        return 0;
    }

    WCHAR szCaption[MAX_PATH];
    LoadString(g_hInstance, IDS_SHARE_PROPTITLE, szCaption, ARRAYLEN(szCaption));

    SHARE_PROPSHEETPAGE sprop;

    sprop.psp.dwSize      = sizeof(sprop);    // no extra data.
    sprop.psp.dwFlags     = PSP_USEREFPARENT;
    sprop.psp.hInstance   = g_hInstance;
    sprop.psp.pszTemplate = MAKEINTRESOURCE(IDD_SHARE_PROPERTIES);
    sprop.psp.hIcon       = NULL;
    sprop.psp.pszTitle    = NULL;
    sprop.psp.pfnDlgProc  = CSharingPropertyPage::DlgProcPage;
    sprop.psp.lParam      = 0;
    sprop.psp.pfnCallback = NULL;
    sprop.psp.pcRefParent = &g_NonOLEDLLRefs;
    sprop.pszMachine      = pData->pszMachine;
    sprop.pszShareName    = pData->pszShareName;

    PROPSHEETHEADER psh;

    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_PROPSHEETPAGE | PSH_USEICONID;
    psh.hwndParent = NULL;
    psh.hInstance  = g_hInstance;
    psh.pszIcon    = MAKEINTRESOURCE(IDI_SHARESFLD);
    psh.pszCaption = szCaption;
    psh.nPages     = 1;
    psh.nStartPage = 0;
    psh.ppsp       = (LPCPROPSHEETPAGE)&sprop;
    psh.pfnCallback= NULL;

    PropertySheet(&psh);

    pData->punk->Release();
    LocalFree(pData);       // The strings are packed in the same allocation!
    return 0;
}

HRESULT
ShareDoProperties(
    IN IUnknown* punk,
    IN LPTSTR    pszMachine,
    IN LPTSTR    pszShareName
    )
{
    if (NULL == pszShareName)
    {
        return E_INVALIDARG;
    }

    DWORD cbMachine = 0;
    DWORD cbStrings = 0;
    if (NULL != pszMachine)
    {
        cbMachine = (lstrlen(pszMachine) + 1) * sizeof(TCHAR);
        cbStrings += cbMachine;
    }
    cbStrings += (lstrlen(pszShareName) + 1) * sizeof(TCHAR);

    HRESULT hr = S_OK;
    HANDLE hThread;
    DWORD idThread;
    SHARE_PROPERTIES_DATA* pData = (SHARE_PROPERTIES_DATA*)LocalAlloc(LPTR, sizeof(SHARE_PROPERTIES_DATA) + cbStrings);
    if (pData)
    {
        if (NULL != pszMachine)
        {
            pData->pszMachine = (LPWSTR)(((LPBYTE)pData) + sizeof(SHARE_PROPERTIES_DATA));
            StringCbCopy(pData->pszMachine, cbMachine, pszMachine);
        }
        else
        {
            pData->pszMachine   = NULL;
        }
        pData->pszShareName = (LPWSTR)(((LPBYTE)pData) + sizeof(SHARE_PROPERTIES_DATA) + cbMachine);
        StringCbCopy(pData->pszShareName, cbStrings - cbMachine, pszShareName);

        pData->punk = punk;
        pData->punk->AddRef();

        hThread = CreateThread(NULL, 0, SharePropertiesThreadProc, pData, 0, &idThread);

        if (hThread)
        {
            CloseHandle(hThread);
            return S_OK;
        }
        else
        {
            pData->punk->Release();
            LocalFree(pData);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT
ShareDoDelete(
    IN HWND hwndOwner,
    IN PWSTR pszMachine,
    IN PWSTR pszShareName
    )
{
    // Remove the share. We need to know the path that was
    // shared to be able to update the explorer. So, get
    // that.
    SHARE_INFO_1* pInfo1 = NULL;
    SHARE_INFO_2* pInfo2 = NULL;
    DWORD ret;
    HRESULT hr = S_OK;

    ret = NetShareGetInfo(pszMachine, pszShareName, 2, (LPBYTE*)&pInfo2);
    if (NERR_Success != ret)
    {
        // make sure it's null
        pInfo2 = NULL;
    }

    // Warn and confirm if it's a special share, either ADMIN$, IPC$,
    // or <drive>$
    if (NULL == pInfo2)
    {
        // Permissions problem? Try getting SHARE_INFO_1.

        ret = NetShareGetInfo(pszMachine, pszShareName, 1, (LPBYTE*)&pInfo1);
        if (NERR_Success != ret)
        {
            // make sure it's null
            pInfo1 = NULL;
        }
    }
    else
    {
        pInfo1 = (SHARE_INFO_1*)pInfo2; // I just need the type
    }

    if (NULL != pInfo1)
    {
        DWORD id = IDYES;
        if (pInfo1->shi1_type & STYPE_SPECIAL)
        {
            id = MyConfirmationDialog(
                            hwndOwner,
                            MSG_DELETESPECIAL,
                            MB_YESNO | MB_ICONEXCLAMATION,
                            pszShareName);
        }

        if (pInfo1 != (SHARE_INFO_1*)pInfo2)
        {
            NetApiBufferFree(pInfo1);
        }

        if (id != IDYES)
        {
            hr = S_OK;
            goto nodelete;
        }
    }

    // Actually delete the share
    ret = NetShareDel(pszMachine, pszShareName, 0);
    if (NERR_Success == ret)
    {
        if (NULL != pInfo2)
        {
            SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, pInfo2->shi2_path, 0);
        }
    }
    else
    {
        // BUGBUG: error message to user

        hr = HRESULT_FROM_WIN32(GetLastError());
    }

nodelete:
    if (NULL != pInfo2)
    {
        NetApiBufferFree(pInfo2);
    }

    return hr;
}

struct SHARE_NEW_DATA
{
    IUnknown* punk;
    LPTSTR    pszMachine;
};

DWORD CALLBACK
ShareNewThreadProc(
    LPVOID lpThreadParameter
    )
{
    SHARE_NEW_DATA* pData = (SHARE_NEW_DATA*)lpThreadParameter;
    if (NULL == pData)
    {
        appAssert(!"Unexpected properties thread data");
        return 0;
    }

    CDlgNewShare dlg(NULL, pData->pszMachine);
    if (dlg.DoModal())
    {
    }

    pData->punk->Release();
    LocalFree(pData);       // The strings are packed in the same allocation!
    return 0;
}


HRESULT
ShareDoNew(
    IN IUnknown* punk,
    IN PWSTR pszMachine
    )
{
    DWORD cbStrings = 0;
    if (NULL != pszMachine)
    {
        cbStrings += (lstrlen(pszMachine) + 1) * sizeof(TCHAR);
    }

    HRESULT hr = S_OK;
    HANDLE hThread;
    DWORD idThread;
    SHARE_NEW_DATA* pData = (SHARE_NEW_DATA*)LocalAlloc(LPTR, sizeof(SHARE_NEW_DATA) + cbStrings);
    if (pData)
    {
        if (NULL != pszMachine)
        {
            pData->pszMachine = (LPWSTR)(((LPBYTE)pData) + sizeof(SHARE_NEW_DATA));
            StringCbCopy(pData->pszMachine, cbStrings, pszMachine);
        }
        else
        {
            pData->pszMachine   = NULL;
        }

        pData->punk = punk;
        pData->punk->AddRef();

        hThread = CreateThread(NULL, 0, ShareNewThreadProc, pData, 0, &idThread);

        if (hThread)
        {
            CloseHandle(hThread);
            return S_OK;
        }
        else
        {
            pData->punk->Release();
            LocalFree(pData);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


#ifdef WIZARDS
HRESULT
ShareDoSpecial(
    IN HWND hwndOwner,
    IN PWSTR pszMachine,
    IN BYTE bType
    )
{
    // Construct the command line to pass to the Share Wizard

    TCHAR szCommandLine[MAX_PATH];
    StringCchCopy(szCommandLine, ARRAYSIZE(szCommandLine), g_szShareWizardArg);

    switch (bType)
    {
    case SHID_SHARE_NW:
        StringCchCat(szCommandLine, ARRAYSIZE(szCommandLine), g_szFpnw);
        break;

    case SHID_SHARE_MAC:
        StringCchCat(szCommandLine, ARRAYSIZE(szCommandLine), g_szSfm);
        break;

    case SHID_SHARE_ALL:
        StringCchCat(szCommandLine, ARRAYSIZE(szCommandLine), g_szAll);
        break;

    case SHID_SHARE_NEW:
        // nothing special
        break;

    default: appAssert(!"Unknown object type");
    }

    if (NULL != pszMachine)
    {
        StringCchCat(szCommandLine, ARRAYSIZE(szCommandLine), pszMachine);
    }

    appDebugOut((DEB_TRACE, "Invoking wizard with this command line: %ws\n", szCommandLine));

    // Looks like CreateProcess writes to this buffer!
    STARTUPINFO si = { 0 };
    si.cb = sizeof(si);
    PROCESS_INFORMATION pi = { 0 };
    BOOL b = CreateProcess(
                    g_szShareWizardCmd,
                    szCommandLine,
                    NULL,   // pointer to process security attributes
                    NULL,   // pointer to thread security attributes
                    FALSE,  // handle inheritance flag
                    0,      // creation flags
                    NULL,   // pointer to new environment block
                    NULL,   // pointer to current directory name
                    &si,    // pointer to STARTUPINFO
                    &pi);   // pointer to PROCESS_INFORMATION
    if (b)
    {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    else
    {
        appDebugOut((DEB_ERROR,
            "CreateProcess failed, 0x%08lx\n",
            GetLastError()));

        MyErrorDialog(hwndOwner, MSG_NOWIZARD);
    }

    return S_OK;
}
#endif // WIZARDS


VOID FSSetStatusText(HWND hwndOwner, LPTSTR* ppszText, int iStart, int iEnd)
{
    HWND hwndStatus = NULL;
    IShellBrowser* psb = FileCabinet_GetIShellBrowser(hwndOwner);

    if (psb)
    {
        psb->GetControlWindow(FCW_STATUS, &hwndStatus);
        if (hwndStatus)
        {
            for (; iStart <= iEnd; iStart++)
            {
                LPTSTR lpsz;

                if (ppszText)
                {
                    lpsz = *ppszText;
                    ppszText++;
                }
                else
                {
                    lpsz = (LPTSTR)TEXT("");
                }
#ifdef WINDOWS_ME
                SendMessage(hwndStatus, SB_SETTEXT, SB_RTLREADING | (WPARAM)iStart, (LPARAM)lpsz);
#else
                SendMessage(hwndStatus, SB_SETTEXT, (WPARAM)iStart, (LPARAM)lpsz);
#endif
            }
        }
    }
}


BOOL
IsLevelOk(
    IN PWSTR pszMachine,
    IN DWORD level
    )
{
    LPBYTE pBuf = NULL;
    DWORD entriesread, totalentries;
    NET_API_STATUS ret;

    // we want to get the minimum amount of data, because all we care about
    // is whether it succeeds the access check
    DWORD prefmaxlen = 300;
    for (;; prefmaxlen *= 2)
    {
        ret = NetShareEnum(
                        pszMachine,
                        level,
                        &pBuf,
                        prefmaxlen,
                        &entriesread,
                        &totalentries,
                        NULL);
        if (NERR_BufTooSmall != ret)
        {
            NetApiBufferFree(pBuf);
            break;
        }
    }

    if (ERROR_ACCESS_DENIED == ret)
    {
        return FALSE;
    }
    else if (NERR_Success == ret || ERROR_MORE_DATA == ret)
    {
        return TRUE;
    }
    else
    {
        // some other error
        return FALSE;
    }
}


VOID
SetDialogIconBig(
    IN HWND hwnd,
    WORD idIcon
    )
{
    HICON hiconLarge = (HICON)LoadImage(
                            g_hInstance,
                            MAKEINTRESOURCE(idIcon),
                            IMAGE_ICON,
                            GetSystemMetrics(SM_CXICON),
                            GetSystemMetrics(SM_CYICON),
                            LR_DEFAULTCOLOR);
    if (NULL == hiconLarge)
    {
        appDebugOut((DEB_ERROR,
            "LoadImage for large image failed, 0x%08lx\n",
            GetLastError()));
    }
    else
    {
        SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hiconLarge);
    }
}


VOID
SetDialogIconSmall(
    IN HWND hwnd,
    WORD idIcon
    )
{
    HICON hiconSmall = (HICON)LoadImage(
                            g_hInstance,
                            MAKEINTRESOURCE(idIcon),
                            IMAGE_ICON,
                            GetSystemMetrics(SM_CXSMICON),
                            GetSystemMetrics(SM_CYSMICON),
                            LR_DEFAULTCOLOR);
    if (NULL == hiconSmall)
    {
        appDebugOut((DEB_ERROR,
            "LoadImage for small image failed, 0x%08lx\n",
            GetLastError()));
    }
    else
    {
        SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hiconSmall);
    }
}

//////////////////////////////////////////////////////////////////////////////

HRESULT
STRRETLoadString(
    UINT ids,
    STRRET* pstr
    )
{
#ifdef UNICODE
    TCHAR szTemp[MAX_PATH];
    szTemp[0] = TEXT('\0');

    LoadString(g_hInstance, ids, szTemp, ARRAYLEN(szTemp));
    int cchOleStr = lstrlen(szTemp)+1;
    pstr->pOleStr = (LPOLESTR)SHAlloc(cchOleStr * sizeof(TCHAR));
    if (NULL != pstr->pOleStr)
    {
        pstr->uType = STRRET_OLESTR;
        StringCchCopy(pstr->pOleStr, cchOleStr, szTemp);
    }
    else
    {
        pstr->uType = STRRET_CSTR;
        pstr->cStr[0] = '\0';
        return E_OUTOFMEMORY;
    }
#else
    pstr->uType = STRRET_CSTR;
    LoadString(g_hInstance, ids, pstr->cStr, ARRAYLEN(pstr->cStr));
#endif

    return S_OK;
}

HRESULT
STRRETCopy(
    LPTSTR pszString,
    STRRET* pstr
    )
{
#ifdef UNICODE
    int cchOleStr = lstrlen(pszString)+1;
    pstr->pOleStr = (LPOLESTR)SHAlloc(cchOleStr * sizeof(TCHAR));
    if (NULL != pstr->pOleStr)
    {
        pstr->uType = STRRET_OLESTR;
        StringCchCopy(pstr->pOleStr, cchOleStr, pszString);
    }
    else
    {
        pstr->uType = STRRET_CSTR;
        pstr->cStr[0] = '\0';
        return E_OUTOFMEMORY;
    }
#else
    pstr->uType = STRRET_CSTR;
    int cch = lstrlen(pszString) + 1;
    cch = min(cch, ARRAYLEN(pstr->cStr));
    StringCchCopy(pstr->cStr, cch, pszString);
    pszString[cch - 1] = '\0';
#endif

    return S_OK;
}


VOID
FillSpecialID(
    LPIDSHARE pids,
    BYTE bFlags,        // SHID_SHARE_*
    UINT idsName
    )
{
    WCHAR szBuf[MAX_PATH];
    szBuf[0] = L'\0';
    LoadString(g_hInstance, idsName, szBuf, ARRAYLEN(szBuf));
    LPWSTR pszName    = szBuf;
    USHORT nameLength = (USHORT)lstrlen(pszName);
    USHORT nameOffset = 0;

    pids->bFlags      = bFlags;
    pids->bReserved   = 0;
    pids->maxUses     = 0xffffffff;     // bogus

    // we don't store nameOffset
    pids->oComment = 0xffff;            // bogus
    pids->oPath    = 0xffff;            // bogus

    StringCchCopy(&pids->cBuf[nameOffset], ARRAYSIZE(pids->cBuf) - nameOffset, pszName);

    pids->cb = offsetof(IDSHARE, cBuf)
               + (nameLength + 1) * sizeof(WCHAR);

    //
    // null terminate pidl
    //

    *(USHORT *)((LPBYTE)pids + pids->cb) = 0;
}

VOID
FillID1(
    LPIDSHARE pids,
    LPSHARE_INFO_1 pInfo
    )
{
    LPWSTR pszName    = pInfo->shi1_netname;
    LPWSTR pszComment = pInfo->shi1_remark;

    USHORT  nameLength, commentLength;
    USHORT  nameOffset, commentOffset;

    nameLength    = (USHORT)lstrlen(pszName);
    commentLength = (USHORT)lstrlen(pszComment);

    nameOffset    = 0;
    commentOffset = nameOffset + nameLength + 1;

    pids->bFlags      = SHID_SHARE_1;
    pids->bReserved   = 0;
    pids->type        = pInfo->shi1_type;
    pids->maxUses     = 0xffffffff;     // bogus

    // we don't store nameOffset
    pids->oComment = commentOffset;
    pids->oPath    = 0xffff;            // bogus

    StringCchCopy(&pids->cBuf[nameOffset], ARRAYSIZE(pids->cBuf) - nameOffset, pszName);
    StringCchCopy(&pids->cBuf[commentOffset], ARRAYSIZE(pids->cBuf) - commentOffset, pszComment);

    pids->cb = offsetof(IDSHARE, cBuf)
               + (nameLength + 1 + commentLength + 1) * sizeof(WCHAR);

    //
    // null terminate pidl
    //

    *(USHORT *)((LPBYTE)pids + pids->cb) = 0;
}


VOID
FillID2(
    LPIDSHARE pids,
    LPSHARE_INFO_2 pInfo
    )
{
    LPWSTR pszName    = pInfo->shi2_netname;
    LPWSTR pszComment = pInfo->shi2_remark;
    LPWSTR pszPath    = pInfo->shi2_path;

    USHORT  nameLength, commentLength, pathLength;
    USHORT  nameOffset, commentOffset, pathOffset;

    nameLength    = (USHORT)lstrlen(pszName);
    commentLength = (USHORT)lstrlen(pszComment);
    pathLength    = (USHORT)lstrlen(pszPath);

    nameOffset    = 0;
    commentOffset = nameOffset + nameLength + 1;
    pathOffset    = commentOffset + commentLength + 1;

    pids->bFlags      = SHID_SHARE_2;
    pids->bReserved   = 0;
    pids->type        = pInfo->shi2_type;
    pids->maxUses     = pInfo->shi2_max_uses;

    // we don't store nameOffset
    pids->oComment = commentOffset;
    pids->oPath    = pathOffset;

    StringCchCopy(&pids->cBuf[nameOffset], ARRAYSIZE(pids->cBuf) - nameOffset, pszName);
    StringCchCopy(&pids->cBuf[commentOffset], ARRAYSIZE(pids->cBuf) - commentOffset, pszComment);
    StringCchCopy(&pids->cBuf[pathOffset], ARRAYSIZE(pids->cBuf) - pathOffset, pszPath);

    pids->cb = offsetof(IDSHARE, cBuf)
               + (nameLength + 1 + commentLength + 1 + pathLength + 1) * sizeof(WCHAR);

    //
    // null terminate pidl
    //

    *(USHORT *)((LPBYTE)pids + pids->cb) = 0;
}


VOID
StrNCopy(
    OUT LPWSTR pszTarget,
    IN LPCWSTR pszSource,
    IN DWORD cchTarget
    )
{
    DWORD cch = lstrlen(pszSource) + 1;
    cch = min(cch, cchTarget);
    StringCchCopy(pszTarget, cch, pszSource);
    pszTarget[cch - 1] = TEXT('\0');
}



//+---------------------------------------------------------------------------
//
//  Function:   TrimLeadingAndTrailingSpaces
//
//  Synopsis:   Trims the leading and trailing spaces from a null-terminated string.
//              Used primarily for share names.
//
//  History:    18-Jul-97 JonN      Created
//
//----------------------------------------------------------------------------

VOID
TrimLeadingAndTrailingSpaces(
    IN OUT PWSTR psz
	)
{
	int cchStrlen = ::wcslen(psz);
	int cchLeadingSpaces = 0;
	int cchTrailingSpaces = 0;
	while (L' ' == psz[cchLeadingSpaces])
		cchLeadingSpaces++;
	if (cchLeadingSpaces < cchStrlen)
	{
		while (L' ' == psz[cchStrlen-(cchTrailingSpaces+1)])
			cchTrailingSpaces++;
	}
	if ((cchLeadingSpaces+cchTrailingSpaces) > 0)
	{
		cchStrlen -= (cchLeadingSpaces+cchTrailingSpaces);
		(void)memmove( psz,
		               psz+cchLeadingSpaces,
					   cchStrlen*sizeof(WCHAR) );
		psz[cchStrlen] = L'\0';
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\shitemid.h ===
#ifndef _WINNETWK_
#include <winnetwk.h>
#endif // _WINNETWK_

#define SHID_JUNCTION           0x80

#define SHID_GROUPMASK          0x70
#define SHID_TYPEMASK           0x7f
#define SHID_INGROUPMASK        0x0f

#define SHID_ROOT               0x10
#define SHID_ROOT_REGITEM       0x1f    // Mail

#if ((DRIVE_REMOVABLE|DRIVE_FIXED|DRIVE_REMOTE|DRIVE_CDROM|DRIVE_RAMDISK) != 0x07)
#error Definitions of DRIVE_* are changed!
#endif

#define SHID_COMPUTER           0x20
#define SHID_COMPUTER_1         0x21    // free
#define SHID_COMPUTER_REMOVABLE (0x20 | DRIVE_REMOVABLE)  // 2
#define SHID_COMPUTER_FIXED     (0x20 | DRIVE_FIXED)      // 3
#define SHID_COMPUTER_REMOTE    (0x20 | DRIVE_REMOTE)     // 4
#define SHID_COMPUTER_CDROM     (0x20 | DRIVE_CDROM)      // 5
#define SHID_COMPUTER_RAMDISK   (0x20 | DRIVE_RAMDISK)    // 6
#define SHID_COMPUTER_7         0x27    // free
#define SHID_COMPUTER_DRIVE525  0x28    // 5.25 inch floppy disk drive
#define SHID_COMPUTER_DRIVE35   0x29    // 3.5 inch floppy disk drive
#define SHID_COMPUTER_NETDRIVE  0x2a    // Network drive
#define SHID_COMPUTER_NETUNAVAIL 0x2b   // Network drive that is not restored.
#define SHID_COMPUTER_C         0x2c    // free
#define SHID_COMPUTER_D         0x2d    // free
#define SHID_COMPUTER_REGITEM   0x2e    // Controls, Printers, ...
#define SHID_COMPUTER_MISC      0x2f    // Unknown drive type

#define SHID_FS                 0x30
#define SHID_FS_TYPEMASK        0x3F
#define SHID_FS_DIRECTORY       0x31    // CHICAGO
#define SHID_FS_FILE            0x32    // FOO.TXT
#define SHID_FS_UNICODE         0x34    // Is it unicode? (this is a bitmask)
#define SHID_FS_DIRUNICODE      0x35    // Folder with a unicode name
#define SHID_FS_FILEUNICODE     0x36    // File with a unicode name

#define SHID_NET                0x40    
#define SHID_NET_DOMAIN         (SHID_NET | RESOURCEDISPLAYTYPE_DOMAIN)
#define SHID_NET_SERVER         (SHID_NET | RESOURCEDISPLAYTYPE_SERVER)
#define SHID_NET_SHARE          (SHID_NET | RESOURCEDISPLAYTYPE_SHARE)
#define SHID_NET_FILE           (SHID_NET | RESOURCEDISPLAYTYPE_FILE)
#define SHID_NET_GROUP          (SHID_NET | RESOURCEDISPLAYTYPE_GROUP)
#define SHID_NET_NETWORK        (SHID_NET | RESOURCEDISPLAYTYPE_NETWORK)
#define SHID_NET_RESTOFNET      (SHID_NET | RESOURCEDISPLAYTYPE_ROOT)
#define SHID_NET_SHAREADMIN     (SHID_NET | RESOURCEDISPLAYTYPE_SHAREADMIN)
#define SHID_NET_DIRECTORY      (SHID_NET | RESOURCEDISPLAYTYPE_DIRECTORY)
#define SHID_NET_TREE           (SHID_NET | RESOURCEDISPLAYTYPE_TREE)
#define SHID_NET_REGITEM        0x4e    // Remote Computer items
#define SHID_NET_PRINTER        0x4f    // \\PYREX\LASER1

#define SIL_GetType(pidl)       (ILIsEmpty(pidl) ? 0 : (pidl)->mkid.abID[0])
#define FS_IsValidID(pidl)      ((SIL_GetType(pidl) & SHID_GROUPMASK) == SHID_FS)
#define NET_IsValidID(pidl)     ((SIL_GetType(pidl) & SHID_GROUPMASK) == SHID_NET)

typedef struct _ICONMAP // icmp
{
    UINT        uType;                  // SHID_ type
    UINT        indexResource;          // Resource index (of SHELL232.DLL)
} ICONMAP, FAR* LPICONMAP;

UINT SILGetIconIndex(LPCITEMIDLIST pidl, const ICONMAP aicmp[], UINT cmax);

#pragma pack(1)
typedef struct _IDNETRESOURCE   // idn
{
        WORD    cb;
        BYTE    bFlags;         // Display type in low nibble
        BYTE    uType;
        BYTE    uUsage;         // Usage in low nibble, More Flags in high nibble
        CHAR    szNetResName[1];
        // char szProvider[*] - If NET_HASPROVIDER bit is set
        // char szComment[*]  - If NET_HASCOMMENT bit is set.
        // WCHAR szNetResNameWide[*] - If NET_UNICODE bit it set.
        // WCHAR szProviderWide[*]   - If NET_UNICODE and NET_HASPROVIDER
        // WCHAR szCommentWide[*]    - If NET_UNICODE and NET_HASCOMMENT
} IDNETRESOURCE, *LPIDNETRESOURCE;
typedef const IDNETRESOURCE *LPCIDNETRESOURCE;
#pragma pack()

//===========================================================================
// CNetwork: Some private macro
//===========================================================================

#define NET_DISPLAYNAMEOFFSET           ((UINT)((LPIDNETRESOURCE)0)->szNetResName)
#define NET_GetFlags(pidnRel)           ((pidnRel)->bFlags)
#define NET_GetDisplayType(pidnRel)     ((pidnRel)->bFlags & 0x0f)
#define NET_GetType(pidnRel)            ((pidnRel)->uType)
#define NET_GetUsage(pidnRel)           ((pidnRel)->uUsage & 0x0f)

// Define some Flags that are on high nibble of uUsage byte
#define NET_HASPROVIDER                 0x80    // Has own copy of provider
#define NET_HASCOMMENT                  0x40    // Has comment field in pidl
#define NET_REMOTEFLD                   0x20    // Is remote folder
#define NET_UNICODE                     0x10    // Has unicode names
#define NET_FHasComment(pidnRel)        ((pidnRel)->uUsage & NET_HASCOMMENT)
#define NET_FHasProvider(pidnRel)        ((pidnRel)->uUsage & NET_HASPROVIDER)
#define NET_IsRemoteFld(pidnRel)        ((pidnRel)->uUsage & NET_REMOTEFLD)
#define NET_IsUnicode(pidnRel)          ((pidnRel)->uUsage & NET_UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\shrinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       shrinfo.cxx
//
//  Contents:   Lanman SHARE_INFO_502 encapsulation
//
//  History:    21-Feb-95   BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "shrinfo.hxx"
#include "util.hxx"

CShareInfo::CShareInfo(
    VOID
    )
    :
    m_bOwn(TRUE),
    m_flags(0),
    m_pInfo(NULL)
{
    INIT_SIG(CShareInfo);
}

CShareInfo::CShareInfo(
    IN SHARE_INFO_502* pInfo
    )
    :
    m_bOwn(FALSE),
    m_flags(0),
    m_pInfo(pInfo)
{
    INIT_SIG(CShareInfo);
}

HRESULT
CShareInfo::InitInstance(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        appAssert(m_pInfo == NULL);

        m_pInfo = new SHARE_INFO_502;
        if (NULL == m_pInfo)
        {
            return E_OUTOFMEMORY;
        }

        m_pInfo->shi502_netname       = NULL;
        m_pInfo->shi502_type          = STYPE_DISKTREE;
        m_pInfo->shi502_remark        = NULL;
        m_pInfo->shi502_permissions   = ACCESS_ALL;
        m_pInfo->shi502_max_uses      = SHI_USES_UNLIMITED;
        m_pInfo->shi502_path          = NULL;
        m_pInfo->shi502_passwd        = NULL;
        m_pInfo->shi502_reserved      = 0;
        m_pInfo->shi502_security_descriptor = NULL;
    }

    return S_OK;
}

CShareInfo::~CShareInfo()
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        if (NULL != m_pInfo)    // must check; InitInstance might have failed
        {
			if ( m_pInfo->shi502_netname )
				delete[] m_pInfo->shi502_netname;
			if ( m_pInfo->shi502_remark )
				delete[] m_pInfo->shi502_remark;
			if ( m_pInfo->shi502_path )
				delete[] m_pInfo->shi502_path;
			if ( m_pInfo->shi502_passwd )
				delete[] m_pInfo->shi502_passwd;
			if ( m_pInfo->shi502_security_descriptor )
				::LocalFree( (BYTE*)m_pInfo->shi502_security_descriptor );
            delete m_pInfo;
        }
    }
}

NET_API_STATUS
CShareInfo::Commit(
    IN PWSTR pszMachine
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if (m_flags == 0)
    {
        // nothing changed
        appDebugOut((DEB_ITRACE, "CShareInfo::Commit: nothing (%ws)\n", m_pInfo->shi502_netname));
        return NERR_Success;
    }

// #if DBG == 1
//     Dump(L"Commit");
// #endif // DBG == 1

    NET_API_STATUS ret;

    // Note: we store a path, even for admin$. However, the NetShare* APIs
    // don't like seeing a path for admin$, so we temporarily strip it here
    // if necessary, before calling any APIs.

    LPWSTR pszPathTmp = m_pInfo->shi502_path;
    if (0 == _wcsicmp(g_szAdminShare, m_pInfo->shi502_netname))
    {
        m_pInfo->shi502_path = NULL;
    }

    if (SHARE_FLAG_ADDED == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: add (%ws)\n", m_pInfo->shi502_netname));
        ret = NetShareAdd(pszMachine, 502, (LPBYTE)m_pInfo, NULL);
    }
    else if (SHARE_FLAG_REMOVE == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: remove (%ws)\n", m_pInfo->shi502_netname));
        ret = NetShareDel(pszMachine, m_pInfo->shi502_netname, 0);
    }
    else if (SHARE_FLAG_MODIFY == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: modify (%ws)\n", m_pInfo->shi502_netname));
        DWORD parm_err;
        ret = NetShareSetInfo(pszMachine, m_pInfo->shi502_netname, 502, (LPBYTE)m_pInfo, &parm_err);
    }

    // Restore the original, in case of admin$
    m_pInfo->shi502_path = pszPathTmp;

    // Must refresh the cache of shares after all commits
    if (ret != NERR_Success)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: err = %d\n", ret));
    }

    return ret;
}

SHARE_INFO_502*
CShareInfo::GetShareInfo(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo;
}

PWSTR
CShareInfo::GetNetname(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_netname;
}

DWORD
CShareInfo::GetType(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_type;
}

PWSTR
CShareInfo::GetRemark(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_remark;
}

DWORD
CShareInfo::GetMaxUses(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_max_uses;
}

PWSTR
CShareInfo::GetPassword(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_passwd;
}

PWSTR
CShareInfo::GetPath(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_path;
}

PSECURITY_DESCRIPTOR
CShareInfo::GetSecurityDescriptor(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo->shi502_security_descriptor;
}

HRESULT
CShareInfo::SetNetname(
    IN PWSTR pszNetname
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetNetname() = '%ws'\n",
        pszNetname));

	if ( m_pInfo->shi502_netname )
		delete[] m_pInfo->shi502_netname;
    m_pInfo->shi502_netname = NewDup(pszNetname);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetType(
    IN DWORD dwType
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (dwType != m_pInfo->shi502_type)
    {
        // only take ownership and set the data if it's changed!

        if (!TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        appDebugOut((DEB_ITRACE,
            "CShareInfo::SetType(%ws) = %d\n",
            m_pInfo->shi502_netname,
            dwType));

        m_pInfo->shi502_type = dwType;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return S_OK;
}

HRESULT
CShareInfo::SetRemark(
    IN PWSTR pszRemark
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetRemark(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszRemark));

	if ( m_pInfo->shi502_remark )
		delete[] m_pInfo->shi502_remark;
    m_pInfo->shi502_remark = NewDup(pszRemark);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetMaxUses(
    IN DWORD dwMaxUses
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (dwMaxUses != m_pInfo->shi502_max_uses)
    {
        // only take ownership and set the data if it's changed!

        if (!TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        appDebugOut((DEB_ITRACE,
            "CShareInfo::SetMaxUses(%ws) = %d\n",
            m_pInfo->shi502_netname,
            dwMaxUses));

        m_pInfo->shi502_max_uses = dwMaxUses;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return S_OK;
}

HRESULT
CShareInfo::SetPassword(
    IN PWSTR pszPassword
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetPassword(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszPassword));

	if ( m_pInfo->shi502_passwd )
		delete[] m_pInfo->shi502_passwd;
    m_pInfo->shi502_passwd = NewDup(pszPassword);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetPath(
    IN PWSTR pszPath
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetPath(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszPath));

	if ( m_pInfo->shi502_path )
		delete[] m_pInfo->shi502_path;
    if (pszPath[0] == TEXT('\0'))
    {
        m_pInfo->shi502_path = NULL;    // so IPC$ and ADMIN$ work
    }
    else
    {
        m_pInfo->shi502_path = NewDup(pszPath);
    }

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetSecurityDescriptor(%ws) = ...\n",
        m_pInfo->shi502_netname));

	if ( m_pInfo->shi502_security_descriptor )
		::LocalFree( (BYTE*)m_pInfo->shi502_security_descriptor );
    m_pInfo->shi502_security_descriptor = CopySecurityDescriptor(pSecDesc);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}


HRESULT
CShareInfo::TransferSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::TransferSecurityDescriptor(%ws) = ...\n",
        m_pInfo->shi502_netname));

	if ( m_pInfo->shi502_security_descriptor )
		::LocalFree( (BYTE*)m_pInfo->shi502_security_descriptor );
    m_pInfo->shi502_security_descriptor = pSecDesc;

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

ULONG
CShareInfo::GetFlag(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    return m_flags;
}

VOID
CShareInfo::SetDirtyFlag(
    ULONG flag
    )
{
    CHECK_SIG(CShareInfo);

    m_flags = flag;
}

HRESULT
CShareInfo::Copy(
    IN SHARE_INFO_502* pInfo
    )
{
    CHECK_SIG(CShareInfo);

    // get a valid SHARE_INFO_502 structure...

    if (m_bOwn)
    {
        // delete what's already there

        appAssert(NULL != m_pInfo);

		if ( m_pInfo->shi502_netname )
			delete[] m_pInfo->shi502_netname;
		if ( m_pInfo->shi502_remark )
			delete[] m_pInfo->shi502_remark;
		if ( m_pInfo->shi502_path )
			delete[] m_pInfo->shi502_path;
		if ( m_pInfo->shi502_passwd )
	        delete[] m_pInfo->shi502_passwd;
		if ( m_pInfo->shi502_security_descriptor )
			::LocalFree( (BYTE*)m_pInfo->shi502_security_descriptor );
    }
    else
    {
        m_pInfo = new SHARE_INFO_502;
        if (NULL == m_pInfo)
        {
            return E_OUTOFMEMORY;
        }
    }

    appAssert(NULL != m_pInfo);

    m_bOwn = TRUE;

    m_pInfo->shi502_netname       = NULL;
    m_pInfo->shi502_type          = pInfo->shi502_type;
    m_pInfo->shi502_remark        = NULL;
    m_pInfo->shi502_permissions   = pInfo->shi502_permissions;
    m_pInfo->shi502_max_uses      = pInfo->shi502_max_uses;
    m_pInfo->shi502_path          = NULL;
    m_pInfo->shi502_passwd        = NULL;
    m_pInfo->shi502_reserved      = pInfo->shi502_reserved;
    m_pInfo->shi502_security_descriptor = NULL;

    if (NULL != pInfo->shi502_netname)
    {
        m_pInfo->shi502_netname = NewDup(pInfo->shi502_netname);
    }
    if (NULL != pInfo->shi502_remark)
    {
        m_pInfo->shi502_remark = NewDup(pInfo->shi502_remark);
    }
    if (NULL != pInfo->shi502_path)
    {
        m_pInfo->shi502_path = NewDup(pInfo->shi502_path);
    }
    if (NULL != pInfo->shi502_passwd)
    {
        m_pInfo->shi502_passwd = NewDup(pInfo->shi502_passwd);
    }

    if (NULL != pInfo->shi502_security_descriptor)
    {
        m_pInfo->shi502_security_descriptor = CopySecurityDescriptor(pInfo->shi502_security_descriptor);
    }

    return S_OK;
}

BOOL
CShareInfo::TakeOwn(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        return TRUE;    // already own the memory
    }

    SHARE_INFO_502* pInfo = new SHARE_INFO_502;
    if (NULL == pInfo)
    {
        return FALSE;
    }

    pInfo->shi502_type          = m_pInfo->shi502_type;
    pInfo->shi502_permissions   = m_pInfo->shi502_permissions;
    pInfo->shi502_max_uses      = m_pInfo->shi502_max_uses;
    pInfo->shi502_reserved      = 0;

    pInfo->shi502_netname = NULL;
    if (NULL != m_pInfo->shi502_netname)
    {
        pInfo->shi502_netname = NewDup(m_pInfo->shi502_netname);
    }

    pInfo->shi502_remark  = NULL;
    if (NULL != m_pInfo->shi502_remark)
    {
        pInfo->shi502_remark = NewDup(m_pInfo->shi502_remark);
    }

    pInfo->shi502_path    = NULL;
    if (NULL != m_pInfo->shi502_path)
    {
        pInfo->shi502_path = NewDup(m_pInfo->shi502_path);
    }

    pInfo->shi502_passwd  = NULL;
    if (NULL != m_pInfo->shi502_passwd)
    {
        pInfo->shi502_passwd = NewDup(m_pInfo->shi502_passwd);
    }

    pInfo->shi502_security_descriptor = NULL;
    if (NULL != m_pInfo->shi502_security_descriptor)
    {
        pInfo->shi502_security_descriptor = CopySecurityDescriptor(m_pInfo->shi502_security_descriptor);
    }

    m_pInfo = pInfo;
    m_bOwn = TRUE;

#if DBG == 1
    Dump(L"After TakeOwn");
#endif // DBG == 1

    return TRUE;
}


#if DBG == 1

VOID
CShareInfo::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CShareInfo);

    appDebugOut((DEB_TRACE,
        "CShareInfo::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t       This: 0x%08lx\n"
"\t       Info: 0x%08lx\n"
"\tOwn memory?: %ws\n"
"\t      Flags: %ws\n"
"\t Share name: %ws\n"
"\t       Type: %d\n"
"\t    Comment: %ws\n"
"\tPermissions: %d\n"
"\t   Max uses: %d\n"
"\t       Path: %ws\n"
"\t   Password: %ws\n"
"\t   Reserved: %d\n"
"\t   Security? %ws\n"
,
this,
m_pInfo,
m_bOwn ? L"yes" : L"no",
(m_flags == 0)
    ? L"none"
    : (m_flags == SHARE_FLAG_ADDED)
        ? L"added"
        : (m_flags == SHARE_FLAG_REMOVE)
            ? L"remove"
            : (m_flags == SHARE_FLAG_MODIFY)
                ? L"modify"
                : L"UNKNOWN!",
(NULL == m_pInfo->shi502_netname) ? L"none" : m_pInfo->shi502_netname,
m_pInfo->shi502_type,
(NULL == m_pInfo->shi502_remark) ? L"none" : m_pInfo->shi502_remark,
m_pInfo->shi502_permissions,
m_pInfo->shi502_max_uses,
(NULL == m_pInfo->shi502_path) ? L"none" : m_pInfo->shi502_path,
(NULL == m_pInfo->shi502_passwd) ? L"none" : m_pInfo->shi502_passwd,
m_pInfo->shi502_reserved,
(NULL == m_pInfo->shi502_security_descriptor) ? L"No" : L"Yes"
));

}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\xicon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       xicon.cxx
//
//  Contents:   Implementation of CSharesEI & CSharesEIA, implementations
//              of IExtractIcon
//
//  History:    14-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "xicon.hxx"
#include "resource.h"
#include "shares.h"

#include <strsafe.h>

STDMETHODIMP
CSharesEI::GetIconLocation(
    UINT uFlags,
    LPTSTR szIconFile,
    UINT cchMax,
    int* piIndex,
    UINT* pwFlags)
{
    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    StringCchCopy(szIconFile, cchMax, TEXT("shareui.dll"));

    WORD wIcon = 0;
    switch (m_bFlags)
    {
    case SHID_SHARE_1:
    case SHID_SHARE_2:
		if ((m_dwType & ~STYPE_SPECIAL) == STYPE_IPC)
		{
        	wIcon = IDI_IPC;
		}
		else
		{
        	wIcon = IDI_SHARE;
		}
        break;

#ifdef WIZARDS
    case SHID_SHARE_NW:
        wIcon = IDI_NWSHARE;
        break;

    case SHID_SHARE_MAC:
        wIcon = IDI_MACSHARE;
        break;

    case SHID_SHARE_ALL:
        wIcon = IDI_ALLSHARE;
        break;

    case SHID_SHARE_NEW:
        wIcon = IDI_NEWSHARE;
        break;
#endif // WIZARDS

    default: appAssert(!"Unknown share type");
    }

    *piIndex = -(int)wIcon;
    *pwFlags = GIL_PERINSTANCE;

    return S_OK;
}

STDMETHODIMP
CSharesEI::Extract(
    LPCTSTR pszFile,
    UINT   nIconIndex,
    HICON* phiconLarge,
    HICON* phiconSmall,
    UINT   nIconSize
    )
{
    return S_FALSE;
}


#ifdef UNICODE

STDMETHODIMP
CSharesEIA::GetIconLocation(
    UINT uFlags,
    LPSTR szIconFile,
    UINT cchMax,
    int* piIndex,
    UINT* pwFlags
    )
{
    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    StringCchCopyA(szIconFile, cchMax, "shareui.dll");

    WORD wIcon = 0;
    switch (m_bFlags)
    {
    case SHID_SHARE_1:
    case SHID_SHARE_2:
		if ((m_dwType & ~STYPE_SPECIAL) == STYPE_IPC)
		{
        	wIcon = IDI_IPC;
		}
		else
		{
        	wIcon = IDI_SHARE;
		}
        break;

#ifdef WIZARDS
    case SHID_SHARE_NW:
        wIcon = IDI_NWSHARE;
        break;

    case SHID_SHARE_MAC:
        wIcon = IDI_MACSHARE;
        break;

    case SHID_SHARE_ALL:
        wIcon = IDI_ALLSHARE;
        break;

    case SHID_SHARE_NEW:
        wIcon = IDI_NEWSHARE;
        break;
#endif // WIZARDS

    default: appAssert(!"Unknown share type");
    }

    *piIndex = -(int)wIcon;
    *pwFlags = GIL_PERINSTANCE;

    return S_OK;
}


STDMETHODIMP
CSharesEIA::Extract(
    LPCSTR pszFile,
    UINT   nIconIndex,
    HICON* phiconLarge,
    HICON* phiconSmall,
    UINT   nIconSize)
{
    return S_FALSE;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\shell.cpp ===
/*****************************************************************************\
    FILE: shell.cpp

    DESCRIPTION:
        Upgrade shell settings

    BryanSt 10/14/2000 (Bryan Starbuck)
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/


#include <windows.h>
#include <tchar.h>
#include <shlwapi.h>                // PathAppend
#include <wininet.h>                // IActiveDesktop
#include <shlobj.h>                 // IActiveDesktop
#include <shlobjp.h>                // IActiveDesktop
#include <shlguid.h>                // IActiveDesktop
#include <shlguidp.h>               // IActiveDesktop

#include "shmgdefs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\res.h ===
#pragma once

#define IDS_HTML_HELP_DIR                                   101

#define IDS_OC_QLAUNCHAPPDATAPATH                           11000
#define IDS_OC_IESHORTCUTNAME_SM                            11001
#define IDS_OC_IEDESCRIPTION                                11002
#define IDS_OC_IESHORTCUTNAME_QL                            11003
#define IDS_OC_OESHORTCUTNAME_SM                            11004
#define IDS_OC_OEDESCRIPTION                                11005
#define IDS_OC_OESHORTCUTNAME_QL                            11006
#define IDS_OC_IESHORTCUTNAME_SM64                          11007

#define IDB_IEACCESS                                          200
#define IDB_OEACCESS                                          201
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\profile.c ===
//*************************************************************
//  File name: profile.c
//
//  Description:   Fixes hard coded paths in the registry for
//                 special folder locations.  Also fixes security
//                 on a few registry keys.
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <tchar.h>
#include "shmgdefs.h"
#include "res.h"


//*************************************************************
//
//  ApplySecurityToRegistryTree()
//
//  Purpose:    Applies the passed security descriptor to the passed
//              key and all its descendants.  Only the parts of
//              the descriptor inddicated in the security
//              info value are actually applied to each registry key.
//
//  Parameters: RootKey   -     Registry key
//              pSD       -     Security Descriptor
//
//  Return:     ERROR_SUCCESS if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/19/95     ericflo    Created
//              6/16/96     bobday     Stolen directly from USERENV
//
//*************************************************************

DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD)

{
    DWORD Error;
    DWORD SubKeyIndex;
    LPTSTR SubKeyName;
    HKEY SubKey;
    DWORD cchSubKeySize = MAX_PATH + 1;



    //
    // First apply security
    //

    Error = RegSetKeySecurity(RootKey, DACL_SECURITY_INFORMATION, pSD);

    if (Error != ERROR_SUCCESS) {
        return Error;
    }


    //
    // Open each sub-key and apply security to its sub-tree
    //

    SubKeyIndex = 0;

    SubKeyName = GlobalAlloc (GPTR, cchSubKeySize * sizeof(TCHAR));

    if (!SubKeyName) {
        return GetLastError();
    }

    while (TRUE) {

        //
        // Get the next sub-key name
        //

        Error = RegEnumKey(RootKey, SubKeyIndex, SubKeyName, cchSubKeySize);


        if (Error != ERROR_SUCCESS) {

            if (Error == ERROR_NO_MORE_ITEMS) {

                //
                // Successful end of enumeration
                //

                Error = ERROR_SUCCESS;

            } else {

            }

            break;
        }


        //
        // Open the sub-key
        //

        Error = RegOpenKeyEx(RootKey,
                             SubKeyName,
                             0,
                             WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                             &SubKey);

        if (Error != ERROR_SUCCESS) {
            break;
        }

        //
        // Apply security to the sub-tree
        //

        Error = ApplySecurityToRegistryTree(SubKey, pSD);


        //
        // We're finished with the sub-key
        //

        RegCloseKey(SubKey);

        //
        // See if we set the security on the sub-tree successfully.
        //

        if (Error != ERROR_SUCCESS) {
            break;
        }

        //
        // Go enumerate the next sub-key
        //

        SubKeyIndex ++;
    }


    GlobalFree (SubKeyName);

    return Error;

}

//*************************************************************
//
//  MakeKeyOrTreeSecure()
//
//  Purpose:    Sets the attributes on the registry key and possibly sub-keys
//              such that Administrators and the OS can delete it and Everyone
//              else has read permission only (OR general read/write access)
//
//  Parameters: RootKey -   Key to set security on
//              fWrite  -   Allow write (or just read)
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/6/95     ericflo    Created
//              06/16/96    bobday     Ported from MakeFileSecure in USERENV
//
//*************************************************************

BOOL MakeKeyOrTreeSecure (HKEY RootKey, BOOL fWrite)
{
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWorld = SECURITY_WORLD_SID_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidEveryone = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    DWORD Error;
    DWORD dwAccess;



    if (fWrite) {
        dwAccess = KEY_ALL_ACCESS;
    } else {
        dwAccess = KEY_READ;
    }

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         goto Exit;
    }


    //
    // Get the World sid
    //

    if (!AllocateAndInitializeSid(&authWorld, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryone)) {

         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (3 * GetLengthSid (psidSystem)) +
            (3 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        goto Exit;
    }



    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccess, psidEveryone)) {
        goto Exit;
    }



    //
    // Now the inheritable ACEs
    //
    if (fWrite) {
        dwAccess = GENERIC_ALL;
    } else {
        dwAccess = GENERIC_READ;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccess, psidEveryone)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        goto Exit;
    }


    //
    // Set the security
    //
    Error = ApplySecurityToRegistryTree(RootKey, &sd);

    if (Error == ERROR_SUCCESS) {
        bRetVal = TRUE;
    }


Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }


    if (psidEveryone) {
        FreeSid(psidEveryone);
    }


    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}

void FixUserProfileSecurity( void )
{
    HKEY    hkeyPolicies;
    DWORD   Error;

    Error = RegOpenKeyEx( HKEY_CURRENT_USER,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"),
                          0,
                          WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                          &hkeyPolicies);

    if (Error == ERROR_SUCCESS)
    {
        MakeKeyOrTreeSecure(hkeyPolicies, FALSE);
        RegCloseKey(hkeyPolicies);
    }
}

void FixPoliciesSecurity( void )
{
    HKEY    hkeyPolicies;
    DWORD   Error, dwDisp;

    Error = RegCreateKeyEx( HKEY_CURRENT_USER,
                            TEXT("Software\\Policies"),
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                            NULL,
                            &hkeyPolicies,
                            &dwDisp);

    if (Error == ERROR_SUCCESS)
    {
        MakeKeyOrTreeSecure(hkeyPolicies, FALSE);
        RegCloseKey(hkeyPolicies);
    }
}

void SetSystemBitOnCAPIDir(void)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    TCHAR szAppData[MAX_PATH];
    DWORD FileAttributes;


    if (S_OK == SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_CURRENT, szAppData)){

        //
        // It is better to use tcscpy and tcscat. This is just a temp fix and it is build with
        // Unicode anyway. Not worth to include extra header file.
        // We do not check error case here. This is just a best effort. If we got error, so what?
        // MAX_PATH should be enough for these DIRs. Not worth to take care of \\?\ format.
        //

        if (SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), szAppData)) &&
            SUCCEEDED(StringCchCat(szPath, ARRAYSIZE(szPath), TEXT("\\Microsoft\\Protect"))))
        {
            FileAttributes = GetFileAttributes(szPath);
            if ((FileAttributes != -1) && ((FileAttributes & FILE_ATTRIBUTE_SYSTEM) == 0)) {
                FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
                SetFileAttributes(szPath, FileAttributes);
            }
        }

        if (SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), szAppData)) &&
            SUCCEEDED(StringCchCat(szPath, ARRAYSIZE(szPath), TEXT("\\Microsoft\\Crypto"))))
        {
            FileAttributes = GetFileAttributes(szPath);
            if ((FileAttributes != -1) && ((FileAttributes & FILE_ATTRIBUTE_SYSTEM) == 0)) {
                FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
                SetFileAttributes(szPath, FileAttributes);
            }
        }
    }

}

void SetScreensaverOnFriendlyUI()
{
    if (IsOS(OS_FRIENDLYLOGONUI)       &&
        IsOS(OS_FASTUSERSWITCHING))
    {
        HKEY hkey;

        if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_SET_VALUE, &hkey) == ERROR_SUCCESS)
        {
            TCHAR szTemp[MAX_PATH];
            DWORD cbTemp = sizeof(szTemp);

            RegSetValueEx(hkey, TEXT("ScreenSaveActive"), 0, REG_SZ, (BYTE*)TEXT("1"), sizeof(TEXT("1")));

            if (SHRegGetValue(hkey, NULL, TEXT("SCRNSAVE.EXE"), SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, szTemp, &cbTemp) != ERROR_SUCCESS || szTemp[0] == TEXT('\0'))
            {
                // if the user dosen't already have a screensaver set, then choose one for them!
                if (ExpandEnvironmentStrings(TEXT("%SystemRoot%\\System32\\logon.scr"), szTemp, ARRAYSIZE(szTemp)))
                {
                    RegSetValueEx(hkey, TEXT("SCRNSAVE.EXE"), 0, REG_SZ, (BYTE*)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
                }
            }

            RegCloseKey(hkey);
        }
    }
}


#define OTHERSIDS_EVERYONE             1
#define OTHERSIDS_POWERUSERS           2

BOOL MakeFileSecure (LPTSTR lpFile, DWORD dwOtherSids)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidUsers = NULL, psidPowerUsers = NULL;
    PSID  psidEveryOne = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bAddPowerUsersAce=TRUE;
    BOOL bAddEveryOneAce=FALSE;
    DWORD dwAccMask;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         goto Exit;
    }


    //
    // Get the users sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0, 0, 0, 0, 0, 0, &psidUsers)) {

         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin))  +
            (2 * GetLengthSid (psidUsers))  +
            sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    //
    // Get the power users sid, if required.
    // Don't fail if you don't get because it might not be available on DCs??
    //

    bAddPowerUsersAce = TRUE;
    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_POWER_USERS, 0, 0, 0, 0, 0, 0, &psidPowerUsers)) {

        bAddPowerUsersAce = FALSE;
    }

    if (bAddPowerUsersAce)
        cbAcl += (2 * GetLengthSid (psidPowerUsers)) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    //
    // Get the EveryOne sid, if required.
    //

    if (dwOtherSids & OTHERSIDS_EVERYONE) {
        bAddEveryOneAce = TRUE;
        if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryOne)) {

            goto Exit;
        }
    }

    if (bAddEveryOneAce)
        cbAcl += (2 * GetLengthSid (psidEveryOne)) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        goto Exit;
    }


    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*GENERIC_READ | GENERIC_EXECUTE,*/ psidUsers)) {
        goto Exit;
    }


    if (bAddPowerUsersAce) {

        //
        // By default give read permissions, otherwise give modify permissions
        //

        dwAccMask = (dwOtherSids & OTHERSIDS_POWERUSERS) ? (FILE_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER)):
                                                           (GENERIC_READ | GENERIC_EXECUTE);

        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*dwAccMask,*/ psidPowerUsers)) {
            goto Exit;
        }
    }

    if (bAddEveryOneAce) {
        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*GENERIC_READ | GENERIC_EXECUTE,*/ psidEveryOne)) {
            goto Exit;
        }
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*GENERIC_READ | GENERIC_EXECUTE,*/ psidUsers)) {
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    if (bAddPowerUsersAce) {
        aceIndex++;
        dwAccMask = (dwOtherSids & OTHERSIDS_POWERUSERS) ? (FILE_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER)):
                                                           (GENERIC_READ | GENERIC_EXECUTE);

        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*dwAccMask,*/ psidPowerUsers)) {
            goto Exit;
        }

        if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
            goto Exit;
        }

        lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    }

    if (bAddEveryOneAce) {
        aceIndex++;

        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, /*GENERIC_READ | GENERIC_EXECUTE,*/ psidEveryOne)) {
            goto Exit;
        }

        if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
            goto Exit;
        }

        lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        goto Exit;
    }


    //
    // Set the security
    //

    if (SetFileSecurity (lpFile, DACL_SECURITY_INFORMATION, &sd)) {
        bRetVal = TRUE;
    } else {
    }



Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }


    if (psidUsers) {
        FreeSid(psidUsers);
    }

    if ((bAddPowerUsersAce) && (psidPowerUsers)) {
        FreeSid(psidPowerUsers);
    }

    if ((bAddEveryOneAce) && (psidEveryOne)) {
        FreeSid(psidEveryOne);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}


#ifdef SHMG_DBG

void SHMGLogErrMsg(char *szErrMsg, DWORD dwError)
{
    DWORD   dwBytesWritten = 0;
    char    szMsg[256];
    static HANDLE  hLogFile = 0;

    if (!hLogFile) {
        hLogFile = CreateFile(_T("shmgrate.log"), GENERIC_WRITE,
                                FILE_SHARE_WRITE, 0,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 );
    }                                
                                                                   
    StringCchPrintf(szMsg, ARRAYSIZE(szMsg), "%s : (%X)\r\n", szErrMsg, dwError);
    WriteFile(hLogFile, szMsg, strlen(szMsg), &dwBytesWritten, 0);
}            

#endif

void
FixHtmlHelp(
    void
    )
{
    TCHAR AppDataPath[MAX_PATH*2];
    TCHAR HtmlHelpPath[MAX_PATH];

    SHMGLogErrMsg("FixHtmlHelp Called",0);
    
    if (SHGetFolderPath(NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_CURRENT, AppDataPath) == S_OK &&
        LoadString( GetModuleHandle(NULL), IDS_HTML_HELP_DIR, HtmlHelpPath, sizeof(HtmlHelpPath)/sizeof(WCHAR) ) > 0)
    {
        if (SUCCEEDED(StringCchCat(AppDataPath, ARRAYSIZE(AppDataPath), HtmlHelpPath)))
        {
            if (CreateDirectory( AppDataPath, NULL ))
            {
                if (!MakeFileSecure(AppDataPath,OTHERSIDS_EVERYONE|OTHERSIDS_POWERUSERS)) 
                    SHMGLogErrMsg("Could not apply security attributes", 0);
            }        
            else
                SHMGLogErrMsg("Could not create the directory", GetLastError());
        }
        else
            SHMGLogErrMsg("Could not compose the path -- path too long", 0);
                        
    } 
    else
       SHMGLogErrMsg("Could not get APPDATA path", GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\shmgrate.c ===
#include <windows.h>
#include <userenv.h>
#include <userenvp.h>
#include <shlwapi.h>
#include "shmgdefs.h"

enum {
    CMD_W95_TO_SUR,
    CMD_DAYTONA_CURSORS,
    CMD_FIX_CURSOR_PATHS,
    CMD_FIX_SPECIAL_FOLDERS,
    CMD_FIX_WINDOWS_PROFILE_SECURITY,
    CMD_FIX_USER_PROFILE_SECURITY,
    CMD_FIX_POLICIES_SECURITY,
    CMD_CVT_SCHEMES_TO_MULTIUSER,
    CMD_UPGRADE_NT4_PROFILE_TO_NT5,
    CMD_UPGRADE_SCHEMES_AND_NCMETRICS_TO_WIN2000,
    CMD_UPGRADE_SCHEMES_AND_NCMETRICS_FROM_WIN9X_TO_WIN2000,
    CMD_FIX_CAPI_DIR_ATTRIBUTES,
    CMD_MERGE_DESKTOP_AND_NORMAL_STREAMS,
    CMD_MOVE_AND_ADJUST_ICON_METRICS,
    CMD_FIX_HTML_HELP,
    CMD_SET_SCREENSAVER_FRIENDLYUI,
    CMD_OCINSTALL_FIXUP,

    //  enums from here down will run within OleInitialize/OleUnitialize
    CMD_OLE_REQUIRED_START = 10000,
    CMD_OCINSTALL_SHOW_IE,
    CMD_OCINSTALL_REINSTALL_IE,
    CMD_OCINSTALL_HIDE_IE,
    CMD_OCINSTALL_USER_CONFIG_IE,
    CMD_OCINSTALL_SHOW_OE,
    CMD_OCINSTALL_REINSTALL_OE,
    CMD_OCINSTALL_HIDE_OE,
    CMD_OCINSTALL_USER_CONFIG_OE,
    CMD_OCINSTALL_SHOW_VM,
    CMD_OCINSTALL_REINSTALL_VM,
    CMD_OCINSTALL_HIDE_VM,
} CMD_VALS;

int mystrcpy( LPTSTR pszOut, LPTSTR pszIn, TCHAR chTerm ) {
    BOOL fInQuote = FALSE;
    LPTSTR pszStrt = pszOut;

    while( *pszIn && !fInQuote && *pszIn != chTerm ) {
        if (*pszIn == TEXT('"')) {
            fInQuote = !fInQuote;
        }
        *pszOut++ = *pszIn++;
    }

    *pszOut = TEXT('\0');
    return (int)(pszOut - pszStrt);
}

BOOL HasPath( LPTSTR pszFilename ) {
    //
    // Special case null string so it won't get changed
    //
    if (*pszFilename == TEXT('\0'))
        return TRUE;

    for(; *pszFilename; pszFilename++ ) {
        if (*pszFilename == TEXT(':') || *pszFilename == TEXT('\\') || *pszFilename == TEXT('/')) {
            return TRUE;
        }
    }

    return FALSE;
}

void HandOffToShell32 (LPCSTR pcszCommand, LPCSTR pcszOptionalArgument)

{
    HINSTANCE hInstShell32 = LoadLibrary(TEXT("shell32"));
    if (hInstShell32 != NULL)
    {
        typedef HRESULT (*PFNFirstUserLogon) (LPCSTR pcszCommand, LPCSTR pcszOptionalArgument);

        PFNFirstUserLogon   pfnFirstUserLogon;

        // Call shell32!FirstUserLogon which is Ordinal230 defined in shell32.src.

        pfnFirstUserLogon = (PFNFirstUserLogon)GetProcAddress(hInstShell32, (LPCSTR)MAKEINTRESOURCE(230));
        if (pfnFirstUserLogon != NULL)
            pfnFirstUserLogon(pcszCommand, pcszOptionalArgument);
        FreeLibrary(hInstShell32);
    }
}

/*
 * Command Parser
 */
typedef struct {
    LPSTR  pszCmd;
    int    idCmd;
} CMD;

CMD aCmds[] = {
    { "W",                                   CMD_W95_TO_SUR       },
    { "Cvt-Curs",                            CMD_DAYTONA_CURSORS  },
    { "Fix-Curs",                            CMD_FIX_CURSOR_PATHS },
    { "Fix-Folders",                         CMD_FIX_SPECIAL_FOLDERS},
    { "Fix-Win-Security",                    CMD_FIX_WINDOWS_PROFILE_SECURITY},
    { "Fix-User-Security",                   CMD_FIX_USER_PROFILE_SECURITY},
    { "Fix-Policies-Security",               CMD_FIX_POLICIES_SECURITY},
    { "Cvt-Mouse-Schemes",                   CMD_CVT_SCHEMES_TO_MULTIUSER},
    { "UpgradeProfileNT4ToNT5",              CMD_UPGRADE_NT4_PROFILE_TO_NT5},
    { "UpgradeSchemesAndNcMetricsToWin2000", CMD_UPGRADE_SCHEMES_AND_NCMETRICS_TO_WIN2000},
    { "UpgradeSchemesAndNcMetricsFromWin9xToWin2000", CMD_UPGRADE_SCHEMES_AND_NCMETRICS_FROM_WIN9X_TO_WIN2000},
    { "FixCAPIDirAttrib",                    CMD_FIX_CAPI_DIR_ATTRIBUTES},
    { "MergeDesktopAndNormalStreams",        CMD_MERGE_DESKTOP_AND_NORMAL_STREAMS },
    { "MoveAndAdjustIconMetrics",            CMD_MOVE_AND_ADJUST_ICON_METRICS },
    { "Fix-HTML-Help",                       CMD_FIX_HTML_HELP },
    { "Set-Screensaver-On-FriendlyUI",       CMD_SET_SCREENSAVER_FRIENDLYUI },
    { "OCInstallShowIE",                     CMD_OCINSTALL_SHOW_IE },
    { "OCInstallReinstallIE",                CMD_OCINSTALL_REINSTALL_IE },
    { "OCInstallHideIE",                     CMD_OCINSTALL_HIDE_IE },
    { "OCInstallUserConfigIE",               CMD_OCINSTALL_USER_CONFIG_IE },
    { "OCInstallShowOE",                     CMD_OCINSTALL_SHOW_OE },
    { "OCInstallReinstallOE",                CMD_OCINSTALL_REINSTALL_OE },
    { "OCInstallHideOE",                     CMD_OCINSTALL_HIDE_OE },
    { "OCInstallUserConfigOE",               CMD_OCINSTALL_USER_CONFIG_OE },
//    { "OCInstallShowVM",                     CMD_OCINSTALL_SHOW_VM },
    { "OCInstallReinstallVM",                CMD_OCINSTALL_REINSTALL_VM },
//    { "OCInstallHideVM",                     CMD_OCINSTALL_HIDE_VM },
    { "OCInstallFixup",                      CMD_OCINSTALL_FIXUP },
};

#define C_CMDS  ARRAYSIZE(aCmds)

void __cdecl main( int cArgs, char **szArg) {
    int i;
    HRESULT hrOle = E_FAIL;

    SHMGLogErrMsg("main called with args", (DWORD)cArgs);

    if (cArgs < 2 || cArgs > 3)
        ExitProcess(1);

#ifdef SHMG_DBG
    for(i=1; i<cArgs; i++)
        SHMGLogErrMsg(szArg[i], (DWORD)i);
#endif        

    for( i = 0; i < C_CMDS && lstrcmpA( szArg[1], aCmds[i].pszCmd ) != 0; i++ );

    if (i >= C_CMDS)
        ExitProcess(1);

    if (aCmds[i].idCmd >= CMD_OLE_REQUIRED_START)
    {
        hrOle = OleInitialize(NULL);

        if (FAILED(hrOle))
        {
            ExitProcess(1);
        }
    }
    

    switch( aCmds[i].idCmd ) {

    case CMD_W95_TO_SUR:
        CvtDeskCPL_Win95ToSUR();
        break;

    case CMD_DAYTONA_CURSORS:
        CvtCursorsCPL_DaytonaToSUR();
        break;

    case CMD_FIX_CURSOR_PATHS:
        FixupCursorSchemePaths();
        break;

    case CMD_FIX_SPECIAL_FOLDERS:
        ResetUserSpecialFolderPaths();
        break;

    case CMD_FIX_WINDOWS_PROFILE_SECURITY:
        ASSERT(FALSE); // no longer supported
        break;

    case CMD_FIX_USER_PROFILE_SECURITY:
        FixUserProfileSecurity();
        break;

    case CMD_FIX_POLICIES_SECURITY:
        FixPoliciesSecurity();
        break;

    case CMD_CVT_SCHEMES_TO_MULTIUSER:
        CvtCursorSchemesToMultiuser();
        break;

    case CMD_UPGRADE_NT4_PROFILE_TO_NT5:
        MigrateNT4ToNT5();
        break;

    case CMD_UPGRADE_SCHEMES_AND_NCMETRICS_TO_WIN2000:
        UpgradeSchemesAndNcMetricsToWin2000();
        break;

    case CMD_UPGRADE_SCHEMES_AND_NCMETRICS_FROM_WIN9X_TO_WIN2000:
        UpgradeSchemesAndNcMetricsFromWin9xToWin2000(cArgs > 2 ? szArg[2] : NULL);
        break;

    case CMD_FIX_CAPI_DIR_ATTRIBUTES:
        SetSystemBitOnCAPIDir();
        break;

    case CMD_MERGE_DESKTOP_AND_NORMAL_STREAMS:
    case CMD_MOVE_AND_ADJUST_ICON_METRICS:
        HandOffToShell32(szArg[1], cArgs > 2 ? szArg[2] : NULL);
        break;

    case CMD_FIX_HTML_HELP:
        FixHtmlHelp();
        break;

    case CMD_SET_SCREENSAVER_FRIENDLYUI:
        SetScreensaverOnFriendlyUI();
        break;

    case CMD_OCINSTALL_FIXUP:
        FixupOptionalComponents();
        break;

    case CMD_OCINSTALL_SHOW_IE:
        ShowHideIE(TRUE, FALSE, TRUE);
        break;
        
    case CMD_OCINSTALL_REINSTALL_IE:
        ShowHideIE(TRUE, TRUE, TRUE);
        break;
        
    case CMD_OCINSTALL_HIDE_IE:
        ShowHideIE(FALSE, FALSE, TRUE);
        break;
        
    case CMD_OCINSTALL_USER_CONFIG_IE:
        UserConfigIE();
        break;
        
    case CMD_OCINSTALL_SHOW_OE:
        ShowHideOE(TRUE, FALSE, TRUE);
        break;
        
    case CMD_OCINSTALL_REINSTALL_OE:
        ShowHideOE(TRUE, TRUE, TRUE);
        break;
        
    case CMD_OCINSTALL_HIDE_OE:
        ShowHideOE(FALSE, FALSE, TRUE);
        break;
        
    case CMD_OCINSTALL_USER_CONFIG_OE:
        UserConfigOE();
        break;
        
    case CMD_OCINSTALL_SHOW_VM:
        //  Do nothing...
        break;
        
    case CMD_OCINSTALL_REINSTALL_VM:
        ReinstallVM();
        break;
        
    case CMD_OCINSTALL_HIDE_VM:
        //  Do nothing...
        break;

    default:
        ExitProcess(2);
    }

    if (SUCCEEDED(hrOle))
    {
        OleUninitialize();
    }



    ExitProcess(0);
}



#ifdef SHMG_DBG
/***************************************************************************\
*
*     FUNCTION: FmtSprintf( DWORD id, ... );
*
*     PURPOSE:  sprintf but it gets the pattern string from the message rc.
*
* History:
* 03-May-1993 JonPa         Created it.
\***************************************************************************/
TCHAR g_szDbgBuffer[16384];
char g_szDbgBufA[16384];
void Dprintf( LPTSTR pszFmt, ... ) {
    DWORD cb;
    LPVOID psz = g_szDbgBuffer;
    va_list marker;

    va_start( marker, pszFmt );

    StringCchVPrintf(g_szDbgBuffer, ARRAYSIZE(g_szDbgBuffer), pszFmt, marker);
    OutputDebugString(g_szDbgBuffer);


#ifdef UNICODE
    cb = WideCharToMultiByte(CP_ACP, 0, g_szDbgBuffer, -1, g_szDbgBufA, sizeof(g_szDbgBufA), NULL, NULL);
    psz = g_szDbgBufA;
#else
    cb = lstrlen(g_szDbgBuffer) * sizeof(TCHAR);
#endif

    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), psz, cb, &cb, NULL);

    va_end( marker );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\shmgdefs.h ===
#include <debug.h>

#define NO_SHLWAPI_STRFCNS
#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_STREAM
#define NO_SHLWAPI_GDI
#include <shlwapi.h>

#define STRSAFE_LIB
#include <strsafe.h>

#define ARRAYSIZE(s)    (sizeof(s) / (sizeof(s[0])))
#define SIZEOF(s)       sizeof(s)

/*
 * Common utility functions
 */
BOOL HasPath( LPTSTR pszFilename );
int mystrcpy( LPTSTR pszOut, LPTSTR pszIn, TCHAR chTerm );


/*
 * Conversion Routines
 */
void CvtDeskCPL_Win95ToSUR( void );
void CvtCursorsCPL_DaytonaToSUR( void );
void FixupCursorSchemePaths( void );
void FixUserProfileSecurity( void );
void FixPoliciesSecurity( void );
void CvtCursorSchemesToMultiuser( void );
void FixGradientColors( void );
void UpgradeSchemesAndNcMetricsToWin2000( void );
void UpgradeSchemesAndNcMetricsFromWin9xToWin2000(char *pszUserKey);
void SetSystemBitOnCAPIDir(void);
void FixHtmlHelp(void);
void SetScreensaverOnFriendlyUI();

EXTERN_C void UserConfigIE();
EXTERN_C void UserConfigOE();
EXTERN_C void ShowHideIE(BOOL fShow, BOOL fForceAssociations, BOOL fMayRunPerUserConfig);
EXTERN_C void ShowHideOE(BOOL fShow, BOOL fForceAssociations, BOOL fMayRunPerUserConfig);
EXTERN_C void ReinstallVM();
EXTERN_C void FixupOptionalComponents();

#ifdef SHMG_DBG
    void Dprintf( LPTSTR pszFmt, ... );
#   define DPRINT(p)   Dprintf p
#   define SHMG_DBG    1
void SHMGLogErrMsg(char *szErrMsg, DWORD dwError);

#else

#define DPRINT(p)
#define SHMGLogErrMsg(x, y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\shmcvt1.c ===
#include <windows.h>
#include <winuserp.h>
#include <tchar.H>
#include <stdio.h>
#include "shmgdefs.h"
#include <regstr.h>

// structure used to store a scheme in the registry
#define SCHEME_VERSION_16 1
#define LF_FACESIZE16    32

#pragma pack(1)
typedef struct {
    SHORT   lfHeight;
    SHORT   lfWidth;
    SHORT   lfEscapement;
    SHORT   lfOrientation;
    SHORT   lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE16];
} LOGFONT16;

typedef LOGFONT16 *LPLOGFONT16;

typedef struct {
    SHORT version;
    NONCLIENTMETRICSA ncm;
    LOGFONT16 lfIconTitle;
    COLORREF rgb[COLOR_MAX];
} SCHEMEDATA16;

typedef SCHEMEDATA16 *PSCHEMEDATA16;
#pragma pack()

// structure used to store a scheme in the registry
#define SCHEME_VERSION_NT 2

typedef struct {
    SHORT version;
    WORD  wDummy;           // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX];
} SCHEMEDATAW;

typedef SCHEMEDATAW *PSCHEMEDATAW;

typedef TCHAR FILEPATH[MAX_PATH];

typedef struct tagSZNODE {
    TCHAR *psz;
    struct tagSZNODE *next;
} SZNODE;

TCHAR szApprSchemes[] = TEXT("Control Panel\\Appearance\\Schemes");
TCHAR szNTCsrSchemes[] = TEXT("Control Panel\\Cursor Schemes");
TCHAR szWinCsrSchemes[] = TEXT("Control Panel\\Cursors\\Schemes");
TCHAR szSystemRoot[] = TEXT("%SystemRoot%\\System32\\");

const TCHAR szWinCursors[] = TEXT("Control Panel\\Cursors");
const TCHAR szSchemes[] = TEXT("Schemes");
const TCHAR szDaytonaSchemes[] = REGSTR_PATH_SETUP TEXT("\\Control Panel\\Cursors\\Schemes");

#define ID_NONE_SCHEME  0       //
#define ID_USER_SCHEME  1       // These are the possible values of "Scheme Source" as define for the
#define ID_OS_SCHEME    2       //  mouse pointer applet

/***********************************************************************\
*
* CONVERSION ROUTINES
*
* NOTE: Although ConvertLF16to32 appears to be identical to ConvertLFAtoW
*       they are actually different once compiled:  the size of the individual
*       fields for a LOGFONT16 and a LOGFONTA are different.
*
\***********************************************************************/

void ConvertLF16to32( LPLOGFONTW plfwDst, UNALIGNED LOGFONT16 *plfaSrc ) {
    plfwDst->lfHeight           = plfaSrc->lfHeight;
    plfwDst->lfWidth            = plfaSrc->lfWidth;
    plfwDst->lfEscapement       = plfaSrc->lfEscapement;
    plfwDst->lfOrientation      = plfaSrc->lfOrientation;
    plfwDst->lfWeight           = plfaSrc->lfWeight;
    plfwDst->lfItalic           = plfaSrc->lfItalic;
    plfwDst->lfUnderline        = plfaSrc->lfUnderline;
    plfwDst->lfStrikeOut        = plfaSrc->lfStrikeOut;
    plfwDst->lfCharSet          = plfaSrc->lfCharSet;
    plfwDst->lfOutPrecision     = plfaSrc->lfOutPrecision;
    plfwDst->lfClipPrecision    = plfaSrc->lfClipPrecision;
    plfwDst->lfQuality          = plfaSrc->lfQuality;
    plfwDst->lfPitchAndFamily   = plfaSrc->lfPitchAndFamily;

    MultiByteToWideChar(CP_ACP, 0, plfaSrc->lfFaceName, -1, plfwDst->lfFaceName, ARRAYSIZE(plfwDst->lfFaceName));
}

void ConvertLFAtoW( LPLOGFONTW plfwDst, UNALIGNED LOGFONTA *plfaSrc ) {
    plfwDst->lfHeight           = plfaSrc->lfHeight;
    plfwDst->lfWidth            = plfaSrc->lfWidth;
    plfwDst->lfEscapement       = plfaSrc->lfEscapement;
    plfwDst->lfOrientation      = plfaSrc->lfOrientation;
    plfwDst->lfWeight           = plfaSrc->lfWeight;
    plfwDst->lfItalic           = plfaSrc->lfItalic;
    plfwDst->lfUnderline        = plfaSrc->lfUnderline;
    plfwDst->lfStrikeOut        = plfaSrc->lfStrikeOut;
    plfwDst->lfCharSet          = plfaSrc->lfCharSet;
    plfwDst->lfOutPrecision     = plfaSrc->lfOutPrecision;
    plfwDst->lfClipPrecision    = plfaSrc->lfClipPrecision;
    plfwDst->lfQuality          = plfaSrc->lfQuality;
    plfwDst->lfPitchAndFamily   = plfaSrc->lfPitchAndFamily;

    MultiByteToWideChar(CP_ACP, 0, plfaSrc->lfFaceName, -1, plfwDst->lfFaceName, ARRAYSIZE(plfwDst->lfFaceName));
}



void ConvertNCMAtoW( LPNONCLIENTMETRICSW pncmwDst, UNALIGNED NONCLIENTMETRICSA *pncmaSrc ) {
    pncmwDst->cbSize = sizeof(*pncmwDst);
    pncmwDst->iBorderWidth      = pncmaSrc->iBorderWidth;
    pncmwDst->iScrollWidth      = pncmaSrc->iScrollWidth;
    pncmwDst->iScrollHeight     = pncmaSrc->iScrollHeight;
    pncmwDst->iCaptionWidth     = pncmaSrc->iCaptionWidth;
    pncmwDst->iCaptionHeight    = pncmaSrc->iCaptionHeight;
    pncmwDst->iSmCaptionWidth   = pncmaSrc->iSmCaptionWidth;
    pncmwDst->iSmCaptionHeight  = pncmaSrc->iSmCaptionHeight;
    pncmwDst->iMenuWidth        = pncmaSrc->iMenuWidth;
    pncmwDst->iMenuHeight       = pncmaSrc->iMenuHeight;


    ConvertLFAtoW( &(pncmwDst->lfCaptionFont),   &(pncmaSrc->lfCaptionFont) );
    ConvertLFAtoW( &(pncmwDst->lfSmCaptionFont), &(pncmaSrc->lfSmCaptionFont) );
    ConvertLFAtoW( &(pncmwDst->lfMenuFont),      &(pncmaSrc->lfMenuFont) );
    ConvertLFAtoW( &(pncmwDst->lfStatusFont),    &(pncmaSrc->lfStatusFont) );
    ConvertLFAtoW( &(pncmwDst->lfMessageFont),   &(pncmaSrc->lfMessageFont) );
}

void CvtDeskCPL_Win95ToSUR( void ) {
    HKEY hk = NULL;
    DWORD cchClass, cb, cch, cSubk, cchMaxSubk, cchMaxCls, iVal, cchMaxVName;
    DWORD cbMaxVData, cbSecDes, dwType;
    FILETIME pfLstWr;
    TCHAR szClass[4];
    LONG lRet;
    PVOID pvVData = NULL;
    LPTSTR pszVName = NULL;
    LONG erc;
    FILETIME ftLstWr;

    // Open the key (Appearence\Schemes)
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szApprSchemes, 0, KEY_READ | KEY_WRITE, &hk) != ERROR_SUCCESS)
        goto ErrorExit;


    cchClass = ARRAYSIZE(szClass);
    erc = RegQueryInfoKey(hk, szClass, &cchClass, NULL, &cSubk, &cchMaxSubk,
            &cchMaxCls, &iVal, &cchMaxVName, &cbMaxVData, &cbSecDes, &ftLstWr);

    if( erc != ERROR_SUCCESS && erc != ERROR_MORE_DATA)
        goto ErrorExit;

    cchMaxVName += 1;

    pszVName = LocalAlloc(LMEM_FIXED, cchMaxVName * SIZEOF(TCHAR));
    pvVData  = LocalAlloc(LMEM_FIXED, cbMaxVData);

    if (pvVData == NULL || pszVName == NULL)
        goto ErrorExit;

    // for each value in the key
    iVal = 0;

    for(;;) {
        PSCHEMEDATA16 psda;
        SCHEMEDATAW  sdw;

        cch = cchMaxVName;
        cb  = cbMaxVData;
        if( RegEnumValue(hk, iVal++, pszVName, &cch, NULL, &dwType, pvVData, &cb  ) != ERROR_SUCCESS )
            break;

        // check if it has been converted yet
        psda = pvVData;
        if (psda->version != SCHEME_VERSION_16)
            continue;

        // if not, convert ANSI font names to UNICODE and tag the structure
        // as converted
        sdw.version = SCHEME_VERSION_NT;
        sdw.wDummy = 0;
        ASSERT(sizeof(psda->rgb) == sizeof(sdw.rgb));
        CopyMemory(sdw.rgb, psda->rgb, sizeof(sdw.rgb));
        ConvertNCMAtoW( &(sdw.ncm), &(psda->ncm) );
        ConvertLF16to32( &(sdw.lfIconTitle), &(psda->lfIconTitle) );

        // write the new data back out
        RegSetValueEx(hk, pszVName, 0L, dwType, (LPBYTE)&sdw, SIZEOF(sdw));
    }

ErrorExit:
    // close the key
    if (hk)
        RegCloseKey(hk);

    if (pvVData)
        LocalFree(pvVData);

    if (pszVName)
        LocalFree(pszVName);

}

#ifdef LATER
void CvtDeskCPL_DaytonaToSur( void ) {
}
#endif

//
// NOTE!  These enums MUST be in the same order that the names will appear in the registry string
enum { arrow,help,appstart,wait,cross,ibeam,pen,no,sizens,sizewe,sizenwse,sizenesw,move,altsel, C_CURSORS } ID_CURSORS;

FILEPATH aszCurs[C_CURSORS];
TCHAR    szOut[(C_CURSORS * (MAX_PATH+1)) + 1];

void CvtCursorsCPL_DaytonaToSUR( void ) {
    HKEY hkIn = NULL, hkOut = NULL;
    DWORD cchClass;
    LONG erc;
    DWORD dwType;
    DWORD cSubk;
    DWORD cchMaxSubk;
    DWORD cchMaxCls;
    DWORD iVal;
    DWORD cchMaxVName;
    DWORD cbMaxVData;
    DWORD cbSecDes;
    FILETIME ftLstWr;
    DWORD cch;
    DWORD cb;
    TCHAR szClass[4];
    PVOID pvVData = NULL;
    LPTSTR pszVName = NULL;

    // Open the source registry key (Cursor Schemes)
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szNTCsrSchemes, 0, KEY_READ, &hkIn) != ERROR_SUCCESS)
        goto ErrorExit;

    // Open/create the dest registry key (Cursors\Schemes)
    if (RegCreateKeyEx(HKEY_CURRENT_USER, szWinCsrSchemes, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hkOut, NULL) != ERROR_SUCCESS) {
        goto ErrorExit;
    }

    // for each value in the source key
    cchClass = ARRAYSIZE(szClass);
    erc = RegQueryInfoKey(hkIn, szClass, &cchClass, NULL, &cSubk, &cchMaxSubk,
            &cchMaxCls, &iVal, &cchMaxVName, &cbMaxVData, &cbSecDes, &ftLstWr);

    if( erc != ERROR_SUCCESS && erc != ERROR_MORE_DATA)
        goto ErrorExit;

    cchMaxVName += 1;

    pszVName = LocalAlloc(LMEM_FIXED, cchMaxVName * SIZEOF(TCHAR));
    pvVData  = LocalAlloc(LMEM_FIXED, cbMaxVData + sizeof(TCHAR));

    if (pvVData == NULL || pszVName == NULL)
        goto ErrorExit;

    iVal = 0;

    for(;;) {
        DWORD cbData;
        LPTSTR pszOut;
        int   i;

        cch = cchMaxVName;
        cb  = cbMaxVData;

        if( RegEnumValue(hkIn, iVal++, pszVName, &cch, NULL, &dwType, pvVData, &cb  ) != ERROR_SUCCESS )
            break;

        // if the name already exists in the new key then skip this one
        if (RegQueryValueEx(hkOut, pszVName, NULL, NULL, NULL, &cbData ) == ERROR_SUCCESS && cbData != 0)
            continue;

        if (dwType != REG_EXPAND_SZ && dwType != REG_SZ)
            continue;

        *(TCHAR *)((LPBYTE)pvVData+cb) = TEXT('\0');  // Make sure nul terminated

        // convert the data to SUR format
        for( i = 0; i < C_CURSORS; i++ ) {
            *aszCurs[i] = TEXT('\0');
        }

        //arrow,wait,appstart,no,ibeam,cross,ns,ew,nwse,nesw,move

        _stscanf(pvVData, TEXT("%[^,], %[^,], %[^,], %[^,], %[^,], %[^,], %[^,], %[^,], %[^,], %[^,]"),
                aszCurs[arrow],aszCurs[wait],aszCurs[appstart],aszCurs[no],
                aszCurs[ibeam],aszCurs[cross],aszCurs[sizens],aszCurs[sizewe],
                aszCurs[sizenwse],aszCurs[sizenesw],aszCurs[move]);

        szOut[0] = TEXT('\0');
        pszOut = szOut;

        for( i = 0; i < C_CURSORS; i++ ) {
            if (!HasPath(aszCurs[i]))
                pszOut += mystrcpy( pszOut, szSystemRoot, TEXT('\0') );

            pszOut += mystrcpy( pszOut, aszCurs[i], TEXT('\0') );

            *pszOut++ = TEXT(',');
        }

        *(pszOut-1) = TEXT('\0');

        // write the new data back out
        RegSetValueEx(hkOut, pszVName, 0L, REG_EXPAND_SZ, (LPBYTE)szOut, (DWORD)(sizeof(TCHAR)*(pszOut - szOut)));
    }

ErrorExit:
    // close the registry keys
    if (hkIn)
        RegCloseKey(hkIn);

    if (hkOut)
        RegCloseKey(hkOut);

    if (pvVData)
        LocalFree(pvVData);

    if (pszVName)
        LocalFree(pszVName);
}

void FixupCursorSchemePaths( void ) {
    HKEY hk = NULL;
    DWORD cchClass, cb, cch, cSubk, cchMaxSubk, cchMaxCls, iVal, cchMaxVName;
    DWORD cbMaxVData, cbSecDes, dwType;
    FILETIME pfLstWr;
    TCHAR szClass[4];
    LONG lRet;
    PVOID pvVData = NULL;
    LPTSTR pszVName = NULL;
    LONG erc;
    FILETIME ftLstWr;

    // Open the key (Appearence\Schemes)
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szWinCsrSchemes, 0, KEY_READ | KEY_WRITE, &hk) != ERROR_SUCCESS)
        goto ErrorExit;


    cchClass = ARRAYSIZE(szClass);
    erc = RegQueryInfoKey(hk, szClass, &cchClass, NULL, &cSubk, &cchMaxSubk,
            &cchMaxCls, &iVal, &cchMaxVName, &cbMaxVData, &cbSecDes, &ftLstWr);

    if( erc != ERROR_SUCCESS && erc != ERROR_MORE_DATA)
        goto ErrorExit;

    cchMaxVName += 1;

    DPRINT(( TEXT("cchName:%d cbData:%d\n"), cchMaxVName, cbMaxVData ));
    pszVName = LocalAlloc(LMEM_FIXED, cchMaxVName * SIZEOF(TCHAR));
    pvVData  = LocalAlloc(LMEM_FIXED, cbMaxVData + sizeof(TCHAR));

    if (pvVData == NULL || pszVName == NULL)
        goto ErrorExit;

    // for each value in the key
    iVal = 0;

    for(;;) {
        LPTSTR pszIn, pszOut;
        BOOL fFixed;
        TCHAR szTmp[MAX_PATH];

        cch = cchMaxVName;
        cb  = cbMaxVData;
        DPRINT(( TEXT("\n\n>>>>>>>>>>>>>>>>>>>Getting scheme %d "), iVal ));
        if( RegEnumValue(hk, iVal++, pszVName, &cch, NULL, &dwType, pvVData, &cb  ) != ERROR_SUCCESS )
            break;

        if (dwType != REG_EXPAND_SZ && dwType != REG_SZ)
            continue;

        *(TCHAR *)((LPBYTE)pvVData+cb) = TEXT('\0');  // Make sure nul terminated

        // check if it has been converted yet
        DPRINT(( TEXT("Scheme : %s = [%s]"), pszVName, pvVData ));

        fFixed = FALSE;
        pszOut = szOut;

        pszIn = pvVData;
        pszIn--;    // prime pszIn for first comma skip

        do {
            pszIn++;    // skip over comma separator
            pszIn += mystrcpy( szTmp, pszIn, TEXT(',') );   // bump ptr by length of token

            DPRINT((TEXT("\n\t%s"), szTmp));

            if (!HasPath(szTmp)) {
                fFixed = TRUE;
                DPRINT((TEXT(" <fixed...")));
                pszOut += mystrcpy( pszOut, szSystemRoot, TEXT('\0') );
                DPRINT((TEXT(">")));
            }

            pszOut += mystrcpy( pszOut, szTmp, TEXT('\0') );

            *pszOut++ = TEXT(',');

#ifdef SHMG_DBG
            *pszOut = TEXT('\0');
            DPRINT((TEXT("\nszOut so far: '%s'"), szOut ));
#endif
        } while ( *pszIn );

        *(pszOut-1) = TEXT('\0');

        DPRINT((TEXT("\n\n******** Findal szOut: [%s]"), szOut ));

        // write the new data back out
        if (fFixed) {
            DPRINT((TEXT("  (Saving back to reg)")));
            RegSetValueEx(hk, pszVName, 0L, REG_EXPAND_SZ, (LPBYTE)szOut, (DWORD)(sizeof(TCHAR)*(pszOut - szOut)));
        }

    }

ErrorExit:

    DPRINT(( TEXT("\n\n **EXITING FN()**\n" )));

    // close the key
    if (hk)
        RegCloseKey(hk);

    if (pvVData)
        LocalFree(pvVData);

    if (pszVName)
        LocalFree(pszVName);


}

// this function will remove entries from HKCU\Control Panel\Cursors\Schemes which are identical to
// schemes found in HKLM\%Current Version%\Control Panel\Cursors\Schemes
//
//  HKCU\Control Panel\Cursors
//      This key contains the users currently selected cursor scheme
//  HKCU\Control Panel\Cursors "Scheme Source"
//      This is a new key which will be added if not present.  The key indicates if the currently
//      select user scheme is user defined or system defined.
//  HKCU\Control Panel\Cursors\Schemes <Scheme name> <file list>
//      This is the location for user defined schemes.  If any of these schemes have both the same
//      scheme name and the same file list as a system defined scheme then that key will be
//      removed from the user list.  If the currently selected cursor scheme is removed then
//      "Scheme Source" will be updated to reflect the new location.
//  HKLM\%Current Version%\Control Panel\Cursors\Schemes <Scheme name>
//      Under the new optional component model, optional components are installed on a per-machine
//      basis into this location instead of the old per-user basis.  This allows floating profiles
//      to use system pointer schemes on multiple machines and simplifies component installation.
void CvtCursorSchemesToMultiuser( void )
{
    HKEY hkOldCursors, hkOldSchemes;
    HKEY hkNewSchemes;
    DWORD iSchemeLocation;
    DWORD iType;
    TCHAR szDefaultScheme[MAX_PATH+1];
    const TCHAR szSchemeSource[] = TEXT("Scheme Source");
    SZNODE *pnHead = NULL;
    SZNODE *pnTail = NULL;

    // open a key to the original cursors location
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szWinCursors, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkOldCursors) == ERROR_SUCCESS)
    {
        DWORD len = sizeof( szDefaultScheme );
        if (SHRegGetValue(hkOldCursors, NULL, NULL, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, szDefaultScheme, &len ) != ERROR_SUCCESS)
        {
            szDefaultScheme[0] = TEXT('\0');    // if the default key isn't set, the user has the default cursors
        }

        // try to read the value of "Scheme Source"
        len = sizeof( iSchemeLocation );
        if ( RegQueryValueEx( hkOldCursors, szSchemeSource, 0, &iType, (BYTE *)&iSchemeLocation, &len )
                != ERROR_SUCCESS )
        {
            iSchemeLocation = ID_USER_SCHEME;  // if the value isn't there then it's a user scheme
            RegSetValueEx( hkOldCursors, szSchemeSource, 0, REG_DWORD, (BYTE *)&iSchemeLocation,
                           sizeof( iSchemeLocation ) );
        }

        // now open the schemes subkey, this is what we're interested in
        if (RegOpenKeyEx( hkOldCursors, szSchemes, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkOldSchemes ) == ERROR_SUCCESS )
        {
            TCHAR szOldKeyName[MAX_PATH+1];
            TCHAR szOldKeyValue[C_CURSORS*(MAX_PATH+1)+1];
            TCHAR szNewKeyValue[C_CURSORS*(MAX_PATH+1)+1];
            long  iLenName;       // the length of the name of the old key
            long  iLenValue;      // the length of the value of the old key
            DWORD iLenNewKey;     // the length of the new key's value
            int iIndex;

            // now we are ready to enum the user defined schemes, but first lets make sure we can
            // open the new location, if we can't open it then we bail out.
            if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, szDaytonaSchemes, 0, KEY_READ, &hkNewSchemes ) != ERROR_SUCCESS )
                goto bailOut;
            DPRINT(( TEXT("Opened key %s"), szDaytonaSchemes ));

            // now we start reading the new schemes
            for (iIndex = 0;;)
            {
                // read next scheme
                iLenName = ARRAYSIZE(szOldKeyName);      // these must be reset each time around
                iLenValue = sizeof( szOldKeyValue );
                if (RegEnumValue( hkOldSchemes, iIndex++, szOldKeyName, &iLenName, NULL, NULL,
                                  (BYTE *)szOldKeyValue, &iLenValue ) != ERROR_SUCCESS )
                {
                    // we fail if we are out of data, which means we're done
                    break;
                }
                else
                {
                    szOldKeyValue[ARRAYSIZE(szOldKeyValue)-1] = TEXT('\0'); // ensure NULL-terminated
                }
                DPRINT(( TEXT("Opened key: %s\n"), szOldKeyName ));

                // now we try to find a key with the same name in the new location
                iLenNewKey = sizeof( szNewKeyValue );
                if (SHRegGetValue(hkNewSchemes, NULL, szOldKeyName, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, szNewKeyValue, &iLenNewKey)
                        == ERROR_SUCCESS )
                {
                    // if the new key exists, compare the values
                    DPRINT(( TEXT("  Key exists in HKLM.\n") ));
                    DPRINT(( TEXT("    Old=%s\n    New=%s\n"), szOldKeyValue, szNewKeyValue ));

                    if ( lstrcmpi(szOldKeyValue, szNewKeyValue) == 0 )
                    {
                        // if the values are the same, see if this is the currently selected scheme
                        if ( lstrcmp(szOldKeyName, szDefaultScheme) == 0 )
                        {
                            // since we're going to delete the user defined scheme and the system scheme
                            // has the same name and value we simply change the value of "Scheme Source"
                            iSchemeLocation = ID_OS_SCHEME;
                            RegSetValueEx( hkOldCursors, szSchemeSource, 0, REG_DWORD, (unsigned char *)&iSchemeLocation,
                                           sizeof( iSchemeLocation ) );
                        }
                        // remove the user key
                        DPRINT(( TEXT("      Tagging user key for removal.\n") ));
                        if ( pnTail == NULL )
                        {
                            pnTail = (SZNODE *)LocalAlloc( LMEM_FIXED, sizeof( SZNODE ) );
                            pnHead = pnTail;
                            if (!pnTail)    // not enough memory
                                break;
                        }
                        else
                        {
                            pnTail->next = (SZNODE *)LocalAlloc( LMEM_FIXED, sizeof( SZNODE ) );
                            pnTail = pnTail->next;
                            if (!pnTail)    // not enough memory
                                break;
                        }
                        pnTail->next = NULL;
                        pnTail->psz = LocalAlloc( LMEM_FIXED, ARRAYSIZE(szOldKeyName) * sizeof(TCHAR) );
                        if (pnTail->psz)
                        {
                            StringCchCopy(pnTail->psz, ARRAYSIZE(szOldKeyName), szOldKeyName);
                        }
                        else
                        {
                            break; // not enough memory
                        }
                    }
                }
            }

            // If we tagged any keys for deletion they will be stored in our list
            while (pnHead)
            {
                if (pnHead->psz)    // if we ran out of memory, this could be NULL
                {
                    DPRINT(( TEXT("Deleting key %s\n"), pnHead->psz ));
                    RegDeleteValue( hkOldSchemes, pnHead->psz );
                    LocalFree( pnHead->psz ); // Clean up the list as we go
                }
                pnTail = pnHead;
                pnHead = pnHead->next;
                LocalFree( pnTail );    // Clean up as we go
            }

            // now we are finished removing the duplicate keys, clean up and exit
            RegCloseKey( hkNewSchemes );
bailOut:
            RegCloseKey( hkOldSchemes );
        }
        // else: no schemes are defined for current user so there's nothing to do

        RegCloseKey( hkOldCursors );
    }
    // else: no cursor key exists for current user so there's nothing to do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\schemnt5.c ===
///////////////////////////////////////////////////////////////////////////////
// schemnt5.c
//
// This component of shmgrate.exe is designed to upgrade the user's schemes
// and colors to the new values required for Windows 2000.  This work is
// coordinated with changes to the scheme data provided by Win2000 setup
// in the files hivedef.inx and hiveusd.inx.
//
// brianau 6/11/98
// brianau 2/18/99  - Updated for "MS Sans Serif"->"Microsoft Sans Serif"
//                    conversion.
// brianau 6/24/99  - Set gradient colors same as non-gradient colors in
//                    NT4 custom schemes.
//
#include <windows.h>
#include <winuserp.h>
#include <tchar.h>
#include <stdio.h>
#include <shlwapi.h>

#include "shmgdefs.h"

#ifndef COLOR_3DALTFACE
//
// This is not defined in winuser.h (looks like it should be).
// The desktop applet places this color at ordinal 25 in the
// order of colors.  There's a "hole" in the ordinal numbers
// defined in winuser.h between numbers 24 and 26 so I'm 
// assuming it's supposed to be COLOR_3DALTFACE.  Regardless,
// the number is valid for the arrays in this module.
//
#   define COLOR_3DALTFACE 25
#endif

//
// This string defines the new font to be used for the 
// NC fonts.  If you want to change the face name, this 
// is the only place a change is required.
//
#define STR_NEWNCFONT  TEXT("Tahoma")

//
// Defining this macro prevents any registry changes from being
// made. Used for development only.
//
// Undefine before flight.
//
//#define NO_REG_CHANGES 1
//
//
// Redefine a private version of COLOR_MAX macro (winuser.h)
// This code needs to stay in sync with Windows Setup and 
// desk.cpl, not what is defined in winuser.h.  Someone added
// two new colors to winuser.h which increased COLOR_MAX by 2
// which increased the size of SCHEMEDATA by 8 bytes.  This 
// caused us to write out 8 extra bytes to the registry so that
// desk.cpl no longer recognizes these entries.  Setup, desk.cpl
// and shmgrate need to stay in sync with respect to the size of 
// SCHEMEDATA. [brianau - 4/3/00]
//
#define MAX_COLORS (COLOR_GRADIENTINACTIVECAPTION + 1)
//
// This structure was taken from shell\ext\cpls\desknt5\lookdlg.c
// It's the definition the desktop applet uses for reading/writing
// scheme data to/from the registry.
//
typedef struct {
    SHORT version;
    WORD  wDummy;           // For alignment.
    NONCLIENTMETRICS ncm;
    LOGFONT lfIconTitle;
    COLORREF rgb[MAX_COLORS];
} SCHEMEDATA;


const TCHAR g_szRegKeySchemes[]      = TEXT("Control Panel\\Appearance\\Schemes");
const TCHAR g_szRegKeyMetrics[]      = TEXT("Control Panel\\Desktop\\WindowMetrics");
const TCHAR g_szRegKeyColors[]       = TEXT("Control Panel\\Colors");
const TCHAR g_szRegValRGB[]          = TEXT("255 255 255");
const TCHAR g_szMsSansSerif[]        = TEXT("MS Sans Serif");
const TCHAR g_szMicrosoftSansSerif[] = TEXT("Microsoft Sans Serif");
const TCHAR g_szCaptionFont[]        = TEXT("CaptionFont");
const TCHAR g_szSmCaptionFont[]      = TEXT("SmCaptionFont");
const TCHAR g_szMenuFont[]           = TEXT("MenuFont");
const TCHAR g_szStatusFont[]         = TEXT("StatusFont");
const TCHAR g_szMessageFont[]        = TEXT("MessageFont");
const TCHAR g_szIconFont[]           = TEXT("IconFont");
const TCHAR g_szNewNcFont[]          = STR_NEWNCFONT;

//
// Font Metric Item index values.  This enumeration represents the
// order of items in any global arrays associated with the
// non-client metric font items.
// These must stay in sync with the entries in g_rgpszFontMetrics[] 
// and g_rglfDefaults[].
//
enum FontMetricIndex { FMI_CAPTIONFONT,
                       FMI_SMCAPTIONFONT,
                       FMI_MENUFONT,
                       FMI_STATUSFONT,
                       FMI_MESSAGEFONT,
                       FMI_ICONFONT };
//
// Font metric reg value name strings.
// The order of these must match the order of the FontMetricIndex
// enumeration.
//
const LPCTSTR g_rgpszFontMetrics[] = { g_szCaptionFont,
                                       g_szSmCaptionFont,
                                       g_szMenuFont,
                                       g_szStatusFont,
                                       g_szMessageFont,
                                       g_szIconFont
                                     };
//
// Total number of window font metrics being considered.
//
#define NUM_NC_FONTS ARRAYSIZE(g_rgpszFontMetrics)
//
// Default LOGFONT data for NC fonts.
// Used if there's no NC font data present (i.e. clean US install).
// This data corresponds to the "Windows Standard" scheme on a clean 
// NT 5.0 installation modified with our desired changes.  
// These entries must be maintained in the order of the FontMetricIndex 
// enumeration.
//
// For reference, The LOGFONT structure is:
//
// struct LOGFONT {
//    LONG      lfHeight;
//    LONG      lfWidth;
//    LONG      lfEscapement;
//    LONG      lfOrientation;
//    LONG      lfWeight;
//    BYTE      lfItalic;
//    BYTE      lfUnderline;
//    BYTE      lfStrikeOut;
//    BYTE      lfCharSet;
//    BYTE      lfOutPrecision;
//    BYTE      lfClipPrecision;
//    BYTE      lfQuality;
//    BYTE      lfPitchAndFamily;
//    TCHAR     lfFaceName[LF_FACESIZE]; // LF_FACESIZE == 32.
// };
//
const LOGFONT g_rglfDefaults[NUM_NC_FONTS] = {

    { -11, 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // CAPTION
    { -11, 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // SMCAPTION
    { -11, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // MENU
    { -11, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // STATUS
    { -11, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }, // MESSAGE
    { -11, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, STR_NEWNCFONT }  // ICON
    };

//
// These are the elements represented in the "Control Panel\Colors"
// reg key.  The rgbValue member is the new color value we want
// to assign.  See UpdateElementColor() for usage.
//
const struct NcmColors
{
    LPCTSTR  pszName;   // Value name in "Control Panel\Colors" reg key.
    COLORREF rgbValue;  // The new color.

} g_rgWinStdColors[] = { 

    { TEXT("Scrollbar"),             0x00C8D0D4 }, // COLOR_SCROLLBAR
    { TEXT("Background"),            0x00A56E3A }, // COLOR_BACKGROUND
    { TEXT("ActiveTitle"),           0x006A240A }, // COLOR_ACTIVECAPTION
    { TEXT("InactiveTitle"),         0x00808080 }, // COLOR_INACTIVECAPTION
    { TEXT("Menu"),                  0x00C8D0D4 }, // COLOR_MENU
    { TEXT("Window"),                0x00FFFFFF }, // COLOR_WINDOW
    { TEXT("WindowFrame"),           0x00000000 }, // COLOR_WINDOWFRAME
    { TEXT("MenuText"),              0x00000000 }, // COLOR_MENUTEXT
    { TEXT("WindowText"),            0x00000000 }, // COLOR_WINDOWTEXT
    { TEXT("TitleText"),             0x00FFFFFF }, // COLOR_CAPTIONTEXT
    { TEXT("ActiveBorder"),          0x00C8D0D4 }, // COLOR_ACTIVEBORDER
    { TEXT("InactiveBorder"),        0x00C8D0D4 }, // COLOR_INACTIVEBORDER
    { TEXT("AppWorkspace"),          0x00808080 }, // COLOR_APPWORKSPACE
    { TEXT("Hilight"),               0x006A240A }, // COLOR_HIGHLIGHT
    { TEXT("HilightText"),           0x00FFFFFF }, // COLOR_HIGHLIGHTTEXT
    { TEXT("ButtonFace"),            0x00C8D0D4 }, // COLOR_BTNFACE
    { TEXT("ButtonShadow"),          0x00808080 }, // COLOR_BTNSHADOW
    { TEXT("GrayText"),              0x00808080 }, // COLOR_GRAYTEXT
    { TEXT("ButtonText"),            0x00000000 }, // COLOR_BTNTEXT
    { TEXT("InactiveTitleText"),     0x00C8D0D4 }, // COLOR_INACTIVECAPTIONTEXT
    { TEXT("ButtonHilight"),         0x00FFFFFF }, // COLOR_BTNHIGHLIGHT
    { TEXT("ButtonDkShadow"),        0x00404040 }, // COLOR_3DDKSHADOW
    { TEXT("ButtonLight"),           0x00C8D0D4 }, // COLOR_3DLIGHT
    { TEXT("InfoText"),              0x00000000 }, // COLOR_INFOTEXT
    { TEXT("InfoWindow"),            0x00E1FFFF }, // COLOR_INFOBK
    { TEXT("ButtonAlternateFace"),   0x00B5B5B5 }, // COLOR_3DALTFACE
    { TEXT("HotTrackingColor"),      0x00800000 }, // COLOR_HOTLIGHT
    { TEXT("GradientActiveTitle"),   0x00F0CAA6 }, // COLOR_GRADIENTACTIVECAPTION
    { TEXT("GradientInactiveTitle"), 0x00C0C0C0 }  // COLOR_GRADIENTINACTIVECAPTION
};



#ifdef NO_REG_CHANGES
void DumpLogFont(
    const LOGFONT *plf
    )
{
    DPRINT((TEXT("Dumping LOGFONT ----------------------------------\n")));
    DPRINT((TEXT("\tplf->lfHeight.........: %d\n"), plf->lfHeight));
    DPRINT((TEXT("\tplf->lfWidth..........: %d\n"), plf->lfWidth));
    DPRINT((TEXT("\tplf->lfEscapement.....: %d\n"), plf->lfEscapement));
    DPRINT((TEXT("\tplf->lfOrientation....: %d\n"), plf->lfOrientation));
    DPRINT((TEXT("\tplf->lfWeight.........: %d\n"), plf->lfWeight));
    DPRINT((TEXT("\tplf->lfItalic.........: %d\n"), plf->lfItalic));
    DPRINT((TEXT("\tplf->lfUnderline......: %d\n"), plf->lfUnderline));
    DPRINT((TEXT("\tplf->lfStrikeOut......: %d\n"), plf->lfStrikeOut));
    DPRINT((TEXT("\tplf->lfCharSet........: %d\n"), plf->lfCharSet));
    DPRINT((TEXT("\tplf->lfOutPrecision...: %d\n"), plf->lfOutPrecision));
    DPRINT((TEXT("\tplf->lfClipPrecision..: %d\n"), plf->lfClipPrecision));
    DPRINT((TEXT("\tplf->lfQuality........: %d\n"), plf->lfQuality));
    DPRINT((TEXT("\tplf->lfPitchAndFamily.: %d\n"), plf->lfPitchAndFamily));
    DPRINT((TEXT("\tplf->lfFaceName.......: \"%s\"\n"), plf->lfFaceName));
}


void DumpSchemeStructure(
    const SCHEMEDATA *psd
    )
{
    int i;

    DPRINT((TEXT("version..............: %d\n"), psd->version));
    DPRINT((TEXT("ncm.cbSize...........: %d\n"), psd->ncm.cbSize));
    DPRINT((TEXT("ncm.iBorderWidth.....: %d\n"), psd->ncm.iBorderWidth));
    DPRINT((TEXT("ncm.iScrollWidth.....: %d\n"), psd->ncm.iScrollWidth));
    DPRINT((TEXT("ncm.iScrollHeight....: %d\n"), psd->ncm.iScrollHeight));
    DPRINT((TEXT("ncm.iCaptionWidth....: %d\n"), psd->ncm.iCaptionWidth));
    DPRINT((TEXT("ncm.iSmCaptionWidth..: %d\n"), psd->ncm.iSmCaptionWidth));
    DPRINT((TEXT("ncm.iSmCaptionHeight.: %d\n"), psd->ncm.iSmCaptionHeight));
    DPRINT((TEXT("ncm.iMenuWidth.......: %d\n"), psd->ncm.iMenuWidth));
    DPRINT((TEXT("ncm.iMenuHeight......: %d\n"), psd->ncm.iMenuHeight));
    DPRINT((TEXT("ncm.lfCaptionFont:\n")));
    DumpLogFont(&psd->ncm.lfCaptionFont);
    DPRINT((TEXT("ncm.lfSmCaptionFont:\n")));
    DumpLogFont(&psd->ncm.lfSmCaptionFont);
    DPRINT((TEXT("ncm.lfMenuFont:\n")));
    DumpLogFont(&psd->ncm.lfMenuFont);
    DPRINT((TEXT("ncm.lfStatusFont:\n")));
    DumpLogFont(&psd->ncm.lfStatusFont);
    DPRINT((TEXT("ncm.lfMessageFont:\n")));
    DumpLogFont(&psd->ncm.lfMessageFont);
    DPRINT((TEXT("lfIconTitle:\n")));
    DumpLogFont(&psd->lfIconTitle);
    for (i = 0; i < ARRAYSIZE(psd->rgb); i++)
    {
        DPRINT((TEXT("Color[%2d] (%3d,%3d,%3d)\n"),
               i,
               GetRValue(psd->rgb[i]),
               GetGValue(psd->rgb[i]),
               GetBValue(psd->rgb[i])));
    }
}
#endif



//
// Retrieve a named color value for a given user.
//
DWORD
GetColorForUser(
    HKEY hkeyColors,
    LPCTSTR pszName,
    COLORREF *prgb
    )
{
    TCHAR szValue[ARRAYSIZE(g_szRegValRGB)];
    DWORD cbData = sizeof(szValue);

    DWORD dwResult = SHRegGetValue(hkeyColors, 
                                   NULL,
                                   pszName,
                                   SRRF_RT_REG_SZ | SRRF_NOEXPAND,
                                   NULL,
                                   (LPBYTE)szValue,
                                   &cbData);

    if (ERROR_SUCCESS == dwResult)
    {
        //
        // Values in the registry are in REG_SZ formatted as
        // "RRR GGG BBB" where RRR, GGG and BBB are byte values
        // expressed as ASCII text.
        //
        BYTE rgbTemp[3] = {0,0,0};
        LPTSTR pszTemp  = szValue;
        LPTSTR pszColor = szValue;
        int i;
        for (i = 0; i < ARRAYSIZE(rgbTemp); i++)
        {
            //
            // Skip any leading spaces.
            //
            while(*pszTemp && TEXT(' ') == *pszTemp)
                pszTemp++;
            //
            // Remember the start of this color value.
            //
            pszColor = pszTemp;
            //
            // Find the end of the current color value.
            //
            while(*pszTemp && TEXT(' ') != *pszTemp)
                pszTemp++;

            if (2 != i && TEXT('\0') == *pszTemp)
            {
                //
                // Nul character encountered before 3rd member of color
                // triplet was read.  Assume it's bogus data.
                //
                dwResult = ERROR_INVALID_DATA;
                DPRINT((TEXT("Invalid color data in registry \"%s\"\n"), szValue));
                break;
            }
            //
            // Nul-terminate this color value string and conver it to a number.
            //
            *pszTemp++ = TEXT('\0');
            rgbTemp[i] = (BYTE)StrToInt(pszColor);
        }
        //
        // Return color info as an RGB triplet.
        //
        *prgb = RGB(rgbTemp[0], rgbTemp[1], rgbTemp[2]);
    }
    else
    {
        DPRINT((TEXT("Error %d querying reg color value \"%s\"\n"), dwResult, pszName));
        dwResult = ERROR_INVALID_HANDLE;
    }
    return dwResult;
}


//
// Update a named color value for a specified user.
//
DWORD
UpdateColorForUser(
    HKEY hkeyColors,
    LPCTSTR pszName,
    COLORREF rgb
    )
{
    DWORD dwResult = ERROR_INVALID_PARAMETER;
    TCHAR szValue[ARRAYSIZE(g_szRegValRGB)];

    //
    // Convert RGB triplet to a text string for storage in the registry.
    //
    if (SUCCEEDED(StringCchPrintf(szValue, ARRAYSIZE(szValue), TEXT("%d %d %d"), GetRValue(rgb), GetGValue(rgb), GetBValue(rgb))))
    {
        //
        // Save it to the registry.
        //
        dwResult = RegSetValueEx(hkeyColors,
                                 pszName,
                                 0,
                                 REG_SZ,
                                 (CONST BYTE *)szValue,
                                 sizeof(szValue));
    }

    if (ERROR_SUCCESS != dwResult)
    {
        DPRINT((TEXT("Error %d setting color value \"%s\" to \"%s\"\n"), dwResult, pszName, szValue));
    }

    return dwResult;
}


DWORD
UpdateElementColor(
    HKEY hkeyColors,
    const int *rgiElements,
    int cElements
    )
{
    int i;
    for (i = 0; i < cElements; i++)
    {
        int iElement = rgiElements[i];
        UpdateColorForUser(hkeyColors, 
                           g_rgWinStdColors[iElement].pszName,
                           g_rgWinStdColors[iElement].rgbValue);
    }
    return ERROR_SUCCESS;
}

    

//
// Perform all color updates for a user's NCM colors.
// These are the new "softer" grays and blues.
// ChristoB provided the color values.
//
DWORD
UpdateColorsForUser(
    HKEY hkeyUser
    )
{
    HKEY hkeyColors;
    DWORD dwResult = RegOpenKeyEx(hkeyUser,
                                  g_szRegKeyColors,
                                  0,
                                  KEY_QUERY_VALUE | KEY_SET_VALUE,
                                  &hkeyColors);

    if (ERROR_SUCCESS == dwResult)
    {
        //
        // Update these if the 3D button color is 192,192,192.
        //
        const int rgFaceChanges[] = { COLOR_BTNFACE,
                                      COLOR_SCROLLBAR,
                                      COLOR_MENU,
                                      COLOR_ACTIVEBORDER,
                                      COLOR_INACTIVEBORDER,
                                      COLOR_3DDKSHADOW,
                                      COLOR_3DLIGHT };
        //
        // Update these if the active caption color is 0,0,128
        //
        const int rgCaptionChanges[] = { COLOR_ACTIVECAPTION,
                                         COLOR_HIGHLIGHT,
                                         COLOR_GRADIENTACTIVECAPTION,
                                         COLOR_GRADIENTINACTIVECAPTION };
        //
        // Update these if the desktop is 128,128,0 (seafoam green)
        //
        const int rgDesktopChanges[] = { COLOR_BACKGROUND };

        struct
        {
            int        iTest;               // COLOR_XXXXX value.
            COLORREF   rgbTest;             // Color value that triggers upgrade.
            const int *prgChanges;          // Array of elements to upgrade.
            int        cChanges;            // Number of elements to upgrade.

        } rgci [] = {{ COLOR_3DFACE,        0x00C0C0C0, rgFaceChanges,    ARRAYSIZE(rgFaceChanges)    },
                     { COLOR_ACTIVECAPTION, 0x00800000, rgCaptionChanges, ARRAYSIZE(rgCaptionChanges) },
                     { COLOR_BACKGROUND,    0x00808000, rgDesktopChanges, ARRAYSIZE(rgDesktopChanges) }};

        int i;
        COLORREF rgb;
        for (i = 0; i < ARRAYSIZE(rgci); i++)
        {
            int iTest        = rgci[i].iTest;
            COLORREF rgbTest = rgci[i].rgbTest;

            if (ERROR_SUCCESS == GetColorForUser(hkeyColors, g_rgWinStdColors[iTest].pszName, &rgb) &&
                rgbTest == rgb)
            {
                UpdateElementColor(hkeyColors, rgci[i].prgChanges, rgci[i].cChanges);
            }
        }
        RegCloseKey(hkeyColors);
    }
    else
    {
        DPRINT((TEXT("Error %d opening reg key \"%s\" for user.\n"), dwResult, g_szRegKeyColors));
    }

    return dwResult;
}


//
// Convert a font metric name to a member of the FontMetricIndex
// enumeration.  Used to index into g_rgpszFontMetrics[] and 
// g_rglfDefaults[].
// 
// i.e. Returns FMI_CAPTIONFONT for "CaptionFont".
//
int
FontMetricNameToIndex(
    LPCTSTR pszName
    )
{
    int i;
    for (i = 0; i < ARRAYSIZE(g_rgpszFontMetrics); i++)
    {
        if (0 == lstrcmp(pszName, g_rgpszFontMetrics[i]))
            return i;
    }
    return -1;
}


//
// When updating a font from "MS Sans Serif" to a TrueType font
// we want to ensure the font point size is 8pt or greater.
// So, if the current font face is "MS Sans Serif" and
// (-11 < lfHeight < 0) is true, we force the lfHeight
// to -11 which corresponds to 8pt.  The standard windows
// schemes incorrectly have the height of the icon font
// specified as -8 (6pt) when it should be -11 (8pt).
// The problem is that the smallest pt size supported by 
// MS Sans Serif is 8pt so even if the requested size is 6pt,
// you see 8pt.  Once we switch to Tahoma (a TrueType font),
// it can produce the requested 6pt size so that's what you
// see.  6pt is way too small for desktop icons.
// The default icon font size used by user32.dll is 8pt.  
// See code in ntuser\kernel\inctlpan.c CreateFontFromWinIni().
// 
void
CorrectTooSmallFont(
    LOGFONT *plf
    )
{
    if ((0 > (int)plf->lfHeight) && (-11 < (int)plf->lfHeight))
    {
        //
        // NT uses font height values.
        //
        plf->lfHeight = -11;
    }
    else if ((0 < (int)plf->lfHeight) && (8 > (int)plf->lfHeight))
    {
        //
        // Win9x uses font point sizes.
        //
        plf->lfHeight = 8;
    }
}



//
// Replace any LOGFONT members in a LOGFONT structure and write the data
// to the registry for a given nc font metric.
//
// If plf is NULL, a new LOGFONT with default data is written to 
// the registry for the metric value.
// If plf is non-NULL and the LOGFONT's facename is in the list of 
// facenames to be updated, the required substitutions are made and
// the LOGFONT data is replaced in the registry.
//
DWORD
UpdateNcFont(
    HKEY hkeyMetrics, 
    LPCTSTR pszValueName,
    const LOGFONT *plf
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    int iMetrics   = FontMetricNameToIndex(pszValueName);
    LOGFONT lfCopy;
    if (NULL == plf)
    {
        //
        // Use all default values.
        //
        plf = &g_rglfDefaults[iMetrics];
    }
    else
    {
        //
        // First see if this face name should be updated.
        //
        if (0 == lstrcmpi(plf->lfFaceName, g_szMsSansSerif))
        {
            //
            // Yep.  Update the face name string in the logfont.  
            // Also make sure that the point size is 8 or greater
            //
            lfCopy = *plf;
            CorrectTooSmallFont(&lfCopy);
            ASSERT(_tcslen(g_szNewNcFont) < ARRAYSIZE(lfCopy.lfFaceName));
            StringCchCopy(lfCopy.lfFaceName, ARRAYSIZE(lfCopy.lfFaceName), g_szNewNcFont);
            plf = &lfCopy;
        }
        else
        {
            plf = NULL;  // Don't update the LOGFONT.
        }
    }

    if (NULL != plf)
    {
#ifdef NO_REG_CHANGES    
        DumpLogFont(plf);
#else
        dwResult = RegSetValueEx(hkeyMetrics,
                                 pszValueName,
                                 0,
                                 REG_BINARY,
                                 (const LPBYTE)plf,
                                 sizeof(*plf));

        if (ERROR_SUCCESS != dwResult)
        {
            DPRINT((TEXT("Error %d setting NC font data for \"%s\"\n"), 
                   dwResult, pszValueName));
        }
#endif
    }
    return dwResult;
}


//
// Update the nc font metrics for a particular user key under HKEY_USERS.
// If a particular font metric exists, the required replacements will be performed.
// If a particular font metric doesn't exist, it is added with default information.
// Note that not all keys under HKEY_USERS contain WindowMetric information.
//
DWORD
UpdateWindowMetricsForUser(
    HKEY hkeyUser
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    HKEY hkeyMetrics;

    dwResult = RegOpenKeyEx(hkeyUser,
                            g_szRegKeyMetrics,
                            0,
                            KEY_QUERY_VALUE | KEY_SET_VALUE,
                            &hkeyMetrics);

    if (ERROR_SUCCESS == dwResult)
    {
        DWORD cbValue;
        DWORD dwType;
        LOGFONT lf;
        int i;

        for (i = 0; i < ARRAYSIZE(g_rgpszFontMetrics); i++)
        {
            LPCTSTR pszValueName = g_rgpszFontMetrics[i];
            //
            // Start out with plf as NULL.  If a LOGFONT doesn't exist
            // for this NC font, leaving plf as NULL will cause 
            // UpdateNcFont to create a new default LOGFONT entry for this
            // NC font.
            //
            LOGFONT *plf = NULL;

            cbValue = sizeof(lf);
            dwResult = RegQueryValueEx(hkeyMetrics,
                                       pszValueName,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)&lf,
                                       &cbValue);

            if (ERROR_SUCCESS == dwResult)
            {
                if (REG_BINARY == dwType)
                {
                    if (sizeof(lf) == cbValue)
                    {
                        //
                        // A LOGFONT already exists for this NC font.
                        // Passing it's address to UpdateNcFont will
                        // update the LOGFONT.
                        //
                        plf = &lf;
                    }
                }
            }
            dwResult = UpdateNcFont(hkeyMetrics, pszValueName, plf);
        }
    }
    else if (ERROR_FILE_NOT_FOUND == dwResult)
    {
        //
        // Some keys under HKEY_USERS don't have WindowMetric information.
        // Such cases are not processed but are still considered successful.
        //
        dwResult = ERROR_SUCCESS;
    }
    else
    {
        DPRINT((TEXT("Error %d opening key \"%s\"\n"), dwResult, g_szRegKeyMetrics));
    }
    return dwResult;
}


//
// Load a scheme's SCHEMEDATA from the registry, perform any necessary
// updates and re-write the data back to the registry.
//
DWORD
UpdateScheme(
    HKEY hkeySchemes, 
    LPCTSTR pszScheme
    )
{
    SCHEMEDATA sd;
    DWORD dwResult;
    DWORD dwType;
    DWORD cbsd = sizeof(sd);

    dwResult = RegQueryValueEx(hkeySchemes,
                               pszScheme,
                               NULL,
                               &dwType,
                               (LPBYTE)&sd,
                               &cbsd);

    if (ERROR_SUCCESS == dwResult)
    {
        if (REG_BINARY == dwType)
        {
            int i;

            struct LogFontInfo
            {
                DWORD iMetrics;
                LOGFONT *plf;

            } rglfi[] = {
                  { FMI_CAPTIONFONT,   &sd.ncm.lfCaptionFont   },
                  { FMI_SMCAPTIONFONT, &sd.ncm.lfSmCaptionFont },
                  { FMI_MENUFONT,      &sd.ncm.lfMenuFont      },
                  { FMI_STATUSFONT,    &sd.ncm.lfStatusFont    },
                  { FMI_MESSAGEFONT,   &sd.ncm.lfMessageFont   },
                  { FMI_ICONFONT,      &sd.lfIconTitle         },
                  };

            for (i = 0; i < ARRAYSIZE(rglfi); i++)
            {
                if (0 == lstrcmpi(rglfi[i].plf->lfFaceName, g_szMsSansSerif))
                {
                    //
                    // Ensure it's no smaller than 8pt.  Anything less
                    // than 8 pt is not readable on current displays.
                    //
                    CorrectTooSmallFont(rglfi[i].plf);
                    //
                    // Update the logfont's facename from 
                    // "MS Sans Serif" to "Microsoft Sans Serif".
                    //
                    ASSERT(_tcslen(g_szMicrosoftSansSerif) < ARRAYSIZE(rglfi[i].plf->lfFaceName));
                    StringCchCopy(rglfi[i].plf->lfFaceName, ARRAYSIZE(rglfi[i].plf->lfFaceName), g_szMicrosoftSansSerif);
                }
            }

            if (cbsd < sizeof(sd))
            {
                //
                // This is an NT4 custom scheme.
                //
                //   NT4->W2K custom schemes are not upgraded so they're still
                //            in NT4 format.  cbsd < sizeof(sd).
                //
                //   W9x->W2K custom schemes are upgraded by the Win9x migration
                //            process so they're already in W2K format.
                //            cbsd == sizeof(sd)
                // 
                // The scheme has no gradient colors defined.  We set them here to 
                // the same color as the corresponding non-gradient colors.  This
                // will result in solid-color caption bars for custom schemes.
                // Also update the hotlight color.
                //
                sd.rgb[COLOR_GRADIENTACTIVECAPTION]   = sd.rgb[COLOR_ACTIVECAPTION];
                sd.rgb[COLOR_GRADIENTINACTIVECAPTION] = sd.rgb[COLOR_INACTIVECAPTION];
                sd.rgb[COLOR_HOTLIGHT]                = sd.rgb[COLOR_ACTIVECAPTION];
            }

            dwResult = RegSetValueEx(hkeySchemes,
                                     pszScheme,
                                     0,
                                     REG_BINARY,
                                     (const LPBYTE)&sd,
                                     sizeof(sd));

            if (ERROR_SUCCESS != dwResult)
            {
                DPRINT((TEXT("Error %d saving new scheme \"%s\"\n"), dwResult, pszScheme));
            }
        }
        else
        {
            DPRINT((TEXT("Invalid data type %d for scheme \"%s\". Expected REG_BINARY.\n"), 
                   dwType, pszScheme));
        }
    }
    else
    {
        DPRINT((TEXT("Error %d querying scheme \"%s\"\n"), dwResult, pszScheme));
    }
    return dwResult;
}

//
// Handles all of the "scheme" related adjustments.
// 1. Converts "MS Sans Serif" to "Microsoft Sans Serif" in 
//    all schemes.  Also ensures we don't have any 6pt
//    Microsoft Sans Serif fonts used.
//
DWORD
UpdateDesktopSchemesForUser(
    HKEY hkeyUser
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    HKEY hkeySchemes;
    
    dwResult = RegOpenKeyEx(hkeyUser,
                            g_szRegKeySchemes,
                            0,
                            KEY_QUERY_VALUE | KEY_SET_VALUE,
                            &hkeySchemes);

    if (ERROR_SUCCESS == dwResult)
    {
        DWORD dwIndex = 0;
        TCHAR szValueName[MAX_PATH];
        DWORD cchValueName;
        DWORD type;
        while(ERROR_SUCCESS == dwResult)
        {
            cchValueName = ARRAYSIZE(szValueName);
            dwResult = RegEnumValue(hkeySchemes,
                                    dwIndex++,
                                    szValueName,
                                    &cchValueName,
                                    NULL,
                                    &type,
                                    NULL,
                                    NULL);

            if (ERROR_SUCCESS == dwResult)
            {
                //
                // Convert "MS Sans Serif" to "Microsoft Sans Serif" in ALL schemes
                //
                UpdateScheme(hkeySchemes, szValueName);
            }
        }
        RegCloseKey(hkeySchemes);
    }
    if (ERROR_FILE_NOT_FOUND == dwResult)
    {
        //
        // Not all subkeys under HKEY_USER have the 
        // Control Panel\Appearance\Schemes subkey.
        //
        dwResult = ERROR_SUCCESS;
    }

    return dwResult;
}



//
// Function used to upgrade schemes and non-client metrics on upgrades
// from Win9x and NT to Win2000.
// 
void 
UpgradeSchemesAndNcMetricsToWin2000ForUser(
    HKEY hkeyUser
    )
{
    DWORD dwResult = ERROR_SUCCESS;

    DPRINT((TEXT("Updating schemes and non-client metrics.\n")));
    //
    // Update gradient colors BEFORE making any other changes.  
    // This code is in gradient.c
    //
    FixGradientColors();

    dwResult = UpdateWindowMetricsForUser(hkeyUser);
    if (ERROR_SUCCESS != dwResult)
    {
        DPRINT((TEXT("Error %d updating non-client metrics for user\n"), dwResult));
    }
    dwResult = UpdateDesktopSchemesForUser(hkeyUser);
    if (ERROR_SUCCESS != dwResult)
    {
        DPRINT((TEXT("Error %d updating schemes for user\n"), dwResult));
    }
    dwResult = UpdateColorsForUser(hkeyUser);
    if (ERROR_SUCCESS != dwResult)
    {
        DPRINT((TEXT("Error %d updating color information for user\n"), dwResult));
    }

    DPRINT((TEXT("Update of schemes and non-client metrics completed.\n")));
}

//
// This version is called on an upgrade from NT->Win2000.
//
void 
UpgradeSchemesAndNcMetricsToWin2000(
    void
    )
{
    UpgradeSchemesAndNcMetricsToWin2000ForUser(HKEY_CURRENT_USER);
}


//
// On upgrades from Win9x we are passed a string value representing the 
// key under which we'll find the user's Control Panel\Appearance subkey.
// The string is in the form "HKCU\$$$".  We first translate the root key
// descriptor into a true root key then pass that root and the "$$$" 
// part onto RegOpenKeyEx.  This function takes that string and opens
// the associated hive key.
//
DWORD
OpenUserKeyForWin9xUpgrade(
    char *pszUserKeyA,
    HKEY *phKey
    )
{
    DWORD dwResult = ERROR_INVALID_PARAMETER;

    if (NULL != pszUserKeyA && NULL != phKey)
    {
        typedef struct {
            char *pszRootA;
            HKEY hKeyRoot;

        } REGISTRY_ROOTS, *PREGISTRY_ROOTS;

        static REGISTRY_ROOTS rgRoots[] = {
            { "HKLM",                 HKEY_LOCAL_MACHINE   },
            { "HKEY_LOCAL_MACHINE",   HKEY_LOCAL_MACHINE   },
            { "HKCC",                 HKEY_CURRENT_CONFIG  },
            { "HKEY_CURRENT_CONFIG",  HKEY_CURRENT_CONFIG  },
            { "HKU",                  HKEY_USERS           },
            { "HKEY_USERS",           HKEY_USERS           },
            { "HKCU",                 HKEY_CURRENT_USER    },
            { "HKEY_CURRENT_USER",    HKEY_CURRENT_USER    },
            { "HKCR",                 HKEY_CLASSES_ROOT    },
            { "HKEY_CLASSES_ROOT",    HKEY_CLASSES_ROOT    }
          };

        char szUserKeyA[MAX_PATH];      // For a local copy.
        char *pszSubKeyA = szUserKeyA;

        //
        // Make a local copy that we can modify.
        //
        if (SUCCEEDED(StringCchCopyA(szUserKeyA, ARRAYSIZE(szUserKeyA), pszUserKeyA)))
        {
            //
            // Find the backslash.
            //
            while(*pszSubKeyA && '\\' != *pszSubKeyA)
                pszSubKeyA++;

            if ('\\' == *pszSubKeyA)
            {
                HKEY hkeyRoot = NULL;
                int i;
                //
                // Replace backslash with nul to separate the root key and
                // sub key strings in our local copy of the original argument 
                // string.
                //
                *pszSubKeyA++ = '\0';
                //
                // Now find the true root key in rgRoots[].
                //
                for (i = 0; i < ARRAYSIZE(rgRoots); i++)
                {
                    if (0 == lstrcmpiA(rgRoots[i].pszRootA, szUserKeyA))
                    {
                        hkeyRoot = rgRoots[i].hKeyRoot;
                        break;
                    }
                }
                if (NULL != hkeyRoot)
                {
                    //
                    // Open the key.
                    //
                    dwResult = RegOpenKeyExA(hkeyRoot,
                                             pszSubKeyA,
                                             0,
                                             KEY_QUERY_VALUE, // this hkey is only used to open other sub-hkey's
                                             phKey);
                }
            }
        }
    }

    if (dwResult != ERROR_SUCCESS)
    {
        *phKey = NULL;
    }

    return dwResult;
}


//
// This version is called on an upgrade from Win9x to Win2000.
//
void 
UpgradeSchemesAndNcMetricsFromWin9xToWin2000(
    char *pszUserKey
    )
{
    HKEY hkeyUser;
    DWORD dwResult = OpenUserKeyForWin9xUpgrade(pszUserKey, &hkeyUser);
    if (ERROR_SUCCESS == dwResult)
    {
        UpgradeSchemesAndNcMetricsToWin2000ForUser(hkeyUser);
        RegCloseKey(hkeyUser);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\migrate\ocinst.cpp ===
#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <inetreg.h>
#include <advpub.h>
#include <debug.h>
#include <inetreg.h>
#include <shlobj.h>
#include <advpub.h>
#include <regstr.h>
#include "shmgdefs.h"
#include "res.h"

HINSTANCE g_hInstResLib = NULL;

const WCHAR c_szIEApp[] = L"iexplore.exe";
const WCHAR c_szOEApp[] = L"msimn.exe";
const WCHAR c_szIECanonicalName[] = L"IEXPLORE.EXE";
const WCHAR c_szOECanonicalName[] = L"Outlook Express";

#ifndef INTERNET_MAX_PATH_LENGTH
#define INTERNET_MAX_PATH_LENGTH    2048
#endif

#ifdef _TNOONAN_TEST_WIN64
#define _WIN64
#undef CSIDL_PROGRAM_FILESX86
#define CSIDL_PROGRAM_FILESX86  CSIDL_PROGRAM_FILES
#endif

//
//  We must create our shortcuts in the same language as the install
//  language.  If the install language is USEnglish, we cannot use
//  LoadString because MUI might redirect us to the localized string,
//  so we have a hard-coded list of USEnglish strings.  We need that
//  anyway in the Hide case, where we may need to delete old USEnglish
//  versions of the shortcut left over from previous versions of IE.
//
enum {  // Localized Shortcut Name
    LSN_SM_IE,
    LSN_QL_IE,
    LSN_SM_OE,
    LSN_QL_OE,
#ifdef _WIN64
    LSN_SM_IE32,
#endif

    // special sentinel value
    LSN_NONE = -1,
};

struct LOCALIZEDSHORTCUTINFO
{
    LPCWSTR pszExe;             // The application to run
    LPCWSTR pszUSEnglish;       // Use if native OS is USEnglish or MUI-localized
    UINT    idsLocalized;       // Use if native OS is fully-localized (relative to shmgrate.exe)
    UINT    idsDescription;     // Shortcut description (relative to shmgrate.exe)
    BOOL    fNeverShowShortcut; // Use if we should never show (only hide)
};

const LOCALIZEDSHORTCUTINFO c_rglsi[] = {
    {       // LSN_SM_IE
        c_szIEApp,
        L"Internet Explorer",
        IDS_OC_IESHORTCUTNAME_SM,
        IDS_OC_IEDESCRIPTION,
        FALSE,
    },

    {       // LSN_QL_IE
        c_szIEApp,
        L"Launch Internet Explorer Browser",
        IDS_OC_IESHORTCUTNAME_QL,
        IDS_OC_IEDESCRIPTION,
        FALSE,
    },

    {       // LSN_SM_OE
        c_szOEApp,
        L"Outlook Express",
        IDS_OC_OESHORTCUTNAME_SM,
        IDS_OC_OEDESCRIPTION,
        FALSE,
    },

    {       // LSN_QL_OE
        c_szOEApp,
        L"Launch Outlook Express",
        IDS_OC_OESHORTCUTNAME_QL,
        IDS_OC_OEDESCRIPTION,
        TRUE,
    },

#ifdef _WIN64
    {   // LSN_SM_IE32
        NULL,       // Special-cased in CreateShortcut since it's not in App Paths
        L"Internet Explorer (32-bit)",
        IDS_OC_IESHORTCUTNAME_SM64,
        IDS_OC_IEDESCRIPTION,
        FALSE,
    }
#endif
};

#ifdef _WIN64
WCHAR g_szIE32Path[MAX_PATH];
#endif

const WCHAR c_szIMN[] = L"Internet Mail and News";
const WCHAR c_szNTOS[] = L"Microsoft(R) Windows NT(TM) Operating System";
const WCHAR c_szHotmail[] = L"Hotmail";

const WCHAR c_szUrlDll[] = L"url.dll";
const WCHAR c_szMailNewsDll[] = L"mailnews.dll";

const WCHAR c_szIEInstallInfoKey[] = L"Software\\Clients\\StartMenuInternet\\IEXPLORE.EXE\\InstallInfo";
const WCHAR c_szOEInstallInfoKey[] = L"Software\\Clients\\Mail\\Outlook Express\\InstallInfo";
const WCHAR c_szIconsVisible[] = L"IconsVisible";
const WCHAR c_szReinstallCommand[] = L"ReinstallCommand";
const WCHAR c_szHideIconsCommand[] = L"HideIconsCommand";
const WCHAR c_szShowIconsCommand[] = L"ShowIconsCommand";

const WCHAR c_szReinstallCommandOE[] = L"%SystemRoot%\\system32\\shmgrate.exe OCInstallReinstallOE";
const WCHAR c_szHideIconsCommandOE[] = L"%SystemRoot%\\system32\\shmgrate.exe OCInstallHideOE";
const WCHAR c_szShowIconsCommandOE[] = L"%SystemRoot%\\system32\\shmgrate.exe OCInstallShowOE";
    
const WCHAR c_szStartMenuInternetClientKey[] = L"Software\\Clients\\StartMenuInternet";
const WCHAR c_szMailClientKey[] = L"Software\\Clients\\Mail";

#ifdef _WIN64
const WCHAR c_szMailClientKeyWOW32[] = L"Software\\Wow6432Node\\Clients\\Mail";
#endif

const WCHAR c_szJavaVMKey[] = L"CLSID\\{08B0E5C0-4FCB-11CF-AAA5-00401C608501}";

const WCHAR c_szIEAccessKey[] = L"Software\\Microsoft\\Active Setup\\Installed Components\\>{26923b43-4d38-484f-9b9e-de460746276c}";
const WCHAR c_szOEAccessKey[] = L"Software\\Microsoft\\Active Setup\\Installed Components\\>{881dd1c5-3dcf-431b-b061-f3f88e8be88a}";

const WCHAR c_szOCSyncKey[] = L"Software\\Microsoft\\Active Setup\\Optional Component Sync";
const WCHAR c_szIsInstalled[] = L"IsInstalled";
const WCHAR c_szLocale[] = L"Locale";
const WCHAR c_szVersion[] = L"Version";

const WCHAR c_szOCManagerSubComponents[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents";
const WCHAR c_szIEAccess[] = L"IEAccess";
const WCHAR c_szOEAccess[] = L"OEAccess";

const WCHAR c_szKeyComponent[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\{871C5380-42A0-1069-A2EA-08002B30309D}";
const WCHAR c_szShellFolder[] = L"ShellFolder";
const WCHAR c_szAttribute[] = L"Attributes";

void ShellFree(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        IMalloc *pMalloc;

        if (SUCCEEDED(SHGetMalloc(&pMalloc)))
        {
            pMalloc->Free(pidl);
            pMalloc->Release();
        }
    }
}

HINSTANCE GetResLibInstance()
{
    if (NULL == g_hInstResLib)
    {
        g_hInstResLib = GetModuleHandle(NULL);
    }

    return g_hInstResLib;
}

BOOL IsServer()
{
    OSVERSIONINFOEX osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    return (GetVersionEx((OSVERSIONINFO *)&osvi) && 
            ((VER_NT_SERVER == osvi.wProductType) || (VER_NT_DOMAIN_CONTROLLER == osvi.wProductType)));
}

LONG GetStringValue(
    IN  HKEY    hkey,
    IN  LPCWSTR pwszSubKey,         OPTIONAL
    IN  LPCWSTR pwszValue,          OPTIONAL
    OUT LPVOID  pvData,             OPTIONAL
    OUT LPDWORD pcbData)            OPTIONAL
{
    DWORD dwType;
    DWORD cbData = pcbData ? *pcbData : 0;

    LONG lResult = SHGetValueW(hkey, pwszSubKey, pwszValue, &dwType, pvData, pcbData);

    if ((ERROR_SUCCESS == lResult) && (REG_SZ == dwType))
    {
        //  NULL terminate this puppy...
        if (pvData && cbData)
        {
            WCHAR *psz = (WCHAR *)pvData;
            psz[(cbData / sizeof(WCHAR)) - 1] = 0;
        }
    }
    else
    {
        lResult = ERROR_BADKEY;
    }

    return lResult;
}

inline HRESULT FailedHresultFromWin32()
{
    DWORD dwGLE = GetLastError();

    return (dwGLE != NOERROR) ? HRESULT_FROM_WIN32(dwGLE) : E_UNEXPECTED;
}

void SendChangeNotification(int csidl)
{
    LPITEMIDLIST pidl;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl, &pidl)))
    {
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidl, NULL);
        
        ShellFree(pidl);
    }
}

BOOL IsNtSetupRunning()
{
    BOOL fSetupRunning = FALSE;
    DWORD dwSetupRunning;
    DWORD cbValue = sizeof(dwSetupRunning);
    long lResult = SHGetValue(HKEY_LOCAL_MACHINE, L"system\\Setup", L"SystemSetupInProgress", NULL, &dwSetupRunning, &cbValue);

    if ((ERROR_SUCCESS == lResult) && (dwSetupRunning))
    {
        fSetupRunning = TRUE;
    }
    else
    {
        cbValue = sizeof(dwSetupRunning);
        lResult = SHGetValue(HKEY_LOCAL_MACHINE, L"system\\Setup", L"UpgradeInProgress", NULL, &dwSetupRunning, &cbValue);

        if ((ERROR_SUCCESS == lResult) && (dwSetupRunning))
        {
            fSetupRunning = TRUE;
        }
    }

    return fSetupRunning;
}

BOOL IsIgnorableClientProgram(LPCWSTR pszCurrentClient, LPCWSTR *ppszIgnoreList)
{
    BOOL fResult = (lstrlen(pszCurrentClient) == 0);

    if (!fResult && (NULL != ppszIgnoreList))
    {
        while (NULL != *ppszIgnoreList)
        {
            if (0 == StrCmpI(pszCurrentClient, *ppszIgnoreList))
            {
                fResult = TRUE;
                break;
            }
            ppszIgnoreList++;
        }
    }

    return fResult;
}

void SetDefaultClientProgram(HKEY hkeyRoot, LPCWSTR pszClientKey, LPCWSTR pszCanonicalName, LPCWSTR *ppszIgnoreList, BOOL fShow, BOOL fForce)
{
    HKEY hKey;
    LONG lResult;

    if (fShow)
    {
        DWORD dwDisposition;

        lResult = RegCreateKeyEx(hkeyRoot, pszClientKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, 
            NULL, &hKey, &dwDisposition);
    }
    else
    {
        lResult = RegOpenKeyEx(hkeyRoot, pszClientKey, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey);
    }

    if (ERROR_SUCCESS == lResult)
    {
        WCHAR szCurrentClient[MAX_PATH];
        DWORD cbCurrentClient = sizeof(szCurrentClient);
        
        lResult = GetStringValue(hKey, NULL, NULL, szCurrentClient, &cbCurrentClient);
        
        //  If we're meant to show ourselves then just show set the key
        if (fShow)
        {
            if (fForce || 
                ((ERROR_SUCCESS != lResult) || IsIgnorableClientProgram(szCurrentClient, ppszIgnoreList)))
            {
                RegSetValue(hKey, NULL, REG_SZ, pszCanonicalName, lstrlen(pszCanonicalName) * sizeof(WCHAR));
            }
        }
        else
        {
            //  If we're meant to disappear then clear the key only if we're the one that is currently set.
            if (fForce || ((ERROR_SUCCESS == lResult) && (0 == StrCmpI(pszCanonicalName, szCurrentClient))))
            {
                RegSetValue(hKey, NULL, REG_SZ, L"", 0);
            }
        }
                
        RegCloseKey(hKey);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error opening client key %s - 0x%08x", pszClientKey, lResult);
    }    
}


BOOL IsInstalled(LPCWSTR pszComponent)
{
    BOOL fIsInstalled;

    //  We're always installed on server!
    if (!IsServer())
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(dwValue);
        DWORD dwResult = SHGetValueW(HKEY_LOCAL_MACHINE, pszComponent, c_szIsInstalled, &dwType, &dwValue, &cbValue);

        fIsInstalled = ((ERROR_SUCCESS == dwResult) && (REG_DWORD == dwType) && (dwValue));
    }
    else
    {
        fIsInstalled = TRUE;
    }

    return fIsInstalled;
}

void SetBool(LPCWSTR pszKey, LPCWSTR pszValue, BOOL fValue)
{
    HKEY hKey;
    DWORD dwDisposition;

    LONG lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_SET_VALUE, NULL, &hKey, &dwDisposition);

    if (ERROR_SUCCESS == lResult)
    {
        DWORD dwValue = fValue ? TRUE : FALSE;
        
        lResult = RegSetValueEx(hKey, pszValue, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

        if (ERROR_SUCCESS != lResult)
        {
            TraceMsg(TF_ERROR, "Error setting value %s - 0x%08x", pszValue, lResult);
        }
        RegCloseKey(hKey);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error creating %s key - 0x%08x", pszKey, lResult);
    }
}

//Copy data from HKLM to HKCU
LONG CopyRegValue(LPCWSTR pszSubKey, LPCWSTR pszValue)
{
    HKEY hKeySrc;
    LONG lResult;
    
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszSubKey, 0, KEY_QUERY_VALUE, &hKeySrc);

    if (ERROR_SUCCESS == lResult)
    {
        BYTE buffer[128];
        DWORD dwSize = sizeof(buffer);
        
        lResult = RegQueryValueEx(hKeySrc, pszValue, NULL, NULL, (LPBYTE)buffer, &dwSize);

        RegCloseKey(hKeySrc);

        if (ERROR_SUCCESS == lResult)
        {
            HKEY hKeyDst;

            lResult = RegCreateKeyEx(HKEY_CURRENT_USER, pszSubKey, 0, NULL, 
                                     REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hKeyDst, NULL);

            if (ERROR_SUCCESS == lResult)
            {
                lResult = RegSetValueEx(hKeyDst, pszValue, NULL, REG_SZ, (CONST BYTE *)buffer, dwSize);
            }
            RegCloseKey(hKeyDst);
        }       
    }

    return lResult;
}

void UpdateActiveSetupValues(LPCWSTR pszKeyName, BOOL fInstall)
{
    if (fInstall)
    {
        CopyRegValue(pszKeyName, c_szLocale);
        CopyRegValue(pszKeyName, c_szVersion);
    }
    else
    {
        RegDeleteKey(HKEY_CURRENT_USER, pszKeyName);
    }
}

LONG GetExeAppPathWorker(LPCWSTR pszAppName, LPWSTR pszExePath, UINT cchExePath, LPCWSTR pszFmt)
{
    WCHAR szExeKey[MAX_PATH];
    HKEY hKey;           

    wnsprintf(szExeKey, ARRAYSIZE(szExeKey), pszFmt, pszAppName);
    
    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szExeKey, 0, KEY_QUERY_VALUE, &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        LONG cbExePath = cchExePath * sizeof(WCHAR);

        lResult = RegQueryValue(hKey, NULL, pszExePath, &cbExePath);
        if (ERROR_SUCCESS != lResult)
        {
            TraceMsg(TF_ERROR, "Error querying for app path value - 0x%08x", lResult);
        }

        RegCloseKey(hKey);
    }

    return lResult;
}

LONG GetExeAppPath(LPCWSTR pszAppName, LPWSTR pszExePath, UINT cchExePath)
{
    return GetExeAppPathWorker(pszAppName, pszExePath, cchExePath, L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\%s");
}

#ifdef _WIN64
LONG GetWow32ExeAppPath(LPCWSTR pszAppName, LPWSTR pszExePath, UINT cchExePath)
{
    return GetExeAppPathWorker(pszAppName, pszExePath, cchExePath, L"Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\App Paths\\%s");
}
#endif

void ShowHideFile(LPCWSTR pszFileName, BOOL fShow)
{
    DWORD dwAttrs = GetFileAttributes(pszFileName);
    
    if (fShow)
    {
        dwAttrs &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
    }
    else
    {
        dwAttrs |= FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;
    }
    
    SetFileAttributes(pszFileName, dwAttrs);
}

void ShowHideExe(LPCWSTR pszAppName, BOOL fShow)
{
    WCHAR szExePath[MAX_PATH];
    
    if (ERROR_SUCCESS == GetExeAppPath(pszAppName, szExePath, ARRAYSIZE(szExePath)))
    {
        ShowHideFile(szExePath, fShow);
    }    
}

#ifdef _WIN64
void ShowHideWow32Exe(LPCWSTR pszAppName, BOOL fShow)
{
    WCHAR szExePath[MAX_PATH];
    
    if (ERROR_SUCCESS == GetWow32ExeAppPath(pszAppName, szExePath, ARRAYSIZE(szExePath)))
    {
        ShowHideFile(szExePath, fShow);
    }    
}
#endif

void CreateShortcut(LPCWSTR pszExePath, LPWSTR pszLinkFullFilePath, int idName, int idDescription)
{
    IShellLink *pShellLink;

    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&pShellLink);

    if (SUCCEEDED(hr))
    {
        if (idDescription)
        {
            WCHAR szDescription[MAX_PATH];

            wnsprintf(szDescription, ARRAYSIZE(szDescription), L"@shmgrate.exe,-%d", idDescription);
            pShellLink->SetDescription(szDescription);
        }

        pShellLink->SetWorkingDirectory(L"%HOMEDRIVE%%HOMEPATH%");

        if (SUCCEEDED(pShellLink->SetPath(pszExePath)))
        {
            IPersistFile *pPersistFile;

            if (SUCCEEDED(pShellLink->QueryInterface(IID_IPersistFile, (void **)&pPersistFile)))
            {
                if (SUCCEEDED(pPersistFile->Save(pszLinkFullFilePath, TRUE)))
                {
                    SHSetLocalizedName(pszLinkFullFilePath, L"shmgrate.exe", idName);
                }

                pPersistFile->Release();
            }
        }

        pShellLink->Release();
    }
    else
    {
        TraceMsg(TF_ERROR, "Couldn't create shell link object - hr = 0x%08x", hr);
    }
}

void FindAndNukeIcons(LPCWSTR pszLinkPath, LPCWSTR pszLongExePath, LPCWSTR pszShortExePath)
{
    WCHAR szStartDir[MAX_PATH];

    if (GetCurrentDirectory(ARRAYSIZE(szStartDir), szStartDir))
    {
        if (SetCurrentDirectory(pszLinkPath))
        {
            WIN32_FIND_DATA fd;
            
            HANDLE hFind = FindFirstFile(L"*.lnk", &fd);

            if (INVALID_HANDLE_VALUE != hFind)
            {
                IShellLink *pShellLink;
                HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&pShellLink);

                if (SUCCEEDED(hr))
                {
                    IPersistFile *pPersistFile;

                    hr = pShellLink->QueryInterface(IID_IPersistFile, (void **)&pPersistFile);

                    if (SUCCEEDED(hr))
                    {
                        do
                        {
                            WCHAR szLinkPath[MAX_PATH];
                            WCHAR szArgs[INTERNET_MAX_PATH_LENGTH];
                                                            
                            if (SUCCEEDED(pPersistFile->Load(fd.cFileName, STGM_READ)) &&
                                SUCCEEDED(pShellLink->GetPath(szLinkPath, ARRAYSIZE(szLinkPath), NULL, 0)) &&
                                ((0 == StrCmpI(pszLongExePath, szLinkPath)) || (0 == StrCmpI(pszShortExePath, szLinkPath))) &&
                                SUCCEEDED(pShellLink->GetArguments(szArgs, ARRAYSIZE(szArgs))))
                            {
                                PathRemoveBlanks(szArgs);

                                if (!szArgs[0])
                                {
                                    SetFileAttributes(fd.cFileName, FILE_ATTRIBUTE_NORMAL);
                                    DeleteFile(fd.cFileName);
                                }
                            }
                        }
                        while (FindNextFile(hFind, &fd));

                        pPersistFile->Release();
                    }

                    pShellLink->Release();
                }

                FindClose(hFind);
            }
        }

        SetCurrentDirectory(szStartDir);
    }
}

void ShowShortcut(LPCWSTR pszLinkPath, int lsn, BOOL fShow)
{
    WCHAR szLinkFullFilePath[MAX_PATH];
    WCHAR szLinkFileName[MAX_PATH];

    szLinkFileName[0] = 0;

    //  If we should use the localized name as the filename, then try to get it.
    //  We should use the localized name if the install language is not USEnglish.
    if (LANGIDFROMLCID(GetSystemDefaultUILanguage()) != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
    {
        LoadString(GetResLibInstance(), c_rglsi[lsn].idsLocalized,
                   szLinkFileName, ARRAYSIZE(szLinkFileName));
    }

    //  If we couldn't (or shouldn't) get the localized name, then
    //  use the USEnglish name instead.
    if (!szLinkFileName[0])
    {
        lstrcpyn(szLinkFileName, c_rglsi[lsn].pszUSEnglish, ARRAYSIZE(szLinkFileName));
    }
    PathAddExtension(szLinkFileName, L".lnk");
    PathCombine(szLinkFullFilePath, pszLinkPath, szLinkFileName);

    WCHAR szExePath[MAX_PATH];
    LONG lResult;

#ifdef _WIN64
    if (lsn == LSN_SM_IE32)
    {
        StrCpyN(szExePath, g_szIE32Path, ARRAYSIZE(szExePath));
        lResult = ERROR_SUCCESS;
    }
    else
#endif
    {
        lResult = GetExeAppPath(c_rglsi[lsn].pszExe, szExePath, ARRAYSIZE(szExePath));
    }

    if (ERROR_SUCCESS == lResult)
    {
        if (fShow)
        {
            if (!c_rglsi[lsn].fNeverShowShortcut)
            {
                CreateShortcut(szExePath, szLinkFullFilePath, c_rglsi[lsn].idsLocalized, c_rglsi[lsn].idsDescription);
            }
        }
        else
        {
            WCHAR szShortExePath[MAX_PATH];
            
            DWORD cch = GetShortPathName(szExePath, szShortExePath, ARRAYSIZE(szShortExePath));

            if (!cch || (cch >= ARRAYSIZE(szShortExePath)))
            {
                szShortExePath[0] = 0;
            }
            FindAndNukeIcons(pszLinkPath, szExePath, szShortExePath);
        }
    }
}

void ShowIEDesktopIcon(BOOL fShow)
{
    DWORD dwValue;
    DWORD dwSize;
    DWORD dwDisposition;
    HKEY hKeyComponent, hKeyShellFolder;
    LONG lResult;

    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, c_szKeyComponent, NULL, NULL, REG_OPTION_NON_VOLATILE, 
                             KEY_CREATE_SUB_KEY, NULL, &hKeyComponent, &dwDisposition);

    if (ERROR_SUCCESS == lResult)
    {
        lResult = RegCreateKeyEx(hKeyComponent, c_szShellFolder, NULL, NULL, REG_OPTION_NON_VOLATILE, 
                                 KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKeyShellFolder, &dwDisposition);

        if (ERROR_SUCCESS == lResult)
        {
            dwSize = sizeof(dwValue);

            lResult = RegQueryValueEx(hKeyShellFolder, c_szAttribute, NULL, NULL, (LPBYTE)&dwValue, &dwSize);

            if (ERROR_SUCCESS != lResult)
            {
                dwValue = 0;
            }

            if (fShow)
            {
                dwValue &= ~ SFGAO_NONENUMERATED;
            }
            else
            {
                dwValue |= SFGAO_NONENUMERATED;
            }

            lResult = RegSetValueEx(hKeyShellFolder, c_szAttribute, NULL, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

            SendChangeNotification(CSIDL_DESKTOP);
            SendChangeNotification(CSIDL_DESKTOPDIRECTORY);

            RegCloseKey(hKeyShellFolder);
        }
        
        RegCloseKey(hKeyComponent);
    }
}

//  Ensure a handler is in place for all the important things
void FixupIEAssociations(BOOL fForceAssociations)
{
    // In order for shdocvw to do its magic, IEXPLORE.EXE must be properly
    // registered.  Setup runs OC Manager before it runs IE.INF, so don't
    // call shdocvw to try to do something he can't do.  (He'll assert if
    // you try.)
    HKEY hk;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"),
                     0, KEY_READ, &hk) != ERROR_SUCCESS)
    {
        // ie.inf hasn't run yet - shdocvw can't do its thing
        return;
    }
    RegCloseKey(hk);

    //  Shdocvw does a pretty good job of this, let's give him a crack at it
    HINSTANCE hinst = LoadLibrary(L"shdocvw.dll");

    if (NULL != hinst)
    {
        typedef HRESULT (WINAPI *DLLINSTALL)(BOOL bInstall, LPCWSTR pszCmdLine);

        DLLINSTALL pfnDllInstall = (DLLINSTALL)GetProcAddress(hinst, "DllInstall");

        if (pfnDllInstall)
        {
            pfnDllInstall(TRUE, (fForceAssociations ? L"ForceAssoc" : L""));
        }
        else
        {
            TraceMsg(TF_ERROR, "Error getting DllInstall entry point - GLE = 0x%08x", GetLastError());
        }

        FreeLibrary(hinst);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error loading shdocvw - GLE = 0x%08x", GetLastError());
    }
}
    
//  This will create or delete shortcuts in Start Menu\Programs and the Quick Launch bar
void ShowUserShortcuts(int lsnSM, int lsnQL, BOOL fShow)
{
    WCHAR szPath[MAX_PATH];
    
    if (lsnSM >= 0 && SHGetSpecialFolderPath(NULL, szPath, CSIDL_PROGRAMS, fShow))
    {
        ShowShortcut(szPath, lsnSM, fShow);
    }

    if (lsnQL >= 0 && SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, fShow))
    {
        WCHAR szQuickLaunchPath[MAX_PATH];

        LoadString(GetResLibInstance(), IDS_OC_QLAUNCHAPPDATAPATH, szQuickLaunchPath, ARRAYSIZE(szQuickLaunchPath));

        PathAppend(szPath, szQuickLaunchPath);

        //  In case we're the first ones through, create the Quick Launch dir
        CreateDirectory(szPath, NULL);
        
        ShowShortcut(szPath, lsnQL, fShow);
    }
}

void NukeFiles(LPCWSTR pszPath, LPCWSTR pszFileSpec)
{
    WCHAR szStartDir[MAX_PATH];
    
    if (GetCurrentDirectory(ARRAYSIZE(szStartDir), szStartDir))
    {
        if (SetCurrentDirectory(pszPath))
        {
            WIN32_FIND_DATA fd;
            
            HANDLE hFind = FindFirstFile(pszFileSpec, &fd);

            if (INVALID_HANDLE_VALUE != hFind)
            {
                do
                {
                    SetFileAttributes(fd.cFileName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(fd.cFileName);
                }
                while (FindNextFile(hFind, &fd));

                FindClose(hFind);
            }
        }

        SetCurrentDirectory(szStartDir);
    }
}

void NukeDesktopCleanupIcons()
{
    WCHAR szPath[MAX_PATH];
    HINSTANCE hInstCleaner = LoadLibraryEx(L"fldrclnr.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    WCHAR szUnusedShortcutFolder[MAX_PATH];

//  From nt\shell\applets\cleanup\fldrclnr\resource.h:
#define IDS_ARCHIVEFOLDER               8
#define IDS_ARCHIVEFOLDER_FIRSTBOOT     15

//  From nt\shell\applets\cleanup\fldrclnr\cleanupwiz.h:
#define REGSTR_OEM_PATH                   REGSTR_PATH_SETUP TEXT("\\OemStartMenuData")
#define REGSTR_OEM_TITLEVAL               TEXT("DesktopShortcutsFolderName")
    
    if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
    {
        NukeFiles(szPath, L"*.{871C5380-42A0-1069-A2EA-08002B30309D}");

        if (hInstCleaner && 
            LoadString(hInstCleaner, IDS_ARCHIVEFOLDER, szUnusedShortcutFolder, ARRAYSIZE(szUnusedShortcutFolder)))
        {
            PathAppend(szPath, szUnusedShortcutFolder);
            NukeFiles(szPath, L"*.{871C5380-42A0-1069-A2EA-08002B30309D}");
        }
    }

    DWORD cb = sizeof(szUnusedShortcutFolder);
    DWORD dwType;

    //  Get the folder name from either the registry or fldrclnr.dll and get the startmenu\programs folder
    if (
        (
         (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_OEM_PATH, REGSTR_OEM_TITLEVAL, &dwType, szUnusedShortcutFolder, &cb))
         ||
         (hInstCleaner && LoadString(hInstCleaner, IDS_ARCHIVEFOLDER_FIRSTBOOT, szUnusedShortcutFolder, ARRAYSIZE(szUnusedShortcutFolder)))
        )
        &&
        SHGetSpecialFolderPath(NULL, szPath, CSIDL_PROGRAMS, FALSE)
       )
    {
        PathAppend(szPath, szUnusedShortcutFolder);
        NukeFiles(szPath, L"*.{871C5380-42A0-1069-A2EA-08002B30309D}");
    }

    if (hInstCleaner)
    {
        FreeLibrary(hInstCleaner);
    }
}

//  Internet Explorer optional component goo
void UserConfigIE()
{
    BOOL fIsInstalled = IsInstalled(c_szIEAccessKey);

    ShowIEDesktopIcon(fIsInstalled);

    if (!fIsInstalled)
    {
        NukeDesktopCleanupIcons();
    }

    ShowUserShortcuts(LSN_SM_IE, LSN_QL_IE, fIsInstalled);

#ifdef _WIN64
    WCHAR szLinkDir[MAX_PATH];

    if (SHGetSpecialFolderPath(NULL, szLinkDir, CSIDL_PROGRAMS, fIsInstalled))
    {
        WCHAR szExePath[MAX_PATH];

        if (SHGetSpecialFolderPath(NULL, szExePath, CSIDL_PROGRAM_FILESX86, FALSE))
        {
            PathCombine(g_szIE32Path, szExePath, L"Internet Explorer\\iexplore.exe");
            ShowShortcut(szLinkDir, LSN_SM_IE32, fIsInstalled);
        }
    }
#endif

    SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)L"Software\\Clients\\StartMenuInternet");
}

void SetIEShowHideFlags(BOOL fShow)
{
    SetBool(c_szIEAccessKey, c_szIsInstalled, fShow);
    SetBool(c_szIEInstallInfoKey, c_szIconsVisible, fShow);
    SetBool(c_szOCManagerSubComponents, c_szIEAccess, fShow);
}

void ShowHideIE(BOOL fShow, BOOL fForceAssociations, BOOL fMayRunPerUserConfig)
{
    if (fShow || !IsServer())
    {
        SetIEShowHideFlags(fShow);

        if (fShow)
        {
            FixupIEAssociations(fForceAssociations);

            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szStartMenuInternetClientKey, c_szIECanonicalName, NULL, TRUE, fForceAssociations);
        }
        else
        {
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szStartMenuInternetClientKey, c_szIECanonicalName, NULL, FALSE, FALSE);
        }

        if (fMayRunPerUserConfig && !IsNtSetupRunning())
        {
            SetDefaultClientProgram(HKEY_CURRENT_USER, c_szStartMenuInternetClientKey, c_szIECanonicalName, NULL, FALSE, fShow);
            UserConfigIE();
            UpdateActiveSetupValues(c_szIEAccessKey, fShow);
        }
        else
        {
            SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)L"Software\\Clients\\StartMenuInternet");
        }

        ShowHideExe(c_szIEApp, fShow);

    #ifdef _WIN64
        ShowHideWow32Exe(c_szIEApp, fShow);
    #endif
    }
}

//  Outlook Express optional component goo

void RemoveOEDesktopIcon()
{
    WCHAR szPath[MAX_PATH];
    
    if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
    {
        ShowShortcut(szPath, LSN_SM_OE, FALSE);

        SendChangeNotification(CSIDL_DESKTOP);
        SendChangeNotification(CSIDL_DESKTOPDIRECTORY);
    }

    if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_COMMON_DESKTOPDIRECTORY, FALSE))
    {
        ShowShortcut(szPath, LSN_SM_OE, FALSE);
        SendChangeNotification(CSIDL_COMMON_DESKTOPDIRECTORY);
    }    
}

void UserConfigOE()
{
    BOOL fIsInstalled = IsInstalled(c_szOEAccessKey);

    ShowUserShortcuts(LSN_SM_OE, LSN_QL_OE, fIsInstalled);

    SHSendMessageBroadcastW(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_MAILCLIENTS);

    if (!fIsInstalled)
    {
        //  ShowUserShortcuts(fInstalled=FALSE) already cleaned up any
        // old OE Quick Launch shortcuts, so all that's left to remove
        // is the desktop icon
        RemoveOEDesktopIcon();
    }
}

void SetOEShowHideFlags(BOOL fShow)
{
    SetBool(c_szOEAccessKey, c_szIsInstalled, fShow);
    SetBool(c_szOEInstallInfoKey, c_szIconsVisible, fShow);
    SetBool(c_szOCManagerSubComponents, c_szOEAccess, fShow);
}

void FixupOEAssociations(BOOL fForceAssociations, LPCWSTR *ppszIgnoreList)
{
    if (!IsNtSetupRunning())
    {
        long lResult;
        
        if (!fForceAssociations)
        {
            WCHAR szValue[MAX_PATH];
            DWORD cbValue = sizeof(szValue);
            DWORD dwType;

            lResult = SHGetValueW(HKEY_CLASSES_ROOT, L"mailto\\shell\\open\\command", NULL, &dwType, szValue, &cbValue);

            if ((REG_SZ == dwType) &&
                ((ERROR_MORE_DATA == lResult) || ((ERROR_SUCCESS == lResult) && (cbValue >= (2 * sizeof(WCHAR))))))
            {
                //   Some sort of valid string data at least character in length -- see if it's one we should stomp,
                //   otherwise leave it alone

                if (NULL != ppszIgnoreList)
                {
                    while (NULL != *ppszIgnoreList)
                    {
                        if (NULL != StrStrIW(szValue, *ppszIgnoreList))
                        {
                            fForceAssociations = TRUE;
                            break;
                        }
                        ppszIgnoreList++;
                    }
                }
            }
            else
            {
                //  Either it's not a string or it's zero length
                fForceAssociations = TRUE;
            }
        }

        if (fForceAssociations)
        {
            HKEY hkey;
            DWORD dwDisposition;

            SHDeleteKey(HKEY_CLASSES_ROOT, L"mailto");
            
            lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT, L"mailto", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, 
                                          NULL, &hkey, &dwDisposition);

            if (ERROR_SUCCESS == lResult)
            {
                SHCopyKey(HKEY_LOCAL_MACHINE, L"Software\\Clients\\Mail\\Outlook Express\\Protocols\\mailto", hkey, 0);
                RegCloseKey(hkey);
            }
        }
    }
}

void ShowHideOE(BOOL fShow, BOOL fForceAssociations, BOOL fMayRunPerUserConfig)
{
    if (fShow || !IsServer())
    {
        static LPCWSTR ppszIgnoreClientsNormal[] = { c_szIMN, c_szNTOS, NULL };
        static LPCWSTR ppszIgnoreClientsSetup[] = { c_szIMN, c_szNTOS, c_szHotmail, NULL };
        LPCWSTR *ppszIgnoreClients = !IsNtSetupRunning() ? ppszIgnoreClientsNormal : ppszIgnoreClientsSetup;

        static LPCWSTR ppszIgnoreMailto[] = { c_szUrlDll, c_szMailNewsDll, NULL };
        
        SetOEShowHideFlags(fShow);

        if (fShow)
        {
            FixupOEAssociations(fForceAssociations, ppszIgnoreMailto);
            
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szMailClientKey, c_szOECanonicalName, ppszIgnoreClients, TRUE, fForceAssociations);
#ifdef _WIN64
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szMailClientKeyWOW32, c_szOECanonicalName, ppszIgnoreClients, TRUE, fForceAssociations);
#endif
        }
        else
        {
            FixupOEAssociations(FALSE, ppszIgnoreMailto);
            
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szMailClientKey, c_szOECanonicalName, ppszIgnoreClients, FALSE, FALSE);
#ifdef _WIN64
            SetDefaultClientProgram(HKEY_LOCAL_MACHINE, c_szMailClientKeyWOW32, c_szOECanonicalName, ppszIgnoreClients, FALSE, FALSE);
#endif
        }
        
        if (fMayRunPerUserConfig && !IsNtSetupRunning())
        {
            SetDefaultClientProgram(HKEY_CURRENT_USER, c_szMailClientKey, c_szOECanonicalName, ppszIgnoreClients, FALSE, fShow);
            UserConfigOE();
            UpdateActiveSetupValues(c_szOEAccessKey, fShow);
        }
        else
        {
            SHSendMessageBroadcastW(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_MAILCLIENTS);
        }

        ShowHideExe(c_szOEApp, fShow);

    #ifdef _WIN64
        ShowHideWow32Exe(c_szOEApp, fShow);
    #endif
    }        
}

HRESULT CallRegisterServer(LPCWSTR pszModule, BOOL fRegister)
{
    HRESULT hr;
    
    HINSTANCE hinst = LoadLibrary(pszModule);

    if (NULL != hinst)
    {
        typedef HRESULT (WINAPI *DLLREGISTERSERVER)();
        LPCSTR pszRegFuncName = fRegister ? "DllRegisterServer" : "DllUnregisterServer";

        DLLREGISTERSERVER pfnDllRegisterServer = (DLLREGISTERSERVER)GetProcAddress(hinst, pszRegFuncName);

        if (pfnDllRegisterServer)
        {
            hr = pfnDllRegisterServer();
        }
        else
        {
            TraceMsg(TF_ERROR, "Error getting DllRegisterServer entry point - GLE = 0x%08x", GetLastError());
            hr = FailedHresultFromWin32();
        }

        FreeLibrary(hinst);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error loading %s - GLE = 0x%08x", pszModule, GetLastError());
        hr = FailedHresultFromWin32();
    }

    return hr;
}

void ReinstallVM()
{
#if 0
    SHDeleteKey(HKEY_CLASSES_ROOT, c_szJavaVMKey);

    CallRegisterServer(L"msjava.dll", TRUE);
#endif
}

void FixupMailClientKey()
{
    SHSetValueW(HKEY_LOCAL_MACHINE, c_szOEInstallInfoKey, c_szReinstallCommand, REG_EXPAND_SZ, c_szReinstallCommandOE, sizeof(c_szReinstallCommandOE));
    SHSetValueW(HKEY_LOCAL_MACHINE, c_szOEInstallInfoKey, c_szHideIconsCommand, REG_EXPAND_SZ, c_szHideIconsCommandOE, sizeof(c_szHideIconsCommandOE));
    SHSetValueW(HKEY_LOCAL_MACHINE, c_szOEInstallInfoKey, c_szShowIconsCommand, REG_EXPAND_SZ, c_szShowIconsCommandOE, sizeof(c_szShowIconsCommandOE));
    SetBool(c_szOEInstallInfoKey, c_szIconsVisible, IsInstalled(c_szOEAccessKey));
}

extern "C" void FixupOptionalComponents()
{
    //  Need to do this here since the app paths weren't set during setup.
    ShowHideExe(c_szIEApp, IsInstalled(c_szIEAccessKey));
    ShowHideExe(c_szOEApp, IsInstalled(c_szOEAccessKey));

#ifdef _WIN64
    ShowHideWow32Exe(c_szIEApp, IsInstalled(c_szIEAccessKey));
    ShowHideWow32Exe(c_szOEApp, IsInstalled(c_szOEAccessKey));
#endif

    //  OE likes to nuke the whole branch and start from scratch.
    FixupMailClientKey();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\atk_inet.h ===
//  File	 : ATK_INET.h
//  Author       : Suresh Krishnan 
//  Date         : 08/05/97
//  Wrapper for INetCFG.DLL exported functions
//  related  function declarations
//
//
#ifndef __ATH_INET__
#define __ATK_INET__

#include <windows.h>
#include <tchar.h>
#include <winnt.h>
#include <wininet.h>
#include <stdio.h>
#include "rw_common.h"

HRESULT ATK_InetGetAutoDial(LPBOOL lpEnable, LPSTR lpszEntryName, DWORD cbEntryName);
HRESULT ATK_InetSetAutoDial(BOOL fEnable, LPCSTR lpszEntryName);
HRESULT ATK_InetConfigSystem( HWND hwndParent, DWORD dwfOptions,
			 LPBOOL lpfNeedsRestart);
HRESULT ATK_InetGetProxy( LPBOOL lpfEnable,
			  LPSTR  lpszServer,
			  DWORD  cbServer,
			  LPSTR  lpszOverride,
			  DWORD  cbOverride);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\atk_ras.h ===
/*
	File : ASTRA_RAS.h

*/
//typedef DWORD  (WINAPI *RASGETENTRYPROPERTIES) ( LPTSTR, LPTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD );
//typedef DWORD  (APIENTRY  *RASGETENTRYPROPERTIES) ( LPTSTR, LPTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD );
#ifndef __ASTRATEK_RAS_WRAPPER
#define __ASTRATEK_RAS_WRAPPER

#include <windows.h>
#include <tchar.h>
#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>


#define  ERROR_LOADING_RAS_DLL   -1
#define  RAS_DLL_LOADED           1
#define  RAS_DLL_NOT_LOADED        0 

typedef DWORD  (APIENTRY *RASGETENTRYPROPERTIES) ( LPTSTR, LPTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD );
typedef DWORD  (APIENTRY *RASSETENTRYPROPERTIES) ( LPTSTR, LPTSTR, LPRASENTRY, DWORD, LPBYTE, DWORD );
typedef DWORD  (APIENTRY *RASDELETEENTRY)      ( LPTSTR, LPTSTR );

typedef DWORD (APIENTRY *RASGETERRORSTRING) (UINT, LPTSTR, DWORD );
typedef DWORD (APIENTRY *RASDIAL)  ( LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD,
                   LPVOID, LPHRASCONN );

typedef DWORD (APIENTRY* RASHANGUP) ( HRASCONN );
typedef DWORD (APIENTRY* RASENUMDEVICES) ( LPRASDEVINFO, LPDWORD, LPDWORD );
typedef DWORD (APIENTRY* RASENUMCONNECTIONS) (LPRASCONN , LPDWORD, LPDWORD);
typedef DWORD (APIENTRY* RASGETCOUNTRYINFO)( LPRASCTRYINFO, LPDWORD );
typedef DWORD (APIENTRY* RASGETCONNECTIONSTATUS)( HRASCONN, LPRASCONNSTATUS );


int ATK_IsRasDllOk();

DWORD ATK_RasDial( LPRASDIALEXTENSIONS lpRasDial, 
			 LPTSTR  lpPhBk, 
			 LPRASDIALPARAMS lpDialParam,
			 DWORD dwNotifyType,
			 LPVOID lpNotifier,
			 LPHRASCONN lphRasConn);

DWORD ATK_RasHangUp ( HRASCONN hrasconn );

DWORD ATK_RasGetEntryProperties(
		LPTSTR lpszPhonebook, 
		LPTSTR lpszEntry, 
		LPRASENTRY lpRasEntry, 
		LPDWORD lpdwEntryInfoSize, 
		LPBYTE lpbDeviceInfo, 
		LPDWORD lpdwDeviceInfoSize );

DWORD ATK_RasSetEntryProperties(
		LPTSTR lpszPhonebook, 
		LPTSTR lpszEntry, 
		LPRASENTRY lpRasEntry, 
		DWORD dwEntryInfoSize, 
		LPBYTE lpbDeviceInfo, 
		DWORD dwDeviceInfoSize );

DWORD ATK_RasDeleteEntry( LPTSTR lpszPhonebook,
					   LPTSTR lpszEntry);

DWORD ATK_RasGetErrorString( UINT uErrorValue, 
							 LPTSTR lpszErrorString, 
							 DWORD cBufSize );

DWORD ATK_RasEnumDevices( LPRASDEVINFO lpRasDevInfo, 
						  LPDWORD lpcb, 
						  LPDWORD lpcDevices);
DWORD ATK_RasEnumConnections ( LPRASCONN lprasconn, 
							   LPDWORD lpcb, 
							   LPDWORD lpcConnections);
DWORD ATK_RasGetCountryInfo( LPRASCTRYINFO lpRasCtryInfo, 
					LPDWORD lpdwSize );

DWORD ATK_RasGetCountryInfoA( LPRASCTRYINFO lpRasCtryInfo, 
					LPDWORD lpdwSize );
DWORD ATK_RasGetConnectionStatus( HRASCONN hrasconn,
		LPRASCONNSTATUS lprasconnstatus );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\progman\progman.c ===
#include <windows.h>
#include <shellapi.h>
#include <shlwapi.h>

#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))

int __cdecl main(int argc, char *argv[], char *envp[])
{
    WCHAR szExplorerPath[MAX_PATH];
    if (GetWindowsDirectory(szExplorerPath, ARRAYSIZE(szExplorerPath)) &&
        PathAppend(szExplorerPath, L"explorer.exe"))

    {
        ShellExecute(NULL, NULL, szExplorerPath, NULL, NULL, SW_SHOWNORMAL);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\cbitmap.h ===
/*********************************************************************
Registration Wizard
CBitmap.h

11/14/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#ifndef __CBitmap__
#define __CBitmap__


class CBitmap
{
public:
	CBitmap(HINSTANCE hInstance, HWND hwndDlg,int idDlgCtl, int idBitmap);
	virtual ~CBitmap();
	LRESULT PASCAL CtlWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
private:
	HBITMAP   GetBmp();
	HINSTANCE m_hInstance;
	FARPROC m_lpfnOrigWndProc;
	HBITMAP m_hBitmap;
	int		m_nIdBitmap;
	HPALETTE m_hPal;
	BOOL    m_isActivePal;
	
};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\cntryinf.h ===
/*********************************************************************
Registration Wizard
cntryinf.h

10/12/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
*********************************************************************/
//#define TAPI_CURRENT_VERSION 0x00010004
#ifndef __CNTRYINF__
#define __CNTRYINF__


#include <tchar.h>
#include <tapi.h>
#define kCountryCodeUnitedStates 1

BOOL CountryCodeFromSzCountryCode(HINSTANCE hInstance,LPTSTR szCountry,DWORD* lpCountry);
DWORD GetCountryCodeUsingTapiId(DWORD dwCountryId, DWORD *dwCountryCode) ;
BOOL GetTapiCurrentCountry(HINSTANCE hInstance,DWORD* dwpCountry);
BOOL FFillCountryList(HINSTANCE hInstance,HWND hwndCB,LPTSTR szCountry,DWORD* lpCountry);


class CCntryInfo {
public :
#ifdef _TAPI
	LINECOUNTRYLIST  *m_pCountry;
#endif
	CCntryInfo();
	~CCntryInfo();
	int  GetCountryCode(_TCHAR *czCountryName);
	int  GetCountryCode( DWORD  dwTapiId);
	_TCHAR * GetCountryName(int iCode =0);
	void FillCountryList(HINSTANCE hInstance,HWND hwndCB);
	int  GetTapiCountryCode(_TCHAR * czCountryName);
	int  GetTapiIDForTheCountryIndex(int iCntryIndex=0); // Useful to Get the Actual TAPI Country Index 

};

extern CCntryInfo     gTapiCountryTable;

#endif //__CNTRYINF__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\credits.h ===
180, 148, 77, 34, 102, 18, 238, 143,
201, 172, 128, 228, 86, 32, 202, 166,
189, 205, 181, 208, 230, 146, 116, 84,
81, 35, 133, 230, 151, 183, 140, 233,
201, 187, 165, 192, 39, 42, 20, 57,
128, 208, 201, 166, 118, 4, 194, 175,
128, 237, 133, 235, 22, 113, 202, 167,
149, 251, 209, 235, 2, 70, 194, 180,
165, 193, 128, 199, 246, 152, 244, 149,
177, 212, 233, 228, 160, 141, 64, 17,
213, 180, 177, 216, 71, 62, 64, 33,
205, 190, 213, 167, 22, 120, 198, 163,
232, 200, 53, 84, 39, 75, 202, 164,
149, 181, 53, 84, 71, 51, 26, 16,
180, 148, 77, 61, 86, 53, 210, 179,
177, 145, 209, 185, 22, 120, 214, 165,
128, 244, 189, 135, 2, 71, 236, 137,
177, 200, 185, 153, 22, 120, 200, 232,
49, 80, 213, 167, 86, 56, 26, 16, 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\devcfg.h ===
// Terminal mode setting
//
#define TERMINAL_NONE   0x00000000
#define TERMINAL_PRE    0x00000001
#define TERMINAL_POST   0x00000002
#define MANUAL_DIAL     0x00000004

#pragma pack( push,4)

// Device Setting Information
//
typedef struct  tagDEVCFGGDR  {
    DWORD       dwSize;
    DWORD       dwVersion;
    DWORD       fTerminalMode;
}   DEVCFGHDR;

typedef struct  tagDEVCFG  {
    DEVCFGHDR   dfgHdr;
    COMMCONFIG  commconfig;
}   DEVCFG, *PDEVCFG, FAR* LPDEVCFG;

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\cregwiz.h ===
/*********************************************************************
Registration Wizard
CRegWiz.h

11/3/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#ifndef __CRegWizard__
#define __CRegWizard__

#include <tchar.h>

const kMaxProductCount = 12;
const kSystemInventoryItemCount = 13;
const kMaxCountryCount = 250;

typedef enum
{
	kInfoFirstName = 0,
	kInfoLastName,
	kInfoCompany,
	kInfoMailingAddress,
	kInfoAdditionalAddress,
	kInfoCity,
	kInfoState,
	kInfoZip,
	kInfoCountry,
	kInfoPhoneNumber,
	kInfoDeclinesNonMSProducts,
	kInfoProductID,
	kInfoProcessor,
	kInfoMathCoProcessor,
	kInfoTotalRAM,
	kInfoTotalDiskSpace,
	kInfoRemoveableMedia,
	kInfoDisplayResolution,
	kInfoDisplayColorDepth,
	kInfoPointingDevice,
	kInfoNetwork,
	kInfoModem,
	kInfoSoundCard,
	kInfoCDROM,
	kInfoOperatingSystem,
	kInfoIncludeSystem,
	kInfoIncludeProducts,
	kInfoApplicationName,
	kInfoOEM,
	kInfoVersion,
	kInfoMakerCompany,
	kInfoResultPath,
	kInfoDate,
	kInfoLanguage,
	kInfoEmailName,
	kInfoResellerName,
	kInfoResellerCity,
	kInfoResellerState,
	kInfoHWID,
	kInfoMSID,
	kInfoPhoneExt,
	kDivisionName, // Division name and User Id is added for FE 3/3/98
	kUserId, 
	kAreaCode,
	kHomeSwKnow,
	kHomeExcited,
	kHomePcSwKnow,
	kBusinessRole,
	kScsiAdapterInfo, // System Inventory
	kComputerManufacturer, // Sysinv Dlg , entry
	kMiddleName,
	kInfoLastIndex
}InfoIndex;

#define kFirstSystemIndex	kInfoProcessor
#define kLastSystemIndex	kInfoOperatingSystem

typedef enum
{
	kTriStateFalse,
	kTriStateTrue,
	kTriStateUndefined
}TriState;

// Typedefs for JumpTableElement;  kMaxAddrSpecTableSize can be
// no larger than the largest value representable by JTE
typedef _TUCHAR JTE;
#define kMaxAddrSpecTableSize 255
#define kMaxLenSize 127
#define kAddrSpecCount 19
//typedef _TSCHAR MAXLEN;
typedef char MAXLEN;
typedef struct
{
	MAXLEN maxLen[kAddrSpecCount];
}ADDRSPEC,*PADDRSPEC;

typedef enum
{
	kAddrSpecFirstName = 0,
	kAddrSpecLastName,
	kAddrSpecCompanyName,
	kAddrSpecAddress,
	kAddrSpecAddress2,
	kAddrSpecCity,
	kAddrSpecState,
	kAddrSpecPostalCode,
	kAddrSpecPhone,
	kAddrSpecEmailName,
	kAddrSpecResellerName,
	kAddrSpecResellerCity,
	kAddrSpecResellerState,
	kAddrSpecExtension,
	kAddrSpecDivision,
	kAddrSpecAreaCode,
	kAddrSpecUserId,
	kSIComputerManufacturer,
	kAddrMiddleName
}ADDRSPEC_FIELD;

class CRegWizard
{
public:
	CRegWizard(HINSTANCE hInstance, LPTSTR szParamRegKey);
	virtual ~CRegWizard();

	void StartRegWizardDialog(int wDlgResID, DLGPROC lpDialogProc);
	void ActivateRegWizardDialog( void );
	INT_PTR ProcessRegWizardDialog( void );
	void EndRegWizardDialog(INT_PTR wExitID);
	BOOL IsDialogActive( void );
	
	void SetWindowCaption(LPTSTR lpszWindowsCaption);
	LPTSTR GetWindowCaption();
	
	INT_PTR GetDialogExitButton( void );
	
	BOOL GetInputParameterStatus( void );
	BOOL GetInputParameterString(short paramID, LPTSTR szParam);

	BOOL IsRegistered( void );
	int AddProduct(LPTSTR szProductName,LPTSTR szProductPath);

	void SetInformationString(InfoIndex index, LPTSTR szInfo);
	BOOL GetInformationString(InfoIndex index, LPTSTR szInfo);
	void SetTriStateInformation(InfoIndex index, TriState infoValue);
	TriState GetTriStateInformation(InfoIndex index);
	void WriteEnableInformation(InfoIndex index, BOOL shouldWrite);
	BOOL IsInformationWriteEnabled(InfoIndex index);

	TriState GetProductSearchLibraryStatus( void );
	BOOL GetProductSearchProcAddress(FARPROC* lpfnProductSearch);
	void SetProductSearchStatus(TriState searchCompleted);
	TriState GetProductSearchStatus( void );
	void SetSystemInventoryStatus(BOOL invCompleted);
	BOOL GetSystemInventoryStatus( void );

	void GetProductName(LPTSTR szProductName,INT_PTR index);
	HICON GetProductIcon(INT_PTR index);
	short GetProductCount( void );
	void WriteInfoToRegistry( void );
	BOOL GetInfoRegValueName(InfoIndex infoIndex,LPTSTR szValueName);
	void GetInfoRegistrationParentKey(LPTSTR szRegKey);
	HINSTANCE GetInstance( void );
	void SetCountryCode(DWORD countryCode);
	DWORD GetCountryCode( void );
	void GetCountryAddrSpec(LONG lCountryID,ADDRSPEC* addrSpec );
	void GetAddrSpecProperties(DWORD dwCountryCode, ADDRSPEC_FIELD addrSpecField, MAXLEN* maxLen,BOOL* isRequired);
	void ConfigureEditTextField(HWND hwndDlg,int editFieldID,ADDRSPEC_FIELD addrSpecField,int iAttachedStrID);
	void SetLogFileName(LPTSTR lpszLogFilePath);
    void DestroyOpenedWindow()
	{
		if (m_hwndCurrDialog)
		{
			DestroyWindow(m_hwndCurrDialog);
			m_hwndCurrDialog = NULL;
		}

	}
	void GetRegKey(LPTSTR szRegKey);
	HWND GetCurrDialog(void );
	void SetDialogHide(HWND hDialogToHide);
	BOOL ShowPrevDialog(void);
	void SetPrevDialog(void);
	void SetDialogExitButton( int nButton );
	static BOOL IsEditTextFieldValid(HWND hwndDlg,int editID);
	static void GetEditTextFieldAttachedString(HWND hwndDlg,int editID,LPTSTR szAttached,int cbBufferSize);
	void ResolveCurrentCountryCode( void );
	BOOL GetMSIDfromCookie(LPTSTR);

	_TCHAR 		m_szParamRegKey[256];

private:
	void BuildAddrSpecTables( void );
	void ReadInfoFromRegistry( void );
	void CreateLogFile( void );
	void WriteToLogFile(LPTSTR lpszLine);
	void CloseLogFile( void );

	HINSTANCE 	m_hInstance;
	HACCEL      m_hAccel;
	LPTSTR 		m_rgszProductName[kMaxProductCount];
	LPTSTR 		m_rgszProductPath[kMaxProductCount];
	HICON		m_rghProductIcon[kMaxProductCount];
	LPTSTR 		m_rgszInfoArray[kInfoLastIndex];
	BOOL 		m_writeEnable[kInfoLastIndex];
	short 		m_productNameCount;
	TriState 	m_searchCompleted;
	BOOL 		m_systemInventoryCompleted;
	_TCHAR 		m_szWindowsCaption[256];
	_TCHAR 		m_szInfoParentKey[256];
	_TCHAR		m_szLogFilePath[_MAX_PATH];
	FARPROC 	m_lpfnProductSearch;
	DWORD 		m_countryCode;
	HANDLE		m_addrJumpTable;
	HANDLE		m_addrSpecTable;
	HANDLE 		m_hLogFile;

	BOOL		m_dialogActive;
	HWND		m_hwndStartDialog;
	HWND		m_hwndCurrDialog;
	INT_PTR		m_wDialogExitButton;
	HWND		m_hwndDialogToHide;
	HWND		m_hwndPrevDialog;
	HINSTANCE	m_ccpLibrary; 
};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\mcm.h ===
#ifndef MCM_H
#define MCM_H

#ifndef TAPI_H
//#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>
#endif

#include <tchar.h>

#define INVALID_PORTID	0xFFFFFFFF
#define fTrue			1
#define fFalse			0
#define Try				__try
#define Leave			__leave
#define Finally			__finally

typedef enum _MODEMSTATUS
{
	kMsModemOk,
	kMsModemNotFound,
	kMsModemTooSlow
}MODEMSTATUS;

#ifdef __cplusplus
extern "C"
{
#endif
MODEMSTATUS MSEnsureModemTAPI (HINSTANCE hInstance, HWND hwnd);
BOOL FGetModemSpeed(HINSTANCE hInstance, DWORD dwDevice, PDWORD pdwSpeed);
BOOL FGetDeviceID(HINSTANCE hInstance, HLINEAPP *phLineApp, PDWORD pdwAPI, PDWORD pdwDevice, DWORD dwIndex);
MODEMSTATUS MSDetectModemTAPI(HINSTANCE hInstance);
#ifdef __cplusplus
}
#endif
#endif // _TAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\fe_util.h ===
/*
	FE_UTIL.H
	Far East Countries helper 
	03/02/98

*/

#ifndef __FE_UTIL__

#define __FE_UTIL__
#include <windows.h>

#define JAPAN_LCID   			411
#define KOREAN_LCID   			412
#define TRADITIONAL_CHINA_LCID  404
#define SIMPLIFIED_CHINA_LCID   804
#define MAX_FE_COUNTRIES_SUPPORTED 256
typedef enum
{
	kNotInitialised,
	kFarEastCountry,   
	kNotAFECountry,
	UnknownCountry
}FeCountriesIndex;

typedef enum {
	kFEWithNonJapaneaseScreen,
	kFEWithJapaneaseScreen // Returned for screen type
}FeScreenType;


extern  FeCountriesIndex   gWhatFECountry; // This is a global variable
										   // Which holds the present FE Country	
extern  FeScreenType       gWhichFEScreenTye; // This is a global variable
										   // Which holds the FE Screen Type	
FeCountriesIndex  IsFarEastCountry(HINSTANCE hIns);
FeScreenType      GetFeScreenType();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\dialogs.h ===
/*********************************************************************
Registration Wizard
Dialogs.h

10/13/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
*********************************************************************/

#include <tchar.h>

INT_PTR WelcomeDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NameDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AddressDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ResellerDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
//INT_PTR CALLBACK PIDDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK InformDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SystemInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProdInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RegisterDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CancelRegWizard(HINSTANCE hInstance,HWND hwndParentDlg);
int RegWizardMessage(HINSTANCE hInstance,HWND hwndParent, int dlgID);
int RegWizardMessageEx(HINSTANCE hInstance,HWND hwndParent, int dlgID, LPTSTR szSub);
void RefreshInventoryList(CRegWizard* pclRegWizard);

//
// The Below Dialog procedures are for Far East countries
INT_PTR CALLBACK AddressForFEDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NameForFEDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\atkinternet.h ===
/*
	File : AtkInternet.h
	Date :
	
	This is a wrapper function declaration for Winows Internet API.
	This Warpper is to handle the UNICODE as the present Windows Internet API does not support UNICODE
	

*/
#ifndef __ASTRATEK_INTERNET_HEADER
#define __ASTRATEK_INTERNET_HEADER

#include <tchar.h>
#include <windows.h>
#include <wininet.h>
#define USE_ASTRATEK_WRAPPER 1

//
// INTERNET_PROXY_INFO - structure supplied with INTERNET_OPTION_PROXY to get/
// set proxy information on a InternetOpen() handle
//
typedef struct {
    // dwAccessType - INTERNET_OPEN_TYPE_DIRECT, INTERNET_OPEN_TYPE_PROXY, or
    // INTERNET_OPEN_TYPE_PRECONFIG (set only)
    DWORD dwAccessType;
    // lpszProxy - proxy server list
    LPCSTR lpszProxy;
    // lpszProxyBypass - proxy bypass list
    LPCSTR lpszProxyBypass;
} ATK_INTERNET_PROXY_INFOW;

#ifdef _UNICODE
	#ifdef USE_ASTRATEK_WRAPPER
	#define ATK_INTERNET_PROXY_INFO  ATK_INTERNET_PROXY_INFOW
	#else
	#define ATK_INTERNET_PROXY_INFO  INTERNET_PROXY_INFO
	#endif
#else
	#define ATK_INTERNET_PROXY_INFO  INTERNET_PROXY_INFO
#endif // !UNICODE
				 

HINTERNET
ATK_InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );				  

#ifdef _UNICODE

	#ifdef USE_ASTRATEK_WRAPPER
	#define ATK_InternetOpen  ATK_InternetOpenW
	#else
	#define ATK_InternetOpen  InternetOpen
	#endif
#else
	#define ATK_InternetOpen  InternetOpenA
#endif // !UNICODE




HINTERNET
ATK_InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef _UNICODE
	#ifdef USE_ASTRATEK_WRAPPER
	#define ATK_InternetConnect  ATK_InternetConnectW
	#else
	#define ATK_InternetConnect  InternetConnect
	#endif
#else
	#define ATK_InternetConnect  InternetConnectA
#endif // !UNICODE


HINTERNET
ATK_HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_HttpOpenRequest  ATK_HttpOpenRequestW
	#else
	#define ATK_HttpOpenRequest  HttpOpenRequest
	#endif
#else
	#define ATK_HttpOpenRequest  HttpOpenRequestA
#endif // !UNICODE



BOOL
ATK_HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_HttpSendRequest  ATK_HttpSendRequestW
	#else
	#define ATK_HttpSendRequest  HttpSendRequest
	#endif
#else
	#define ATK_HttpSendRequest  HttpSendRequestA
#endif // !UNICODE





BOOL
ATK_InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_InternetGetLastResponseInfo  ATK_InternetGetLastResponseInfoW
	#else
	#define ATK_InternetGetLastResponseInfo  InternetGetLastResponseInfo
	#endif
#else
	#define ATK_InternetGetLastResponseInfo  InternetGetLastResponseInfoA
#endif



BOOL
ATK_HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
	);

#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_HttpQueryInfo  ATK_HttpQueryInfoW
	#else
	#define ATK_HttpQueryInfo  HttpQueryInfo
	#endif
#else
	#define ATK_HttpQueryInfo  HttpQueryInfoA
#endif

//
//  In this functin declaration we have modified the first
//  parameter type as TCHAR to have uniformity in coding in tha APP 
//  
BOOL ATK_InternetGetCookieW(IN TCHAR *lpszUrl,
					       IN TCHAR *lpszCookieName,
					  	   OUT TCHAR *lpCookieData,
						   OUT LPDWORD lpdwSize);
#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_InternetGetCookie  ATK_InternetGetCookieW
	#else
	#define ATK_InternetGetCookie  InternetGetCookie
	#endif

#else
	#define ATK_InternetGetCookie  InternetGetCookieA
#endif

BOOL
ATK_InternetQueryOptionW(IN HINTERNET hInternet,
						 IN DWORD dwOption,
						 OUT LPVOID lpBuffer,
						 IN OUT LPDWORD lpdwBufferLength);

#ifdef _UNICODE
	#ifdef  USE_ASTRATEK_WRAPPER
	#define ATK_InternetQueryOption  ATK_InternetQueryOptionW
	#else
	#define ATK_InternetQueryOption  InternetQueryOption
	#endif
#else
	#define ATK_InternetQueryOption  InternetQueryOptionA
#endif





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\cstattxt.h ===
/*********************************************************************
Registration Wizard
CStaticText.h

11/14/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#ifndef __CStaticText__
#define __CStaticText__
#include <tchar.h>

class CStaticText
{
public:
	CStaticText(HINSTANCE hInstance, HWND hwndDlg,int idControl,int idString1,int idString2);
	virtual ~CStaticText();

	LRESULT PASCAL CtlWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
	static LPTSTR LoadExtendedString(HINSTANCE hInstance,int idString1,int idString2);

private:
	HINSTANCE m_hInstance;
	LPTSTR m_szText;
	FARPROC m_lpfnOrigWndProc;
	HFONT m_hFont;
};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\regpage.h ===
/*

	File    : RegPage.h
	Date    : 12/31/97
	Author  : Suresh Krishnan
	Regsitration Wizard Page info using Wizard 97 control
	Modification History:
	4/29/98 : Removed Reseller screen constant
	4/28/98 : Added constants for Business user and Homer user screen



*/
#ifndef __REGWIZPAGE__
#define __REGWIZPAGE__

//
//
//
//
#include <Windows.h>
#include <windowsx.h>
#include <PRSHT.H>



class	 CRegWizard;
class    DialupHelperClass;
//
//  CONTROL ID of the Wizard 97 control
//  This is got using the SPY
//


#define  RWZ_WIZ97_STATIC_ID  3027
#define  RWZ_WIZ97_FINISH_ID  3025
#define  RWZ_WIZ97_NEXT_ID    3024
#define  RWZ_WIZ97_BACK_ID    3023
#define  RWZ_WIZ97_CANCEL_ID     2
#define  RWZ_WIZ97_HELP_ID       9


// for iLastKeyOperation
#define RWZ_UNRECOGNIZED_KEYPESS   0
#define RWZ_BACK_PRESSED	1
#define RWZ_NEXT_PRESSED	2
#define RWZ_CANCEL_PRESSED  3

//
//
//iCancelledByUser can have the following
#define  RWZ_SKIP_AND_GOTO_NEXT 3
#define  RWZ_ABORT_TOFINISH     2
#define  RWZ_CANCELLED_BY_USER  1
#define  RWZ_PAGE_OK            0
struct PageInfo
{

    UINT		CurrentPage;
    UINT		TotalPages;
	HFONT		hBigBoldFont;
	HFONT		hBoldFont;
	HINSTANCE 	hInstance;
	UINT        ErrorPage;  // Set By the Page exiting
	INT_PTR		iError;    // Error
	DWORD       dwConnectionType; // Via Network or Dialup
					// Set in the Welcome Screen and used in the Register Screen
	DWORD       dwMsgId;  // Msg COntext Id to be  displayed on the last page
	HPROPSHEETPAGE  *ahpsp ;  // Handle of Property sheet pages created
	CRegWizard* pclRegWizard;
	DialupHelperClass  *pDialupHelper; // This is Dialup helper class used in Dialup Screen
	int         iCancelledByUser;
	int         iLastKeyOperation;
      LPTSTR   pszProductPath;
};

//
//	Dialog Index of Registration Wizard
//

typedef enum
{	kWelcomeDialog,
	kInformDialog,
	kNameDialog,
	kAddressDialog,
	//kResellerDialog,
	kBusinessUserDialog,
	kHomeUserDialog,
	kSysInventoryDialog,
	kProductInventoryDialog,
	kRegisterDialog,
	kDialupDialog,
	kDialogExit
}RegWizScreenIndex;

//
// Used by System Inventory and Product Inventory
//
#define DO_NOT_SHOW_THIS_PAGE 1
#define DO_SHOW_THIS_PAGE     2

BOOL
Is256ColorSupported(
    VOID
    );



INT_PTR CALLBACK
WizardDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

VOID
SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId
    );

VOID
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    );

VOID
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    );

INT_PTR
DoRegistrationWizard(
                     HINSTANCE hInstance,
                     CRegWizard* clRegWizard,
                     LPTSTR szProductPath
                     );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\rwwin95.h ===
/*********************************************************************
Registration Wizard
rwWin95.h

This file contains special definitions needed by RegWizard that are
found only in the Windows95 SDK.
12/15/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#ifndef __rwWin95__
#define __rwWin95__

#include <tchar.h>

#ifndef SS_ETCHEDFRAME
#define SS_ETCHEDFRAME      0x00000012L
#endif

#ifndef VER_PLATFORM_WIN32s
#define VER_PLATFORM_WIN32s             0
#endif

#ifndef VER_PLATFORM_WIN32_WINDOWS
#define VER_PLATFORM_WIN32_WINDOWS      1
#endif

#ifndef VER_PLATFORM_WIN32_NT
#define VER_PLATFORM_WIN32_NT           2
#endif

#ifndef WM_DEVICECHANGE
#define WM_DEVICECHANGE		0x0219
#endif

#ifndef WM_HELP
#define WM_HELP             0x0053
#endif

#ifndef WM_SETICON
#define WM_SETICON          0x0080
#endif

WINUSERAPI BOOL WINAPI DrawIconEx(HDC, int, int, HICON, int, int, UINT, HBRUSH, UINT);

#endif	//rwWin95.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\regwizmain.h ===
/*********************************************************************
Registration Wizard
RegWizard.h

10/12/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
*********************************************************************/
#ifndef __regwiz__
#define __regwiz__

#ifndef __CRegWizard__
#include "CRegWiz.h"
#endif

#include <tchar.h>
// Global variable references
extern vDialogInitialized;
typedef enum
{
	kNoneFound = 0,
	kModemFound = 1,
	kConfigErr = 2,
	kModemTooSlow = 3
}ModemStatus;




ModemStatus DetectModem(HINSTANCE hInstance);
extern INT_PTR  DoRegistrationWizard(HINSTANCE hInstance, CRegWizard* clRegWizard, LPTSTR szProductPath);

BOOL CheckOEMdll(void);
typedef	int		(*pfnDialogFunc)(HWND,int,LPCTSTR );

int DisplayDialog(HWND,int nDialogType, LPCTSTR lpszFieldName);

typedef	int		(WINAPI *OEMStartDialog)(WORD,HBITMAP,HPALETTE,HWND *,pfnDialogFunc);

typedef	BOOL	(WINAPI *OEMValidate)(LPSTR,LPTSTR,WORD,LPBOOL,LPWORD);

typedef	BOOL	(WINAPI *OEMGetData)(WORD,LPBOOL,LPBYTE,WORD);

typedef	int		(WINAPI *OEMDataCount)();

typedef	void	(WINAPI *OEMRegistered)(BOOL);

static HBITMAP hOemBitmap;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\regutil.h ===
/*********************************************************************
Registration Wizard
regutil.h

12/7/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
*********************************************************************/
#include <tchar.h>
#define  RWZ_MAKE_BOLD 1
void InitDlgNormalBoldFont();
void DeleteDlgNormalBoldFont();
HFONT NormalizeDlgItemFont(HWND hwndDlg,int idControl, int iMakeBold=0);
void ReplaceDialogText(HWND hwndDlg,int idControl,LPTSTR szText);
BOOL ValidateInvDialog(HWND hwndDlg,int iStrID);
void GetEditFieldProperties(HWND hwndDlg,int stringID,short* maxLen,BOOL* isRequired);
void UpgradeDlg(HWND hwndDlg);
void LoadAndCombineString(HINSTANCE hInstance,LPCTSTR szTarget,int idReplacementString,LPTSTR szString);
void StripCharFromString(LPTSTR szInString, LPTSTR szOutString, _TCHAR charToStrip);

BOOL GetIndexedRegKeyValue(HINSTANCE hInstance, int enumIndex, LPTSTR szBaseKey,int valueStrID, LPTSTR szValue);
BOOL FileExists(LPTSTR szPathName);
void UppercaseString(LPTSTR sz);
LONG GetResNumber(HINSTANCE hInstance, int iStrResID);
BOOL Windows95OrGreater( void );
void DrawTransparentBitmap(HDC hdc, HBITMAP hBitmap, int xStart,int yStart, 
	int xWidth, int yWidth, int xSrc, int ySrc, COLORREF cTransparentColor);
BOOL GetSystemLanguageInfo(LPTSTR lpszLanguage, DWORD dwBufferSize,LANGID* lpLangId);
void GetRegWizardVersionString(HINSTANCE hIns, LPTSTR lpszVersion);
void RegWizardInfo(HWND hwndDlg);
UINT GetRegKeyValue32 ( HKEY hRootKey, LPTSTR const cszcSubKey, LPTSTR const cszcValueName,
	 PDWORD pdwType, PTBYTE pbData, UINT cbData );

BOOL FResSetDialogTabOrder(HWND hwndDlg, UINT wResStringID);
BOOL FSetDialogTabOrder(HWND hwndDlg, LPTSTR szTabOrder);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\rwpost.h ===
#ifndef _RWPOST_H_
#define	_RWPOST_H_

/**************************************************************************
   File:          RWPOST.h
   Description:   
**************************************************************************/
#define MAX_BUFFER	5*1024

#ifdef __cplusplus
extern "C" 
{
#endif
DWORD CheckInternetConnectivityExists( HWND hWnd, HINSTANCE hInstance);
DWORD_PTR CheckWithDisplayInternetConnectivityExists(HINSTANCE hIns,HWND hwnd,int iMsgType=0);
//DWORD SendHTTPData(HINSTANCE hInstance,LPTSTR czB, DWORD *dwBufSize);
DWORD SendHTTPData(HWND hWnd, HINSTANCE hInstance);
DWORD PostHTTPData(HINSTANCE hInstance);
DWORD_PTR PostDataWithWindowMessage( HINSTANCE hIns);
void  InitializeInetThread(HINSTANCE hInstance);

#ifdef __cplusplus
}
#endif

#define  RWZ_SITE_CONNECTED   1
#define  RWZ_FAIL_TOCONNECTTOSITE  0
#define  RWZ_SITE_REQUIRES_AUTHENTICATION 2

DWORD  ChkSiteAvailability( HWND hWnd,
			   LPCTSTR szIISServer,
			   DWORD   dwTimeOut,
			   LPTSTR szProxyServer,
               LPTSTR	szUserName ,
   			   LPTSTR  szPassword);

extern RECT gRect;


#endif	//_INTERFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\rw_common.h ===
#ifndef __RW_COMMON__
#define __RW_COMMON__

#include <windows.h>
#include  <stdio.h>
//#include <iostream.h>
//#include <fstream.h>
#include <tchar.h>
#include <wininet.h>

#ifdef __cplusplus
extern "C" 
{
#endif

int  InvokeRegistration ( HINSTANCE hInstance  , LPCTSTR  czPath);
void TransmitRegWizInfo ( HINSTANCE hInstance , LPCTSTR szParams,BOOL fOEM);
void DisplayInterNetConnectingMsg(HINSTANCE hIns);
void CloseDisplayInetrnetConnecting();
DWORD CheckWithDisplayInterNetConnectingMsg(HINSTANCE hIns);

void SetMSID(HINSTANCE hInstance);
BOOL GetMSIDfromRegistry(HINSTANCE hInstance,LPTSTR szValue);
BOOL GetMSIDfromCookie(HINSTANCE hInstance,LPTSTR szMSID);

DWORD_PTR GetProxyAuthenticationInfo(HINSTANCE hIns,TCHAR *czProxy,
								 TCHAR *czUserName,TCHAR *czPswd);
void  RemoveMSIDEntry(HINSTANCE hIns);

#ifdef __cplusplus
}
#endif

TCHAR * GetModemDeviceInformation(HINSTANCE hIns, int iModemIndex);
//
// Status returend while finding the removable media and cdrom
//
#define     REGFIND_ERROR      1
#define     REGFIND_RECURSE    2
#define     REGFIND_FINISH     3

//
// Status returend while Cheching for InternetConnection
//
#define     DIALUP_NOT_REQUIRED      1
#define     DIALUP_REQUIRED          2
//#define     CONNECTION_CANNOT_BE_ESTABLISHED  3

//
// HTTP Post related status messages
//
#define  RWZ_NOERROR  0
#define  RWZ_NO_INFO_AVAILABLE			1
#define  RWZ_INVALID_INFORMATION		2 
#define  RWZ_BUFFER_SIZE_INSUFFICIENT	3
#define  RWZ_INTERNAL_ERROR				4 // Internal Programming Error 
#define  RWZ_POST_SUCCESS               5
#define  RWZ_POST_FAILURE               6    
#define  RWZ_POST_WITH_SSL_FAILURE      7    
#define  RWZ_POST_MSN_SITE_BUSY         8   
#define  RWZ_ERROR_NOTCPIP              9
//
//  Error Values returned by the Signup Dialogue
//

#define  RWZ_ERROR_LOCATING_MSN_FILES       10
#define  RWZ_ERROR_LOCATING_DUN_FILES       11 
#define  RWZ_ERROR_MODEM_IN_USE             12  
#define  RWZ_ERROR_MODEM_CFG_ERROR			13 
#define  RWZ_ERROR_TXFER_CANCELLED_BY_USER	14  
#define  RWZ_ERROR_CANCELLED_BY_USER		14 
#define  RWZ_ERROR_SYSTEMERROR				15
#define  RWZ_ERROR_NODIALTONE				16
// Environment Not proper 
#define  RWZ_ERROR_MODEM_NOT_FOUND		   17
#define  RWZ_ERROR_NO_ANSWER               18    // no response engaged tone
#define  RWZ_ERROR_RASDLL_NOTFOUND         19

#define     CONNECTION_CANNOT_BE_ESTABLISHED  20 // Mdem cfg error
// Error in Invoking 
#define  RWZ_ERROR_INVALID_PARAMETER	    30
#define  RWZ_ERROR_INVALID_DLL              31
#define  REGWIZ_ALREADY_CONFIGURED			32 
#define  RWZ_ERROR_PREVIOUSCOPY_FOUND       33 

#define  RWZ_ERROR_REGISTERLATER            34   


// Status of Ping

#define   RWZ_PINGSTATUS_NOTCPIP    40
#define   RWZ_PINGSTATUS_SUCCESS    41
#define   RWZ_PINGSTATUS_FAIL       42





//
//  The below defines  is for creating a Log File 
//
#define _LOG_IN_FILE                 //	 uses a file 

class RWDebug {
public:
	RWDebug() {
		m_iError = 0;
		fp       = NULL;
	};
	~RWDebug(){};
	void     UseStandardOutput();
	void     CreateLogFile(char *czFile);
	inline  RWDebug& operator<<(RWDebug& (__cdecl * _f)(RWDebug&));
	RWDebug& operator <<( int  iv) ;
	RWDebug& operator <<( unsigned int  iv) ;
	RWDebug& operator <<( short sv) ;
	RWDebug& operator <<( unsigned short usv) ;
	RWDebug& operator <<( const unsigned short *usv) ;
	RWDebug& operator <<( void *  pVoid) ;
	RWDebug& operator <<( long  lv) ;
	RWDebug& operator <<( unsigned long ulv) ;
	RWDebug& operator <<( float  fv) ;
	RWDebug& operator <<( char   cv) ;
	//RWDebug& operator <<( bool  bv) ;
	RWDebug& operator <<( char *  sv) ;
	RWDebug& operator <<( unsigned char *  sv) ;
	RWDebug& operator <<( const char *  sv) ;
	RWDebug& flush() {return *this;};
	RWDebug& Write (char *czT); 
private :
	FILE *fp;
	char czTemp[48];
	int m_iError;
	

};
inline RWDebug& RWDebug::operator<<(RWDebug& (__cdecl * _f)(RWDebug&)) { (*_f)(*this); return *this; }
inline RWDebug& __cdecl flush(RWDebug& _outs) { return _outs.flush(); }
inline RWDebug& __cdecl endl(RWDebug& _outs) { return _outs << '\n' << flush; }

//ostream &GetDebugLogStream();
RWDebug &GetDebugLogStream();

REGSAM RW_GetSecDes() ;
int  GetProductRoot (TCHAR * pPath , PHKEY  phKey);

#define RW_DEBUG  GetDebugLogStream()



/* 
 Function name	: RegFindValueInAllSubKey
 Description	: It searches the subkey for the presence of the ValueName "Type" which has 
				  value given by szValueToFind.It returns the value of "Identifier" 
				  ValueName present along with the type in szIdentifier.
 Return Value	: TRUE if Successful else FALSE
*/
int RegFindValueInAllSubKey(HINSTANCE hInstance,HKEY key ,LPCTSTR szSubKeyNameToFind,LPCTSTR szValueToFind,LPTSTR szIdentifier,int nType );

/* 
 Function name	: RegFindTheSubKey
 Description	: Finds the key specified within the subkey. 
 Return Value	: TRUE if Successful else FALSE 
*/
BOOL RegFindTheSubKey(HKEY key,LPCTSTR szSubKeyName,LPCTSTR szSubKeyNameToFind,LPTSTR szData);
/*
 Function name	: RegGetPointingDevice
 Description	: Get the pointing device. 
 Return Value	: TRUE if Successful else FALSE 
*/
BOOL RegGetPointingDevice(HKEY hKey,LPCTSTR szSubKeyName,LPTSTR szData);


LPCTSTR BstrToSz(BSTR pszW);

#ifdef _UNICODE
	TCHAR* ConvertToUnicode(char FAR* szA);
#else
	TCHAR * ConvertToUnicode(TCHAR * szW) ;
#endif

char * ConvertToANSIString (LPCTSTR  szW);

int IsDialupConnectionActive();

HRESULT GetNewGUID(PSTR pszGUID);
//
//
//  Internet connection settings related  function
//  define ATK_INET.CPP  
int  DisableAutoDial(); // Disables Auto Dial
int  ResetAutoDialConfiguration();
void GetAutoDialConfiguration();
void UnLoadInetCfgLib();
//
//
//  product Info related function
void SetProductBeingRegistred(TCHAR *szProduct);
TCHAR *GetProductBeingRegistred();

//
// OEM DLL Validation 
#define OEM_NO_ERROR		0
#define OEM_VALIDATE_FAILED 1
#define OEM_INTERNAL_ERROR  2
int CheckOEMdll(); // This checks if Registration is with OEM
int GetOemManufacturer (TCHAR *szProductregKey, TCHAR *szBuf );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\mcx.h ===
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1994, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _MCX_H_
#define _MCX_H_

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in deciseconds
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // deciseconds
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap
    
    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap
    DWORD   dwNegotiatedDCERate;        // bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
#define DIALOPTION_BILLING  0x00000040  // Supports wait for bong "$"
#define DIALOPTION_QUIET    0x00000080  // Supports wait for quiet "@"
#define DIALOPTION_DIALTONE 0x00000100  // Supports wait for dial tone "W"

// SpeakerVolume for MODEMDEVCAPS
#define MDMVOLFLAG_LOW      0x00000001
#define MDMVOLFLAG_MEDIUM   0x00000002 
#define MDMVOLFLAG_HIGH     0x00000004 

// SpeakerVolume for MODEMSETTINGS
#define MDMVOL_LOW          0x00000000
#define MDMVOL_MEDIUM       0x00000001 
#define MDMVOL_HIGH         0x00000002

// SpeakerMode for MODEMDEVCAPS
#define MDMSPKRFLAG_OFF         0x00000001 
#define MDMSPKRFLAG_DIAL        0x00000002 
#define MDMSPKRFLAG_ON          0x00000004 
#define MDMSPKRFLAG_CALLSETUP   0x00000008

// SpeakerMode for MODEMSETTINGS
#define MDMSPKR_OFF         0x00000000 
#define MDMSPKR_DIAL        0x00000001 
#define MDMSPKR_ON          0x00000002 
#define MDMSPKR_CALLSETUP   0x00000003 
 
// Modem Options
#define MDM_COMPRESSION      0x00000001
#define MDM_ERROR_CONTROL    0x00000002
#define MDM_FORCED_EC        0x00000004
#define MDM_CELLULAR         0x00000008
#define MDM_FLOWCONTROL_HARD 0x00000010
#define MDM_FLOWCONTROL_SOFT 0x00000020
#define MDM_CCITT_OVERRIDE   0x00000040
#define MDM_SPEED_ADJUST     0x00000080
#define MDM_TONE_DIAL        0x00000100
#define MDM_BLIND_DIAL       0x00000200

#endif /* _MCX_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\sudefs.h ===
//--------------------------------------------------------------------------------
//sudefs.h    
//started - Umesh Madan
//(c)Microsoft Corporation 1995
//standard alert ids etc 
//--------------------------------------------------------------------------------


#ifndef _SUDEFS_
#define _SUDEFS_

//Return codes.
#define DIALFAILED			0
#define DIALSUCCESS			1
#define DIALCANCEL			2
#define	SIGNUPTHROTTLED		3
#define SIGNUPWANTED		4		//do signup
#define	SIGNUPDECLINED		5		//don't do signup
#define SIGNUPSETUPONLY		6		//only do setup
#define TOLLFREECANCEL		7		
#define TOLLFREEOK			8
#define PHONESYNCOK			9
#define PHONESYNCCANCEL		10
#define AUTOPICKOK			11
#define AUTOPICKCANCEL		12
#define SIGNUPDONE			16
#define SIGNUPCONTINUE		17
#define JOINOK				18
#define JOINCANCEL			19
#define JOINFAILED			20
#define LEGALAGREE			21
#define LEGALREFUSE			22
#define PRODINFOOK 			23
#define PRODINFOFAILED		24
#define USERPASSOK			25
#define USERPASSCANCEL		26
#define USERPASSFAILED		27
#define USERPASSRETRY		28
#define USERPASSACCTERROR	29	  
#define USERPASSBADCREDIT	30
#define LOCKOUTOK			31
#define LOCKOUTFAILED		32 

//Alerts - tells the inherited class what alerts to put up.
#define ALERTIDCANCEL		1						//do a cancellation alert
#define ALERTIDRETRY		ALERTIDCANCEL + 1		//do a general retry this action alert
#define ALERTIDSETTINGS		ALERTIDRETRY + 1		//display connection settings etc..
#define ALERTIDGENERAL		ALERTIDSETTINGS + 1		//general no retry alert.. 
#define ALERTIDNOMODEM		ALERTIDGENERAL + 1		//no modem alert
#define ALERTIDLINEDROPPED	ALERTIDNOMODEM + 1		//line dropped alert.
#define ALERTIDOOM			ALERTIDLINEDROPPED + 1	//out of memory
#define ALERTIDFTMERROR		ALERTIDOOM + 1			//ftm error
#define ALERTIDNOTEXT		ALERTIDFTMERROR + 1		//blank edit field
#define ALERTIDDBCS			ALERTIDNOTEXT + 1		//DBCS characters found... 
#define ALERTIDLESSTEXT		ALERTIDDBCS + 1			//not enough text in edit field 
#define ALERTIDHASSPACES    ALERTIDLESSTEXT + 1		//string has spaces

//Status - tells the inherited class the status of the call
#define STATUSIDINIT		1		//initializing..
#define STATUSIDDIAL		2		//dialing..
#define STATUSIDCONNECT		3		//connected..
#define STATUSIDDISCONNECT	4		//disconnected..
#define STATUSIDCANCELLING	5		//cancelling..
#define STATUSIDCANCEL		6		//cancelled..
#define STATUSTRANSFER		7		//transferring data..

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\debug.h ===
#ifndef _PHBKDEBUG
#define _PHBKDEBUG

//extern "C" {
	void Dprintf(LPCSTR pcsz, ...);
//}

#ifdef DEBUG
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags);
	void DebugSz(LPCSTR psz);
//#ifdef __cplusplus
//}
//#endif // __cplusplus
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
	#define Assert(f)					AssertSz((f), "!(" #f ")")
#else
	#define DebugSz(x)
	#define AssertSzFlg(f, sz, dwFlg) (f)
	#define AssertSz(f, sz) (f)
	#define Assert(f) (f)
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\version.h ===
#include <tchar.h>
#define rmj		3
#define rmm		0
#define rup		0
#define szVerName	_T""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\ccsv.h ===
#ifndef _CCSV
#define _CCSV

#include <windows.h>
#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for phone books
class CCSVFile
{
	
	public:
		void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
		void operator delete( void far * p ) {GlobalFree(p); };

		CCSVFile();
		~CCSVFile();
		BOOLEAN Open(LPCSTR pszFileName);
		BOOLEAN ReadToken(LPSTR pszDest, DWORD cbMax);	// reads up to comma or newline, returns fFalse on EOF
		void Close(void);
		inline int ILastRead(void)
			{
			return m_iLastRead;
			}

	private:
		BOOL 	FReadInBuffer(void);
		inline int 	ChNext(void);
		char 	m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
		LPSTR 	m_pchBuf;			//pointer to the next item in the buffer to read
		LPSTR	m_pchLast;			//pointer to the last item in the buffer
		int  	m_iLastRead;		//the character last read.
		DWORD 	m_cchAvail;
		HANDLE 	m_hFile;

}; // ccsv
#endif //_CCSV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\debug.cpp ===
/*-----------------------------------------------------------------------------

  debug.cpp

	This file implements the debuggin features

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
		7/31/96 ValdonB Changes for Win16
	
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>





BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(LPCSTR psz)
{
#if defined(DEBUG)
	OutputDebugString(psz);
#endif	
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(LPCSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintf(szBuf, pcsz, argp);

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags)
{

	BOOL fAssertIntoDebugger = FALSE;

	char szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	//BYTE	szTime[80];
#if !defined(WIN16)
	CHAR	szTime[80];
	HANDLE	hAssertTxt;
	SYSTEMTIME st;
	DWORD	cbWritten;
#endif
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz("***Recursive Assert***\r\n");
		return(FALSE);
		}

	fInAssert = TRUE;
	
#if defined(WIN16)
	GetModuleFileName(g_hInstDll, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%ld\r\n%s,\r\n%s", szFile, dwLine, szFileName, szMsg);
#else
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
#endif
	wsprintf(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
#if !defined(WIN16)
	hAssertTxt = CreateFile("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);   
		wsprintf(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}
#endif

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
#if defined(WIN16)
			abort();
#else
    		ExitProcess(0);
#endif
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;  
	
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\include\sysinv.h ===
#ifndef __sysinv__
#define __sysinv__

#ifdef  __cplusplus
extern "C" {
#endif

/*
 * Function:
 *	BOOL WINAPI GetSystemInventory(INT type, LPTSTR szInventory);
 *
 * Description:
 *	Get system inventory information by type caller asked
 *
 * Parameters:
 *	INT type:	specify what type information caller.  Should be one of INV_* constants
 *	LPTSTR szInventory:	The description of specific item information on return.  The contents depends on item type.
 *						The length of the buffer has to be at least 256.
 *
 * Return Value:
 *	TRUE on success.
 *	FALSE on failure.  szInventory[0] is also assigned 0
 */
BOOL WINAPI GetSystemInventory(INT, LPTSTR);

#define SYSINV_DLL_PRESENT  1
#define SYSINV_DLL_NOTPRESENT  2

int  CheckSysInvDllPresent();

void GetOEMString(HINSTANCE hInstance, LPTSTR szOEM);
void GetProcessorTypeString(HINSTANCE hInstance, LPTSTR szProcessor);
void GetTotalMemoryString(HINSTANCE hInstance, LPTSTR szTotalMemory);
void GetTotalHardDiskSpaceString(HINSTANCE hInstance, LPTSTR szTotalHardDiskSpace);
void GetDisplayResolutionString(HINSTANCE hInstance, LPTSTR szDisplayResolution);
void GetDisplayColorDepthString(HINSTANCE hInstance, LPTSTR szDisplayColorDepth);
void GetWindowsVersionString(HINSTANCE hInstance, LPTSTR szVersion);
void GetNetworkCardString(HINSTANCE hInstance, LPTSTR szNetwork);
void GetModemString(HINSTANCE hInstance, LPTSTR szModem);
void GetPointingDeviceString(HINSTANCE hInstance, LPTSTR szPointingDevice);
void GetCDRomString(HINSTANCE hInstance, LPTSTR szCDRom);
void GetSoundCardString(HINSTANCE hInstance, LPTSTR szSoundCard);
void GetRemoveableMediaString(HINSTANCE hInstance, LPTSTR szRemoveableMedia, int iBufSize);
void GetSCSIAdapterString(HINSTANCE hInstance, LPTSTR szScsi);

BOOL IsCoProcessorAvailable( HINSTANCE hInstance );
LONG GetTotalHardDiskSpace( void );
void GetDisplayCharacteristics(PINT horizResolution, PINT vertResolution,PINT colorDepth);
void GetWindowsVersion(LONG* lpPlatform, LONG* lpMajorVersion,LONG* lpMinorVersion,LONG* lpBuildNumber);

#define INV_OEM				1	// szInventory: Descriptive string
#define INV_PROCESSORTYPE	2	// szInventory: Descriptive string
#define INV_TOTALMEMORY		3	// szInventory: Descriptive string
#define INV_TOTALHDSPACE	4	// szInventory: Descriptive string
#define INV_DISPRESOLUTION	5	// szInventory: Descriptive string
#define INV_DISPCOLORDEPTH	6	// szInventory: Descriptive string
#define INV_WINVERSION		7	// szInventory: Descriptive string
#define INV_NETCARD			8	// szInventory: Descriptive string
#define INV_MODEM			9	// szInventory: Descriptive string
#define INV_POINTDEVICE		10	// szInventory: Descriptive string
#define INV_CDROM			11	// szInventory: Descriptive string
#define INV_SOUNDCARD		12	// szInventory: Descriptive string
#define INV_REMOVEABLEMEDIA	13	// szInventory: Descriptive string
#define INV_COPRECESSOR		14	// szInventory[0] = 1 for available, 0 for nonavailable
#define INV_SCSIADAPTER     15  
#define INV_DISPLAY_ADAPTER 16  // Display Adapter with Driver
#define INV_DISPLAY_WITH_RESOLUTION 17 // Display Adapter and Color resolution        //
#ifdef __cplusplus
}   /* ... extern "C" */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\main.cpp ===
// ############################################################################
#include "pch.hpp"

extern "C" {
HINSTANCE g_hInstDll;	// instance for this DLL  
}


#ifdef WIN16

int CALLBACK LibMain(HINSTANCE hinst, 
						WORD wDataSeg, 
						WORD cbHeap,
						LPSTR lpszCmdLine )
{
	g_hInstDll = hinst;

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   PrivateMalloc()
//
//  Synopsis:   Allocate and initialize memory
//
//  Arguments:  [size	- Size of memory block to be allocated]
//
//	Returns:	pointer to memory block if successful
//				NULL otherwise
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void far *PrivateMalloc(size_t size)
{
	void far * ReturnValue = NULL;
	
	ReturnValue = malloc(size);
	if (NULL != ReturnValue)
		memset(ReturnValue, 0, size);
		
	return ReturnValue;
}

//+---------------------------------------------------------------------------
//
//  Function:   PrivateReAlloc()
//
//  Synopsis:   Reallocate memory
//
//  Arguments:  [lpBlock 	- Block to be reallocated ]
//				[size		- Size of memory block to be allocated]
//
//	Returns:	pointer to memory block if successful
//				NULL otherwise
//
//  History:    7/25/96     ValdonB    Created
//
//----------------------------------------------------------------------------
void far *PrivateReAlloc(void far *lpBlock, size_t size)
{
	void far *lpRetBlock;
	
	lpRetBlock = PrivateMalloc(size);
	if (NULL == lpRetBlock)
		return NULL;
	
	if (NULL != lpBlock)
	{
		size_t OldBlockSize, MoveSize;
		
		OldBlockSize = _msize(lpBlock);
		MoveSize = min(OldBlockSize, size);
		memmove(lpRetBlock, lpBlock, MoveSize);  
		PrivateFree(lpBlock);
	}
	
	return lpRetBlock;
}


//+---------------------------------------------------------------------------
//
//  Function:   PrivateFree
//
//  Synopsis:   Free a block of memory
//
//  Arguments:  [lpBlock - Block to be freed]
//
//	Returns:	Nothing
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void PrivateFree(void far *lpBlock)
{
	free(lpBlock);
}


//+---------------------------------------------------------------------------
//
//  Function:   SearchPath()
//
//  Synopsis:   Searchs for the specified file in the given path
//
//  Arguments:  [lpPath			- Address of search path]
//				[lpFileName		- Address of filename]
//				[lpExtension	- Address of Extension]
//				[nBufferLength	- size, in characters, of buffer]
//				[lpBuffer		- address of buffer for found filename]
//				[lpFilePart		- address of pointer to file component]
//
//	Returns:	Length of string copied to buffer (not including terminating
//					NULL character) if successful
//				0 otherwise
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
DWORD SearchPath(LPCTSTR lpPath,LPCTSTR lpFileName, LPCTSTR lpExtension,
					DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart)
{ 
	
	BOOL bUseExtension = FALSE, bPathContainsFileName = FALSE;
	DWORD dwRequiredLength;
	LPSTR lpszPath = lpPath;
	char szFileName[MAX_PATH+1];
	OFSTRUCT OpenBuf;
		
	
	
	// Check if extension should be used
	//
	if ((NULL != lpExtension) && !strchr(lpFileName, '.'))
		bUseExtension = TRUE;

	//
	// Form Filename
	//
	lstrcpy(szFileName, lpFileName);
	if (bUseExtension)
		lstrcat(szFileName, lpExtension);
	
	
	//
	// If search path is NULL, then try to OpenFile using OF_SEARCH flag
	// get the full path in OpenBuf struct
	//
	if (NULL == lpszPath)
	{
		
		if (HFILE_ERROR != OpenFile(szFileName, &OpenBuf, OF_EXIST | OF_SEARCH))
		{ 
			//
			// This path contains the file name also
			//
			lpszPath = &OpenBuf.szPathName[0];
			bPathContainsFileName = TRUE;
		}
		else
			return 0;
	}
			
	//
	// Check if output buffer length is sufficient
	//
	dwRequiredLength = lstrlen(lpszPath) + 
						(bPathContainsFileName ? 0 :lstrlen(szFileName)) + 1;
	if (nBufferLength < dwRequiredLength)
		return 0;

	//
	// Copy the full name to buffer
	//
	if (bPathContainsFileName)
		lstrcpy(lpBuffer, lpszPath);
	else
		wsprintf(lpBuffer, "%s\\%s", lpszPath, szFileName);

	
	//
	// Do not include the terminating null character in return length
	//
	return dwRequiredLength - 1;
}


#else // WIN16

#ifdef   _NOT_USING_ACTIVEX 
extern "C" __declspec(dllexport) BOOL WINAPI DllMain(
    HINSTANCE  hinstDLL,	// handle to DLL module 
    DWORD  fdwReason,		// reason for calling function 
    LPVOID  lpvReserved 	// reserved 
   )
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_hInstDll = hinstDLL;
    
	return TRUE;
}
#if 0
extern "C" __declspec(dllexport) BOOL WINAPI DllMain(
    HINSTANCE  hinstDLL,	// handle to DLL module 
    DWORD  fdwReason,		// reason for calling function 
    LPVOID  lpvReserved 	// reserved 
   )
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_hInstDll = hinstDLL;
    
	return TRUE;
}
#endif

#endif
#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\ccsv.cpp ===
// ############################################################################
// INCLUDES
#include "pch.hpp"

#include "ccsv.h"
#include "debug.h"

// ############################################################################
// DEFINES
#define chComma ','
#define chNewline '\n'
#define chReturn '\r'

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
	m_hFile = 0;
	m_iLastRead = 0;
	m_pchLast = m_pchBuf = NULL;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
	AssertSz(!m_hFile,"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCSTR pszFileName)
{
	AssertSz(!m_hFile, "a file is already open.");
		
	m_hFile = CreateFile((LPCTSTR)pszFileName, 
							GENERIC_READ, FILE_SHARE_READ, 
							0, OPEN_EXISTING, 0, 0);
	if (INVALID_HANDLE_VALUE == m_hFile)
	{
		return FALSE;
	}
	m_pchLast = m_pchBuf = NULL;
	return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(LPSTR psz, DWORD cbMax)
{
	LPSTR	pszLast;
	char		ch;

	ch = (char) ChNext();
	if (-1 == ch)
		{
		return FALSE;
		}

	pszLast = psz + (cbMax - 1);
	while (psz < pszLast && chComma != ch && chNewline != ch && -1 != ch)
		{
		*psz++ = ch;
		ch = (char) ChNext(); //Read in the next character
		}

	*psz++ = '\0';

	return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
	if (m_hFile)
		CloseHandle(m_hFile);
#ifdef DEBUG
	if (!m_hFile) Dprintf("CCSVFile::Close was called, but m_hFile was already 0\n");
#endif
	m_hFile = 0;
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
	//Read another buffer
#ifdef WIN16
	if ((m_cchAvail = _read(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE)) <= 0)
		return FALSE;
#else
	if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
		{
		return FALSE;	 //nothing more to read
		}
#endif

	m_pchBuf = m_rgchBuf;
	m_pchLast = m_pchBuf + m_cchAvail;
	
	return TRUE; //success
}

// ############################################################################
inline int CCSVFile::ChNext(void)
{

LNextChar:
	if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
		return -1;	 //nothing more to read

	m_iLastRead = *m_pchBuf++;
	if (chReturn == m_iLastRead)
		goto LNextChar;		//faster to NOT make extra function call

	return m_iLastRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\misc.cpp ===
// ############################################################################
// Miscellaneous support routines
#include "pch.hpp"
#include "phbk.h"

#define irgMaxSzs 5
char szStrTable[irgMaxSzs][256];

// ############################################################################
LPSTR GetSz(WORD wszID)
{
	static int iSzTable=0;
	LPSTR psz = (LPSTR)&szStrTable[iSzTable][0];
	
	iSzTable++;
	if (iSzTable >= irgMaxSzs)
		iSzTable = 0;
		
	if (!LoadString(g_hInstDll, wszID, psz, 256))
	{
		Dprintf("LoadString failed %d\n", (DWORD) wszID);
		*psz = 0;
	}
		
	return (psz);
}

// ############################################################################
void SzCanonicalFromAE (LPSTR psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE)
{
	if (NO_AREA_CODE == pAE->dwAreaCode)
	{
		wsprintf(psz, "+%ld %s", pLCE->dwCountryCode, pAE->szAccessNumber);
	}
	else
	{
		wsprintf(psz, "+%ld (%s) %s", pLCE->dwCountryCode, pAE->szAreaCode, pAE->szAccessNumber);
	}
	
	return;
}

// ############################################################################
int MyStrcmp(LPVOID pv1, LPVOID pv2)
{
	LPSTR pc1 = (LPSTR) pv1;
	LPSTR pc2 = (LPSTR) pv2;
	int iRC = 0;
	// loop while not pointed at the ending NULL character and no difference has been found
	while (*pc1 && *pc2 && !iRC)
	{
		iRC = (int)(*pc1 - *pc2);
		pc1++;
		pc2++;
	}

	// if we exited because we got to the end of one string before we found a difference
	// return -1 if pv1 is longer, else return the character pointed at by pv2.  If pv2
	// is longer than pv1 then the value at pv2 will be greater than 0.  If both strings
	// ended at the same time, then pv2 will point to 0.
	if (!iRC)
	{
		iRC = (*pc1) ? -1 : (*pc2);
	}
	return iRC;
}
// ############################################################################
int __cdecl Compare950Entry(const void*pv1, const void*pv2)
{
	return (((NPABLOCK *) pv1)->wAreaCode - ((NPABLOCK *) pv2)->wAreaCode);
}

// ############################################################################
int __cdecl CompareIDLookUpElements(const void *e1, const void *e2)
{
	if (((LPIDLOOKUPELEMENT)e1)->dwID > ((LPIDLOOKUPELEMENT)e2)->dwID)
		return 1;
	if (((LPIDLOOKUPELEMENT)e1)->dwID < ((LPIDLOOKUPELEMENT)e2)->dwID)
		return -1;
	return 0;
}

// ############################################################################
int __cdecl CompareCntryNameLookUpElements(const void *e1, const void *e2)
{
	LPCNTRYNAMELOOKUPELEMENT pCUE1 = (LPCNTRYNAMELOOKUPELEMENT)e1;
	LPCNTRYNAMELOOKUPELEMENT pCUE2 = (LPCNTRYNAMELOOKUPELEMENT)e2;

#ifdef WIN16
	return lstrcmpi(pCUE1->psCountryName, pCUE2->psCountryName);
#else		
	return CompareString(LOCALE_USER_DEFAULT,0,pCUE1->psCountryName,
		pCUE1->dwNameSize,pCUE2->psCountryName,
		pCUE2->dwNameSize) - 2;
//	return CompareString(LOCALE_USER_DEFAULT,0,((LPCNTRYNAMELOOKUPELEMENT)*e1)->psCountryName,
//		((LPCNTRYNAMELOOKUPELEMENT)*e1)->dwNameSize,((LPCNTRYNAMELOOKUPELEMENT)*e2)->psCountryName,
//		((LPCNTRYNAMELOOKUPELEMENT)*e2)->dwNameSize) - 2;
#endif
}

// ############################################################################
int __cdecl CompareIdxLookUpElements(const void *e1, const void *e2)
{
	if (((LPIDXLOOKUPELEMENT)e1)->dwIndex > ((LPIDXLOOKUPELEMENT)e2)->dwIndex)
		return 1;
	if (((LPIDXLOOKUPELEMENT)e1)->dwIndex < ((LPIDXLOOKUPELEMENT)e2)->dwIndex)
		return -1;
	return 0;
}

// ############################################################################
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2)
{
	PACCESSENTRY pae1, pae2;
	int iSort;

	pae1 = ((LPIDXLOOKUPELEMENT)pv1)->pAE;
	pae2 = ((LPIDXLOOKUPELEMENT)pv2)->pAE;

	// sort empty enteries to the end of the list
	if (!(pae1 && pae2))
	{
		return (pae1 ? -1 : (pae2 ? 1 : 0));
	}

	// country ASC, state ASC, city ASC, toll free DESC, flip DESC, con spd max DESC
	if (pae1->dwCountryID != pae2->dwCountryID)
	{
		return (int)(pae1->dwCountryID - pae2->dwCountryID);
	}
	
	if (pae1->wStateID != pae2->wStateID)
	{
		return (pae1->wStateID - pae2->wStateID);
	}

	iSort  = MyStrcmp((LPVOID)pae1->szCity, (LPVOID)pae2->szCity);
	if (iSort)
	{
		return (iSort);
	}

	if (pae1->fType != pae2->fType)
	{
		return (pae2->fType - pae1->fType);
	}

	if (pae1->bFlipFactor != pae2->bFlipFactor)
	{
		return (pae2->bFlipFactor - pae1->bFlipFactor);
	}

	if (pae1->dwConnectSpeedMax != pae2->dwConnectSpeedMax)
	{
		return (int)(pae2->dwConnectSpeedMax - pae1->dwConnectSpeedMax);
	}

	return 0;
}

// ############################################################################
//inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
BOOL FSz2Dw(LPCSTR pSz,DWORD far *dw)
{
	DWORD val = 0;
	while (*pSz)
	{
		if (*pSz >= '0' && *pSz <= '9')
		{
			val *= 10;
			val += *pSz++ - '0';
		}
		else
		{
			return FALSE;  //bad number
		}
	}
	*dw = val;
	return (TRUE);
}

// ############################################################################
//inline BOOL FSz2W(PCSTR pSz,WORD *w)
BOOL FSz2W(LPCSTR pSz,WORD far *w)
{
	DWORD dw;
	if (FSz2Dw(pSz,&dw))
	{
		*w = (WORD)dw;
		return TRUE;
	}
	return FALSE;
}

// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2B(LPCSTR pSz,BYTE far *pb)
{
	DWORD dw;
	if (FSz2Dw(pSz,&dw))
	{
		*pb = (BYTE)dw;
		return TRUE;
	}
	return FALSE;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
	HFONT hfont = NULL;

	hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	if (hfont) DeleteObject(hfont);
	return ERROR_SUCCESS;
}

// ############################################################################
HRESULT MakeBold (HWND hwnd)
{
	HRESULT hr = ERROR_SUCCESS;
	HFONT hfont = NULL;
	HFONT hnewfont = NULL;
	LOGFONT far * plogfont = NULL;

	if (!hwnd) goto MakeBoldExit;

	hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	if (!hfont)
	{
		hr = GetLastError();
		goto MakeBoldExit;
	}
    
	plogfont = (LOGFONT far *)GlobalAlloc(GPTR,sizeof(LOGFONT));
	if (!plogfont)
	{
		hr = GetLastError();
		goto MakeBoldExit;
	}

	if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
	{
		hr = GetLastError();
		goto MakeBoldExit;
	}

	if (plogfont->lfHeight < 24)
	{
		plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
	}

	plogfont->lfWeight = FW_BOLD;

	if (!(hnewfont = CreateFontIndirect(plogfont)))
	{
		hr = GetLastError();
		goto MakeBoldExit;
	}

	SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(FALSE,0));

	GlobalFree(plogfont);
	plogfont = NULL;
	
MakeBoldExit:
	//if (hfont) DeleteObject(hfont);
	// BUG:? Do I need to delete hnewfont at some time?
	return hr;
}

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//	Function:	DWGetWin32Platform
//
//	Synopsis:	Return a value to determine win32 platform
//
//	Arguements:	None
//
//	Returns:	platform enumeration (see GetVersionEx for details)
//
//	History:	8/8/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
DWORD DWGetWin32Platform()
{
	OSVERSIONINFO osver;
	ZeroMemory(&osver,sizeof(osver));
	osver.dwOSVersionInfoSize = sizeof(osver);
	if (GetVersionEx(&osver))
		return osver.dwPlatformId;
	AssertSz(0,"GetVersionEx failed.\r\n");
	return 0;
}

//+----------------------------------------------------------------------------
//
//	Function:	DWGetWin32BuildNumber
//
//	Synopsis:	Return a value to determine win32 build
//
//	Arguements:	None
//
//	Returns:	build number
//
//	History:	9/26/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
DWORD DWGetWin32BuildNumber()
{
	OSVERSIONINFO osver;
	ZeroMemory(&osver,sizeof(osver));
	osver.dwOSVersionInfoSize = sizeof(osver);
	if (GetVersionEx(&osver))
		// dwBuildNumber
		// Identifies the build number of the operating system in the low-order
		// word. (The high-order word contains the major and minor version numbers.)
		return (osver.dwBuildNumber & 0xFFFF);
	AssertSz(0,"GetVersionEx failed.\r\n");
	return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\misc.h ===
// ############################################################################
// PROTOTYPES
LPSTR GetSz(WORD wszID);
void SzCanonicalFromAE (LPSTR psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE);
int __cdecl CompareIDLookUpElements(const void *e1, const void *e2);
int __cdecl CompareCntryNameLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2);
int __cdecl Compare950Entry(const void*e1, const void*e2);
BOOL FSz2Dw(LPCSTR pSz,DWORD far *dw);
BOOL FSz2W(LPCSTR pSz,WORD far *w);
BOOL FSz2B(LPCSTR pSz,BYTE far *pb);
HRESULT MakeBold (HWND hwnd);
HRESULT ReleaseBold(HWND hwnd);
#if !defined(WIN16)
DWORD DWGetWin32Platform();
DWORD DWGetWin32BuildNumber();
#endif
/*
inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw);
inline BOOL FSz2W(PCSTR pSz,WORD *w);
inline BOOL FSz2B(PCSTR pSz,BYTE *pb);
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\pch.h ===
#include <windows.h>

#include <tapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\pch.hpp ===
#include <windows.h>


#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>

#include <ras.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\phbk.cpp ===
// ############################################################################
// Phone book APIs
#include "pch.hpp"
#include <tchar.h>

#include "phbk.h"
#include "misc.h"
#include "phbkrc.h"
#include "suapi.h"

#define ReadVerifyPhoneBookDW(x)	if (!ReadPhoneBookDW(&(x),pcCSVFile))				\
										{	AssertSz(0,"Invalid DWORD in phone book");	\
											goto ReadError; }
#define ReadVerifyPhoneBookW(x)		if (!ReadPhoneBookW(&(x),pcCSVFile))				\
										{	AssertSz(0,"Invalid DWORD in phone book");	\
											goto ReadError; }
#define ReadVerifyPhoneBookB(x)		if (!ReadPhoneBookB(&(x),pcCSVFile))				\
										{	AssertSz(0,"Invalid DWORD in phone book");	\
											goto ReadError; }
#define ReadVerifyPhoneBookSZ(x,y)	if (!ReadPhoneBookSZ(&x[0],y+sizeof('\0'),pcCSVFile))	\
										{	AssertSz(0,"Invalid DWORD in phone book");		\
											goto ReadError; }

#define CHANGE_BUFFER_SIZE 50

#define TEMP_PHONE_BOOK_PREFIX "PBH"

#define ERROR_USERBACK 32766
#define ERROR_USERCANCEL 32767

char szTempBuffer[TEMP_BUFFER_LENGTH];
char szTempFileName[MAX_PATH];

#ifdef __cplusplus
extern "C" {
#endif
HWND g_hWndMain;
#ifdef __cplusplus
}
#endif


static void GetAbsolutePath( LPTSTR input, LPTSTR output, DWORD chOut)
	{
		if(_tcschr(input,_T('%')) == NULL) {
			_tcsncpy(output, input, chOut);
			return ;
		}

		if(input[0] == _T('%'))
		{
			LPTSTR token = _tcstok(input,_T("%"));
			if(token != NULL)
			{
				LPTSTR sztemp;
				sztemp = getenv( token );
				if(sztemp != NULL)
				{
					_tcsncpy(output, sztemp, chOut);
				}
				token = _tcstok(NULL,_T("\0"));
				if(token != NULL)
				{
					_tcsncat(output, token, chOut - _tcslen(output));
				}
			}
		}
		else
		{
			LPTSTR token = _tcstok(input,_T("%"));
			if(token != NULL)
			{
				_tcsncpy(output, token, chOut);
				token = _tcstok(NULL,_T("%"));
				if(token != NULL)
				{
					LPTSTR sztemp;
					sztemp = getenv( token );
					if(sztemp != NULL)
					{
						_tcsncat(output, sztemp, chOut - _tcslen(output));
					}
					token = _tcstok(NULL,_T("\0"));
					if(token != NULL)
					{
						_tcsncat(output, token, chOut - _tcslen(output));
					}
				}
			}
		}
		
		GetAbsolutePath(output, output, chOut);
	}



// ############################################################################
CPhoneBook::CPhoneBook()
{
	HINSTANCE hInst = NULL;
	LONG lrc;
//	HANDLE   hKey;
	LONG  regStatus;
	char  uszRegKey[]="SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE";
	char  uszR[ ]= "Path";
	DWORD dwInfoSize ;
	HKEY  hKey;

	DWORD dwType;
	DWORD dwSize;
	CHAR  szData[MAX_PATH+1];
	CHAR  czTemp[256];

	m_rgPhoneBookEntry = NULL;
	m_hPhoneBookEntry = NULL;
	m_cPhoneBookEntries =0;
	m_rgLineCountryEntry=NULL;
	m_rgState=NULL;
	m_cStates=0;
	m_rgIDLookUp = NULL;
	m_rgNameLookUp = NULL;
	m_pLineCountryList = NULL;

	ZeroMemory(&m_szINFFile[0],MAX_PATH);
	ZeroMemory(&m_szINFCode[0],MAX_INFCODE);
	ZeroMemory(&m_szPhoneBook[0],MAX_PATH);
	ZeroMemory(&m_szICWDirectoryPath,MAX_PATH);

	

	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					uszRegKey,0,KEY_READ ,&hKey);
	if (regStatus == ERROR_SUCCESS) {
		// Get The Path
		dwInfoSize = MAX_PATH;
		RegQueryValueEx(hKey,uszR,NULL,0,(LPBYTE) czTemp,
			&dwInfoSize);
		GetAbsolutePath(czTemp,m_szICWDirectoryPath, MAX_PATH-1);
		size_t sLen = strlen(m_szICWDirectoryPath);
		m_szICWDirectoryPath[sLen-1] = '\0';
	}
	else {

		MessageBox(NULL,"Error Accessing PAth ","SearchPath",MB_OK);
		// Error
	}


#if !defined(WIN16)
	if (VER_PLATFORM_WIN32_NT == DWGetWin32Platform())
	{
		m_bScriptingAvailable = TRUE;
	}
	else
	{
		//
		// Verify scripting by checking for smmscrpt.dll in RemoteAccess registry key
		//
		if (1111 <= DWGetWin32BuildNumber())
		{
			m_bScriptingAvailable = TRUE;
		}
		else
		{
			m_bScriptingAvailable = FALSE;
			hKey = NULL;
			lrc=RegOpenKey(HKEY_LOCAL_MACHINE,"System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP",&hKey);
			if (ERROR_SUCCESS == lrc)
			{
				dwSize = MAX_PATH;
				lrc = RegQueryValueEx(hKey,"Path",0,&dwType,(LPBYTE)szData,&dwSize);
				if (ERROR_SUCCESS == lrc)
				{
					if (0 == lstrcmpi(szData,"smmscrpt.dll"))
						m_bScriptingAvailable = TRUE;
				}
			}
			if (hKey)
				RegCloseKey(hKey);
			hKey = NULL;
		}

		//
		// Verify that the DLL can be loaded
		//
		if (m_bScriptingAvailable)
		{
			hInst = LoadLibrary("smmscrpt.dll");
			if (hInst)
				FreeLibrary(hInst);
			else
				m_bScriptingAvailable = FALSE;
			hInst = NULL;
		}
	}
#endif // WIN16
}

// ############################################################################
CPhoneBook::~CPhoneBook()
{
#ifdef WIN16
	if (m_rgPhoneBookEntry)
		GlobalFree(m_rgPhoneBookEntry);
#else
	if (m_hPhoneBookEntry)
		GlobalUnlock(m_hPhoneBookEntry);

	if (m_hPhoneBookEntry)
		GlobalFree(m_hPhoneBookEntry);
#endif

	if (m_pLineCountryList)
		GlobalFree(m_pLineCountryList);

	if (m_rgIDLookUp)
		GlobalFree(m_rgIDLookUp);

	if (m_rgNameLookUp)
		GlobalFree(m_rgNameLookUp);

	if (m_rgState)
		GlobalFree(m_rgState);
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookDW(DWORD far *pdw, CCSVFile far *pcCSVFile)
{
	if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
			return FALSE;
	return (FSz2Dw(szTempBuffer,pdw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookW(WORD far *pw, CCSVFile far *pcCSVFile)
{
	if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
			return FALSE;
	return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookB(BYTE far *pb, CCSVFile far *pcCSVFile)
{
	if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
			return FALSE;
	return (FSz2B(szTempBuffer,pb));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile)
{
	if (!pcCSVFile->ReadToken(psz,dwSize))
			return FALSE;
	return TRUE;
}

// ############################################################################
BOOL CPhoneBook::FixUpFromRealloc(PACCESSENTRY paeOld, PACCESSENTRY paeNew)
{
	BOOL bRC = FALSE;
	LONG_PTR lDiff = 0;
	DWORD idx = 0;

	//
	// No starting value or no move, therefore no fix-ups needed
	//
	if ((0 == paeOld) || (paeNew == paeOld))
	{
		bRC = TRUE;
		goto FixUpFromReallocExit;
	}

	Assert(paeNew);
	Assert(((LONG_PTR)paeOld) > 0);	// if these address look like negative numbers
	Assert(((LONG_PTR)paeNew) > 0); // I'm not sure the code would handle them

	lDiff = (LONG_PTR)paeOld - (LONG_PTR)paeNew;

	//
	// fix up STATES
	//
	for (idx = 0; idx < m_cStates; idx++)
	{
		if (m_rgState[idx].paeFirst)
			m_rgState[idx].paeFirst = (PACCESSENTRY )((LONG_PTR)m_rgState[idx].paeFirst - lDiff);
	}

	//
	// fix up ID look up array
	//
	for (idx = 0; idx < m_pLineCountryList->dwNumCountries ; idx++)
	{
		if (m_rgIDLookUp[idx].pFirstAE)
			m_rgIDLookUp[idx].pFirstAE = (PACCESSENTRY )((LONG_PTR)m_rgIDLookUp[idx].pFirstAE - lDiff);
	}

	bRC = TRUE;
FixUpFromReallocExit:
	return bRC;
}
/*
long WINAPI lineGetCountry(unsigned long x,unsigned long y,struct linecountrylist_tag *z)
{
	return 0;
}
*/
// ############################################################################
HRESULT CPhoneBook::Init(LPCSTR pszISPCode)
{
	LPLINECOUNTRYLIST pLineCountryTemp = NULL;
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	DWORD dwLastState = 0;
	DWORD dwLastCountry = 0;
	DWORD dwSizeAllocated;
	PACCESSENTRY pCurAccessEntry;
        PACCESSENTRY pAETemp;
	HGLOBAL pTemp;
	LPLINECOUNTRYENTRY pLCETemp;
	DWORD idx;
	LPSTR pszTemp;
	CCSVFile far *pcCSVFile=NULL;
	LPSTATE	ps,psLast; //faster to use pointers.
	int iTestSK;
	

	// Get TAPI country list
	m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
	if (!m_pLineCountryList)
		goto InitExit;
	
	m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);

	
	
#if defined(WIN16)
	idx = (DWORD) IETapiGetCountry(0, m_pLineCountryList);
#else
	idx = lineGetCountry(0,0x10003,m_pLineCountryList);
#endif
	if (idx && idx != LINEERR_STRUCTURETOOSMALL)
		goto InitExit;
	
	Assert(m_pLineCountryList->dwNeededSize);

	pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
														(size_t)m_pLineCountryList->dwNeededSize);
	if (!pLineCountryTemp)
		goto InitExit;
	
	pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
	GlobalFree(m_pLineCountryList);
	
	m_pLineCountryList = pLineCountryTemp;
	pLineCountryTemp = NULL;

#if defined(WIN16)
	if (IETapiGetCountry(0, m_pLineCountryList))
#else
	if (lineGetCountry(0,0x10003,m_pLineCountryList))
#endif
		goto InitExit;

//#endif	// WIN16

	// Load Look Up arrays
#ifdef DEBUG
	m_rgIDLookUp = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,
		(int)(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries+5));
#else
	m_rgIDLookUp = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,
		(int)(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries));
#endif
	if (!m_rgIDLookUp) goto InitExit;

	pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList +
		m_pLineCountryList->dwCountryListOffset);

	for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
	{
		m_rgIDLookUp[idx].dwID = pLCETemp[idx].dwCountryID;
		m_rgIDLookUp[idx].pLCE = &pLCETemp[idx];
	}

	qsort(m_rgIDLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
		CompareIDLookUpElements);

	m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,
		(int)(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries));

	if (!m_rgNameLookUp) goto InitExit;

	for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
	{
		m_rgNameLookUp[idx].psCountryName = (LPSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
		m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
		m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
	}

	qsort(m_rgNameLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENT),
		CompareCntryNameLookUpElements);
	
	// Load States
	if (!SearchPath(NULL,STATE_FILENAME,NULL,TEMP_BUFFER_LENGTH,szTempBuffer,&pszTemp))
	{
		if(m_szICWDirectoryPath){
			// Try with c:\\ProgramFile\\ICW-INTERNET\\......
			if(! SearchPath(m_szICWDirectoryPath,
				STATE_FILENAME,NULL,TEMP_BUFFER_LENGTH,szTempBuffer,&pszTemp)) {
				AssertSz(0,"STATE.ICW not found");
				hr = ERROR_FILE_NOT_FOUND;
				goto InitExit;

			}else {
				; // OK Th e file is found
				iTestSK=0;

			}
		}
		else {
			AssertSz(0,"STATE.ICW not found");
			hr = ERROR_FILE_NOT_FOUND;
			goto InitExit;
		}
	}

	pcCSVFile = new CCSVFile;
	if (!pcCSVFile) goto InitExit;

	if (!pcCSVFile->Open(szTempBuffer))
	{
		AssertSz(0,"Can not open STATE.ICW");
		delete pcCSVFile;
		pcCSVFile = NULL;
		goto InitExit;
	}

	
	// first token in state file is the number of states
	if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
		goto InitExit;

	if (!FSz2Dw(szTempBuffer,&m_cStates))
	{
		AssertSz(0,"STATE.ICW count is invalid");
		goto InitExit;
	}

	m_rgState = (LPSTATE)GlobalAlloc(GPTR,(int)(sizeof(STATE)*m_cStates));
	if (!m_rgState)
		goto InitExit;

	for (ps = m_rgState, psLast = &m_rgState[m_cStates - 1]; ps <= psLast;++ps)
		{
		pcCSVFile->ReadToken(ps->szStateName,cbStateName);	
		}
	
	pcCSVFile->Close();

	// Locate ISP's INF file
	if (!SearchPath(NULL,(LPCTSTR) pszISPCode,INF_SUFFIX,MAX_PATH,
						m_szINFFile,&pszTemp))
	{
		wsprintf(szTempBuffer,"Can not find:%s%s (%d)",pszISPCode,INF_SUFFIX,GetLastError());
		if(m_szICWDirectoryPath) {
			if(!SearchPath(m_szICWDirectoryPath,(LPCTSTR) pszISPCode,INF_SUFFIX,MAX_PATH,
				m_szINFFile,&pszTemp)) {
					AssertSz(0,szTempBuffer);
					hr = ERROR_FILE_NOT_FOUND;
					goto InitExit;
				//
			}else {
				iTestSK++;

			}

		}else {
			AssertSz(0,szTempBuffer);
			hr = ERROR_FILE_NOT_FOUND;
			goto InitExit;
		}
	}

	//Load Phone Book
	if (!GetPrivateProfileString(INF_APP_NAME,INF_PHONE_BOOK,INF_DEFAULT,
		szTempBuffer,TEMP_BUFFER_LENGTH,m_szINFFile))
	{
		AssertSz(0,"PhoneBookFile not specified in INF file");
		hr = ERROR_FILE_NOT_FOUND;
		goto InitExit;
	}
	
#ifdef DEBUG
	if (!lstrcmp(szTempBuffer,INF_DEFAULT))
	{
		wsprintf(szTempBuffer, "%s value not found in ISP file", INF_PHONE_BOOK);
		AssertSz(0,szTempBuffer);
	}
#endif
	if (!SearchPath(NULL,szTempBuffer,NULL,MAX_PATH,m_szPhoneBook,&pszTemp))
	{
		if(m_szICWDirectoryPath){
			if (!SearchPath(m_szICWDirectoryPath,szTempBuffer,NULL,MAX_PATH,m_szPhoneBook,&pszTemp)){
				AssertSz(0,"ISP phone book not found");
				hr = ERROR_FILE_NOT_FOUND;
				goto InitExit;

			}else {
				;; // OK file Found
				iTestSK++;
			}

		}else {
			AssertSz(0,"ISP phone book not found");
			hr = ERROR_FILE_NOT_FOUND;
			goto InitExit;
		}

		
	}

	if (!pcCSVFile->Open(m_szPhoneBook))
	{
		AssertSz(0,"Can not open phone book");
		hr = GetLastError();
		goto InitExit;
	}
	
	dwSizeAllocated = 0;
	do {
		Assert (dwSizeAllocated >= m_cPhoneBookEntries);
		// check that sufficient memory is allocated
		if (m_rgPhoneBookEntry)
		{
			if (dwSizeAllocated == m_cPhoneBookEntries)
			{
				//
				// we need more memory
				//
//				AssertSz(0,"Out of memory originally allocated for phone book.\r\n");
//				goto InitExit;
                                pAETemp = m_rgPhoneBookEntry;
#ifdef WIN16			
				dwSizeAllocated += PHONE_ENTRY_ALLOC_SIZE;
				pTemp = GlobalReAlloc(m_rgPhoneBookEntry,
					(int)(dwSizeAllocated * sizeof(ACCESSENTRY)),GHND);
				if (NULL == pTemp)
					goto InitExit;
                                else
                                        m_rgPhoneBookEntry = (PACCESSENTRY)pTemp;
#else

				// UNLOCK
				Assert(m_hPhoneBookEntry);
				if (FALSE == GlobalUnlock(m_hPhoneBookEntry))
				{
					if (NO_ERROR != GetLastError())
						goto InitExit;
				}

				// REALLOC
				dwSizeAllocated += PHONE_ENTRY_ALLOC_SIZE;
				pTemp = GlobalReAlloc(m_hPhoneBookEntry,
					(int)(dwSizeAllocated * sizeof(ACCESSENTRY)),GHND);
				if (NULL == pTemp)
					goto InitExit;
                                else
                                        m_hPhoneBookEntry = pTemp;

				// LOCK
				m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
				if (NULL == m_rgPhoneBookEntry)
					goto InitExit;
				
#endif
				FixUpFromRealloc(pAETemp, m_rgPhoneBookEntry);
				Dprintf("Grow phone book to %d entries\n",dwSizeAllocated);
				pCurAccessEntry = (PACCESSENTRY)((LONG_PTR)pCurAccessEntry -
					((LONG_PTR)pAETemp - (LONG_PTR)(m_rgPhoneBookEntry)));

			}
		}
		else
		{
			//
			// Initialization for the first time through
			//
			
			// ALLOC
#ifdef WIN16
			m_rgPhoneBookEntry = (PACCESSENTRY)GlobalAlloc(GHND,sizeof(ACCESSENTRY) * PHONE_ENTRY_ALLOC_SIZE);
			if(NULL == m_rgPhoneBookEntry)
				goto InitExit;
#else
			m_hPhoneBookEntry = GlobalAlloc(GHND,sizeof(ACCESSENTRY) * PHONE_ENTRY_ALLOC_SIZE);
			if(NULL == m_hPhoneBookEntry)
				goto InitExit;

			// LOCK
			m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
			if(NULL == m_rgPhoneBookEntry)
				goto InitExit;
#endif
			dwSizeAllocated = PHONE_ENTRY_ALLOC_SIZE;
			pCurAccessEntry = m_rgPhoneBookEntry;
		}

		// Read a line from the phonebook
		hr = ReadOneLine(pCurAccessEntry,pcCSVFile);
		if (hr == ERROR_NO_MORE_ITEMS)
		{
			break;
		}
		else if (hr != ERROR_SUCCESS)
		{
			goto InitExit;
		}

		hr = ERROR_NOT_ENOUGH_MEMORY;

		// Check to see if this is the first phone number for a given country
		if (pCurAccessEntry->dwCountryID != dwLastCountry)
		{
			LPIDLOOKUPELEMENT lpIDLookupElement;
			// NOTE: Not sure about the first parameter here.
			lpIDLookupElement = (LPIDLOOKUPELEMENT)bsearch(&pCurAccessEntry->dwCountryID,
				m_rgIDLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
				CompareIDLookUpElements);
			if (!lpIDLookupElement)
			{
				// bad country ID, but we can't assert here
				Dprintf("Bad country ID in phone book %d\n",pCurAccessEntry->dwCountryID);
				continue;
			}
			else
			{
				// for a given country ID this is the first phone number
				lpIDLookupElement->pFirstAE = pCurAccessEntry;
				dwLastCountry = pCurAccessEntry->dwCountryID;
			}
		}

		// Check to see if this is the first phone number for a given state
		if (pCurAccessEntry->wStateID && (pCurAccessEntry->wStateID != dwLastState))
		{
			idx = pCurAccessEntry->wStateID - 1;
			m_rgState[idx].dwCountryID = pCurAccessEntry->dwCountryID;
			m_rgState[idx].paeFirst = pCurAccessEntry;
			dwLastState = pCurAccessEntry->wStateID;
		}

		pCurAccessEntry++;
		m_cPhoneBookEntries++;
	} while (TRUE);

	// Trim the phone book for unused memory
	Assert(m_rgPhoneBookEntry && m_cPhoneBookEntries);

	pAETemp = m_rgPhoneBookEntry;

#ifdef WIN16
	pTemp = GlobalReAlloc(m_rgPhoneBookEntry,(int)(m_cPhoneBookEntries * sizeof(ACCESSENTRY)),GHND);
	if (pTemp == NULL)
                goto InitExit;
        else
                m_rgPhoneBookEntry = (PACCESSENTRY)pTemp;
#else

	// UNLOCK
	Assert(m_hPhoneBookEntry);
	if (FALSE != GlobalUnlock(m_hPhoneBookEntry))
	{
		if (NO_ERROR != GetLastError())
			goto InitExit;
	}

	// REALLOC
	pTemp = GlobalReAlloc(m_hPhoneBookEntry,(int)(m_cPhoneBookEntries * sizeof(ACCESSENTRY)),GHND);
	if (NULL == pTemp)
		goto InitExit;
        else
                m_hPhoneBookEntry = pTemp;

	// LOCK
	m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
	if (NULL == m_rgPhoneBookEntry)
		goto InitExit;
#endif
	FixUpFromRealloc(pAETemp, m_rgPhoneBookEntry);

	hr = ERROR_SUCCESS;
InitExit:
	// If something failed release everything
	if (hr != ERROR_SUCCESS)
	{
#ifdef WIN16
		GlobalFree(m_rgPhoneBookEntry);
#else
		GlobalUnlock(m_hPhoneBookEntry);
		GlobalFree(m_hPhoneBookEntry);
#endif
		GlobalFree(m_pLineCountryList);
		GlobalFree(m_rgIDLookUp);
		GlobalFree(m_rgNameLookUp);
		GlobalFree(m_rgState);

		m_cPhoneBookEntries = 0 ;
		m_cStates = 0;

		m_pLineCountryList = NULL;
		m_rgPhoneBookEntry = NULL;
		m_hPhoneBookEntry = NULL;
		m_rgIDLookUp=NULL;
		m_rgNameLookUp=NULL;
		m_rgState=NULL;
	}

	if (pcCSVFile)
	{
		pcCSVFile->Close();
		delete pcCSVFile;
	}
	return hr;
}

// ############################################################################
HRESULT CPhoneBook::Merge(LPCSTR pszChangeFile)
{
	CCSVFile far *pcCSVFile;
	ACCESSENTRY aeChange;
	LPIDXLOOKUPELEMENT rgIdxLookUp;
	LPIDXLOOKUPELEMENT pCurIdxLookUp;
	DWORD dwAllocated;
	DWORD dwUsed;
	DWORD dwOriginalSize;
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	DWORD	dwIdx;
#if !defined(WIN16)
	HANDLE hTemp;
	HANDLE hIdxLookUp;
#else
	// Normandy 11746
	LPVOID rgTemp;  // 16-bit only
#endif
	DWORD cch, cchWritten;
	HANDLE hFile;

	// Pad the phonebook for new entries.
	dwAllocated = m_cPhoneBookEntries + CHANGE_BUFFER_SIZE;
#ifdef WIN16
	Assert(m_rgPhoneBookEntry);
	rgTemp = GlobalReAlloc(m_rgPhoneBookEntry, (int)(sizeof(ACCESSENTRY) * dwAllocated),GHND);
	Assert(rgTemp);
	if (!rgTemp) goto MergeExit;
	m_rgPhoneBookEntry = (PACCESSENTRY)rgTemp;
#else
	Assert(m_hPhoneBookEntry);
	GlobalUnlock(m_hPhoneBookEntry);
	hTemp = (HANDLE)GlobalReAlloc(m_hPhoneBookEntry, sizeof(ACCESSENTRY) * dwAllocated,GHND);
	Assert(hTemp);
	if (!hTemp)
		goto MergeExit;
	m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
	if (!m_rgPhoneBookEntry)
		goto MergeExit;
#endif

	// Create index to loaded phone book, sorted by index
#ifdef WIN16
	rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalAlloc(GHND,(int)(sizeof(IDXLOOKUPELEMENT) * dwAllocated));
#else
	hIdxLookUp = (HANDLE)GlobalAlloc(GHND,sizeof(IDXLOOKUPELEMENT) * dwAllocated);
	rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalLock(hIdxLookUp);
#endif
	Assert(rgIdxLookUp);
	if (!rgIdxLookUp)
		goto MergeExit;

	for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
	{
		rgIdxLookUp[dwIdx].dwIndex = rgIdxLookUp[dwIdx].pAE->dwIndex;
		rgIdxLookUp[dwIdx].pAE = &m_rgPhoneBookEntry[dwIdx];
	}
	dwUsed = m_cPhoneBookEntries;
	dwOriginalSize = m_cPhoneBookEntries;

	qsort(rgIdxLookUp,(int)dwOriginalSize,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);

	// Load changes to phone book
	pcCSVFile = new CCSVFile;
	Assert(pcCSVFile);
	if (!pcCSVFile)
		goto MergeExit;
	if (!pcCSVFile->Open(pszChangeFile))
		goto MergeExit;
	
	do {

		// Read a change record
		ZeroMemory(&aeChange,sizeof(ACCESSENTRY));
		hr = ReadOneLine(&aeChange, pcCSVFile);

		if (hr == ERROR_NO_MORE_ITEMS)
		{
			break; // no more enteries
		}
		else if (hr != ERROR_SUCCESS)
		{
			goto MergeExit;
		}

		hr = ERROR_NOT_ENOUGH_MEMORY;

		// Determine if this is a delete or add record
		if (aeChange.szAccessNumber[0] == '0' && aeChange.szAccessNumber[1] == '\0')
		{
			// This is a delete record, find matching record
			// NOTE: we only search the numbers that existed before the change file,
			// because they are the only ones that are sorted.
			pCurIdxLookUp = (LPIDXLOOKUPELEMENT)bsearch(&aeChange,rgIdxLookUp,(int)dwOriginalSize,
				sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);
			AssertSz(pCurIdxLookUp,"Attempting to delete a record that does not exist.  The change file and phone book versions do not match.");
			if (pCurIdxLookUp)
				pCurIdxLookUp->pAE = NULL;  //Create a dead entry in the look up table
			m_cPhoneBookEntries--;
		}
		else
		{
			// This is an add entry
			m_cPhoneBookEntries++;
			dwUsed++;
			// Make sure we have enough room
			if (m_cPhoneBookEntries > dwAllocated)
			{
				// Grow phone book
				dwAllocated += CHANGE_BUFFER_SIZE;
#ifdef WIN16
				Assert(m_rgPhoneBookEntry);
				rgTemp = GlobalReAlloc(m_rgPhoneBookEntry,(int)(sizeof(ACCESSENTRY)*dwAllocated),GHND);
				Assert(rgTemp);
				if (!rgTemp)
					goto MergeExit;
				m_rgPhoneBookEntry = (PACCESSENTRY)rgTemp;

				// Grow look up index
				Assert(rgIdxLookUp);
				rgTemp = GlobalReAlloc(rgIdxLookUp,(int)(sizeof(IDXLOOKUPELEMENT)*dwAllocated),GHND);
				Assert(rgTemp);
				if (!rgTemp)
					goto MergeExit;
				rgIdxLookUp = (LPIDXLOOKUPELEMENT)rgTemp;
#else
				Assert(m_hPhoneBookEntry);
				GlobalUnlock(m_hPhoneBookEntry);
				hTemp = (HANDLE)GlobalReAlloc(m_hPhoneBookEntry,sizeof(ACCESSENTRY)*dwAllocated,GHND);
				Assert(hTemp);
				if (!hTemp)
					goto MergeExit;
				m_hPhoneBookEntry = hTemp;
				m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
				Assert(m_rgPhoneBookEntry);
				if (!m_rgPhoneBookEntry)
					goto MergeExit;

				// Grow look up index
				Assert(hIdxLookUp);
				GlobalUnlock(hIdxLookUp);
				hTemp = (HANDLE)GlobalReAlloc(hIdxLookUp,sizeof(IDXLOOKUPELEMENT)*dwAllocated,GHND);
				Assert(hTemp);
				if (!hTemp)
					goto MergeExit;
				hIdxLookUp = hTemp;
				rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalLock(hIdxLookUp);
				Assert(rgIdxLookUp);
				if (!rgIdxLookUp)
					goto MergeExit;
#endif
			}

			//Add entry to the end of the phonebook and to end of look up index
			CopyMemory(&m_rgPhoneBookEntry[m_cPhoneBookEntries],&aeChange,sizeof(ACCESSENTRY));
			rgIdxLookUp[m_cPhoneBookEntries].dwIndex = m_rgPhoneBookEntry[m_cPhoneBookEntries].dwIndex;
			rgIdxLookUp[m_cPhoneBookEntries].pAE = &m_rgPhoneBookEntry[m_cPhoneBookEntries];
			// NOTE: because the entry is added to the end of the list, we can't add
			// and delete entries in the same change file.
		}
	} while (TRUE);

	// resort the IDXLookUp index to reflect the correct order of enteries
	// for the phonebook file, including all of the entries to be deleted.
	qsort(rgIdxLookUp,(int)dwUsed,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElementsFileOrder);

	// Build a new phonebook file
#ifdef WIN16
	GetTempFileName(0, TEMP_PHONE_BOOK_PREFIX, 0, szTempFileName);
#else
	if (!GetTempPath(TEMP_BUFFER_LENGTH,szTempBuffer))
		goto MergeExit;
	if (!GetTempFileName(szTempBuffer,TEMP_PHONE_BOOK_PREFIX,0,szTempFileName))
		goto MergeExit;
#endif
	hFile = CreateFile(szTempFileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
		FILE_FLAG_WRITE_THROUGH,0);
	if (hFile == INVALID_HANDLE_VALUE)
		goto MergeExit;

	for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
	{
		cch = wsprintf(szTempBuffer, "%lu,%lu,%lu,%s,%s,%s,%lu,%lu,%lu,%lu,%s\r\n",
			rgIdxLookUp[dwIdx].pAE->dwIndex,
			rgIdxLookUp[dwIdx].pAE->dwCountryID,
			DWORD(rgIdxLookUp[dwIdx].pAE->wStateID),
			rgIdxLookUp[dwIdx].pAE->szCity,
			rgIdxLookUp[dwIdx].pAE->szAreaCode,
			rgIdxLookUp[dwIdx].pAE->szAccessNumber,
			rgIdxLookUp[dwIdx].pAE->dwConnectSpeedMin,
			rgIdxLookUp[dwIdx].pAE->dwConnectSpeedMax,
			DWORD(rgIdxLookUp[dwIdx].pAE->bFlipFactor),
			DWORD(rgIdxLookUp[dwIdx].pAE->fType),
			rgIdxLookUp[dwIdx].pAE->szDataCenter);

		if (!WriteFile(hFile,szTempBuffer,cch,&cchWritten,NULL))
		{
			// something went wrong, get rid of the temporary file
			CloseHandle(hFile);
			DeleteFile(szTempFileName);
			hr = GetLastError();
			goto MergeExit;
		}

		Assert(cch == cchWritten);
	}
	CloseHandle(hFile);
	hFile = NULL;

	// Move new phone book over old
	if (!MoveFileEx(szTempFileName,m_szPhoneBook,MOVEFILE_REPLACE_EXISTING))
	{
		hr = GetLastError();
		goto MergeExit;
	}

	// discard the phonebook in memory
#ifndef WIN16
	Assert(m_hPhoneBookEntry);
	GlobalUnlock(m_hPhoneBookEntry);
#endif
	m_rgPhoneBookEntry = NULL;
	m_cPhoneBookEntries = 0;
	GlobalFree(m_pLineCountryList);
	GlobalFree(m_rgIDLookUp);
	GlobalFree(m_rgNameLookUp);
	GlobalFree(m_rgState);
	m_cStates = 0;

	lstrcpy(szTempBuffer,m_szINFCode);
	m_szINFFile[0] = '\0';
	m_szPhoneBook[0] = '\0';
	m_szINFCode[0] = '\0';

	//  Reload it (and rebuild look up arrays)
	hr = Init(szTempBuffer);

MergeExit:
	if (hr != ERROR_SUCCESS)
	{
		GlobalFree(rgIdxLookUp);
		if (pcCSVFile) delete pcCSVFile;
		CloseHandle(hFile);
	}
	return hr;
}

// ############################################################################
HRESULT CPhoneBook::ReadOneLine(PACCESSENTRY lpAccessEntry, CCSVFile far *pcCSVFile)
{
	HRESULT hr = ERROR_SUCCESS;

#if !defined(WIN16)
ReadOneLineStart:
#endif //WIN16
	if (!ReadPhoneBookDW(&lpAccessEntry->dwIndex,pcCSVFile))
	{
		hr = ERROR_NO_MORE_ITEMS; // no more enteries
		goto ReadExit;
	}
	ReadVerifyPhoneBookDW(lpAccessEntry->dwCountryID);
	ReadVerifyPhoneBookW(lpAccessEntry->wStateID);
	ReadVerifyPhoneBookSZ(lpAccessEntry->szCity,cbCity);
	ReadVerifyPhoneBookSZ(lpAccessEntry->szAreaCode,cbAreaCode);
	// NOTE: 0 is a valid area code and ,, is a valid entry for an area code
	if (!FSz2Dw(lpAccessEntry->szAreaCode,&lpAccessEntry->dwAreaCode))
		lpAccessEntry->dwAreaCode = NO_AREA_CODE;
	ReadVerifyPhoneBookSZ(lpAccessEntry->szAccessNumber,cbAccessNumber);
	ReadVerifyPhoneBookDW(lpAccessEntry->dwConnectSpeedMin);
	ReadVerifyPhoneBookDW(lpAccessEntry->dwConnectSpeedMax);
	ReadVerifyPhoneBookB(lpAccessEntry->bFlipFactor);
	ReadVerifyPhoneBookDW(lpAccessEntry->fType);
	ReadVerifyPhoneBookSZ(lpAccessEntry->szDataCenter,cbDataCenter);
#if !defined(WIN16)
	//
	// If scripting is not available and the phonebook entry has a dun file other than
	// icwip.dun, then ignore the entry and read the one after that.
	//
	if (!m_bScriptingAvailable)
	{
		if (0 != lstrcmpi(lpAccessEntry->szDataCenter,"icwip.dun"))
		{
			ZeroMemory(lpAccessEntry,sizeof(ACCESSENTRY));
			goto ReadOneLineStart;
		}
	}
#endif //WIN16

ReadExit:
	return hr;
ReadError:
	hr = ERROR_INVALID_DATA;
	goto ReadExit;
}

// ############################################################################
HRESULT CPhoneBook::Suggest(PSUGGESTINFO pSuggest)
{
	WORD		wNumFound = 0;
	HRESULT		hr = ERROR_NOT_ENOUGH_MEMORY;

	// Validate parameters
	Assert(pSuggest);
	Assert(pSuggest->wNumber);

	if (wNumFound == pSuggest->wNumber)
		goto SuggestExit;

	LPIDLOOKUPELEMENT pCurLookUp;
	PACCESSENTRY lpAccessEntry;
	
	//REVIEW: double check this
	pCurLookUp = (LPIDLOOKUPELEMENT)bsearch(&pSuggest->dwCountryID,m_rgIDLookUp,
		(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
		CompareIDLookUpElements);

	// Check for invalid country
	if (!pCurLookUp)
		goto SuggestExit;

	// Check if there are any phone numbers for this country
	if (!pCurLookUp->pFirstAE) goto SuggestExit;

	lpAccessEntry = pCurLookUp->pFirstAE;
	do {
		// check for the right area code
		if (lpAccessEntry->dwAreaCode == pSuggest->wAreaCode)
		{
			// check for the right type of number
			if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType)
			{
				pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
				wNumFound++;
			}
		}
		lpAccessEntry++;
	} while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) &&
		(wNumFound < pSuggest->wNumber) &&
		(lpAccessEntry->dwCountryID == pSuggest->dwCountryID));

	// if we couldn't find enough numnbers, try something else
	// 10/15/96  jmazner  ported fixes below from core\client\phbk
	// Do this only if area code is not 0 - Bug #9349 (VetriV)
	// 	if ((pSuggest->wAreaCode != 0) && (wNumFound < pSuggest->wNumber))
	// No, there are some places (Finland?  ChrisK knows) where 0 is a legit area code -- jmazner

	if (wNumFound < pSuggest->wNumber)
	{
		lpAccessEntry = pCurLookUp->pFirstAE;
	
		// Note: we are now only looking for Nationwide phone numbers (state = 0)

		// 8/13/96 jmazner MOS Normandy #4597
		// We want nationwide toll-free numbers to display last, so for this pass,
		// only consider numbers that are _not_ toll free  (fType bit #1 = 0)
		
		// Tweak pSuggest->bMask to let through the toll/charge bit
		pSuggest->bMask |= MASK_TOLLFREE_BIT;

		// Tweak pSuggest->ftype to be charge
		pSuggest->fType &= TYPE_SET_TOLL;

		do {

			// 8/13/96 jmazner MOS Normandy #4598
			// If this entry's area code matches pSuggest->wAreaCode, then we already
			// have included it in the previous pass, so don't duplicate it again here.
			if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType &&
				 lpAccessEntry->wStateID == 0 &&
				 lpAccessEntry->dwAreaCode != pSuggest->wAreaCode)
			{
				pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
				wNumFound++;
			}
			lpAccessEntry++;
		} while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) &&
			(wNumFound < pSuggest->wNumber) &&
			(lpAccessEntry->dwCountryID == pSuggest->dwCountryID) &&
			(lpAccessEntry->wStateID == 0) );
	}


	// 8/13/96 jmazner MOS Normandy #4597
	// if we STILL couldn't find enough numnbers, widen the search to include tollfree #s

	if (wNumFound < pSuggest->wNumber)
	{
		lpAccessEntry = pCurLookUp->pFirstAE;
		
		// Tweak pSuggest->bMask to let through the toll/charge bit
		// REDUNDANT? If we made it to this point, we _should_ have done this above...
		// Better safe than sorry!
		Assert(pSuggest->bMask & MASK_TOLLFREE_BIT);
		pSuggest->bMask |= MASK_TOLLFREE_BIT;

		// Tweak pSuggest->ftype to be tollfree
		pSuggest->fType |= TYPE_SET_TOLLFREE;

		do {

			// 8/13/96 jmazner MOS Normandy #4598
			// If this entry's area code matches pSuggest->wAreaCode, then we already
			// have included it in the first pass, so don't include it here.
			// Any entry that made it in in the 2nd pass will definitely not make it in here
			// (because of tollfree bit), so no need to worry about dups from there.
			if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType &&
		      lpAccessEntry->wStateID == 0 &&
			  lpAccessEntry->dwAreaCode != pSuggest->wAreaCode)
			{
				pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
				wNumFound++;
			}
			lpAccessEntry++;
		} while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) &&
			(wNumFound < pSuggest->wNumber) &&
			(lpAccessEntry->dwCountryID == pSuggest->dwCountryID) &&
			(lpAccessEntry->wStateID == 0) );
	}
	hr = ERROR_SUCCESS;
SuggestExit:
	pSuggest->wNumber = wNumFound;
	return hr;
}

// ############################################################################
HRESULT CPhoneBook::GetCanonical (PACCESSENTRY pAE, LPSTR psOut)
{
	HRESULT hr = ERROR_SUCCESS;
	LPIDLOOKUPELEMENT pIDLookUp;

	pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&pAE->dwCountryID,m_rgIDLookUp,
		(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);

	if (!pIDLookUp)
	{
		hr = ERROR_INVALID_PARAMETER;
	} else {
		SzCanonicalFromAE (psOut, pAE, pIDLookUp->pLCE);
	}

	return hr;
}

// ############################################################################
DllExportH PhoneBookLoad(LPCSTR pszISPCode, DWORD_PTR far *pdwPhoneID)
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	CPhoneBook far *pcPhoneBook;

	if (!g_hInstDll)
		g_hInstDll = GetModuleHandle(NULL);

	// validate parameters
	Assert(pszISPCode && *pszISPCode && pdwPhoneID);
	*pdwPhoneID = NULL;

	// allocate phone book
	pcPhoneBook = new CPhoneBook;

	// initialize phone book
	if (pcPhoneBook)
		hr = pcPhoneBook->Init(pszISPCode);

	// in case of failure
	if (hr && pcPhoneBook)
	{
		delete pcPhoneBook;
	} else {
		*pdwPhoneID = (DWORD_PTR)pcPhoneBook;
	}

#if defined(WIN16)
	if (!hr)
		BMP_RegisterClass(g_hInstDll);
#endif	

	return hr;
}

// ############################################################################
DllExportH PhoneBookUnload(DWORD_PTR dwPhoneID)
{
	Assert(dwPhoneID);

	if (dwPhoneID)
	{
#if defined(WIN16)
		BMP_DestroyClass(g_hInstDll);
#endif
		// Release contents
		delete (CPhoneBook far*)dwPhoneID;
	}

	return ERROR_SUCCESS;
}

// ############################################################################
DllExportH PhoneBookMergeChanges(DWORD_PTR dwPhoneID, LPCSTR pszChangeFile)
{
	return ((CPhoneBook far*)dwPhoneID)->Merge(pszChangeFile);
}

// ############################################################################
DllExportH PhoneBookSuggestNumbers(DWORD_PTR dwPhoneID, PSUGGESTINFO lpSuggestInfo)
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;

	// get suggested numbers
	lpSuggestInfo->rgpAccessEntry = (PACCESSENTRY *)GlobalAlloc(GPTR,sizeof(PACCESSENTRY) * lpSuggestInfo->wNumber);
	if (lpSuggestInfo->rgpAccessEntry)
	{
		hr = ((CPhoneBook far *)dwPhoneID)->Suggest(lpSuggestInfo);
	}

	return hr;
}

// ############################################################################
DllExportH PhoneBookGetCanonical (DWORD_PTR dwPhoneID, PACCESSENTRY pAE, LPSTR psOut)
{
	return ((CPhoneBook far*)dwPhoneID)->GetCanonical(pAE,psOut);
}

// ############################################################################
DllExportH PhoneBookDisplaySignUpNumbers (DWORD_PTR dwPhoneID,
														LPSTR far *ppszPhoneNumbers,
														LPSTR far *ppszDunFiles,
														WORD far *pwPhoneNumbers,
														DWORD far *pdwCountry,
														WORD far *pwRegion,
														BYTE fType,
														BYTE bMask,
														HWND hwndParent,
														DWORD dwFlags)
{
	INT_PTR hr;
	AssertSz(ppszPhoneNumbers && pwPhoneNumbers && pdwCountry &&pwRegion,"invalid parameters");


	//CAccessNumDlg *pcDlg;
	CSelectNumDlg far *pcDlg;
	pcDlg = new CSelectNumDlg;
	if (!pcDlg)
	{
		hr = GetLastError();
		goto DisplayExit;
	}

	// Initialize information for dialog
	//

	pcDlg->m_dwPhoneBook = dwPhoneID;
	pcDlg->m_dwCountryID = *pdwCountry;
	pcDlg->m_wRegion = *pwRegion;
	pcDlg->m_fType = fType;
	pcDlg->m_bMask = bMask;
	pcDlg->m_dwFlags = dwFlags;

	// invoke the dialog
	//
	
	// BUG: NOT THREAD SAFE!!
	g_hWndMain = hwndParent;
	hr = DialogBoxParam(g_hInstDll,MAKEINTRESOURCE(IDD_SELECTNUMBER),
							g_hWndMain,PhbkGenericDlgProc,(LPARAM)pcDlg);
	g_hWndMain = NULL;

	if (hr == IDC_CMDNEXT)
	{
		*pwRegion = pcDlg->m_wRegion;
		*pdwCountry = pcDlg->m_dwCountryID;

		Assert (ppszPhoneNumbers[0] && ppszDunFiles[0]);
		lstrcpy(ppszPhoneNumbers[0],&pcDlg->m_szPhoneNumber[0]);
		lstrcpy(ppszDunFiles[0],&pcDlg->m_szDunFile[0]);

		hr = ERROR_SUCCESS;
	}
	else if (hr == IDC_CMDBACK)
		hr = ERROR_USERBACK;
	else
		hr = ERROR_USERCANCEL;

	//	hr == -1;
DisplayExit:
	if (pcDlg) delete pcDlg;

	return (HRESULT) hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\phbkex.h ===
#ifndef _PHBKEX
#define _PHBKEX

#define TYPE_SIGNUP_ANY			0x82
#define TYPE_SIGNUP_TOLLFREE	0x83
#define TYPE_SIGNUP_TOLL		0x82
#define TYPE_REGULAR_USAGE		0x42

#define MASK_SIGNUP_ANY			0xB2
#define MASK_SIGNUP_TOLLFREE	0xB3
#define MASK_SIGNUP_TOLL		0xB3
#define MASK_REGULAR_USAGE		0x73

#define cbAreaCode	6			// maximum number of characters in an area code, not including \0
#define cbCity 19				// maximum number of chars in city name, not including \0
#define cbAccessNumber 15		// maximum number of chars in phone number, not including \0
#define cbStateName 31 			// maximum number of chars in state name, not including \0
								// check this against state.pbk delivered by mktg
#define cbBaudRate 6			// maximum number of chars in a baud rate, not including \0
#define cbDataCenter 12			// max length of data center string

typedef struct
{
	DWORD	dwIndex;								// index number
	BYTE	bFlipFactor;							// for auto-pick
	BYTE	fType;									// phone number type
	WORD	wStateID;								// state ID
	DWORD	dwCountryID;							// TAPI country ID
	DWORD	dwAreaCode;								// area code or NO_AREA_CODE if none
	DWORD	dwConnectSpeedMin;						// minimum baud rate
	DWORD	dwConnectSpeedMax;						// maximum baud rate
	char	szCity[cbCity + sizeof('\0')];			// city name
	char	szAccessNumber[cbAccessNumber + sizeof('\0')];	// access number
	char	szDataCenter[cbDataCenter + sizeof('\0')];				// data center access string
	char	szAreaCode[cbAreaCode + sizeof('\0')];					//Keep the actual area code string around.
} ACCESSENTRY, FAR  *PACCESSENTRY; 	// ae

typedef struct tagSUGGESTIONINFO
{
	DWORD	dwCountryID;
	DWORD	wAreaCode;
	DWORD	wExchange;
	WORD	wNumber;
	BYTE	fType;
	BYTE	bMask;
	PACCESSENTRY *rgpAccessEntry;
} SUGGESTINFO,FAR *PSUGGESTINFO;

#endif _PHBKEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\phbkrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by phbk.rc
//
#define IDS_950NUMBER                   1
#define IDS_WANTTOEXIT                  2
#define IDS_TITLE                       3
#define IDS_NOTENOUGHMEMORY             4
#define IDS_NATIONWIDE                  5
#define IDS_INVALIDPHONE                6
#define IDS_OK                          7
#define IDD_ACCESSNUMBERS               101
#define IDD_SELECTNUMBER                102
#define IDB_WORLD                       106
#define IDB_PHONE                       107
#define IDC_CMDHELP                     1000
#define IDC_TXTPRIMARY                  1001
#define IDC_TXTSECONDARY                1002
#define IDC_CMDCHANGEPRIMARY            1003
#define IDC_CMDCHANGESECONDARY          1004
#define IDC_CMDEXIT                     1005
#define IDC_CMDOK                       1006
#define IDC_CMBCOUNTRY                  1007
#define IDC_CMBREGION                   1008
#define IDC_LSTNUMBER                   1009
#define IDC_CMDCANCEL                   IDCANCEL
#define IDC_CMBNUMBER                   1011
#define IDC_CMDNEXT                     1012
#define IDC_CMDBACK                     1013
#define IDC_LBLTITLE                    1014
#define IDC_LBLAUTODIAL                 1015
#define IDC_LBLSIGNUP                   1016
#define IDC_LBLDIALERR                  1017
#define IDC_LBLCOUNTRY                  1018
#define IDC_LBLSTATEMSG						 1019
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\phbk.h ===
#ifndef _PHBK
#define _PHBK

#include "ccsv.h"
#include "debug.h"

#define DllExportH extern "C" HRESULT WINAPI __stdcall
//#define DllExportH extern "C" __declspec(dllexport) HRESULT WINAPI

#if !defined(WIN16)
#define MsgBox(m,s) MessageBox(g_hWndMain,GetSz(m),GetSz(IDS_TITLE),s)
#endif

#define cbAreaCode	6			// maximum number of characters in an area code, not including \0
#define cbCity 19				// maximum number of chars in city name, not including \0
#define cbAccessNumber 15		// maximum number of chars in phone number, not including \0
#define cbStateName 31 			// maximum number of chars in state name, not including \0
								// check this against state.pbk delivered by mktg
#define cbBaudRate 6			// maximum number of chars in a baud rate, not including \0
#if defined(WIN16)
#define cbDataCenter 12			// max length of data center string
#else
#define cbDataCenter (MAX_PATH+1)			// max length of data center string
#endif
#define NO_AREA_CODE 0xFFFFFFFF

#define PHONE_ENTRY_ALLOC_SIZE	500
#define INF_SUFFIX ".ISP"
#define INF_APP_NAME "ISP INFO"
#define INF_PHONE_BOOK "PhoneBookFile"
#define INF_DEFAULT	"SPAM SPAM SPAM SPAM SPAM SPAM EGGS AND SPAM"
#define STATE_FILENAME "STATE.ICW"
#define FILE_NAME_800950 "800950.DAT"
#define TEMP_BUFFER_LENGTH 1024
#define MAX_INFCODE 9

#define TYPE_SIGNUP_TOLLFREE	0x83
#define TYPE_SIGNUP_TOLL		0x82
#define TYPE_REGULAR_USAGE		0x42

#define MASK_SIGNUP_TOLLFREE	0xB3
#define MASK_SIGNUP_TOLL		0xB3
#define MASK_REGULAR_USAGE		0x73

// 8/13/96 jmazner for Normandy bug #4597
// ported from core\client\phbk 10/15/96
#define MASK_TOLLFREE_BIT			0x01	// Bit #1: 1=tollfree, 0=charge
#define TYPE_SET_TOLLFREE			0x01	// usage: type |= TYPE_SET_TOLLFREE
// want TYPE_SET_TOLL to be a DWORD to match pSuggestInfo->fType
#define TYPE_SET_TOLL				~((DWORD)TYPE_SET_TOLLFREE)    // usage: type &= TYPE_SET_TOLL


#define clineMaxATT	16
#define NXXMin		200
#define NXXMax		999
#define cbgrbitNXX	((NXXMax + 1 - NXXMin) / 8)

// Phone number select dialog flags
//

#define FREETEXT_SELECTION_METHOD  0x00000001
#define PHONELIST_SELECTION_METHOD 0x00000002
#define AUTODIAL_IN_PROGRESS       0x00000004
#define DIALERR_IN_PROGRESS        0x00000008

typedef struct
{
	DWORD	dwIndex;								// index number
	BYTE	bFlipFactor;							// for auto-pick
	DWORD	fType;									// phone number type
	WORD	wStateID;								// state ID
	DWORD	dwCountryID;							// TAPI country ID
	DWORD	dwAreaCode;								// area code or NO_AREA_CODE if none
	DWORD	dwConnectSpeedMin;						// minimum baud rate
	DWORD	dwConnectSpeedMax;						// maximum baud rate
	char	szCity[cbCity + sizeof('\0')];			// city name
	char	szAccessNumber[cbAccessNumber + sizeof('\0')];	// access number
	char	szDataCenter[cbDataCenter + sizeof('\0')];				// data center access string
	char	szAreaCode[cbAreaCode + sizeof('\0')];					//Keep the actual area code string around.
} ACCESSENTRY, far *PACCESSENTRY; 	// ae

typedef struct {
	DWORD dwCountryID;								// country ID that this state occurred in
	PACCESSENTRY paeFirst;							// pointer to first access entry for this state
	char szStateName[cbStateName + sizeof('\0')];	// state name
} STATE, far *LPSTATE;

typedef struct tagIDLOOKUPELEMENT {
	DWORD dwID;
	LPLINECOUNTRYENTRY pLCE;
	PACCESSENTRY pFirstAE;
} IDLOOKUPELEMENT, far *LPIDLOOKUPELEMENT;

typedef struct tagCNTRYNAMELOOKUPELEMENT {
	LPSTR psCountryName;
	DWORD dwNameSize;
	LPLINECOUNTRYENTRY pLCE;
} CNTRYNAMELOOKUPELEMENT, far *LPCNTRYNAMELOOKUPELEMENT;

typedef struct tagIDXLOOKUPELEMENT {
	DWORD dwIndex;
	PACCESSENTRY pAE;
} IDXLOOKUPELEMENT,far *LPIDXLOOKUPELEMENT;

typedef struct tagSUGGESTIONINFO
{
	DWORD	dwCountryID;
	DWORD	wAreaCode;
	DWORD	wExchange;
	WORD	wNumber;
	DWORD	fType;  // 9/6/96 jmazner  Normandy
	DWORD	bMask;  // make this struct look like the one in %msnroot%\core\client\phbk\phbk.h
	PACCESSENTRY *rgpAccessEntry;
} SUGGESTINFO, far *PSUGGESTINFO;

typedef struct tagNPABlock
{
	WORD wAreaCode;
	BYTE grbitNXX [cbgrbitNXX];
} NPABLOCK, far *LPNPABLOCK;



class CPhoneBook
{
	//friend HRESULT DllExport PhoneBookLoad(LPCSTR pszISPCode, DWORD_PTR *pdwPhoneID);
	//friend class CDialog;
	
	// 1/9/96  jmazner Normandy #13185
	//friend class CAccessNumDlg;
	
	friend class CSelectNumDlg;

public:
	void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
	void operator delete( void far * p ) {GlobalFree(p); };

	CPhoneBook();
	~CPhoneBook();

	HRESULT Init(LPCSTR pszISPCode);
	HRESULT Merge(LPCSTR pszChangeFilename);
	HRESULT Suggest(PSUGGESTINFO pSuggest);
	HRESULT GetCanonical(PACCESSENTRY pAE, LPSTR psOut);

private:
	PACCESSENTRY			m_rgPhoneBookEntry;
	HANDLE					m_hPhoneBookEntry;	
	DWORD					m_cPhoneBookEntries;
	LPLINECOUNTRYENTRY		m_rgLineCountryEntry;
	LPLINECOUNTRYLIST 		m_pLineCountryList;
	LPIDLOOKUPELEMENT		m_rgIDLookUp;
	LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;
	LPSTATE					m_rgState;
	DWORD					m_cStates;
	BOOL              m_bScriptingAvailable;
	char					m_szINFFile[MAX_PATH];
	char					m_szINFCode[MAX_INFCODE];
	char					m_szPhoneBook[MAX_PATH];
	char                    m_szICWDirectoryPath[MAX_PATH];
	// Added on 05/13/97  by Suresh
	// To store the ICW directory Path as it is required by RegWiz
	//
	BOOL ReadPhoneBookDW(DWORD far *pdw, CCSVFile far *pcCSVFile);
	BOOL ReadPhoneBookW(WORD far *pw, CCSVFile far *pcCSVFile);
	BOOL ReadPhoneBookSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
	BOOL ReadPhoneBookB(BYTE far *pb, CCSVFile far *pcCSVFile);
	HRESULT ReadOneLine(PACCESSENTRY pAccessEntry, CCSVFile far *pcCSVFile);
	BOOL FixUpFromRealloc(PACCESSENTRY paeOld, PACCESSENTRY paeNew);

};

#ifdef __cplusplus
extern "C" {
#endif
extern HINSTANCE g_hInstDll;	// instance for this DLL
extern HWND g_hWndMain;
#ifdef __cplusplus
}
#endif
#endif // _PHBK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\rnaapi.cpp ===
//-----------------------------------------------------------------------------
// RNAAPI class
// 
// This class provides a series of cover function for the RNAPH/RASAPI32 dlls
//
// Created 1-29-96	ChrisK

// ############################################################################
// INCLUDES
#include "pch.hpp"
//#include "ras.h"
#include <ras.h>
#pragma pack (4)
//#if !defined(WIN16)
//#include <rnaph.h>
//#endif
#pragma pack ()
#include "rnaapi.h"
#include "debug.h"

// ############################################################################
// RNAAPI class 
CRNAAPI::CRNAAPI()
{
	m_hInst = LoadLibrary("RASAPI32.DLL");
	m_hInst2 = LoadLibrary("RNAPH.DLL");

	m_fnRasEnumDeviecs = NULL;
	m_fnRasValidateEntryName = NULL;
	m_fnRasSetEntryProperties = NULL;
	m_fnRasGetEntryProperties = NULL;
}

// ############################################################################
CRNAAPI::~CRNAAPI()
{
	// Clean up
	if (m_hInst) FreeLibrary(m_hInst);
	if (m_hInst2) FreeLibrary(m_hInst2);
}

// ############################################################################
DWORD CRNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
							 LPDWORD lpcDevices)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasEnumDevices",(FARPROC*)&m_fnRasEnumDeviecs);

	if (m_fnRasEnumDeviecs)
		dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

	return dwRet;
}

// ############################################################################
BOOL CRNAAPI::LoadApi(LPSTR pszFName, FARPROC* pfnProc)
{
	if (*pfnProc == NULL)
	{
		// Look for the entry point in the first DLL
		if (m_hInst)
			*pfnProc = GetProcAddress(m_hInst,pszFName);
		
		// if that fails, look for the entry point in the second DLL
		if (m_hInst2 && !(*pfnProc))
			*pfnProc = GetProcAddress(m_hInst2,pszFName);
	}

	return (pfnProc != NULL);
}

// ############################################################################
DWORD CRNAAPI::RasValidateEntryName(LPSTR lpszPhonebook,LPSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasValidateEntryName",(FARPROC*)&m_fnRasValidateEntryName);

	if (m_fnRasValidateEntryName)
		dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

	return dwRet;
}

// ############################################################################
DWORD CRNAAPI::RasSetEntryProperties(LPSTR lpszPhonebook, LPSTR lpszEntry,
									LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
									LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasSetEntryProperties",(FARPROC*)&m_fnRasSetEntryProperties);

	if (m_fnRasSetEntryProperties)
		dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, dwEntryInfoSize,
									lpbDeviceInfo, dwDeviceInfoSize);

	return dwRet;
}

// ############################################################################
DWORD CRNAAPI::RasGetEntryProperties(LPSTR lpszPhonebook, LPSTR lpszEntry,
									LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
									LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasGetEntryProperties",(FARPROC*)&m_fnRasGetEntryProperties);

	if (m_fnRasGetEntryProperties)
		dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, lpdwEntryInfoSize,
									lpbDeviceInfo, lpdwDeviceInfoSize);

	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\suapi.h ===
// ############################################################################
//#include "ras.h"
#define cbDataCenter (MAX_PATH+1)	// max length of data center string

// ############################################################################
class CDialog
{
public:
	void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
	void operator delete( void far * p ) {GlobalFree(p); };

	CDialog() {};
	~CDialog() {};
	virtual INT_PTR DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT)=0;
};

// ############################################################################
class CSelectNumDlg : public CDialog
{
public:
	CSelectNumDlg();
	INT_PTR DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
	DWORD m_dwCountryID;
	DWORD m_dwCountryIDOrg;
	WORD m_wRegion;
	DWORD_PTR m_dwPhoneBook;
	char m_szPhoneNumber[RAS_MaxPhoneNumber+1];
	char m_szDunFile[cbDataCenter];
	BYTE m_fType;
	BYTE m_bMask;
	DWORD m_dwFlags;
private:
	BOOL FHasPhoneNumbers(LPLINECOUNTRYENTRY pLCE);
	BOOL m_fHasRegions;
	HWND m_hwndDlg;
	HRESULT FillRegion();
	HRESULT FillNumber();
};

// ############################################################################
/********** 1/9/96 jmazner Normandy #13185
class CAccessNumDlg : public CDialog
{
public:
	CAccessNumDlg();
	~CAccessNumDlg() {};
	INT_PTR			DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
	DWORD			m_dwPhoneBook;
	PACCESSENTRY	*m_rgAccessEntry;
	WORD			m_wNumber;
	DWORD			m_dwCountryID;
	WORD			m_wRegion;
	BYTE			m_fType;
	BYTE			m_bMask;
	char	m_szPrimary[RAS_MaxPhoneNumber];
	char	m_szSecondary[RAS_MaxPhoneNumber];
	char	m_szDunPrimary[cbDataCenter + sizeof('\0')];
	char	m_szDunSecondary[cbDataCenter + sizeof('\0')];
};	
**************/

// ############################################################################
#ifdef WIN16
extern "C" INT_PTR CALLBACK __export PhbkGenericDlgProc(
#else
extern "C" __declspec(dllexport) INT_PTR CALLBACK PhbkGenericDlgProc(
#endif
    HWND  hwndDlg,	// handle to dialog box
    UINT  uMsg,	// message
    WPARAM  wParam,	// first message parameter
    LPARAM  lParam 	// second message parameter
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\rnaapi.h ===
//-----------------------------------------------------------------------------
// RNAAPI class
//
// This class provides a series of cover function for the RNAPH/RASAPI32 dlls
//
// Created 1-29-96	ChrisK

//-----------------------------------------------------------------------------
// TYPEDEF
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPSTR lpszPhonebook, LPSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPSTR lpszPhonebook, LPSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPSTR lpszPhonebook, LPSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);

//-----------------------------------------------------------------------------
// CLASS
// ############################################################################
class CRNAAPI
{
public:
	void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
	void operator delete( void far * p ) {GlobalFree(p); };

	CRNAAPI();
	~CRNAAPI();

	DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
	DWORD RasValidateEntryName(LPSTR,LPSTR);
	DWORD RasSetEntryProperties(LPSTR lpszPhonebook, LPSTR lpszEntry,
								LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
								LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
	DWORD RasGetEntryProperties(LPSTR lpszPhonebook, LPSTR lpszEntry,
								LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
								LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);


private:
	BOOL LoadApi(LPSTR, FARPROC*);

	HINSTANCE m_hInst;
	HINSTANCE m_hInst2;

	PFNRASENUMDEVICES m_fnRasEnumDeviecs;
	PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
	PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
	PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\phbooklib\suapi.cpp ===
// ############################################################################
#include "pch.hpp" 
#include "phbk.h"
#include "debug.h"
#include "phbkrc.h"
#include "misc.h"
//#include "ras.h"
#include <ras.h>
#pragma pack (4)
//#if !defined(WIN16)
//#include <rnaph.h>
//#endif
#pragma pack ()
#include "suapi.h"

#define ERROR_USER_EXIT 0x8b0bffff
#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

#define NOTIFY_CODE (HIWORD(wParam))

#define WM_SHOWSTATEMSG WM_USER+1

char szTemp[100];

char szValidPhoneCharacters[] = {"0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0"};

// ############################################################################
BOOL CSelectNumDlg::FHasPhoneNumbers(LPLINECOUNTRYENTRY pLCE)
{
	LPIDLOOKUPELEMENT pIDLookUp;
	IDLOOKUPELEMENT LookUpTarget;
	CPhoneBook far *pcPBTemp;
	PACCESSENTRY pAE = NULL, pAELast = NULL;
	DWORD dwCountryID;

	pcPBTemp = ((CPhoneBook far*)m_dwPhoneBook);

	LookUpTarget.dwID = pLCE->dwCountryID;

	pIDLookUp = NULL;
	pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&LookUpTarget,pcPBTemp->m_rgIDLookUp,
		(int)pcPBTemp->m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);

	if (!pIDLookUp) return FALSE; // no such country

	pAE = pIDLookUp->pFirstAE;
	if (!pAE) return FALSE; // no phone numbers at all

	dwCountryID = pAE->dwCountryID;

	pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
	while (pAELast > pAE && 
		   pAE->dwCountryID == dwCountryID)
	{
		if ((pAE->fType & m_bMask) == m_fType) return TRUE;
		pAE++;
	}
	return FALSE; // no phone numbers of the right type

//	return ((BOOL)(pIDLookUp->pFirstAE));
}

// ############################################################################
INT_PTR CSelectNumDlg::DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT lResult)
{
	LRESULT lRet = TRUE;
	unsigned int idx;
	int iCurIndex;
	int iLastIndex;
	PACCESSENTRY pAE = NULL;
	LPSTR p, p2;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		CPhoneBook far *pcPBTemp;
		pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
		m_hwndDlg = hwndDlg;

		// figure out if we are in the middle of an AUTODIAL
		//

		if (m_dwFlags & AUTODIAL_IN_PROGRESS)
		{
			EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDBACK),FALSE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSIGNUP),SW_HIDE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLDIALERR),SW_HIDE);
		} else if (m_dwFlags& DIALERR_IN_PROGRESS){
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSIGNUP),SW_HIDE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLAUTODIAL),SW_HIDE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_CMDBACK),SW_HIDE);
			SetDlgItemText(m_hwndDlg,IDC_CMDNEXT,GetSz(IDS_OK));
		}else {
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLAUTODIAL),SW_HIDE);
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLDIALERR),SW_HIDE);
		}

		// Fill in country list and select current country
		//

		iCurIndex = -1;		// 0xFFFFFFFF
		// NOTE: it might be nice for INTL testing purposes to fill this combo box with
		// a list sorted by the country ID instead of the country name.
		for (idx=0;idx<pcPBTemp->m_pLineCountryList->dwNumCountries;idx++)
		{
			if (FHasPhoneNumbers(pcPBTemp->m_rgNameLookUp[idx].pLCE))
			{
				wsprintf(szTemp,"%s (%ld)",
							pcPBTemp->m_rgNameLookUp[idx].psCountryName,
							pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID);
				iLastIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,
														CB_ADDSTRING,0,
														(LPARAM)((LPSTR) &szTemp[0]));
				SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETITEMDATA,
									(WPARAM)iLastIndex,
									(LPARAM)pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID);
				if (pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID == m_dwCountryID)
				{
					iCurIndex = iLastIndex;
				}
			}
		}

		if (iCurIndex != -1)	// 0xFFFFFFFF
		{
			SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETCURSEL,(WPARAM)iCurIndex,0);
		} else {
			SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETCURSEL,0,0);
			iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETITEMDATA,0,0);
			if (iCurIndex != CB_ERR) m_dwCountryID = iCurIndex;
		}

		// Copy country to label
		//
		if (GetDlgItemText(m_hwndDlg,IDC_CMBCOUNTRY,szTemp,100))
		{
			SetDlgItemText(m_hwndDlg,IDC_LBLCOUNTRY,szTemp);
		}

		// Initialize Last Selection Method
		//

		m_dwFlags &= (~FREETEXT_SELECTION_METHOD);
		m_dwFlags |= PHONELIST_SELECTION_METHOD;

		// Fill in region list and select current region
		//
		FillRegion();

		// Fill in phone numbers
		//
		FillNumber();

		SetFocus(GetDlgItem(m_hwndDlg,IDC_CMBCOUNTRY));
		lRet = FALSE;
		break;
	case WM_SHOWSTATEMSG:
		if (wParam)
		{
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSTATEMSG),SW_SHOW);
		} else {
			ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSTATEMSG),SW_HIDE);
		}
		break;
		// 1/9/96 jmazner  added for Normandy #13185
	case WM_CLOSE:
		if ((m_dwFlags & (AUTODIAL_IN_PROGRESS|DIALERR_IN_PROGRESS)) == 0) 
		{
			if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
				MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
				EndDialog(hwndDlg,IDC_CMDCANCEL);
		} else {
			EndDialog(hwndDlg,IDC_CMDCANCEL);
		}
		break;
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
			case IDC_CMBCOUNTRY:
				if (NOTIFY_CODE == CBN_SELCHANGE)
				{
					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETCURSEL,0,0);
					if (iCurIndex == CB_ERR) break;

					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
					if (iCurIndex == CB_ERR) break;
					m_dwCountryID = iCurIndex;  //REVIEW: data type????

					FillRegion();
					m_wRegion = 0;

					FillNumber();
				}
				break;
			case IDC_CMBREGION:
				if (NOTIFY_CODE == CBN_SELCHANGE)
				{
					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_GETCURSEL,0,0);
					if (iCurIndex == CB_ERR) break;

					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
					if (iCurIndex == CB_ERR) break;
					m_wRegion = (WORD) iCurIndex; //REVIEW: data type???

					FillNumber();
				}
				break;
			case IDC_CMBNUMBER:
				if ((NOTIFY_CODE == CBN_SELCHANGE) || (NOTIFY_CODE == CBN_DROPDOWN))
				{
					//iCurIndex = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETCURSEL,0,0);
					//if (iCurIndex == CB_ERR) break;

					EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);

					//iCurIndex = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
					//if (iCurIndex == CB_ERR) break;
					//if (!lstrcpy(&m_szDunFile[0],&((PACCESSENTRY)iCurIndex)->szDataCenter[0]))
					//{
					//	AssertSz(0,"Failed to copy data center from AE\n");
					//	break;
					//}

					// Set Last Selection Method
					//

					m_dwFlags &= (~FREETEXT_SELECTION_METHOD);
					m_dwFlags |= PHONELIST_SELECTION_METHOD;

				} else if (NOTIFY_CODE == CBN_EDITCHANGE) {

					if (SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,WM_GETTEXTLENGTH,0,0))
					{
						EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);
					} else {
						EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),FALSE);
					}

					// Set Last Selection Method
					//

					m_dwFlags &= (~PHONELIST_SELECTION_METHOD);
					m_dwFlags |= FREETEXT_SELECTION_METHOD;
				}

				break;
			case IDC_CMDNEXT:
				if ((m_dwFlags & PHONELIST_SELECTION_METHOD) == PHONELIST_SELECTION_METHOD)
				{
					DWORD_PTR dwItemData;

					iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETCURSEL,0,0);
					if (iCurIndex == CB_ERR) break;

					dwItemData = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
					if (iCurIndex == CB_ERR) break;

					// Get the relavant information out of the AE structures
					//

					pAE = (PACCESSENTRY)dwItemData;
					((CPhoneBook far *)m_dwPhoneBook)->GetCanonical(pAE,m_szPhoneNumber);
					lstrcpy(m_szDunFile,pAE->szDataCenter);
				} else {

					// Parse the text that the user entered
					//

					if (GetDlgItemText(m_hwndDlg,IDC_CMBNUMBER,m_szPhoneNumber,RAS_MaxPhoneNumber))
					{
						m_szPhoneNumber[RAS_MaxPhoneNumber] = '\0';
						for (p = m_szPhoneNumber;*p && *p != ':';p++);
						if (*p)
						{
							*p = '\0';
							p++;
							lstrcpy(m_szDunFile,p);
						} else {
							m_szDunFile[0] = '\0';
						}

						// Check that the phone number on contains valid characters
						//

						for (p = m_szPhoneNumber;*p;p++)
						{
							for(p2 = szValidPhoneCharacters;*p2;p2++)
							{
								if (*p == *p2)
									break; // p2 for loop
							}
							if (!*p2) break; // p for loop
						}

						if (*p)
						{
							MessageBox(m_hwndDlg,GetSz(IDS_INVALIDPHONE),GetSz(IDS_TITLE),MB_MYERROR);
							//MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
							break; // switch statement
						}
					} else {
						AssertSz(0,"You should never be able to hit NEXT with nothing in the phone number.\n");
					}
				}
				EndDialog(m_hwndDlg,IDC_CMDNEXT);
				break;
			case IDC_CMDCANCEL:
				if ((m_dwFlags & (AUTODIAL_IN_PROGRESS|DIALERR_IN_PROGRESS)) == 0) 
				{
					if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
						MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
						EndDialog(hwndDlg,IDC_CMDCANCEL);
				} else {
					EndDialog(hwndDlg,IDC_CMDCANCEL);
				}
			break;
				EndDialog(m_hwndDlg,IDC_CMDCANCEL);
				break;
			case IDC_CMDBACK:
				EndDialog(m_hwndDlg,IDC_CMDBACK);
				break;
		}
	default:
		lRet = FALSE;
		break;
	}// switch

	return lRet;
}

// ############################################################################
/***** 1/9/96  jmazner  Normandy #13185
CAccessNumDlg::CAccessNumDlg()
{
	m_szDunPrimary[0] = '\0';
	m_szDunSecondary[0] = '\0';
	m_szPrimary[0] = '\0';
	m_szSecondary[0] = '\0';
	m_rgAccessEntry = NULL;
	m_wNumber = 0;
	m_dwPhoneBook=0;
}
*********/

// ############################################################################
/********* 1/9/96 jmazner  Normandy #13185
                           This was dead code, unused anywhere in icwphbk
INT_PTR CAccessNumDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
										LRESULT lResult)
{
	LRESULT lRet = TRUE;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		SendDlgItemMessage(hwnd,IDC_TXTPRIMARY,EM_SETLIMITTEXT,RAS_MaxPhoneNumber,0);
		SendDlgItemMessage(hwnd,IDC_TXTSECONDARY,EM_SETLIMITTEXT,RAS_MaxPhoneNumber,0);

/ *
		// turn AccessEntries into phone numbers
		if(m_szPrimary[0] == '\0')
		{
			LPIDLOOKUPELEMENT pIDLookUp;
			CPhoneBook *pcPBTemp;
			pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);

			AssertSz(m_dwPhoneBook,"No phonebook set");

			//For the primary phone number
			pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&m_rgAccessEntry[0]->dwCountryID,
				pcPBTemp->m_rgIDLookUp,pcPBTemp->m_pLineCountryList->dwNumCountries,
				sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);
			SzCanonicalFromAE (m_szPrimary, m_rgAccessEntry[0], pIDLookUp->pLCE);

			if (m_rgAccessEntry[1])
			{
				if (m_rgAccessEntry[0]->dwCountryID != m_rgAccessEntry[1]->dwCountryID)
				{
					pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&m_rgAccessEntry[0]->dwCountryID,
						pcPBTemp->m_rgIDLookUp,pcPBTemp->m_pLineCountryList->dwNumCountries,
						sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);
				}
				SzCanonicalFromAE (m_szSecondary, m_rgAccessEntry[1], pIDLookUp->pLCE);
			}
		}
* /
		SendDlgItemMessage(hwnd,IDC_TXTPRIMARY,WM_SETTEXT,0,(LPARAM)&m_szPrimary[0]);
		SendDlgItemMessage(hwnd,IDC_TXTSECONDARY,WM_SETTEXT,0,(LPARAM)&m_szSecondary[0]);
		break;

		
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_CMDOK:
			// Check that we have at least one phone number
			// Leave dialog
			GetDlgItemText(hwnd,IDC_TXTPRIMARY,&m_szPrimary[0],RAS_MaxPhoneNumber);
			GetDlgItemText(hwnd,IDC_TXTSECONDARY,&m_szSecondary[0],RAS_MaxPhoneNumber);

			if (m_szPrimary[0])
				m_wNumber=1;
			else
				m_wNumber=0;

			if (m_szSecondary[0])
				m_wNumber++;

			EndDialog(hwnd,IDC_CMDOK);
			break;
		case IDC_CMDEXIT:
			// Verify with user
			// Get out of Dodge
			if (MessageBox(hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
				MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
				EndDialog(hwnd,IDC_CMDEXIT);
			break;
		case IDC_CMDCHANGEPRIMARY:
			// hide dialog
			ShowWindow(hwnd,SW_HIDE);
			// show new dialog
			CSelectNumDlg far *pcSelectNumDlg;
			pcSelectNumDlg = new CSelectNumDlg;
			if (!pcSelectNumDlg)
			{
				MessageBox(hwnd,GetSz(IDS_NOTENOUGHMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
//				MsgBox(IDS_NOTENOUGHMEMORY,MB_MYERROR);
				ShowWindow(hwnd,SW_SHOW);
				break;
			}
			int irc;
			pcSelectNumDlg->m_dwPhoneBook = m_dwPhoneBook;
			pcSelectNumDlg->m_dwCountryID = m_dwCountryID;
			pcSelectNumDlg->m_wRegion = m_wRegion;
			irc = DialogBoxParam(g_hInstDll,MAKEINTRESOURCE(IDD_SELECTNUMBER),
									g_hWndMain,PhbkGenericDlgProc,
									(LPARAM)pcSelectNumDlg);
			ShowWindow(hwnd,SW_SHOW);
			switch (irc)
			{
				case -1:
					MessageBox(hwnd,GetSz(IDS_NOTENOUGHMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
//					MsgBox(IDS_NOTENOUGHMEMORY,MB_MYERROR);
					goto DlgProcExit;
					// break;
				case IDC_CMDOK:
					m_dwCountryID = pcSelectNumDlg->m_dwCountryID;
					m_wRegion = pcSelectNumDlg->m_wRegion;
					lstrcpy(m_szDunPrimary,pcSelectNumDlg->m_szDunFile);
					SetDlgItemText(hwnd,IDC_TXTPRIMARY,pcSelectNumDlg->m_szPhoneNumber);
					break;
			}
			break;
		}
		break;
	default:
		lRet = FALSE;
		break;
	}
DlgProcExit:
	return lRet;
}

*********************/

#ifdef WIN16
// ############################################################################
// NAME: SetNonBoldDlg
//
//	Set all the child controls in a window to a non-bold version of the
//	current control font.
//
// Parameters: HWND hDlg	Handle to the dialog window
//
// Created 8/12/96	ValdonB (creatively borrowed from IE)
// ############################################################################

void
SetNonBoldDlg(HWND hDlg)
{
    HFONT hfontDlg = (HFONT) NULL;
    LOGFONT lFont;
    HWND hCtl;
    if ((hfontDlg = (HFONT) SendMessage(hDlg, WM_GETFONT, 0, 0L)))
    {
        if (GetObject(hfontDlg, sizeof(LOGFONT), (LPSTR) &lFont))
        {
            lFont.lfWeight = FW_NORMAL;
            if (hfontDlg = CreateFontIndirect((LPLOGFONT) &lFont))
            {
                // apply the font to all the child controls
                for (hCtl = GetWindow(hDlg, GW_CHILD);
                        NULL != hCtl;
                        hCtl = GetWindow(hCtl, GW_HWNDNEXT))
                {
                    SendMessage(hCtl, WM_SETFONT, (WPARAM) hfontDlg, 0);
                }
            }
        }
    }
}


// ############################################################################
// NAME: SetNonBoldDlg
//
// 	The dialog was modified earlier by unbolding the dialog font, and
// 	getting each control in the dialog to use that font. This function
// 	is called when the dialog is being destroyed so the font can be
// 	deleted
//
// Parameters: HWND hDlg	Handle to the dialog window
//
// Created 8/12/96	ValdonB (creatively borrowed from IE)
// ############################################################################

void
DeleteDlgFont
(
    HWND hDlg
)
{
	HFONT hfont = NULL;

	hfont = (HFONT)SendMessage(hDlg,WM_GETFONT,0,0);
	if (hfont) DeleteObject(hfont);
}
#endif	// WIN16



// ############################################################################
#ifdef WIN16
extern "C" INT_PTR CALLBACK __export PhbkGenericDlgProc(
#else
extern "C" __declspec(dllexport) INT_PTR CALLBACK PhbkGenericDlgProc(
#endif
    HWND  hwndDlg,	// handle to dialog box
    UINT  uMsg,	// message
    WPARAM  wParam,	// first message parameter
    LPARAM  lParam 	// second message parameter
   )
{
#if defined(WIN16)
	RECT	MyRect;
	RECT	DTRect;
#endif
//#ifdef DEBUG
//	DebugBreak();
//#endif
	CDialog far *pcDlg = NULL;
	LRESULT lRet;
	switch (uMsg)
	{
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(hwndDlg,IDC_LBLTITLE));
		break;
	case WM_INITDIALOG:
		pcDlg = (CDialog far *)lParam;
		SetWindowLongPtr(hwndDlg,DWLP_USER,lParam);
		lRet = TRUE;
#if defined(WIN16)
		//
		// Move the window to the center of the screen
		//
		GetWindowRect(hwndDlg, &MyRect);
		if (0 == MyRect.left && 0 == MyRect.top)
		{
			GetWindowRect(GetDesktopWindow(), &DTRect);
			MoveWindow(hwndDlg, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
								MyRect.right, MyRect.bottom, FALSE);
		}
		SetNonBoldDlg(hwndDlg);
#endif
		MakeBold(GetDlgItem(hwndDlg,IDC_LBLTITLE));
		break;
#if defined(WIN16)
	case WM_SYSCOLORCHANGE:
		Ctl3dColorChange();
		break;
#endif
	// 1/9/96  jmazner Normandy #13185, moved to CSelectNumDlg::DlgProc
	//case WM_CLOSE:
	//	if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
	//		MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
	//		EndDialog(hwndDlg,IDC_CMDCANCEL);
	//	lRet = TRUE;
	//	break;
//		//PostQuitMessage(0);
//		EndDialog(hwndDlg,FALSE);
//		lRet = TRUE;
//		break;
	default:
		// let the system process the message
		lRet = FALSE;
	}

	if (!pcDlg) pcDlg = (CDialog far*)GetWindowLongPtr(hwndDlg,DWLP_USER);
	if (pcDlg)
		lRet = pcDlg->DlgProc(hwndDlg,uMsg,wParam,lParam,lRet);

	return (INT_PTR)lRet;
}

// ############################################################################
HRESULT CSelectNumDlg::FillRegion()
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	int iCurIndex;
	int iLastIndex;
	unsigned int idx;
	CPhoneBook far *pcPBTemp;
	pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
	int iDebugIdx;
	
	// Fill in region list
	//

	SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_RESETCONTENT,0,0);
	SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_ADDSTRING,0,(LPARAM)GetSz(IDS_NATIONWIDE));
	iCurIndex = -1;		// 0xFFFFFFFF;
	m_fHasRegions = FALSE;
	for (idx=0;idx<pcPBTemp->m_cStates;idx++)
	{
		if (pcPBTemp->m_rgState[idx].dwCountryID == m_dwCountryID)
		{
			PACCESSENTRY pAE = NULL, pAELast = NULL;
			pAE = pcPBTemp->m_rgState[idx].paeFirst;
			Assert(pAE);
			pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
			while (pAELast > pAE && 
				pAE->dwCountryID == m_dwCountryID &&
				pAE->wStateID == idx+1)
			{
				if ((pAE->fType & m_bMask) == m_fType)
					goto AddRegion;
				pAE++;
			}
			continue;

AddRegion:
			m_fHasRegions = TRUE;

			iLastIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_ADDSTRING,0,(LPARAM)&pcPBTemp->m_rgState[idx].szStateName[0]);
			iDebugIdx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETITEMDATA,(WPARAM)iLastIndex,(LPARAM)idx+1);
			if ((idx+1) == m_wRegion)
			{
				iCurIndex = iLastIndex;
			}
		}
	}

	// select current region or nation wide
	//

	if (iCurIndex != -1)	// 0xFFFFFFFF
	{
		SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETCURSEL,(WPARAM)iCurIndex,0);
	} else {
		m_wRegion = 0;	// Nationwide
		SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETCURSEL,0,0);
	}

	EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMBREGION),m_fHasRegions);
	PostMessage(m_hwndDlg,WM_SHOWSTATEMSG,m_fHasRegions,0);

	hr = ERROR_SUCCESS;
	return hr;
}

// ############################################################################
CSelectNumDlg::CSelectNumDlg()
{
	m_dwCountryID = 0;
	m_wRegion = 0;
	m_dwPhoneBook = 0;
	m_szPhoneNumber[0] = '\0';
	m_szDunFile[0] = '\0';
	m_fType = 0;
	m_bMask = 0;
	m_fHasRegions = FALSE;
	m_hwndDlg = NULL;
	m_dwFlags = 0;
}

// ############################################################################
HRESULT CSelectNumDlg::FillNumber()
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
	PACCESSENTRY pAELast, pAE = NULL;
	CPhoneBook far *pcPBTemp;
	unsigned int idx;
	pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
	
	// Check if we need to look up the number from the region or from the country
	//

	if (m_fHasRegions && m_wRegion)
		pAE = pcPBTemp->m_rgState[m_wRegion-1].paeFirst;
	

	// Find the Access Entries for the country
	//

	if (!pAE)
	{
		LPIDLOOKUPELEMENT pIDLookUp, pLookUpTarget;

		pLookUpTarget = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,sizeof(IDLOOKUPELEMENT));
		Assert(pLookUpTarget);
		if (!pLookUpTarget) goto FillNumberExit;
		pLookUpTarget->dwID = m_dwCountryID;

		pIDLookUp = NULL;
		pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(pLookUpTarget,pcPBTemp->m_rgIDLookUp,
			(int)pcPBTemp->m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);
		if (pIDLookUp)
			pAE = pIDLookUp->pFirstAE;
	}

	// Fill the list for whatever AE's we found
	//
	
	SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_RESETCONTENT,0,0);
	if (pAE)
	{
		//pAELast = pcPBTemp->m_rgPhoneBookEntry + pcPBTemp->m_cPhoneBookEntries;
		pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
		while (pAELast > pAE && pAE->dwCountryID == m_dwCountryID && pAE->wStateID == m_wRegion)
		{
			if ((pAE->fType & m_bMask) == m_fType)
			{
				wsprintf(szTemp,"%s (%s) %s",pAE->szCity,pAE->szAreaCode,
							pAE->szAccessNumber);
				idx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,
												CB_ADDSTRING,0,
												(LPARAM)((LPSTR) &szTemp[0]));
				if (idx == -1) goto FillNumberExit;
				SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETITEMDATA,
									(WPARAM)idx,(LPARAM)pAE);
			}
			pAE++;
		}

		// Select the first item
		//

		if (SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETCURSEL,0,0) == CB_ERR)
				EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),FALSE);
		else
				EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);
		hr = ERROR_SUCCESS;
	}
FillNumberExit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\addr_fe.cpp ===
/*********************************************************************
Registration Wizard
Addr_fe.cpp
Address Dialog screen for Far East Countries
In getting the phone numbers the Area Code , Phone Number and Extension is got seperately.
And while sending the information to the backend the Area code is combined with Phone number. 

03/10/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <regpage.h>

#include <Winnt.h>
#include <stdio.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "cstattxt.h"
#include "cbitmap.h"
#include "cntryinf.h"
#include <rw_common.h>


static PROPSHEETPAGE  *spAddrSheet=NULL;
//static int vDeclineOffers = -1;
void ConfigureFEAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
void SetRegWizardCountryCode(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateFEAddrDialog(CRegWizard* pclRegWizard,HWND hwndDlg);
int ValidateFEAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);

///////////////////////////////
//#define CREATE_TAB_ORDER_FILE
///////////////////////////////

#ifdef CREATE_TAB_ORDER_FILE
void CreateAddrDlgTabOrderString(HWND hwndDlg);
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam);
#endif
INT_PTR CALLBACK AddressFEDialogProc(HWND hwndDlg, 
					UINT uMsg, 
					WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the 
user's address,phone, etc.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
	_TCHAR szTemp[256];
    INT_PTR bStatus;
	static int iXY = 0;
	HWND hWnd;
	
	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}
	
	
    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;	
        case WM_INITDIALOG:
		{	
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			//SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
						
	
		
			HWND hwndStateField = GetDlgItem(hwndDlg,IDC_EDIT4);
			SetFocus(hwndStateField);
			
			//NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			//NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT5);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT6);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT7);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT8);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT9);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT10);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT12);
		
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			
			BOOL boughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
			int stringID1 = boughtByCompany ? IDS_ADDRDLG_TEXT1B : IDS_ADDRDLG_TEXT1A;
			int stringID2 = boughtByCompany ? IDS_ADDRDLG_TEXT2B : IDS_ADDRDLG_TEXT2A;
			LoadString(pi->hInstance,stringID1,szTemp,256);
			//HWND hWnd = GetDlgItem(hwndDlg,IDT_TEXT1);
			//SetWindowText(hWnd,szTemp);

			LoadString(pi->hInstance,stringID2,szTemp,256);
			hWnd = GetDlgItem(hwndDlg,IDT_TEXT2);
			SetWindowText(hWnd,szTemp);

			//new CStaticText(pclRegWizard->GetInstance(),hwndDlg,IDT_TEXT1,stringID1,NULL);
			//new CStaticText(pclRegWizard->GetInstance(),hwndDlg,IDT_TEXT2,stringID2,NULL);
			if (pclRegWizard->GetInformationString(kInfoMailingAddress,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
			}
/*			if (pclRegWizard->GetInformationString(kInfoAdditionalAddress,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
			}*/
			if (pclRegWizard->GetInformationString(kInfoCity,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoState,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoZip,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoPhoneNumber,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT6,WM_SETTEXT,0,(LPARAM) szInfo);
			}
		/*	if (pclRegWizard->GetInformationString(kInfoEmailName,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT7,WM_SETTEXT,0,(LPARAM) szInfo);
			}*/
			if (pclRegWizard->GetInformationString(kInfoPhoneExt,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT8,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kAreaCode,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_AREACODE,WM_SETTEXT,0,(LPARAM) szInfo);
			}

		
			pclRegWizard->ResolveCurrentCountryCode();

			gTapiCountryTable.FillCountryList(pclRegWizard->GetInstance(), 
				GetDlgItem(hwndDlg,IDC_COMBO1)	);
			PTSTR psz = gTapiCountryTable.GetCountryName ( pclRegWizard->GetCountryCode());
			SendMessage(GetDlgItem(hwndDlg,IDC_COMBO1),
			CB_SELECTSTRING, (WPARAM) -1,(LPARAM) psz); //select this country
			if (pclRegWizard->GetInformationString(kInfoCountry,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_SELECTSTRING,(WPARAM) -1,(LPARAM) szInfo);
			}
			ConfigureFEAddrEditFields(pclRegWizard,hwndDlg);

			#ifdef CREATE_TAB_ORDER_FILE
			CreateAddrDlgTabOrderString(hwndDlg);
			FResSetDialogTabOrder(hwndDlg,IDS_TAB_ADDRESS);
			#endif

			vDialogInitialized = TRUE;
            return TRUE;
		} // WM_INIT
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
                pi->iCancelledByUser = RWZ_PAGE_OK;

				{
						BOOL boughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
						int stringID1 = boughtByCompany ? IDS_ADDRDLG_TEXT1B : IDS_ADDRDLG_TEXT1A;
						int stringID2 = boughtByCompany ? IDS_ADDRDLG_TEXT2B : IDS_ADDRDLG_TEXT2A;
						LoadString(pi->hInstance,stringID1,szTemp,256);
						//HWND hWnd = GetDlgItem(hwndDlg,IDT_TEXT1);
					//	SetWindowText(hWnd,szTemp);
						LoadString(pi->hInstance,stringID2,szTemp,256);
						hWnd = GetDlgItem(hwndDlg,IDT_TEXT2);
						SetWindowText(hWnd,szTemp);
				}
						

				//if(spAddrSheet) {
				//	spAddrSheet->pszHeaderTitle = MAKEINTRESOURCE(IDS_WELCOME_SCR_TITLE);
				//}

				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;
            case PSN_WIZNEXT:
				iRet=0;
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					if( ValidateFEAddrDialog(pclRegWizard,hwndDlg)) {
						ConfigureFEAddrEditFields(pclRegWizard,hwndDlg);
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoMailingAddress,szInfo);
					/*	SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoAdditionalAddress,szInfo);*/
						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCity,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoState,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoZip,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT6,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoPhoneNumber,szInfo);
					/*	SendDlgItemMessage(hwndDlg,IDC_EDIT7,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoEmailName,szInfo);*/
						SendDlgItemMessage(hwndDlg,IDC_EDIT8,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoPhoneExt,szInfo);
						
						// Get Area Code 
						SendDlgItemMessage(hwndDlg,IDC_AREACODE,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kAreaCode,szInfo);


						LRESULT selIndex = SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETCURSEL,0,0L);
						SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETLBTEXT,selIndex,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCountry,szInfo);
					
						SetRegWizardCountryCode(pclRegWizard,hwndDlg);
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
					
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet); 
				}
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kAddressDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
		{
			if (HIWORD(wParam) == CBN_KILLFOCUS){
				ConfigureFEAddrEditFields(pclRegWizard,hwndDlg);
			}
		} // WM_COMMAND
		break;
	    default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}



BOOL ValidateFEAddrDialog(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Address
dialog.  If any required edit field input is empty, ValidateAddrDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateFEAddrEditFields(pclRegWizard,hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szLabel[128];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szLabel,128);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szLabel,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndInvField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndInvField);
		return FALSE;
	}
}


int ValidateFEAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
ValidateFEAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the first empty
edit field control will be returned as the function result.  If all 
fields are OK, NULL will be returned.
**********************************************************************/
{
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1; 
//	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2; 
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3; 
	if(pclRegWizard->GetCountryCode() == 0)
	{
		if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT4)) 
			return IDC_EDIT4; 
	}
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT5)) return IDC_EDIT5; 
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT6)) return IDC_EDIT6;
//	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT7)) return IDC_EDIT7;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT8)) return IDC_EDIT8;

	return NULL; 
}


void ConfigureFEAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	SetRegWizardCountryCode(pclRegWizard,hwndDlg);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecAddress,IDT_TEXT2);
//	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecAddress2,IDT_TEXT4);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecCity,IDT_TEXT5);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT4,kAddrSpecState,IDT_TEXT6);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT5,kAddrSpecPostalCode,IDT_TEXT7);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT6,kAddrSpecPhone,IDT_TEXT8);
//	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT7,kAddrSpecEmailName,IDT_TEXT12);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT8,kAddrSpecExtension,IDT_TEXT9);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_AREACODE,kAddrSpecAreaCode,IDT_AREACODE);
}




#ifdef CREATE_TAB_ORDER_FILE
void CreateAddrDlgTabOrderString(HWND hwndDlg)
/*********************************************************************
Creates a comma delimited list of ID's for all controls belonging to
the given dialog, and writes the list to a text file.
**********************************************************************/
{
	HANDLE hFile = CreateFile(_T"c:\\ADDRTAB.TXT",GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		EnumChildWindows(hwndDlg, EnumChildProc,(LPARAM) hFile);
		CloseHandle(hFile);
	}
}
#endif


#ifdef CREATE_TAB_ORDER_FILE
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	_TCHAR rgch[128];
	int iCtrlId = GetDlgCtrlID(hwndChild);
	LPTSTR sz = GetFocus() == hwndChild ? _T"F" : _T"";
	wsprintf(rgch,_T"%i%s,",iCtrlId,sz);

	HANDLE hFile = (HANDLE) lParam;
	DWORD dwBytesWritten;
	WriteFile(hFile,rgch,_tcslen(rgch) * sizeof(_TCHAR),&dwBytesWritten,NULL);
	return TRUE;
}
#endif

//
//  This function is calles during the creation and deletion of
//  Address Property Sheet 
//  Store the Address of PPROPSHEETPAGE so the Subtitle can be changed
//
//
//
UINT CALLBACK AddressFEPropSheetPageProc(HWND hwnd, 
								UINT uMsg, 
								LPPROPSHEETPAGE ppsp 
								) 
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
		spAddrSheet = ppsp;
	default:
		break;

	}
	return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\business.cpp ===
/*********************************************************************
Registration Wizard
(c) 1994-95 Microsoft Corporation
Business Question

  04/26/98 - Suresh Krishnan

    06/18/98 - Add Blank Option for Software Role
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "RegPage.h"
#include "regwizmain.h"
#include "resource.h"
#include "dialogs.h"
#include "regutil.h"
#include <rw_common.h>

#define _INCLUDE_3RDPARTYLOGIC_CODE 

#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 
static int vDeclineOffers = -1;
#endif

static int siMaxSWRoleOptions=0;
BOOL ValidateBusinessUserDialog(HWND hwndDlg,int iStrID);
int  GetAndAddBusinessRoleFromResource(HINSTANCE hIns, HWND hwnd);

INT_PTR  CALLBACK BusinessUserDialogProc(HWND hwndDlg, UINT uMsg, 
										 WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that displays 
Business related Question 
network type, etc.
**********************************************************************/
{


	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
	BOOL NotboughtByCompany;
	HWND   hwBusinessRole;
	LRESULT    dwStatus;
	DWORD dwStart,dwEnd;
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 
	TriState shouldInclude;
#endif

	int	  iIndex; // Selection index for SW Role

	
	static int iShowThisPage= DO_SHOW_THIS_PAGE; 


	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
		hwBusinessRole = GetDlgItem(hwndDlg,IDC_COMBO2);
	}
	

    switch (uMsg)
    {
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;
		case WM_CLOSE:
			 break;			
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			siMaxSWRoleOptions = GetAndAddBusinessRoleFromResource(pi->hInstance, GetDlgItem(hwndDlg,IDC_COMBO2) );
			vDialogInitialized = FALSE;
            return TRUE;
		} // WM_INIT
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				NotboughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
				//
				// Check if System Inv DLL is present
				if( !NotboughtByCompany) {
					iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
				}else {
					iShowThisPage= DO_SHOW_THIS_PAGE;
				}
				if(iShowThisPage== DO_SHOW_THIS_PAGE) {
					NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
					NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
				}
				if( iShowThisPage== DO_NOT_SHOW_THIS_PAGE ) {
					//CB_GETCOUNT 
					//CB_GETCURSEL  // CB_ERR

					
					//CB_FINDSTRING wParam = (WPARAM) indexStart;    lParam = (LPARAM) (LPCSTR) lpszFind   
 

					pi->iCancelledByUser = RWZ_SKIP_AND_GOTO_NEXT;
					if( pi->iLastKeyOperation == RWZ_BACK_PRESSED){
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_BACK);
					}else {
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
					}

				}
				else {
					// Show this page
					pi->iCancelledByUser = RWZ_PAGE_OK;
					pi->iLastKeyOperation = RWZ_UNRECOGNIZED_KEYPESS;
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
										
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 					

					shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
					if (shouldInclude == kTriStateTrue ){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						vDeclineOffers = 1;
					}
					else if (shouldInclude == kTriStateFalse){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						vDeclineOffers = 0;
					}else if (shouldInclude == kTriStateUndefined){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
						vDeclineOffers = -1;
					}
					// Enable for previpously entred value in screen
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
#endif
					
#ifdef     USE_DROPDOWN
					if(pclRegWizard->GetInformationString(kBusinessRole,szInfo)) {
							//SendMessage(hwBusinessRole,	WM_SETTEXT,0,(LPARAM) szInfo);
							SendMessage(hwBusinessRole,CB_SELECTSTRING,(WPARAM) -1,(LPARAM) szInfo);
					}else {
							SendMessage(hwBusinessRole,	CB_SETCURSEL,0,0);
					}
#endif
					iIndex = 0;	
					if(pclRegWizard->GetInformationString(kBusinessRole,szInfo)) {
							iIndex = _ttoi(szInfo);
							if(iIndex < 10){
								iIndex = 0;
							}else {
								iIndex -=10;
                                iIndex++; // Added to include blank in option
							}
					}
					SendMessage(hwBusinessRole,	CB_SETCURSEL,iIndex,0);
					

					vDialogInitialized = TRUE;
					
				}
                break;

            case PSN_WIZNEXT:
					switch(pi->iCancelledByUser) {
					case  RWZ_CANCELLED_BY_USER : 
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					break;
					case RWZ_PAGE_OK:
					iRet=0;
					if( ValidateBusinessUserDialog(hwndDlg,IDS_BAD_SYSINV)) {
					    dwStatus = SendMessage(hwBusinessRole,	CB_GETCURSEL,0,0);
						if(dwStatus == CB_ERR) {
							dwStatus = 0;
						}
                        if(dwStatus > 0 ) {    
					        dwStatus--; // Added on 6/18  to include blank option	
                           _stprintf(szInfo,_T("%i"),dwStatus+10);
                        }
                        else {
                            dwStatus = 0; // to eleminate negative numbers 
                           _stprintf(szInfo,_T("%i"),dwStatus);
                        }
						pclRegWizard->SetInformationString(kBusinessRole,szInfo);


#ifdef USE_DROPDOWN
						dwStart = 128; 
						SendMessage(hwBusinessRole,	WM_GETTEXT,(WPARAM) (LPDWORD) dwStart,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kBusinessRole,szInfo);
						if(dwStatus == CB_ERR) {
							dwStatus = GetLastError();
							SendMessage(hwBusinessRole,	CB_GETEDITSEL,(WPARAM) (LPDWORD) &dwStart,(LPARAM) (LPDWORD) &dwEnd);
							SendMessage(hwBusinessRole,	WM_GETTEXT,(WPARAM) (LPDWORD) dwStart,(LPARAM) szInfo);
					 	}
#endif
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 
						if(vDeclineOffers == -1){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateUndefined);
						}
						else
						if(vDeclineOffers == 0){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateFalse);
						}
						else{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateTrue);
						}
						_stprintf(szInfo,_T("%i"),vDeclineOffers);
						RW_DEBUG << "\n Business Decline Offers " << szInfo << "\n" << flush;
						pclRegWizard->SetInformationString(kInfoDeclinesNonMSProducts,szInfo);
#endif

						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						// Set as Next Key Button Pressed
						}else {
							// Validation has failed so for it in the same screen
							// Force it it be in this screen
							iRet=-1;
						}
						SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet); 
					break;
					case RWZ_SKIP_AND_GOTO_NEXT:
					default:
						// Do not Validate the page and just go to the next page 
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;

					break;
				} // end of switch pi->iCancelledByUser
				break;
            case PSN_WIZBACK:
                pi->CurrentPage--;
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
				break;
			case PSN_QUERYCANCEL :
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kBusinessUserDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					pi->iLastKeyOperation = RWZ_CANCEL_PRESSED;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
        case WM_COMMAND:
		{
			switch (wParam)
            {
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 
              case IDC_RADIO2:
			  case IDC_RADIO1:
				if (vDialogInitialized){
					// If the 'No' button is checked, the user is declining
					// the "Non-Microsoft product" offers
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						vDeclineOffers = 1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						vDeclineOffers = 0;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else{
						vDeclineOffers = -1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
					}

				}
				break;
#endif
			  default:
				  break;
            }
		}// End of WM_COMMAND
        break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
       
}



BOOL ValidateBusinessUserDialog(HWND hwndDlg,int iStrID)
{
	return TRUE;
}

//
// returns Maximum number of elements 
//
int  GetAndAddBusinessRoleFromResource(HINSTANCE hIns, HWND hwndCB )
{
	
	int iCount =0;
	int iTokLen;
	int iResLen; 
	_TCHAR	seps[] = _T(",");
	_TCHAR *pDummy;
	LRESULT dwAddStatus ;

	LPTSTR	token;
	TCHAR   tcSrc[1024];

 	//SendMessage(hwndCB, CB_ADDSTRING, -1, (LPARAM) _T("             "));
	iResLen = LoadString(hIns,IDS_BUSINESSROLE_LIST,tcSrc,1024);
	
	token = _tcstok( tcSrc, seps );
    //	token = _tcstok( NULL, seps );
	while( token != NULL ) {
		iCount++;
		 RW_DEBUG  << "\n Add Business Role=[" << iCount << "]=" << token << flush;
 		 dwAddStatus = SendMessage(hwndCB, CB_ADDSTRING, -1, (LPARAM) token);
		/* Get next token: */
		token = _tcstok( NULL, seps );

   }
	return iCount;
   
  
   
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\addrdlg.cpp ===
/*********************************************************************
Registration Wizard

AddressDialog.cpp
10/19/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <regpage.h>

#include <Winnt.h>
#include <stdio.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "cstattxt.h"
#include "cbitmap.h"
#include "cntryinf.h"
#include <rw_common.h>


static PROPSHEETPAGE  *spAddrSheet=NULL;
void ConfigureAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
void SetRegWizardCountryCode(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateAddrDialog(CRegWizard* pclRegWizard,HWND hwndDlg);
int ValidateAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
//static int vDeclineOffers = -1;
///////////////////////////////
//#define CREATE_TAB_ORDER_FILE
///////////////////////////////

#ifdef CREATE_TAB_ORDER_FILE
void CreateAddrDlgTabOrderString(HWND hwndDlg);
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam);
#endif
INT_PTR CALLBACK AddressDialogProc(HWND hwndDlg, 
					UINT uMsg, 
					WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the 
user's address,phone, etc.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
	_TCHAR szTemp[256];
    INT_PTR bStatus;
	static int iXY = 0;
	HWND hWnd;
//	TriState shouldInclude;
	
	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}
	
	
    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;	
        case WM_INITDIALOG:
		{	
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
						
	
		
			HWND hwndAddrField = GetDlgItem(hwndDlg,IDC_EDIT1);
			SetFocus(hwndAddrField);
			
			//NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT5);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT6);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT7);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT8);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT9);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT10);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT12);
		
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			
			BOOL boughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
			int stringID1 = boughtByCompany ? IDS_ADDRDLG_TEXT1B : IDS_ADDRDLG_TEXT1A;
			int stringID2 = boughtByCompany ? IDS_ADDRDLG_TEXT2B : IDS_ADDRDLG_TEXT2A;
			LoadString(pi->hInstance,stringID1,szTemp,256);
			HWND hWnd = GetDlgItem(hwndDlg,IDT_TEXT1);
			SetWindowText(hWnd,szTemp);

			LoadString(pi->hInstance,stringID2,szTemp,256);
			hWnd = GetDlgItem(hwndDlg,IDT_TEXT2);
			SetWindowText(hWnd,szTemp);

			//new CStaticText(pclRegWizard->GetInstance(),hwndDlg,IDT_TEXT1,stringID1,NULL);
			//new CStaticText(pclRegWizard->GetInstance(),hwndDlg,IDT_TEXT2,stringID2,NULL);
			if (pclRegWizard->GetInformationString(kInfoMailingAddress,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
			}
/*			if (pclRegWizard->GetInformationString(kInfoAdditionalAddress,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
			}*/
			if (pclRegWizard->GetInformationString(kInfoCity,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoState,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoZip,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoPhoneNumber,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT6,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			if (pclRegWizard->GetInformationString(kInfoPhoneExt,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT8,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			if (pclRegWizard->GetInformationString(kAreaCode,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_AREACODE,WM_SETTEXT,0,(LPARAM) szInfo);
			}

		
			pclRegWizard->ResolveCurrentCountryCode();

			gTapiCountryTable.FillCountryList(pclRegWizard->GetInstance(), 
				GetDlgItem(hwndDlg,IDC_COMBO1)	);
			PTSTR psz = gTapiCountryTable.GetCountryName ( pclRegWizard->GetCountryCode());
			SendMessage(GetDlgItem(hwndDlg,IDC_COMBO1),
			CB_SELECTSTRING, (WPARAM) -1,(LPARAM) psz); //select this country
			if (pclRegWizard->GetInformationString(kInfoCountry,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_SELECTSTRING,(WPARAM) -1,(LPARAM) szInfo);
			}
			ConfigureAddrEditFields(pclRegWizard,hwndDlg);

			#ifdef CREATE_TAB_ORDER_FILE
			CreateAddrDlgTabOrderString(hwndDlg);
			FResSetDialogTabOrder(hwndDlg,IDS_TAB_ADDRESS);
			#endif

//			vDialogInitialized = TRUE;
            return TRUE;
		} // WM_INIT
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
                pi->iCancelledByUser = RWZ_PAGE_OK;

				{
						BOOL boughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
						int stringID1 = boughtByCompany ? IDS_ADDRDLG_TEXT1B : IDS_ADDRDLG_TEXT1A;
						int stringID2 = boughtByCompany ? IDS_ADDRDLG_TEXT2B : IDS_ADDRDLG_TEXT2A;
						LoadString(pi->hInstance,stringID1,szTemp,256);
						HWND hWnd = GetDlgItem(hwndDlg,IDT_TEXT1);
						SetWindowText(hWnd,szTemp);
						LoadString(pi->hInstance,stringID2,szTemp,256);
						hWnd = GetDlgItem(hwndDlg,IDT_TEXT2);
						SetWindowText(hWnd,szTemp);
				}
						

				//if(spAddrSheet) {
				//	spAddrSheet->pszHeaderTitle = MAKEINTRESOURCE(IDS_WELCOME_SCR_TITLE);
				//}

				//  Third Party  info related code 
/*					shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
					if (shouldInclude == kTriStateTrue ){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						vDeclineOffers = 1;
					}
					else if (shouldInclude == kTriStateFalse){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						vDeclineOffers = 0;
					}else if (shouldInclude == kTriStateUndefined){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
						vDeclineOffers = -1;
					}
					// Enable for previpously entred value in screen
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
*/
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;
            case PSN_WIZNEXT:
				iRet=0;
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					if( ValidateAddrDialog(pclRegWizard,hwndDlg)) {
						ConfigureAddrEditFields(pclRegWizard,hwndDlg);
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoMailingAddress,szInfo);
					/*	SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoAdditionalAddress,szInfo);*/
						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCity,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoState,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoZip,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT6,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoPhoneNumber,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT8,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoPhoneExt,szInfo);
						LRESULT selIndex = SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETCURSEL,0,0L);
						SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETLBTEXT,selIndex,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCountry,szInfo);

						// Get Area Code 
						SendDlgItemMessage(hwndDlg,IDC_AREACODE,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kAreaCode,szInfo);
						SetRegWizardCountryCode(pclRegWizard,hwndDlg);
						// 3 rd Party Acceptance
/*						if(vDeclineOffers == -1){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateUndefined);
						}
						else
						if(vDeclineOffers == 0){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateFalse);
						}
						else{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateTrue);
						}
						_stprintf(szInfo,_T("%i"),vDeclineOffers);
						RW_DEBUG << "\n Address Screen Decline Offers " << szInfo << "\n" << flush;
						pclRegWizard->SetInformationString(kInfoDeclinesNonMSProducts,szInfo);
*/						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						pi->CurrentPage++;
					
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet); 
				}
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kAddressDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
		{
			if (HIWORD(wParam) == CBN_KILLFOCUS){
				ConfigureAddrEditFields(pclRegWizard,hwndDlg);
			}
/*			case IDC_RADIO2:
			  case IDC_RADIO1:
				if (vDialogInitialized){
					// If the 'No' button is checked, the user is declining
					// the "Non-Microsoft product" offers
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						vDeclineOffers = 1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						vDeclineOffers = 0;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else{
						vDeclineOffers = -1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
					}

				}
				
*/

		} // WM_COMMAND
		break;
	    default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}



BOOL ValidateAddrDialog(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Address
dialog.  If any required edit field input is empty, ValidateAddrDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateAddrEditFields(pclRegWizard,hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szLabel[128];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szLabel,128);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szLabel,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndAddrField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndAddrField);
		return FALSE;
	}
}


int ValidateAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
ValidateAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the first empty
edit field control will be returned as the function result.  If all 
fields are OK, NULL will be returned.
**********************************************************************/
{
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1; 
//	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2; 
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3; 
	if(pclRegWizard->GetCountryCode() == 0)
	{
		if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT4)) 
			return IDC_EDIT4; 
	}
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT5)) return IDC_EDIT5; 
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT6)) return IDC_EDIT6;
//	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT7)) return IDC_EDIT7;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT8)) return IDC_EDIT8;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_AREACODE)) return IDC_AREACODE;


	return NULL; 
}


void ConfigureAddrEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	SetRegWizardCountryCode(pclRegWizard,hwndDlg);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecAddress,IDT_TEXT2);
//	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecAddress2,IDT_TEXT4);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecCity,IDT_TEXT5);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT4,kAddrSpecState,IDT_TEXT6);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT5,kAddrSpecPostalCode,IDT_TEXT7);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT6,kAddrSpecPhone,IDT_TEXT8);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT8,kAddrSpecExtension,IDT_TEXT9);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_AREACODE,kAddrSpecAreaCode,IDT_AREACODE);
}


void SetRegWizardCountryCode(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
This function determines the country code of the currently selected 
country in the Address dialog combo box, and sends it to the given
CRegWizard object.
**********************************************************************/
{
	_TCHAR szInfo[256];
	LRESULT selIndex = SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETCURSEL,0,0L);
	if (selIndex != CB_ERR)
	{
		SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_GETLBTEXT,selIndex,(LPARAM) szInfo);
		#ifdef SURESH
		DWORD dwCountryCode;
		if (CountryCodeFromSzCountryCode(pclRegWizard->GetInstance(),szInfo,&dwCountryCode))
		{
			pclRegWizard->SetCountryCode(dwCountryCode);
		}
		#endif 
		pclRegWizard->SetCountryCode(
		gTapiCountryTable.GetCountryCode(szInfo));

	}
}

#ifdef CREATE_TAB_ORDER_FILE
void CreateAddrDlgTabOrderString(HWND hwndDlg)
/*********************************************************************
Creates a comma delimited list of ID's for all controls belonging to
the given dialog, and writes the list to a text file.
**********************************************************************/
{
	HANDLE hFile = CreateFile(_T"c:\\ADDRTAB.TXT",GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		EnumChildWindows(hwndDlg,EnumChildProc,(LPARAM) hFile);
		CloseHandle(hFile);
	}
}
#endif


#ifdef CREATE_TAB_ORDER_FILE
BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	_TCHAR rgch[128];
	int iCtrlId = GetDlgCtrlID(hwndChild);
	LPTSTR sz = GetFocus() == hwndChild ? _T"F" : _T"";
	wsprintf(rgch,_T"%i%s,",iCtrlId,sz);

	HANDLE hFile = (HANDLE) lParam;
	DWORD dwBytesWritten;
	WriteFile(hFile,rgch,_tcslen(rgch) * sizeof(_TCHAR),&dwBytesWritten,NULL);
	return TRUE;
}
#endif

//
//  This function is calles during the creation and deletion of
//  Address Property Sheet 
//  Store the Address of PPROPSHEETPAGE so the Subtitle can be changed
//
//
//
UINT CALLBACK AddressPropSheetPageProc(HWND hwnd, 
								UINT uMsg, 
								LPPROPSHEETPAGE ppsp 
								) 
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
		spAddrSheet = ppsp;
	default:
		break;

	}
	return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\cstattxt.cpp ===
/*********************************************************************
Registration Wizard
Class: CStaticText

--- This class subclasses a Window control to create a custom static 
text control.

11/14/94 - Tracy Ferrier
04/15/97 - Modified to take care of crashing in Memphis as the default destoy was not handled 

(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <stdio.h>
#include "cstattxt.h"
#include "Resource.h"

LRESULT PASCAL StaticTextWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

CStaticText::CStaticText(HINSTANCE hInstance, HWND hwndDlg,int idControl,int idString1,int idString2)
/*********************************************************************
Constructor for our CStaticText class.  
**********************************************************************/
{
	m_hInstance = hInstance;
	m_szText = LoadExtendedString(hInstance,idString1,idString2);

	HWND hwndCtl = GetDlgItem(hwndDlg,idControl);
	m_lpfnOrigWndProc = (FARPROC) GetWindowLongPtr(hwndCtl,GWLP_WNDPROC);
	SetWindowLongPtr(hwndCtl,GWLP_WNDPROC,(LONG_PTR) StaticTextWndProc);
	SetWindowLongPtr(hwndCtl,GWLP_USERDATA,(LONG_PTR) this);

	HFONT hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0, 0L);
	if (hfont != NULL)
	{
		LOGFONT lFont;
		if (!GetObject(hfont, sizeof(LOGFONT), (LPTSTR)&lFont))
		{
			m_hFont = NULL;
		}
		else
		{
			lFont.lfWeight = FW_NORMAL;
			hfont = CreateFontIndirect((LPLOGFONT)&lFont);
			if (hfont != NULL)
			{
				m_hFont = hfont;
			}
		}
	}

}


CStaticText::~CStaticText()
/*********************************************************************
Destructor for our CStaticText class
**********************************************************************/
{
	if (m_szText) GlobalFree(m_szText);
	if (m_hFont) DeleteObject(m_hFont);
}


LPTSTR CStaticText::LoadExtendedString(HINSTANCE hInstance,int idString1,int idString2)
/*********************************************************************
This function builds a single string out of the string resources whose 
ID's are given by the idString1 and idString2 parameters (if the
idString2 parameter is given as NULL, only the string resource 
specified by idString1 will be used.  LoadExtendedString allocates
space for the extended string on the heap, and returns a pointer to
it as the function result.
**********************************************************************/
{
	_TCHAR szTextBuffer[512];
	int resSize = LoadString(hInstance,idString1,szTextBuffer,255);
	if (idString2 != NULL)
	{
		_TCHAR szTextBuffer2[256];
		resSize = LoadString(hInstance,idString2,szTextBuffer2,255);
		_tcscat(szTextBuffer,szTextBuffer2);
	}
	HGLOBAL szReturnBuffer = GlobalAlloc(LMEM_FIXED,(_tcslen(szTextBuffer) + 1)* sizeof(_TCHAR));
	_tcscpy((LPTSTR) szReturnBuffer,szTextBuffer);
	return (LPTSTR) szReturnBuffer;
}


LRESULT PASCAL CStaticText::CtlWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	switch (message)
	{
		case WM_PAINT:
		{
			PAINTSTRUCT ps;
			RECT wndRect;
			GetClientRect(hwnd,&wndRect);
			HDC hdc = BeginPaint(hwnd,&ps);
			SelectObject(hdc,m_hFont);
			SetBkMode(hdc,TRANSPARENT);
			DrawText(hdc,m_szText,-1,&wndRect,DT_LEFT | DT_WORDBREAK);
			EndPaint(hwnd,&ps);
			break;
		}
		case WM_GETTEXT:
		{
			LPTSTR szBuffer = (LPTSTR) lParam;
			WPARAM userBufferSize = wParam;
			_tcsncpy(szBuffer,m_szText,(size_t)userBufferSize);
			break;
		}
		case WM_SETTEXT:
		{
			if (m_szText) GlobalFree(m_szText);
			LPTSTR szBuffer = (LPTSTR) lParam;
			m_szText = (LPTSTR) GlobalAlloc(LMEM_FIXED,(_tcslen(szBuffer) + 1)* sizeof(_TCHAR));
			_tcscpy(m_szText,szBuffer);
			break;
		}
	
		case WM_DESTROY:
			SetWindowLongPtr(hwnd,GWLP_WNDPROC,(LONG_PTR) m_lpfnOrigWndProc);

		default:
#ifdef _WIN95
		return CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#else
		return CallWindowProc((WNDPROC) m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#endif

			break;
	}
	return 0;
}


LRESULT PASCAL StaticTextWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	CStaticText* pclStaticText = (CStaticText*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
	LRESULT lret;
	switch (message)
	{
		case WM_DESTROY:
			lret = pclStaticText->CtlWndProc(hwnd,message,wParam,lParam);

			delete pclStaticText;
			return lret;
		default:
			return pclStaticText->CtlWndProc(hwnd,message,wParam,lParam);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\dialscr.cpp ===
/*
	File : DialScr.cpp
	Dialup Screen for RegWiz using Wizard 97 control

	02/13/98  Suresh Krishnan
	Modifications :
	Date 5/27/98 : Suresh

	DisplayPhoneNumber() was displaying  junk if countries do not have area code
	This is because the TAPI  call was failing because of the format represented in canonical form .
	Presently if are code is NULL then,  araecode is ignored in canonical form.
	


*/

#include <Windows.h>
#include "RegPage.h"
#include <stdio.h>
#include "ATK_RAS.h"

#include <tchar.h>
#include "resource.h"
#include "RegWizMain.h"
#include "dialogs.h"
#include <sudefs.h>
#include "rw_common.h"
#include "rwpost.h"
#include "regutil.h"
#include "mcm.h"

extern BOOL bPostSuccessful;

static  RASENTRY	 theRasEntry;
static  TCHAR szIspUserName[256];   // Temporary ISP Acoount Name
static  TCHAR szIspUserPassword[256]; // temp ISP Account Password

#define  MSN_SITE_DUN  _T("REGWIZ")

void  DialingProperties (HINSTANCE hIns, HWND hParent); //

DWORD ConfigureDUN ( HWND hWnd, HINSTANCE hInstance,
					 RASENTRY	*pRasEntry,
					 TCHAR		*szUserName,
					 TCHAR		*szPassword,
					 int    iModemIndex);

//
//  Global Variables
static HINSTANCE	m_hInstance;
static HWND			m_hWnd;
static HANDLE		m_hThread;
static HANDLE		hRasNotifyEvt;
static HANDLE		hRasKillEvt;
static HRASCONN		hRasConn;
static int siExitThread = 0;   // Set if the USer wants to Terminate
static DWORD    dwRasError = 0; // To Store Ras reported Error
static  int siPreviousRasState = RASCS_OpenPort;
static  int siCurrentRasState  = RASCS_OpenPort;

static DWORD DialThread(PVOID pData);  // the thread fun used for RAS connection
static void  RasDialFunc( UINT unMsg, RASCONNSTATE rasconnstate, DWORD dwError );
class  DialupHelperClass {
public :
	DialupHelperClass(HINSTANCE hIns, HWND hWnd);
	~DialupHelperClass();
	BOOL InvokeDialupSettings();
	BOOL CheckForDialingProperties();
    BOOL DisplayPhoneNumber();

	DWORD	CreateRasDialThread();
	BOOL	WaitForRasThread( HANDLE	hThread, BOOL fTimeOut);
	void	InitForStaticFunction( HINSTANCE hIns, HWND hWnd);
	void	DestroyRasThread(BOOL bRetry);

};


//
//  FUNCTION: GetRasConnState( RASCONNSTATE )
//
//  PURPOSE: get the index to the corresponding string
//
//  PARAMETERS:
//    rasconn - ras connection state
//
//  RETURN VALUE:
//    index into stringtable.
//
//  COMMENTS:
//
UINT GetRasConnState( RASCONNSTATE rasconn )
{
	

    switch( rasconn )
    {
        case RASCS_OpenPort:
            return IDS_OPENPORT;
        case RASCS_PortOpened:
            return IDS_PORTOPENED;
        case RASCS_ConnectDevice:
            return IDS_CONNECTDEVICE;
        case RASCS_DeviceConnected:
            return IDS_DEVICECONNECTED;
        case RASCS_AllDevicesConnected:
            return IDS_ALLDEVICESCONNECTED;
        case RASCS_Authenticate:
            return IDS_AUTHENTICATE;
        case RASCS_AuthNotify:
            return IDS_AUTHNOTIFY;
        case RASCS_AuthRetry:
            return IDS_AUTHRETRY;
        case RASCS_AuthCallback:
            return IDS_AUTHCALLBACK;
        case RASCS_AuthChangePassword:
            return IDS_AUTHCHANGEPASSWORD;
        case RASCS_AuthProject:
            return IDS_AUTHPROJECT;
        case RASCS_AuthLinkSpeed:
            return IDS_AUTHLINKSPEED;
        case RASCS_AuthAck:
            return IDS_AUTHACK;
        case RASCS_ReAuthenticate:
            return IDS_REAUTHENTICATE;
        case RASCS_Authenticated:
            return IDS_AUTHENTICATED;
        case RASCS_PrepareForCallback:
            return IDS_PREPAREFORCALLBACK;
        case RASCS_WaitForModemReset:
            return IDS_WAITFORMODEMRESET;
        case RASCS_WaitForCallback:
            return IDS_WAITFORCALLBACK;
        case RASCS_Interactive:
            return IDS_INTERACTIVE;
        case RASCS_RetryAuthentication:
            return IDS_RETRYAUTHENTICATION;
        case RASCS_CallbackSetByCaller:
            return IDS_CALLBACKSETBYCALLER;
        case RASCS_PasswordExpired:
            return IDS_PASSWORDEXPIRED;
        case RASCS_Connected:
            return IDS_CONNECTED;
        case RASCS_Disconnected:
            return IDS_DISCONNECTED;
        default:
            return IDS_RAS_UNDEFINED_ERROR;
    }
}


//
//  This function Enable or Disables the Controls of Wizard 97 control
//  Cancel, Back, Next buttons
//  the hDlg passed is the child of the Wizard control. So we use
//  GetParent to get the handle of Wizard control
//
BOOL RW_EnableWizControl(
					HWND hDlg,
					int	 idControl,
					BOOL fEnable
					)
{
	if (hDlg ==NULL ){
		return FALSE;
	}

	HWND hWnd = GetDlgItem(GetParent( hDlg),idControl);
	if (hWnd){
		EnableWindow(hWnd,fEnable);
	}
	return TRUE;

}



BOOL FEnableControl(
					HWND hDlg,
					int	 idControl,
					BOOL fEnable
					)
{
	if (NULL == hDlg)
	{
		//AssertSz(0,"Null Param");
		return FALSE;
	}

	HWND hWnd = GetDlgItem(hDlg,idControl);
	if (hWnd)
	{
		EnableWindow(hWnd,fEnable);
	}
	return TRUE;
}





DialupHelperClass :: DialupHelperClass( HINSTANCE hIns, HWND hWnd)
{
	m_hInstance = hIns;
	m_hWnd = hWnd;
	hRasNotifyEvt = NULL;
	hRasKillEvt = NULL;
	m_hThread = NULL;
	hRasConn = NULL;

}

DialupHelperClass :: ~DialupHelperClass()
{

}

//
// This function invokes Telephoney Settings of the control Panel
//

BOOL DialupHelperClass :: InvokeDialupSettings()
{	
/*********************************************************************
This function puts up the "Telephon properties " control panel, and
returns only when the user has dismissed the dialog (either after
installing a new modem, or canceling).
Returns: FALSE if an error prevented the dialog from being displayed.
**********************************************************************/

	_TCHAR 				szCmdLine[128];
	STARTUPINFO 		si;
	PROCESS_INFORMATION pi;
	BOOL 				fControlProcessDone = FALSE;
	BOOL 				fProcessStatus;
	//HWND				hwndProcess;
	

	LoadString(m_hInstance ,IDS_DIALINGPROPERTIES,szCmdLine,128);

	si.cb = sizeof(STARTUPINFO);
	si.lpReserved = NULL;
	si.lpDesktop = NULL;
	si.lpTitle = NULL;
	si.dwFlags = 0L;
	si.cbReserved2 = 0;
	si.lpReserved2 = NULL;

	fProcessStatus = CreateProcess(NULL,szCmdLine,NULL,NULL,FALSE,
		CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP | NORMAL_PRIORITY_CLASS,NULL,NULL,&si,&pi);
	if (fProcessStatus == FALSE)
	{
		return FALSE;
	}
	else
	{
		CloseHandle(pi.hThread);

		DWORD dwRet;
		dwRet = WaitForSingleObject(pi.hProcess, INFINITE);
		switch(dwRet) {
		case WAIT_ABANDONED :
			break;
		case WAIT_OBJECT_0:
			break;
		case WAIT_TIMEOUT:
			break;
		case WAIT_FAILED:
			DWORD dwLastError;
			dwLastError = GetLastError();
			break;
		default :
			break;
		}
	
	}
	CloseHandle(pi.hProcess);
	return TRUE;
}

//Cancel..
void DialupHelperClass :: DestroyRasThread(BOOL bRetry)
{
	
	if(!bRetry)
	{
		siExitThread  = 1;
		if(hRasNotifyEvt)
		{
			SetEvent (hRasNotifyEvt);
		}
	
		if(m_hThread)
		WaitForSingleObject(m_hThread, INFINITE);
	}

	if( hRasConn != NULL )
	{
		int i =0;
		DWORD dwConnectStatus = 0;
		DWORD dwHangupRet =0;
		RASCONNSTATUS rasConn;
		rasConn.dwSize = sizeof(RASCONNSTATUS);
		try
		{
		
			RW_DEBUG << "Hanging up the connection" << endl;

			dwHangupRet = ATK_RasHangUp( hRasConn );
			if(!dwHangupRet)
			{
				do
				{
					RW_DEBUG << "chek connection status" << endl;
					dwConnectStatus = ATK_RasGetConnectionStatus(hRasConn,&rasConn) ;
					Sleep(100);
					i++;
				}while ((dwConnectStatus != ERROR_INVALID_HANDLE ) || (i < 200));
			}
			else
			{
				RW_DEBUG << "Hangup result: " << dwHangupRet << endl;
			}

			RW_DEBUG << "connection shot dead" << endl;
			hRasConn = NULL;
		}
		catch(...)
		{
			RW_DEBUG << "Error Caught dwHangupRet:" << dwHangupRet << endl;
			//RW_DEBUG << "hRasConn:" << hRasConn << endl;
		}
	}

	if(!bRetry)
	{
		siExitThread  = 0;
		m_hThread = NULL;
	}

	RW_DEBUG << "Exiting DestroyRasThread" << endl;
	return ;	
}

BOOL DialupHelperClass ::  CheckForDialingProperties()
{
	HKEY    hKey;
	TCHAR   szTel[256] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations");
	TCHAR   szCI [48] = _T("CurrentID");
	_TCHAR  czLastStr[48];
	_TCHAR  czNewKey[256];
	DWORD   dwCurrentId;

	LONG	lStatus;
	DWORD   dwInfoSize = 48;
	BOOL    bRetValue;
	bRetValue = TRUE;

	LoadString(m_hInstance,IDS_TELEPHONE_LOC,szTel,256);
	LoadString(m_hInstance,IDS_TELEPHONE_CID,szCI,48);

	lStatus= RegOpenKeyEx(HKEY_LOCAL_MACHINE,szTel,0,KEY_READ,&hKey);
	if (lStatus == ERROR_SUCCESS)
	{
		//  Get Index
		//
		dwInfoSize = sizeof(dwCurrentId);
		lStatus = RegQueryValueEx(hKey,szCI,NULL,0,(  LPBYTE )&dwCurrentId,&dwInfoSize);
		if( lStatus !=  ERROR_SUCCESS)
		{
			RegCloseKey(hKey);
			bRetValue = FALSE;
		}
		RegCloseKey(hKey);
	}

	//
	// Now Contine to scan
	//for (int iCount =0; iCount < dwNumEntries; iCount ++ )
		
	_stprintf(czLastStr,_T("\\Location%d"),dwCurrentId);
	_tcscpy(czNewKey,szTel);
	_tcscat(czNewKey,czLastStr);

	lStatus= RegOpenKeyEx(HKEY_LOCAL_MACHINE,czNewKey,0,KEY_READ,&hKey);

	if (lStatus == ERROR_SUCCESS)
	{
			bRetValue = TRUE;
	}
	
	if(!bRetValue)
	{
		_TCHAR szMessage[256];
		LoadString(m_hInstance,IDS_DIALING_MESSAGE,szMessage,256);
		RegWizardMessageEx(m_hInstance,m_hWnd,IDD_INVALID_DLG,szMessage);
		return InvokeDialupSettings();
	}
	return bRetValue;
}

BOOL DialupHelperClass :: DisplayPhoneNumber(void)
{
	HLINEAPP hLineApp;
	_TCHAR szAddressIn[256];
	HWND hCtl;

	DWORD dwAPI,dwDevice,dwAPIHighVersion = 0x30000;
	
    LPLINETRANSLATEOUTPUT lpTranslateOutput;
	
	lpTranslateOutput = (LPLINETRANSLATEOUTPUT)LocalAlloc (LPTR, sizeof(LINETRANSLATEOUTPUT));

    lpTranslateOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

    if(FGetDeviceID(m_hInstance, &hLineApp, &dwAPI, &dwDevice,0))
	{
		_TCHAR szTemp[256];
	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n After FGetDeviceID" << flush;
	#endif
	
		// Put the number in the canonical form -> +1 (201) 2220577
		
		_itot(theRasEntry.dwCountryCode,szTemp,10);
		_tcscpy(szAddressIn,_T("+"));
		_tcscat(szAddressIn,szTemp);
		if(theRasEntry.szAreaCode[0] == 0 ) {
			_tcscat(szAddressIn,_T(" "));;
		}else {
			_tcscat(szAddressIn,_T(" ("));
			_tcscat(szAddressIn,theRasEntry.szAreaCode);
			_tcscat(szAddressIn,_T(") "));
		}
		
		_tcscat(szAddressIn,theRasEntry.szLocalPhoneNumber);

	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n Device:" <<dwDevice << "Phone number:" <<ConvertToANSIString(szAddressIn)<< flush;
	#endif
	
		long lRet = lineTranslateAddress(hLineApp,dwDevice,dwAPIHighVersion,(LPCTSTR)szAddressIn,0,0,
										lpTranslateOutput);
	
		if(lRet == 0)
		{
			size_t sizeNeeded;
			sizeNeeded = lpTranslateOutput->dwNeededSize;
			
			LocalFree(lpTranslateOutput);


			// Make sure the buffer exists, is valid and big enough.
		    lpTranslateOutput = (LPLINETRANSLATEOUTPUT)LocalAlloc (LPTR,sizeNeeded);
			
			lpTranslateOutput->dwTotalSize = sizeNeeded;

			if (lpTranslateOutput == NULL)
		        return FALSE;


			lRet = lineTranslateAddress(hLineApp,dwDevice,dwAPIHighVersion,(LPCTSTR)szAddressIn,0,0,
										lpTranslateOutput);
			if(lRet == 0)
			{
				_TCHAR szTemp[256] ;
				#ifdef _LOG_IN_FILE
					 RW_DEBUG  << "\n lineTranslateAddress  returns true:" << flush;
				#endif
				
				RW_DEBUG  << "\n dwTotalSize:" << lpTranslateOutput->dwTotalSize<< endl;
				RW_DEBUG  << "\n dwNeededSize:" << lpTranslateOutput->dwNeededSize  << endl;
				RW_DEBUG  << "\n dwUsedSize:" << lpTranslateOutput->dwUsedSize << endl;
				RW_DEBUG  << "\n dwDisplayableStringSize:" << lpTranslateOutput->dwDisplayableStringSize << endl;
				RW_DEBUG  << "\n dwDisplayableStringOffset:" << lpTranslateOutput->dwDisplayableStringOffset << endl;
				RW_DEBUG  << "\n dwDialableStringSize:" << lpTranslateOutput->dwDialableStringSize << endl;
				RW_DEBUG  << "\n dwDialableStringOffset:" << lpTranslateOutput->dwDialableStringOffset << endl;
				RW_DEBUG  << "\n dwDestCountry:" << lpTranslateOutput->dwDestCountry << endl;
				RW_DEBUG  << "\n dwCurrentCountry:" << lpTranslateOutput->dwCurrentCountry << endl;
			
				hCtl = GetDlgItem(m_hWnd,IDC_PHONENUMBER);
				if (hCtl)
				{
					#ifdef _LOG_IN_FILE
					// RW_DEBUG  << "\n Full Phone number:" <<ConvertToANSIString(szTemp)<< flush;
					#endif

					SetWindowText(hCtl,(LPCTSTR)(((LPCSTR)lpTranslateOutput) + lpTranslateOutput->dwDisplayableStringOffset ));

					LocalFree(lpTranslateOutput);

					return TRUE;
				}
				else
				{
					LocalFree(lpTranslateOutput);
				}
			}
		}
		else
		{
			
			#ifdef _LOG_IN_FILE
				 RW_DEBUG  << "\n*Error in  lineTranslateAddress  returned:" << lRet << flush;
			#endif
   		    hCtl = GetDlgItem(m_hWnd,IDC_PHONENUMBER);
			SetWindowText(hCtl,szAddressIn);

		}
	}
	else
	{
		#ifdef _LOG_IN_FILE
			 RW_DEBUG  << "\n FGetDeviceID failed" << flush;
		#endif

	}
	return FALSE;
}




DWORD  DialupHelperClass :: CreateRasDialThread()
{
	DWORD	dwTID;
	DWORD	dwEnd;
		 					
	if (m_hThread)	//if we are already doing this..
	{
		if (STILL_ACTIVE == GetExitCodeThread(m_hThread,&dwEnd)) //pass back the exit code from the thread.
		{
			//AssertSz(0,"Already have a thread dialing..");
			WaitForRasThread(m_hThread,FALSE);			//wait for thread as long as it takes.
		}	
		CloseHandle(m_hThread);
		m_hThread = NULL;
	}
	hRasNotifyEvt = CreateEvent(NULL, FALSE,FALSE,NULL);
	hRasKillEvt   = CreateEvent(NULL, FALSE,FALSE,NULL);

	if(hRasNotifyEvt == NULL ) {
		return DIALFAILED;
	}
    //launch a thread to do dialing.
	m_hThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)
		DialThread ,NULL,0,&dwTID);						
	if (NULL == m_hThread)
	{
		
		return DIALFAILED;
	}
		
	return DIALSUCCESS;
	
}



DWORD  DialThread(PVOID pData)
{
    RASDIALPARAMS rdParams;
    DWORD dwRet;
    _TCHAR  szBuf[256];
	int iExit;
	DWORD dwPostRet;
	int iTimeOut;

    // setup RAS Dial Parameters
    rdParams.dwSize = sizeof(RASDIALPARAMS);
    lstrcpy(rdParams.szEntryName,MSN_SITE_DUN);
    rdParams.szPhoneNumber[0] = '\0';
	
	GetDlgItemText(m_hWnd,IDC_PHONENUMBER,rdParams.szPhoneNumber,RAS_MaxPhoneNumber+1);

    rdParams.szCallbackNumber[0] = '*';
    rdParams.szCallbackNumber[1] = '\0';

    //rdParams.szUserName[0] = '\0';
    //rdParams.szPassword[0] = '\0';
	_tcscpy(szIspUserName,_T("RegWizNT30@gn.microsoft.com"));
	_tcscpy(szIspUserPassword,_T("RegSupNT"));

	_tcscpy(rdParams.szUserName,szIspUserName);
	_tcscpy(rdParams.szPassword,szIspUserPassword);
    rdParams.szDomain[0] = '*';
    rdParams.szDomain[1] = '\0';
    hRasConn = NULL;
	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n Before RAS Dial " << flush;
	     RW_DEBUG  << "\n UserName:" << ConvertToANSIString(szIspUserName) << flush;
		 RW_DEBUG  << "\n UserPassword:" << ConvertToANSIString(szIspUserPassword) << flush;
	#endif


    dwRet = ATK_RasDial( NULL, NULL, &rdParams, 0L, (RASDIALFUNC) RasDialFunc, &hRasConn);
		#ifdef _LOG_IN_FILE
			 RW_DEBUG  << "\n After  RAS Dial " << flush;
			
		#endif

    if ( dwRet ){
        if ( ATK_RasGetErrorString( (UINT)dwRet, (LPTSTR)szBuf, 256 ) != 0 )
            wsprintf( (LPTSTR)szBuf, _T("Undefined RAS Dial Error (%ld)."), dwRet );
		LoadString(m_hInstance, IDS_MODEM_ALREADY_INUSE, szBuf, 64 );
		#ifdef _LOG_IN_FILE
			RW_DEBUG  << "\n" << "Undefined Error"  << flush;
		#endif
		SetDlgItemText( m_hWnd, ID_LABELINIT, (LPCTSTR) szBuf );
		PostMessage( m_hWnd, WM_COMMAND,
						(WPARAM) IDEND, RWZ_ERROR_MODEM_IN_USE );
		
        return TRUE;
    }
	iExit = 0;
	iTimeOut = 0;
	do
	{
		dwRet = WaitForSingleObject(hRasNotifyEvt,100);
		switch(dwRet)
		{
		case WAIT_ABANDONED :
			iExit = 1;
			break;
		case WAIT_OBJECT_0:
			break;
		case WAIT_TIMEOUT:
			break;
		default :
			break;
		}
		//
		//  Check if it is necessary to  kill this thread operation
		//
		if( siExitThread  )
		{
			iExit = 1;
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n RAS Thread : User request to Kill The RAS Thread " << dwRasError << flush;
			#endif
		}
		else
		{
			// Check if there is any RAS Error
			if(  dwRasError )
			{
				#ifdef _LOG_IN_FILE
					RW_DEBUG << "\n RAS Thread : Error  " << dwRasError << flush;
				#endif
				iExit = 1;
				PostMessage( m_hWnd, WM_COMMAND,
				(WPARAM) IDD_DIALUP_ERROR, dwRasError );
				dwRasError = 0;

			}
			else
			{
			//
			// Check if RAS Connection is established
				if(siCurrentRasState   == RASCS_Connected )
				{

					#ifdef _LOG_IN_FILE
						RW_DEBUG << "\n RAS Thread : Connected To MSN Site \n Txmit Data  " << flush;
						
					#endif
					iExit =1;
					dwPostRet = SendHTTPData(m_hWnd, m_hInstance);
					#ifdef _LOG_IN_FILE
						RW_DEBUG << "\n RAS Thread : After Posting Data  " << dwPostRet  << flush;
						
					#endif
					PostMessage( m_hWnd, WM_COMMAND,
						(WPARAM) IDEND, dwPostRet );

					//
					// Send Data by HTP Post
					//
				}
			}
		}

	}while(!iExit);
	//
	//  Action  to be done while exiting the Thread
	//

	if(hRasNotifyEvt)
	{
		CloseHandle(hRasNotifyEvt); // CLose The Event Object
	}

	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n Before  Exiting RAS Dial Thread " << flush;
	#endif

    return TRUE;
}

VOID  RasDialFunc( UINT unMsg, RASCONNSTATE rasconnstate, DWORD dwError )
{

    _TCHAR szMessage[256];
	
	DWORD dwRet = WaitForSingleObject(hRasKillEvt,3);
	// We Were killed Hangup
	if(dwRet ==  WAIT_OBJECT_0)
	{
		if(hRasConn != NULL)
		{
			ATK_RasHangUp( hRasConn );
			RW_DEBUG << "Hanging up in RasDialFunc" << endl;
		}
		else
		{
			RW_DEBUG << "Tried Hanging up in RasDialFunc but hRasConn is NULL" << endl;
		}

		if(hRasKillEvt)
		{
			CloseHandle(hRasKillEvt); // CLose The Event Object
		}
		return;
	}

    LoadString(m_hInstance, GetRasConnState( (RASCONNSTATE) rasconnstate), szMessage, 64 );
	//SetWindowText(m_hDlg,(LPCTSTR) szMessage);
	RW_DEBUG  << "\n" << ConvertToANSIString(szMessage) << flush;
    SetDlgItemText( m_hWnd, ID_LABELINIT, (LPCTSTR) szMessage );
	
    if (dwError)  // error occurred


    {
        if ( ATK_RasGetErrorString( (UINT)dwError, szMessage, 256 ) != 0 )
            wsprintf( (LPTSTR)szMessage, _T("Undefined RAS Dial Error.") );

        RW_DEBUG  << "\n Exiting with Error " << ConvertToANSIString(szMessage);
		
		if( dwError == ERROR_USER_DISCONNECTION )
			return;
		dwRasError  = dwError; // Set The Error


        //PostMessage( m_hDlg, WM_COMMAND, (WPARAM) IDD_DIALUP_ERROR, dwError );

    }
    else if ( RASCS_DONE & rasconnstate)
    {
		RW_DEBUG  << "\n" << " RACS_DONE .... " ;
		
        //EndDialog(m_hDlg, TRUE);          // Exit the dialog
    }
    siPreviousRasState = siCurrentRasState ;
	siCurrentRasState  = rasconnstate;
	if( hRasNotifyEvt) {
		// Set The Event So the RAS Processing Thread can wake up
		SetEvent(hRasNotifyEvt);
	}
	

    return ;

}


BOOL DialupHelperClass :: WaitForRasThread(
					HANDLE	hThread,
					BOOL fTimeOut
					)
{
	BOOL 	fRet = TRUE;

	if (hThread){
		DWORD dwRet=WAIT_TIMEOUT;
		if (WAIT_TIMEOUT == dwRet){
			TerminateThread(hThread,0);
			fRet = FALSE;
		}
	}
	return fRet;
}





INT_PTR CALLBACK DialupScreenProc(HWND hwndDlg,
					  UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Main entry point for the Registration Wizard.
**********************************************************************/
{
	CRegWizard*    pclRegWizard = NULL;
	DialupHelperClass  *pDH;
	int    iMsgId;
	static int iRetry =0;
	static BOOL bIsPhoneBookCreated = TRUE;
	static int    iModemIndex=1; // Index of the Modem
	INT_PTR iRet;
	_TCHAR szInfo[256];
	_TCHAR szMessage[256];	

	
	BOOL bStatus = TRUE;
	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
		pDH          = pi->pDialupHelper;
	};

    switch (uMsg)
    {
				
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				
        case WM_INITDIALOG:
		{
			_TCHAR szInfo[256];
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			
			if(pi->pDialupHelper ==  NULL ) {
					pi->pDialupHelper = new DialupHelperClass(pi->hInstance,
										hwndDlg);
			}
			pDH   = pi->pDialupHelper;



			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);

			//UpgradeDlg(hwndDlg);
			
			NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
			NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			ReplaceDialogText(hwndDlg,ID_LABELCALLONE,szInfo);
			SetDlgItemText( hwndDlg, IDC_PHONENUMBER, _TEXT("1 800 795 5675"));
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());
			FEnableControl(hwndDlg,IDC_DISCONNECT,FALSE);
			return TRUE;
		}// WM_INIT
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				

				pi->ErrorPage  = kDialupDialog;
				pi->iError     = RWZ_NOERROR;
				
				bPostSuccessful = TRUE;
				//
				// Check if RAS is installed
				if( ATK_IsRasDllOk() != RAS_DLL_LOADED ) {
				//
				// Error as no RAS DLL
					pi->iError     = RWZ_ERROR_RASDLL_NOTFOUND;
					bPostSuccessful = FALSE;
				
				}else
				{
				// Check if Telephoney is configured
					pDH->CheckForDialingProperties( );
					if(!ConfigureDUN(hwndDlg,
						pi->hInstance,
						&theRasEntry,
						szIspUserName,szIspUserPassword,
						iModemIndex) )
					{
						pi->iError  = RWZ_ERROR_LOCATING_DUN_FILES;
						bPostSuccessful = FALSE;
						#ifdef _LOG_IN_FILE
							RW_DEBUG  << "\n ConfigureDUN PostUnSuccessful" << flush;
						#endif

					}
					else
					{
						
						#ifdef _LOG_IN_FILE
							RW_DEBUG  << "\n ConfigureDUN Successful" << flush;
						#endif
					}
				}
				
				 iRetry = 1;
				//  Check for Errors
				if(pi->iError) {
					pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
				}else {
					bIsPhoneBookCreated = TRUE;	
					pDH->DisplayPhoneNumber();
					//PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK PSWIZB_NEXT );
					pi->iCancelledByUser = RWZ_PAGE_OK;
					PropSheet_SetWizButtons( GetParent( hwndDlg ), 0);
				}
            break;

			case PSN_KILLACTIVE :
				if(pi->pDialupHelper) {
					delete pi->pDialupHelper;
					
				}
				pi->pDialupHelper = NULL;
			break;

            case PSN_WIZNEXT:
				iRet=0;
									//
				// Delete any RAS Connection

				pDH->DestroyRasThread(FALSE);

				ATK_RasDeleteEntry(NULL,MSN_SITE_DUN);

				if(pi->iCancelledByUser  == RWZ_CANCELLED_BY_USER  ||
					pi->iCancelledByUser == RWZ_ABORT_TOFINISH)
				{
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
				}else {
					pi->CurrentPage++;	
				}
			
				break;

            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kDialupDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					bPostSuccessful = FALSE;

					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (LONG_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);


				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        }
        break;
		case WM_COMMAND:
			switch (LOWORD(wParam)){
			case IDDIAL :
					 RW_DEBUG  << "\n IN IDDIAL ....." << flush;
					//
					//

					if(!bIsPhoneBookCreated){
						// Go To the Next Modem
						iModemIndex ++;
						iRetry = 1;
						if(!ConfigureDUN(hwndDlg,
							pi->hInstance,
							&theRasEntry,
							szIspUserName,szIspUserPassword,
							iModemIndex) )
						{
								pi->iError  = RWZ_ERROR_MODEM_CFG_ERROR;
								pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
								bPostSuccessful = FALSE;
								#ifdef _LOG_IN_FILE
									RW_DEBUG  << "\n ConfigureDUN PostUnSuccessful" << flush;
								#endif
								goto PrepareForExit;							
						}
						else
						{
							#ifdef _LOG_IN_FILE
								RW_DEBUG  << "\n ConfigureDUN Successful" << flush;
								RW_DEBUG  << "\n Phone number:" <<ConvertToANSIString(theRasEntry.szAreaCode)<<ConvertToANSIString(theRasEntry.szLocalPhoneNumber)<< flush;
							#endif
						}

						
						pDH->DisplayPhoneNumber();
#ifdef _DISPLAY_MODEM_NAME
						SetDlgItemText( m_hDlg, IDC_MODEM_NAME, (LPCTSTR) theRasEntry.szDeviceName );
#endif
					}
					bIsPhoneBookCreated = TRUE;
					FEnableControl(hwndDlg,IDDIAL,FALSE);
					FEnableControl(hwndDlg,IDC_DISCONNECT,TRUE);
					//FEnableControl(hwndDlg,ID_BTNSETTINGS,FALSE);
					pi->ErrorPage  = kDialupDialog;
					pi->iError     =  0; // Dialup Errors
					bPostSuccessful = TRUE;

					if (pDH->CreateRasDialThread() == DIALFAILED ){
						pi->iError = RWZ_ERROR_SYSTEMERROR;
						bPostSuccessful = FALSE;
						goto  PrepareForExit;
							
					}
					goto CoolExit;
		 	 	
PrepareForExit :
					pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

CoolExit:			
                FEnableControl(hwndDlg,IDC_DISCONNECT,TRUE);

				break;
			case  IDC_DISCONNECT:
				FEnableControl(hwndDlg,IDC_DISCONNECT,FALSE);
				
				SetDlgItemText(hwndDlg, ID_LABELINIT, (LPCTSTR) _T("Disconnecting device"));
				
				SetEvent(hRasKillEvt);

				pDH->DestroyRasThread(FALSE);
				Sleep(1000);
				// Retry
				pDH->DestroyRasThread(TRUE);
				Sleep(3000);
				
				//RW_DEBUG  << "RasConnection: " << hRasConn <<endl;

				hRasConn = NULL;
				FEnableControl(hwndDlg,IDDIAL,TRUE);
				SetDlgItemText(hwndDlg, ID_LABELINIT, (LPCTSTR) _T("  "));
				break;
			case IDEND: // This Message is sent Afetr Posting
					if (m_hThread){
						CloseHandle(m_hThread);
						m_hThread = NULL;
					}
					pi->iError = lParam;
					if(pi->iError == RWZ_POST_SUCCESS)
					{
						bPostSuccessful = TRUE;
						pi->iCancelledByUser = RWZ_PAGE_OK;
						RW_DEBUG  << "\n Post Successful" << flush;
					}
					else
					{
						bPostSuccessful = FALSE;
						pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
						RW_DEBUG  << "\n Post UNSuccessful" << flush;
					}
					
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
			break;

			case IDD_DIALUP_ERROR :
				iMsgId = IDS_MODEM_NODIALTONE;
				RW_DEBUG << "\n IN IDS_DIALUP_ERROR " << (ULONG)lParam << flush;
				switch( lParam ) {
					case ERROR_NO_DIALTONE :
						iMsgId = IDS_MODEM_NODIALTONE;
						goto CntPrcs;
					case ERROR_NO_ANSWER   :
					
						iMsgId = IDS_MODEM_NOANSWER;
						 goto CntPrcs;
	      	            case ERROR_PORT_OR_DEVICE : // 692
					case ERROR_HARDWARE_FAILURE :
					case ERROR_DISCONNECTION : // 628
					case ERROR_FROM_DEVICE  :  // 651 :
						iMsgId = IDS_HARDWARE_FAILURE;
CntPrcs :				pDH->DestroyRasThread(FALSE);
						pDH->DestroyRasThread(TRUE);
						if( iRetry > 3 ){
							 RW_DEBUG  << "\n Automatic  Switch ...." << flush;

							pDH->DestroyRasThread(FALSE);
							bIsPhoneBookCreated = FALSE;
							PostMessage( hwndDlg, WM_COMMAND, (WPARAM) IDDIAL,0 );
							goto LReturn;
						}
						
						if(iRetry++ > 0){
						
							LoadString(m_hInstance,iMsgId,szMessage,256);
							RegWizardMessageEx(m_hInstance,hwndDlg ,IDD_INVALID_DLG,szMessage);
							//MessageBox(m_hDlg,szMessage,szWindowsCaption,MB_OK|MB_ICONEXCLAMATION);
						}
						SetDlgItemText( m_hWnd, ID_LABELINIT, (LPCTSTR) _T("  "));
						FEnableControl(hwndDlg,IDDIAL,TRUE);		//ensure that these are enabled..
						FEnableControl(hwndDlg,IDC_DISCONNECT,FALSE);		
						//FEnableControl(hwndDlg,ID_BTNSETTINGS,TRUE);

						//PostMessage( m_hDlg, WM_COMMAND, (WPARAM) IDOK,0 );
						break;
					case ERROR_LINE_BUSY :
						
						pi->iError = RWZ_ERROR_NO_ANSWER;
						pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
						bPostSuccessful = FALSE;
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
						break;
					case ERROR_PORT_NOT_AVAILABLE:
					case ERROR_DEVICE_NOT_READY :
					default :

						RW_DEBUG << "\n RAS ERROR PORT NOT AVAILABLE " << flush;
						pi->iError = RWZ_ERROR_MODEM_CFG_ERROR;
						pi->iCancelledByUser = RWZ_ABORT_TOFINISH;
						bPostSuccessful = FALSE;
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
						break;

					}

					break;


			}
		break;
		// WM_COMMAND
        default:
			bStatus = FALSE;
            break;
    }
LReturn :
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\cbitmap.cpp ===
/*********************************************************************
Registration Wizard
Class: CBitmap

--- This class subclasses a Window control to create a control that
displays a bitmap

11/16/94 - Tracy Ferrier
04/15/97 - Modified to take care of crashing in Memphis as the default destoy was not handled 
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <stdio.h>
#include "cbitmap.h"
#include "Resource.h"
#include "assert.h"

static HBITMAP BitmapFromDib (
    LPVOID         pDIB,
    HPALETTE   hpal, WORD wPalSize);


LRESULT PASCAL BitmapWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

CBitmap::CBitmap(HINSTANCE hInstance, HWND hwndDlg,int idDlgCtl, int idBitmap)
/*********************************************************************
Constructor for our CBitmap class.  
**********************************************************************/
{
	m_hInstance = hInstance;
	m_nIdBitmap = idBitmap;
	m_hPal = NULL;
	m_hBitmap =  GetBmp(); //LoadBitmap(hInstance,MAKEINTRESOURCE(m_nIdBitmap));
	assert(m_hBitmap != NULL);

	HWND hwndCtl = GetDlgItem(hwndDlg,idDlgCtl);
	m_lpfnOrigWndProc = (FARPROC) GetWindowLongPtr(hwndCtl,GWLP_WNDPROC);
	assert(m_lpfnOrigWndProc != NULL);
	m_isActivePal = TRUE;
	SetWindowLongPtr(hwndCtl,GWLP_WNDPROC,(LONG_PTR) BitmapWndProc);
	SetWindowLongPtr(hwndCtl,GWLP_USERDATA,(LONG_PTR) this);
}


CBitmap::~CBitmap()
/*********************************************************************
Destructor for our CBitmap class
**********************************************************************/
{

	
	if (m_hBitmap) 
		DeleteObject(m_hBitmap);
	if( m_hPal ) 
		DeleteObject(m_hPal);

}

/* *****************************************************************
Create a 256 Color Bitmap
********************************************************************/

HBITMAP CBitmap::GetBmp()
{
       RECT rect;
       HDC  hDC;
       BOOL bRet;
 
       // detect this display is 256 colors or not
       hDC = GetDC(NULL);
       bRet = (GetDeviceCaps(hDC, BITSPIXEL) != 8);
       ReleaseDC(NULL, hDC);
       if (bRet) 
	   {                             
		   // the display is not 256 colors, let Windows handle it
          return LoadBitmap(m_hInstance,MAKEINTRESOURCE(m_nIdBitmap));
       }
 

       LPBITMAPINFO lpBmpInfo;               // bitmap informaiton
       int i;
       HRSRC hRsrc;
	   HANDLE hDib;
	   HBITMAP hBMP;
	   HPALETTE hPal;
       struct {
			   WORD            palVersion;
		       WORD            palNumEntries;
			   PALETTEENTRY    PalEntry[256];
	   } MyPal;
               
       hRsrc = FindResource(m_hInstance, MAKEINTRESOURCE(m_nIdBitmap),RT_BITMAP);
       if (!hRsrc)
         return NULL;
 
       hDib = LoadResource(m_hInstance, hRsrc);
       if (!hDib)
         return NULL;
 
       if (!(lpBmpInfo = (LPBITMAPINFO) LockResource(hDib)))
               return NULL;
                               
       MyPal.palVersion = 0x300;
       MyPal.palNumEntries = 1 << lpBmpInfo->bmiHeader.biBitCount;
 
       for (i = 0; i < MyPal.palNumEntries; i++) 
	   {
         MyPal.PalEntry[i].peRed   = lpBmpInfo->bmiColors[i].rgbRed;
         MyPal.PalEntry[i].peGreen = lpBmpInfo->bmiColors[i].rgbGreen;
         MyPal.PalEntry[i].peBlue  = lpBmpInfo->bmiColors[i].rgbBlue;
         MyPal.PalEntry[i].peFlags = 0;
       }
       m_hPal = CreatePalette((LPLOGPALETTE)&MyPal);

       if (m_hPal == NULL) 
	   {        // create palette fail, let window handle the bitmap
          return LoadBitmap(m_hInstance,MAKEINTRESOURCE(m_nIdBitmap));          
       }
       
       hBMP = BitmapFromDib(hDib,m_hPal,MyPal.palNumEntries);
       UnlockResource(hDib);
	   if( hBMP == NULL ) {
		   DeleteObject(m_hPal);
		   m_hPal = NULL;
		   hBMP = LoadBitmap(m_hInstance,MAKEINTRESOURCE(m_nIdBitmap));
       }
	   //DeleteObject(hPal);
	   return hBMP;
}


LRESULT PASCAL CBitmap::CtlWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	switch (message)
	{
		case WM_PAINT:
		{
			PAINTSTRUCT ps;
			HPALETTE hpalT;
			HDC hdc = BeginPaint(hwnd,&ps);
			HDC hMemDC = CreateCompatibleDC(hdc);
			SelectObject(hMemDC,m_hBitmap);
			RECT wndRect;
			GetClientRect(hwnd,&wndRect);
		    if (m_hPal){
				hpalT = SelectPalette(hdc,m_hPal,FALSE);
				RealizePalette(hdc);     
			}


			BitBlt(hdc,0,0,wndRect.right - wndRect.left,wndRect.bottom - wndRect.top,hMemDC,0,0,SRCCOPY);
			if( m_hPal ) 
				SelectPalette(hdc,hpalT,FALSE);

			DeleteDC(hMemDC);
			EndPaint(hwnd,&ps);
#ifdef _WIN95
			return CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#else
			return CallWindowProc((WNDPROC) m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#endif
			

			break;
		}
		case WM_QUERYNEWPALETTE :
				if(m_hPal && !m_isActivePal) 
					InvalidateRect(hwnd,NULL,FALSE);
				return 0;//CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);


		case WM_PALETTECHANGED :
			if( (HWND)wParam != hwnd ) {
				if(m_hPal ) {
					m_isActivePal = FALSE;
					InvalidateRect(hwnd,NULL,FALSE);
				}
			}
			else m_isActivePal = TRUE;
			return 0; //CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);

		case WM_DESTROY:
			SetWindowLongPtr(hwnd,GWLP_WNDPROC,(LONG_PTR) m_lpfnOrigWndProc);

		default:
#ifdef _WIN95
			return CallWindowProc(m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#else
			return CallWindowProc((WNDPROC) m_lpfnOrigWndProc,hwnd,message,wParam,lParam);
#endif

			

			break;
	}
	return 0;
}


LRESULT PASCAL BitmapWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
/*********************************************************************
**********************************************************************/
{
	CBitmap* pclBitMap = (CBitmap*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
	LRESULT lret;
		
	switch (message)
	{
		case WM_DESTROY:

			//return 
			lret = pclBitMap->CtlWndProc(hwnd,message,wParam,lParam);
			delete pclBitMap;
			return lret;
			// fall through
		default:
			lret = pclBitMap->CtlWndProc(hwnd,message,wParam,lParam);
			return lret ;
			break;
	}
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BitmapFromDib(LPVOID hdib, HPALETTE hpal, WORD palSize)                  *
 *                                                                          *
 *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global *
 *               handle to a memory block in CF_DIB format                  *
 *                                                                          *
 *  RETURNS    : A handle to the DDB.                                       *
 *                                                                          *
 ****************************************************************************/

static HBITMAP BitmapFromDib (
    LPVOID         pDIB,
    HPALETTE   hpal, WORD wPalSize)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hpalT;
    HDC                 hdc;
    HBITMAP             hbm;

   

    if (!pDIB || wPalSize == 16 )
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)pDIB; // lock resource


    hdc = GetDC(NULL);

    if (hpal){
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);     
    }

    hbm = CreateDIBitmap(hdc,
                (LPBITMAPINFOHEADER)lpbi,
                (LONG)CBM_INIT,
                (LPSTR)lpbi + lpbi->biSize + wPalSize*sizeof(PALETTEENTRY),
                (LPBITMAPINFO)lpbi,
                DIB_RGB_COLORS );

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    ReleaseDC(NULL,hdc);

    return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\failscr.cpp ===
/*
	File : FAILSCR.CPP
	The final screen of Registration Wizard using Wizard 97 control
	This screen displays the staus of the Online registration
	Date : 02/12/98  Suresh Krishnan

  Modification History:
  08/20/98 :
  FormRegWizErrorMsgString() is added to form Error string
*/



#include <Windows.h>
#include "RegWizMain.h"
#include "Resource.h"
#include <RegPage.h>
#include "Dialogs.h"
#include "regutil.h"
#include <rw_common.h>
#include <commctrl.h>

static   TCHAR  szClosingMsg[2048]=_T("");
extern BOOL RW_EnableWizControl(HWND hDlg,int	 idControl,	BOOL fEnable);

void FormRegWizErrorMsgString(TCHAR *czDest,HINSTANCE hIns,UINT iS1)
{
	_TCHAR szText2[1024];
	//LoadString(hIns,IDS_FINAL_UNSUCCESS_PREFIX,czDest,1024);
	LoadString(hIns,iS1,szText2,1024);
	_tcscat(czDest,szText2);
	//LoadString(hIns,IDS_FINAL_UNSUCCESS_SUFFIX,szText2,1024);
	//_tcscat(czDest,szText2);

}

/********************************************************************************

   AddErrorToList
   This function adds the error in the list view

******************************************************************************/

BOOL AddErrorToList( HWND hwndList, HINSTANCE hInstance,TCHAR *szErrorMsg)
{
	LV_ITEM     lvItem;
	int         i,
		        nIndex,
			    nImageCount;
				

	HIMAGELIST  himl;
	IMAGEINFO   ii;
	
	SendMessage(hwndList, LVM_DELETEALLITEMS, 0, 0);

	lvItem.mask = LVIF_TEXT;
	lvItem.pszText = szErrorMsg;
	lvItem.iItem = (int)SendMessage(hwndList, LVM_GETITEMCOUNT, 0, 0);
	lvItem.iSubItem = 0;
	nIndex = (int)SendMessage(hwndList, LVM_INSERTITEM, (WPARAM)0, (LPARAM)&lvItem);

	SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
	UpdateWindow(hwndList);
	return TRUE;
}

INT CALLBACK FinalFailedScreenDialogProc(HWND hwndDlg,
					   UINT uMsg,
					   WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that presents the
Product Identification number to the user.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	int iRet;
	_TCHAR szInfo[256];
    BOOL bStatus;
 	 HKEY  hKey;
	_TCHAR szText1[2048];
	_TCHAR szText2[1024];
	_TCHAR szRegDone[10]= _T("1");
	_TCHAR uszRegKey[128];
	short resSize;
	PTBYTE lpbData;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {
		case WM_CLOSE:
			break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				

        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;

			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDC_TEXT1);
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDC_LIST1);
			
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			RW_DEBUG << "\n In Final Screen ["  << (INT)pi->iError << flush;
			ReplaceDialogText(hwndDlg, IDT_TEXT1,szInfo);
			ReplaceDialogText(hwndDlg, IDC_TEXT3,szInfo);
			
			//  pi->iError = RWZ_POST_FAILURE ;
			switch(pi->iError)
			{
				case RWZ_POST_SUCCESS :
					{
						SendDlgItemMessage(hwndDlg,IDC_TEXT1,WM_SETTEXT,0,(LPARAM) _T("You have successfully completed the registration wizard."));
						ShowWindow(GetDlgItem(hwndDlg,IDC_LIST1),SW_HIDE);
					}
				break;
				case RWZ_ERROR_NOTCPIP :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_NOTCP1_MSG);

					//_stprintf(szClosingMsg,szText1,szInfo);
				break;
				case CONNECTION_CANNOT_BE_ESTABLISHED:
					//
					// Modem  not found
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_MODEMCFG_MSG1);
					
				break;
				case RWZ_ERROR_NO_ANSWER: // Site Busy Try Later Modem Error
				case RWZ_POST_FAILURE :
				case RWZ_POST_MSN_SITE_BUSY:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_SITEBUSY_MSG);
				break;

				case RWZ_ERROR_TXFER_CANCELLED_BY_USER:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_CANCEL_MSG);
					
					break;

				case RWZ_ERROR_REGISTERLATER :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),
						IDS_FINAL_REGISTERLATER_MSG);
				break;
				case RWZ_ERROR_RASDLL_NOTFOUND :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_RASCFG_MSG);

				break;					
				case RWZ_ERROR_MODEM_IN_USE: // Can not Dial as another app is using the COM port
				case RWZ_ERROR_MODEM_CFG_ERROR:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),
						IDS_FINAL_MODEMINUSE_MSG);
				break;
				case RWZ_ERROR_LOCATING_DUN_FILES:
					LoadString(pclRegWizard->GetInstance(),IDS_FINAL_UNSUCCESS_PREFIX,
						szClosingMsg,1024);
					LoadString(pclRegWizard->GetInstance(),IDS_FINAL_SYSTEMERROR_MSG,
							szText2,1024);
					_tcscat(szClosingMsg,szText2);
				default : // System Error ...
				break;

			}

			if(pi->iError != RWZ_NOERROR)
			{
				TCHAR  szTmp[2048];
				_stprintf(szTmp,szClosingMsg,szInfo);
				AddErrorToList(GetDlgItem(hwndDlg,IDC_LIST1),pclRegWizard->GetInstance(),szTmp);
			}

			return TRUE;
		}
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_FINISH );
				RW_EnableWizControl(hwndDlg,RWZ_WIZ97_CANCEL_ID,FALSE);
				break;

            case PSN_WIZNEXT:
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					pi->CurrentPage++;
				}
				break;

            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (LONG_PTR) iRet);
				break;
				default:
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
        default:
		bStatus = FALSE;
         break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\fe_util.cpp ===
/*
	FE_UTIL.CPP
	FareEastCountries heper functions
	Author : Suresh Krishnan
	Date   :03/02/98

*/

#include <fe_util.h>
#include <tchar.h>
#include <windows.h>
#include <winnls.h>
#include <rw_common.h>
#include <resource.h>


FeCountriesIndex gWhatFECountry    = kNotInitialised;
FeScreenType     gWhichFEScreenTye =kFEWithNonJapaneaseScreen;



typedef struct {
	int m_iMaxCountries;
	int m_iCountryCode[MAX_FE_COUNTRIES_SUPPORTED];
	FeScreenType m_iScreenType[MAX_FE_COUNTRIES_SUPPORTED];
}FEInfoTable;

static FEInfoTable     sFETable;




void GetFECountryListFromResource(HINSTANCE hIns )
{
	sFETable.m_iMaxCountries=0;
	int iCount =0;
	int iTokLen;
	int iResLen;
	_TCHAR	seps[] = _T(",");
	_TCHAR *pDummy;

	LPTSTR	token;
	TCHAR 	buf[80];
    TCHAR   tcSrc[512];
	iResLen = LoadString(hIns,IDS_FECOUNTRY_LIST,tcSrc,512);
	token = _tcstok( tcSrc, seps );
    sFETable.m_iMaxCountries = 0;
//	token = _tcstok( NULL, seps );
	while( token != NULL ) {
		
		_tcscpy(buf,token);
		iTokLen= _tcslen(token);
		if( iTokLen < 3) {
			goto  FinishScan; // Error in string format so skip
		}
		sFETable.m_iMaxCountries = iCount+1;
		// Get What Type of screen to use
		if( token[iTokLen-1] == _T('1')) {
			sFETable.m_iScreenType[iCount]=kFEWithJapaneaseScreen;
		}else{
			sFETable.m_iScreenType[iCount]=kFEWithNonJapaneaseScreen;
		}
		//Get the Country Code
		//buf[iTokLen-2] = _T('\0');
		sFETable.m_iCountryCode[iCount]= _tcstol(buf,&pDummy,16);
		
		iCount++;
		if(iCount >= MAX_FE_COUNTRIES_SUPPORTED ) {
			goto FinishScan;
			// Presently our Table supports 256  entries

		}
		/* Get next token: */
		token = _tcstok( NULL, seps );

   }

   FinishScan :
   RW_DEBUG  << "\n Total FE Countries Cfg " << sFETable.m_iMaxCountries;
   for(int ij=0;ij<sFETable.m_iMaxCountries;ij++) {
	   RW_DEBUG  <<"\nCountry " << sFETable.m_iCountryCode[ij] << " ScreenType" << sFETable.m_iScreenType[ij] << flush;
   }

}

//
//  This function checks if the dwCurCountry has an entry in the FE Table
//  if so it pFeType as FE country and gives the corrosponding screen type
//  in pFeScrType
//
DWORD MapCountryLcidWithFETable(DWORD dwCurCountry,
						  FeCountriesIndex *pFeType,
						  FeScreenType      *pFeScrType
						  )
{
	DWORD dwReturn;
	int iIndex;
	dwReturn = 0;
	for(iIndex = 0; iIndex < sFETable.m_iMaxCountries;iIndex++) {
		if( (DWORD)sFETable.m_iCountryCode[iIndex] == dwCurCountry ) {
			// It matches in the FE list
			*pFeType  = kFarEastCountry;
			*pFeScrType =sFETable.m_iScreenType[iIndex];
			return dwReturn;

		}

	}
	return dwReturn;

}


//
//	This fucntion gets the current LCID of the system
//  uisng GetSystemDefaultLCID().
//
//
FeCountriesIndex IsFarEastCountry(HINSTANCE hIns)
{
	LCID  lcRet;
	int   RegSettings;
	if( gWhatFECountry == kNotInitialised ) {
		GetFECountryListFromResource(hIns);
		lcRet = GetSystemDefaultLCID();

		RW_DEBUG << "\n GetSystemLCID Returns :"<< lcRet << flush;	
		gWhatFECountry = kNotAFECountry;
		MapCountryLcidWithFETable(lcRet, &gWhatFECountry,
			&gWhichFEScreenTye);
	}else {
		
		;
	}
	return gWhatFECountry;
}

FeScreenType  GetFeScreenType()
{
	return gWhichFEScreenTye;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\cntryinf.cpp ===
/*********************************************************************
Registration Wizard

CNTRYINF.CPP
This file houses a set of function that use TAPI to access country
code/name information.

11/15/94 - Tracy Ferrier
05/08/97 - Suresh Krishnan
	Modified Country inforamtion retrival  using classes
	The class CCntryInfo  will get  the information of the country list using
	TAPI API.
	And it has methiods GetCountryCode() and GetCountryName() to Accessit.
	Also A Combo List can be generated using the
2/3/98   - Suresh Krishnan
	Added GetCountryCodeUsingTapiId() ;
	This uses RAS API to get the country ID
	
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include <rw_common.h>
#include "cntryinf.h"
#include <ATK_RAS.H>

//#define COMPILE_USING_VC   Enable this if U are compiling for UNICODE using VISULA c++ 5.0 compiler


static DWORD dwAPILowVersion = 0 << 16;
static DWORD dwAPIHighVersion = 3 << 16;

BOOL FGetLocationEntry(HLINEAPP hLineApp, DWORD dwAPI,LINELOCATIONENTRY *pLE);
BOOL FGetLineCountryList(LINECOUNTRYLIST **ppcl);
void CALLBACK CountryLineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);
BOOL PrepareCountryListFromTapi ( HINSTANCE hInstance,
								  LINECOUNTRYLIST	**pcl);

CCntryInfo  gTapiCountryTable; // Gloabal variable for buildind and maintaininf TAPI cntry info.

#define INVALID_PORTID (DWORD) -1
#ifndef _TAPI
#define _TAPI
#endif
BOOL GetTapiCurrentCountry(HINSTANCE hInstance,DWORD* dwpCountry)
/*********************************************************************
Returns the current code of the user's location, as determined by
Tapi.
**********************************************************************/
{
	#ifdef _TAPI
	DWORD				dwAPI;
	LINELOCATIONENTRY	LE;
	BOOL				fDefCountry;
	HLINEAPP 			hLineApp;
	DWORD 				numDevs;
	LONG tapiStatus = lineInitialize(&hLineApp, hInstance,
		(LINECALLBACK) CountryLineCallback, NULL, &numDevs);
	if (tapiStatus != 0)
	{
		char szMessage[256];
		sprintf(szMessage,"lineInitialize call failed: error = %li",tapiStatus);
		RW_DEBUG << szMessage << "\n"<< flush;
		//MessageBox(NULL,szMessage,_T("TAPI STATUS"),MB_OK);
		return FALSE;
	}
#ifdef SURESH
	DWORD dwAPILowVersion = 1 << 16;
	DWORD dwAPIHighVersion = 4 << 16;
#endif
	
	LINEEXTENSIONID extensionID;
	tapiStatus = lineNegotiateAPIVersion(hLineApp,0,dwAPILowVersion, dwAPIHighVersion,&dwAPI,&extensionID);

//	RW_DEBUG << "Api Version : " << dwAPI << flush;

	 //this gets the currently selected TAPI country
	//fDefCountry = FGetLocationEntry(hLineApp, dwAPI, &LE);
	fDefCountry = FGetLocationEntry(hLineApp, 0x30000, &LE);
	//if (LE.dwCountryID == kCountryCodeNorthAmerica)
	//{
	//	LE.dwCountryID = kCountryCodeUnitedStates;
	//}
	if(fDefCountry) {
		*dwpCountry = LE.dwCountryID;
	}else {
		*dwpCountry = 1; // Default To USA

	}
	lineShutdown(hLineApp);

	#endif	//_TAPI

	return (fDefCountry);
} // FFillCountryList()

//
//
//  Returns 0 if successful
//
//
DWORD GetCountryCodeUsingTapiId(DWORD dwCountryId, DWORD *dwCountryCode)
{
	DWORD dwRet;
	dwRet = 0;
	struct XXForRasCntry{
		RASCTRYINFO    rci;
		TCHAR          czB[256] ; // To Store the Country Name
		
	} Rc;
	DWORD dwSz;
	*dwCountryCode = 1; // Default Value

	// Init the Sizes of Data Struct and Buffer
	Rc.rci.dwSize = sizeof(Rc.rci );
	dwSz = sizeof(Rc);

	Rc.rci.dwCountryID = dwCountryId;
	ATK_RasGetCountryInfo((RASCTRYINFO *)&Rc,&dwSz);
	*dwCountryCode = Rc.rci.dwCountryCode;
	return  dwRet;

}

BOOL FGetLocationEntry(HLINEAPP hLineApp, DWORD dwAPI,LINELOCATIONENTRY *pLE)
 /***************************************************************************
 Allocate memory for and fetch a line country list (LINECOUNTRYLIST) from
TAPI
****************************************************************************/
{
	BOOL fRet = FALSE;

	#ifdef _TAPI
	DWORD dwRet, iLoc;
	LINETRANSLATECAPS ltc, *pltc;
	LPLINELOCATIONENTRY plle;

    if (pLE == NULL) return (fRet);

    ltc.dwTotalSize = sizeof(LINETRANSLATECAPS);
    dwRet = lineGetTranslateCaps(hLineApp, dwAPI, &ltc);
    pltc = (LINETRANSLATECAPS*) LocalAlloc(LPTR, ltc.dwNeededSize+100);
    if (!pltc) return (fRet);

    pltc->dwTotalSize = ltc.dwNeededSize;
    dwRet = lineGetTranslateCaps(hLineApp, dwAPI, pltc);
    plle = (LPLINELOCATIONENTRY) (((LONG_PTR) pltc) + pltc->dwLocationListOffset);
    for (iLoc = 0; iLoc < pltc->dwNumLocations; iLoc ++)
    {
        if (pltc->dwCurrentLocationID == plle->dwPermanentLocationID)
        {
            *pLE = *plle;
            fRet = TRUE;
            break;
        }
        plle ++;
   }

    LocalFree(pltc);
	#endif
    return (fRet);
} // FGetLocationEntry()




void CALLBACK CountryLineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1,
								  DWORD dwParam2, DWORD dwParam3)
{
;

}


BOOL PrepareCountryListFromTapi(HINSTANCE hInstance,
					  LINECOUNTRYLIST		**pcl )
{
	
	DWORD				dwAPI;
	HLINEAPP hLineApp;
	DWORD numDevs;

	LINECOUNTRYLIST cl;
	


	BOOL fRet = FALSE;

	LONG tapiStatus = lineInitialize(&hLineApp,
		hInstance, (LINECALLBACK) CountryLineCallback,
		NULL, &numDevs);
	if (tapiStatus != 0)
	{
		CHAR szMessage[256];
		sprintf(szMessage,"lineInitialize call failed: error = %li",tapiStatus);
		RW_DEBUG << szMessage <<"\n"<< flush;
		return FALSE;
	}

	
	LINEEXTENSIONID extensionID;
	tapiStatus = lineNegotiateAPIVersion(hLineApp,0,dwAPILowVersion, dwAPIHighVersion,&dwAPI,&extensionID);
	
	*pcl = NULL;
	cl.dwTotalSize = sizeof(LINECOUNTRYLIST);
	// find size needed for list
	if (0 != lineGetCountry(0, 0x10003, &cl)){
	 	goto EndFn;
	}
	*pcl = (LINECOUNTRYLIST *) LocalAlloc(LPTR, cl.dwNeededSize + 100 );
	if (NULL == *pcl){
		goto EndFn;
	}

	(*pcl)->dwTotalSize = cl.dwNeededSize + 100;
	if (0 != lineGetCountry(0, 0x10003, *pcl))
	{
		goto EndFn;
	}
	

EndFn:
	lineShutdown(hLineApp);
	return (fRet);
}




//
//
//
//
//

CCntryInfo :: CCntryInfo()
{
	HINSTANCE hIns= NULL;;

#ifdef _TAPI
	m_pCountry= NULL;
	PrepareCountryListFromTapi(hIns,
					 &m_pCountry);
#endif

		
}

CCntryInfo :: ~CCntryInfo()
{
#ifdef _TAPI
	if(m_pCountry) {
		LocalFree(m_pCountry);
	}
#endif
}

int CCntryInfo :: GetCountryCode( _TCHAR * czCountryName)
{
	
#ifdef _TAPI
	LINECOUNTRYENTRY	*plce;
	_TCHAR *			pTsz;
	PSTR                psz;
	DWORD				iCountry;

#ifdef COMPILE_USING_VC
	return 1;
#endif


	int iRet = -1;
	
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	for (iCountry = 0; iCountry < m_pCountry->dwNumCountries; ++iCountry)
	{
		psz = ((PSTR) m_pCountry ) + plce->dwCountryNameOffset;
		pTsz = (PTSTR) psz;
		//pTsz = ConvertToUnicode(psz);
		if(!_tcscmp(czCountryName,pTsz) ){
			return iCountry;
		}
		*plce ++;
	}
	return iRet;
#else
	return -1;
#endif
}

int CCntryInfo :: GetCountryCode( DWORD  dwTapiId)
{
	
#ifdef _TAPI
	LINECOUNTRYENTRY	*plce;
	_TCHAR *			pTsz;
	PSTR                psz;
	DWORD				iCountry;

#ifdef COMPILE_USING_VC
	return 1;
#endif


	int iRet = 0;
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	for (iCountry = 0; iCountry < m_pCountry->dwNumCountries; ++iCountry)
	{
		if( plce->dwCountryID  == dwTapiId){
				return iCountry;
		}
		*plce ++;
	}
	return iRet;
#else
	return -1;
#endif
}


_TCHAR * CCntryInfo :: GetCountryName(int iCode)
{
#ifdef _TAPI
	LINECOUNTRYENTRY	*plce;

	PSTR				psz;
	PTSTR                pTsz;
	int iRet = -1;

	if( iCode < 0 ){
		iCode = 0;
	}
	if ( iCode > (int)m_pCountry->dwNumCountries) {
		iCode = 0;
	}
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	psz = ((PSTR) m_pCountry ) + plce[iCode].dwCountryNameOffset;
	pTsz = (PTSTR) psz;
	//pTsz = ConvertToUnicode(psz);
	return pTsz;
#else
	return NULL;
#endif
}

int CCntryInfo :: GetTapiCountryCode(_TCHAR * czCountryName)
{
	LINECOUNTRYENTRY	*plce;
	PSTR				psz;
	_TCHAR *			pTsz;
	DWORD				iCountry;

	int iRet = 0;
	
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	for (iCountry = 0; iCountry < m_pCountry->dwNumCountries; ++iCountry)
	{
		psz = ((PSTR) m_pCountry ) + plce->dwCountryNameOffset;
		pTsz = (PTSTR) psz;
		//pTsz = ConvertToUnicode(psz);
		if(!_tcscmp(czCountryName,pTsz) ){
			return plce->dwCountryID;
		}
		
		*plce ++;
	}
	return iRet;
}
//
// Used for Field checking
int CCntryInfo::GetTapiIDForTheCountryIndex ( int iCode)
{
	return GetTapiCountryCode(GetCountryName(iCode));
}



//
//   Adds the country information in the ComboBox specified in hwndCB
//
//
//
void CCntryInfo :: FillCountryList(HINSTANCE hInstance,
								   HWND hwndCB)
{

#ifdef _TAPI
	LINECOUNTRYENTRY	*plce;
	PSTR				psz;
	PTSTR               pTsz;
	DWORD				iCountry;

	if(	hwndCB == NULL || m_pCountry == NULL ) {
		// if the country list or Combo control handle is Null
		return ;
	}
	int iRet = -1;
	
	plce = (LINECOUNTRYENTRY *)(((PBYTE) m_pCountry) + m_pCountry->dwCountryListOffset);
	for (iCountry = 0; iCountry < m_pCountry->dwNumCountries; ++iCountry)
	{
		psz = ((PSTR) m_pCountry ) + plce->dwCountryNameOffset;
		pTsz = (PTSTR) psz;
		LRESULT dwAddStatus = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM) pTsz);
/**
#ifdef COMPILE_USING_VC
		DWORD dwAddStatus = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM) psz);
#else
		pTsz= ConvertToUnicode(psz);
		DWORD dwAddStatus = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM) pTsz);
#endif
**/		

		if (dwAddStatus == CB_ERR){
			return;
		}
		*plce ++;
	}
#endif


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\cregwiz.cpp ===
/*********************************************************************
Registration Wizard
Class: CRegWizard

--- This class is responsible for accumulating information gathered
from the user by the Registration Wizard, and then writing it to the
Registration Database in preparation for transmission via modem.

11/3/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/
#include <Windows.h>
#include <stdio.h>
#include "cregwiz.h"
#include "resource.h"
#include "version.h"
#include "regutil.h"
#include "cntryinf.h"
#include "rwwin95.h"
#include "cntryinf.h"
#include "wininet.h"
#include "rw_common.h"

#define kRegBufferSize	260

CRegWizard::CRegWizard(HINSTANCE hInstance, LPTSTR szParamRegKey)
/*********************************************************************
Constructor for our Registration Wizard class.  The szParamRegKey
parameter should be a Registration Database key pointing to a block
of Reg Wizard input parameters.
**********************************************************************/
{

	m_hInstance = hInstance;
	_tcscpy(m_szParamRegKey,szParamRegKey);
	m_szInfoParentKey[0] = NULL;
	m_productNameCount = 0;
	m_searchCompleted = kTriStateFalse;
	m_systemInventoryCompleted = FALSE;
	m_lpfnProductSearch = NULL;
	m_countryCode= 0;  // CXZ   5/8/97   from NULL to 0
	m_dialogActive = FALSE;
	m_hwndStartDialog = NULL;
	m_hwndCurrDialog = NULL;
	m_wDialogExitButton = 0;
	m_szLogFilePath[0] = NULL;
	m_hLogFile = INVALID_HANDLE_VALUE;
	m_hwndDialogToHide = NULL;
	m_hwndPrevDialog = NULL;
	m_ccpLibrary	 = NULL;

	for (short index = 0;index < kInfoLastIndex;index++)
	{
		m_rgszInfoArray[index] = NULL;
		m_writeEnable[index] = TRUE;
	}

	// Since we want to perform a new product search each time, we'll delete any
	// existing product name keys.
	index = 0;
	_TCHAR szParentKey[255];
	_TCHAR szProductBase[64];
	LONG regStatus;
	HKEY hKey;
	GetInfoRegistrationParentKey(szParentKey);
	int resSize = LoadString(m_hInstance,IDS_PRODUCTBASEKEY,szProductBase,64);
	
	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szParentKey,NULL,KEY_ALL_ACCESS,&hKey);

	if (regStatus == ERROR_SUCCESS)
	{
		for (int x = 1;x <= kMaxProductCount;x++)
		{
			_TCHAR szProductValueName[256];
			_stprintf(szProductValueName,_T("%s %i"),szProductBase,x);
			regStatus = RegSetValueEx(hKey,szProductValueName,NULL,REG_SZ,(CONST BYTE*) _T(""),1);
		}
	}

	// Read any default information from the registry (if RegWizard
	// hasn't been run before, there will be no existing default info).
	ReadInfoFromRegistry();
	ResolveCurrentCountryCode();	

	// These four information strings we know implicitly,
	// so we'll set them now.
	_TCHAR szInfo[256];
	GetRegWizardVersionString(hInstance,szInfo);
	SetInformationString(kInfoVersion,szInfo);

	LoadString(hInstance,IDS_MAKERCOMPANY,szInfo,64);
	SetInformationString(kInfoMakerCompany,szInfo);

	SetInformationString(kInfoResultPath,m_szParamRegKey);

	GetDateFormat(LOCALE_SYSTEM_DEFAULT,0,NULL,_T("MM'/'dd'/'yyyy"),szInfo,256);
	SetInformationString(kInfoDate,szInfo);

	LANGID langID;
	GetSystemLanguageInfo(szInfo,256,&langID);
	wsprintf(szInfo,_T("%i"),langID);
	SetInformationString(kInfoLanguage,szInfo);

	// Build our tables specifying country-specific parameters
	// for all our edit fields.
	BuildAddrSpecTables();
    m_hAccel=LoadAccelerators(m_hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR));

}

CRegWizard::~CRegWizard()
/*********************************************************************
Destructor for our Registration Wizard class
**********************************************************************/
{

	if(m_addrJumpTable != NULL)
		GlobalFree( m_addrJumpTable );
	
	if(m_addrSpecTable != NULL)
		GlobalFree( m_addrSpecTable );
		
	for (short index = 0;index < kInfoLastIndex;index++)
	{

		if(m_rgszInfoArray[index] != NULL)
		{
			LocalFree(m_rgszInfoArray[index]);
			m_rgszInfoArray[index] = NULL;
		}
	}

	if (m_hLogFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hLogFile);
	}

	FreeLibrary(m_ccpLibrary);
}


void CRegWizard::StartRegWizardDialog(int wDlgResID, DLGPROC lpDialogProc)
/*********************************************************************
Given a dialog template resource ID (wDlgResID) and a pointer to a
DialogProc callback function, StartRegWizardDialog creates and
displays a dialog window.

Note: Creating our dialogs as modeless lets us keep the current dialog
displayed while the next dialog is initializing (which can take a
while for some RegWizard dialogs), and then immediately flip to the
next dialog.
**********************************************************************/
{
	if (m_hwndStartDialog == NULL)
	{
		m_hwndStartDialog = CreateDialogParam(m_hInstance,MAKEINTRESOURCE(wDlgResID),
			NULL,lpDialogProc, (LPARAM) this);
		m_dialogActive = TRUE;
		ActivateRegWizardDialog();
	}
}


void CRegWizard::ActivateRegWizardDialog( void )
/*********************************************************************
ActivateRegWizardDialog should be called after creating a RegWizard
dialog window.  This function will display the window, and will
then destroy the current dialog window (if any).
**********************************************************************/
{
	if (m_hwndStartDialog)
	{	
		HWND hW;
		RECT r;
		
		
		hW = m_hwndDialogToHide? m_hwndDialogToHide : m_hwndCurrDialog;
		if( hW )
		{
			GetWindowRect(hW, &r);
			SetWindowPos( m_hwndStartDialog, NULL, r.left, r.top,0,0,
												SWP_NOSIZE|SWP_NOZORDER);
		
		}
		
		
		ShowWindow(m_hwndStartDialog,SW_SHOW);
		
		if(m_hwndDialogToHide != NULL)
		{
			ShowWindow(m_hwndDialogToHide,SW_HIDE);
			m_hwndDialogToHide = NULL;
		}
		else
		{
			if(m_hwndCurrDialog != NULL)
				DestroyWindow(m_hwndCurrDialog);
		}
		m_hwndCurrDialog = m_hwndStartDialog;
		m_hwndStartDialog = NULL;
		HCURSOR hCursor = LoadCursor(NULL,IDC_ARROW);
		SetCursor(hCursor);
	}
}


void CRegWizard::SetPrevDialog(void)
{
	m_hwndPrevDialog = m_hwndCurrDialog;
}

INT_PTR CRegWizard::ProcessRegWizardDialog( void )
/*********************************************************************
After calling StartRegWizardDialog, ProcessRegWizardDialog should
next be called.  This function will retain control until the user
dismisses the current dialog.  The ID of the control used to
terminate the dialog will be returned as the function result.
**********************************************************************/
{
	if (m_hwndCurrDialog)
	{
		while (IsDialogActive())
		{
			MSG msg;
			GetMessage(&msg,NULL,0,0);
	        if (!TranslateAccelerator(m_hwndCurrDialog, m_hAccel, &msg))
		    {
				if (!IsDialogMessage(m_hwndCurrDialog,&msg))
				{
					TranslateMessage(&msg);
			        DispatchMessage(&msg);
				}
			}
		}
	}
	return GetDialogExitButton();
}



void CRegWizard::EndRegWizardDialog(INT_PTR wExitID)
/*********************************************************************
Should be called from within the DialogProc when the user wants to
dismiss the dialog.  The ID of the control used to terminate the
dialog should be passed as the wExitID parameter.
**********************************************************************/
{
	HCURSOR hCursor = LoadCursor(NULL,IDC_WAIT);
	SetCursor(hCursor);
	EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_EXIT),FALSE);
	if(wExitID == IDB_REG_LATER)
		EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_REG_LATER),FALSE);
	else
	if(wExitID == IDB_BACK)
		EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_BACK),FALSE);
	else
	{
		if(GetDlgItem(m_hwndCurrDialog,IDB_BACK) == NULL)
			EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_REG_LATER),FALSE);
		else
			EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_BACK),FALSE);
	}

	EnableWindow(GetDlgItem(m_hwndCurrDialog,IDB_NEXT),FALSE);
	m_wDialogExitButton = wExitID;
	m_dialogActive = FALSE;
}


BOOL CRegWizard::IsDialogActive( void )
/*********************************************************************
Returns TRUE if a RegWizard dialog is currently active (i.e. the
EndRegWizardDialog function has not been called by the active dialog's
DialogProc.
**********************************************************************/
{
	return m_dialogActive;
}


INT_PTR CRegWizard::GetDialogExitButton( void )
/*********************************************************************
Returns the ID of the control used to dismiss the current dialog.
**********************************************************************/
{
	return m_wDialogExitButton;
}

void CRegWizard::SetDialogExitButton( int nButton )
/*********************************************************************
Returns the ID of the control used to dismiss the current dialog.
**********************************************************************/
{
	m_wDialogExitButton = nButton;
}

TriState CRegWizard::GetProductSearchLibraryStatus( void )
/*********************************************************************
Returns:
- kTriStateTrue: the ProductSearch library is available and can be
	successfully loaded.
- kTriStateFalse: the ProductSearch library couldn't be found.
- kTriStateUndefined: product searching does not need to be performed.
**********************************************************************/
{
	FARPROC lpfnProductSearch;
	BOOL status = GetProductSearchProcAddress(&lpfnProductSearch);
	if (status == TRUE)
	{
		return lpfnProductSearch == NULL ? kTriStateUndefined : kTriStateTrue;
	}
	else
	{
		return kTriStateFalse;
	}
}


BOOL CRegWizard::GetProductSearchProcAddress(FARPROC* lpfnProductSearch)
/*********************************************************************
This function attempts to load the ProductSearch (CCP) library, and
if successful, returns the ProcAddress of the RegProductSearch
function.

Returns:
-- TRUE if the ProcAddress passed in lpfnProductSearch is valid,
OR if the input parameters to RegWizard specify that no product
searching is to be performed (in which case NULL will be returned in
the lpfnProductSearch parameter).

-- FALSE if the ProductSearch library could not be located, AND the
input parameters to the RegWizard specified that product searching is
to be performed.

Note: RegWizard determines whether product searching is to be
performed by looking at the InventoryPath "input parameter" registry
key.  If it is not present, or contains a blank value, then no
product searching is to be performed.
**********************************************************************/
{
	BOOL returnVal = FALSE;
	if (m_lpfnProductSearch)
	{
		*lpfnProductSearch = m_lpfnProductSearch;
		returnVal = TRUE;
	}
	else
	{
		*lpfnProductSearch = NULL;
		_TCHAR szLibName[kRegBufferSize];
		BOOL goodParam = GetInputParameterString(IDS_INPUT_INVENTORYPATH,szLibName);
		if (goodParam == FALSE || (goodParam == TRUE && szLibName[0] == NULL))
		{
			*lpfnProductSearch = NULL;
			returnVal = TRUE;
		}
		else
		{
			m_ccpLibrary = LoadLibrary(szLibName);
			if (m_ccpLibrary)
			{
				m_lpfnProductSearch = GetProcAddress(m_ccpLibrary,"RegProductSearch");
				if (m_lpfnProductSearch)
				{
					*lpfnProductSearch = m_lpfnProductSearch;
					returnVal = TRUE;
				}
			}
		}
	}
	return returnVal;
}



BOOL CRegWizard::GetInputParameterStatus( void )
/***************************************************************************
Returns TRUE only if the input parameter registrion key passed to the
CRegWizard constructor points to a valid key that contains a proper block of
input parameter subkeys.
****************************************************************************/
{
	BOOL returnVal = FALSE;
	_TCHAR szParam[kRegBufferSize];
	if (GetInputParameterString(IDS_INPUT_PRODUCTNAME,szParam))
	{
		if (GetInputParameterString(IDS_INPUT_PRODUCTID,szParam))
		{
			returnVal = TRUE;

			// 12/13/94: we will no longer consider a missing inventory
			// path key to be an error (it now means "don't do product
			// inventory").
			//if (GetInputParameterString(IDS_INPUT_INVENTORYPATH,szParam))
			//{
			//	returnVal = TRUE;
			//}
		}
	}
	return returnVal;
}



BOOL CRegWizard::GetInputParameterString(short paramID, LPTSTR szParam)
/***************************************************************************
This function retrieves an input parameter string.  The paramID parameter
must be the resource ID of the Registration Database key whose contents are
to be returned in the szParam parameter.

Allowable values for paramID:
- IDS_INPUT_PRODUCTNAME
- IDS_INPUT_PRODUCTID
- IDS_INPUT_INVENTORYPATH
- IDS_INPUT_ISREGISTERED

Returns:
- FALSE if the specified key cannot be found in the Registry.
****************************************************************************/
{
	BOOL returnVal = FALSE;
	_TCHAR szFullParamRegKey[300];
	_TCHAR szParamSubKey[64];
	LPTSTR szValueName;
	szParam[0] = NULL;
	_tcscpy(szFullParamRegKey,m_szParamRegKey);
	int resSize = LoadString(m_hInstance,paramID,szParamSubKey,63);
	#ifdef USE_INPUT_SUBKEYS
	{
		_tcscat(szFullParamRegKey,_T"\\");
		_tcscat(szFullParamRegKey,szParamSubKey);
		szValueName = NULL;
	}
	#else
	{
		szValueName = szParamSubKey;
	}
	#endif

	HKEY hKey;
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szFullParamRegKey,0,KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		unsigned long infoSize;
		infoSize = kRegBufferSize;
		regStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szParam,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			returnVal = TRUE;
		}
		RegCloseKey(hKey);
	}
	return returnVal;
}


BOOL CRegWizard::IsRegistered( void )
/***************************************************************************
This function returns TRUE if registration for the product specified by
the input parameters (via the Registration Database) has already been
performed.
****************************************************************************/
{
	_TCHAR szIsRegistered[kRegBufferSize];
	BOOL goodParam = GetInputParameterString(IDS_INPUT_ISREGISTERED,szIsRegistered);
	return goodParam == TRUE && szIsRegistered[0] == _T('1') ? TRUE : FALSE;

}


int CRegWizard::AddProduct(LPTSTR szProductName,LPTSTR szProductPath)
/***************************************************************************
This function adds the product whose name is given by the szProductName
parameter to the inventory of our user's installed products.

Returns: the new count of products on the list.
****************************************************************************/
{
	short strLenName = (_tcslen(szProductName)+1) * sizeof(_TCHAR);
	short strLenPath = (_tcslen(szProductPath)+1) * sizeof(_TCHAR);
	if (m_productNameCount < kMaxProductCount)
	{
		m_rgszProductName[m_productNameCount] = (LPTSTR) LocalAlloc(0,strLenName );
		_tcscpy(m_rgszProductName[m_productNameCount],szProductName);

		m_rgszProductPath[m_productNameCount] = (LPTSTR) LocalAlloc(0,strLenPath);
		_tcscpy(m_rgszProductPath[m_productNameCount],szProductPath);

		m_rghProductIcon[m_productNameCount] = NULL;
		m_productNameCount++;
	}
	return m_productNameCount;
}


void CRegWizard::GetProductName(LPTSTR szProductName,INT_PTR index)
/***************************************************************************
This function returns the product name whose index is given by the 'index'
parameter.  If index is greater than the number of products on the list, an
empty string will be returned.
****************************************************************************/
{
	szProductName[0] = NULL;
	if (index < m_productNameCount)
	{
		_tcscpy(szProductName, m_rgszProductName[index]);
	}
}

HICON CRegWizard::GetProductIcon(INT_PTR index)
/***************************************************************************
This function returns an icon for the product whose index is given by the
'index' parameter. If index is greater than the number of products on the
list, NULL will be returned.
****************************************************************************/
{
	if (index < m_productNameCount)
	{
		if (m_rghProductIcon[index] == NULL)
		{
			m_rghProductIcon[index] = ExtractIcon(m_hInstance,m_rgszProductPath[index],0);
			//m_rghProductIcon[index] = LoadImage(m_hInstance,m_rgszProductPath[index],IMAGE_ICON,32,32,LR_LOADFROMFILE);
			DWORD lastErr = GetLastError();
			if (m_rghProductIcon[index] == NULL)
			{
				m_rghProductIcon[index] = LoadIcon(m_hInstance,MAKEINTRESOURCE(IDI_REGWIZ));
			}
		}
		return m_rghProductIcon[index];
	}
	else
	{
		return NULL;
	}
}



short CRegWizard::GetProductCount( void )
/***************************************************************************
This function returns a count of the current number of products occupying
the inventory list.
****************************************************************************/
{
	return m_productNameCount;
}



void CRegWizard::SetInformationString(InfoIndex index, LPTSTR szInfo)
/***************************************************************************
This function saves the given string interally, associating it with info
attribute whose ID is given by the 'index' parameter.
****************************************************************************/
{
	short strLen ;
	if (index < kInfoLastIndex)
	{
		if (m_rgszInfoArray[index] != NULL)
		{
			LocalFree(m_rgszInfoArray[index]);
			m_rgszInfoArray[index] = NULL;
		}
		if(szInfo == NULL ) return;

		strLen = (_tcslen(szInfo)+1) * sizeof(_TCHAR);
		m_rgszInfoArray[index] = (LPTSTR) LocalAlloc(0, strLen);
		_tcscpy(m_rgszInfoArray[index],szInfo);
	}
}


BOOL CRegWizard::GetInformationString(InfoIndex index, LPTSTR szInfo)
/***************************************************************************
This function retrieves the information string whose ID is given by the
'index' parameter.  If the requested string has not been set yet, FALSE
will be returned as the function result, and an empty string will be
returned in szInfo.

Note: if you are interested only in determining whether the value is set
for a particular information string, you can pass NULL for szInfo.
****************************************************************************/
{
	if (index < kInfoLastIndex && m_rgszInfoArray[index] && m_rgszInfoArray[index][0]!=_T('\0') )
	{
		if (szInfo) _tcscpy(szInfo,m_rgszInfoArray[index]);
		return TRUE;
	}
	else
	{

		//if (szInfo) szInfo[0] = NULL;  by Suresh 06/6/97
		szInfo[0] = _T('\0');
		return FALSE;
	}
}


void CRegWizard::SetTriStateInformation(InfoIndex index, TriState infoValue)
/***************************************************************************
This function saves the given TriState value interally, associating it with
the info attribute whose ID is given by the 'index' parameter.

Note: if infoValue is kTriStateTrue, the value will be saved as "1"; if
kTriStateFalse or kTriStateUndefined, it will be saved as "0".
****************************************************************************/
{
	_TCHAR szInfo[4];
	_stprintf(szInfo,_T("%i"),infoValue == kTriStateTrue ? 1 : 0);
	SetInformationString(index,szInfo);
}


TriState CRegWizard::GetTriStateInformation(InfoIndex index)
/***************************************************************************
This function retrieves the TriState value whose ID is given by the 'index'
parameter.

Returns:
- kTriStateTrue
- kTriStateFalse
- kTriStateUndefined: value has not been set yet.
****************************************************************************/
{
	_TCHAR szInfo[kRegBufferSize];
	BOOL goodString = GetInformationString(index,szInfo);
	if (goodString == FALSE)
	{
		return kTriStateUndefined;
	}
	else
	{
		return szInfo[0] == _T('0') ? kTriStateFalse : kTriStateTrue;
	}
}


void CRegWizard::WriteEnableInformation(InfoIndex index, BOOL shouldWrite)
/***************************************************************************
If shouldWrite is TRUE, the information associated with the given index
will be enabled for writing to the Registration Database; otherwise, the
value for this index will be written as a NULL string.  By default, all
information members are write-enabled.
****************************************************************************/
{
	m_writeEnable[index] = shouldWrite;
}


BOOL CRegWizard::IsInformationWriteEnabled(InfoIndex index)
/***************************************************************************
Returns TRUE if the information associated with the given index is enabled
for writing to the Registration Database.
****************************************************************************/
{
	return m_writeEnable[index];
}


void CRegWizard::SetProductSearchStatus(TriState searchCompleted)
/***************************************************************************
This function needs to be called with a searchCompleted value of
kTriStateTrue when the product searching thread completes, or
kTriStateUndefined if an error prevents the search from being completed.
****************************************************************************/
{
	m_searchCompleted = searchCompleted;
}


TriState CRegWizard::GetProductSearchStatus( void )
/***************************************************************************
This function returns:
- kTriStateTrue if the product searching thread has completed.
- kTriStateFalse if the search is still in progress.
- kTriStateUndefined if an error prevented the search from being completed.
****************************************************************************/
{
	return m_searchCompleted;
}


void CRegWizard::SetSystemInventoryStatus(BOOL invCompleted)
/***************************************************************************
This function needs to be called with a invCompleted value of TRUE when
the system inventory compilation thread completes.
****************************************************************************/
{
	m_systemInventoryCompleted = invCompleted;
}


BOOL CRegWizard::GetSystemInventoryStatus( void )
/***************************************************************************
This function returns TRUE if the system inventory compilation thread has
completed.
****************************************************************************/
{
	return m_systemInventoryCompleted;
}


void CRegWizard::WriteInfoToRegistry( void )
/***************************************************************************
Writes all the information gathered by the RegWizard to the appropriate keys
in the Registration Database.
****************************************************************************/
{

	short index = kInfoFirstName;
	_TCHAR szRegKey[kRegBufferSize];
	_TCHAR szLogBuffer[kRegBufferSize];
	HKEY hKey;
	DWORD dwReserved=0;
	DWORD dwDisposition;
	TBYTE* lpbData;
	DWORD  dwStrSz;

	#ifndef WRITE_COUNTRY_AS_STRING
	wsprintf(szLogBuffer,_T("%li"),GetCountryCode());
	SetInformationString(kInfoCountry,szLogBuffer);
	#endif
	
	_tcscpy(szLogBuffer,_T("=== Microsoft Registration Wizard ==="));
	WriteToLogFile(szLogBuffer);

	GetInfoRegistrationParentKey(szRegKey);	

	LONG regStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
					szRegKey,
					dwReserved,
					NULL,
					REG_OPTION_NON_VOLATILE,
					KEY_ALL_ACCESS,
					NULL,
					&hKey,
					&dwDisposition);

	if (regStatus != ERROR_SUCCESS) return;

	while (index != kInfoLastIndex)
	{
		_TCHAR szInfo[kRegBufferSize];
		_TCHAR szValueName[kRegBufferSize];
		GetInfoRegValueName((InfoIndex) index,szValueName);

		// The value of any information entry that has been "write-disabled"
		// will be blanked out (i.e. the key will be written, but with an
		// empty string as the value).
		if (m_writeEnable[index] == FALSE)
		{
			szInfo[0] = NULL;
		}
		else
		{
			GetInformationString((InfoIndex) index,szInfo);
		}
		
		// First, write to our log file
		wsprintf(szLogBuffer,_T("%s = %s"),szValueName,szInfo);
		WriteToLogFile(szLogBuffer);
		if(szInfo[0] == _T('\0')) {
			lpbData = (TBYTE*) _T("\0");
			dwStrSz = _tcslen((const TCHAR *) lpbData)* sizeof(_TCHAR);
			regStatus = RegSetValueEx(hKey,szValueName,NULL,REG_SZ,(CONST BYTE*) lpbData,sizeof(TCHAR));
			

		}else{
		 lpbData = (TBYTE*) szInfo;
		 dwStrSz = _tcslen(szInfo)* sizeof(_TCHAR);
		 	regStatus = RegSetValueEx(hKey,szValueName,NULL,REG_SZ,(CONST BYTE *)lpbData, dwStrSz);
		}
		
		index++;
	}

	// If the kInfoIncludeProducts flag is FALSE, we want to write the ProductX keys,
	// but blank out the values.
	BOOL shouldIncludeProducts = GetTriStateInformation(kInfoIncludeProducts);
	index = 0;
	_TCHAR szProductBase[64];
	int resSize = LoadString(m_hInstance,IDS_PRODUCTBASEKEY,szProductBase,64);
	while (index < kMaxProductCount)
	{
		_TCHAR szProductValueName[kRegBufferSize];
		_TCHAR szProductName[kRegBufferSize];
		_stprintf(szProductValueName,_T("%s %i"),szProductBase,index + 1);
		if (shouldIncludeProducts == kTriStateTrue)
		{
			GetProductName(szProductName,index);
		}
		else
		{
			szProductName[0] = NULL;
		}
		wsprintf(szLogBuffer,_T("%s = %s"),szProductValueName,szProductName);
		WriteToLogFile(szLogBuffer);
		regStatus = RegSetValueEx(hKey,szProductValueName,NULL,REG_SZ,(CONST BYTE*) szProductName,_tcslen(szProductName)* sizeof(_TCHAR));
		index++;
	}

	RegCloseKey(hKey);
	CloseLogFile();
}
									

void CRegWizard::ReadInfoFromRegistry( void )
/***************************************************************************
Reads any information written to the Registration Database by previous runs
of RegWizard, and populates all information strings accordingly.
****************************************************************************/
{
	short index = kInfoFirstName;
	_TCHAR szRegKey[kRegBufferSize];
	HKEY hKey;

	GetInfoRegistrationParentKey(szRegKey);	
#ifdef SURESH
	LONG regStatus = RegOpenKeyEx(HKEY_CURRENT_USER,szRegKey,0,KEY_READ,&hKey);
#endif
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRegKey,0,KEY_READ,&hKey);

	if (regStatus == ERROR_SUCCESS)
	{
		while (index != kInfoLastIndex)
		{
			_TCHAR szInfo[kRegBufferSize];
			_TCHAR szValueName[kRegBufferSize];
			unsigned long infoSize;
			BOOL refresh = GetInfoRegValueName((InfoIndex) index,szValueName);
			if (refresh)
			{
				infoSize = kRegBufferSize;
				regStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szInfo,&infoSize);
				if (regStatus == ERROR_SUCCESS)
				{
					SetInformationString((InfoIndex) index,szInfo);
				}
			}
			index++;
		}
		RegCloseKey(hKey);
	}

	// Two of the information fields are fed to RegWizard as input parameters;
	// we'll read these from our input parameter block.
	_TCHAR szParam[kRegBufferSize];
	GetInputParameterString(IDS_INPUT_PRODUCTNAME,szParam);
	SetInformationString(kInfoApplicationName,szParam);
	GetInputParameterString(IDS_INPUT_PRODUCTID,szParam);
	SetInformationString(kInfoProductID,szParam);
}


BOOL CRegWizard::GetInfoRegValueName(InfoIndex infoIndex,LPTSTR szValueName)
/***************************************************************************
Returns in buffer pointed to by szValueName the value name associated with
the information item specified by infoIndex.

Returns:
If this key represents a value that should be used to refresh the value in
memory when RegWizard starts up,TRUE will be returned as the function result.
****************************************************************************/
{
	_TCHAR szOrigValueName[kRegBufferSize];
	LPTSTR szValueNamePtr;
	BOOL shouldRefresh = FALSE;
	short infoResIndex ;
	int resSize;

	if(infoIndex < kDivisionName ){
		infoResIndex = IDS_INFOKEY1 + infoIndex;
		resSize = LoadString(m_hInstance,infoResIndex,szOrigValueName,255);
	}else {
		infoResIndex = IDS_DIVISIONNAME_KEY + (infoIndex-kDivisionName);
		resSize = LoadString(m_hInstance,infoResIndex,szOrigValueName,255);

	}
	// After 03/03/98 in corporationg extra fields for Division and UserID, assuming
	// more fields can be added in the future a set of 15 more ID is reserver in the resource
	// so for Division and USEID, this pool of resource ID  will be used



	// SubKeys are flagged as 'refresh' keys by a leading underscore
	szValueNamePtr = szOrigValueName;
	if (szOrigValueName[0] == _T('_'))
	{
		shouldRefresh = TRUE;
		szValueNamePtr = _tcsinc(szValueNamePtr);
	}
	_tcscpy(szValueName,szValueNamePtr);
	return shouldRefresh;
}


void CRegWizard::GetInfoRegistrationParentKey(LPTSTR szRegKey)
/***************************************************************************
Returns the Registration Database key that specifies the parent of all our
information keys.
****************************************************************************/
{
	if (m_szInfoParentKey[0] == NULL)
	{
		_TCHAR szPartialKey[kRegBufferSize];
		int resSize = LoadString(m_hInstance,IDS_KEY2,szRegKey,255);
		_tcscat(szRegKey,_T("\\"));
		resSize = LoadString(m_hInstance,IDS_KEY3,szPartialKey,255);
		_tcscat(szRegKey,szPartialKey);
		_tcscat(szRegKey,_T("\\"));
		resSize = LoadString(m_hInstance,IDS_KEY4,szPartialKey,255);
		_tcscat(szRegKey,szPartialKey);
		#ifdef USE_INFO_SUBKEYS
		_tcscat(szRegKey,_T("\\"));
		#endif
		_tcscpy(m_szInfoParentKey,szRegKey);
	}
	else
	{
		_tcscpy(szRegKey,m_szInfoParentKey);
	}
}


void CRegWizard::GetRegKey(LPTSTR szRegKey)
/**************************************************************************
Returns the country code selected by the user in the Address dialog.
****************************************************************************/
{
	_tcscpy(szRegKey,m_szParamRegKey);
}


HINSTANCE CRegWizard::GetInstance( void )
/***************************************************************************
Returns the instance handle of the application that created this
CRegWiz object.
****************************************************************************/
{
	return m_hInstance;
}


void CRegWizard::SetCountryCode(DWORD countryCode)
/***************************************************************************
Saves off the country code selected by the user in the Address dialog.
****************************************************************************/
{
	m_countryCode = countryCode;
}


DWORD CRegWizard::GetCountryCode( void )
/**************************************************************************
Returns the country code selected by the user in the Address dialog.
****************************************************************************/
{
	return m_countryCode;
}


void CRegWizard::GetCountryAddrSpec(LONG lCountryID,ADDRSPEC* addrSpec )
/**************************************************************************
Returns a ADDRSPEC structure based on the specified countryID value.
****************************************************************************/
{
	if (lCountryID >= 0 && m_addrJumpTable != NULL)
	{
		JTE* addrJumpTable = (JTE*) GlobalLock(m_addrJumpTable);
		JTE jumpIndex = addrJumpTable[lCountryID];
		if (addrSpec)
		{
			ADDRSPEC* addrSpecTable = (ADDRSPEC*) GlobalLock(m_addrSpecTable);
			*addrSpec = addrSpecTable[jumpIndex];
			GlobalUnlock(m_addrSpecTable);
		}
		GlobalUnlock(m_addrJumpTable);
	}
}


void CRegWizard::GetAddrSpecProperties(DWORD dwCountryCode, ADDRSPEC_FIELD addrSpecField, MAXLEN* maxLen,BOOL* isRequired)
/*********************************************************************
Returns the maximum char length and "required?" properties associated
with the editable field specified by addrSpecField, and the country
code specified in the dwCountryCode parameter.
**********************************************************************/
{
	BOOL lclIsRequired = TRUE;
	ADDRSPEC addrSpec;
	GetCountryAddrSpec(dwCountryCode,&addrSpec);
	if (maxLen)
	{
		*maxLen = addrSpec.maxLen[addrSpecField];
		if (*maxLen < 0)
		{
			*maxLen = abs(*maxLen);
			lclIsRequired = FALSE;
		}
	}
	if((dwCountryCode == 0)&&(addrSpecField == kAddrSpecState))
	{
			*maxLen = (MAXLEN)2;
	}
	if((dwCountryCode == 0)&&(addrSpecField == kAddrSpecResellerState))
	{
			*maxLen = (MAXLEN)2;
	}
	
	RW_DEBUG << "COUNTRY CODE:" << dwCountryCode << "SPEC FIELD" << addrSpecField<<"LENGTH:" << (int) (*maxLen) << endl;

	if (isRequired) *isRequired = lclIsRequired;
}


BOOL CRegWizard::IsEditTextFieldValid(HWND hwndDlg,int editID)
/*********************************************************************
Returns TRUE if the edit text field specified by the editID parameter
contains at least one character, OR has been marked as 'not required'
by a call to the ConfigureEditTextField function.

Note: if the edit text field has been disabled, it will considered to
be "not required", regardless of the state set by ConfigureEditText-
Field.
**********************************************************************/
{
	HWND hwndEdit = GetDlgItem(hwndDlg,editID);
	BOOL isEnabled = IsWindowEnabled(hwndEdit);
	BOOL isRequired = isEnabled == FALSE ? FALSE : (BOOL) HIWORD(GetWindowLongPtr(hwndEdit,GWLP_USERDATA));
	LRESULT editTextLen = SendMessage(hwndEdit,WM_GETTEXTLENGTH,0,0L);
	return isRequired == FALSE || editTextLen > 0 ? TRUE : FALSE;
}



void CRegWizard::GetEditTextFieldAttachedString(HWND hwndDlg,int editID,LPTSTR szAttached,int cbBufferSize)
/*********************************************************************
Returns the string whose resource ID was attached to the specified
edit control by a call to ConfigureEditTextField
**********************************************************************/
{
	_TCHAR szBuffer[kRegBufferSize];
	HWND hwndEdit = GetDlgItem(hwndDlg,editID);
	WORD wLabelID = LOWORD(GetWindowLongPtr(hwndEdit,GWLP_USERDATA));
	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
	GetDlgItemText(hwndDlg,wLabelID,szAttached,cbBufferSize);
	StripCharFromString(szAttached, szBuffer, _T('&'));
	StripCharFromString(szBuffer, szAttached, _T(':'));
}



void CRegWizard::ConfigureEditTextField(HWND hwndDlg,int editFieldID,ADDRSPEC_FIELD addrSpecField,int iAttachedStrID)
/*********************************************************************
Sets the maximum character limit and "required?" status for the edit
field whose ID is given by the editFieldID parameter.  The
addrSpecField parameter specifies which field within the AddrSpec
(as defined by the currently selected country) to use to determine
the char limit and "required?" values.

If the text currently residing in the edit control is longer than
the maximum allowed for that field, ConfigureEditTextField will
truncate it to the allowable value.

Note: the current country code MUST be set via a call to
SetCountryCode before calling ConfigureEditTextField.
**********************************************************************/
{
	MAXLEN maxLen;
	BOOL isRequired;
	DWORD dwTapiCntryId;
	maxLen = 0;
	isRequired = FALSE;
	dwTapiCntryId = gTapiCountryTable.GetTapiIDForTheCountryIndex(m_countryCode);
	//GetAddrSpecProperties(m_countryCode,addrSpecField,&maxLen,&isRequired);
	GetAddrSpecProperties(dwTapiCntryId,addrSpecField,&maxLen,&isRequired);
	SendDlgItemMessage(hwndDlg,editFieldID,EM_LIMITTEXT,maxLen,0L);
	
	LRESULT dwTextLen = SendDlgItemMessage(hwndDlg,editFieldID,WM_GETTEXTLENGTH,0,0L);
	if (dwTextLen > (LRESULT) maxLen)
	{
		_TCHAR szText[256];
		SendDlgItemMessage(hwndDlg,editFieldID,WM_GETTEXT,255,(LPARAM) szText);
		szText[maxLen] = NULL;
		SendDlgItemMessage(hwndDlg,editFieldID,WM_SETTEXT,0,(LPARAM) szText);
	}

	HWND hwndEdit = GetDlgItem(hwndDlg,editFieldID);
	LONG_PTR lWindowLong = (isRequired << 16) | iAttachedStrID;
	SetWindowLongPtr(hwndEdit,GWLP_USERDATA,(LONG_PTR)lWindowLong);
}



void CRegWizard::BuildAddrSpecTables( void )
/*********************************************************************
Builds country code-dependent name/address specification table (by
reading and parsing the specification strings for each country from
string resources.
**********************************************************************/
{
	// Build country-code dependent address spec tables
	LONG lMaxCntryCode = GetResNumber(m_hInstance,IDS_CNTRY_MAXCODE);
	m_addrJumpTable = GlobalAlloc(GHND, sizeof(JTE) * (lMaxCntryCode + 1));
	JTE* addrJumpTable = (JTE*) GlobalLock(m_addrJumpTable);

	LONG lUniqueCount = GetResNumber(m_hInstance,IDS_CNTRY_UNIQUECOUNT);
	m_addrSpecTable = GlobalAlloc(GHND, sizeof(ADDRSPEC) * (lUniqueCount + 1));
	ADDRSPEC* addrSpecTable = (ADDRSPEC*) GlobalLock(m_addrSpecTable);

	LONG lSpecTableIndex = 0;
	int iStrResID = IDS_CNTRY_DEFAULT;
	while (iStrResID < IDS_CNTRY_END && lSpecTableIndex < kMaxAddrSpecTableSize)
	{
		_TCHAR szSpecString[64];
		int iStrLen = LoadString(m_hInstance,iStrResID,szSpecString,64);
		// Gaps are allowable in the string resource ID numbering, so watch out.
		if (iStrLen > 0)
		{						
			LPTSTR szSpecPtr = szSpecString;
			LPTSTR szNext;						
			long lCntryCode = _tcstol(szSpecPtr,&szNext,10);
			if (lCntryCode < lMaxCntryCode && lCntryCode >= 0 && szNext[0] == _T(':'))
			{
				//szSpecPtr += _tcsclen(szNext + 1);
				szSpecPtr = szNext + 1;
				LONG lInterTableReference = _tcstol(szSpecPtr,&szNext,10);
				if (szNext[0] == NULL || szNext[0] == _T(' '))
				{
					addrJumpTable[lCntryCode] = addrJumpTable[lInterTableReference];
				}
				else
				{
					addrJumpTable[lCntryCode] = (JTE) lSpecTableIndex;
					WORD wSpecIndex = 0;
					do
					{
						LONG lMaxLen = _tcstol(szSpecPtr,&szNext,10);

						// A missing 'y' or 'n' specifier is considered a
						// syntax error, and we'll stop processing that line.
						if (szNext[0] == _T('y') || szNext[0] == _T('n'))
						{
							if (lMaxLen > kMaxLenSize) lMaxLen = kMaxLenSize;
							if (szNext[0] == _T('n')) lMaxLen *= -1;
							addrSpecTable[lSpecTableIndex].maxLen[wSpecIndex++] = (MAXLEN) lMaxLen;
							szSpecPtr = szNext + 1;
						}
						else
						{
							szSpecPtr = NULL;
						}
					}while (szSpecPtr && szSpecPtr[0] && wSpecIndex < kAddrSpecCount);
					lSpecTableIndex++;
				}
			}
		}
		iStrResID++;	
	}
	GlobalUnlock(m_addrJumpTable);
	GlobalUnlock(m_addrSpecTable);
}


void CRegWizard::ResolveCurrentCountryCode( void )
/*********************************************************************
If the user has run RegWizard previously, we'll use the last selection
as the current country code.  Otherwise, we'll ask Tapi for the
current system country code.
**********************************************************************/
{
	_TCHAR szCountry[kRegBufferSize];
	DWORD dwCountryCode=0;
		
	if( GetInformationString(kInfoCountry,szCountry) )
	{
		dwCountryCode = _ttol(szCountry);
	}
	else
	{
		// Get TAPI Country Code
		if (GetTapiCurrentCountry(m_hInstance,&dwCountryCode)){
			RW_DEBUG << "\n TAPI Country Code :[" << dwCountryCode << flush;
				

			dwCountryCode= gTapiCountryTable.GetCountryCode(dwCountryCode);
			RW_DEBUG << "]=Mapping Index : " << dwCountryCode << flush;
		}else {
			dwCountryCode = 0; // Fore it to USA

		}
	}
	SetCountryCode(dwCountryCode);
}


void CRegWizard::SetLogFileName(LPTSTR lpszLogFilePath)
/*********************************************************************
If this function is called with a valid full pathname to a file,
CRegWizard will write all registration information, as text, to this
file, in addition to writing it to the Registration Database.
**********************************************************************/
{
	_tcscpy(m_szLogFilePath,lpszLogFilePath);
}


void CRegWizard::CreateLogFile( void )
/**********************************************************************
This function attempts to create a logfile into which all pertinent
registration information will be dumped, if that file has not been
created already (by a previous call to CreateLogFile).

Note: CreateLogFile is called automatically by WriteToLogFile if the
log file does not exist, so you don't need to call CreateLogFile first.
***********************************************************************/
{
	if (m_szLogFilePath[0] && m_hLogFile == INVALID_HANDLE_VALUE)
	{
		m_hLogFile = CreateFile(m_szLogFilePath,GENERIC_WRITE,FILE_SHARE_READ,NULL,CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,NULL);
	}
}


void CRegWizard::WriteToLogFile(LPTSTR lpszLine)
/**********************************************************************
This function first checks to see if registration logging has been
enabled (via a call to SetLogFileName), and if so, writes the given
line to the designated log file.

Note: WriteToLogFile automatically appends CR/LF to the given string.

Note: If the log file does not yet exist, WriteToLogFile will create
it automatically.
***********************************************************************/
{
	#define chEol	_T('\n')
	#define chCR	_T('\r')

	if (m_hLogFile == INVALID_HANDLE_VALUE)
	{
		CreateLogFile();
	}
	
	if (m_hLogFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwBytesWritten;
		DWORD wLen = _tcslen(lpszLine);
		lpszLine[wLen]   = chCR;
		lpszLine[wLen + 1] = chEol;
		lpszLine[wLen + 2] = NULL;
		WriteFile(m_hLogFile,lpszLine, _tcslen(lpszLine)* sizeof(_TCHAR),&dwBytesWritten,NULL);
	}		
}


void CRegWizard::CloseLogFile( void )
/**********************************************************************
If the RegWizard log file is open, this function closes it.
***********************************************************************/
{
	if (m_hLogFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hLogFile);
	}
}


HWND CRegWizard::GetCurrDialog(void )
{
	return m_hwndCurrDialog;
}

void CRegWizard::SetDialogHide(HWND hDialogToHide)
{
	m_hwndDialogToHide = hDialogToHide;
}

BOOL CRegWizard::ShowPrevDialog(void)
{
	if(m_hwndPrevDialog != NULL)
	{
		RECT r;
		HWND hwndTmpDialog;
		GetWindowRect(m_hwndDialogToHide, &r);
		SetWindowPos(m_hwndPrevDialog, NULL, r.left, r.top,0,0,SWP_NOSIZE|SWP_NOZORDER);
		ShowWindow(m_hwndDialogToHide,SW_HIDE);
		m_hwndDialogToHide = NULL;
		hwndTmpDialog = m_hwndCurrDialog;
		m_hwndCurrDialog = m_hwndPrevDialog;
		m_hwndPrevDialog = hwndTmpDialog;
		
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void CRegWizard::SetWindowCaption(LPTSTR lpszWindowsCaption)
{
	_TCHAR szTitle[64];
	LoadString(m_hInstance,IDS_WINDOWS_CAPTION,szTitle,64);
	_tcscpy(m_szWindowsCaption,lpszWindowsCaption);
	_tcscat(m_szWindowsCaption,szTitle);
}


LPTSTR CRegWizard::GetWindowCaption(void)
{
	return m_szWindowsCaption;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\exitdlg.cpp ===
/*********************************************************************
Registration Wizard

exitdlg.cpp
10/13/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
Modification History:
	MXX1 
	Date :02/17/99: 
	By   :SK 
	Change Request :Cancel Dialog should not be displayed
	Function : CancelRegWizard()

**********************************************************************/

#include <Windows.h>
#include "Resource.h"
#include "regutil.h"
#include <stdio.h>

static INT_PTR CALLBACK ExitDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern _TCHAR szWindowsCaption[256];

INT_PTR CancelRegWizard(HINSTANCE hInstance,HWND hwndParentDlg)
/*********************************************************************
Returns TRUE if the user confirms that RegWizard should be canceled.
**********************************************************************/
{
//	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndParentDlg,GWLP_HINSTANCE);
	
	// MXX1  --- Start
	//NT_PTR hitButton = DialogBox(hInstance,MAKEINTRESOURCE(IDD_CANCEL),hwndParentDlg, ExitDialogProc);
	//return hitButton == IDB_YES ? TRUE : FALSE;
	
	// MXX1  --- Finish

	// MXX1  --- Start
	return TRUE;
	// MXX1  --- Finish
}


INT_PTR CALLBACK ExitDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Proc for dialog displayed when the user hits the 'cancel' button
**********************************************************************/
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
		{
			RECT parentRect,dlgRect;
			HWND hwndParent = GetParent(hwndDlg);

			GetWindowRect(hwndParent,&parentRect);
			GetWindowRect(hwndDlg,&dlgRect);
			int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
			int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
			MoveWindow(hwndDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			
			SetWindowText(hwndDlg,szWindowsCaption);


            return TRUE;
		}
        case WM_COMMAND:
            switch (wParam)
            {
                case IDB_YES:
				case IDB_NO:
					EndDialog(hwndDlg,wParam);
					break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\finalscr.cpp ===
/*
	File : FINALSCR.CPP
	The final screen of Registration Wizard using Wizard 97 control
	This screen displays the staus of the Online registration
	Date : 02/12/98  Suresh Krishnan

  Modification History:
  08/20/98 :
  FormRegWizErrorMsgString() is added to form Error string
  02/16/99 :
  In case if the user presses CANCEL the Final screen should not be 
  displayed
  02/17/99 :
  Back to original feature . In case of Cancel the final screen will be displayed
*/



#include <Windows.h>
#include "RegWizMain.h"
#include "Resource.h"
#include <RegPage.h>
#include "Dialogs.h"
#include "regutil.h"
#include <rw_common.h>
#include <commctrl.h>

static   TCHAR  szClosingMsg[2048]=_T("");
extern BOOL RW_EnableWizControl(HWND hDlg,int	 idControl,	BOOL fEnable);
extern void FormRegWizErrorMsgString(TCHAR *czDest, HINSTANCE hIns,UINT iS1);

INT_PTR
CALLBACK
FinalScreenDialogProc(
                      HWND hwndDlg,
					  UINT uMsg,
					  WPARAM wParam,
                      LPARAM lParam
                      )
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that presents the
Product Identification number to the user.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	int iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
 	 HKEY  hKey;
	_TCHAR szText1[2048];
	_TCHAR szText2[1024];
	_TCHAR szRegDone[10]= _T("1");
	_TCHAR uszRegKey[128];
	int resSize;
	PTBYTE lpbData;
	static int iDonotShowThisPage=0;

	
	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {
		case WM_CLOSE:
			break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				

        case WM_INITDIALOG:
		{
			LV_COLUMN   lvColumn;

			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;

			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			RW_DEBUG << "\n In Final Screen [" << (ULONG)pi->iError << flush;
			ReplaceDialogText(hwndDlg, IDT_TEXT1,szInfo);
			ReplaceDialogText(hwndDlg, IDC_TEXT3,szInfo);

			//initialize the columns
			lvColumn.mask = LVCF_FMT|LVCF_WIDTH;
			lvColumn.fmt  = LVCFMT_LEFT;
			lvColumn.cx   = 700;

			ListView_InsertColumn(GetDlgItem(hwndDlg,IDC_LIST1), 0, &lvColumn);

			//  pi->iError = RWZ_POST_FAILURE ;
			switch(pi->iError)
			{
				case RWZ_POST_SUCCESS :
					{
						RECT Rect;
						_TCHAR szSuccessTxt[256];
						LoadString(pclRegWizard->GetInstance(),IDS_SUCCESS_TEXT,szSuccessTxt,256);
						SendDlgItemMessage(hwndDlg,IDC_TEXT1,WM_SETTEXT,0,(LPARAM) szSuccessTxt);
						ShowWindow(GetDlgItem(hwndDlg,IDC_TEXT2),SW_HIDE);
						ShowWindow(GetDlgItem(hwndDlg,IDC_LIST1),SW_HIDE);
						ShowWindow(GetDlgItem(hwndDlg,IDC_TEXT3),SW_HIDE);
						ShowWindow(GetDlgItem(hwndDlg,IDC_ERROR),SW_HIDE);
						
						uszRegKey[0] = _T('\0');
						resSize = LoadString(pclRegWizard->GetInstance(),IDS_INPUT_ISREGISTERED,uszRegKey,128);
						GetProductRoot (pi->pszProductPath , &hKey);
						lpbData = (PTBYTE) szRegDone;
						RegSetValueEx(hKey,uszRegKey,NULL,REG_SZ,(CONST BYTE *)lpbData,_tcsclen(szRegDone)*sizeof(_TCHAR));
								
						//GetWindowRect(GetDlgItem(hwndDlg,IDC_TEXT2),&Rect);
						//MoveWindow(GetDlgItem(hwndDlg,IDC_TEXT4),Rect.left,Rect.top,(Rect.right - Rect.left),(Rect.bottom - Rect.top),TRUE);
					}
				break;
				case RWZ_ERROR_NOTCPIP :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_NOTCP1_MSG);

					//_stprintf(szClosingMsg,szText1,szInfo);
				break;
				case CONNECTION_CANNOT_BE_ESTABLISHED:
					//
					// Modem  not found
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_MODEMCFG_MSG1);
					
				break;
				case RWZ_ERROR_NO_ANSWER: // Site Busy Try Later Modem Error
				case RWZ_POST_FAILURE :
				case RWZ_POST_MSN_SITE_BUSY:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_SITEBUSY_MSG);
				break;

				case RWZ_ERROR_TXFER_CANCELLED_BY_USER:
			
					iDonotShowThisPage =0;
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_CANCEL_MSG);
					
					break;

				case RWZ_ERROR_REGISTERLATER :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),
						IDS_FINAL_REGISTERLATER_MSG);
				break;
				case RWZ_ERROR_RASDLL_NOTFOUND :
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),IDS_FINAL_RASCFG_MSG);

				break;					
				case RWZ_ERROR_MODEM_IN_USE: // Can not Dial as another app is using the COM port
				case RWZ_ERROR_MODEM_CFG_ERROR:
					FormRegWizErrorMsgString(szClosingMsg, pclRegWizard->GetInstance(),
						IDS_FINAL_MODEMINUSE_MSG);
				break;
				
				case RWZ_ERROR_LOCATING_DUN_FILES:
				default:
					//LoadString(pclRegWizard->GetInstance(),IDS_FINAL_UNSUCCESS_PREFIX,szClosingMsg,1024);
					LoadString(pclRegWizard->GetInstance(),IDS_FINAL_SYSTEMERROR_MSG,szText2,1024);
					_tcscat(szClosingMsg,szText2);
				//default : // System Error ...
				break;

			}

			if(pi->iError != RWZ_POST_SUCCESS)
			{
				TCHAR  szTmp[2048];
				_stprintf(szTmp,szClosingMsg,szInfo);
				
				SetDlgItemText(hwndDlg,IDC_ERROR,szTmp);
				//AddErrorToList(GetDlgItem(hwndDlg,IDC_LIST1),pclRegWizard->GetInstance(),szClosingMsg);
			}

			return TRUE;
		}
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
				
            switch( pnmh->code ){
				

            case PSN_SETACTIVE:
				
				pi->iCancelledByUser = RWZ_PAGE_OK;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_FINISH );
				RW_EnableWizControl(hwndDlg,RWZ_WIZ97_CANCEL_ID,FALSE);
				if(iDonotShowThisPage ) {
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_FINISH);
				}
				
				break;

            case PSN_WIZNEXT:
				
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					
					pi->CurrentPage++;
				}
				break;

            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, iRet);
				break;
			default:

                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
        default:
		bStatus = FALSE;
         break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\inetdlg.cpp ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "resource.h"
#include "rw_common.h"
#include "rwpost.h"
#include "sysinv.h"
#include "regutil.h"

#define POST_DATA_WITH_DISPLAY 1

static HWND  m_hDlg = NULL;
static HINSTANCE m_hInst=NULL;
static DWORD    dwRasError = 0; // To Store Ras reported Error
static HANDLE hRasNotifyEvt=  NULL ; // Event handle used for RAS Notififiation
static int siMsgType=0;  // used to choose the message to be displayed
static int siOperation=0;
extern BOOL bOemDllLoaded;
extern HANDLE hOemDll;
extern _TCHAR szWindowsCaption[256];

INT_PTR CALLBACK  DisplayDlgWindowWithOperation(
				HWND hDlg, 			//dialog window
				UINT uMsg,
				WPARAM wParam,
				LPARAM lParam
			)
			
//BOOL CALLBACK  DisplayMSNConnection(
	//	HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	
	DWORD	dwEnd = 0;
	BOOL	fRet = TRUE;
	HWND hwndParent ;
	switch(uMsg){
		case WM_INITDIALOG:	
			
			RECT parentRect,dlgRect;
			m_hDlg = hDlg;
			m_hInst   = ( HINSTANCE) lParam;
			hwndParent = GetParent(hDlg);
						
			if (hwndParent)
			{
				GetWindowRect(hwndParent,&parentRect);
				GetWindowRect(hDlg,&dlgRect);
				int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			else
			{
				int horiz,vert;
				GetDisplayCharacteristics(&horiz,&vert,NULL);
				GetWindowRect(hDlg,&dlgRect);
				int newX = horiz/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = vert/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			NormalizeDlgItemFont(hDlg,IDC_TEXT1);
			
			SetWindowText(hDlg,szWindowsCaption);

			ReplaceDialogText(hDlg,IDC_TEXT1,GetProductBeingRegistred());

			if(siMsgType)
			{
				ReplaceDialogText(hDlg,IDC_TEXT1,GetProductBeingRegistred());
			}
			else
			{

				if(siOperation == POST_DATA_WITH_DISPLAY)
				{
					TCHAR szValueName[256] = _T("");
					HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hDlg,GWLP_HINSTANCE);
					LoadString(hInstance,IDS_POST_MESSAGE,szValueName,128);
					SendDlgItemMessage(hDlg,IDC_TEXT1,WM_SETTEXT,0,(LPARAM)szValueName);
				}
			}
			
			PostMessage( m_hDlg, WM_COMMAND, (WPARAM) IDOK,0 );
			return TRUE;
  			goto LReturn;
			break;
		case WM_COMMAND:
		switch (LOWORD(wParam)){
			case IDOK  :
				if(siOperation == POST_DATA_WITH_DISPLAY) {
					dwEnd = SendHTTPData(m_hDlg,m_hInst);
					goto LEnd;

				}
			
				dwEnd = CheckInternetConnectivityExists(m_hDlg,
					m_hInst);
				goto LEnd;

			case IDCANCEL:
				goto LEnd;
			default:
				fRet = FALSE;
				goto LReturn;
			}
		break;
		default :
		fRet = FALSE;
		goto LReturn;
		break;
	}
LEnd:
	EndDialog(hDlg,dwEnd);
	m_hDlg = NULL;	//no more dialog	
LReturn:	
	return fRet;
}



//  Function : CheckWithDisplayInternetConnectivityExists( )
//  This function calls the Background fucntion CheckInternetConnectivityExists() 		
//  whcih checks for the  connectivity cfg to the MSN.
//  The return value is based on the return value of CheckInternetConnectivityExists()
//	Returns
//	DIALUP_NOT_REQUIRED  : Use Network for tx
//  DIALUP_REQUIRED       : Use Dialupo for Tx
//  RWZ_ERROR_NOTCPIP      : No TCP/IPO
//  CONNECTION_CANNOT_BE_ESTABLISHED  : No modem or RAS setup


DWORD_PTR CheckWithDisplayInternetConnectivityExists(HINSTANCE hIns,HWND hwnd,int iMsgType)
{
	
	INT_PTR dwRet;	
	siMsgType = iMsgType;
	RW_DEBUG << "\n Before invoking Dlg   Display Internet Connection "  <<  flush;
	dwRet=DialogBoxParam(hIns, MAKEINTRESOURCE(IDD_VERIFY_CONNECTION), hwnd,DisplayDlgWindowWithOperation,
			 (LPARAM)hIns);
	siMsgType = 0;
	if(dwRet == -1 ) {
			 // Error in creating the Dialogue
	
	}
	RW_DEBUG << "\n In Chk With Display Internet Connection "  <<  flush;
	return dwRet;
}


DWORD_PTR PostDataWithWindowMessage( HINSTANCE hIns)
{
	INT_PTR dwRet;	
	siMsgType = 0;
	siOperation = POST_DATA_WITH_DISPLAY;
	RW_DEBUG << "\n Invoking PostDataDlg   Display Internet Connection "  <<  flush;
	dwRet=DialogBoxParam(hIns, MAKEINTRESOURCE(IDD_VERIFY_CONNECTION), NULL,DisplayDlgWindowWithOperation,
			 (LPARAM)hIns);
	siMsgType = 0;
	siOperation = 0;
	if(dwRet == -1 ) {
			 // Error in creating the Dialogue
	
	}
	return dwRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\home.cpp ===
/*********************************************************************
Registration Wizard

Home user related questions

  04/26/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "RegPage.h"
#include "regwizmain.h"
#include "resource.h"
#include "dialogs.h"
#include "regutil.h"
#include <rw_common.h>

#define  LIMIT_INFLUENCE  9
#define  LIMIT_EXCITED    9
#define  LIMIT_SKILL      5   

#define _INCLUDE_3RDPARTYLOGIC_CODE

#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
static int vDeclineOffers = -1;
#endif

BOOL ValidateHomeUserDialog(HWND hwndDlg,int iStrID);
void FillListEntry(HWND hwnd,int iLimit);

int  GetListIndexFromValue(TCHAR * czValue, int iMax)
{	int iIndex;
	iIndex = _ttoi(czValue);
	if(iIndex == 0) {
		return 0;
	}else {
		return (iMax - iIndex)+1;
	}
}
int GetValueFromListIndex(int iIndex, int iMax)
{
    if(iIndex == 0) {
         return 0;
    }
	return (iMax -iIndex)+1;
}

INT_PTR  CALLBACK HomeUserDialogProc(HWND hwndDlg, UINT uMsg, 
										 WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that displays 
Business related Question 
network type, etc.
**********************************************************************/
{


	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
	BOOL NotboughtByCompany;
	HWND hwCmpSw,hwExcite, hwPcSw; 
	LRESULT dwIndex;
	int iIndex;
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
	TriState shouldInclude;
#endif


	

	static int iShowThisPage= DO_SHOW_THIS_PAGE; 


	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
		hwCmpSw  = GetDlgItem(hwndDlg,IDC_LIST2);
		hwExcite = GetDlgItem(hwndDlg,IDC_LIST4);
		hwPcSw   = GetDlgItem(hwndDlg,IDC_LIST5);;
	}
	

    switch (uMsg)
    {
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;
		case WM_CLOSE:
			 break;			
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			hwCmpSw  = GetDlgItem(hwndDlg,IDC_LIST2);
			hwExcite = GetDlgItem(hwndDlg,IDC_LIST4);
			hwPcSw   = GetDlgItem(hwndDlg,IDC_LIST5);;

			FillListEntry(hwCmpSw,LIMIT_INFLUENCE);
			FillListEntry(hwExcite,LIMIT_EXCITED);
			FillListEntry(hwPcSw, LIMIT_SKILL);
			
			SetFocus(hwCmpSw);

		    vDialogInitialized = FALSE;
            return TRUE;
		} // WM_INIT
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:

			NotboughtByCompany = pclRegWizard->IsInformationWriteEnabled(kInfoCompany);
			if(NotboughtByCompany) 
			{
				iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
			}else {
				iShowThisPage= DO_SHOW_THIS_PAGE;
			}
			if(iShowThisPage== DO_SHOW_THIS_PAGE) {
				NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
				NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
				
			}
			if( iShowThisPage== DO_NOT_SHOW_THIS_PAGE ) 
			{
				pi->iCancelledByUser = RWZ_SKIP_AND_GOTO_NEXT;
				if( pi->iLastKeyOperation == RWZ_BACK_PRESSED){
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_BACK);
				}else {
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
				}
			}
			else {
				// Show thi  page
				pi->iCancelledByUser = RWZ_PAGE_OK;
				pi->iLastKeyOperation = RWZ_UNRECOGNIZED_KEYPESS;
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT);
			
				// Update Indexes 
				if(pclRegWizard->GetInformationString(kHomeSwKnow,szInfo)) {
					iIndex = GetListIndexFromValue(szInfo,LIMIT_INFLUENCE);
					SendMessage(hwCmpSw, LB_SETCURSEL,iIndex, 0);
				}else {
					
				}
				
				if( pclRegWizard->GetInformationString(kHomeExcited,szInfo)){
					iIndex = GetListIndexFromValue(szInfo,LIMIT_INFLUENCE);
					SendMessage(hwExcite, LB_SETCURSEL ,iIndex, 0);
				}
					
				if(pclRegWizard->GetInformationString(kHomePcSwKnow,szInfo)) {
					iIndex = GetListIndexFromValue(szInfo,LIMIT_SKILL);
					SendMessage(hwPcSw, LB_SETCURSEL ,iIndex,0);
				}
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
				
				// 
				// radio buttons
				shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
				if (shouldInclude == kTriStateTrue ){
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					vDeclineOffers = 1;
				}
				else if (shouldInclude == kTriStateFalse){
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					vDeclineOffers = 0;
				}else if (shouldInclude == kTriStateUndefined){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
					vDeclineOffers = -1;
				}
				// Enable for previpously entred value in screen
				if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}
				if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}
#endif

				vDialogInitialized = TRUE;



			}
            break;
            case PSN_WIZNEXT:
				switch(pi->iCancelledByUser) 
				{
				case  RWZ_CANCELLED_BY_USER : 
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					break;
				case RWZ_PAGE_OK:
					{
						RW_DEBUG << "Home questionaire RWZ_PAGE_OK " << endl;
						iRet=0;
						if( ValidateHomeUserDialog(hwndDlg,IDS_BAD_SYSINV)) 
						{
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
						BOOL yesChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
						BOOL noChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
#endif

						// Get Selected Value 
						dwIndex =  SendMessage(hwCmpSw, LB_GETTOPINDEX , 0, 0);
					
						if(dwIndex != LB_ERR)
						{
						 	dwIndex = GetValueFromListIndex((int) dwIndex,LIMIT_INFLUENCE); 	
							_stprintf(szInfo,_T("%d"),dwIndex);
							
							RW_DEBUG << "Home questionaire kHomeSwKnow "<< ConvertToANSIString(szInfo) << endl;

							pclRegWizard->SetInformationString(kHomeSwKnow,szInfo);
						}
						else 
						{
							RW_DEBUG << "Home questionaire kHomeSwKnow NULL " << endl;
							pclRegWizard->SetInformationString(kHomeSwKnow,NULL);
						}

						// Get 
						dwIndex =  SendMessage(hwExcite, LB_GETTOPINDEX , 0, 0);
						if(dwIndex !=  LB_ERR) 
						{
							dwIndex = GetValueFromListIndex((int) dwIndex,LIMIT_INFLUENCE); 	
							_stprintf(szInfo,_T("%d"),dwIndex);
							
							RW_DEBUG << "Home questionaire kHomeExcited "<< ConvertToANSIString(szInfo) << endl;

							pclRegWizard->SetInformationString(kHomeExcited,szInfo);
						}
						else 
						{
							RW_DEBUG << "Home questionaire kHomeExcited NULL " << endl;
							pclRegWizard->SetInformationString(kHomeExcited,NULL);
						}
						//
						// Get Home PC Know
						dwIndex =  SendMessage(hwPcSw, LB_GETTOPINDEX , 0, 0);
						_stprintf(szInfo,_T("%d"),dwIndex);

						if(dwIndex !=  LB_ERR) 
						{
							dwIndex = GetValueFromListIndex((int) dwIndex,LIMIT_SKILL); 	
							_stprintf(szInfo,_T("%d"),dwIndex);
							RW_DEBUG << "Home questionaire kHomePcSwKnow "<< ConvertToANSIString(szInfo) << endl;

							pclRegWizard->SetInformationString(kHomePcSwKnow,szInfo);
						}
						else 
						{
							RW_DEBUG << "Home questionaire kHomePcSwKnow NULL " << endl;
							pclRegWizard->SetInformationString(kHomePcSwKnow,NULL);
						}

#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
 						if(vDeclineOffers == -1)
						{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateUndefined);
						}
						else
						if(vDeclineOffers == 0)
						{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateFalse);
						}
						else
						{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateTrue);
						}
						_stprintf(szInfo,_T("%i"),vDeclineOffers);
						pclRegWizard->SetInformationString(kInfoDeclinesNonMSProducts,szInfo);
#endif
						RW_DEBUG << "Home questionaire done " << endl;
					// *****
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
					// Set as Next Key Button Pressed
					}
					else 
					{
					// Force it it be in this screen
						iRet=-1;
					}
						SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet); 
					}
					break;
					case RWZ_SKIP_AND_GOTO_NEXT:
					default:
						// Do not Validate the page and just go to the next page 
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;

					break;
				} // end of switch pi->iCancelledByUser
				break;
            case PSN_WIZBACK:
                pi->CurrentPage--;
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
				break;
			case PSN_QUERYCANCEL :
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kHomeUserDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					pi->iLastKeyOperation = RWZ_CANCEL_PRESSED;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
        case WM_COMMAND:
		{
			switch (wParam)
            {
#ifdef _INCLUDE_3RDPARTYLOGIC_CODE 	
              case IDC_RADIO2:
			  case IDC_RADIO1:
					if (vDialogInitialized){
					// If the 'No' button is checked, the user is declining
					// the "Non-Microsoft product" offers
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						vDeclineOffers = 1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						vDeclineOffers = 0;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					}else{
						vDeclineOffers = -1;
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
						//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
					}

				}
				break;
#endif

			  default:
				  break;
            }
		}// End of WM_COMMAND
        break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
       
}



BOOL ValidateHomeUserDialog(HWND hwndDlg,int iStrID)
{
	return TRUE;
}

void FillListEntry(HWND hwnd, int iLimit)
{
	TCHAR szTemp[20];
	SendMessage(hwnd, LB_ADDSTRING , 0, (LPARAM) " ");
	for(int i=iLimit; i > 0;i--){
		_stprintf(szTemp,_T("%d"),i);
		SendMessage(hwnd, LB_ADDSTRING , 0, (LPARAM) szTemp);
	}
	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\modem.cpp ===
/*********************************************************************
Registration Wizard

This file houses a set of functions that use TAPI to access
information about installed modems.

11/15/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation

Original source: MOS development
**********************************************************************/
#include <windows.h>
#include <mcx.h>
#include <tapi.h>
#include <devcfg.h>

#include "mcm.h"
#include "resource.h"
#include "ATK_RAS.h"

#include  "rw_common.h"


#define pcszDataModem		_T("comm/datamodem")
#define pcszWaitLineCreate	_T("MCMLineCreate")
#define PTSTR(wszID)		GetSz(hInst, wszID)
#define chBackslash		'\\'
#define irgMaxSzs		5
// Globals
static _TCHAR		szStrTable[irgMaxSzs][256];
static INT			iSzTable = 0;

MODEMSTATUS MSDetectModemTAPI(HINSTANCE hInstance);
BOOL DoInstallDialog(HINSTANCE hInstance,int nDialogType);
INT_PTR CALLBACK NoModemDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void SetWaitLineCreateEvent(void);
void CenterDlg(HWND hWnd);
PVOID PVReadRegSt(HINSTANCE hInst, WORD wiszKey, WORD wiszVal);
PVOID PVReadReg(HKEY hKeyM, HINSTANCE hInst, WORD wiszKey, WORD wiszVal);
PTSTR GetSz(HINSTANCE hInst, WORD wszID);
void CALLBACK LineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);

void CALLBACK CountryLineCallback1(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1,
										  DWORD dwParam2, DWORD dwParam3)
{

}





MODEMSTATUS MSEnsureModemTAPI(HINSTANCE hInstance,HWND hwnd)
/*********************************************************************
Ensures that a modem is installed and that tapi is setup. if not, user
will be prompted to do so.

Returns:
- kMsModemOk
- kMsModemNotFound
- kMsModemTooSlow
**********************************************************************/
{
	MODEMSTATUS			msReturnVal = kMsModemNotFound;
	do
	{
		msReturnVal = MSDetectModemTAPI(hInstance);
		if (msReturnVal != kMsModemOk)
		{	
			INT_PTR dlgReturn;
			int iDialogID = msReturnVal == kMsModemNotFound ? IDD_NOMODEM : IDD_MODEM_TOO_SLOW;
			dlgReturn = DialogBox(hInstance, MAKEINTRESOURCE(iDialogID), hwnd,
				NoModemDlgProc);
			if (!dlgReturn)
			{
				return kMsModemNotFound;
			}
			msReturnVal = MSDetectModemTAPI(hInstance);
		}
	}while (msReturnVal != kMsModemOk);
	return (msReturnVal);
}


MODEMSTATUS MSDetectModemTAPI(HINSTANCE hInstance)
/*********************************************************************
Returns:
- kMsModemOk
- kMsModemNotFound
- kMsModemTooSlow
**********************************************************************/
{
	HLINEAPP 	hLineApp;
	DWORD 		dwAPI;
	DWORD 		dwDevice;
	BOOL		fModem;
	const DWORD cMarvelBpsMin = 2400;
	MODEMSTATUS	msReturnVal = kMsModemNotFound;
	DWORD 		dwIndex = 0;
	#ifdef _LOG_IN_FILE
		RW_DEBUG  <<"\n Inside MSDetectModemTAPI "  << flush;
	#endif

	do
	{
		fModem = FGetDeviceID(hInstance, &hLineApp, &dwAPI, &dwDevice,dwIndex++);
		if (fModem)
		{
			DWORD dwSpeed;
			if (FGetModemSpeed(hInstance, dwDevice,&dwSpeed))
			{
				if (dwSpeed >= cMarvelBpsMin || 0 == dwSpeed )
				{
					msReturnVal = kMsModemOk; 	//modem speed is ok
				}
				else
				{
					msReturnVal = kMsModemTooSlow;
				}
			}
			lineShutdown(hLineApp);
		}
		
		RW_DEBUG << "\n Index:" << dwIndex << "fModem:"<<fModem <<flush;

	}while (fModem == TRUE && msReturnVal != kMsModemOk);
	return msReturnVal;
}



BOOL DoInstallDialog(HINSTANCE hInstance,int nDialogType)
/*********************************************************************
This function puts up the "Install new modem" control panel, and
returns only when the user has dismissed the dialog (either after
installing a new modem, or canceling).
Returns: FALSE if an error prevented the dialog from being displayed.
**********************************************************************/
{
	_TCHAR 				szCmdLine[128];
	STARTUPINFO 		si;
	PROCESS_INFORMATION pi;
	BOOL 				fControlProcessDone = FALSE;
	BOOL 				fProcessStatus;
	//HWND				hwndProcess;

	if(nDialogType == 1)
	{
		LoadString(hInstance,IDS_ADDMODEMCOMMAND,szCmdLine,128);
	}
	else
	{
		_tcscpy(szCmdLine,_T(""));
		LoadString(hInstance,IDS_DIALINGPROPERTIES,szCmdLine,128);
	}
	si.cb = sizeof(STARTUPINFO);
	si.lpReserved = NULL;
	si.lpDesktop = NULL;
	si.lpTitle = NULL;
	si.dwFlags = 0L;
	si.cbReserved2 = 0;
	si.lpReserved2 = NULL;
	fProcessStatus = CreateProcess(NULL,szCmdLine,NULL,NULL,FALSE,
		CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP | NORMAL_PRIORITY_CLASS,NULL,NULL,&si,&pi);
	if (fProcessStatus == FALSE)
	{
		return FALSE;
	}
	return TRUE;
}

// ======================== NoModemDlgProc ==============================

INT_PTR CALLBACK NoModemDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static fInstallModemDlgStarted = FALSE;
	static fDialingPropertiesStarted = FALSE;

	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hWnd,GWLP_HINSTANCE);
	switch (uMsg)
	{
		case WM_INITDIALOG:
			CenterDlg(hWnd);
			SetForegroundWindow(hWnd);
			return fTrue;

		case WM_ACTIVATE:
			if (wParam != 0 && fInstallModemDlgStarted == TRUE)
			{
				DoInstallDialog(hInstance,2);
				fDialingPropertiesStarted = TRUE;
				fInstallModemDlgStarted = FALSE;
			}
			
			if (wParam != 0 && fDialingPropertiesStarted == TRUE)
			{
				fDialingPropertiesStarted = FALSE;
				EndDialog(hWnd,fTrue);
			}
			break;
		case WM_CLOSE:
			EndDialog(hWnd, fFalse);
			break;
		case WM_COMMAND:
			switch (LOWORD(wParam))
				{
				case IDCANCEL:
					EndDialog(hWnd, fFalse);
					break;
				case IDYES:
					DoInstallDialog(hInstance,1);
					fInstallModemDlgStarted = TRUE;
					EnableWindow(GetDlgItem(hWnd,IDYES),FALSE);
					break;
				case IDNO:
					EndDialog(hWnd, fFalse);
					return (fTrue);
				}		
			break;
		}

	return (fFalse);
}


BOOL FGetModemSpeed(HINSTANCE hInstance, DWORD dwDevice, PDWORD pdwSpeed)
/*********************************************************************
Given a lineDevice ID in the dwDevice parameter, FGetModemSpeed
returns the operating speed of the device represented by that ID.
**********************************************************************/
{
	BOOL		fRet = fFalse;
	PSTR		pvs = NULL;
	DWORD		dwRet;

	*pdwSpeed = 0;	//7/12/94 UmeshM. Init the variable
	Try
		{
		VARSTRING	vs;
		
		vs.dwTotalSize = sizeof(vs);
		dwRet = lineGetDevConfig(dwDevice, &vs, pcszDataModem);
		if (dwRet != 0 && dwRet != LINEERR_STRUCTURETOOSMALL)
			{
			//Dprintf("linegetdevconfig = %X\n", dwRet);
			Leave;
			}

		pvs =(char *)  LocalAlloc(LPTR, vs.dwNeededSize);
		if (!pvs)
			Leave;
			
		((VARSTRING *) pvs)->dwTotalSize = vs.dwNeededSize;
		dwRet = lineGetDevConfig(dwDevice, (LPVARSTRING)  pvs, pcszDataModem);
		if (dwRet != 0)
			{
			//Dprintf("linegetdevconfig = %X\n", dwRet);
			Leave;
			}

			{
			LPDEVCFG pDevCfg = (LPDEVCFG)(pvs + sizeof(VARSTRING));
			COMMCONFIG *pConf = (COMMCONFIG*)(pvs + sizeof(VARSTRING) + sizeof(DEVCFGHDR));
			MODEMSETTINGS *pSet;
			
			pSet = (MODEMSETTINGS*)( ((char*)pConf) + pConf->dwProviderOffset);
			
			//if (FAmIOnline())
			//	*pdwSpeed = pSet->dwNegotiatedDCERate;
			//else
				*pdwSpeed = pConf->dcb.BaudRate;
			fRet = fTrue;
			}
		} // Try
		
	Finally
		{
		if (pvs)
			LocalFree(pvs);
			
		}
		
	return (fRet);
} // FGetModemSpeed()



// ======================== FGetDeviceID ==============================
BOOL FGetDeviceID(HINSTANCE hInstance, HLINEAPP *phLineApp, PDWORD pdwAPI, PDWORD pdwDevice, DWORD dwIndex)
{
	DWORD				dwDevices, iDevice, dwRet;
	LINEEXTENSIONID		ExtID;
	LINEDEVCAPS			dc, *pdc;
	PSTR				pszCL;

	DWORD				dwLocalIndex;
	#ifdef _LOG_IN_FILE
		RW_DEBUG  <<"\n Inside FGetDeviceID "  << flush;
	#endif

	//Assert(phLineApp && pdwDevice && pdwAPI);
	if ((dwRet = lineInitialize(phLineApp, hInstance, (LINECALLBACK) LineCallback, NULL, &dwDevices)) != 0)
		{
			#ifdef _LOG_IN_FILE
				RW_DEBUG  <<"\n lineInitialize Error "  << dwRet << flush;
			#endif
			return (fFalse);
		}

	pszCL = (PSTR) PVReadRegSt(hInstance, iszLoginKey, IDS_CURRENTCOMMDEV);
	*pdwDevice = INVALID_PORTID;
	dc.dwTotalSize = sizeof(LINEDEVCAPS);
	
	dwLocalIndex = 0;
	
	RW_DEBUG << "dwDevices: " << dwDevices << flush;

	for (iDevice = 0; iDevice < dwDevices; iDevice ++)
	{
		DWORD dwAPILowVersion = 0 << 16;
		DWORD dwAPIHighVersion = 3 << 16;
		
		RW_DEBUG << "\n Enter 0" << flush;
	
		dwRet = lineNegotiateAPIVersion(*phLineApp, iDevice,  dwAPILowVersion,dwAPIHighVersion, pdwAPI, &ExtID);
		dwRet |= lineGetDevCaps(*phLineApp, iDevice, *pdwAPI, 0, &dc);
		
		if (dc.dwMediaModes & LINEMEDIAMODE_DATAMODEM && dwRet == 0)
		{
			RW_DEBUG << "\ndwIndex:" <<dwIndex<< " dwLocalIndex:" << dwLocalIndex <<flush;

			if (dwLocalIndex++ == dwIndex)
			{
				RW_DEBUG << "\n Enter 2 iDevice:" << iDevice << flush;

				if (*pdwDevice == INVALID_PORTID)
					*pdwDevice = iDevice;
				
				pdc = (LINEDEVCAPS *) LocalAlloc(LPTR, dc.dwNeededSize);
				if (pdc)
				{
					RW_DEBUG << "\n Enter 3" << flush;

					pdc->dwTotalSize = dc.dwNeededSize;
					dwRet |= lineGetDevCaps(*phLineApp, iDevice, *pdwAPI, 0, pdc);
					if (pdc->dwLineNameSize > 0 && pszCL)
					{
						RW_DEBUG << "\n Enter 3" << flush;
						PSTR	pszLineName;
					
			            pszLineName = (LPSTR)(pdc) + pdc->dwLineNameOffset;
		
			            // Use if specified in registry
			            if (strcmp(pszCL, pszLineName) == 0)
							*pdwDevice = iDevice;
					}
					LocalFree(pdc);
					RW_DEBUG << "\n Exit 3" << flush;
				}
				RW_DEBUG << "\n Exit 2" << flush;
			}
			RW_DEBUG << "\n Exit 1" << flush;
		}
		RW_DEBUG << "\n Exit 0" << flush;
	}
								
	if (*pdwDevice == INVALID_PORTID)
		{ // no data modem found
			#ifdef _LOG_IN_FILE
				RW_DEBUG  <<"\n lineGetDevCaps returned INVALID_PORTID Error"  << flush;
			#endif

			lineShutdown(*phLineApp);
			return (fFalse);
		}
		
	return (fTrue);
} // FGetDeviceID()				



void CenterDlg(HWND hWnd)
{
	HWND	hwndOwner;
	RECT	rcOwner, rcDlg, rc;
	
	if (((hwndOwner = GetParent(hWnd)) == NULL) || IsIconic(hwndOwner) || !IsWindowVisible(hWnd))
		hwndOwner = GetDesktopWindow();
	GetWindowRect(hwndOwner, &rcOwner);
	GetWindowRect(hWnd, &rcDlg);
	CopyRect(&rc, &rcOwner);

	
	// Offset the owner and dialog box rectangles so that
	// right and bottom values represent the width and
	// height, and then offset the owner again to discard
	// space taken up by the dialog box.

	OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
	OffsetRect(&rc, -rc.left, -rc.top);
	OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

	// The new position is the sum of half the remaining
	// space and the owner's original position.

	SetWindowPos(hWnd,HWND_TOP, rcOwner.left + (rc.right / 2),
		rcOwner.top + (rc.bottom / 2),	0, 0, SWP_NOSIZE);
} // CenterDlg


// ======================== PVReadRegSt ==============================

PVOID PVReadRegSt(HINSTANCE hInst, WORD wiszKey, WORD wiszVal)
{
	return (PVReadReg(HKEY_CURRENT_USER, hInst, wiszKey, wiszVal));
} // PVReadRegSt()

// ======================== PVReadReg ==============================

// returns pointer to struct. REMEMBER to free the pointer(LocalFree)

PVOID PVReadReg(HKEY hKeyM, HINSTANCE hInst, WORD wiszKey, WORD wiszVal)
{
	HKEY	hKey = NULL;
	PVOID	pVal = NULL;
	DWORD	dwCb;
	BOOL	fRead = fFalse;
		

	Try
		{
		if (RegOpenKey(hKeyM, PTSTR(wiszKey), &hKey) != ERROR_SUCCESS)
			Leave;
			
		if (!(RegQueryValueEx(hKey, PTSTR(wiszVal), NULL, NULL, NULL, &dwCb) == ERROR_SUCCESS && dwCb))
			Leave;
			
		pVal = LocalAlloc(LPTR, dwCb);
		if (pVal == NULL)
			Leave;
				
		if (RegQueryValueEx(hKey, PTSTR(wiszVal), NULL,
			NULL,(LPBYTE ) pVal, &dwCb) != ERROR_SUCCESS)
			Leave;
		fRead = fTrue;
		}
		
	Finally
		{
		RegCloseKey(hKey);
		if (fRead == fFalse)
			{
				if(pVal != NULL)
				{
					LocalFree(pVal);
					pVal = NULL;
				}
			}
		}
		
	return (pVal);
} // PVReadReg()


// BEWARE uses static variable.
PTSTR GetSz(HINSTANCE hInst, WORD wszID)
{
	PTSTR	psz = szStrTable[iSzTable];
	
	iSzTable ++;
	if (iSzTable >= irgMaxSzs)
		iSzTable = 0;
		
	if (!LoadString(hInst, wszID, psz, 256))
		{	// now u could return a error but then everybody will have to check
			// the return value
		//AssertGLE(0);
		*psz = 0;
		}
		
	return (psz);
} // GetSz()


void SetWaitLineCreateEvent(void)
{
	HANDLE hEvent;

	hEvent = OpenEvent(SYNCHRONIZE, fFalse, pcszWaitLineCreate);
	if (hEvent)
		{
		SetEvent(hEvent);
		CloseHandle(hEvent);
		}
}

void CALLBACK LineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{
	switch (dwMessage)
	{
		case LINE_LINEDEVSTATE:
		{
			if (dwParam1 == LINEDEVSTATE_REINIT)
			{
				SetWaitLineCreateEvent();
			}
		}
			break;
	}
} // LineCallback

#define  MAX_RAS_DEVICES   10
#define  SZ_BUF_RET_SZ     256
//
// iModemIndex : Index of Modem Nane required, should be starting from 1 to MAX_RAS_DEVICES
//
//
TCHAR * GetModemDeviceInformation(HINSTANCE hInstance, int iModemIndex)
{

	static  TCHAR  szRetValue[MAX_RAS_DEVICES][SZ_BUF_RET_SZ]
		={	_T(""),_T(""),_T(""),
			_T(""),_T(""),_T(""),
			_T(""),_T(""),_T(""),
			_T("")};
	static  TCHAR szNoModem[] = _T("NOMODEM");
	static  int iFirstTimeCall=0;
	static  int nNoofModemDevice = 0;
		
	RASDEVINFO  *pdi,*pDevInfo;

	DWORD dwSize=0,dwNum=0,dwRet;
	int iEntries;
	int i;

	if( iModemIndex < 1 ) {
		return szNoModem;
	}
	if(iFirstTimeCall == 0 )
	{
		iFirstTimeCall = 1;
		if( ATK_IsRasDllOk() == RAS_DLL_LOADED)
		{
			dwRet = ATK_RasEnumDevices(NULL,&dwSize,&dwNum);
			iEntries = dwSize /sizeof(RASDEVINFO);
		
			pDevInfo = (LPRASDEVINFO)LocalAlloc(LPTR,dwSize);

            if (pDevInfo)
            {
			    pdi = pDevInfo;
			    
			    for(i=0; i< iEntries;i++) {
				    pdi->dwSize = sizeof(RASDEVINFO);
				    pdi++;
			    }
			    dwRet = ATK_RasEnumDevices(pdi,&dwSize,&dwNum);
			    if(dwRet == 0)
			    {
			    
				    for(i=0; i< iEntries;i++)
				    {
					    #ifdef _LOG_IN_FILE
						    RW_DEBUG << "\n Device Name:"<< ConvertToANSIString(pdi->szDeviceName) << flush;
						    RW_DEBUG << "\n Device Type:"<< ConvertToANSIString(pdi->szDeviceType) << flush;
					    #endif

						    if( !_tcscmp(pdi->szDeviceType, RASDT_Modem) )
						    {
							    _tcscpy(szRetValue[nNoofModemDevice],pdi->szDeviceName);
							    nNoofModemDevice++;
							    //i=iEntries+1;
						    }
					    pdi++;
				    }
			    }
			    else
			    {
				    switch(dwRet)
				    {
					    case ERROR_BUFFER_TOO_SMALL:
						    RW_DEBUG <<"\n ERROR_BUFFER_TOO_SMALL"<< flush;
						    break;
					    case ERROR_NOT_ENOUGH_MEMORY:
						    RW_DEBUG <<"\n ERROR_NOT_ENOUGH_MEMORY"<< flush;
						    break;
					    case ERROR_INVALID_PARAMETER:
						    RW_DEBUG <<"\n ERROR_INVALID_PARAMETER"<< flush;
						    break;
					    case ERROR_INVALID_USER_BUFFER :
						    RW_DEBUG <<"\n ERROR_INVALID_USER_BUFFER"<< flush;
						    break;
					    default:
						    RW_DEBUG <<"\n UNKNOWN_ERROR"<< flush;
						    break;
				    }

			    }
			    LocalFree(pDevInfo);
            }
		}
		else
		{
			return szNoModem;
		}	
	}

	// Return the  modem device name
	if( iModemIndex  > nNoofModemDevice ) {
			return szNoModem;
	}else {
			return &szRetValue[iModemIndex-1][0];
	}
		
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\informdlg.cpp ===
/*********************************************************************
Registration Wizard

InformDialog.cpp
10/19/94 - Tracy Ferrier
02/11/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include "RegWizMain.h"
#include "Resource.h"
#include <RegPage.h>
#include "Dialogs.h"
#include "regutil.h"
#include <rw_common.h>

INT_PTR CALLBACK InformDialogProc(HWND hwndDlg, 
					   UINT uMsg, 
					   WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that presents the
Product Identification number to the user.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {
		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				

        case WM_INITDIALOG:
		{
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;

			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			//SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			ReplaceDialogText(hwndDlg,IDT_TEXT2,szInfo);
			return TRUE;
		}
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					pi->CurrentPage++;
				}
				break;

            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet =0;
					iRet = 1;
					pi->ErrorPage  = kInformDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
        default:
		bStatus = FALSE;
         break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\invdlg.cpp ===
/*********************************************************************
Registration Wizard

InventoryDialog.cpp
10/21/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
07/20/98 -  Modified as System Inventory items to be displayed using ListView control
		    and added an Edit control for Computer Manufacturer and Model entry
			EnabelOrDisableSIItems() function sets the flag if the SI info need
			to be sent to the backend

(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "RegPage.h"
#include "regwizmain.h"
#include "resource.h"
#include "dialogs.h"
#include "regutil.h"
#include <sysinv.h>
#include <rw_common.h>

//#include <windowsx.h>
#include <commctrl.h>

// ListVive control related supporting functions
HWND CreateListView(HINSTANCE hInstance,
					HWND hwndParent,
					RECT *pRect);

void AddIconToListView(HINSTANCE hInstance, HWND hwndListView);
BOOL InitListViewHeaders(HINSTANCE hInstance, HWND hwndListView);
BOOL AddSI_ItemsToListView(HWND hwndSIListView, CRegWizard* pRegWizard);
void ConfigureSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);

void ConfigureSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateSIDialog(CRegWizard* pclRegWizard,HWND hwndDlg);
int ValidateSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);

//
void EnabelOrDisableSIItems( BOOL bAction, CRegWizard* pclRegWizard);

void DestroyListViewResources();



#define NO_OF_SI_ITEMS          13
#define NUMBER_OF_SI_ICONS		5
#define NO_SI_ICONS_FORFUTURE   1
#define  MAX_NO_SI_COLUMNS                       2 // Number of columns
#define  MAX_COLUMNITEM_DESCRIPTION_LEN          25 // Length of Description item on header

//
// Global and Static variables

static HIMAGELIST  himlSmall = NULL;
static HIMAGELIST  himlLarge =NULL;

//  This structure that maps the Device Name in the resource with the ICON and corrosponding
//  index in RegWiz to get the Device Description
//
//
typedef struct  SIItemMapping{
	int iResIndexForDevice;
	int iIconIndex;
	InfoIndex  iIndexToGetDeviceDescription;
} _SIItemMapping ;

static _SIItemMapping  SITable[NO_OF_SI_ITEMS]= {
	{IDS_INFOKEY13,0,kInfoProcessor},// Processor
	{IDS_INFOKEY15,1,kInfoTotalRAM}, // Total RAM
	{IDS_INFOKEY16,2,kInfoTotalDiskSpace}, // Total HardDisk Space
	{IDS_INFOKEY17,3,kInfoRemoveableMedia}, // Removable Media
	{IDS_INFOKEY18,4,kInfoDisplayResolution}, // Display Resolution
	{IDS_INFOKEY20,5,kInfoPointingDevice}, // Pointing Device
	{IDS_INFOKEY21,6,kInfoNetwork}, // Network
	{IDS_SCSI_ADAPTER,7,kScsiAdapterInfo}, // SCSI
	{IDS_INFOKEY22,8,kInfoModem}, // Modem
	{IDS_INFOKEY23,9,kInfoSoundCard}, // SoundCard
	{IDS_INFOKEY24,10,kInfoCDROM}, // CD ROM
	{IDS_INFOKEY25,11,kInfoOperatingSystem},  // Operating System
	{IDS_COMPUTER_MODEL,12,kComputerManufacturer}  // Operating System
};

INT_PTR
CALLBACK
SystemInventoryDialogProc(
                          HWND hwndDlg,
                          UINT uMsg,
                          WPARAM wParam,
                          LPARAM lParam
                          )
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that displays system
inventory information, such as processor type, RAM, display type,
network type, etc.
**********************************************************************/
{

      _TCHAR  szInventory[256];
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
	static HBITMAP fHBitmap = NULL;
	static int iMaxLabelWidth = 0;
	static BOOL fMaxWidthCalcDone = FALSE;
	static int iShowThisPage= DO_SHOW_THIS_PAGE;
	TriState shouldInclude;

	HWND hSI;
	RECT SIRect;
	RECT SICRect,DlgRect,CliDlgRect;
	HWND	hwndSIListView;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}
	

    switch (uMsg)
    {
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			if(fHBitmap) {
				DeleteObject(fHBitmap);
			}
			fHBitmap = NULL;
			break;
		case WM_CLOSE:
			 break;			
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			//
			// Check if System Inv DLL is present
			if( CheckSysInvDllPresent() != SYSINV_DLL_PRESENT) {
				iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
			}


			if(iShowThisPage== DO_SHOW_THIS_PAGE) {
				 GetModemString(pclRegWizard->GetInstance(),szInventory);
				 pclRegWizard->SetInformationString(kInfoModem,szInventory);
				 fHBitmap = LoadBitmap(pclRegWizard->GetInstance(),MAKEINTRESOURCE(IDB_SYSINV_ICONS));
				 NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
				 NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
				 NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
				 NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
				 NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
				 NormalizeDlgItemFont(hwndDlg,IDC_RADIO1);
				 NormalizeDlgItemFont(hwndDlg,IDC_RADIO2);
				 SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());
				 hwndSIListView = GetDlgItem(hwndDlg,IDC_LIST1);
				 AddIconToListView(pclRegWizard->GetInstance(), hwndSIListView);
				if(!hwndSIListView) {
						// Error in creating List view control  so skip to the next page
						// This a system error which should occure
					iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
				}else {
					// Add SI entries
					InitListViewHeaders(pclRegWizard->GetInstance(), hwndSIListView);
					AddSI_ItemsToListView(hwndSIListView,
							pclRegWizard);
					//ConfigureSIEditFields(pclRegWizard,hwndDlg);
				}
				
			}
			

   	        vDialogInitialized = TRUE;
            return TRUE;
		} // WM_INIT
		break;
		
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				if( iShowThisPage== DO_NOT_SHOW_THIS_PAGE ) {
					pclRegWizard->SetTriStateInformation(kInfoIncludeSystem,kTriStateFalse);
					pi->iCancelledByUser = RWZ_SKIP_AND_GOTO_NEXT;
					if( pi->iLastKeyOperation == RWZ_BACK_PRESSED){
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_BACK);
					}else {
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
					}

				}
				else {
					pi->iCancelledByUser = RWZ_PAGE_OK;
					pi->iLastKeyOperation = RWZ_UNRECOGNIZED_KEYPESS;
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK);

					shouldInclude = pclRegWizard->GetTriStateInformation(kInfoIncludeSystem);
					RW_DEBUG << "INV DLG  ; ACTIVE  " << shouldInclude << flush;
					if (shouldInclude == kTriStateTrue ){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					else if (shouldInclude == kTriStateFalse){
						CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					else if (shouldInclude == kTriStateUndefined){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK);
			
					}
					//
					// Enable for previpously entred value in screen
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
						PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					}
					/*
					//
					// Init Computer Model Field
					if (pclRegWizard->GetInformationString(kComputerManufacturer,szInfo)){
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
					}*/

				}

                break;

            case PSN_WIZNEXT:
					switch(pi->iCancelledByUser) {
					case  RWZ_CANCELLED_BY_USER :
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					break;
					case RWZ_PAGE_OK:
						iRet=0;
					/*	if( ValidateInvDialog(hwndDlg,IDS_BAD_SYSINV) &&
							ValidateSIDialog(pclRegWizard,hwndDlg))*/
						if( ValidateInvDialog(hwndDlg,IDS_BAD_SYSINV))
						{
							BOOL yesChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
							BOOL noChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
							if (yesChecked){
								//pclRegWizard->WriteEnableSystemInventory(TRUE);
								// send info to backend
								EnabelOrDisableSIItems(TRUE,pclRegWizard);
								pclRegWizard->SetTriStateInformation(kInfoIncludeSystem,kTriStateTrue);
							}else if (noChecked){
								//pclRegWizard->WriteEnableSystemInventory(FALSE);

								// Do not send to the back end
								EnabelOrDisableSIItems(FALSE,pclRegWizard);
								pclRegWizard->SetTriStateInformation(kInfoIncludeSystem,kTriStateFalse);
							}
						/*
							// Get Computer Model Information
							SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
							pclRegWizard->SetInformationString(kComputerManufacturer,szInfo);
							RW_DEBUG << "\n Computer Model " << szInfo << flush;
*/
							pi->CurrentPage++;
							pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						// Set as Next Key Button Pressed
						}else {
						// Force it it be in this screen
							iRet=-1;
						}
						SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
					break;
					case RWZ_SKIP_AND_GOTO_NEXT:
					default:
						// Do not Validate the page and just go to the next page
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;

					break;
				} // end of switch pi->iCancelledByUser
				break;
            case PSN_WIZBACK:
                pi->CurrentPage--;
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
				break;
			case PSN_QUERYCANCEL :
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kSysInventoryDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					pi->iLastKeyOperation = RWZ_CANCEL_PRESSED;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
        case WM_COMMAND:
		{
			switch (wParam)
            {
              case IDC_RADIO2:
			  case IDC_RADIO1:
					if (vDialogInitialized){
						// If the 'No' button is checked, the user is declining
						// the "Non-Microsoft product" offers
						if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						}
						if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
						}
					}
				break;
			  default:
				  break;
            }
		}// End of WM_COMMAND
        break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;

}



BOOL ValidateInvDialog(HWND hwndDlg,int iStrID)
/*********************************************************************
This function checks the two radio buttons in the System Inventory or
Product Inventory dialog boxes.  If neither button is selected,
ValidateInvDialog will put up a validation error dialog, and return
FALSE as the function result; otherwise, TRUE will be returned.

If an error dialog is presented, the string whose resource ID is
passed in the iStrID parameter will displayed in the dialog text
field.
**********************************************************************/
{
	BOOL isYesChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1) == 1 ? TRUE : FALSE;
	BOOL isNoChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2) == 1 ? TRUE : FALSE;

	if (isYesChecked == TRUE || isNoChecked == TRUE)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szMessage[256];
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadString(hInstance,iStrID,szMessage,256);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		return FALSE;
	}
	


}







//
//
//
//
HWND CreateListView(HINSTANCE hInstance,
					HWND hwndParent,
					RECT *pRect)
{
	DWORD       dwStyle;
	HWND        hwndListView;
	HIMAGELIST  himlSmall;
	HIMAGELIST  himlLarge;
	BOOL        bSuccess = TRUE;
	dwStyle =   WS_TABSTOP  |
				WS_CHILD |
				WS_BORDER |
				LVS_REPORT |//LVS_LIST |
                LVS_SHAREIMAGELISTS | // LVS_NOCOLUMNHEADER |
				WS_VISIBLE;

	hwndListView = CreateWindowEx( WS_EX_CLIENTEDGE | WS_EX_TOPMOST,          // ex style
                                   WC_LISTVIEW,               // class name - defined in commctrl.h
                                   NULL,                      // window text
                                   dwStyle,                   // style
                                   pRect->left,                         // x position
                                   pRect->top,
								   pRect->right,
								   pRect->bottom,
								  //pRect->right - pRect->left, // width
								  //pRect->bottom - pRect->top,//  height
                                   hwndParent,                // parent
                                   (HMENU) IDC_LIST1,       // ID
                                   hInstance,                // instance
                                 NULL);                     // no extra data

   if(!hwndListView)
   return NULL;
	
   AddIconToListView(hInstance, hwndListView);
   return hwndListView;

}


void AddIconToListView( HINSTANCE hInstance, HWND hwndListView )
{
	HICON hIconItem;

	himlSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
		GetSystemMetrics(SM_CYSMICON),TRUE,NUMBER_OF_SI_ICONS,
		NO_SI_ICONS_FORFUTURE);

	himlLarge = ImageList_Create(GetSystemMetrics(SM_CXICON),
		GetSystemMetrics(SM_CYICON),TRUE,NUMBER_OF_SI_ICONS,
		NO_SI_ICONS_FORFUTURE);


	// Add Icon to image List
	for (int i=0; i <NO_OF_SI_ITEMS ;i++ ) {
		hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_SIICON1+i));
		ImageList_AddIcon(himlSmall,hIconItem);
		ImageList_AddIcon(himlLarge,hIconItem);
		DeleteObject(hIconItem );
	}
/***
	hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_BADREGWIZ));
	ImageList_AddIcon(himlSmall,hIconItem);
	ImageList_AddIcon(himlLarge,hIconItem);
	DeleteObject(hIconItem );

	hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WORLD));
	ImageList_AddIcon(himlSmall,hIconItem);
	ImageList_AddIcon(himlLarge,hIconItem);
	DeleteObject(hIconItem );

	hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ENVELOPE));
	ImageList_AddIcon(himlSmall,hIconItem);
	ImageList_AddIcon(himlLarge,hIconItem);
	DeleteObject(hIconItem );

	hIconItem =  LoadIcon(hInstance, MAKEINTRESOURCE(IDI_REGWIZ));
	ImageList_AddIcon(himlSmall,hIconItem);
	ImageList_AddIcon(himlLarge,hIconItem);
	DeleteObject(hIconItem );
	**/
	
	// Assign  the image lists  to the list view control
	ListView_SetImageList(hwndListView, himlSmall, LVSIL_SMALL);
	ListView_SetImageList(hwndListView, himlLarge, LVSIL_NORMAL);

}

BOOL InitListViewHeaders(HINSTANCE hInstance, HWND hwndListView)
{
	LV_COLUMN   lvColumn;
	RECT         CliRect;
	int         i = 0;
	TCHAR       szString[MAX_NO_SI_COLUMNS][MAX_COLUMNITEM_DESCRIPTION_LEN] =
	{	 TEXT("Device"),
		 TEXT("Description")
	};

	LoadString(hInstance,IDS_SI_DEVICENAME, szString[0],MAX_COLUMNITEM_DESCRIPTION_LEN);
	LoadString(hInstance,IDS_SI_DEVICEDESCRIPTION, szString[1],MAX_COLUMNITEM_DESCRIPTION_LEN);
	//initialize the columns
	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvColumn.fmt = LVCFMT_LEFT;
	//lvColumn.cx = 100;
	GetClientRect(hwndListView,&CliRect);

	lvColumn.cx = 133;
	lvColumn.pszText = szString[0];
	SendMessage(hwndListView, LVM_INSERTCOLUMN, (WPARAM)i, (LPARAM)&lvColumn);
	
	i = 1;
	lvColumn.cx = CliRect.right - 149;
	lvColumn.pszText = szString[1];
	SendMessage(hwndListView, LVM_INSERTCOLUMN, (WPARAM)i, (LPARAM)&lvColumn);

   return TRUE;

}



/********************************************************************************

   AddSI_ItemsToLIstVIew
   This function adds the SI items in the list view

******************************************************************************/

BOOL AddSI_ItemsToListView( HWND hwndListView, CRegWizard* pclRegWizard)
{
	LV_ITEM     lvItem;
	int         i,nImageCount;
	TCHAR       szTempDevice[MAX_PATH];
				

	HIMAGELIST  himl;
	IMAGEINFO   ii;
	HINSTANCE hInstance;
	BOOL bOemInfoPresent = TRUE;

	 hInstance = pclRegWizard->GetInstance();

	// SendMessage(hwndListView, WM_SETREDRAW, FALSE, 0);
	//empty the list
	SendMessage(hwndListView, LVM_DELETEALLITEMS, 0, 0);
	//get the number of icons in the image list
	himl = (HIMAGELIST)SendMessage(hwndListView, LVM_GETIMAGELIST, (WPARAM)LVSIL_SMALL, 0);
	nImageCount = ImageList_GetImageCount(himl);
	for(i = 0; i < NO_OF_SI_ITEMS ; i++) {
		// Get Device Name
		LoadString(hInstance,SITable[i].iResIndexForDevice, szTempDevice, 256);
		//fill in the LV_ITEM structure for the first item
		lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
		lvItem.pszText = szTempDevice;
		lvItem.iImage = SITable[i].iIconIndex;
		lvItem.iItem = (INT)SendMessage(hwndListView, LVM_GETITEMCOUNT, 0, 0);
		lvItem.iSubItem = 0;
	   //add the item - get the index in case the ListView is sorted
		SendMessage(hwndListView, LVM_INSERTITEM, (WPARAM)0, (LPARAM)&lvItem);

	   //GetDevice Description
		if(!pclRegWizard->GetInformationString(SITable[i].iIndexToGetDeviceDescription,
			szTempDevice))
		{
			if(i == 12)
			{
				bOemInfoPresent = FALSE;
			}

			LoadString(hInstance,IDS_SYSINV_NOTFOUND,szTempDevice, 256);
		}
		lvItem.iSubItem = 1;
		SendMessage(hwndListView, LVM_SETITEM, 0, (LPARAM)&lvItem);
		
   	}
	
	if(!bOemInfoPresent)
	{
		ListView_DeleteItem(hwndListView,12);
	}

	SendMessage(hwndListView, WM_SETREDRAW, TRUE, 0);
	UpdateWindow(hwndListView);
	//EnableWindow(hwndListView, FALSE);
	return TRUE;
}


//
//  This function should be called before exiting RegWiz this will release the resources allocated
//  for list view control (image list)
//
//
void DestroyListViewResources()
{
	if(himlSmall) {
		ImageList_Destroy(himlSmall);
		himlSmall = NULL;
	}
	if(himlLarge) {
		ImageList_Destroy(himlLarge);
		himlLarge = NULL;
	}

}

//
//    bAction : TRUE  ( Enabel send info to  backend)
//              FALSE ( Do not send info to backend )
//
//

void EnabelOrDisableSIItems( BOOL bAction, CRegWizard* pclRegWizard)
{

	int iIndex;
	// Itens in the List View Control
	for(iIndex = 0; iIndex < NO_OF_SI_ITEMS ; iIndex++) {
		pclRegWizard->WriteEnableInformation(SITable[iIndex].iIndexToGetDeviceDescription,
			bAction);

	}
	// Computer Model
//	pclRegWizard->WriteEnableInformation(kComputerManufacturer, bAction);

}

//BOOL ValidateSIDialog(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Address
dialog.  If any required edit field input is empty, ValidateAddrDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
/*{
	int iInvalidEditField = ValidateSIEditFields(pclRegWizard,hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szLabel[128];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szLabel,128);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szLabel,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndInvField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndInvField);
		return FALSE;
	}
}*/


//int ValidateSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
ValidateFEAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the first empty
edit field control will be returned as the function result.  If all
fields are OK, NULL will be returned.
**********************************************************************/
/*{

	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1;
	return NULL;
}


void ConfigureSIEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
{
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kSIComputerManufacturer,IDC_COMPUTER_MODEL);
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\msgdlg.cpp ===
/*********************************************************************
Registration Wizard

msgdlg.cpp
11/22/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include "Resource.h"
#include "regutil.h"
#include <stdio.h>
#include "sysinv.h"

#define REPLACE_TITLE	     0
#define RETAIN_DEFAUT_TITLE  1

extern _TCHAR szWindowsCaption[256];

static INT_PTR CALLBACK MsgDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static int iShowTitle =REPLACE_TITLE;

int RegWizardMessage(HINSTANCE hInstance,HWND hwndParent, int dlgID)
/*********************************************************************
Puts up the dialog box with the given ID, and maintains control until
the user dismisses it.  The ID of the control used for the dismissal
will be returned as the function result.

Note: pass NULL for hwndParent if there is to be no parent window
for the message dialog.
**********************************************************************/
{
	iShowTitle =REPLACE_TITLE;
	if(dlgID == IDD_INPUTPARAM_ERR ||
		dlgID == IDD_ANOTHERCOPY_ERROR ) {
		iShowTitle = RETAIN_DEFAUT_TITLE;
	}
	int hitButton = (int) DialogBoxParam(hInstance,MAKEINTRESOURCE(dlgID),hwndParent, MsgDialogProc, NULL);
	return hitButton;
}


int RegWizardMessageEx(HINSTANCE hInstance,HWND hwndParent, int dlgID, LPTSTR szSub)
/*********************************************************************
Puts up the dialog box with the given ID, and maintains control until
the user dismisses it.  The ID of the control used for the dismissal
will be returned as the function result.

If the specified dialog has a text field with IDT_TEXT1, and the
text within that field has a %s specifier, that specifier will be
replaced with the string pointed to by the szSub parameter.

Note: pass NULL for hwndParent if there is to be no parent window
for the message dialog.
**********************************************************************/
{
	iShowTitle =REPLACE_TITLE;
	int hitButton = (int) DialogBoxParam(hInstance,MAKEINTRESOURCE(dlgID),hwndParent, MsgDialogProc,(LPARAM) szSub);
	return hitButton;
}



INT_PTR CALLBACK MsgDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Proc for a standard "message" dialog box.
**********************************************************************/
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
		{
			RECT parentRect,dlgRect;
			HWND hwndParent = GetParent(hwndDlg);
			if (hwndParent)
			{
				GetWindowRect(hwndParent,&parentRect);
				GetWindowRect(hwndDlg,&dlgRect);
				int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hwndDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			else
			{
				int horiz,vert;
				GetDisplayCharacteristics(&horiz,&vert,NULL);
				GetWindowRect(hwndDlg,&dlgRect);
				int newX = horiz/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = vert/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hwndDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);

			if( iShowTitle ==REPLACE_TITLE )
			SetWindowText(hwndDlg,szWindowsCaption);

			if (lParam != NULL)
			{
				LPTSTR szSub = (LPTSTR) lParam;
				ReplaceDialogText(hwndDlg,IDT_TEXT1,szSub);
			}
            return TRUE;
		}
        case WM_COMMAND:
			EndDialog(hwndDlg,wParam);
			break;
        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\namedlg.cpp ===
/*********************************************************************
Registration Wizard

NameDialog.cpp
10/13/94 - Tracy Ferrier
02/11/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
Modification History :
	MDX1 :   Suresh
	Date    : 2/12/99
	Function: Modified in void ConfigureNameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
	Reason	: The Middle name is set to Null, This looks like the filed validation is not taking
	from the Resoure settings for each TAPI id
**********************************************************************/

#include <Windows.h>
#include "RegPage.h"
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "rw_common.h"

typedef enum
{
	kPurchaseUndefined,
	kPurchaseBySelf,
	kPurchaseByCompany
}PurchaseType;

static PurchaseType vPurchaseType = kPurchaseUndefined;
void ConfigureNameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateNameDialog(HWND hwndDlg);
int ValidateNameEditFields(HWND hwndDlg);
BOOL GetDefaultCompanyName(CRegWizard* pclRegWizard,LPTSTR szValue);

INT_PTR CALLBACK NameDialogProc(	HWND hwndDlg,
								UINT uMsg,
								WPARAM wParam,
								LPARAM lParam )
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the
user's name and company.
**********************************************************************/
{
	CRegWizard* pclRegWizard = NULL;
	static INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;		
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;			
        case WM_INITDIALOG:
		{
			_TCHAR szCallingContext[64];
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			RW_DEBUG << "\n  INIT DIALOG " << pi->iCancelledByUser << flush;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);

			//UpgradeDlg(hwndDlg);
			
			HWND hwndNameField = GetDlgItem(hwndDlg,IDC_EDIT1);
			SetFocus(hwndNameField);
			NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT12);
			NormalizeDlgItemFont(hwndDlg,IDC_GROUP1);
			
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szCallingContext);
			ReplaceDialogText(hwndDlg,IDT_TEXT1,szCallingContext);
			
			if (pclRegWizard->GetInformationString(kInfoFirstName,szInfo)){
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
				vPurchaseType = kPurchaseBySelf;
			}
			
			if (pclRegWizard->GetInformationString(kInfoLastName,szInfo)){
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
				vPurchaseType = kPurchaseBySelf;
			}
			if (pclRegWizard->GetInformationString(kMiddleName,szInfo)){
				SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			OutputDebugString(_T("\n Middle Name "));
			OutputDebugString(szInfo);

			if (pclRegWizard->GetInformationString(kInfoEmailName,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			OutputDebugString(_T("\n Email "));
			OutputDebugString(szInfo);

			BOOL isCompanyNameValid = FALSE;
			if (pclRegWizard->GetInformationString(kInfoCompany,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
				if (szInfo[0])
				{
					isCompanyNameValid = TRUE;
					vPurchaseType = kPurchaseByCompany;
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
					EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT3),TRUE);
					EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT4),TRUE);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
				}
				else
				{
					vPurchaseType = kPurchaseBySelf;
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT3),FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT4),FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
				}
			}
			else
			{
				if(	vPurchaseType != kPurchaseBySelf)
				{
					vPurchaseType = kPurchaseUndefined;
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
				}
				else
				{
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
				}
			}

			SendDlgItemMessage(hwndDlg,IDC_EDIT1,EM_SETSEL,0,-1);
			ConfigureNameEditFields(pclRegWizard,hwndDlg);
			vDialogInitialized = TRUE;
			//pclRegWizard->ActivateRegWizardDialog();
            return TRUE;
		}
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
				// Cancel is not Pressed
					iRet=0;
					if( ValidateNameDialog(hwndDlg)) {
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoFirstName,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoLastName,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCompany,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kMiddleName,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT5,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoEmailName,szInfo);
						pclRegWizard->WriteEnableInformation(kInfoCompany,vPurchaseType == kPurchaseBySelf ? FALSE : TRUE);
						pclRegWizard->EndRegWizardDialog(wParam);
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						pi->CurrentPage++;
					
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
				}
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kNameDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        }
        break;
		case WM_COMMAND:{
            if (vPurchaseType == kPurchaseUndefined){
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
            }
            BOOL selfChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
            BOOL companyChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
            if (selfChecked)
            {
                vPurchaseType = kPurchaseBySelf;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
            }
            else if (companyChecked)
            {
                vPurchaseType = kPurchaseByCompany;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                // EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
            }
            BOOL shouldEnable = vPurchaseType == kPurchaseByCompany ? TRUE : FALSE;
            HWND hwndCompanyField = GetDlgItem(hwndDlg,IDC_EDIT3);
            HWND hwndCompanyLabel = GetDlgItem(hwndDlg,IDT_TEXT4);
            if (IsWindowEnabled(hwndCompanyField) != shouldEnable)
            {
                EnableWindow(hwndCompanyField,shouldEnable);
                EnableWindow(hwndCompanyLabel,shouldEnable);
                if(!shouldEnable)
                {
                    SetDlgItemText(hwndDlg,IDC_EDIT3,_T(""));
                }
                else
                {
                    SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,
                                                            (LPARAM) szInfo);
                    if(!szInfo[0])
                    {
                        if(GetDefaultCompanyName(pclRegWizard,szInfo))	
                        {
                            SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,
                                                        255,(LPARAM) szInfo);
                        }
                    }
                }
            }
		 }// WM_COMMAND
		break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}


BOOL GetDefaultCompanyName(CRegWizard* pclRegWizard,LPTSTR szValue)
{
	HKEY hKey;
	_TCHAR szKeyName[256];
	
	pclRegWizard->GetRegKey(szKeyName);	
	
	DWORD dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_READ,&hKey);

	if (dwStatus == ERROR_SUCCESS)
	{
	  _TCHAR szValueName[64];
	  unsigned long infoSize = 255;
	  LoadString(pclRegWizard->GetInstance(),IDS_COMPANY_NAME,szValueName,64);
	  dwStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
	  if (dwStatus == ERROR_SUCCESS)
	  {
		return TRUE;
	  }
	}
	return FALSE;
}

BOOL ValidateNameDialog(HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Name
dialog.  If any required edit field input is empty, ValidateNameDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateNameEditFields(hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szAttached[256];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szAttached,256);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szAttached,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndNameField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndNameField);
		return FALSE;
	}
}



int ValidateNameEditFields(HWND hwndDlg)
/*********************************************************************
ValidateAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the edit field
control will be returned as the function result.  If all fields are
OK, NULL will be returned.
**********************************************************************/
{
	
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT4)) return IDC_EDIT4;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT5)) return IDC_EDIT5;
	return NULL;
}

 
void ConfigureNameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecFirstName,IDT_TEXT2);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecLastName,IDT_TEXT3);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecCompanyName,IDT_TEXT4);
	//pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT4,kAddrMiddleName,IDT_TEXT5);	
	// comented on 2/12/99  to take Middle initial
	// MDX1
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT5,kAddrSpecEmailName,IDT_TEXT12);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\regpage.cpp ===
/*
	File 	: RegPage.CPP
	Date 	: 02/11/98
	Author 	: Suresh Krishnan
	
	Registration Wizard Page Control using Wizard 97 control
	
	This file exposes
	DoRegistrationWizard () which creates the necessary screen pages for RegWIz
	Modification History:
	4/29/98 : Removed Reseller screen as per Microsoft Request
	4/28/98 : Added Business user and Homer user screen

*/
#include <tchar.h>
#include <Windows.h>
#include <Resource.h>
#include <rw_common.h>
#include <fe_util.h>
#include "RegWizMain.h"
#include "RegPage.h"

BOOL bPostSuccessful = FALSE;

UINT CALLBACK DefaultPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);
UINT CALLBACK AddressPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);
UINT CALLBACK AddressFEPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);
UINT CALLBACK ResellerPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);
UINT CALLBACK RegisterPropSheetPageProc(HWND hwnd,UINT uMsg, LPPROPSHEETPAGE ppsp);

INT_PTR CALLBACK WizardDlgProc(IN HWND     hwnd,IN UINT     uMsg,IN WPARAM   wParam,IN LPARAM   lParam);
extern INT_PTR  CALLBACK WelcomeDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK InformDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
extern INT_PTR  CALLBACK NameDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK NameFEDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK AddressDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK AddressFEDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK ResellerDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK SystemInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK ProdInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK RegisterDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK DialupScreenProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK FinalScreenDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
//extern INT_PTR  CALLBACK FinalFailedScreenDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK BusinessUserDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
extern INT_PTR  CALLBACK HomeUserDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);

typedef struct RegWizPageInfo{
	DLGPROC		pfnCallback;
	LPFNPSPCALLBACK  pfnPropSheetProc;
	WORD            wDlgId;
	WORD			wTitle;
	WORD			wSubTitle;
}_RegWizPageInfo;

RegWizPageInfo RwPgInf[] = {
{WelcomeDialogProc,DefaultPropSheetPageProc, IDD_WELCOME_FOR98,IDS_WELCOME_SCR_TITLE,IDS_WELCOME_SCR_STITLE}, // Welcome Screen
{InformDialogProc,DefaultPropSheetPageProc,IDD_INFORM, IDS_INFORM_SCR_TITLE,IDS_INFORM_SCR_STITLE},  // Inform Screen
{NameDialogProc,DefaultPropSheetPageProc,IDD_NAME,  IDS_NAME_SCR_TITLE,IDS_NAME_SCR_STITLE},  // Name Screen
{AddressDialogProc,AddressPropSheetPageProc ,IDD_ADDRESS,		IDS_ADDRESS_SCR_TITLE,IDS_ADDRESS_SCR_STITLE},  // Address Screen
//{ResellerDialogProc,ResellerPropSheetPageProc,IDD_RESELLER ,  IDS_RESELLER_SCR_TITLE,IDS_RESELLER_SCR_STITLE},  // Reseller Screen
{BusinessUserDialogProc,DefaultPropSheetPageProc,IDD_BUSINESS_QUESTIONS ,  IDS_BUSINESSUSER_SCR_TITLE,IDS_BUSINESSUSER_SCR_STITLE},  // Business User Screen
{HomeUserDialogProc,DefaultPropSheetPageProc,IDD_HOME_QUESTIONS ,  IDS_HOMEUSER_SCR_TITLE,IDS_HOMEUSER_SCR_STITLE},  // Home user  Screen
{SystemInventoryDialogProc,DefaultPropSheetPageProc,IDD_INVENTORY,		IDS_SYSINV_SCR_TITLE,IDS_SYSINV_SCR_STITLE},  // Sys Inv Screen
{ProdInventoryDialogProc,DefaultPropSheetPageProc,IDD_PRODINVENTORY, IDS_PRODINV_SCR_TITLE,IDS_PRODINV_SCR_STITLE},  // Product Inventory Screen
{RegisterDialogProc,RegisterPropSheetPageProc,IDD_REGISTER, IDS_REGISTER_SCR_TITLE,IDS_REGISTER_SCR_STITLE},  // Register Screen
{DialupScreenProc,DefaultPropSheetPageProc,IDD_DIAL, IDS_DIALUP_SCR_TITLE,IDS_DIALUP_SCR_STITLE}  // Dialup Screen

};

RegWizPageInfo RwFEPgInf[] = {
{NameFEDialogProc,DefaultPropSheetPageProc,IDD_NAME_FE,  IDS_NAME_SCR_TITLE,IDS_NAME_SCR_STITLE},  // Name Screen
{AddressFEDialogProc,AddressFEPropSheetPageProc ,IDD_ADDRESS_FE,		IDS_ADDRESS_SCR_TITLE,IDS_ADDRESS_SCR_STITLE},  // Address Screen

};


//
//  Default Property Sheet Procedure called during Property Sheet creatinion
//  and deletion
//
//
//
UINT CALLBACK DefaultPropSheetPageProc(HWND hwnd,
								UINT uMsg,
								LPPROPSHEETPAGE ppsp
								)
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
	default:
		break;

	}
	return 1;

}

INT_PTR DoRegistrationWizard(HINSTANCE hInstance,
						  CRegWizard* pclRegWizard,
						  LPTSTR szProductPath)

{
    UINT				iPage;
	UINT			kNumPages           = kDialogExit+1;
	INT_PTR			iError;

	UINT            i                   = 0;
    BOOL            bStatus             = TRUE;
    PageInfo        PageInfo            = {0};
    PROPSHEETPAGE   psp                 = {0};
    HPROPSHEETPAGE  *ahpsp;
    PROPSHEETHEADER psh                 = {0};

	iError = RWZ_ERROR_CANCELLED_BY_USER;

	#ifdef _LOG_IN_FILE
		 RW_DEBUG  << "\n INFORM DIALOG HEADER"<< flush;
	#endif

	// Allocate and initialize
    ahpsp = (HPROPSHEETPAGE *) GlobalAlloc( GMEM_FIXED, sizeof( HPROPSHEETPAGE) *
										kNumPages);

	for(iPage=0;iPage < kNumPages;iPage++) {
		ahpsp[iPage] = 0;			
	}
	iPage = 0;
	// Create Welcome Page
	psp.pfnCallback         = DefaultPropSheetPageProc;
	psp.dwSize              = sizeof( psp );
    psp.dwFlags             = PSP_DEFAULT;
    psp.hInstance           = hInstance;
    psp.lParam              = (LPARAM)&PageInfo;
	psp.pfnDlgProc          = WelcomeDialogProc;
	psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER| PSP_USECALLBACK ;;
    psp.pszTemplate         = MAKEINTRESOURCE( IDD_WELCOME);
	ahpsp[iPage++]          = CreatePropertySheetPage( &psp );

	psp.dwFlags             = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE |PSP_USECALLBACK ;
	

	for(;iPage < kNumPages-1 ;){
		psp.pfnDlgProc          = RwPgInf[iPage].pfnCallback;
			//(int (__stdcall *)(void))NameDialogProc;
		psp.pfnCallback         =  RwPgInf[iPage].pfnPropSheetProc;
		//psp.pfnDlgProc          = WizardDlgProc;
		psp.pszHeaderTitle      = MAKEINTRESOURCE(RwPgInf[iPage].wTitle);
		psp.pszHeaderSubTitle   = MAKEINTRESOURCE(RwPgInf[iPage].wSubTitle);
		
		if(iPage == kInformDialog)
		{
			_TCHAR szheader[256],szheaderInfo[256],szInfo[256];
			LoadString(hInstance,IDS_INFORM_SCR_STITLE,szheaderInfo,256);
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			_stprintf(szheader,szheaderInfo,szInfo);
			psp.pszHeaderSubTitle   = szheader;
		}
		else
		if(iPage == kDialupDialog)
		{
			_TCHAR szheader[256],szheaderInfo[256],szInfo[256];
			LoadString(hInstance,IDS_DIALUP_SCR_STITLE,szheaderInfo,256);
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			_stprintf(szheader,szheaderInfo,szInfo);
			psp.pszHeaderSubTitle   = szheader;
		}

		psp.pszTemplate         = MAKEINTRESOURCE(RwPgInf[iPage].wDlgId  );

		// Change the
		if(IsFarEastCountry(hInstance) ==  kFarEastCountry ) {
			switch( iPage) {
			case kNameDialog   :
			case kAddressDialog:
				psp.pfnDlgProc          = RwFEPgInf[iPage-kNameDialog].pfnCallback;
				psp.pfnCallback         = RwFEPgInf[iPage-kNameDialog].pfnPropSheetProc;
				psp.pszHeaderTitle      = MAKEINTRESOURCE(RwFEPgInf[iPage-kNameDialog].wTitle);
				psp.pszHeaderSubTitle   = MAKEINTRESOURCE(RwFEPgInf[iPage-kNameDialog].wSubTitle);
				psp.pszTemplate         = MAKEINTRESOURCE(RwFEPgInf[iPage-kNameDialog].wDlgId);
				break;
			default :
			break;
			}
		}
		ahpsp[iPage++]          = CreatePropertySheetPage( &psp );
	}

	// Create Last Page
	//psp.dwFlags             = PSP_DEFAULT ;
	psp.pszTemplate         = MAKEINTRESOURCE(IDD_FAILURE_REGISTRATION);	
	psp.pfnDlgProc          = FinalScreenDialogProc;

	psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER;

    ahpsp[iPage++]          = CreatePropertySheetPage( &psp );

	psh.dwFlags             = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
	psh.dwFlags             &= ~(PSH_HASHELP);
	psh.pszbmWatermark      = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader         = MAKEINTRESOURCE(IDB_BANNER);

    psh.dwSize              = sizeof( psh );
    psh.hInstance           = hInstance;
    psh.hwndParent          = NULL;
    psh.pszCaption          = _T("Registration Wizard for Windows NT ");//MAKEINTRESOURCE( IDS_TITLE );
    psh.phpage              = ahpsp;
    psh.nStartPage          = 0;
    psh.nPages              = iPage;
    PageInfo.TotalPages     = iPage;
	PageInfo.pclRegWizard   = pclRegWizard;
	PageInfo.hInstance		= hInstance;
	PageInfo.pDialupHelper  = NULL;
	PageInfo.ErrorPage      = -1;
	PageInfo.dwConnectionType   =1;
    PageInfo.pszProductPath = szProductPath;

    //
    // Create the bold fonts.
    //
    SetupFonts( hInstance, NULL, &PageInfo.hBigBoldFont, &PageInfo.hBoldFont );

    //
    // Validate all the pages.
    //
    for( i = 0; i < kNumPages; i++ )
    {
        if( ahpsp[i] == 0 )
        {
            bStatus = FALSE;
        }
    }

	INT_PTR iRetVal=0;
    //
    // Display the wizard.
    //
    if( bStatus )
    {
		iRetVal = PropertySheet( &psh );
        if(iRetVal  == -1 )
        {
            bStatus = FALSE;
        }
    }
	if( iRetVal == 0 ) {
		// Cancelled By the User
		if( PageInfo.ErrorPage  == kWelcomeDialog) {
				
				iError = PageInfo.iError;
				return iError;
			;
		}
	}
    if( !bStatus )
    {
        //
        // Manually destroy the pages if something failed.
        //
        for( i = 0; i < psh.nPages; i++)
        {
            if( ahpsp[i] )
            {
                DestroyPropertySheetPage( ahpsp[i] );
            }
        }
    }

    //
    // Destroy the fonts that were created.
    //
    DestroyFonts( PageInfo.hBigBoldFont, PageInfo.hBoldFont );

    return iError;


}



//
// Wizard dialog proc.
//
INT_PTR CALLBACK
WizardDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
    BOOL bStatus = TRUE;
    PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwnd, GWLP_USERDATA );

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pi );
        if( ( pi->CurrentPage == 0 ) || ( pi->CurrentPage == pi->TotalPages - 1 ) )
        {
        	SetControlFont( pi->hBigBoldFont, hwnd, IDT_TEXT1);
	        //SetControlFont( pi->hBoldFont,    hwnd, IDC_BOLDTITLE);
        }
        break;

    case WM_DESTROY:
        SetWindowLongPtr( hwnd, GWLP_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
                if( pi->CurrentPage == 0 )
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT );
                else if( pi->CurrentPage == pi->TotalPages - 1 ) {
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK | PSWIZB_FINISH );
					// PropSheet_SetFinishText(GetParent( hwnd ),"Register");
				}
                else
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
                pi->CurrentPage++;
                break;

            case PSN_WIZBACK:
                pi->CurrentPage--;
                break;
			case PSN_QUERYCANCEL :
				
				SetWindowLongPtr( GetParent( hwnd ),DWLP_MSGRESULT, (LONG_PTR) 5);
				break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}


VOID
SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId
    )
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowFont(hwndControl, hFont, TRUE);

        }
    }
}

VOID
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    )
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    TCHAR FontSizeString[MAX_PATH];
    INT FontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if(!LoadString(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE))
    {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    }

    if(LoadString(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR)))
    {
        FontSize = _tcstoul( FontSizeString, NULL, 10 );
    }
    else
    {
        FontSize = 12;
    }

	HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		*pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);
    }
}

VOID
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    )
{
    if( hBigBoldFont )
    {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\regdlg.cpp ===
/*********************************************************************
Registration Wizard

RegDlg.cpp
10/28/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
08/20/98  : Removed the substitution of Product name in SubTitle
**********************************************************************/

#include <Windows.h>
#include "RegPage.h"
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include <stdio.h>
#include "cntryinf.h"
#include <rw_common.h>
#include <rwpost.h>

static TCHAR szRegisterSubTitle[1024]=_T("");
static PROPSHEETPAGE  *spAddrSheet=NULL;
// Private functions
int LogFileQuery(HWND hwndParentDlg);
INT_PTR CALLBACK LogFileQueryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK RegisterDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Main entry point for the Registration Wizard.
**********************************************************************/
{
	CRegWizard* pclRegWizard = NULL;
	static INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi)
	{
		pclRegWizard = pi->pclRegWizard;
	};

    switch (uMsg)
    {
		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;	
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;				
        case WM_INITDIALOG:
		{
			_TCHAR szInfo[256];
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);

			//UpgradeDlg(hwndDlg);
			
			//NormalizeDlgItemFont(hwndDlg,IDC_TITLE,RWZ_MAKE_BOLD);
			//NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT5);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT6);
			
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szInfo);
			ReplaceDialogText(hwndDlg,IDT_TEXT1,szInfo);


			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());
			
			
			
			if (pclRegWizard->GetInformationString(kInfoProductID,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDT_TEXT6,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			/***
			// Update the Sub title by substituting the product name
			_TCHAR rgchCallingContext[256];
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,rgchCallingContext);
			LoadString(pi->hInstance,IDS_REGISTER_SCR_STITLE,szRegisterSubTitle,256);
			_tcscat(szRegisterSubTitle,_T(" "));
 			_tcscat(szRegisterSubTitle,rgchCallingContext);
			_tcscat(szRegisterSubTitle,_T("."));
			spAddrSheet->pszHeaderSubTitle = szRegisterSubTitle;
			**/


			if (pclRegWizard->GetCountryCode() == kCountryCodeUnitedStates)
			{
				HWND hwndCtrl;
				hwndCtrl = GetDlgItem(hwndDlg,IDT_TEXT3);
				ShowWindow(hwndCtrl,SW_HIDE);
				hwndCtrl = GetDlgItem(hwndDlg,IDT_TEXT4);
				ShowWindow(hwndCtrl,SW_HIDE);
				hwndCtrl = GetDlgItem(hwndDlg,IDT_TEXT5);
				ShowWindow(hwndCtrl,SW_HIDE);
				hwndCtrl = GetDlgItem(hwndDlg,IDC_ENVELOPE);
				ShowWindow(hwndCtrl,SW_HIDE);
			}

            return TRUE;
		}// WM_INIT
		break;
		case WM_NOTIFY:
        {
			LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code )
			{
            case PSN_SETACTIVE:
                //PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK PSWIZB_NEXT );
				pi->iCancelledByUser = RWZ_PAGE_OK;
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
				iRet=0;
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER )
				{
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
				}
				else
				{
					if (pclRegWizard->GetTriStateInformation(kInfoIncludeProducts) == kTriStateUndefined){	
						pclRegWizard->SetTriStateInformation(kInfoIncludeProducts,kTriStateFalse);
					}
					pclRegWizard->WriteInfoToRegistry();
					
					//
					// Check  for the type of Connectivity
					//
					if(pi->dwConnectionType == DIALUP_REQUIRED)
					{
						pi->CurrentPage++;
						// go to the Dialup Screen
					}
					else
					{
						//
						//
						// Post The  Date
						pi->iError =PostDataWithWindowMessage(pclRegWizard->GetInstance());
						pi->CurrentPage=pi->TotalPages-1;
						PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					}
					pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
				}

				//SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kRegisterDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
				}
				else
				{
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        }
        break;

        default:
			bStatus = FALSE;
            break;
    }
    return bStatus;
}



int LogFileQuery(HWND hwndParentDlg)
/**********************************************************************
Puts up a dialog asking the user if he/she would like a text log of all
registration information.

Returns:
IDB_YES
IDB_NO
IDB_CANCEL
***********************************************************************/
{
	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndParentDlg,GWLP_HINSTANCE);
	int hitButton = (int) DialogBox(hInstance,MAKEINTRESOURCE(IDD_LOGFILE_QUERY),hwndParentDlg,
		LogFileQueryDialogProc);
	return hitButton;
}


INT_PTR CALLBACK LogFileQueryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Proc for our "Do you want a log file" dialog.
**********************************************************************/
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
		{
			RECT parentRect,dlgRect;
			HWND hwndParent = GetParent(hwndDlg);
			GetWindowRect(hwndParent,&parentRect);
			GetWindowRect(hwndDlg,&dlgRect);
			int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
			int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
			MoveWindow(hwndDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
            return TRUE;
		}
        case WM_COMMAND:
            switch (wParam)
            {
                case IDB_YES:
				case IDB_NO:
					EndDialog(hwndDlg,wParam);
					break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    return FALSE;
}

//
//  This function is calles during the creation and deletion of
//  Address Property Sheet
//  Store the Address of PPROPSHEETPAGE so the Subtitle can be changed
//
//
//
UINT CALLBACK RegisterPropSheetPageProc(HWND hwnd,
								UINT uMsg,
								LPPROPSHEETPAGE ppsp
								)
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
		spAddrSheet = ppsp;
	default:
		break;

	}
	return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\pr_psswd.cpp ===
/*

	File : PR_PSSWD.CPP
	
	Module for Displaying and getting the  Username and password for
	Proxy Server

*/


#include <Windows.h>
#include <tchar.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "sysinv.h"
#include "rw_common.h"

#define MAX_USR_NAME_SZ   48
#define MAX_PSSWD_SZ      48
#define MAX_PRXOY_SRV_SZ  48

typedef struct _TmpProxyInfo{

	TCHAR  m_User[MAX_USR_NAME_SZ];
	TCHAR  m_Passwd[MAX_PSSWD_SZ];
	TCHAR  m_PrxySrv[MAX_PRXOY_SRV_SZ];
	HINSTANCE m_hInst;
}__TMPXX;

static _TmpProxyInfo  sPrInf;

INT_PTR CALLBACK  DisplayProxyAuthentication(
				HWND hDlg, 			//dialog window
				UINT uMsg,
				WPARAM wParam,
				LPARAM lParam
			)
			

{
	TCHAR szInfo[256];
	DWORD	dwEnd = 0;
	BOOL	fRet = TRUE;
	HWND hwndParent ;
	switch(uMsg){
		case WM_INITDIALOG:	
			
			RECT parentRect,dlgRect;
		
			hwndParent = GetParent(hDlg);
						
			if (hwndParent)
			{
				GetWindowRect(hwndParent,&parentRect);
				GetWindowRect(hDlg,&dlgRect);
				int newX = parentRect.left + (parentRect.right - parentRect.left)/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = parentRect.top + (parentRect.bottom - parentRect.top)/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			else
			{
				int horiz,vert;
				GetDisplayCharacteristics(&horiz,&vert,NULL);
				GetWindowRect(hDlg,&dlgRect);
				int newX = horiz/2 - (dlgRect.right - dlgRect.left)/2;
				int newY = vert/2 - (dlgRect.bottom - dlgRect.top)/2;
				MoveWindow(hDlg,newX,newY,dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,FALSE);
			}
			NormalizeDlgItemFont(hDlg,IDC_TEXT1);
			
			//SetWindowText(hDlg,szWindowsCaption);

		
			if(sPrInf.m_User)
				SendDlgItemMessage(hDlg,IDC_USERNAME,WM_SETTEXT,0,(LPARAM) sPrInf.m_User);

			if(sPrInf.m_Passwd)
				SendDlgItemMessage(hDlg,IDC_PASSWORD,WM_SETTEXT,0,(LPARAM) sPrInf.m_Passwd);
			ReplaceDialogText(hDlg,IDC_TEXT1,sPrInf.m_PrxySrv);
			SendDlgItemMessage(hDlg,IDC_USERNAME,EM_SETSEL,0,-1);
			return TRUE;
  			goto LReturn;
			break;
		case WM_COMMAND:
		switch (LOWORD(wParam)){
			case IDOK  :
				SendDlgItemMessage(hDlg,IDC_USERNAME,WM_GETTEXT,255,
					(LPARAM) szInfo);
				_tcscpy(sPrInf.m_User,szInfo);

				SendDlgItemMessage(hDlg,IDC_PASSWORD,WM_GETTEXT,255,
					(LPARAM) szInfo);
				_tcscpy(sPrInf.m_Passwd,szInfo);
				goto LEnd;

			case IDCANCEL:
				dwEnd = 1;
				goto LEnd;
			default:
				fRet = FALSE;
				goto LReturn;
			}
		break;
		default :
		fRet = FALSE;
		goto LReturn;
		break;
	}
LEnd:
	EndDialog(hDlg,dwEnd);
LReturn:	
	return fRet;
}








//
//  returns 1 if Cancel is pressed
//

DWORD_PTR GetProxyAuthenticationInfo(HINSTANCE hIns,TCHAR *czProxy,
								 TCHAR *czUserName,TCHAR *czPswd)
{
	DWORD_PTR dwRet;	

	RW_DEBUG << "\n Invoking PROXY DIALOG "  <<  flush;

	sPrInf.m_hInst = hIns;
	if(czProxy) {
		_tcscpy(sPrInf.m_PrxySrv,czProxy);
	}
	else {
		//
		// Return from mfunction without displaying the Dld
		return -1;

	}
	if(czUserName) {
		_tcscpy(sPrInf.m_User,czUserName);
	}else {
		sPrInf.m_User[0] = _T('\0');
	}
	if(czPswd) {
		_tcscpy(sPrInf.m_Passwd,czPswd);
	}else {
		sPrInf.m_Passwd[0] = _T('\0');
	}

	dwRet=DialogBoxParam(hIns, MAKEINTRESOURCE(IDD_PROXY_LOG), NULL,DisplayProxyAuthentication,
			 (LPARAM)hIns);

	if(dwRet == -1 ) {
			 // Error in creating the Dialogue
		return 0;
	
	}

	//
	// Get from the Dialog
	if(sPrInf.m_User) {
		_tcscpy(czUserName, sPrInf.m_User);
	}else {
		czUserName[0] = _T('\0');
	}
	if(sPrInf.m_Passwd) {
		_tcscpy(czPswd,sPrInf.m_Passwd);
	}else {
		czPswd[0] = _T('\0');
	}
	RW_DEBUG << "\nAfter PROXY DIALOG \tUser[" << czUserName  << "]" << flush;
    //RW_DEBUG << "\n\t\tPassword[" << czPswd <<"]" << flush;
	return dwRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\pinvdlg.cpp ===
/*********************************************************************
Registration Wizard

ProdInventoryDialog.cpp
10/21/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "RegPage.h"
#include "regwizmain.h"
#include "resource.h"
#include "dialogs.h"
#include "regutil.h"
#include <rw_common.h>

static HWND vhwndProdInvDlg = NULL;
static BOOL vProdInvListBusy = FALSE;

void DrawProdInventoryCell(CRegWizard* pclRegWizard,HDC hDC,INT_PTR productIndex, RECT* rc);
void BuildInventoryList(CRegWizard* pclRegWizard);


INT_PTR CALLBACK ProdInventoryDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the dialog that displays product information found by
Registration Wizard.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
	INT_PTR bStatus;
	static int iShowThisPage= DO_SHOW_THIS_PAGE;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}
	switch (uMsg)
    {
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			vhwndProdInvDlg = NULL;
			break;
		case WM_CLOSE:
			 break;			
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			
			//
			//
			// Verify is it necessary to show thi spage
			short productCount = pclRegWizard->GetProductCount();
			TriState prodSearchStatus = pclRegWizard->GetProductSearchStatus();
			TriState includeProdInventory = pclRegWizard->GetTriStateInformation(kInfoIncludeProducts);
			BOOL validSearch = productCount > 0;

			if ((validSearch == TRUE && includeProdInventory != kTriStateUndefined)){
				//
				// Ok continue Displaying
				iShowThisPage= DO_SHOW_THIS_PAGE;
				
			}else {
				//
				// Set To cancel
				iShowThisPage= DO_NOT_SHOW_THIS_PAGE;
			}
			

			//
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			vhwndProdInvDlg = hwndDlg;
			NormalizeDlgItemFont(hwndDlg,IDC_TITLE ,RWZ_MAKE_BOLD);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDC_GROUP1);
			NormalizeDlgItemFont(hwndDlg,IDC_GROUP2);
			NormalizeDlgItemFont(hwndDlg,IDC_RADIO1);
			NormalizeDlgItemFont(hwndDlg,IDC_RADIO2);
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());
			TriState shouldInclude = pclRegWizard->GetTriStateInformation(kInfoIncludeProducts);
			if (shouldInclude == kTriStateTrue )
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
				//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
			}
			else if (shouldInclude == kTriStateFalse)
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
				//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
			}
			else if (shouldInclude == kTriStateUndefined)
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
				//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
			}
			
			
			BuildInventoryList(pclRegWizard);
			vDialogInitialized = TRUE;
            return TRUE;
		}// WM_INIT
		case WM_DRAWITEM:
		{
			const kMaxFirstColumnIndex = 5;
			const kMaxProductsPerColumn = 6;
			const kTextAreaWidth = 110;
			const kIconAreaWidth = 32;
			LPDRAWITEMSTRUCT	lpDraw = (LPDRAWITEMSTRUCT) lParam;
			if (lpDraw->itemAction == ODA_DRAWENTIRE)
			{
				RECT rcLine = lpDraw->rcItem;
				INT_PTR listItem = lpDraw->itemData;
				int itemHeight = rcLine.bottom - rcLine.top;
				int lastProductIndex = pclRegWizard->GetProductCount() - 1;

				if (listItem <= kMaxFirstColumnIndex)
				{
					RECT cellRect = rcLine;
					if (lastProductIndex > kMaxFirstColumnIndex)
					{
						cellRect.right = cellRect.left + kTextAreaWidth + kIconAreaWidth;
					}
					DrawProdInventoryCell(pclRegWizard,lpDraw->hDC,listItem,&cellRect);
					if (lastProductIndex >= listItem + kMaxProductsPerColumn)
					{
						cellRect = rcLine;
						cellRect.left = rcLine.right >> 1;
						cellRect.right = cellRect.left + kTextAreaWidth + kIconAreaWidth;
						DrawProdInventoryCell(pclRegWizard,lpDraw->hDC,listItem + kMaxProductsPerColumn,&cellRect);
					}
					if (lastProductIndex > kMaxFirstColumnIndex)
					{
						WORD grayScale = 210;
						HPEN hPen = CreatePen(PS_DOT,1,RGB(grayScale,grayScale,grayScale));
						SelectObject(lpDraw->hDC,hPen);
						
						#ifdef USE_HORIZ_LINES
						MoveToEx(lpDraw->hDC,rcLine.left,rcLine.bottom - 1,NULL);
						LineTo(lpDraw->hDC,rcLine.right,rcLine.bottom - 1);
						#endif

						RECT rcListbox;
						GetClientRect(lpDraw->hwndItem,&rcListbox);
						WORD hPos = (WORD)((rcListbox.right >> 1) - 2);
						MoveToEx(lpDraw->hDC,hPos,rcListbox.top,NULL);
						LineTo(lpDraw->hDC,hPos,rcListbox.bottom);
						MoveToEx(lpDraw->hDC,hPos-2,rcListbox.top,NULL);
						LineTo(lpDraw->hDC,hPos-2,rcListbox.bottom);
						DeleteObject(hPen);
					}
				}
			}
			break;
		}
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				if( iShowThisPage== DO_NOT_SHOW_THIS_PAGE ) {
					pclRegWizard->SetTriStateInformation(kInfoIncludeProducts,kTriStateFalse);
					pi->iCancelledByUser = RWZ_SKIP_AND_GOTO_NEXT;
					if( pi->iLastKeyOperation == RWZ_BACK_PRESSED){
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_BACK);
					}else {
						PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
					}

				}
				else {
	                pi->iCancelledByUser = RWZ_PAGE_OK;
					pi->iLastKeyOperation = RWZ_UNRECOGNIZED_KEYPESS;
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}
                break;

            case PSN_WIZNEXT:
				switch(pi->iCancelledByUser) {
				case RWZ_CANCELLED_BY_USER:
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);
					break;
				case RWZ_PAGE_OK:
					iRet=0;
					if( ValidateInvDialog(hwndDlg,IDS_BAD_SYSINV)) {
						BOOL yesChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
						BOOL noChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
						if (yesChecked){
							pclRegWizard->SetTriStateInformation(kInfoIncludeProducts,kTriStateTrue);
						}else if (noChecked){
							pclRegWizard->SetTriStateInformation(kInfoIncludeProducts,kTriStateFalse);
						}
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						// Set as Next Key Button Pressed
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
					break;
					case RWZ_SKIP_AND_GOTO_NEXT:
					default:
						// Do not Validate the page and just go to the next page
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						
					break;
				}

				break;
            case PSN_WIZBACK:
                pi->CurrentPage--;
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                break;
			case PSN_QUERYCANCEL :
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kProductInventoryDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					pi->iLastKeyOperation = RWZ_CANCEL_PRESSED;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;
				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;
		case WM_COMMAND:
		{
            if (vDialogInitialized)
            {
                // If the 'No' button is checked, the user is declining
                // the "Non-Microsoft product" offers
                if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
                     PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                    //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
                }else
                if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
                    PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                    //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
                }else{
                    PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK);
                    //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
                }

            }
		}
		break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}

void BuildInventoryList(CRegWizard* pclRegWizard)
/*********************************************************************
Dialog Proc for the dialog that displays product information found by
Registration Wizard.
**********************************************************************/
{
	if (vhwndProdInvDlg)
	{
		vProdInvListBusy = TRUE;
		SendDlgItemMessage(vhwndProdInvDlg,IDC_LIST1,LB_RESETCONTENT,0,0);
		short productCount = pclRegWizard->GetProductCount();
		WORD wExtraSpace = ((6 - productCount) > 0 ? (6 - productCount) : 0) * 4;
		if (wExtraSpace > 8) wExtraSpace = 8;
		SendDlgItemMessage(vhwndProdInvDlg,IDC_LIST1,LB_SETITEMHEIGHT,0,36 + wExtraSpace);
		for (short x = 0;x < productCount;x++)
		{
			SendDlgItemMessage(vhwndProdInvDlg,IDC_LIST1,LB_ADDSTRING,0,(LPARAM) x);
		}
		vProdInvListBusy = FALSE;
	}
}


void DrawProdInventoryCell(CRegWizard* pclRegWizard, HDC hDC, INT_PTR productIndex, RECT* rc)
/*********************************************************************
Dialog Proc for the dialog that displays product information found by
Registration Wizard.
**********************************************************************/
{
	RECT rcCell = *rc;
	const kNameTab = 38;
	const kIconHeight = 32;
	_TCHAR szProductName[90];
	pclRegWizard->GetProductName(szProductName,productIndex);
	HICON hIcon = pclRegWizard->GetProductIcon(productIndex);
	WORD wIconTop = (WORD)(rcCell.top + (rcCell.bottom - rcCell.top - kIconHeight)/2);
	DrawIcon(hDC,rcCell.left + 2,wIconTop,hIcon);
	
	rcCell.left += kNameTab;

	SIZE sTextSize;
	GetTextExtentPoint32(hDC,szProductName,lstrlen(szProductName),&sTextSize);
	WORD wLineCount = sTextSize.cx > (rcCell.right - rcCell.left) ? 2 : 1;
	WORD wTextHeight = (WORD)(sTextSize.cy * wLineCount);
	rcCell.top += (rcCell.bottom - rcCell.top - wTextHeight)/2;
	DrawText(hDC,szProductName,-1,&rcCell,DT_LEFT | DT_WORDBREAK);
}


void RefreshInventoryList(CRegWizard* pclRegWizard)
/*********************************************************************
If the product inventory dialog is currently active, the given
product name will be added to the product list box.
**********************************************************************/
{
	while (vhwndProdInvDlg && vProdInvListBusy)
	{
		MSG msg;
		PeekMessage(&msg,NULL,0,0,PM_NOREMOVE);
	}
	if (vhwndProdInvDlg)
	{
		#ifdef _DEBUG
		MessageBeep(0xFFFFFFFF);
		#endif
		BuildInventoryList(pclRegWizard);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\regwizmain.cpp ===
/*********************************************************************
Registration Wizard
10/12/94 - Tracy Ferrier
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <RegPage.h>

#include <tapi.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include <process.h>
#include "sysinv.h"
#include <stdio.h>
#include "cntryinf.h"
#include "mcm.h"
#include "rw_common.h"
#include "rwpost.h"
#include "string.h"
#include <rpcdce.h>
#pragma comment(lib, "rpcrt4.lib")

// MSID Definitions
#define cchMaxSzMSID    32
#define cbMaxSzMSID     (cchMaxSzMSID + 1)
RECT gRect;

// Private functions
void __cdecl LaunchProductSearchThread(void*);
void __cdecl LaunchSystemInventoryThread(void* lParam);
void __cdecl LaunchOemCheckThread(void *);

typedef void (FAR PASCAL *LPFNPRODUCTSEARCH) (void (*pfnReceiveProductName) (LPTSTR,LPTSTR) );
void ReceiveProductName(LPTSTR szProductName,LPTSTR szProductPathName);
void ExitWithImproperBinary(HINSTANCE hInstance,HWND hParent);
void ExitWithInputParamError(HINSTANCE hInstance,HWND hParent);
void ExitWithTxferError(HINSTANCE hInstance,HWND hParent);
void ExitWithSuccessfulRegistration(HINSTANCE hInstance, LPTSTR szProductName);
void ExitWithModemError(HINSTANCE hInstance,HWND hParent);
void ExitWithModemCfgError(HINSTANCE hInstance,HWND hParent);
void ExitWithTcpCfgError(HINSTANCE hInstance,HWND hParent);
void ExitWithCompletedStatus(HINSTANCE hInstance,LPTSTR szProductName);
void ExitWithTryLater(HINSTANCE hInstance, HWND hParent);
void ExitWithConfigurationProblem(HINSTANCE hInstance, HWND hParent);
void ExitWithAnotherCopyRunning(HINSTANCE hInstance, HWND hParent);

BOOL ParseCmdLine(LPTSTR szCmdLine, LPTSTR szBuf, UINT cbBufMax,int *pSwitchType);
BOOL GetSignupLocation(HINSTANCE hInstance, LPTSTR szFileName,LPTSTR szDirectory);
void CopyCharToBuf ( _TCHAR** pszCur, _TCHAR** pszBuf, UINT* pcbBuf );

void RegWizStartupError(DWORD dwError, HINSTANCE hInstance, TCHAR *pszProductName=NULL);
int CheckOEMdll();
int OemPutDataInRegistry();

int CheckWin95OrNT();
int CheckIfProductIsRegistred(HINSTANCE hInstance ,
							  _TCHAR * szParamRegKey);
HBITMAP GetOemBmp();
HBITMAP BitmapFromDib (LPVOID pDIB, HPALETTE hpal,WORD wPalSize);

void GetWindowsDirectory(TCHAR *szParamRegKey,
						 TCHAR *czBuf);
/*****************************/
VOID	ReduceUUID(PSTR szUUID);
HRESULT HrTestHWID();
HRESULT GetNewGUID(PSTR pszGUID);
BOOL	CheckHWIDPresent();
void	MakeHWIDNotUsed(HINSTANCE hins);
/*****************************/
#ifdef _DEBUG
void DebugMessageBox(LPTSTR szMessage);
#else
#define DebugMessageBox(szMessage) 0
#endif

void CloseForTcpIcmp(); // TCP.CPP

#define chSpace 32
BOOL bOemDllLoaded = FALSE;
HINSTANCE hOemDll= NULL;
HANDLE hOemEvent =NULL;
HANDLE hProductEvent=NULL;
HANDLE hInventoryEvent=NULL;

_TCHAR szProductName[256];
_TCHAR szWindowsCaption[256];
_TCHAR szOEMIncenMsg[256];

static CRegWizard* vclRegWizard = NULL;
static LPTSTR lpszRegWizardClass = _T("RegWizard");

static HPALETTE gPal;

BOOL vDialogInitialized = FALSE;

//
//
//
#define SWITCH_WITH_UNKNOWNOPTION    0
#define SWITCH_WITH_I				 1
#define SWITCH_WITH_T				 2
#define SWITCH_WITH_R				 3



#define OEM_NO_ERROR		0
#define OEM_VALIDATE_FAILED 1
#define OEM_INTERNAL_ERROR  2

#define  WIN98_OS     1
#define  WINNT_OS     2
#define  UNKNOWN_OS   0

//
// returns 1 if Win95
//         2 if Win NT
//         0 if Error
int CheckWin95OrNT()
{
	int iRet = 0;
	OSVERSIONINFO  oi;
	oi.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
   	GetVersionEx(&oi);
	switch(oi.dwPlatformId) {
		case VER_PLATFORM_WIN32_NT:
			iRet = 2;
			break;
		case VER_PLATFORM_WIN32_WINDOWS:
			iRet = 1;
			break;
		default :
			break;
	}
	RW_DEBUG << "\n Check OS "  << iRet << flush;
	return iRet;
		


}


//
// Checks to make sure (8 RegWIz Binary is not used in NT
// and NT Binary is not being used in Windows 98
// returns :
//		NO_ERROR   if Binary is the one created for the OS it is running
//      RWZ_ERROR_INVALID_DLL : Dll is not intended for this OS
DWORD CheckForValidRegWizBinary()
{
	int iOsType;
	int iError;
	iError = NO_ERROR;
	iOsType = CheckWin95OrNT();
	#ifdef _WIN95
		if (iOsType != WIN98_OS )
		{
			// Error the OS is not Win 95
			iError = RWZ_ERROR_INVALID_DLL ;
			
		}
	#else
		if (iOsType != WINNT_OS )
		{
			// Error the OS is not Win NT
			iError = RWZ_ERROR_INVALID_DLL;
			
		}
	#endif
	return iError;


}

//int PASCAL _tWinMain( HANDLE hInstance, HANDLE hPrevInstance, LPTSTR lpszCmdParam, int nCmdShow)
// Returns 0 if invoked by /i
// Option : /t
// Returns	 0    if Not Registred
// Returns	 1    if Product is Registred
// Returns  -1  if errror in parameter /t option

int InvokeRegistration ( HINSTANCE hInstance  , LPCTSTR czPath)
/*********************************************************************
Main entry point for the Registration Wizard.
**********************************************************************/
{
	_TCHAR szParamRegKey[256];
	BOOL goodRegKey;
	HANDLE hMutexForInstanceCheck;
	TriState productSearchLibStatus;
	_TCHAR szTitle[64];
	_TCHAR szValue[256]; // used for MSID

	int iError;
	int iSwitchType;


	iSwitchType = SWITCH_WITH_UNKNOWNOPTION;
	hMutexForInstanceCheck = NULL;
	iError = NO_ERROR;

	//
	// Create a Mutex object to check for another copy of regWiz running
	//

	hMutexForInstanceCheck = CreateMutex(NULL,TRUE,_T("RegWizResource_1298345_ForRegistration"));
	if(hMutexForInstanceCheck != NULL ) {
		if( GetLastError() ==  ERROR_ALREADY_EXISTS){
			//
			// Already an instance of RegWiz is running
			iError = RWZ_ERROR_PREVIOUSCOPY_FOUND;
			goto StartupError_NOResourceCleanup;
		}
	}

	//
	//
	// Init variables for Font creation
	InitDlgNormalBoldFont();


	//
	// Check for Binary Validity
	if((iError=CheckForValidRegWizBinary()) ==
		RWZ_ERROR_INVALID_DLL)				{
			goto StartupError_NOResourceCleanup;
	}

	goodRegKey = ParseCmdLine((LPTSTR) czPath,szParamRegKey,256,
		&iSwitchType);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n After ParseCmdLine"  << flush;
	#endif
	if (!goodRegKey){
		// This is a special case for browser
		if(iSwitchType == SWITCH_WITH_T){
			return  -1;
		}
		iError = RWZ_ERROR_INVALID_PARAMETER;
		goto StartupError_NOResourceCleanup;
	}

	//
	//  This is a special case for Registration Wizard to be launched from Browsers.
	//  This is to check if the product is already registred
	//  This returns 1 if registred and 0 if it is not registred
	if(iSwitchType == SWITCH_WITH_T){
		return CheckIfProductIsRegistred(hInstance, szParamRegKey);
		
	}

	


	// 02/06/98 If REGWIZ.EXE is invoke with /r and the product info is not passed
	// then it has to regregister the OS
	// so if the product info is null it fills the proper OS reg details
	if(iSwitchType == SWITCH_WITH_R) {
		if(szParamRegKey[0] == NULL || szParamRegKey[0] == _T('\0')){
			// LOad the OS String
			switch(CheckWin95OrNT()) {
			case WIN98_OS:
				LoadString(hInstance,
					IDS_REREGISTER_OS1,
					szParamRegKey,
					256);
					
				break;
			case WINNT_OS :
				LoadString(hInstance,
					IDS_REREGISTER_OS2,
					szParamRegKey,
					256);
					//_tcscpy(szParamRegKey,_T("SOFTWARE\\Microsoft\\NT5.0"));
				break;
			default:
				break;
			}
		
		}				
		

	}

	RW_DEBUG << "\n Prod Key [" << szParamRegKey <<"]" <<  flush;
	vclRegWizard = new CRegWizard(hInstance,szParamRegKey);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n After new CRegWizard"  << flush;
	#endif

	if (vclRegWizard->GetInputParameterStatus() == FALSE){
		#ifdef _DEBUG
		DebugMessageBox(_T("One or more 'input parameter' registration keys are invalid."));
		#endif
		iError = RWZ_ERROR_INVALID_PARAMETER;
		goto StartupError_CloseRegWizard;
	}

	// Set the product name  globally so it can be accessed
	vclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szProductName);
	SetProductBeingRegistred(szProductName);
	vclRegWizard->SetWindowCaption(szProductName);
	

	LoadString(hInstance,IDS_WINDOWS_CAPTION,szTitle,64);
	_tcscpy(szWindowsCaption,szProductName);
	_tcscat(szWindowsCaption,szTitle);

	// If registration has already been done for this product
	// (as specified in the input parameters), we can just
	// inform the user and then exit.
	if(iSwitchType != SWITCH_WITH_R){
	
		if (vclRegWizard->IsRegistered()){
			vclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szProductName);
			iError = REGWIZ_ALREADY_CONFIGURED ;
			goto StartupError_CloseRegWizard;
		}
	}
	// If our CRegWizard object can't locate the product search
	// DLL (complinc.dll), we can't go on.
	productSearchLibStatus = vclRegWizard->GetProductSearchLibraryStatus();
	if (productSearchLibStatus == kTriStateFalse){
		#ifdef _DEBUG
			DebugMessageBox(_T("The Product Inventory DLL specified by the 'input parameter' registration key could")
			_T(" not be found, or has an invalid format."));
		#endif
		iError = RWZ_ERROR_INVALID_PARAMETER;
		goto StartupError_CloseRegWizard;
	}

	//
	//  Resource Allocation from now on has to be freed
	//  during Exit


	// Get Auto Dial Status
	GetAutoDialConfiguration();
	#ifdef _LOG_IN_FILE
		RW_DEBUG <<"\n After GetAutoDialConfiguration"  << flush;
	#endif
	InitializeInetThread(hInstance);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n After InitializeInetThread"  << flush;
	#endif

	//
	// Product Inventory Search in the background	
	hProductEvent = CreateEvent( NULL, TRUE, FALSE,NULL);
	hInventoryEvent = CreateEvent( NULL, TRUE, FALSE,NULL);
	if (productSearchLibStatus == kTriStateTrue){
		_beginthread(LaunchProductSearchThread,0,vclRegWizard);
	}
	else{
		vclRegWizard->SetProductSearchStatus(kTriStateTrue);
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Bypassed LaunchProductSearchThread"  << flush;
		#endif
		SetEvent(hProductEvent);
	}
	
	_beginthread(LaunchSystemInventoryThread,0,vclRegWizard);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n After LaunchSystemInventoryThread"  << flush;
	#endif
	// 03/11/99 Delete HWID Logic , Delete Existing HWID
	//if(CheckHWIDPresent() == FALSE)
	//	HrTestHWID();
	MakeHWIDNotUsed(hInstance);


	iError = (ULONG)DoRegistrationWizard(hInstance, vclRegWizard, szParamRegKey);

	#ifdef _LOG_IN_FILE
		RW_DEBUG <<"\n iError :  " << iError << flush;
	#endif

		

	if(hInventoryEvent)
	WaitForSingleObject(hInventoryEvent,INFINITE);
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n System Inventory WAIT FINISHED" << flush;
	#endif
	if(hProductEvent)
	WaitForSingleObject(hProductEvent,INFINITE);
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Product Search WAIT FINISHED"<< flush;
	#endif
	
		

	if(hProductEvent)	CloseHandle(hProductEvent);
	if(hInventoryEvent) CloseHandle(hInventoryEvent);
	


	// Remove The MSID Entry
	RemoveMSIDEntry(hInstance);
	MakeHWIDNotUsed(hInstance);

	// Close any opened windows
	if(vclRegWizard)
	vclRegWizard->DestroyOpenedWindow();

	ResetAutoDialConfiguration();
	
	UnLoadInetCfgLib(); // Frees  INETCFG.DLL
	// comment the above line as it is creating a problem IE
	CloseForTcpIcmp(); //  Frees   ICMP.DLL and Closes Socket

	if(vclRegWizard) delete vclRegWizard;

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Exiting Regwiz....." << flush;
	#endif
	if(hMutexForInstanceCheck) {
		CloseHandle(hMutexForInstanceCheck);
	}

	goto CoolExit;

StartupError_CloseRegWizard:
	//
	// Close the
	RegWizStartupError(iError,hInstance,szProductName );
	if(hMutexForInstanceCheck) {
		CloseHandle(hMutexForInstanceCheck);
	}
	if(vclRegWizard) delete vclRegWizard;
	goto CoolExit;

StartupError_NOResourceCleanup:
	RegWizStartupError(iError,hInstance,szProductName );	
	if(hMutexForInstanceCheck) {
		CloseHandle(hMutexForInstanceCheck);
	}
		

CoolExit:
	//
	// Call function to destroy for the fonts that are created
	DeleteDlgNormalBoldFont();

	return iError;

}

void RegWizStartupError(DWORD dwError, HINSTANCE hInstance, TCHAR  *pszProductName)
{
	RW_DEBUG << "\n In RegWizStartupError " << dwError << flush;
	switch(dwError) {
		case  RWZ_ERROR_INVALID_DLL:
			ExitWithImproperBinary(hInstance, NULL);
			break;
		case  RWZ_ERROR_PREVIOUSCOPY_FOUND:
			ExitWithAnotherCopyRunning(hInstance, NULL);
			break;
		case  RWZ_ERROR_INVALID_PARAMETER:
			ExitWithInputParamError(hInstance,NULL);
			break;
		case  REGWIZ_ALREADY_CONFIGURED:
			ExitWithCompletedStatus(hInstance,pszProductName);
			break;

			

		default:
			break;
			//
			//
		break;

	}

}


/*   T R A N S M I T   R E G   W I Z   I N F O   */
/*-------------------------------------------------------------------------
    Owner: SteveBu

    REVIEW: add support fOEM, tricking RegWiz into posting both prodreg
    and OEM information.
-------------------------------------------------------------------------*/
void TransmitRegWizInfo(HINSTANCE hInstance,
						LPCTSTR szParams, BOOL fOEM)
	
{	
	
		
}







ModemStatus DetectModem(HINSTANCE hInstance)
/*********************************************************************
This function detects whether the user's machine has a modem connected
and properly configured.

Returns:
kNoneFound: No modem is connected.
kModemFound: A modem is connected and configured.
kConfigErr: A modem is connected, but it could not be configured
	correctly.
**********************************************************************/
{
	#ifdef _TAPI
		MODEMSTATUS msModemStatus = MSEnsureModemTAPI(hInstance,NULL);
		switch (msModemStatus)
		{
			case kMsModemOk:
				return kModemFound;
			case kMsModemNotFound:
				return kNoneFound;
			case kMsModemTooSlow:
				return kModemTooSlow;
			default:
				return kNoneFound;
		}
	#else
		if (vclRegWizard->GetInformationString(kInfoCountry,NULL) == NULL)
		{
			vclRegWizard->SetInformationString(kInfoCountry,_T("United States of America"));
		}
		return kModemFound;
	#endif
}



void __cdecl LaunchProductSearchThread(void* lParam)
/*********************************************************************
This function spawns a thread that builds an inventory list of the
products installed on the user's system.  The lParam parameter should
contain a pointer to our CRegWizard object.
**********************************************************************/
{
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n LaunchProductSearchThread started" << flush;
	#endif
	
	CRegWizard* pclRegWizard = (CRegWizard*) lParam;
	pclRegWizard->SetProductSearchStatus(kTriStateFalse);

	LPFNPRODUCTSEARCH lpfnProdSearch;
	pclRegWizard->GetProductSearchProcAddress((FARPROC*) &lpfnProdSearch);
	if (lpfnProdSearch)
	{
		lpfnProdSearch(ReceiveProductName);
		pclRegWizard->SetProductSearchStatus(kTriStateTrue);
	}
	else
	{
		pclRegWizard->SetProductSearchStatus(kTriStateUndefined);
	}
	
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n LaunchProductSearchThread finished" << flush;
	#endif

	SetEvent(hProductEvent);
	_endthread();
	
}

void __cdecl LaunchSystemInventoryThread(void* lParam)
/*********************************************************************
This function spawns a thread that builds an inventory list of
detected system information .  The lParam parameter should contain a
pointer to our CRegWizard object.
**********************************************************************/
{
	CRegWizard* pclRegWizard = (CRegWizard*) lParam;
	pclRegWizard->SetSystemInventoryStatus(FALSE);

	const int iInvBufSize = 256;
	_TCHAR szInventory[iInvBufSize];
	GetProcessorTypeString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoProcessor,szInventory);

	GetTotalMemoryString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoTotalRAM,szInventory);

	GetTotalHardDiskSpaceString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoTotalDiskSpace,szInventory);

	GetDisplayResolutionString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoDisplayResolution,szInventory);
	
	GetDisplayColorDepthString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoDisplayColorDepth,szInventory);

	GetWindowsVersionString(pclRegWizard->GetInstance(), szInventory);
	pclRegWizard->SetInformationString(kInfoOperatingSystem,szInventory);

	GetNetworkCardString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoNetwork,szInventory);

	GetModemString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoModem,szInventory);

	GetPointingDeviceString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoPointingDevice,szInventory);

	GetCDRomString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoCDROM,szInventory);

	GetSoundCardString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kInfoSoundCard,szInventory);

	GetRemoveableMediaString(pclRegWizard->GetInstance(),szInventory,iInvBufSize);
	pclRegWizard->SetInformationString(kInfoRemoveableMedia,szInventory);

	GetOEMString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kComputerManufacturer,szInventory);

	GetSCSIAdapterString(pclRegWizard->GetInstance(),szInventory);
	pclRegWizard->SetInformationString(kScsiAdapterInfo,szInventory);


	BOOL hasCoProcessor = IsCoProcessorAvailable(pclRegWizard->GetInstance());
	pclRegWizard->SetTriStateInformation(kInfoMathCoProcessor,
	hasCoProcessor == TRUE ? kTriStateTrue : kTriStateFalse);

	pclRegWizard->SetSystemInventoryStatus(TRUE);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n LaunchSystemInventoryThread finished" << flush;
	#endif
	SetEvent(hInventoryEvent);
	_endthread();
}



void ReceiveProductName(LPTSTR szProductName,LPTSTR szProductPathName)
/***************************************************************************
This function receives the given product name back from complinc.dll
****************************************************************************/
{
	vclRegWizard->AddProduct(szProductName,szProductPathName);
	RefreshInventoryList(vclRegWizard);
}


BOOL ParseCmdLine(LPTSTR szCmdLine, LPTSTR szBuf, UINT cbBufMax, int *pSwitchType)
/***************************************************************************
This function expects in the szCmdLine parameter a pointer to the
command line parameter string used when RegWiz was launched.  This string
will be parsed, and the bare command line argument (which should be a
RegDB key referencing our parameter block) will be returned in the
szBuf parameter.

If no valid command line parameter is located, an empty string will be
returned in szBuf, and FALSE will be returned as the function result.
****************************************************************************/
{

	TCHAR  cSwitch;
    *szBuf = 0; // Initialize the output buffer
	*pSwitchType = SWITCH_WITH_UNKNOWNOPTION;
	if (szCmdLine == NULL || szCmdLine[0] == 0)
	{
		return FALSE;
	}
	else
	{
		LPTSTR szCurr = szCmdLine;
		while (*szCurr == chSpace)
		{
			szCurr = CharNext(szCurr);
		}
	

		if (*szCurr != _T('/') && *szCurr != _T('-')) return FALSE;
		szCurr = CharNext(szCurr);

		cSwitch = *szCurr;
		cSwitch = _totupper(cSwitch);

		if (cSwitch != _T('I') && cSwitch != _T('T') && cSwitch != _T('R') )return FALSE;

		if(cSwitch ==_T('T'))
		{
			*pSwitchType = SWITCH_WITH_T;
		}
		else
		if(cSwitch ==_T('I'))
		{
			*pSwitchType =SWITCH_WITH_I;
		}
		else
		if(cSwitch ==_T('R'))
		{
			*pSwitchType =SWITCH_WITH_R;
		}
		else
		{
			*pSwitchType =SWITCH_WITH_UNKNOWNOPTION;
		}

		szCurr = CharNext(szCurr);
		while (*szCurr == chSpace)
		{
			szCurr = CharNext(szCurr);
		}

		BOOL fInQuoted = FALSE;
		while (*szCurr != NULL && (fInQuoted == TRUE || fInQuoted == FALSE && *szCurr != chSpace))
		{
			if (*szCurr == _T('"'))
			{
				szCurr = CharNext(szCurr);
				fInQuoted = fInQuoted == TRUE ? FALSE : TRUE;
			}
			else
			{
				CopyCharToBuf(&szCurr,&szBuf,&cbBufMax);
			}
		}
		*szBuf = NULL;
		while (*szCurr == chSpace)
		{
			szCurr = CharNext(szCurr);
		}
		if (*szCurr != NULL) return FALSE;

		#ifdef _DEBUG
			if (fInQuoted)
			{
				DebugMessageBox(_T("Unmatched quotes in '/i' command line parameter."));
			}
		#endif
		return fInQuoted == TRUE ? FALSE : TRUE;
	}
}


void CopyCharToBuf ( LPTSTR* pszCur, LPTSTR* pszBuf, UINT* pcbBuf )
{
	LPTSTR szEnd = CharNext(*pszCur);
	if (UINT(szEnd - *pszCur) <= *pcbBuf)
		{
		while (*pszCur < szEnd)
			{
				//*(*pszBuf)++ = *(*pszCur)++;
				_tcscpy(*pszBuf,*pszCur);
				(*pszBuf) = _tcsinc((*pszBuf));
				(*pszCur) = _tcsinc((*pszCur));
				//(*pcbBuf) = _tcsdec((*pcbBuf));
				(*pcbBuf)--;
			}
		}
	else
		{
		*pszCur = szEnd;
		*pcbBuf = 0;
		}
}



void ExitWithInputParamError(HINSTANCE hInstance,HWND hParent)
/***************************************************************************
Displays a message informing the user of a problem with the input parameters
(either the command line argument regkey, or the parameter subkeys in the
Reg Database), and then terminates the RegWizard.
****************************************************************************/
{
	RegWizardMessage(hInstance,hParent,IDD_INPUTPARAM_ERR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif
}


void 	ExitWithTxferError(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_POST_ERROR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif
}

void 	ExitWithTryLater(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_POST_PROBLEM);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif
}

void ExitWithConfigurationProblem(HINSTANCE hInstance, HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_CFG_PROBLEM);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif

}

void ExitWithModemError(HINSTANCE hInstance,HWND hParent)
/***************************************************************************
Displays a message informing the user of that RegWizard cannot run without
a properly configured modem, and then terminates.
****************************************************************************/
{

	RegWizardMessageEx(hInstance,hParent,IDD_MODEM_ERR, GetProductBeingRegistred());
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}

void ExitWithTcpCfgError(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_NETWORK_CFG_ERROR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}

void ExitWithImproperBinary(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_ERROR_INVALIDBINARY);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif

}

void ExitWithModemCfgError(HINSTANCE hInstance,HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_MODEM_CFG_ERROR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}

void ExitWithAnotherCopyRunning(HINSTANCE hInstance, HWND hParent)
{
	RegWizardMessage(hInstance,hParent,IDD_ANOTHERCOPY_ERROR);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}
void ExitWithSuccessfulRegistration(HINSTANCE hInstance, LPTSTR szProductName)
{
	RegWizardMessageEx(hInstance,NULL,IDD_SUCCESSFUL_REGISTRATION,szProductName);
	#ifdef _REGWIZ_EXE
		exit(EXIT_SUCCESS);
	#endif
}


void ExitWithCompletedStatus(HINSTANCE hInstance,LPTSTR szProductName)
/***************************************************************************
Displays a message informing the user of registration has already been
performed for this product, and then exits.  The szProductName parameter
should contain a pointer to the product name.
****************************************************************************/
{
	RegWizardMessageEx(hInstance,NULL,IDD_ALREADY_REGISTERED,szProductName);
	#ifdef _REGWIZ_EXE
		exit(EXIT_FAILURE);
	#endif
}



BOOL GetSignupLocation(HINSTANCE hInstance, LPTSTR szFileName,LPTSTR szDirectory)
/***************************************************************************
Returns the filename and full pathname to the directory of the SignUp
executable.  If either value cannot be determined (i.e. the pathname cannot
be found in the Registration Database), FALSE will be returned as the
function result.
****************************************************************************/
{
	HKEY hKey;
	_TCHAR szKeyName[256];
	BOOL retValue = FALSE;
	int resSize = LoadString(hInstance,IDS_SIGNUPLOC_KEY,szKeyName,255);
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[64];
		unsigned long infoSize = 255;
		resSize = LoadString(hInstance,IDS_SIGNUPLOC_VALUENAME,szValueName,64);
		regStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szDirectory,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			retValue = TRUE;
			LoadString(hInstance,IDS_SIGNUPLOC_FILENAME,szFileName,255);
		}
		RegCloseKey(hKey);
	}
	return retValue;
}


int CheckOEMdll()
{
	return OEM_INTERNAL_ERROR;
}



#ifdef _DEBUG
void DebugMessageBox(LPTSTR szMessage)
/***************************************************************************
Displays the given message in a "Stop" message box (debug builds only).
****************************************************************************/
{
	MessageBox(NULL,szMessage,_T("Registration Wizard Error"),MB_ICONSTOP);
}
#endif



/*************************************
/*   R E D U C E   U   U   I   D   */
/*----------------------------------------------------------------------
    Owner: SteveBu
    Reduces a UUID to a string
----------------------------------------------------------------------*/
VOID ReduceUUID(PSTR szUUID)
{
        int i;
        for (i=9; i<13; i++) szUUID[i-1]=szUUID[i];
        for (i=14; i<18; i++) szUUID[i-2]=szUUID[i];
        for (i=19; i<23; i++) szUUID[i-3]=szUUID[i];
        for (i=24; i<36; i++) szUUID[i-4]=szUUID[i];
        szUUID[32]='\0';
}

/*   G E T   N E W   G   U   I   D   */
/*----------------------------------------------------------------------
    Owner: SteveBu
    Generates a new GUID.  Assumes passed in pszGUID is 32 characters in
    length.
	03/10/99:
	NUll String will be returned, GUID will no longer be created on 
	clients machine
-----------------------------------------------------------------------*/
HRESULT GetNewGUID(PSTR pszGUID)
{
        UUID    idNumber;
        PBYTE  uuidString;
        DWORD   dwErr;
		char szUidString[40];

		strcpy(pszGUID,"");
		return NO_ERROR;
		/******
        if ( (RPC_S_OK==(dwErr=UuidCreate(&idNumber))) &&
                 (RPC_S_OK==(dwErr=UuidToStringA(&idNumber,&uuidString))) )
        {
    		RW_DEBUG << "\n: Create New HWID :" << uuidString << flush;
                strcpy(szUidString, (PSTR)uuidString);
                RpcStringFreeA(&uuidString);
                ReduceUUID(szUidString);
				strcpy(pszGUID,szUidString);
                return NO_ERROR;
        }
        return HRESULT_FROM_WIN32(dwErr);
		**/
}

/**
BOOL CheckHWIDPresent()
{
	HKEY hKeyHWID;

	_TCHAR szKeyName[256];
	_TCHAR szValue[256];
	
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));
	
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_READ,&hKeyHWID);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[64];
		unsigned long infoSize = 255;
		LoadString(vclRegWizard->GetInstance(),IDS_HWID,szValueName,64);
		regStatus = RegQueryValueEx(hKeyHWID,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			vclRegWizard->SetInformationString(kInfoHWID,szValue);
			RegCloseKey(hKeyHWID);
			return TRUE;
		}

	}
	RegCloseKey(hKeyHWID);
	return FALSE;
}

HRESULT HrTestHWID()
{
 DWORD	dwRet;
 _TCHAR szKeyName[256];
 HRESULT hr;
 HKEY	hIDKey;
 char szHWID[cbMaxSzMSID+64];
 TCHAR  *TP;

 _tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));

 if (FAILED(hr = GetNewGUID(szHWID)))
	  szHWID[0] = '\0';
 else
 {
    RW_DEBUG << "\n:HWID :" << szHWID << flush;
  // Store HWID into
	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS)
	{
		TP = ConvertToUnicode(szHWID);
		dwRet = RegSetValueEx(hIDKey,_T("HWID"),NULL,REG_SZ,(CONST BYTE *)TP,
									_tcslen( TP) * sizeof(TCHAR) );
		vclRegWizard->SetInformationString(kInfoHWID,TP);
		RegCloseKey(hIDKey);
	}
 }

 return hr;
}
****/

void MakeHWIDNotUsed(HINSTANCE  hInstance)
{
	_TCHAR szKeyName[256];
	_TCHAR szValue[256];
	HRESULT hr;
	HKEY	hIDKey;
	DWORD dwRet;
	szValue[0] = _T('\0');
	LoadString(hInstance,IDS_NOTUSED,szValue,255);

	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));
	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) {
		//RegDeleteValue(hIDKey,_T("HWID") );
		RegSetValueEx(hIDKey,_T("HWID"),NULL,REG_SZ,(CONST BYTE *)szValue,
								_tcslen((LPCTSTR)szValue)* sizeof(_TCHAR) );
		RegCloseKey(hIDKey);
	}
	// Delete From User Informatipon
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\User Information"));
	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) {
		//RegDeleteValue(hIDKey,_T("HWID") );
		RegSetValueEx(hIDKey,_T("HWID"),NULL,REG_SZ,(CONST BYTE *)szValue,
								_tcslen((LPCTSTR)szValue) * sizeof(_TCHAR));
		RegCloseKey(hIDKey);
	}

}

//
// Return 0 : if not registred
//        1 : if Registred
//
int CheckIfProductIsRegistred(HINSTANCE hInstance ,
							  _TCHAR * szParamRegKey)
{
	int iReturn ;
	HKEY hKey;
	TCHAR szValueName[256] = _T("");
	TCHAR szRetVal[48];
	DWORD dwSize= 48;
	LONG regStatus ;
	int resSize = LoadString(hInstance,
				IDS_INPUT_ISREGISTERED,szValueName,128);

	iReturn  = 1;

	if (ERROR_SUCCESS != GetProductRoot(szParamRegKey , &hKey))
    {
		return iReturn;
	}
	regStatus = RegQueryValueEx(hKey,
		szValueName,
		NULL,
		0,
		(LPBYTE) szRetVal,
		&dwSize);
	if (regStatus == ERROR_SUCCESS){
		// Verifty the Value
		//
		if(szRetVal[0] == _T('1')) {
			iReturn = 0; // Product Registred flag is set
		}
	}
	RegCloseKey(hKey);
	
	return iReturn;

}



HBITMAP GetOemBmp()
{
       HDC  hDC;
       BOOL bRet;

       // detect this display is 256 colors or not
       hDC = GetDC(NULL);
       bRet = (GetDeviceCaps(hDC, BITSPIXEL) != 8);
       ReleaseDC(NULL, hDC);
       if (bRet)
	   {
		   // the display is not 256 colors, let Windows handle it
          return LoadBitmap(vclRegWizard->GetInstance(),MAKEINTRESOURCE(IDB_BITMAP1));
       }


       LPBITMAPINFO lpBmpInfo;               // bitmap informaiton
       int i;
       HRSRC hRsrc;
	   HANDLE hDib;
	   HBITMAP hBMP;

       struct
	   {
			   WORD            palVersion;
		       WORD            palNumEntries;
			   PALETTEENTRY    PalEntry[256];
	   } MyPal;

       hRsrc = FindResource(vclRegWizard->GetInstance(), MAKEINTRESOURCE(IDB_BITMAP1),RT_BITMAP);
       if (!hRsrc)
         return NULL;

       hDib = LoadResource(vclRegWizard->GetInstance(), hRsrc);
       if (!hDib)
         return NULL;

       if (!(lpBmpInfo = (LPBITMAPINFO) LockResource(hDib)))
               return NULL;

       MyPal.palVersion = 0x300;
       MyPal.palNumEntries = 1 << lpBmpInfo->bmiHeader.biBitCount;

       for (i = 0; i < MyPal.palNumEntries; i++)
	   {
         MyPal.PalEntry[i].peRed   = lpBmpInfo->bmiColors[i].rgbRed;
         MyPal.PalEntry[i].peGreen = lpBmpInfo->bmiColors[i].rgbGreen;
         MyPal.PalEntry[i].peBlue  = lpBmpInfo->bmiColors[i].rgbBlue;
         MyPal.PalEntry[i].peFlags = 0;
       }
       gPal = CreatePalette((LPLOGPALETTE)&MyPal);

       if (gPal == NULL)
	   {        // create palette fail, let window handle the bitmap
          return LoadBitmap(vclRegWizard->GetInstance(),MAKEINTRESOURCE(IDB_BITMAP1));
       }

       hBMP = BitmapFromDib(hDib,gPal,MyPal.palNumEntries);
       UnlockResource(hDib);
	   if( hBMP == NULL ) {
		   DeleteObject(gPal);
		   gPal = NULL;
		   hBMP = LoadBitmap(vclRegWizard->GetInstance(),MAKEINTRESOURCE(IDB_BITMAP1));
       }
	   return hBMP;
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BitmapFromDib(LPVOID hdib, HPALETTE hpal, WORD palSize)                  *
 *                                                                          *
 *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global *
 *               handle to a memory block in CF_DIB format                  *
 *                                                                          *
 *  RETURNS    : A handle to the DDB.                                       *
 *                                                                          *
 ****************************************************************************/

HBITMAP BitmapFromDib (
    LPVOID         pDIB,
    HPALETTE   hpal, WORD wPalSize)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hpalT;
    HDC                 hdc;
    HBITMAP             hbm;



    if (!pDIB || wPalSize == 16 )
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)pDIB; // lock resource


    hdc = GetDC(NULL);

    if (hpal){
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    hbm = CreateDIBitmap(hdc,
                (LPBITMAPINFOHEADER)lpbi,
                (LONG)CBM_INIT,
                (LPSTR)lpbi + lpbi->biSize + wPalSize*sizeof(PALETTEENTRY),
                (LPBITMAPINFO)lpbi,
                DIB_RGB_COLORS );

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    ReleaseDC(NULL,hdc);

    return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\regutil.cpp ===
/*********************************************************************
Registration Wizard

regutil.cpp

Standard RegWizard utility functions 

12/7/94 - Tracy Ferrier
(c) 1994-96 Microsoft Corporation

  Modification History:
  5/26/99 : The Regsitration Version number should have the OS build number 
  The build number should be tahen from HKLM/SW/Ms/Windows NT/CurrentBuildNumber
  eg 3.0.nnnn 
**********************************************************************/

#include <Windows.h>
#include <winnt.h>
#include "regutil.h"
#include "resource.h"
#include <stdio.h>
#include "rwwin95.h"
#include "sysinv.h"
#include "version.h"
#include "rw_common.h"



void EncryptBlock (PTBYTE lpbBlock, DWORD dwBlockSize );
void DecryptBlock (PTBYTE lpbBlock, DWORD dwBlockSize );
#define BITS_PER_BYTE		8
WORD vrgwRot[] = {2,3,2,1,4,2,1,1};

_TUCHAR g_rgchCredits[] = {
#include "credits.h"
};
static  HFONT   shBoldFont;
static  HFONT   shNormalFont;

void InitDlgNormalBoldFont()
{
	shBoldFont   = NULL;
	shNormalFont = NULL;
}
void DeleteDlgNormalBoldFont()
{
	int iInd;
	if(shBoldFont) {
		DeleteObject(shBoldFont);
		RW_DEBUG << "\n In Delete Bold Font:[" << shBoldFont << flush;
	}
	if(shNormalFont){
		DeleteObject(shNormalFont);
		RW_DEBUG << "\n In Delete Normal Font:[" << shNormalFont<< flush;
	}

	shBoldFont   = NULL;
	shNormalFont = NULL;

		
}
// Modified on 04/07/98 
// Previously a font was created for all of the controls, when ever the function is called. 
// Now 2 fonts Normal and Bold is created only once and is used by all the controls calling this fn
//
//
HFONT NormalizeDlgItemFont(HWND hwndDlg,int idControl, int iMakeBold)
/*********************************************************************
This function removes any BOLD weight attribute attached to the
dialog control specified by hwndDlg and idControl.
**********************************************************************/
{
	// This is needed only when running under NT. Under
	// Win95, the dialog text is unbolded by default.
	
	HFONT hfont;
	hfont = NULL;
	
	//if(iMakeBold != RWZ_MAKE_BOLD){
	//	return hfont;
	//}
		if (Windows95OrGreater())
	{

		hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0, 0L);
		if (hfont != NULL){
			LOGFONT lFont;
			if (!GetObject(hfont, sizeof(LOGFONT), (LPTSTR)&lFont))
			{
				hfont = NULL;
			}
			else
			{
				if(iMakeBold == RWZ_MAKE_BOLD){
						lFont.lfWeight = FW_BOLD;
						// Create Bold Font
						if(shBoldFont==NULL){
							shBoldFont = CreateFontIndirect((LPLOGFONT)&lFont);
							RW_DEBUG << "\n\tIn Create Bold Font:[" << shBoldFont << flush;
						}
						hfont = shBoldFont;
				}else {
					lFont.lfWeight = FW_NORMAL;
						// Create Normal Font
						if(shNormalFont==NULL){
							shNormalFont = CreateFontIndirect((LPLOGFONT)&lFont);
							RW_DEBUG << "\n\tIn Create Normal Font:[" << shNormalFont <<  flush;
						}
						hfont = shNormalFont;
				}

							
				if (hfont != NULL)
				{			
				
					SendDlgItemMessage(hwndDlg, idControl, WM_SETFONT,(WPARAM)hfont , 0L);
				}
			}
		}
	}
	
	return hfont;
}


//
//
// Old implementation of NormalizeDlgItemFont(),this fn was used till 
// 4/7/98
// 
void NormalizeDlgItemFont1(HWND hwndDlg,int idControl, int iMakeBold)
/*********************************************************************
This function removes any BOLD weight attribute attached to the
dialog control specified by hwndDlg and idControl.
**********************************************************************/
{
	// This is needed only when running under NT. Under
	// Win95, the dialog text is unbolded by default.
	if (!Windows95OrGreater())
	//if (Windows95OrGreater())
	{
		HFONT hfont = (HFONT)SendMessage(hwndDlg, WM_GETFONT, 0, 0L);
		if (hfont != NULL)
		{
			LOGFONT lFont;
			if (!GetObject(hfont, sizeof(LOGFONT), (LPTSTR)&lFont))
			{
				hfont = NULL;
			}
			else
			{
				if(iMakeBold == RWZ_MAKE_BOLD){
						lFont.lfWeight = FW_BOLD;
				}else {
					lFont.lfWeight = FW_NORMAL;
				}
			
				hfont = CreateFontIndirect((LPLOGFONT)&lFont);
				if (hfont != NULL)
				{
					SendDlgItemMessage(hwndDlg, idControl, WM_SETFONT,(WPARAM)hfont, 0L);
				}
			}
		}
	}
}


void ReplaceDialogText(HWND hwndDlg,int idControl,LPTSTR szText)
/*********************************************************************
For the dialog control indicated by hwndDlg and idControl, this
function replaces the first occurrence of '%s' with the text pointed
to by szText.
**********************************************************************/
{
	_TCHAR szCurrentText[512];
	_TCHAR szTextBuffer[512];
	LRESULT textLen = SendDlgItemMessage(hwndDlg, idControl, WM_GETTEXT, (WPARAM) 512, (LPARAM) szCurrentText);
	_stprintf(szTextBuffer,szCurrentText,szText);
	SendDlgItemMessage(hwndDlg,idControl,WM_SETTEXT,0,(LPARAM) szTextBuffer);
}



void UpgradeDlg(HWND hwndDlg)
/*********************************************************************
Applies an RegWizard defined set of "upgrades" to the dialog whose
handle is given in the hwndDlg parameter.
**********************************************************************/
{
	// Turn SS_BLACKFRAME line into SS_ETCHEDFRAME
	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
	HWND hwndEtchedLine = GetDlgItem(hwndDlg,IDC_ETCHEDLINE);
	if (hwndEtchedLine)
	{
		SetWindowLongPtr(hwndEtchedLine,GWL_STYLE,SS_ETCHEDFRAME | WS_VISIBLE | WS_CHILD);
	}
	//CenterDlg(hwndDlg);// We now set the DS_CENTER window style instead

	if (Windows95OrGreater())
	{
		HICON hIcon = LoadIcon(hInstance,MAKEINTRESOURCE(IDI_REGWIZ));
		SendMessage(hwndDlg,WM_SETICON,(WPARAM) TRUE,(LPARAM) hIcon);
	}
}


void LoadAndCombineString(HINSTANCE hInstance,LPCTSTR szReplaceWith,int idReplacementString,LPTSTR szString)
/*********************************************************************
This function replaces the first occurrence of "%s" in szTarget with 
the string specified by the idReplacementString resource ID, and 
returns the resulting string in the szString parameter.
**********************************************************************/
{
	_TCHAR szTarget[256];
	LoadString(hInstance,idReplacementString,szTarget,256);
	_stprintf(szString,szTarget,szReplaceWith);
}



 void StripCharFromString(LPTSTR szInString, LPTSTR szOutString, _TCHAR charToStrip)
 /***********************************************************************
 Strips the given character from szInString, and returns the result in
 szOutString.
 ************************************************************************/
 {
 	while (1)
	{
		if (*szInString != charToStrip)
		{
		  //*szOutString++ = *szInString;
			_tcscpy(szOutString,szInString);
			szOutString = _tcsinc(szOutString);
		}
		//if (*szInString++ == NULL) return;
		if (*szInString == NULL) return;
		szInString = _tcsinc(szInString);
	};
 }



BOOL GetIndexedRegKeyValue(HINSTANCE hInstance, int enumIndex, LPTSTR szBaseKey,int valueStrID, LPTSTR szValue)
/*********************************************************************
Looks for a subkey, under the Registration Database key given in the
szBaseKey parameter, of the form "0000", "0001", etc.  The numerical
equivalent of the subkey is determined by the index value given in
the enumIndex parameter.  The value attached to the valueName
specified in the string resource whose ID is given in valueStrID will
be returned in szValue.

Returns: FALSE if the key specified is not found. 
**********************************************************************/
{
	_TCHAR szRegKey[256];
	_stprintf(szRegKey,_T("%s\\%04i"),szBaseKey,enumIndex);

	BOOL returnVal = FALSE;
	HKEY hKey;
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRegKey,0,KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[128];
		LoadString(hInstance,valueStrID,szValueName,128);
		unsigned long infoSize = 255;
		regStatus = RegQueryValueEx(hKey,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			returnVal = TRUE;
		}
		RegCloseKey(hKey);
	}
	return returnVal;
}



BOOL FileExists(LPTSTR szPathName)
/***************************************************************************
Returns TRUE if the file specified by the given pathname actually exists.
****************************************************************************/
{
	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;
	HANDLE fileHandle = CreateFile(szPathName,GENERIC_READ,0,&sa,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

	BOOL retValue;
	if (fileHandle == INVALID_HANDLE_VALUE)
	{
		retValue = FALSE;
	}
	else
	{
		retValue = TRUE;
		CloseHandle(fileHandle);
	}
	return retValue;
}


void UppercaseString(LPTSTR sz)
/*********************************************************************
Converts the given string to uppercase, in place.
**********************************************************************/
{
	if (sz)
	{
		while (*sz)
		{
			*sz = _totupper(*sz);
			//sz++;
			sz = _tcsinc(sz);
		}
	}
}

LONG GetResNumber(HINSTANCE hInstance, int iStrResID)
/*********************************************************************
Loads the string whose ID is given by the iStrResID parameter, and
returns the numerical equivalent of the string's value.
**********************************************************************/
{
	_TCHAR szRes[256];
	LoadString(hInstance,iStrResID,szRes,255);
	LONG lResNum = _ttol(szRes);
	return lResNum;
}


BOOL Windows95OrGreater( void )
/*********************************************************************
Returns TRUE if the current operating system is Windows 4.0 or better.
**********************************************************************/
{
	LONG lPlatform, lMajorVersion,lMinorVersion,lBuildNumber;
	GetWindowsVersion(&lPlatform,&lMajorVersion,&lMinorVersion,&lBuildNumber);
	return lMajorVersion >= 4 ? TRUE : FALSE;
}


void DrawTransparentBitmap(HDC hdc, HBITMAP hBitmap, int xStart,int yStart, 
	int xWidth, int yWidth, int xSrc, int ySrc, COLORREF cTransparentColor)
/*********************************************************************
Draws the given bitmap, treating the color given by the 
cTransparentColor parameter as transparent.
**********************************************************************/
{
	BITMAP     bm;
	COLORREF   cColor;
	HBITMAP    bmAndBack, bmAndObject, bmAndMem, bmSave;
	HBITMAP    bmBackOld, bmObjectOld, bmMemOld, bmSaveOld;
	HDC        hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
	POINT      ptSize,ptBmSize;

	hdcTemp = CreateCompatibleDC(hdc);
	SelectObject(hdcTemp, hBitmap);   // Select the bitmap
	GetObject(hBitmap, sizeof(BITMAP), (LPTSTR)&bm);
	ptSize.x = xWidth;            // Get width of bitmap
	ptSize.y = yWidth;           // Get height of bitmap
	ptBmSize.x = bm.bmWidth;            // Get width of bitmap
	ptBmSize.y = bm.bmHeight;           // Get height of bitmap
	DPtoLP(hdcTemp, &ptSize, 1);      // Convert from device
										// to logical points
	// Create some DCs to hold temporary data.
	hdcBack   = CreateCompatibleDC(hdc);
	hdcObject = CreateCompatibleDC(hdc);
	hdcMem    = CreateCompatibleDC(hdc);
	hdcSave   = CreateCompatibleDC(hdc);
   
	// Create a bitmap for each DC. DCs are required for a number of GDI functions.
	// Monochrome DC
	bmAndBack   = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);
	
	// Monochrome DC
	bmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);
	bmAndMem    = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
	bmSave      = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
   
	// Each DC must select a bitmap object to store pixel data.
	bmBackOld   = (HBITMAP) SelectObject(hdcBack, bmAndBack);
	bmObjectOld = (HBITMAP) SelectObject(hdcObject, bmAndObject);
	bmMemOld    = (HBITMAP) SelectObject(hdcMem, bmAndMem);
	bmSaveOld   = (HBITMAP) SelectObject(hdcSave, bmSave);
	
	// Set proper mapping mode.
	SetMapMode(hdcTemp, GetMapMode(hdc));
	
	// Save the bitmap sent here, because it will be overwritten.
	BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, xSrc, ySrc, SRCCOPY);
   
	// Set the background color of the source DC to the color.
	// contained in the parts of the bitmap that should be transparent
	cColor = SetBkColor(hdcTemp, cTransparentColor);
  
  	// Create the object mask for the bitmap by performing a BitBlt
	// from the source bitmap to a monochrome bitmap.
	BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, xSrc, ySrc,SRCCOPY);

	// Set the background color of the source DC back to the original color.
	SetBkColor(hdcTemp, cColor);
   
	// Create the inverse of the object mask.
	BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0,NOTSRCCOPY);
   
	// Copy the background of the main DC to the destination.
	BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart,SRCCOPY);
   
	// Mask out the places where the bitmap will be placed.
	BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);
   
	// Mask out the transparent colored pixels on the bitmap.
	BitBlt(hdcTemp, xSrc, ySrc, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);
	
	// XOR the bitmap with the background on the destination DC.
	BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, xSrc, ySrc, SRCPAINT);
   
	// Copy the destination to the screen.
	BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0,SRCCOPY);
   
	// Place the original bitmap back into the bitmap sent here.
	BitBlt(hdcTemp, xSrc, ySrc, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);
   
	// Delete the memory bitmaps.
	DeleteObject(SelectObject(hdcBack, bmBackOld));
	DeleteObject(SelectObject(hdcObject, bmObjectOld));
	DeleteObject(SelectObject(hdcMem, bmMemOld));
	DeleteObject(SelectObject(hdcSave, bmSaveOld));

	// Delete the memory DCs.
	DeleteDC(hdcMem);
	DeleteDC(hdcBack);
	DeleteDC(hdcObject);
	DeleteDC(hdcSave);
	DeleteDC(hdcTemp);
}


BOOL GetSystemLanguageInfo(LPTSTR lpszLanguage, DWORD dwBufferSize,LANGID* lpLangID)
/*********************************************************************
Returns, in the buffer pointed to by the lpszLanguage parameter, a
string describing the current system language setting.  The
corresponding language ID is returned in the buffer pointed to by
lpLangID (pass NULL for lpLangID if you don't need this value).
**********************************************************************/
{
	LANGID langID = GetSystemDefaultLangID();
	if (lpLangID) *lpLangID = langID;
	DWORD dwRet = VerLanguageName(langID,lpszLanguage,dwBufferSize);
	return dwRet == 0 ? FALSE : TRUE;
}


void GetRegWizardVersionString(HINSTANCE hInstance, LPTSTR lpszVersion)
/*********************************************************************
Returns a string representing the current release version of RegWizard
**********************************************************************/
{
	TCHAR  czBuildNo[24];
	DWORD  dwStatus;
	TCHAR  uszRegKey[128];
	HKEY  hKey; 
	DWORD dwBuildNo,dwInfoSize, dwValueType;

	dwBuildNo = 0;
	uszRegKey[0] = 0;
	LoadString(hInstance, IDS_REREGISTER_OS2, uszRegKey, sizeof(uszRegKey)/sizeof(uszRegKey[0]));
	
	czBuildNo[0] =0;
	dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, uszRegKey, 0, KEY_READ, &hKey);
	if(dwStatus == ERROR_SUCCESS) {
		LoadString(hInstance, IDS_OSBUILDNUMBER, uszRegKey, sizeof(uszRegKey)/sizeof(uszRegKey[0]));
		dwInfoSize = sizeof(czBuildNo);
		RegQueryValueEx(hKey, uszRegKey, NULL, &dwValueType, (LPBYTE)czBuildNo, &dwInfoSize);
		RegCloseKey(hKey);
	}
	wsprintf(lpszVersion,_T("%i.%i.%s"),rmj,rmm,czBuildNo);
	
}


void RegWizardInfo(HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	if (GetKeyState(VK_CONTROL) < 0 && GetKeyState(VK_SHIFT) < 0)
	{
		static BOOL fDecrypt = FALSE;
		long iLen = _tcslen((LPTSTR)g_rgchCredits);
		if (fDecrypt == FALSE)
		{
			fDecrypt = TRUE;
			DecryptBlock((PTBYTE) g_rgchCredits,iLen);
			g_rgchCredits[iLen] = 0;
		}
		_TCHAR rgchVersion[60];
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		GetRegWizardVersionString(hInstance, rgchVersion);

		_TCHAR rgchInfo[340];
		_TCHAR szAbout[256];
    

		LoadString(hInstance,IDD_MICROSOFT_ABOUT_MSG,szAbout,256);
		wsprintf(rgchInfo,szAbout,rgchVersion,0xA9,g_rgchCredits);
		LoadString(hInstance,IDD_MICROSOFT_ABOUT_CAPTION,szAbout,256);
		MessageBox(hwndDlg,rgchInfo,szAbout,MB_OK | MB_ICONINFORMATION);
	}
}

void DecryptBlock (PTBYTE lpbBlock, DWORD dwBlockSize )
/**************************************************************
EncryptBlock decrypts a data block that was encrypted by the
EncryptBlock function.
 
- lpbBlock: a pointer to the block to be decrypted.
- dwBlockSize: the size, in bytes, of the given block.

Returns: nothing.
**************************************************************/
{
	for (DWORD x = 0;x < dwBlockSize;x += 2)
	{
		if ((x + 1) < dwBlockSize)
		{
			lpbBlock[x + 1] = (TBYTE)(lpbBlock[x] ^ lpbBlock[x + 1]);
		}
		WORD wRot = vrgwRot[x & 0x07];
		lpbBlock[x] = (TBYTE) ((lpbBlock[x] >> wRot) + (lpbBlock[x] << (BITS_PER_BYTE - wRot)));

	} 
}



UINT GetRegKeyValue32 ( HKEY hRootKey, LPTSTR const cszcSubKey, LPTSTR const cszcValueName,
	 PDWORD pdwType, PTBYTE pbData, UINT cbData )
/**********************************************************************
Determines the value associated with the specified Registration
Database key and value name.

Returns:
	The cb of the key data if successful, 0 otherwise.
Notes:
	If hRootKey is NULL, HKEY_CLASSES_ROOT is used for the root
***********************************************************************/
{
	HKEY hSubKey;
	LONG lErr;
	DWORD cbSize = (DWORD)cbData;

	if (hRootKey == NULL)
		hRootKey = HKEY_CLASSES_ROOT;

	lErr = RegOpenKeyEx(hRootKey, cszcSubKey, 0, KEY_READ, &hSubKey);
	if (lErr != ERROR_SUCCESS)
	{
		pdwType[0] = NULL;
		return 0;	/* Return 0 if the key doesn't exist */
	}

	lErr = RegQueryValueEx(hSubKey, (LPTSTR)cszcValueName, NULL, pdwType, (LPBYTE)pbData,
						   &cbSize);
	RegCloseKey(hSubKey);
	if (lErr != ERROR_SUCCESS)
	{
		pdwType[0] = NULL;
		return 0;	/* Return 0 if the value doesn't exist */
	}

	return (UINT)cbSize;
}


BOOL FSetDialogTabOrder(HWND hwndDlg,LPTSTR szTabOrder)
/*********************************************************************
FSetDialogTabOrder sets the tabbing order of all controls in a dialog.
Optionally, the control that should initially have the focus can be
set at the same time.

hwndDlg: handle to the dialog containing the controls.
szTabOrder: a string containing the dlg ID's of all controls in the
dialog, separated by commas.  The order of the ID's in the string
determines what the new tabbing order will be.  If any ID is 
immediately followed with 'F', the corresponding control will be
given the initial input focus.
Example: "1001,1002,105F,72,1006,1005,1007,1008"

Returns:
- TRUE: Tabbing order successfully set
- FALSE: one or more ID's in szTabOrder did not correspond to a valid
			control in the given dialog.
**********************************************************************/
{
	if (szTabOrder == NULL || szTabOrder[0] == NULL) return FALSE;

	LPTSTR sz = szTabOrder;
	int iCtrl1 = 0;
	int iCtrl2 = 0;
	while (*sz)
	{
		LPTSTR szEnd;
		iCtrl1 = iCtrl2;
		iCtrl2 = _tcstol(sz,&szEnd,10);
		HWND hwndCtrl1 = GetDlgItem(hwndDlg, iCtrl1);
		HWND hwndCtrl2 = GetDlgItem(hwndDlg, iCtrl2);
		if (!hwndCtrl2) return FALSE;

		if (*szEnd == _T('F') || *szEnd == _T('f'))
		{
			if (hwndCtrl2) SetFocus(hwndCtrl2);
			//szEnd++;
			szEnd = _tcsinc(szEnd);
		}
		if (hwndCtrl1 && hwndCtrl2)
		{
			SetWindowPos(hwndCtrl2,hwndCtrl1,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE);
		}
		//sz = *szEnd == NULL ? szEnd : szEnd+1;
		sz = (*szEnd == NULL) ? szEnd : _tcsinc(szEnd);
	}
	return TRUE;
}


BOOL FResSetDialogTabOrder(HWND hwndDlg, UINT wResStringID)
/*********************************************************************
Same as FSetDialogTabOrder, except that instead of passing a pointer
to a string, the wResStringID parameter specifies a string in the 
resource string table.  

Returns:
If the string represented by wResStringID cannot be loaded, or if one
or more of the ID's in the loaded string do not correspond to a valid
dialog control, FALSE will be returned as the function result.
**********************************************************************/
{
	_TCHAR rgchTabOrder[256];
	HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
	if (LoadString(hInstance,wResStringID,rgchTabOrder,256) > 0)
	{
		return FSetDialogTabOrder(hwndDlg,rgchTabOrder);
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\name_fe.cpp ===
/*********************************************************************
Registration Wizard

Name_FE.cpp
03/11/98 - Suresh Krishanan
Name Screen for Far East Countries

Specification : 02/28/98
	- The Pronunciation field is enable only for JAPAN and for other
	FE countries it is disabled.

	- The USER ID is only for JAPAN and for other FarEast countries
	it should be deleted i.e do not display.

	- While sending the information to the back end, the name will
	be sent as FirstName and the Pronunciation will be
	sent as Last Name.
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include "RegPage.h"
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include "rw_common.h"
#include <fe_util.h>


typedef enum
{
	kPurchaseUndefined,
	kPurchaseBySelf,
	kPurchaseByCompany
}PurchaseType;

static PurchaseType vPurchaseType = kPurchaseUndefined;
void ConfigureFENameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateFENameDialog(HWND hwndDlg);
int ValidateFENameEditFields(HWND hwndDlg);
BOOL GetDefaultCompanyName(CRegWizard* pclRegWizard,LPTSTR szValue);

INT_PTR CALLBACK NameFEDialogProc(	HWND hwndDlg,
								UINT uMsg,
								WPARAM wParam,
								LPARAM lParam )
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the
user's name and company.
**********************************************************************/
{
	CRegWizard* pclRegWizard = NULL;
	static INT_PTR iRet;
	_TCHAR szInfo[256];
    BOOL bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;		
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;			
        case WM_INITDIALOG:
		{
			_TCHAR szCallingContext[64];
			
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			RW_DEBUG << "\n  INIT DIALOG " << pi->iCancelledByUser << flush;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);

			//UpgradeDlg(hwndDlg);
			
			
			NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT4); // Company
			NormalizeDlgItemFont(hwndDlg,IDT_DIVISION); //Division

			if(GetFeScreenType() == kFEWithJapaneaseScreen ) {
				// Enable USER ID
				ShowWindow(GetDlgItem(hwndDlg,IDT_USERID),SW_SHOW);
				ShowWindow(GetDlgItem(hwndDlg,IDC_USERID), SW_SHOW);
				EnableWindow (GetDlgItem(hwndDlg,IDC_USERID), TRUE);
				NormalizeDlgItemFont(hwndDlg,IDT_USERID); //Division
			}

			NormalizeDlgItemFont(hwndDlg,IDC_GROUP1);
			
			SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			//pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szCallingContext);
			//ReplaceDialogText(hwndDlg,IDT_TEXT1,szCallingContext);
			
			if (pclRegWizard->GetInformationString(kInfoFirstName,szInfo)){
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
				vPurchaseType = kPurchaseBySelf;
			}


			if(GetFeScreenType() == kFEWithJapaneaseScreen ) {
				// FOR JAPAN fill the Pronunciation info  and User ID
				if (pclRegWizard->GetInformationString(kInfoLastName,szInfo)){
					SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
				}
				if (pclRegWizard->GetInformationString(kUserId,szInfo)){
					SendDlgItemMessage(hwndDlg,IDC_USERID,WM_SETTEXT,0,(LPARAM) szInfo);
				}
			}else {
				//
				// Disable Pronunciation for other FE countries
				EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT2),FALSE);
				EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT3),FALSE);
			}


             // fix 381069

            if (pclRegWizard->GetInformationString(kInfoEmailName,szInfo))
            {
                SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_SETTEXT,0,(LPARAM) szInfo);
            }			
			
			BOOL isCompanyNameValid = FALSE;
			if (pclRegWizard->GetInformationString(kInfoCompany,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
				if (szInfo[0])
				{
					isCompanyNameValid = TRUE;
					vPurchaseType = kPurchaseByCompany;
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
					EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT3),TRUE);
					SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
					EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT4),TRUE);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					// Enable  Division Name
					EnableWindow(GetDlgItem(hwndDlg,IDC_DIVISION),TRUE);
					EnableWindow(GetDlgItem(hwndDlg,IDT_DIVISION),TRUE);
					//
					//
					if (pclRegWizard->GetInformationString(kDivisionName,szInfo)){
						SendDlgItemMessage(hwndDlg,IDC_DIVISION,WM_SETTEXT,0,(LPARAM) szInfo);
					}

				}
				else
				{
					vPurchaseType = kPurchaseBySelf;
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					EnableWindow(GetDlgItem(hwndDlg,IDC_EDIT3),FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDT_TEXT4),FALSE);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
					// Disable Division Name
					EnableWindow(GetDlgItem(hwndDlg,IDC_DIVISION),FALSE);
				}
			}
			else
			{
				if(	vPurchaseType != kPurchaseBySelf)
				{
					vPurchaseType = kPurchaseUndefined;
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
				}
				else
				{
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
				}
			}

			SendDlgItemMessage(hwndDlg,IDC_EDIT1,EM_SETSEL,0,-1);
			ConfigureFENameEditFields(pclRegWizard,hwndDlg);

			HWND hwndNameField = GetDlgItem(hwndDlg,IDC_EDIT1);
			SetFocus(hwndNameField);

			vDialogInitialized = TRUE;
			//pclRegWizard->ActivateRegWizardDialog();
            return TRUE;
		}
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
				// Cancel is not Pressed
					iRet=0;
					if( ValidateFENameDialog(hwndDlg)) {
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoFirstName,szInfo);
						// pronunciation
						if ( GetFeScreenType() == kFEWithJapaneaseScreen ) {
							SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
							pclRegWizard->SetInformationString(kInfoLastName,szInfo);
						}

						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoCompany,szInfo);

						// Division
						SendDlgItemMessage(hwndDlg,IDC_DIVISION,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kDivisionName,szInfo);

                        // E-mail:  fix 381069 
 
                        SendDlgItemMessage(hwndDlg,IDC_EDIT4,WM_GETTEXT,255,(LPARAM) szInfo);
                        pclRegWizard->SetInformationString(kInfoEmailName,szInfo);
						
						// User ID
						if ( GetFeScreenType() == kFEWithJapaneaseScreen ) {
							SendDlgItemMessage(hwndDlg,IDC_USERID,WM_GETTEXT,255,(LPARAM) szInfo);
							pclRegWizard->SetInformationString(kUserId,szInfo);
						}


						pclRegWizard->WriteEnableInformation(kInfoCompany,vPurchaseType == kPurchaseBySelf ? FALSE : TRUE);
						// pclRegWizard->EndRegWizardDialog(wParam);
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
						pi->CurrentPage++;
					
					}else {
						// Force it it be in this screen
						iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
				}
				break;

            case PSN_WIZBACK:
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet=0;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kNameDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        }
        break;
		case WM_COMMAND:{
            if (vPurchaseType == kPurchaseUndefined){
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
            }
            BOOL selfChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO1);
            BOOL companyChecked = IsDlgButtonChecked(hwndDlg,IDC_RADIO2);
            if (selfChecked)
            {
                vPurchaseType = kPurchaseBySelf;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK );
                //EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
            }
            else if (companyChecked)
            {
                vPurchaseType = kPurchaseByCompany;
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK);
                // EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
            }
            BOOL shouldEnable = vPurchaseType == kPurchaseByCompany ? TRUE : FALSE;
            HWND hwndCompanyField = GetDlgItem(hwndDlg,IDC_EDIT3);
            HWND hwndCompanyLabel = GetDlgItem(hwndDlg,IDT_TEXT4);
            if (IsWindowEnabled(hwndCompanyField) != shouldEnable)
            {
                EnableWindow(hwndCompanyField,shouldEnable);
                EnableWindow(hwndCompanyLabel,shouldEnable);
                // Division enable
                EnableWindow(GetDlgItem(hwndDlg,IDT_DIVISION),shouldEnable);
                EnableWindow(GetDlgItem(hwndDlg,IDC_DIVISION),shouldEnable);

                if(!shouldEnable)
                {
                    SetDlgItemText(hwndDlg,IDC_EDIT3,_T(""));
                    SetDlgItemText(hwndDlg,IDC_DIVISION,_T(""));
                }
                else
                {
                    SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,
                                                            (LPARAM) szInfo);
                    if(!szInfo[0])
                    {
                        if(GetDefaultCompanyName(pclRegWizard,szInfo))	
                        {
                            SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,
                                                        255,(LPARAM) szInfo);
                        }
                    }
                }
            }
		 }// WM_COMMAND
		break;
        default:
		bStatus = FALSE;
        break;
    }
    return bStatus;
}


BOOL ValidateFENameDialog(HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Name
dialog.  If any required edit field input is empty, ValidateFENameDialog
will put up a message box informing the user of the problem, and set
the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateFENameEditFields(hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szAttached[256];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szAttached,256);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szAttached,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndNameField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndNameField);
		return FALSE;
	}
}



int ValidateFENameEditFields(HWND hwndDlg)
/*********************************************************************
ValidateAddrEditFields validates all edit fields in the Address
dialog.  If any required field is empty, the ID of the edit field
control will be returned as the function result.  If all fields are
OK, NULL will be returned.
**********************************************************************/
{
	
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_DIVISION)) return IDC_DIVISION;
	if (GetFeScreenType() == kFEWithJapaneaseScreen ) {
		if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_USERID)) return IDC_USERID;
	}
	return NULL;
}


void ConfigureFENameEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecFirstName,IDT_TEXT2);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecLastName,IDT_TEXT3);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecCompanyName,IDT_TEXT4);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_DIVISION,kAddrSpecDivision,IDT_DIVISION);
	if(GetFeScreenType() == kFEWithJapaneaseScreen ) {
		pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_USERID,kAddrSpecUserId,IDT_USERID);

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\reseldlg.cpp ===
/*********************************************************************
Registration Wizard

ResellerDialog
10/19/94 - Tracy Ferrier
02/12/98 - Suresh Krishnan
(c) 1994-95 Microsoft Corporation
**********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include <RegPage.h>
#include "RegWizMain.h"
#include "Resource.h"
#include "Dialogs.h"
#include "regutil.h"
#include  <rw_common.h>

static int vDeclineOffers = -1;
static PROPSHEETPAGE  *spAddrSheet=NULL;
static TCHAR  szResellerSubTitle[256]=_T(""); // used for Sub Title

void ConfigureResellerEditFields(CRegWizard* pclRegWizard,HWND hwndDlg);
BOOL ValidateResellerDialog(HWND hwndDlg);
int ValidateResellerEditFields(HWND hwndDlg);

///////////////////////////////
//#define CREATE_TAB_ORDER_FILE
///////////////////////////////

INT_PTR CALLBACK ResellerDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
/*********************************************************************
Dialog Proc for the Registration Wizard dialog that requests the
name, city, and state of the reseller that sold the software to the
user.
**********************************************************************/
{
	CRegWizard* pclRegWizard;
	INT_PTR iRet;
	_TCHAR szInfo[256];
    INT_PTR bStatus;
	TriState shouldInclude;

	pclRegWizard = NULL;
	bStatus = TRUE;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {

		case WM_CLOSE:
			if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) pclRegWizard->EndRegWizardDialog(IDB_EXIT);
            break;
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
			break;	
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			
			//UpgradeDlg(hwndDlg);
			HWND hwndResellerNameField = GetDlgItem(hwndDlg,IDC_EDIT1);
			SetFocus(hwndResellerNameField);
			NormalizeDlgItemFont(hwndDlg,IDC_TITLE, RWZ_MAKE_BOLD);
			NormalizeDlgItemFont(hwndDlg,IDC_SUBTITLE);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT1);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT2);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT3);
			NormalizeDlgItemFont(hwndDlg,IDT_TEXT9);
						
			//SetWindowText(hwndDlg,pclRegWizard->GetWindowCaption());

			_TCHAR rgchCallingContext[256];
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,rgchCallingContext);
			LoadString(pi->hInstance,IDS_RESELLER_SCR_STITLE,szResellerSubTitle,256);
			_tcscat(szResellerSubTitle,_T(" "));
 			_tcscat(szResellerSubTitle,rgchCallingContext);
			_tcscat(szResellerSubTitle,_T("?"));
			spAddrSheet->pszHeaderSubTitle = szResellerSubTitle;


			//ReplaceDialogText(hwndDlg,IDC_SUBTITLE,rgchCallingContext);
			if (pclRegWizard->GetInformationString(kInfoResellerName,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			if (pclRegWizard->GetInformationString(kInfoResellerCity,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			else if (pclRegWizard->GetInformationString(kInfoCity,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			if (pclRegWizard->GetInformationString(kInfoResellerState,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
			}
			else if (pclRegWizard->GetInformationString(kInfoState,szInfo))
			{
				SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_SETTEXT,0,(LPARAM) szInfo);
			}

			ConfigureResellerEditFields(pclRegWizard,hwndDlg);

			SendDlgItemMessage(hwndDlg,IDC_EDIT1,EM_SETSEL,0,-1);
			// To remove the default checking of the radio button for the first entry

			shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
			if (shouldInclude == kTriStateTrue )
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				vDeclineOffers = 0;
			}
			else if (shouldInclude == kTriStateFalse)
			{
				CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				vDeclineOffers = 1;
			}
			else if (shouldInclude == kTriStateUndefined)
			{
				PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
				vDeclineOffers = -1;
			}
			
			vDialogInitialized = TRUE;
            return TRUE;
		} // WM_INIT
		break;
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				RW_DEBUG << "\n PSN_ACTIVE   " << (ULONG)wParam << flush;
                //PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK PSWIZB_NEXT );
				pi->iCancelledByUser = RWZ_PAGE_OK;
				//PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
				shouldInclude = pclRegWizard->GetTriStateInformation(kInfoDeclinesNonMSProducts);
				if (shouldInclude == kTriStateTrue ){
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1);
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					vDeclineOffers = 0;
				}
				if (shouldInclude == kTriStateFalse){
					CheckRadioButton(hwndDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2);
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
					vDeclineOffers = 1;
				}
				if (shouldInclude == kTriStateUndefined){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK );
					vDeclineOffers = -1;
				}
				// Enable for previpously entred value in screen
				if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1)){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}
				if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2)){
					PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
				}

                break;

            case PSN_WIZNEXT:
				RW_DEBUG << "\n PSN_NEXT  " << (ULONG)wParam << flush;
				
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
					iRet=0;
					if( ValidateResellerDialog(hwndDlg) ) {
						pclRegWizard->EndRegWizardDialog((int) wParam);
						SendDlgItemMessage(hwndDlg,IDC_EDIT1,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoResellerName,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT2,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoResellerCity,szInfo);
						SendDlgItemMessage(hwndDlg,IDC_EDIT3,WM_GETTEXT,255,(LPARAM) szInfo);
						pclRegWizard->SetInformationString(kInfoResellerState,szInfo);
						if(vDeclineOffers == -1){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateUndefined);
						}
						else
						if(vDeclineOffers == 0){
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateFalse);
						}
						else{
							pclRegWizard->SetTriStateInformation(kInfoDeclinesNonMSProducts,kTriStateTrue);
						}
						_stprintf(szInfo,_T("%i"),vDeclineOffers);
						pclRegWizard->SetInformationString(kInfoDeclinesNonMSProducts,szInfo);
						pi->CurrentPage++;
						pi->iLastKeyOperation = RWZ_NEXT_PRESSED;
					}else {
					// Force it it be in this screen
					iRet=-1;
					}
					SetWindowLongPtr( hwndDlg ,DWLP_MSGRESULT, (INT_PTR) iRet);
				}
				break;

            case PSN_WIZBACK:
				
				pi->iLastKeyOperation = RWZ_BACK_PRESSED;
				RW_DEBUG << "\n PSN_BACK  " << (ULONG)wParam << flush;
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
					RW_DEBUG << "\n PSN_CANCEL  " << (ULONG)wParam << flush;
				if (CancelRegWizard(pclRegWizard->GetInstance(),hwndDlg)) {
					//pclRegWizard->EndRegWizardDialog(IDB_EXIT) ;
					iRet = 1;
					pi->ErrorPage  = kProductInventoryDialog;
					pi->iError     = RWZ_ERROR_CANCELLED_BY_USER;
					SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet);
					pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
					PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);

				}else {
					//
					// Prevent Cancell Operation as User does not want to Cancel
					iRet = 1;

				}
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 				
				break;
				default:
                //bStatus = FALSE;
                break;
            }
        } // WM_Notify
		break;

		

        case WM_COMMAND:
		{
			
            switch (wParam)
            {
              case  IDC_RADIO1:
			  case  IDC_RADIO2:
				if (vDialogInitialized){
						// If the 'No' button is checked, the user is declining
						// the "Non-Microsoft product" offers
						if(IsDlgButtonChecked(hwndDlg,IDC_RADIO1))
						{
							vDeclineOffers = 1;
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
							//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
						}
						else
						if(IsDlgButtonChecked(hwndDlg,IDC_RADIO2))
						{
							vDeclineOffers = 0;
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK | PSWIZB_NEXT );
							//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),TRUE);
						}
						else
						{
							vDeclineOffers = -1;
							PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_BACK  );
							//EnableWindow(GetDlgItem(hwndDlg,IDB_NEXT),FALSE);
						}

					}
                    break;
			  default:
				  break;
			}
		}// WM_COMMAND
		break;
		
		
		default :
		bStatus = FALSE;

        break;
    }
    return bStatus;
}






BOOL ValidateResellerDialog(HWND hwndDlg)
/*********************************************************************
Returns TRUE if all required user input is valid in the Reseller
dialog.  If any required edit field input is empty,
ValidateResellerDialog will put up a message box informing the user
of the problem, and set the focus to the offending control.
**********************************************************************/
{
	int iInvalidEditField = ValidateResellerEditFields(hwndDlg);
	if (iInvalidEditField == NULL)
	{
		return TRUE;
	}
	else
	{
		_TCHAR szLabel[128];
		_TCHAR szMessage[256];
		CRegWizard::GetEditTextFieldAttachedString(hwndDlg,iInvalidEditField,szLabel,128);
		HINSTANCE hInstance = (HINSTANCE) GetWindowLongPtr(hwndDlg,GWLP_HINSTANCE);
		LoadAndCombineString(hInstance,szLabel,IDS_BAD_PREFIX,szMessage);
		RegWizardMessageEx(hInstance,hwndDlg,IDD_INVALID_DLG,szMessage);
		HWND hwndResellerField = GetDlgItem(hwndDlg,iInvalidEditField);
		SetFocus(hwndResellerField);
		return FALSE;
	}
}


int ValidateResellerEditFields(HWND hwndDlg)
/*********************************************************************
ValidateResellerEditFields validates all edit fields in the Reseller
dialog.  If any required field is empty, the ID of the first empty
edit field control will be returned as the function result.  If all
fields are OK, NULL will be returned.
**********************************************************************/
{
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT1)) return IDC_EDIT1;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT2)) return IDC_EDIT2;
	if (!CRegWizard::IsEditTextFieldValid(hwndDlg,IDC_EDIT3)) return IDC_EDIT3;
	return NULL;
}


void ConfigureResellerEditFields(CRegWizard* pclRegWizard,HWND hwndDlg)
/*********************************************************************
**********************************************************************/
{
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT1,kAddrSpecResellerName,IDT_TEXT1);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT2,kAddrSpecResellerCity,IDT_TEXT2);
	pclRegWizard->ConfigureEditTextField(hwndDlg,IDC_EDIT3,kAddrSpecResellerState,IDT_TEXT3);
}



//
//  This function is calles during the creation and deletion of
//  Address Property Sheet
//  Store the Address of PPROPSHEETPAGE so the Subtitle can be changed
//
//
//
UINT CALLBACK ResellerPropSheetPageProc(HWND hwnd,
								UINT uMsg,
								LPPROPSHEETPAGE ppsp
								)
{
	
	switch(uMsg) {
	case PSPCB_CREATE :
		spAddrSheet = ppsp;
	default:
		break;

	}
	return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizctrl\crwctrl.h ===
// CRegWizCtrl.h : Declaration of the CRegWizCtrl

#ifndef __REGWIZCTRL_H_
#define __REGWIZCTRL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CRegWizCtrl
class ATL_NO_VTABLE CRegWizCtrl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRegWizCtrl, &CLSID_RegWizCtrl>,
	public IObjectWithSiteImpl<CRegWizCtrl>,
	public ISupportErrorInfo,
	public IDispatchImpl<IRegWizCtrl, &IID_IRegWizCtrl, &LIBID_REGWIZCTRLLib>
{
public:
	CRegWizCtrl()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_REGWIZCTRL)

BEGIN_COM_MAP(CRegWizCtrl)
	COM_INTERFACE_ENTRY(IRegWizCtrl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IRegWizCtrl
public:
	STDMETHOD(get_Version)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(TransferOEMRegWizInformation)(BSTR InformationPath);
	STDMETHOD(get_HWID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_HWID)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_MSID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_MSID)(/*[in]*/ BSTR newVal);
	STDMETHOD(TransferRegWizInformation)(BSTR  InformationPath);
	STDMETHOD(InvokeRegWizard)(BSTR ProductPath);
	STDMETHOD(get_IsRegistered)(VARIANT_BOOL *pbStatus);
	STDMETHOD(put_IsRegistered)(BSTR ProductPath);
};

#endif //__REGWIZCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizctrl\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__50E5E3CC_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_)
#define AFX_DLLDATAX_H__50E5E3CC_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__50E5E3CC_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\welcdlg.cpp ===
/*********************************************************************
Registration Wizard

WelcomeDialog.cpp
10/13/94 -  Tracy Ferrier
02/11/98 -  Suresh Krishnan
(c) 1994-95 Microsoft Corporation
8/20/98 - The "Use Windows Update .."  text is disabled for non OS products
**********************************************************************/

#include <Windows.h>
#include <RegPage.h>
#include <Resource.h>
#include "RegWizMain.h"
#include "Dialogs.h"
#include "regutil.h"
#include <stdio.h>
#include "version.h"
#include "rwwin95.h"
#include "rw_common.h"
#include "rwpost.h"

//
//
//  Returns 1 if Success
//          0 if failure
int GetOsName(HINSTANCE hIns, TCHAR *szOsName)
{
	HKEY hKey;
	TCHAR szOsPath[256];
	TCHAR szParamSubKey[64];
	int iRet;
	unsigned long infoSize;
	infoSize = 256; // Size of Buffer

	iRet = 0;
	LONG regStatus ;
	LoadString(hIns,IDS_REREGISTER_OS2,szOsPath,255);
	LoadString(hIns,IDS_INPUT_PRODUCTNAME,szParamSubKey,63);

	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szOsPath,0,KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS) {
		
		regStatus = RegQueryValueEx(hKey ,szParamSubKey, NULL,0,(LPBYTE) szOsName,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			iRet = 1;
		}
		RegCloseKey(hKey);
	}

	return iRet;

	
}

INT_PTR CALLBACK WelcomeDialogProc(HWND hwndDlg, 
						UINT uMsg, 
						WPARAM wParam, LPARAM lParam)
/*********************************************************************
Main entry point for the Registration Wizard.
**********************************************************************/
{
	 INT_PTR bStatus = TRUE;
	 CRegWizard* pclRegWizard = NULL;
	_TCHAR szCallingContext[256];
	_TCHAR szText2[256];
	_TCHAR szTemp[128];
	_TCHAR szButtonText[48];
	_TCHAR szOsName[256];
	DWORD  dwConnectivity;
	 INT_PTR iRet;
	 int iCurPage;
	 static int iFirstTimeEntry=1; // This is to verify for Network connection
	LONG_PTR lStyle;

	PageInfo *pi = (PageInfo *)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
	if(pi) {
		pclRegWizard = pi->pclRegWizard;
	}

    switch (uMsg)
    {				
		case WM_DESTROY:
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, NULL );
        break;
        case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			pi->iCancelledByUser = RWZ_PAGE_OK;
			pclRegWizard = pi->pclRegWizard;
			SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pi );
			SetControlFont( pi->hBigBoldFont, hwndDlg, IDT_TEXT1);
			pclRegWizard->GetInputParameterString(IDS_INPUT_PRODUCTNAME,szCallingContext);
			_tcscpy(szText2,szCallingContext);

			// appending ,so Microsoft can  
			//LoadString(pclRegWizard->GetInstance(),
			//IDS_WELCOME_SCR_TEXT22,szTemp,128);
			//_tcscat(szText2,szTemp);
					
								
			ReplaceDialogText(hwndDlg,IDT_TEXT1,szCallingContext);
			ReplaceDialogText(hwndDlg,IDT_TEXT2,szText2);
			// if the product being registered is not Windows NT OS  then do not 
			// display the Windows Updat site text
			szOsName[0] = _T('\0');
			GetOsName(pclRegWizard->GetInstance(),szOsName);

			
			HWND hParent = GetParent(hwndDlg);

			lStyle = GetWindowLongPtr( hParent, GWL_STYLE);
			lStyle &= ~WS_SYSMENU;
			SetWindowLongPtr(hParent,GWL_STYLE,lStyle);
			
			if(_tcscmp(szCallingContext,szOsName)){
				ShowWindow(GetDlgItem(hwndDlg,IDC_TEXT7),SW_HIDE);//SW_SHOW);
			}

            return TRUE;
		}
		case WM_NOTIFY:
        {   LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code ){
            case PSN_SETACTIVE:
				pi->iCancelledByUser = RWZ_PAGE_OK;
				PropSheet_SetTitle(GetParent( hwndDlg ),0,pclRegWizard->GetWindowCaption());
                PropSheet_SetWizButtons( GetParent( hwndDlg ), PSWIZB_NEXT);
				LoadString(pclRegWizard->GetInstance(),
						IDS_REGISTERLATER_BUTTONTEXT,
						szButtonText,16);

				// Limiting the Button Text to 16
				// As mo
				SetWindowText(GetDlgItem( GetParent( hwndDlg ),2),szButtonText); 
            break;
			case PSN_KILLACTIVE  :
				LoadString(pclRegWizard->GetInstance(),
						IDS_CANCEL_BUTTONTEXT,
						szButtonText,16);

				// Limiting the Button Text to 16
				// As mo
				SetWindowText(GetDlgItem( GetParent( hwndDlg ),2),szButtonText); 
				 
			break;
            case PSN_WIZNEXT:
			//  Check if it is cancelled bt the user
			//  if so then switch to the last Page
			//					
				if(pi->iCancelledByUser == RWZ_CANCELLED_BY_USER ) {
					pi->CurrentPage=pi->TotalPages-1;
					PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

				}else {
				//
				// User Has Not pressed Next 					
					if(iFirstTimeEntry) {
						iFirstTimeEntry = 0;
						pi->dwConnectionType = 0; // Init to Zero
						dwConnectivity =  (DWORD)CheckWithDisplayInternetConnectivityExists(pi->hInstance,hwndDlg);  
						//dwConnectivity = DIALUP_REQUIRED;
						switch(dwConnectivity) {
							case DIALUP_NOT_REQUIRED :
							case DIALUP_REQUIRED     :
								pi->dwConnectionType = dwConnectivity;
								break;
								//
								// The System is OK so proceed to the next screen 
							case RWZ_ERROR_NOTCPIP: // NO TCP_IP
							case CONNECTION_CANNOT_BE_ESTABLISHED: // NO Proper Modem or RAS
							default :
								// Set the NEXT so it goes to the lase Page
								pi->ErrorPage  = kWelcomeDialog;
								pi->iError     = dwConnectivity;
								pi->CurrentPage=pi->TotalPages-1;
								PropSheet_SetCurSel(GetParent(hwndDlg),NULL,pi->TotalPages-1);

								//pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
								//PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
							break;
						}
												
					}
					pi->CurrentPage++;
				}
					
					
				
			break;
            case PSN_WIZBACK:
                pi->CurrentPage--;

                break;
			case PSN_QUERYCANCEL :
				iRet = 1;
				pi->ErrorPage  = kWelcomeDialog;
				pi->iError     = RWZ_ERROR_REGISTERLATER ;
				SetWindowLongPtr( hwndDlg,DWLP_MSGRESULT, (INT_PTR) iRet); 
				pi->iCancelledByUser = RWZ_CANCELLED_BY_USER;
				PropSheet_PressButton (GetParent( hwndDlg ),PSBTN_NEXT);
			break;
            default:
                //bStatus = FALSE;
                break;
            }
        }
        break;
      
        default:
			bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizctrl\cathelp.cpp ===
//=--------------------------------------------------------------------------=
// CatHelp.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "stdafx.h"

#include <comcat.h>

//const CATID CATID_SafeForScripting      = {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

//const CATID CATID_SafeForInitializing   = {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\sysinv.cpp ===
/*********************************************************************
Registration Wizard

sysinv.cpp
02/24/98  - Suresh Krishnan
07/20/98  - Suresh Krishnan
		    GetSCSIAdapterString() function is addded to get SCSI adapter details
	
(c) 1994-95 Microsoft Corporation
08/06/98   GetDisplayResolutionString() is  modified so it now gets Display Adapter with Resolution
**********************************************************************/
#include <tchar.h>
#include <Windows.h>
#include <stdio.h>
#include "sysinv.h"
#include "resource.h"


// The packed structures below get messed up with optimizations turned on
#pragma optimize( _T(""), off )

typedef BOOL   (APIENTRY *GETSYSTEMINVENTORY) ( INT ,LPTSTR );
HINSTANCE   hSiDllInst=NULL;
GETSYSTEMINVENTORY m_fp = NULL ;
BOOL WINAPI GetSystemInventory(INT type, LPTSTR szInventory)
{
	static int iEntry=0;
	if(!iEntry) {
		hSiDllInst = LoadLibrary(_T("SYSINV.DLL"));

		if(hSiDllInst == NULL ) {
			m_fp = NULL;
			iEntry = 1;
			return FALSE;
		}

	#ifdef UNICODE
		m_fp = (GETSYSTEMINVENTORY ) GetProcAddress(hSiDllInst, "GetSystemInventoryW");
	#else
		m_fp = (GETSYSTEMINVENTORY ) GetProcAddress(hSiDllInst, "GetSystemInventoryA");
	#endif
		iEntry = 1;
	}
	if(m_fp){
		return (*m_fp)(type ,szInventory);
	}else {
		return FALSE;
	}

}

int CheckSysInvDllPresent()
{
	int iRet;
	iRet = SYSINV_DLL_NOTPRESENT;
	HANDLE  hSi;
	hSi = LoadLibrary(_T("SYSINV.DLL"));
	if(hSi) {
		iRet = SYSINV_DLL_PRESENT;
	}
	return iRet;

}

void GetOEMString(HINSTANCE hInstance, LPTSTR szOEM)
/*********************************************************************
Returns a string containing the name of the Original Equipment
Manufacturer.
**********************************************************************/
{
	GetSystemInventory(INV_OEM, szOEM);
	
}


void GetProcessorTypeString(HINSTANCE hInstance, LPTSTR szProcessor)

{
	GetSystemInventory(INV_PROCESSORTYPE, szProcessor);
}

void GetTotalMemoryString(HINSTANCE hInstance, LPTSTR szTotalMemory)
{
	GetSystemInventory(INV_TOTALMEMORY,szTotalMemory);
}

void GetTotalHardDiskSpaceString(HINSTANCE hInstance, LPTSTR szTotalHardDiskSpace)
{
	GetSystemInventory(INV_TOTALHDSPACE,szTotalHardDiskSpace);
}

void GetDisplayResolutionString(HINSTANCE hInstance, LPTSTR szDisplayResolution)

{	
	GetSystemInventory(INV_DISPLAY_WITH_RESOLUTION,szDisplayResolution);
}


void GetDisplayColorDepthString(HINSTANCE hInstance, LPTSTR szDisplayColorDepth)
/*********************************************************************
Returns a string that describes the color depth (number of colors
available).
**********************************************************************/
{
	GetSystemInventory(INV_DISPCOLORDEPTH,szDisplayColorDepth);
}


void GetWindowsVersionString(HINSTANCE hInstance, LPTSTR szVersion)
/*********************************************************************
Returns a string describing the platform and verson of the currently
operating Windows OS.
**********************************************************************/
{
	GetSystemInventory(INV_WINVERSION,szVersion);
}


void GetNetworkCardString(HINSTANCE hInstance, LPTSTR szNetwork)
{
	GetSystemInventory(INV_NETCARD,szNetwork);
}


void GetModemString(HINSTANCE hInstance, LPTSTR szModem)
{
	GetSystemInventory(INV_MODEM,szModem);
}

void GetSCSIAdapterString(HINSTANCE hInstance, LPTSTR szScsi)
{
	GetSystemInventory(INV_SCSIADAPTER,szScsi);
}

void GetPointingDeviceString(HINSTANCE hInstance, LPTSTR szPointingDevice)
/*********************************************************************
Returns a string describing all pointing devices (mouse, tablet, etc.)
available.
**********************************************************************/
{

	GetSystemInventory(INV_POINTDEVICE,szPointingDevice);	

		
}



void GetCDRomString(HINSTANCE hInstance, LPTSTR szCDRom)
{
	GetSystemInventory(INV_CDROM,szCDRom);	
}



void GetSoundCardString(HINSTANCE hInstance, LPTSTR szSoundCard)
{

	GetSystemInventory(INV_SOUNDCARD,szSoundCard);	
}



void GetRemoveableMediaString(HINSTANCE hInstance, LPTSTR szRemoveableMedia, int iBufSize)
/*********************************************************************
Returns a string describing the capacity and format of removeable
drives.
**********************************************************************/
{

		GetSystemInventory(INV_REMOVEABLEMEDIA,szRemoveableMedia);	
}


BOOL IsCoProcessorAvailable(HINSTANCE hInstance)
/*********************************************************************
Returns TRUE if a co-processor is installed in the user's system.
**********************************************************************/
{
	TCHAR czRet[256];
	BOOL  bRet = TRUE;
	GetSystemInventory(INV_COPRECESSOR,czRet);
	if(czRet[0] == _T('\0')){
		bRet = FALSE;
	}
	return bRet;
}




void GetDisplayCharacteristics(PINT lpHorizResolution, PINT lpVertResolution,PINT lpColorDepth)
/*********************************************************************
Returns the horizontal and vertical resolution (in pixels) of the 
user's main screen, as well as the color depth (bits per pixel).

Note: NULL can be passed for any parameter that is not of interest.
**********************************************************************/
{
	HWND hwnd = GetDesktopWindow();
	HDC hdc = GetDC(hwnd);
	if (lpHorizResolution) *lpHorizResolution = GetDeviceCaps(hdc,HORZRES);
	if (lpVertResolution) *lpVertResolution = GetDeviceCaps(hdc,VERTRES);
	if (lpColorDepth) *lpColorDepth = GetDeviceCaps(hdc,BITSPIXEL);
	ReleaseDC(hwnd,hdc);
}


void GetWindowsVersion(LONG* lpPlatform, LONG* lpMajorVersion,LONG* lpMinorVersion,LONG* lpBuildNo)
/*********************************************************************
Returns integers representing the platform, major version number, and
minor version number of the currently running Windows OS.

Platform:
VER_PLATFORM_WIN32_NT:		Windows NT
VER_PLATFORM_WIN32s: 		Win32s with Windows 3.1
VER_PLATFORM_WIN32_WINDOWS:	Win32 on Windows 4.0 or later

Note: NULL can be passed for any parameter that is not of interest.
**********************************************************************/
{
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if (lpMajorVersion) *lpMajorVersion = osvi.dwMajorVersion;
	if (lpMinorVersion) *lpMinorVersion = osvi.dwMinorVersion;
	if (lpPlatform) *lpPlatform = osvi.dwPlatformId;
	if (lpBuildNo) *lpBuildNo = osvi.dwBuildNumber;
}







#pragma optimize( _T(""), on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwiz\rw_common.cpp ===
/*

	File : RW_COMMON.CPP
	Date : 04/22/97
	Author : Suresh Krishnan

	Common functions for RegWiz 

*/

#include "RW_Common.h"
#include "resource.h"
#include <ATKInternet.h>

#define STRCONVERT_MAXLEN    1024
static TCHAR gszProductBeingRegistred[128]= _T("");
static TCHAR gszTempProdWithOem[256] =_T("");
//
// This Function returns the Security Descriptor
//
REGSAM RW_GetSecDes() 
{ 
#ifdef _WINDOWS95
	return NULL; 
#else 
	return NULL;
	//
	// To be implemented for NT
#endif
}


void RWDebug :: UseStandardOutput()
{
	fp = stdout;
}

void RWDebug :: CreateLogFile(char *czFName)
{
	char   czTmpPath[256] = "";
	char   czLogFile[256];
	czLogFile[0] = '\0';

#ifdef _LOG_IN_FILE
	if( GetEnvironmentVariableA("TEMP",czTmpPath,228) > 0 ) {
			strcpy(czLogFile,czTmpPath);
	}
	strcat(czLogFile,"\\");
	strcat(czLogFile,czFName);
	fp = fopen(czLogFile,"w");
	if(fp == NULL) {
		m_iError = -1;
	}
#else
	UseStandardOutput();
#endif

		
}

RWDebug& RWDebug:: Write (char *czP)
{
	
	if(m_iError < 0  ) return *this;

	if(fp == NULL) {
		CreateLogFile("REGWIZ.LOG");
		// Fail to create file
		if(m_iError < 0) return *this;
	}

	

	if(czP  && *czP) {
		//OutputDebugStringA(czP);
		
		m_iError = fputs(czP,fp);
		m_iError = fflush(fp);
	}
    return *this;
}


RWDebug& RWDebug:: operator << (int  iv)
{
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);;
}

RWDebug& RWDebug:: operator << (unsigned int  iv)
{
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);;
    
}

RWDebug& RWDebug:: operator << (long  iv)
{
	
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);
    
}

RWDebug& RWDebug:: operator << (unsigned long  iv)
{
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);;
	
}


RWDebug& RWDebug:: operator << (short   iv)
{
	
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);;
    
}

RWDebug& RWDebug:: operator << (unsigned short  iv)
{
	
	sprintf(czTemp,"%d",iv);
	return Write(czTemp);
}

RWDebug& RWDebug:: operator << (char cV)
{
	
	sprintf(czTemp,"%c",cV);
	return Write(czTemp);
    
}

RWDebug& RWDebug:: operator << (float  iv)
{
	
	sprintf(czTemp,"%10.4f",iv);
	return Write(czTemp);
    
}

RWDebug& RWDebug:: operator << (char *czP)
{
	return Write(czP);
	
}

RWDebug& RWDebug:: operator << (const char *czP)
{
	return Write((char *) czP);
	
}
RWDebug& RWDebug :: operator << ( const unsigned short *usv) 
{ 
	char *czP;
	if(usv && *usv) {
		czP = ConvertToANSIString(usv);
		if(czP && *czP)
		Write((char *) czP);

	}
	return *this;
}

RWDebug& RWDebug :: operator << ( void *p) 
{ 
	
	if(p) {
		sprintf(czTemp,"Addr :0x%p",p);
		Write(czTemp);

	}
	return *this;
}
 
RWDebug& GetDebugLogStream()
{
	static RWDebug  rwD;
	return rwD;
}
/***
ostream &GetDebugLogStream()
{
	static ostream *os;
	char   czTmpPath[256] = "";
	char   czLogFile[256];

	czLogFile[0] = '\0';
	if(os == NULL)  {
#ifdef _LOG_IN_FILE
		if( GetEnvironmentVariableA("TEMP",czTmpPath,228) > 0 ) {
			strcpy(czLogFile,czTmpPath);
		}
		strcat(czLogFile,"\\REGWIZ.LOG");
		
		os = new ofstream (czLogFile);
		if( os == NULL ){
			os = &cout;
		}
#else
		os = &cout;
#endif

	}
	return *os;
			
}
***/
/*	Value  -- > "CurrentDriveLetterAssignment"		Data -- > "A"
	Value  -- > "Removable"							Data -- > 01
	Value  -- > "Class"								Data -- > "DiskDrive"*/


int RegFindValueInAllSubKey(HINSTANCE hInstance,HKEY key ,LPCTSTR szSubKeyNameToFind,LPCTSTR szValueToFind,LPTSTR szIdentifier,int nType )
{
   DWORD   dwRet,dwIndex,dwSubkeyLen;
   TCHAR   szSubKey[256],szFloppy[256];
   BOOL    bType = FALSE,bRemovable = FALSE,bPrevMassStorage,bPrevFloppy;
   HKEY    hKey;
   static BOOL bMassStorage = FALSE;
   static BOOL bFloppy = FALSE;
	
   bPrevMassStorage =	bMassStorage;
   bPrevFloppy		=	bFloppy;

   if (szSubKeyNameToFind != NULL)
   {
     dwRet=RegOpenKeyEx(
						 key,
						 szSubKeyNameToFind,
						 0,
						 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
						 &hKey 
						 );

	 if( dwRet == ERROR_SUCCESS)
	 {	 dwIndex = 0;
         while (dwRet == ERROR_SUCCESS )
         {
            dwSubkeyLen = 256;
			dwRet=RegEnumKeyEx(
                           hKey,
                           dwIndex,       
                           szSubKey,
                           &dwSubkeyLen,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );
 
            if(dwRet == ERROR_NO_MORE_ITEMS)
            {
				_TCHAR		valueName[80];
				DWORD		valueNameSize,valueSize,n = 0;
				TBYTE		value[80];
				
                do
				{
					valueNameSize=80* sizeof(_TCHAR);
					valueSize=80* sizeof(TBYTE);
					dwRet = RegEnumValue(
										 hKey,
										 n,
										 valueName,
										 &valueNameSize,
										 NULL,
										 NULL,
										 (LPBYTE) value,
										 &valueSize
										 );
					if(dwRet == ERROR_SUCCESS)
					{
						
						if(nType == 1)
						{
							if (!_tcscmp(valueName,_T("Type"))) 
							{
								if (!_tcscmp(szValueToFind,(LPCTSTR)value))
								{
									bType = TRUE;
								}
							}
							if (!_tcscmp(valueName,_T("Identifier"))) 
							{
								_tcscpy(szIdentifier,(LPCTSTR)value);
							}
						}
						else
						if(nType == 2)
						{
							if (!_tcscmp(valueName,_T("Class"))) 
							{
								if (!_tcscmp(szValueToFind,(LPCTSTR)value))
								{
									bType = TRUE;
								}
							}
							if (!_tcscmp(valueName,_T("DeviceDesc"))) 
							{
// bFloppy and bMassStorage are used for handling the conditions when there are multiple 
// Floppy and mass storage media present.
								_tcscpy(szFloppy,(LPCTSTR)value);
								_tcsupr(szFloppy);
								if(_tcsstr(szFloppy,_T("FLOPPY")) != NULL)
								{
									if(!bFloppy)
									{
										_tcscpy(szFloppy,(LPCTSTR)value);
										bFloppy = TRUE;
									}
								}
								else
// if it is not removable or it is a cdrom the condition for type and removable 
// takes care of it.
								{
									if(!bMassStorage)
									{
										bMassStorage = TRUE;
									}
								}

							}
							if (!_tcscmp(valueName,_T("Removable"))) 
							{
								if (*value == 0x01 )
								{
									bRemovable = TRUE;
								}
							}
							/*if (!_tcscmp(valueName,_T("CurrentDriveLetterAssignment"))) 
							{
								_tcscpy(szRemovableTemp,(LPCTSTR)value);
							}*/
							
						}
						n++;
					}

				} while (dwRet == ERROR_SUCCESS);

				if(nType == 1)
				{
					if(bType)
					{
						return REGFIND_FINISH;
					}
					else
					{
						return REGFIND_RECURSE;
					}
				}
				else
				if(nType == 2)
				{

					if(bType && bRemovable )
					{
					/*	_tcscat(szRemovableTemp,_T(":"));
						_tcscat(szRemovableTemp,szIdentifier);
						_tcscpy(szIdentifier,szRemovableTemp);*/
						if(bFloppy != bPrevFloppy )
						{						
							_tcscpy(szIdentifier,szFloppy);	
						}
						if(bFloppy && bMassStorage)
						{
							_TCHAR szMassString[64];
							LoadString(hInstance,IDS_MASS_STRORAGE_ENTRY,szMassString,64);
							_tcscat(szIdentifier,szMassString);	
							return REGFIND_FINISH;
						}
						return REGFIND_RECURSE;
					}
// The bMassStorage flag has to be reset to the previous state. 
					else
					{
						bMassStorage = bPrevMassStorage;
						if(bFloppy != bPrevFloppy)
							bFloppy = bPrevFloppy;
						return REGFIND_RECURSE;
					}
				}            
			}
            else
			{
				if(dwRet == ERROR_SUCCESS)
				{
					int nStatus;
					nStatus = RegFindValueInAllSubKey(hInstance,hKey, szSubKey,szValueToFind,szIdentifier,nType);

					switch(nStatus)
					{
						case REGFIND_FINISH:
							{
								return REGFIND_FINISH;
							}
						case REGFIND_ERROR:
							{
								return REGFIND_ERROR;
							}
						default :
							{
								if(bFloppy != bPrevFloppy)
								  bPrevFloppy = bFloppy;
						
							}
							break;
					}
					
					dwIndex++;
				}
			}
         }
         RegCloseKey(hKey);
      }
	  else
	  {
		  RW_DEBUG << "Error Opening the key " << ConvertToANSIString(szSubKeyNameToFind)<< flush;
	  }
   }
   else
   {
	   RW_DEBUG << "Error: key cannot be NULL" << flush;
   }
 
   return REGFIND_ERROR;
}


BOOL RegFindTheSubKey(HKEY key,LPCTSTR szSubKeyName,LPCTSTR szSubKeyNameToFind,LPTSTR szData )
{
   DWORD   dwRet,dwIndex,dwSubkeyLen;
   TCHAR   szSubKey[256];
   HKEY    hKey;

   if (szSubKeyName != NULL)
   {
     dwRet=RegOpenKeyEx(
						 key,
						 szSubKeyName,
						 0,
						 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
						 &hKey 
						);

	 if( dwRet == ERROR_SUCCESS)
	 {	 dwIndex = 0;
         while (dwRet == ERROR_SUCCESS )
         {
            dwSubkeyLen = 256;
			dwRet=RegEnumKeyEx(
                           hKey,
                           dwIndex,       
                           szSubKey,
                           &dwSubkeyLen,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );
 
            if(dwRet == ERROR_NO_MORE_ITEMS)
            {
					return FALSE;
            }
            else
			{
  			 if(dwRet == ERROR_SUCCESS)
			 {
				if(!_tcscmp(szSubKey,szSubKeyNameToFind))
				{
					if(RegGetPointingDevice(hKey,szSubKey,szData))
					{
						RegCloseKey(hKey);
						return TRUE;
					}
					else
						return FALSE;
				}
				else
				if(RegFindTheSubKey(hKey,szSubKey,szSubKeyNameToFind,szData))
				{
					return TRUE;
				}
			 }
			 dwIndex++;
			}
         }
         RegCloseKey(hKey);
      }
	  else
	  {
		  RW_DEBUG << "Error Opening the key " << ConvertToANSIString(szSubKeyNameToFind) << flush;
	  }
   }
   else
   {
	   RW_DEBUG << "Error: key cannot be NULL"<< flush;
   }
 
   return FALSE;
}


BOOL RegGetPointingDevice(HKEY Key,LPCTSTR szSubKeyName,LPTSTR szData)
{
   DWORD	dwRet,dwSubkeyLen;
   _TCHAR	szSubKey[256];
   _TCHAR	valueName[80];
   DWORD	valueNameSize;
   TBYTE	value[80];
   DWORD	valueSize;
   DWORD	n = 0;
   HKEY		hKey,hKey2;

   dwRet=RegOpenKeyEx(
						 Key,
						 szSubKeyName,
						 0,
						 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
						 &hKey 
						);

   if( dwRet == ERROR_SUCCESS)
	{
	  dwSubkeyLen = 256;
      dwRet=RegEnumKeyEx(
                           hKey,
                           0,       
                           szSubKey,
                           &dwSubkeyLen,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );

	  dwRet=RegOpenKeyEx(
						 hKey,
						 szSubKey,
						 0,
						 KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
						 &hKey2 
						);
      if (dwRet == ERROR_SUCCESS)
      {
         do
		   {
			   valueNameSize=80 * sizeof(TCHAR);
			   valueSize=80 * sizeof(TCHAR);

               dwRet = RegEnumValue(
								     hKey2,
								     n,
								     valueName,
								     &valueNameSize,
								     NULL,
								     NULL,
								     (LPBYTE) value,
								     &valueSize
								     );
			   if(dwRet == ERROR_SUCCESS)
			   {
				   if (!_tcscmp(valueName,_T("Identifier"))) 
				   {
					   _tcscpy(szData,(LPCTSTR)value);
			           RegCloseKey(hKey2);
				       RegCloseKey(hKey);
					   return TRUE;
				   }
				   n++;
			   }
		    } while (dwRet == ERROR_SUCCESS);
         RegCloseKey(hKey2);
      }
      RegCloseKey(hKey);
   }
   return FALSE;
}


//
// This function Converts  an UNICODE to String
//
//
LPCTSTR BstrToSz(BSTR pszW)
{
#ifndef _UNICODE 
	ULONG cbAnsi, ulNoOfChars;
	DWORD dwError;
	LPTSTR lpString;
	if(pszW== NULL) 
		return NULL;
	ulNoOfChars = wcslen(pszW)+1;
	cbAnsi =   ulNoOfChars +2;
	lpString = (LPTSTR) CoTaskMemAlloc(cbAnsi);
	if( NULL == lpString )
		return NULL;
	if( WideCharToMultiByte(CP_ACP,0,pszW,ulNoOfChars,lpString,cbAnsi,NULL,NULL) == 0) {
		dwError = GetLastError();
		CoTaskMemFree(lpString);
		lpString = NULL;
	}
	return lpString;
#endif
	return (LPCTSTR)  pszW;


}


int  GetProductRoot (LPTSTR pPath , PHKEY  phKey)
{

    LONG regStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
		pPath,0,KEY_READ |KEY_WRITE,phKey);
	if (regStatus != ERROR_SUCCESS) {
		return 1; // error
	}
	else{
		return 0; // Success 
	}

}


//
//  This function converts an UNICODE STRING to ANSI char String
//
//
char * ConvertToANSIString (LPCTSTR   pszW)
{

#ifdef _UNICODE 
	static char szAString[STRCONVERT_MAXLEN];
	ULONG cbAnsi, ulNoOfChars;
	DWORD dwError;
	LPSTR lpString;
	if(pszW == NULL) 
		return NULL;
	if(*pszW == 0) {
		return NULL;

	}
	ulNoOfChars = wcslen(pszW)+1;
	cbAnsi =   ulNoOfChars +2;
	lpString = (LPSTR) szAString;
	if( WideCharToMultiByte(CP_ACP,0,pszW,ulNoOfChars,lpString,STRCONVERT_MAXLEN,NULL,NULL) == 0) {
		dwError = GetLastError();
		lpString = NULL;
	}
	return lpString;
#else
	return (LPTSTR)  pszW;
#endif
 
}



#ifdef _UNICODE

TCHAR* ConvertToUnicode(char FAR* szA)
{
  static TCHAR  achW[STRCONVERT_MAXLEN]; 
  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);  
  return achW; 
}

#else
//
//  in case of 
TCHAR * ConvertToUnicode(TCHAR * szW) 
{
	return szW;
}
#endif

TCHAR * GetProductBeingRegistred()
{
	return  gszProductBeingRegistred;
}

void SetProductBeingRegistred(TCHAR *szProduct)
{
	_tcscpy (gszProductBeingRegistred,szProduct);
}

void GetWindowsDirectory(TCHAR *szParamRegKey,
						 TCHAR *czBuf)
{
	HKEY hKey;
	TCHAR szRetVal[128];
	DWORD dwSize= 128;
	LONG regStatus ;

	_tcscpy(czBuf,_T("")); // Set Path to Blank


	GetProductRoot(szParamRegKey , &hKey);
	if(!hKey) {
		return ;
	}
	regStatus = RegQueryValueEx(hKey,
		_T("SystemRoot"),
		NULL,
		0,
		(LPBYTE) szRetVal,
		&dwSize);
	if (regStatus == ERROR_SUCCESS){
		// Verifty the Value 
		//
		_tcscpy(czBuf,szRetVal);
	}
	RegCloseKey(hKey);
	
}


/*
	Returns 1 if successful
	        0 if failure
*/
int GetOemManufacturer (TCHAR *szProductRegKey, TCHAR *szBuf )
{ 
	TCHAR szSection[] = _T("general");
	TCHAR szKeyName[] = _T("Manufacturer");
	TCHAR szOemFile[MAX_PATH] = _T("");
	
	GetSystemDirectory(szOemFile,MAX_PATH);
	_tcscat(szOemFile,_T("\\Oeminfo.ini"));

	if( CheckOEMdll()== OEM_NO_ERROR ) {
		GetPrivateProfileString (szSection,
							 szKeyName,
							 _T(""),
							 szBuf, 
							 256,
							 szOemFile
							 );
		return 1;
	}
	else {
		return 0;
	}
}

void SetMSID(HINSTANCE hInstance)
{
 
 DWORD	dwRet;
 _TCHAR szKeyName[256];
 HKEY	hIDKey;
 TCHAR  szMSID[256];
 
 
 if(!GetMSIDfromCookie(hInstance,szMSID)){
	 szMSID[0] = _T('\0');
 }
 else {
	
	_TCHAR szPartialKey[256];
	int resSize = LoadString(hInstance,IDS_KEY2,szKeyName,255);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY3,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY4,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);

	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) {
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szMSID,
								_tcslen((LPCTSTR)szMSID)*sizeof(TCHAR) );
		RegCloseKey(hIDKey);
	}

 }
}

void RemoveMSIDEntry(HINSTANCE hInstance)
{
    DWORD	dwRet;		
	 HKEY	hIDKey;
	_TCHAR szPartialKey[256];
	_TCHAR szValue[256];
	 _TCHAR szKeyName[256];
	int resSize = LoadString(hInstance,IDS_KEY2,szKeyName,255);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY3,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY4,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);
	szValue[0] = _T('\0');
	resSize = LoadString(hInstance,IDS_NOTUSED,szValue,255);

	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS){
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szValue,
								_tcslen((LPCTSTR)szValue)* sizeof(_TCHAR));
		RegCloseKey(hIDKey);
	}
	// 
	// Set in Current User
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"));
	dwRet = RegOpenKeyEx(HKEY_CURRENT_USER,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS){
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szValue,
								_tcslen((LPCTSTR)szValue)* sizeof(_TCHAR));
		RegCloseKey(hIDKey);
	}


}

BOOL GetMSIDfromCookie(HINSTANCE hInstance,LPTSTR szMSID)
{	
	_TCHAR szCookieInfo[256],szRegisterSiteURL[256],szTmpURL1[256];
	_TCHAR szTmpURL2[256];
	DWORD dwSize = 256;
	
	_tcscpy(szTmpURL1,_T("http://"));
	LoadString(hInstance, IDS_HTTP_SERVER,szRegisterSiteURL, 255);
	_tcscat(szTmpURL1,szRegisterSiteURL);
	LoadString(hInstance, IDS_HTTP_SERVER_PATH,szTmpURL2, 255);
	
	InternetCombineUrl(	szTmpURL1,	szTmpURL2,	szRegisterSiteURL,
									&dwSize,	ICU_DECODE );

	dwSize = 256;
	//
	
	BOOL bRet = ATK_InternetGetCookie(szRegisterSiteURL,
		_T(""),szCookieInfo,&dwSize );
   
	if(bRet)
	{
		if(szCookieInfo[0] != _T('\0')){
			RW_DEBUG <<"\nAfterInternetGetCookie "  << ConvertToANSIString(szCookieInfo) << flush;
		}

		BOOL bfound = FALSE;

		_TCHAR seps[] = _T("=");
		_TCHAR *token;

		token = _tcstok( szCookieInfo, seps );
	
	    while( token != NULL )
		{
		  if(!_tcscmp(token,_T("GUID")))
		  {
			  bfound = TRUE;
			  break;
		  }
	      token = _tcstok( NULL, seps );
		}

		if(bfound)
		{
		  token = _tcstok( NULL, seps );
		  _tcscpy(szMSID,token);
		 RW_DEBUG <<"\n Cookie Found " << ConvertToANSIString(szMSID) << flush;
		  return TRUE;
	    }
		else
		{
			_tcscpy(szMSID,_T(""));
		}
	}
	else
	{
		_tcscpy(szMSID,_T(""));
	}
	return FALSE;
}

BOOL GetMSIDfromRegistry(HINSTANCE hInstance,LPTSTR szValue)
{
	HKEY hKeyMSID;

	_TCHAR szKeyName[256];
	
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));
	
	LONG regStatus = RegOpenKeyEx(HKEY_CURRENT_USER,szKeyName,0,KEY_READ,&hKeyMSID);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[64];
		unsigned long infoSize = 255;
		LoadString(hInstance,IDS_MSID,szValueName,64);
		regStatus = RegQueryValueEx(hKeyMSID,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			RegCloseKey(hKeyMSID);
			RW_DEBUG <<"\n GetCookie from Registry "  << ConvertToANSIString(szValue) << flush;
			return TRUE;
		}
	}
	RegCloseKey(hKeyMSID);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizctrl\crwctrl.cpp ===
// CRegWizCtrl.cpp : Implementation of CRegWizCtrl
#include "stdafx.h"
#include "RegwizCtrl.h"
#include "CRwCtrl.h"
#include "rw_common.h"
#include "regutil.h"

int TstFn1 ( HANDLE hInstance  );

_TCHAR szProductPath[256];

/////////////////////////////////////////////////////////////////////////////
// CRegWizCtrl

STDMETHODIMP CRegWizCtrl::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IRegWizCtrl,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CRegWizCtrl::InvokeRegWizard(BSTR ProductPath)
{
	LPCTSTR  pPath;
	int      iRet;
	iRet = 0; // No Error
	// TODO: Add your implementation code here
	//TstFn1 ( _Module.GetModuleInstance(), m_ctlButton.m_hWnd);
	#ifndef _UNICODE
	pPath	= BstrToSz(ProductPath);
	#else
	pPath   = ProductPath;
	#endif
	if(pPath) {
		//MessageBox("TransferRegWizInformation",lpInfo);
		iRet = InvokeRegistration ( _Module.GetModuleInstance()  ,pPath );
#ifndef _UNICODE
		CoTaskMemFree((void *) pPath);
#endif

	}
	//return (HRESULT) iRet;
	//return iRet == NO_ERROR ? S_OK:E_FAIL;
	return S_OK;
}

STDMETHODIMP CRegWizCtrl::TransferRegWizInformation(BSTR InformationPath)
{
	// TODO: Add your implementation code here
	LPCTSTR lpInfo;
	//::MessageBox(NULL,"TransferRegWizInformation","SSS ",MB_OK);

#ifndef _UNICODE
	lpInfo	= BstrToSz(InformationPath);
#else
	lpInfo = InformationPath;
#endif

	if(lpInfo) {
	//	MessageBox("TransferRegWizInformation",lpInfo);
		TransmitRegWizInfo(_Module.GetModuleInstance(), lpInfo,FALSE);
#ifndef _UNICODE
		CoTaskMemFree((void *) lpInfo);
#endif

	}


	return S_OK;
}

STDMETHODIMP CRegWizCtrl::put_IsRegistered(BSTR InformationPath)
{
	LPCTSTR lpInfo;

	#ifndef _UNICODE
		lpInfo	= BstrToSz(InformationPath);
	#else
		lpInfo = InformationPath;
	#endif

	_tcscpy(szProductPath,lpInfo);
	return S_OK;
}

STDMETHODIMP CRegWizCtrl::get_IsRegistered(VARIANT_BOOL * pbStatus)
{
	int iReturn ;
	HKEY hKey;
	TCHAR szValueName[256] = _T("");
	TCHAR szRetVal[48];
	DWORD dwSize= 48;
	LONG regStatus ;
	
	*pbStatus = FALSE;

	HINSTANCE hInstance = _Module.GetModuleInstance();

	int resSize = LoadString(hInstance,
				IDS_INPUT_ISREGISTERED,szValueName,128);

	iReturn  = 1;

    regStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
	szProductPath,0,KEY_READ |KEY_WRITE,&hKey);
	if (regStatus != ERROR_SUCCESS) 
	{
		return E_FAIL; // error
	}
	
	regStatus = RegQueryValueEx(hKey,
		szValueName,
		NULL,
		0,
		(LPBYTE) szRetVal,
		&dwSize);
	if (regStatus == ERROR_SUCCESS){
		// Verifty the Value 
		//
		if(szRetVal[0] == _T('1')) {
			*pbStatus = TRUE; // Product Registred flag is set
		}
	}
	RegCloseKey(hKey);
	return S_OK;
}

/*   B S T R   C R E A T E   S Z   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Creates a BSTR from a string
-------------------------------------------------------------------------*/
#ifndef _UNICODE
BSTR BstrCreateSz(LPCSTR lpa)
{
    BSTR bsz;
    UINT cch;

    cch = lstrlen(lpa);

    bsz = SysAllocStringLen(NULL, cch);
    
    if (bsz == NULL)
        return NULL;

    if (cch > 0)
	    MultiByteToWideChar(CP_ACP, 0, lpa, cch, bsz, cch);

	bsz[cch] = NULL;
	return bsz;
}
#endif 


/*   G E T _   M   S   I   D   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Returns a user's MSID from the Registry.  If it does not exist, this 
    code issues a MSID using GetNewGUID.
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::get_MSID(BSTR *pbstrMSID)
{
	HRESULT hr = S_OK;
	_TCHAR szValue[256];
	char   czNewGuid[256];
	BOOL fPutMSID = FALSE;

	szValue[0] = '\0';

	*pbstrMSID = NULL;

	if(!GetMSIDfromRegistry(_Module.GetModuleInstance(), szValue))
		{
		GetNewGUID(czNewGuid);
		_tcscpy(szValue,ConvertToUnicode(czNewGuid));

		fPutMSID = TRUE;
		}

	// TODO: Add your implementation code here

#ifndef _UNICODE
	if ((*pbstrMSID = BstrCreateSz(szValue)) == NULL)
#else
	if ((*pbstrMSID = SysAllocString(szValue)) == NULL)
#endif // _UNICODE
		{
		hr = E_OUTOFMEMORY;
		}


	if (SUCCEEDED(hr) && fPutMSID && *pbstrMSID)
		return put_MSID(*pbstrMSID);
	
	return hr;
}

/*   P U T _   M   S   I   D   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Adds a MSID to the registry
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::put_MSID(BSTR bstrMSID)
{
	DWORD	dwRet;
	_TCHAR szKeyName[256];
	HKEY	hIDKey;
	TCHAR  szMSID[256];
	HINSTANCE hInstance = _Module.GetModuleInstance();

	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));

#ifndef _UNICODE
	WideCharToMultiByte(CP_ACP, 0, bstrMSID, -1, szMSID, 256, NULL, NULL);
#else
	_tcscpy(szMSID, bstrMSID);
#endif // _UNICODE

	dwRet = RegOpenKeyEx(HKEY_CURRENT_USER,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) 
		{
		szMSID[32]=_T('\0');
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szMSID,
								_tcslen((LPCTSTR)szMSID));
		RegCloseKey(hIDKey);
		}

	_TCHAR szPartialKey[256];
	int resSize = LoadString(hInstance,IDS_KEY2,szKeyName,255);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY3,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);
	_tcscat(szKeyName,_T("\\"));
	resSize = LoadString(hInstance,IDS_KEY4,szPartialKey,255);
	_tcscat(szKeyName,szPartialKey);

	dwRet = RegOpenKeyEx(HKEY_CURRENT_USER,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	if (dwRet == ERROR_SUCCESS) 
		{
		// Store MSID into
		dwRet = RegSetValueEx(hIDKey,_T("MSID"),NULL,REG_SZ,(CONST BYTE *)szMSID, _tcslen((LPCTSTR)szMSID));
		RegCloseKey(hIDKey);
		}

	return S_OK;
}

/*   G E T _   H   W   I   D   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Returns the machine HWID or creates it.
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::get_HWID(BSTR * pbstrHWID)
{
	HKEY hKeyHWID;
	HRESULT hr = S_OK;
	BOOL fPutHWID = FALSE;

	_TCHAR szKeyName[256];
	_TCHAR szValue[256];
	char   czNewGuid[256];

	*pbstrHWID = NULL;
	szValue[0] = '\0';

	
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));
	
	LONG regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_READ, &hKeyHWID);
	
	if (regStatus == ERROR_SUCCESS)
		{
		_TCHAR szValueName[64];
		unsigned long infoSize = 255;
		
		LoadString(_Module.GetModuleInstance(),IDS_HWID, szValueName,64);
		regStatus = RegQueryValueEx(hKeyHWID,szValueName,NULL,0,(LPBYTE) szValue,&infoSize);
		if (regStatus != ERROR_SUCCESS)
			{
			GetNewGUID(czNewGuid);
			_tcscpy(szValue,ConvertToUnicode(czNewGuid));
			fPutHWID = TRUE;
			}
			
		RegCloseKey(hKeyHWID);
		}

#ifndef _UNICODE
	if ((*pbstrHWID = BstrCreateSz(szValue)) == NULL)
#else
	if ((*pbstrHWID = SysAllocString(szValue)) == NULL)
#endif // _UNICODE
		{
		hr = E_OUTOFMEMORY;
		}

	if (SUCCEEDED(hr) && fPutHWID && *pbstrHWID)
		return put_HWID(*pbstrHWID);
	
	return hr;
}

/*   P U T _   H   W   I   D   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Adds the passed in HWID to the registry
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::put_HWID(BSTR bstrHWID)
{
	DWORD	dwRet;
	_TCHAR szKeyName[256];
	HKEY	hIDKey;
 
	_tcscpy(szKeyName,_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"));

	// Store HWID into Registry
	dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szKeyName,0,KEY_ALL_ACCESS,&hIDKey);
	
	if (dwRet == ERROR_SUCCESS) 
		{
		_TCHAR szHWID[256];
		
#ifndef _UNICODE
		WideCharToMultiByte(CP_ACP, 0, bstrHWID, -1, szHWID, 256, NULL, NULL);
#else
		_tcscpy(szHWID, bstrHWID);
#endif // _UNICODE		

		dwRet = RegSetValueEx(hIDKey,_T("HWID"),NULL, REG_SZ,(CONST BYTE *)szHWID, _tcslen((LPCTSTR)szHWID));
		RegCloseKey(hIDKey);
		}

	return S_OK;
}

/*   T R A N S F E R   O   E   M   R E G   W I Z   I N F O R M A T I O N   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Transfer product registration and OEM information.
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::TransferOEMRegWizInformation(BSTR InformationPath)
{
	LPCTSTR lpInfo;
	//::MessageBox(NULL,"TransferOEMRegWizInformation","SSS ",MB_OK);

#ifndef _UNICODE
	lpInfo	= BstrToSz(InformationPath);
#else
	lpInfo = InformationPath;
#endif

	if(lpInfo) {
	//	MessageBox("TransferRegWizInformation",lpInfo);
		TransmitRegWizInfo(_Module.GetModuleInstance(), lpInfo, TRUE);
#ifndef _UNICODE
		CoTaskMemFree((void *) lpInfo);
#endif
	}


	return S_OK;
}

/*   G E T _   V E R S I O N   */
/*-------------------------------------------------------------------------
    Owner: SteveBu
 
    Returns the RegWiz Version Number
-------------------------------------------------------------------------*/
STDMETHODIMP CRegWizCtrl::get_Version(BSTR * pbstr)
{
	_TCHAR szValue[256];
	
	GetRegWizardVersionString(_Module.GetModuleInstance(),szValue);

#ifndef _UNICODE
	if ((*pbstr = BstrCreateSz(szValue)) == NULL)
#else
	if ((*pbstr = SysAllocString(szValue)) == NULL)
#endif // _UNICODE
		{
		return E_OUTOFMEMORY;
		}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizctrl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizctrl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__50E5E3C4_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_)
#define AFX_STDAFX_H__50E5E3C4_C07E_11D0_B9FD_00A0249F6B00__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__50E5E3C4_C07E_11D0_B9FD_00A0249F6B00__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by hellctrl.ico
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\regwizc_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.00.0140 */
/* at Thu Mar 11 12:57:09 1999
 */
/* Compiler settings for regwizctrl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IRegWizCtrl = {0x50E5E3CF,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const IID LIBID_REGWIZCTRLLib = {0x50E5E3C0,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const CLSID CLSID_RegWizCtrl = {0x50E5E3D1,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizctrl\regwizctrl.cpp ===
// RegwizCtrl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f RegwizCtrlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "RegwizCtrl.h"

#include "RegwizCtrl_i.c"
#include "CRWCtrl.h"
#include "cathelp.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_RegWizCtrl, CRegWizCtrl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hr;
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif

	// registers object, typelib and all interfaces in typelib
	if ( SUCCEEDED(hr =_Module.RegisterServer(TRUE)) &&
		 SUCCEEDED(hr = CreateComponentCategory(CATID_SafeForScripting, 
						L"Controls that are safely scriptable")) &&
		 SUCCEEDED(hr = CreateComponentCategory(CATID_SafeForInitializing, 
						L"Controls safely initializable from persistent data")) &&
		 SUCCEEDED(hr = RegisterCLSIDInCategory(CLSID_RegWizCtrl, 
												CATID_SafeForScripting)) )
	{
		hr = RegisterCLSIDInCategory(CLSID_RegWizCtrl, CATID_SafeForInitializing);
	}

	return hr;
	
	
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();

	// Remove CATID information.
    UnRegisterCLSIDInCategory(CLSID_RegWizCtrl, CATID_SafeForScripting);
    UnRegisterCLSIDInCategory(CLSID_RegWizCtrl, CATID_SafeForInitializing);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rwExe.rc
//
#define IDS_RWNOTFOUND                  1
#define IIDS_ERROR                      2
#define IDI_REGWIZ                      117

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\rwexemain.cpp ===
/*************************************************************************
**
**    
**	File 	:    RWExeMain.cpp
**      Product  :	
**	Date 	:    05/07/97
**	Author 	:    Suresh Krishnan	
**
**   Registration Wizard Exe programs main file
**   The Exe version of Registration Wizard is implemented using the Active X 
**   component
**
*************************************************************************/
#define STRICT

#include <windows.h>
#include <windowsx.h>
#ifdef WIN16   
  #include <ole2.h>
  #include <compobj.h>    
  #include <dispatch.h> 
  #include <variant.h>
  #include <olenls.h>
  #include <commdlg.h>  
#endif  
#include <initguid.h>   
#include "RWInterface.h" 
#include "RWExeMain.h"      
#include "resource.h"


// Globals
HINSTANCE g_hinst;                          // Instance of application
HWND      g_hwnd;                           // Toplevel window handle

TCHAR g_szNotFound[STR_LEN];
TCHAR g_szError[STR_LEN]; 

#define INVOKDE_REGISTRATION   1
#define INVOKE_TRANSFER        2 
#define INVOKE_ERROR           3
#define chSpace 32
int ProcessCmdLine(LPTSTR lpCmd) 
{
	int iC=0;
	int iExit=1;
	LPTSTR szCurr = lpCmd;
	if (lpCmd  == NULL || lpCmd[0] == 0)
	{
		return INVOKE_ERROR;
	}
	while (*szCurr == chSpace)
		{
			szCurr = CharNext(szCurr);
		}
	if (*szCurr != '/' && *szCurr != '-') {
		return INVOKE_ERROR ;
	}
		szCurr = CharNext(szCurr);
		if (*szCurr == 'I' || *szCurr == 'i') {
			return INVOKDE_REGISTRATION ;
		}
		if (*szCurr == 'T' || *szCurr == 't') {
			return INVOKE_TRANSFER ;
		}
		
		return INVOKE_ERROR;


}
/*
 * WinMain
 *
 * Purpose:
 *  Main entry point of application. Should register the app class
 *  if a previous instance has not done so and do any other one-time
 *  initializations.
 *
 */
/*
int _tWinMain   ( HINSTANCE hinst, 
				  HINSTANCE hinstPrev, 
				  LPTSTR lpCmdLine, 
				  int nCmdShow)
*/
int APIENTRY WinMain (HINSTANCE hinst, 
					  HINSTANCE hinstPrev, 
					  LPSTR lpCmdLine, 
					  int nCmdShow)

{
   MSG msg;
   static IRegWizCtrl FAR* pRegWiz = NULL;    
   HRESULT hr;
   LPUNKNOWN punk;
   
   
   //  It is recommended that all OLE applications set
   //  their message queue size to 96. This improves the capacity
   //  and performance of OLE's LRPC mechanism.
   int cMsg = 96;                  // Recommend msg queue size for OLE
   while (cMsg && !SetMessageQueue(cMsg))  // take largest size we can get.
       cMsg -= 8;
   if (!cMsg)
       return -1;                  // ERROR: we got no message queue
	LoadString(hinst, IDS_RWNOTFOUND, g_szNotFound, STR_LEN);
    LoadString(hinst, IDS_ERROR, g_szError, STR_LEN);
   
   
   if (!hinstPrev)
      if (!InitApplication(hinst))
         return (FALSE);

   if(OleInitialize(NULL) != NOERROR)
      return FALSE;
      
   if (!InitInstance(hinst, nCmdShow))
      return (FALSE);

   hr = CoCreateInstance(CLSID_RegWizCtrl, NULL, CLSCTX_INPROC_SERVER, 
        IID_IUnknown, (void FAR* FAR*)&punk);
	if (FAILED(hr))                 {
            MessageBox(NULL,g_szNotFound , g_szError, MB_OK); 
            return 0L;
        }                     
        hr = punk->QueryInterface(IID_IRegWizCtrl ,  (void FAR* FAR*)&pRegWiz);   
        if (FAILED(hr))  
        {
            MessageBox(NULL, TEXT("QueryInterface(IID_IHello)"), g_szError, MB_OK);
            punk->Release(); 
            return 0L;
        }
#ifndef _UNICODE 
			hr = pRegWiz->InvokeRegWizard(ConvertToUnicode(lpCmdLine));
#else
			hr = pRegWiz->InvokeRegWizard(lpCmdLine);
#endif

/*
	int iStatus = ProcessCmdLine(lpCmdLine);
	switch(iStatus ) 
	{
	case INVOKDE_REGISTRATION :
#ifndef _UNICODE 
			hr = pRegWiz->InvokeRegWizard(ConvertToUnicode(lpCmdLine));
#else
			hr = pRegWiz->InvokeRegWizard(lpCmdLine);
#endif
			break;
	case INVOKE_TRANSFER :
#ifndef _UNICODE 
			hr = pRegWiz->TransferRegWizInformation(ConvertToUnicode(lpCmdLine));
#else
			hr = pRegWiz->TransferRegWizInformation(lpCmdLine);
#endif
	default:
		break;

	}
*/
	//	ConvertToUnicode("/i \"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\"")	);
	
   OleUninitialize();
   if(SUCCEEDED(hr))
	   return NO_ERROR;
   else
	   return 1;

   //return (msg.wParam); // Returns the value from PostQuitMessage
}

/*
 * InitApplication
 *
 * Purpose:
 *  Registers window class
 *
 * Parameters:
 *  hinst       hInstance of application
 *
 * Return Value:
 *  TRUE if initialization succeeded, FALSE otherwise.
 */
BOOL InitApplication (HINSTANCE hinst)
{
   WNDCLASS wc;

   wc.style = CS_DBLCLKS;
   wc.lpfnWndProc = MainWndProc;
   wc.cbClsExtra = 0;
   wc.cbWndExtra = 0;
   wc.hInstance = hinst;
   wc.hIcon =0; // LoadIcon(hinst, TEXT("ControlIcon"));
   wc.hCursor =0; // LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
   wc.lpszMenuName = NULL ;//TEXT("");
   wc.lpszClassName = TEXT("RegistrationWizard");
   return RegisterClass(&wc);
 }

/*
 * InitInstance
 *
 * Purpose:
 *  Creates and shows main window
 *
 * Parameters:
 *  hinst           hInstance of application
 *  nCmdShow        specifies how window is to be shown
 *
 * Return Value:
 *  TRUE if initialization succeeded, FALSE otherwise.
 */
BOOL InitInstance (HINSTANCE hinst, int nCmdShow)
{
  
   g_hinst   = hinst;
   return TRUE;
}

/*
 * MainWndProc
 *
 * Purpose:
 *  Window procedure for main window
 *
 */
LRESULT CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   switch (msg)
   {
         
      case WM_DESTROY:
         PostQuitMessage(0);
         break;
      default:                         
         return DefWindowProc(hwnd, msg, wParam, lParam);
   }
   
   return NULL;
}

/*
 * DisplayError
 *
 * Purpose:
 *  Obtains Rich Error Information about the automation error from
 *  the IErrorInfo interface.
 *
 */
void DisplayError(IRegWizCtrl FAR* phello)
{  
   IErrorInfo FAR* perrinfo;    
   BSTR bstrDesc;
   HRESULT hr;
   ISupportErrorInfo FAR* psupporterrinfo;  

   hr = phello->QueryInterface(IID_ISupportErrorInfo, (LPVOID FAR*)&psupporterrinfo);
   if (FAILED(hr)) 
   {
      MessageBox(NULL, TEXT("QueryInterface(IID_ISupportErrorInfo)"), g_szError, MB_OK);
      return;
   }
   
   hr = psupporterrinfo->InterfaceSupportsErrorInfo(IID_IRegWizCtrl);   
   if (hr != NOERROR)
   {   
       psupporterrinfo->Release();
       return;
   }
   psupporterrinfo->Release();
  
   // In this example only the error description is obtained and displayed. 
   // See the IErrorInfo interface for other information that is available. 
   hr = GetErrorInfo(0, &perrinfo); 
   if (FAILED(hr))
       return;   
   hr = perrinfo->GetDescription(&bstrDesc);
   if (FAILED(hr)) 
   {
       perrinfo->Release(); 
       return;
   }  
   
   MessageBox(NULL, FROM_OLE_STRING(bstrDesc), g_szError, MB_OK);   
   SysFreeString(bstrDesc);
}

#ifdef WIN32

#ifndef UNICODE
char* ConvertToAnsi(OLECHAR FAR* szW)
{
  static char achA[STRCONVERT_MAXLEN]; 
  
  WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, STRCONVERT_MAXLEN, NULL, NULL);  
  return achA; 
} 

OLECHAR* ConvertToUnicode(char FAR* szA)
{
  static OLECHAR achW[STRCONVERT_MAXLEN]; 

  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);  
  return achW; 
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\rwexemain.h ===
#ifdef WIN32

#ifdef UNICODE
    #define FROM_OLE_STRING(str) str
    #define TO_OLE_STRING(str) str 
#else
    #define FROM_OLE_STRING(str) ConvertToAnsi(str)
    char* ConvertToAnsi(OLECHAR FAR* szW);  
    #define TO_OLE_STRING(str) ConvertToUnicode(str)
    OLECHAR* ConvertToUnicode(char FAR* szA);   
    // Maximum length of string that can be converted between Ansi & Unicode
    #define STRCONVERT_MAXLEN 500         
#endif

#else  // WIN16
//#include <tchar.h>


  #define APIENTRY far pascal  
  #define TCHAR char
  #define TEXT(sz) sz 
  #define FROM_OLE_STRING(str) str  
  #define TO_OLE_STRING(str) str 
  #define LPTSTR LPSTR   
  #define LPCTSTR LPCSTR

  
  // Windows NT defines the following in windowsx.h
  #define GET_WM_COMMAND_ID(w,l) (w)
  #define GET_WM_COMMAND_CMD(w,l) HIWORD(l)
  #define GET_WM_COMMAND_HWND(w,l) LOWORD(l)
#endif



// MAX len of string table entries
#define STR_LEN   100

// String table constants
#define IDS_PROGNAME                   1
#define IDS_RESULT                     2
#define IDS_ERROR                      3

// Function prototypes
int PASCAL WinMain (HINSTANCE, HINSTANCE, LPSTR, int);
BOOL InitApplication (HINSTANCE);
BOOL InitInstance (HINSTANCE, int);
void DisplayError(IRegWizCtrl FAR* phello);
#ifdef WIN16
LRESULT __export CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#else
LRESULT CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\rwexe_m.cpp ===
/*************************************************************************
**
**    
**	File 	:    RWExeMain.cpp
**      Product  :	
**	Date 	:    05/07/97
**	Author 	:    Suresh Krishnan	
**
**   Registration Wizard Exe programs main file
**   The Exe version of Registration Wizard is implemented using the Active X 
**   component
** Modification History	
**     07/20/98 : The RegWizControl is changed  from Button control to an IE object,
**                some of the properties like Text, HWND  of the button no longer exists.
*************************************************************************/

#include <stdio.h>
#include <tchar.h>
#include "rwexe_m.h"
#include "regwizC_i.c"

#define STRCONVERT_MAXLEN 256
OLECHAR* ConvertToUnicode(char FAR* szA)
{
  static OLECHAR achW[STRCONVERT_MAXLEN]; 

  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);  
  return achW; 
}


int LoadAndUseRegWizCtrl(TCHAR *lpCmdLine)
{
	HRESULT hr;
	IRegWizCtrl *pRegWiz;


	hr = CoCreateInstance( CLSID_RegWizCtrl,
	                       NULL,
	                       CLSCTX_ALL,
	                       IID_IRegWizCtrl,
	                       (void**)&pRegWiz);

	if(FAILED(hr) ){
		//printf("\n Error Creating Interface...");
		return 0;
	}else {
		//printf("\n Created Interface (IExeTest)...");
	}
	// Invoke register
	#ifndef _UNICODE 
		hr = pRegWiz->InvokeRegWizard(ConvertToUnicode(lpCmdLine));
	#else
		hr = pRegWiz->InvokeRegWizard(lpCmdLine);
	#endif
		return 0;
}


int APIENTRY WinMain (HINSTANCE hinst, 
					  HINSTANCE hinstPrev, 
					  LPSTR lpCmdLine, 
					  int nCmdShow)
{
	CoInitialize(NULL);
	LoadAndUseRegWizCtrl(lpCmdLine);
	CoUninitialize();
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\rwexe_m.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.00.0140 */
/* at Thu Mar 11 12:57:09 1999
 */
/* Compiler settings for regwizctrl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __regwizctrl_h__
#define __regwizctrl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRegWizCtrl_FWD_DEFINED__
#define __IRegWizCtrl_FWD_DEFINED__
typedef interface IRegWizCtrl IRegWizCtrl;
#endif 	/* __IRegWizCtrl_FWD_DEFINED__ */


#ifndef __RegWizCtrl_FWD_DEFINED__
#define __RegWizCtrl_FWD_DEFINED__

#ifdef __cplusplus
typedef class RegWizCtrl RegWizCtrl;
#else
typedef struct RegWizCtrl RegWizCtrl;
#endif /* __cplusplus */

#endif 	/* __RegWizCtrl_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IRegWizCtrl_INTERFACE_DEFINED__
#define __IRegWizCtrl_INTERFACE_DEFINED__

/* interface IRegWizCtrl */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRegWizCtrl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50E5E3CF-C07E-11D0-B9FD-00A0249F6B00")
    IRegWizCtrl : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IsRegistered( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStatus) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IsRegistered( 
            /* [in] */ BSTR strText) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InvokeRegWizard( 
            BSTR ProductPath) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegWizCtrlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRegWizCtrl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRegWizCtrl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsRegistered )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStatus);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsRegistered )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [in] */ BSTR strText);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeRegWizard )( 
            IRegWizCtrl __RPC_FAR * This,
            BSTR ProductPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            IRegWizCtrl __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IRegWizCtrlVtbl;

    interface IRegWizCtrl
    {
        CONST_VTBL struct IRegWizCtrlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegWizCtrl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegWizCtrl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegWizCtrl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegWizCtrl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRegWizCtrl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRegWizCtrl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRegWizCtrl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRegWizCtrl_get_IsRegistered(This,pbStatus)	\
    (This)->lpVtbl -> get_IsRegistered(This,pbStatus)

#define IRegWizCtrl_put_IsRegistered(This,strText)	\
    (This)->lpVtbl -> put_IsRegistered(This,strText)

#define IRegWizCtrl_InvokeRegWizard(This,ProductPath)	\
    (This)->lpVtbl -> InvokeRegWizard(This,ProductPath)

#define IRegWizCtrl_get_Version(This,pVal)	\
    (This)->lpVtbl -> get_Version(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRegWizCtrl_get_IsRegistered_Proxy( 
    IRegWizCtrl __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbStatus);


void __RPC_STUB IRegWizCtrl_get_IsRegistered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRegWizCtrl_put_IsRegistered_Proxy( 
    IRegWizCtrl __RPC_FAR * This,
    /* [in] */ BSTR strText);


void __RPC_STUB IRegWizCtrl_put_IsRegistered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRegWizCtrl_InvokeRegWizard_Proxy( 
    IRegWizCtrl __RPC_FAR * This,
    BSTR ProductPath);


void __RPC_STUB IRegWizCtrl_InvokeRegWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRegWizCtrl_get_Version_Proxy( 
    IRegWizCtrl __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRegWizCtrl_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegWizCtrl_INTERFACE_DEFINED__ */



#ifndef __REGWIZCTRLLib_LIBRARY_DEFINED__
#define __REGWIZCTRLLib_LIBRARY_DEFINED__

/* library REGWIZCTRLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_REGWIZCTRLLib;

EXTERN_C const CLSID CLSID_RegWizCtrl;

#ifdef __cplusplus

class DECLSPEC_UUID("50E5E3D1-C07E-11D0-B9FD-00A0249F6B00")
RegWizCtrl;
#endif
#endif /* __REGWIZCTRLLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\rwinterface.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: Hello */

#ifndef _REGWIZ_H_
#define _REGWIZ_H_

const IID IID_IRegWizCtrl = {0x50E5E3CF,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const IID LIBID_REGWIZCTRLLib = {0x50E5E3C0,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const CLSID CLSID_RegWizCtrl = {0x50E5E3D1,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};



/* Definition of interface: IHello */
DECLARE_INTERFACE_(IRegWizCtrl, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IHello methods */
	STDMETHOD(get_Window ) () PURE;
    STDMETHOD(put_Text )(THIS_ BSTR InformationPath) PURE; 
    STDMETHOD(get_Text ) () PURE;
    STDMETHOD(put_IsRegistered )(THIS_ BSTR InformationPath) PURE; 
    STDMETHOD(get_IsRegistered ) () PURE;
    STDMETHOD(InvokeRegWizard)(THIS_ BSTR ProductPath) PURE;
    STDMETHOD(TransferRegWizInformation)(THIS_ BSTR InformationPath) PURE;
};


class RegWizCtrl;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizexe\rwinter.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: Hello */

#ifndef _REGWIZ_H_
#define _REGWIZ_H_

const IID IID_IRegWizCtrl = {0x50E5E3CF,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const IID LIBID_REGWIZCTRLLib = {0x50E5E3C0,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};


const CLSID CLSID_RegWizCtrl = {0x50E5E3D1,0xC07E,0x11D0,{0xB9,0xFD,0x00,0xA0,0x24,0x9F,0x6B,0x00}};



/* Definition of interface: IHello */
DECLARE_INTERFACE_(IRegWizCtrl, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IHello methods */
	STDMETHOD(get_Window ) () PURE;
    STDMETHOD(put_Text )(THIS_ BSTR InformationPath) PURE; 
    STDMETHOD(get_Text ) () PURE;
    STDMETHOD(InvokeRegWizard)(THIS_ BSTR ProductPath) PURE;
    STDMETHOD(TransferRegWizInformation)(THIS_ BSTR InformationPath) PURE;
};


class RegWizCtrl;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\atkinter.cpp ===
/*
	File : ATKInternet.cpp

	This is a wrapper function for internet API which accepts UNICODE.
	Basically these wrapper converts the UNICODE string to normal SBCS and invokes the
	appropriate SBCS  internet function


*/
#ifdef _UNICODE


#include <tchar.h>
#include "AtkInternet.h"
#include "rw_common.h"


#define MAX_SZ   260

HINTERNET  ATK_InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

{
	char *pRet;

	char  szAgent[MAX_SZ] = "" ;
	char  szProxy[MAX_SZ] ="";
	char  szProxyByPass[MAX_SZ]="";

	pRet =  ConvertToANSIString (lpszAgent);
	if(pRet) {
	strcpy(szAgent, pRet);
	}

	pRet = ConvertToANSIString (lpszProxy);
	if(pRet) {
	strcpy(szProxy, pRet);
	}

	pRet = ConvertToANSIString (lpszProxyBypass);
	if(pRet) {
	strcpy(szProxyByPass, ConvertToANSIString (lpszProxyBypass));
	}

	return InternetOpenA(
    szAgent,
    dwAccessType,
    szProxy ,
    szProxyByPass,
	dwFlags);


}




HINTERNET
ATK_InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    )
{

	char szServerName[MAX_SZ]="";
	char szUserName[MAX_SZ]="";
	char szPassword[MAX_SZ]="";
	char *pRet;

	pRet = ConvertToANSIString (lpszServerName);
	if(pRet) {
		strcpy(szServerName,pRet);
	}

	pRet = ConvertToANSIString (lpszUserName);
	if(pRet) {
		strcpy(szUserName,pRet);
	}
	pRet = ConvertToANSIString (lpszPassword);
	if(pRet) {
		strcpy(szPassword,pRet);
	}

	return InternetConnectA(
    hInternet,
    szServerName,
    nServerPort,
    szUserName ,
    szPassword ,
    dwService,
    dwFlags,
    dwContext
    );


}



HINTERNET
ATK_HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

{
	char szVerb[MAX_SZ]= "";
	char szObjectName[MAX_SZ]="";
	char szVersion[MAX_SZ]="";
	char szReferrer[MAX_SZ]="";
	char szAcceptTypes[MAX_SZ]="";
	char *pRet;

	pRet = ConvertToANSIString (lpszVerb);
	if(pRet) {
		strcpy(szVerb,pRet);
	}

	pRet = ConvertToANSIString (lpszObjectName);
	if(pRet) {
		strcpy(szObjectName,pRet);
	}

	pRet = ConvertToANSIString (lpszVersion);
	if(pRet) {
		strcpy(szVersion,pRet);
	}
	pRet = ConvertToANSIString (lpszReferrer);
	if(pRet) {
		strcpy(szReferrer,pRet);
	}
//	strcpy(szAcceptTypes,ConvertToANSIString (lpszAcceptTypes));

	return HttpOpenRequestA(
    hConnect,
    szVerb,
    szObjectName,
    szVersion,
    szReferrer ,
    NULL,
    dwFlags,
    dwContext
    );

}



BOOL
ATK_HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )
{
	char szHeaders[MAX_SZ]="";
	char *pRet;
	pRet =  ConvertToANSIString (lpszHeaders);
	if(pRet) {
		strcpy(szHeaders,pRet);
	}
	return HttpSendRequestA(
    hRequest,
    szHeaders ,
    dwHeadersLength,
    lpOptional,
    dwOptionalLength);


}


BOOL
ATK_InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
	DWORD dwError;
	DWORD dwErrorLen;
	CHAR szErrorInfo[256];	
	dwErrorLen = 256;
	BOOL bRet;

	bRet = InternetGetLastResponseInfoA(&dwError,
							szErrorInfo,
							&dwErrorLen);
#ifdef _DEBUG
	RW_DEBUG << "\nInternet GetLastResponse ErrorNo:" << dwError ;
	RW_DEBUG << "\n\tErrorInfo:"<<szErrorInfo<<flush;
#endif

	return bRet;
	

}


BOOL ATK_HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
	)
{
	BOOL bRet;

	bRet = HttpQueryInfoA(hRequest, dwInfoLevel,lpBuffer,
			lpdwBufferLength, lpdwIndex);
#ifdef _DEBUG
	RW_DEBUG << "\nHttpQueryInfo:" ;
	RW_DEBUG << "\n\tBuffer  Length "<< *lpdwBufferLength <<flush;
#endif
	return bRet;


}




BOOL ATK_InternetGetCookieW(IN TCHAR *lpszUrl,
						      IN TCHAR *lpszCookieName,
							  OUT TCHAR *lpCookieData,
							  OUT LPDWORD lpdwSize)
{
	char czUrl[256]="";
	char czCookieName[128]="";
	char czCookieData[256]="";
	char *pRet= NULL;
	TCHAR *pTP;
	BOOL  bRetVal;
#ifdef _UNICODE
	
	// Presently the UNICODE version is not implemented in
	// the NT SDK
	//and the declaration defined in WININET.H is
	//	BOOLAPI
	//	InternetGetCookieW(
    //	IN LPCSTR lpszUrl,
    //	IN LPCWSTR lpszCookieName,
    //	OUT LPWSTR lpCookieData,
    //	IN OUT LPDWORD lpdwSize
    //);
// So Convert the first parameter to  ANSI String
	pRet = ConvertToANSIString(lpszUrl);
	if(pRet) strcpy(czUrl,pRet);

	pRet = ConvertToANSIString(lpszCookieName);
	if(pRet) strcpy(czCookieName,pRet);

	#ifdef  USE_ASTRATEK_WRAPPER
	bRetVal = InternetGetCookieA(czUrl,
							czCookieName,
							czCookieData,
							lpdwSize);
	//
	// Convert the Return Values to Unicode
	 pTP= ConvertToUnicode(czCookieData);
	 if(pTP) {
		 _tcscpy(lpCookieData,pTP);
	 }else {
		lpCookieData[0]= _T('\0');
	 }

	#else
	bRetVal = InternetGetCookieW(czUrl,
							lpszCookieName,
							lpCookieData,
							lpdwSize);

	#endif
	
	 return bRetVal;
#endif

}


BOOL ATK_InternetQueryOption(IN HINTERNET hInternet,
							 IN DWORD dwOption,
							 OUT LPVOID lpBuffer,
							 IN OUT LPDWORD lpdwBufferLength
							)
{
	BOOL  bRetVal;
	bRetVal = InternetQueryOptionA(hInternet,
							dwOption,
							lpBuffer,
							lpdwBufferLength);

    return bRetVal;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\atk_ras.cpp ===
/*
	File : ASTRA_RAS.h

*/
#include <ATK_RAS.h>



static int siRasDllLoaded = RAS_DLL_NOT_LOADED ;
static HINSTANCE	hRasDllInst=NULL;

static RASGETENTRYPROPERTIES  pRasGetEntryProperties;
static RASSETENTRYPROPERTIES  pRasSetEntryProperties;
static RASDELETEENTRY         pRasDelEntry;
static RASGETERRORSTRING      pRasGetErrorString;
static RASDIAL                pRasDial;
static RASHANGUP              pRasHangup;
static RASENUMDEVICES         pRasEnumDevices;
static RASENUMCONNECTIONS     pRasEnumConnections;
static RASGETCOUNTRYINFO      pRasGetCountryInfo; 
static RASGETCOUNTRYINFO      pRasGetCountryInfoA;
static RASGETCONNECTIONSTATUS pRasGetConnectionStatus;  



int ATK_IsRasDllOk()
{
	if(siRasDllLoaded == RAS_DLL_NOT_LOADED  ) {
		hRasDllInst = LoadLibrary(_T("RASAPI32.DLL"));
		if(hRasDllInst == NULL) {
			siRasDllLoaded = ERROR_LOADING_RAS_DLL;

		}else {
			//
			//
			// Get All Function Pointers;
#ifdef _UNICODE
			pRasGetEntryProperties  = (RASGETENTRYPROPERTIES) 
				GetProcAddress(hRasDllInst, "RasGetEntryPropertiesW");
#else
			pRasGetEntryProperties  = (RASGETENTRYPROPERTIES) 
				GetProcAddress(hRasDllInst, "RasGetEntryPropertiesA");

#endif

#ifdef _UNICODE
			pRasSetEntryProperties=  (RASSETENTRYPROPERTIES)
				GetProcAddress(hRasDllInst, "RasSetEntryPropertiesW");
#else
			pRasSetEntryProperties=  (RASSETENTRYPROPERTIES)
				GetProcAddress(hRasDllInst, "RasSetEntryPropertiesA");
#endif

#ifdef _UNICODE
			pRasDelEntry = (RASDELETEENTRY) 
				GetProcAddress(hRasDllInst, "RasDeleteEntryW");
#else
			pRasDelEntry = (RASDELETEENTRY) 
				GetProcAddress(hRasDllInst, "RasDeleteEntryA");
#endif

#ifdef _UNICODE
			pRasGetErrorString = (RASGETERRORSTRING)
			GetProcAddress(hRasDllInst, "RasGetErrorStringW");
#else
			pRasGetErrorString = (RASGETERRORSTRING)
			GetProcAddress(hRasDllInst, "RasGetErrorStringA");
#endif


#ifdef _UNICODE
			pRasDial = (RASDIAL)
			GetProcAddress(hRasDllInst, "RasDialW");
#else
			pRasDial = (RASDIAL)
			GetProcAddress(hRasDllInst, "RasDialA");
#endif


#ifdef _UNICODE
			pRasHangup = (RASHANGUP)
			GetProcAddress(hRasDllInst, "RasHangUpW");
#else
			pRasHangup = (RASHANGUP)
			GetProcAddress(hRasDllInst, "RasHangUpA");
#endif


#ifdef _UNICODE
			pRasEnumDevices = (RASENUMDEVICES )
					GetProcAddress(hRasDllInst, "RasEnumDevicesW");
#else
				pRasEnumDevices = (RASENUMDEVICES )
					GetProcAddress(hRasDllInst, "RasEnumDevicesA");
#endif

#ifdef _UNICODE
			pRasEnumConnections = (RASENUMCONNECTIONS)
					GetProcAddress(hRasDllInst, "RasEnumConnectionsW");
#else
			pRasEnumConnections = (RASENUMCONNECTIONS)
					GetProcAddress(hRasDllInst, "RasEnumConnectionsA");
#endif

#ifdef _UNICODE
			pRasGetCountryInfo = (RASGETCOUNTRYINFO)
					GetProcAddress(hRasDllInst, "RasGetCountryInfoW");
#else
			pRasGetCountryInfo = (RASGETCOUNTRYINFO)
					GetProcAddress(hRasDllInst, "RasGetCountryInfoA");
#endif
		
			pRasGetCountryInfoA = (RASGETCOUNTRYINFO)
					GetProcAddress(hRasDllInst, "RasGetCountryInfoA");

#ifdef _UNICODE
			pRasGetConnectionStatus  = (RASGETCONNECTIONSTATUS) 
				GetProcAddress(hRasDllInst, "RasGetConnectionStatusW");
#else
			pRasGetConnectionStatus  = (RASGETCONNECTIONSTATUS) 
				GetProcAddress(hRasDllInst, "RasGetConnectionStatusA");
#endif


				
			siRasDllLoaded = RAS_DLL_LOADED;
  		}


	}
	return siRasDllLoaded;
	 
}


DWORD ATK_RasGetEntryProperties(
		LPTSTR lpszPhonebook, 
		LPTSTR lpszEntry, 
		LPRASENTRY lpRasEntry, 
		LPDWORD lpdwEntryInfoSize, 
		LPBYTE lpbDeviceInfo, 
		LPDWORD lpdwDeviceInfoSize )
{
	return (*pRasGetEntryProperties) ( lpszPhonebook, 
				 lpszEntry, 
				 lpRasEntry, 
			  	 lpdwEntryInfoSize, 
				 lpbDeviceInfo, 
				 lpdwDeviceInfoSize);

}


DWORD ATK_RasSetEntryProperties(
		LPTSTR lpszPhonebook, 
		LPTSTR lpszEntry, 
		LPRASENTRY lpRasEntry, 
		DWORD dwEntryInfoSize, 
		LPBYTE lpbDeviceInfo, 
		DWORD dwDeviceInfoSize )
{
	return (*pRasSetEntryProperties) ( 
				 lpszPhonebook, 
				 lpszEntry, 
				 lpRasEntry, 
			  	 dwEntryInfoSize, 
				 lpbDeviceInfo, 
				 dwDeviceInfoSize);


}

DWORD ATK_RasDeleteEntry( LPTSTR lpszPhonebook,
					   LPTSTR lpszEntry)
{
	return (*pRasDelEntry)(lpszPhonebook,lpszEntry);
}

DWORD ATK_RasGetErrorString( UINT uErrorValue, 
							 LPTSTR lpszErrorString, 
							 DWORD cBufSize )
{
	return (*pRasGetErrorString)(uErrorValue,lpszErrorString,cBufSize);

}

DWORD ATK_RasHangUp( HRASCONN hrasconn )
{
	return (*pRasHangup)(hrasconn);
}              


DWORD ATK_RasDial( LPRASDIALEXTENSIONS lpRasDial, 
			 LPTSTR  lpPhBk, 
			 LPRASDIALPARAMS lpDialParam,
			 DWORD dwNotifyType,
			 LPVOID lpNotifier,
			 LPHRASCONN lphRasConn)
{
	return (*pRasDial) ( lpRasDial, 
			 lpPhBk, 
			 lpDialParam,
			 dwNotifyType,
			 lpNotifier,
			 lphRasConn);

}



DWORD ATK_RasEnumDevices( LPRASDEVINFO lpRasDevInfo, 
						  LPDWORD lpcb, 
						  LPDWORD lpcDevices)

{
	return (*pRasEnumDevices)(lpRasDevInfo, 
		lpcb, 
		lpcDevices);

}

DWORD ATK_RasEnumConnections ( LPRASCONN lprasconn, 
							  LPDWORD lpcb, 
							  LPDWORD lpcConnections)
{
	return (*pRasEnumConnections) (lprasconn,lpcb, 
							  lpcConnections);
}

#define  MAX_ACTIVE_RAS_CONNECTION 5
/*

	Returns +VE value if there is an active connection

*/
int IsDialupConnectionActive()
{
	RASCONN RasConn[MAX_ACTIVE_RAS_CONNECTION];
	DWORD   dwSizeConn,dwConnections,dwRet;
	int		iCount;
	dwConnections = 0;
	for(iCount=0;iCount < MAX_ACTIVE_RAS_CONNECTION ;iCount++) {
		RasConn[iCount].dwSize= sizeof(RASCONN);
	}

	dwSizeConn = sizeof(RASCONN) * MAX_ACTIVE_RAS_CONNECTION;
	dwRet = ATK_RasEnumConnections ( RasConn, 
							 &dwSizeConn, 
							 &dwConnections);
	switch(dwRet) 
	{
	case ERROR_BUFFER_TOO_SMALL :
		;
		//cout << "\n Buffer Too Small "<< flush;
	case ERROR_NOT_ENOUGH_MEMORY :
		;
		//cout << "\n Not enough memory  "<< flush;
	default :
		break;
	} 

	if(dwConnections) {
		return ((int)dwConnections);
	}else {
		return 0;
	}


}

DWORD ATK_RasGetCountryInfo( LPRASCTRYINFO lpRasCtryInfo, 
					LPDWORD lpdwSize )
{
 return (*pRasGetCountryInfo) (lpRasCtryInfo,lpdwSize); 
				  
 
} 
 
DWORD ATK_RasGetCountryInfoA( LPRASCTRYINFO lpRasCtryInfo, 
					LPDWORD lpdwSize )
{
 return (*pRasGetCountryInfoA) (lpRasCtryInfo,lpdwSize); 
} 

DWORD ATK_RasGetConnectionStatus( HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus )
{
 return (*pRasGetConnectionStatus) (hrasconn,lprasconnstatus); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\dconv.h ===
/*
   File : DConv.H
   Header file for Data Conversion of  RegWiz Registry Information 

      

*/
#ifndef __DCONV__
#define __DCONV__

#ifdef __cplusplus
extern "C" 
{
#endif

int PrepareRegWizTxbuffer(HINSTANCE hIns, char *tcTxBuf, DWORD * pRetLen); 
DWORD OemTransmitBuffer(HINSTANCE hIns,char *sztxBuffer,DWORD * pRetLen);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\icw.h ===
#ifndef __ICW_h__
#define __ICW_h__
/**************************************************************************

   File:          icw.h
   
   Description:   

**************************************************************************/
typedef HRESULT (WINAPI *INETGETPROXY)(LPBOOL lpfEnable, LPSTR lpszServer, DWORD cbServer, LPSTR lpszOverride, DWORD cbOverride);
typedef HRESULT (WINAPI *INETCONFIGSYSTEM) ( HWND hWndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);



#ifdef __cplusplus
extern "C" 
{
#endif

	BOOL ICWGetProxy(PTCHAR szProxy, DWORD dwBufferLength);

#ifdef __cplusplus
}
#endif	

#endif	// __ICW_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\dconv.cpp ===
//
//	File : DCONV.CPP
//  Date : 04/25/97
//	Author : Suresh Krishnan
//  This file has modules responsible for making the  buffer data to be transmitted to the IIS
//
//  MDF 1 : 05/07/97   Modified the Table as per StevBush modifications in the BackEnd
//  MFD 2 : 03/03/97   Added Division Name and UserID for FE screens
//                     Phone number will be prefixed with Area Code
//  MFD3  : 04/29/98   Added additional 4 fileds to be sent to the backend as a part of
//                     Taxanomy Screen changes.
//                     Fields risen from 60 to 64. Fileds added
//					   SoftwareRole,InfluenceLevel,EngagementLevel,SkillLevel
//  MFD4  : 07/21/98   Additional 2 fields  to be sent to the backend SCSIAdapter
//					   and ComputerManufacturer & Model of SystemInventory
//  MFD5  : 08/1/98    The MathCoprocessor and Color Depth are no longer necessary to be sent to the back end
//                     so the items that are sent to the back end are 66-2 = 64
//  MFD6  : 08/21/98   Added AreaCode and MiddleName( Middle Initial) fo posting
//                     So number of Fields for posting 64+2 = 66
//                     From now on Area code will be sent as a seperate field  to the backend
//                     the logic involved in prefixing with phone number will be removed
//
//	MFD7 :  03/10/99  HWID no longer will be Transmitted to the Backend 
//			  	      Total Entries to Backend 65	
// 
//
#include <mbstring.h>
#include "RW_Common.h"
#include "resource.h"
#include <tchar.h>
#include "dconv.h"
#include "cntryinf.h"
#include "RegWizMain.h"



extern BOOL bOemDllLoaded;
extern HINSTANCE  hOemDll;

#define  NAME_VALUE_SEPERATOR   _T("=")    // Seperator between name and its value
#define  NAME_SEPERATOR         _T("&") 	 // Seperator between the names
#define  RW_BLANK               _T(' ')      // The padding character
#define  RW_WITH_URL			1
#define  PHONE_NUMBER_SEPERATOR _T("-")

#define MAX_NAME_LENGTH    64	 // The Max size of the of the name field
#define VARIABLE_LEN       -2
#define REG_SEPERATOR   TEXT("\\")
#define MAX_TBL_ENTRIES   65     //  No of name fields to be sent to the IIS
#define MAX_REG_VAL_BUF_SZ    300 // The Maximum  size of a value associated with name field
#define STRCONVERT_MAXLEN  1024

static  TCHAR * GetNameString ( TCHAR **pRet,UINT iId,HINSTANCE hIns) ;
int  GetRootOfRegWizRegistry(HINSTANCE hInstance , PHKEY  phKey);
#ifdef _UNICODE
	char* ConvertToMB (TCHAR * szW)
	{
		static char achA[STRCONVERT_MAXLEN];
		WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, STRCONVERT_MAXLEN, NULL, NULL);
		return achA;
	}
#else
	char* ConvertToMB (TCHAR * szW)
	{
		return szW;
	}
#endif

// Information processig functions
void	RW_Dummy (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
};

void 	RW_LanguageTranslate (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	LANGID langID = GetSystemDefaultLangID();
	VerLanguageName(langID,tcDes,MAX_REG_VAL_BUF_SZ);
}

void 	RW_CreateDateProcess (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
};

void 	RW_RegisterDateProcess (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
};

void    RW_MailingAddressProcess (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	size_t iSrcLen = _tcslen(tcSrc);
	if(iSrcLen)
	{
		_tcscpy(tcDes,TEXT("1"));
	}
	else
	{
		_tcscpy(tcDes,TEXT("2"));
	}
}


void	RW_ValidateTapiCountryCode (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	DWORD dwTapiCntryId;
	DWORD dwCode = _ttol(tcSrc);
	dwTapiCntryId = gTapiCountryTable.GetTapiIDForTheCountryIndex(dwCode);
	_stprintf(tcDes,_T("%d"),dwTapiCntryId);


};

void	RW_TranslateCountryCode(_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	DWORD dwCode = _ttol(tcSrc); // Convert the Current code in string to long
	_tcscpy(tcDes, gTapiCountryTable.GetCountryName(dwCode));

}

void	RW_ParsePhoneNumber(_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	HKEY	hKey;
	DWORD   infoSize;
	TCHAR   szR[48];
	TCHAR   szParam[256];
	LONG    lRegStatus;
	TCHAR   szInBuf[256];
	//
	// As a part of FE screen changes it is necessary to Prefix the Area code
	// before the phone number
	hKey = NULL;
	if(GetRootOfRegWizRegistry(hIns, &hKey) ) {
		return;
		// Not able to open the Registry Tree for Area Code
		// so simply return ...
	}
	infoSize = 48;
	LoadString( hIns, IDS_AREACODE_KEY,
						szR,
						sizeof(szR)/ sizeof (TCHAR));
	lRegStatus = RegQueryValueEx(hKey,&szR[1],NULL,0,(LPBYTE)szParam,&infoSize);
	if(tcSrc[0] !=  _T('\0')){
		_tcscpy(szInBuf,tcSrc);
	}else {
		szInBuf[0] = _T('\0');
	}

	if (lRegStatus != ERROR_SUCCESS){
		   	return; //  	RWZ_INVALID_INFORMATION;
	}else {
		if(szParam[0] != _T('\0')) {
			_tcscpy(tcDes,szParam); // Area Code
			_tcscat(tcDes,PHONE_NUMBER_SEPERATOR);     // Separator
			_tcscat(tcDes,szInBuf);
			
		}else {
			//No need to do any thing
			;
		}
		if(hKey)
		RegCloseKey(hKey);
	}
	

}

void	RW_PrcsProductId (LPTSTR tcSrc, LPTSTR tcDes , HINSTANCE hIns )
{
	_TCHAR	seps[] = _T("-");
	LPTSTR	token;
	LPTSTR	buf;
	if (*tcSrc == 0 ) 
    {
		*tcDes=0;
		return;
	}

   buf = new _TCHAR[_tcslen(tcSrc) * sizeof(_TCHAR) +sizeof(_TCHAR)];
   if (buf)
   {
       token = _tcstok( tcSrc, seps );
       _tcscpy(buf,token);

       token = _tcstok( NULL, seps );
       while( token != NULL )
       {
	    /* Get next token: */
	    _tcscat(buf,token);
	    token = _tcstok( NULL, seps );
       }
	    
	    _tcscpy(tcDes,buf);

        delete[] buf;
   }
};

//
// void	RW_ParseTotalSize (_TCHAR * tcSrc, _TCHAR * tcDes  )
// This function retrives the the Size  wich is founs as the first  token in tcSrc
// After the end of this function the tcDes will be assiged with the Size
//
void	RW_ParseTotalSize (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	int isBlankPassed=0;
	TCHAR tcSteps[]   = TEXT(" ,\t\n");
	if(*tcSrc == 0 )
	{
		*tcDes=0;
		return;
	}

	// since the value in tcSrc is "RAM UNIT" so it is encouh if is pass only the first word
	TCHAR  *tcToken;
    tcToken =_tcstok(tcSrc, tcSteps);
	_tcscpy(tcDes,tcToken);

}

//
// void	RW_ParseUnits (_TCHAR * tcSrc, _TCHAR * tcDes  )
// This function retrives the the unit name wich is founs as the second token in tcSrc
// After the end of this function the tcDes will be assiged with the Units
//
void	RW_ParseUnits (_TCHAR * tcSrc, _TCHAR * tcDes , HINSTANCE hIns )
{
	int isBlankPassed=0;
	TCHAR tcSteps[]   = TEXT(" ,\t\n\0");
	if(*tcSrc == 0 )
	{
		*tcDes=0;
		return;
	}
	// since the value in tcSrc is "RAM UNIT" so it is encouh if is pass only the first word
	TCHAR  *tcToken;
    tcToken =_tcstok(tcSrc, tcSteps); // get the size
    tcToken = _tcstok( NULL, tcSteps); // get the units
	_tcscpy(tcDes,tcToken);

}

//
// RegWizInfoDetails
// This  structure is used to create a table which has the Namefiled,
// the value reference in the Resource  which is to  be used to retrive from registry
// and Function  to process the value
//
typedef struct  RegWizInfoDetails
{
	int    m_iIndex;
	TCHAR   m_czName[MAX_NAME_LENGTH];
	int    m_iLen;
	int    m_ResourceIndex;
	int    m_iParam;
	void (*m_fp)(_TCHAR * tcSrc, _TCHAR * tcDes, HINSTANCE hIns);
} _RegWizInfoDetails ;

static RegWizInfoDetails  sRegWizInfoTbl[MAX_TBL_ENTRIES] =
{
{ 1,    _T("RegWizVer")			,8,				IDS_INFOKEY30,		0, RW_Dummy },
{ 2,    _T("CodePage")			,5,				-1 ,				0, RW_Dummy },
{ 3,    _T("LangCode")			,5,				IDS_INFOKEY34 ,		0, RW_Dummy },
{ 4,    _T("LangName")			,30,			IDS_INFOKEY34 ,		0, RW_LanguageTranslate },
{ 5,    _T("CreatedDate")		,10,			-1 ,				0, RW_CreateDateProcess    },
{ 6,    _T("RegDate")			,10,			IDS_INFOKEY33,		0, RW_RegisterDateProcess },
{ 7,    _T("FName")				,VARIABLE_LEN,	IDS_INFOKEY1 ,		0, RW_Dummy },
{ 8,    _T("LName")				,VARIABLE_LEN,	IDS_INFOKEY2 ,		0, RW_Dummy },
{ 9,    _T("CompanyName")		,VARIABLE_LEN,	IDS_INFOKEY3,		0, RW_Dummy },
{ 10,   _T("AddrType")			,1,				IDS_INFOKEY3,		0, RW_MailingAddressProcess },
{ 11,   _T("Addr1")				,VARIABLE_LEN , IDS_INFOKEY4,		0, RW_Dummy },
{ 12,   _T("Addr2")				,VARIABLE_LEN,  IDS_INFOKEY5,		0, RW_Dummy },
{ 13,   _T("City")				,VARIABLE_LEN,  IDS_INFOKEY6,		0, RW_Dummy },
{ 14,   _T("State")				,VARIABLE_LEN , IDS_INFOKEY7,		0, RW_Dummy },
{ 15,   _T("Zip")				,VARIABLE_LEN , IDS_INFOKEY8,		0, RW_Dummy },
{ 16,   _T("CountryCode")		,4 ,            IDS_INFOKEY9 ,		0, RW_ValidateTapiCountryCode  },
{ 17,   _T("Country")			,60,            IDS_INFOKEY9 ,		0, RW_TranslateCountryCode },
{ 18,   _T("Phone")				,VARIABLE_LEN , IDS_INFOKEY10,		0, RW_Dummy },
{ 19,   _T("NoOther")			,1 ,			IDS_INFOKEY11,		0, RW_Dummy },
{ 20,   _T("Product")			,255,			IDS_INFOKEY28,		0, RW_Dummy },
{ 21,   _T("PID")				,20,			IDS_INFOKEY12,		0, RW_PrcsProductId },
{ 22,   _T("OEM")				,255 ,			IDS_INFOKEY29,		0, RW_Dummy },
{ 23,   _T("SysInv")			,1,				IDS_INFOKEY26,		0, RW_Dummy },
{ 24,   _T("OS")				,40,			IDS_INFOKEY25,		0, RW_Dummy },
{ 25,   _T("CPU")				,20 ,			IDS_INFOKEY13,		0, RW_Dummy },
//{ 26,   _T("MathCo")			,1  ,			IDS_INFOKEY14,		0, RW_Dummy },
{ 27,   _T("TotalRAM")			,8 ,			IDS_INFOKEY15,		0, RW_ParseTotalSize},
{ 28,   _T("RAMUnits")			,2 ,			IDS_INFOKEY15,		0, RW_ParseUnits},
{ 29,   _T("TotalDisk")			,8 ,			IDS_INFOKEY16,		0, RW_ParseTotalSize},
{ 30,   _T("DiskUnits")			,2 ,			IDS_INFOKEY16,		0, RW_ParseUnits},
{ 31,   _T("RemoveableMedia")	,60 ,			IDS_INFOKEY17,		0, RW_Dummy },
//{ 32,   _T("DisplayRes")		,16 ,			IDS_INFOKEY18 ,		0, RW_Dummy },
{ 33,   _T("DisplayColorDepth")	,8 ,			IDS_INFOKEY19 ,		0, RW_Dummy },
{ 34,   _T("PointingDevice")	,75,			IDS_INFOKEY20 ,		0, RW_Dummy },
{ 35,   _T("Network")			,75 ,			IDS_INFOKEY21 ,		0, RW_Dummy },
{ 36,   _T("Modem")				,75 ,			IDS_INFOKEY22 ,		0, RW_Dummy },
{ 37,   _T("Sound")				,60 ,			IDS_INFOKEY23 ,		0, RW_Dummy },
{ 38,   _T("CDROM")				,40 ,			IDS_INFOKEY24 ,		0, RW_Dummy },
{ 39,   _T("ProdInv")			,1 ,			IDS_INFOKEY27 ,		0, RW_Dummy },
{ 40,   _T("InvProd1")			,75,			IDS_PRODUCTBASEKEY, 1, RW_Dummy },
{ 41,   _T("InvProd2")			,75,			IDS_PRODUCTBASEKEY, 2, RW_Dummy },
{ 42,   _T("InvProd3")			,75,			IDS_PRODUCTBASEKEY, 3, RW_Dummy },
{ 43,   _T("InvProd4")			,75,			IDS_PRODUCTBASEKEY, 4, RW_Dummy },
{ 44,   _T("InvProd5")			,75,			IDS_PRODUCTBASEKEY, 5, RW_Dummy },
{ 45,   _T("InvProd6")			,75,			IDS_PRODUCTBASEKEY, 6, RW_Dummy },
{ 46,   _T("InvProd7")			,75,			IDS_PRODUCTBASEKEY, 7, RW_Dummy },
{ 47,   _T("InvProd8")			,75,			IDS_PRODUCTBASEKEY, 8, RW_Dummy },
{ 48,   _T("InvProd9")			,75,			IDS_PRODUCTBASEKEY, 9, RW_Dummy },
{ 49,   _T("InvProd10")			,75,			IDS_PRODUCTBASEKEY, 10,RW_Dummy },
{ 50,   _T("InvProd11")			,75,			IDS_PRODUCTBASEKEY, 11,RW_Dummy },
{ 51,   _T("InvProd12")			,75,			IDS_PRODUCTBASEKEY, 12,RW_Dummy },
{ 52,   _T("EmailName")			,50,            IDS_INFOKEY35,		0, RW_Dummy },
{ 53,   _T("Reseller")			,30,            IDS_INFOKEY36,		0, RW_Dummy },
{ 54,   _T("ResellerCity")		,20,            IDS_INFOKEY37,		0, RW_Dummy },
{ 55,   _T("ResellerState")		,3,             IDS_INFOKEY38,		0, RW_Dummy },
//{ 56,   _T("HWID")				,32,            IDS_INFOKEY39,		0, RW_Dummy },
{ 57,   _T("MSID")				,32,            IDS_INFOKEY40,		0, RW_Dummy },
{ 58,   _T("Extension")			,32,            IDS_INFOKEY41,		0, RW_Dummy },
{ 59,   _T("DivisionName")      ,50,            IDS_DIVISIONNAME_KEY,   0, RW_Dummy },
{ 60,   _T("UserID")            ,50,            IDS_USERID_KEY,     0, RW_Dummy },
{ 61,   _T("SoftwareRole")		,2,             IDS_BUSINESSQ1,		0, RW_Dummy },
{ 62,   _T("InfluenceLevel")	,2,             IDS_HOMEQ1,		0, RW_Dummy },
{ 63,   _T("EngagementLevel")   ,2,             IDS_HOMEQ2,   0, RW_Dummy },
{ 64,   _T("SkillLevel")        ,2,             IDS_HOMEQ3,     0, RW_Dummy },
{ 65,   _T("SCSIAdapter")       ,75,            IDS_SCSI_ADAPTER,     0, RW_Dummy },
{ 66,   _T("ComputerManf")     ,256,            IDS_COMPUTER_MODEL,     0, RW_Dummy },
{ 67,   _T("AreaCode")       ,30,            IDS_AREACODE_KEY,     0, RW_Dummy },
{ 68,   _T("Mname")     ,75,            IDS_MIDDLE_NAME,     0, RW_Dummy }
};





//
//  PadWithBlanks(TCHAR **pSrc, TCHAR ** pDes,int iLen)
//
//  This function adds space to the soiurce string so the resultant string is of the length
//  specified by iLen
//
//
//
void PadWithBlanks(TCHAR *pSrc, TCHAR * pDes,int iLen)
{
	int iSrcLen;

	iSrcLen = _tcslen(pSrc) * sizeof(_TCHAR);
	if(iLen < 0)
	{
		//  if it is  variable length then copy the string and return
		_tcscpy(pDes,pSrc);
		return;
	}
	
	//
	// Try to copy till iLen
	// the extra +1 is added to add a null terminator after copy
	_tcsnccpy(pDes,pSrc,iLen+ sizeof(_TCHAR));

	if(iSrcLen < iLen )
	{
		// the source string is less than the expected maximum length
		for(int iIndex = iSrcLen;iIndex < iLen;iIndex++)
		{
			pDes[iIndex] = RW_BLANK; // Adds blank
		}
		pDes[iIndex] = _T('\0');
	}
	
}

// int  GetRootOfRegWizRegistry(HINSTANCE hInstance , PHKEY  phKey)
//
// Description :
//	This function Opens the User  Information value in the registry for
//  regWizard configured values to be read
//
//	Return Information:
//	This function return the HANDLE of the registry in phKey and returns 0
//  If the Key is not found the  function returns 1
//
//


int  GetRootOfRegWizRegistry(HINSTANCE hInstance , PHKEY  phKey)
{
	TCHAR uszPartialKey[128];
	TCHAR uszRegKey[128];
	uszRegKey[0] = _T('\0');
	
	int resSize = LoadString(hInstance,IDS_KEY2,uszRegKey,128);
	_tcscat(uszRegKey,REG_SEPERATOR);
	resSize = LoadString(hInstance,IDS_KEY3,uszPartialKey,128);
	_tcscat(uszRegKey,uszPartialKey);
	_tcscat(uszRegKey,REG_SEPERATOR);
	resSize = LoadString(hInstance,IDS_KEY4,uszPartialKey,128);
	_tcscat(uszRegKey,uszPartialKey);
	
	#ifdef USE_INFO_SUBKEYS
		_tcscat(uszRegKey,REG_SEPERATOR);
	#endif

	LONG regStatus =RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		uszRegKey,
		0,
		KEY_ALL_ACCESS,
		phKey);

	if (regStatus != ERROR_SUCCESS)
	{
		return 1; // error
	}
	else
	{
		return 0; // Success
	}
}

//
// TCHAR * GetNameString ( TCHAR **pRet,UINT uId,HINSTANCE hIns)
//
//  Description :
//
//	This function retrives the Name field  for Transmission from the Resource
//  Some names in the  resouce is prefixed with '_' so this function  removes the
//  prefix character.
//
//  Return Information:
//  This function returns  NULL if the string is not found in the resource
//	It accepts the address of a TCHAR pointer  ,the string address is assigned in the
//  pointer.  It also returns the same address as a return Status
//
//  Note :
//  It is not required to delete the pointer returned by this function as it is static
//

TCHAR * GetNameString ( TCHAR **pRet,UINT uId,HINSTANCE hIns)
{
	static TCHAR tczRetValue[MAX_NAME_LENGTH ];
	int  iLoad = LoadString( hIns, uId,
						tczRetValue,
						sizeof(tczRetValue)/ sizeof (TCHAR));
	if(!iLoad )
	{
		pRet = NULL;
		return NULL;
	}

	if( tczRetValue[0]   == _T('_')   )
	{
		*pRet = &tczRetValue[1];
		return &tczRetValue[1];
	}
	else
	{
		*pRet = &tczRetValue[0];
		return &tczRetValue[0];
	}

}

//
//
// URL Encoding

/*===================================================================
URLEncodeLen

Return the storage requirements for a URL-Encoded string

Parameters:
	szSrc  - Pointer to the string to URL Encode

Returns:
	the number of bytes required to encode the string
===================================================================*/

int URLEncodeLen(const char *szSrc)
{
	int cbURL = 1;		// add terminator now
	while (*szSrc)
	{
		if (*szSrc & 0x80)				// encode foreign characters
			cbURL += 3;
		else
		if (*szSrc == ' ')			// encoded space requires only one character
			++cbURL;
		else
		if (! isalnum(*szSrc))		// encode non-alphabetic characters
			cbURL += 3;
		else
			++cbURL;

		++szSrc;
	}
	return cbURL;
}



/*===================================================================
URLEncode

URL Encode a string by changing space characters to '+' and escaping
non-alphanumeric characters in hex.

Parameters:
	szDest - Pointer to the buffer to store the URLEncoded string
	szSrc  - Pointer to the source buffer

Returns:
	A pointer to the NUL terminator is returned.
===================================================================*/

char *URLEncode(char *szDest, const char *szSrc)
{
	char hex[] = "0123456789ABCDEF";

	while (*szSrc)
	{
		if (*szSrc == ' ')
		{
			*szDest++ = '+';
			++szSrc;
		}
		else
		if (!isalnum(*szSrc) || (*szSrc & 0x80))
		{
			*szDest++ = '%';
			*szDest++ = hex[BYTE(*szSrc) >> 4];
			*szDest++ = hex[*szSrc++ & 0x0F];
		}
		else
			*szDest++ = *szSrc++;
	}

	*szDest = '\0';
	return szDest;
}



//
// This class is used to store the RegWiz Info in URL encode format
// This class is construected with the TxBuffer pointer
// The AppendToBuffer converts the string to URL encoded form and adds to the TxBuffer
// if the TxBuffer size  is less then it only computesthe size  and does not transfer
// the buffer contents
//

class RegWizTxBuffer
{

public :

	char *m_pBuf;
	int   m_iSizeExceeded; // set
	DWORD *m_pdInitialSize;
	DWORD m_dCurrentIndex;

	RegWizTxBuffer(char *tcTxBuf, DWORD * pRetLen)
	{
		m_pBuf = tcTxBuf; // Initial Pointer of the Destination Buffer
		m_pdInitialSize = pRetLen; // The Destination Buffer Size
		m_dCurrentIndex = 0; // Current Index of the number of bytes of information transmitted
		m_iSizeExceeded = 0;
		m_pBuf[0] = '\0';
	}

	void  AppendToBuffer(TCHAR *tcTxBuf, int iIsUrl=0)
	{
		int iLen=0;
		
		#ifdef _UNICODE
			unsigned char *mbpTxBuf;
		#endif

		// The TxBuffer has to be converted to MultiByte in case
		// Convert to MultByte

		#ifdef _UNICODE
			mbpTxBuf = (unsigned char *)ConvertToMB (tcTxBuf); // Convert to MultiByte
			iLen =  _mbslen (mbpTxBuf);
		#else
			iLen = _tcsclen(tcTxBuf);
		#endif

		if(iIsUrl)
		{
			#ifdef _UNICODE
				iLen= URLEncodeLen((const char *)mbpTxBuf);
			#else
				iLen = URLEncodeLen(tcTxBuf);
			#endif
		}

		if( m_dCurrentIndex + iLen >= *m_pdInitialSize )
		{
			// continue counting the lengthn required
			m_iSizeExceeded = 1;
	 	}
		else
		{
			if( iIsUrl)
			{
				#ifdef _UNICODE
					URLEncode(m_pBuf+m_dCurrentIndex,(const char *)mbpTxBuf);
				#else
					// for MBCS and SBCS
					URLEncode(m_pBuf+m_dCurrentIndex,tcTxBuf);
				#endif
			}
			else
			{
				#ifdef _UNICODE
					strcat(m_pBuf,(const char *)mbpTxBuf);
				#else
					_tcscat(m_pBuf,tcTxBuf);
				#endif
			}
		;

		}
		if(iIsUrl)
		m_dCurrentIndex +=  iLen-1;
		else
		m_dCurrentIndex +=  iLen;

	}

	int  IsValidBuffer()
	{
		m_pBuf[m_dCurrentIndex] = '\0';
		*m_pdInitialSize = m_dCurrentIndex;
		return m_iSizeExceeded ;
	}

};


int PrepareRegWizTxbuffer(HINSTANCE hIns, char *tcTxBuf, DWORD * pRetLen)
{
	int				iRetValue;
	HKEY			hKey;
	LONG			lRegStatus;
	TCHAR			*szR;
	TCHAR			tczTmp[10];
	TCHAR			szParam[MAX_REG_VAL_BUF_SZ]; // ?? chk in case of Unicode
	unsigned long	infoSize;
	RegWizTxBuffer  TxferBuf(tcTxBuf,pRetLen);

	iRetValue		= RWZ_NOERROR;
	infoSize		= MAX_REG_VAL_BUF_SZ;

	if(GetRootOfRegWizRegistry(hIns, &hKey) )
	{
		iRetValue = RWZ_NO_INFO_AVAILABLE;
		// No User Information is Available So Abort the program
	}
	else
	{
		// Process for all the information entries
		 for(int i =0;i <  MAX_TBL_ENTRIES ;i++)
		 {
			infoSize = MAX_REG_VAL_BUF_SZ;
			szParam[0] = '\0';
		
			#ifdef _LOG_IN_FILE			
		 		RW_DEBUG << "\n" << i+1  << "\t"  << ConvertToMB (sRegWizInfoTbl[i].m_czName) << "\t" << flush;
			#endif
			
			TxferBuf.AppendToBuffer(sRegWizInfoTbl[i].m_czName,RW_WITH_URL);
			
			TxferBuf.AppendToBuffer(NAME_VALUE_SEPERATOR);

			if( sRegWizInfoTbl[i].m_ResourceIndex < 1)
			{
				 // continue processing
			}
			else
			{
				if( GetNameString(&szR,sRegWizInfoTbl[i].m_ResourceIndex,hIns ) )
				{

					if(	sRegWizInfoTbl[i].m_iParam )
					{
						//  This block is  for appending Product name index
						_itot(sRegWizInfoTbl[i].m_iParam,tczTmp,10);
						_tcscat(szR,_T(" ")); // add a single blank
						_tcscat(szR,tczTmp);
						#ifdef _LOG_IN_FILE
							RW_DEBUG  << ConvertToMB (szR) << "\t";
						#endif
					}
					lRegStatus = RegQueryValueEx(hKey,szR,NULL,0,(  LPBYTE )   szParam,&infoSize);

					if (lRegStatus != ERROR_SUCCESS)
					{
					   	return 	RWZ_INVALID_INFORMATION;
					}

					#ifdef _LOG_IN_FILE
						RW_DEBUG  << "[" <<ConvertToMB (szParam )<< "]\t"   << flush;
					#endif
					
				}
				else
				{
 					//
					//  This condition can happen if information is not found in the Resource
					//  If the function  entres this block the it is necessary to verify the
					//  the resource string in the table mapping
					//
					return 	RWZ_INTERNAL_ERROR;

				}
			}

			if(szParam)
			{
				(*sRegWizInfoTbl[i].m_fp)(szParam,szParam,hIns); // Invoke processing Function
				//PadWithBlanks(szParam,szRet,sRegWizInfoTbl[i].m_iLen); // Add balnks
			}

			//TxferBuf.AppendToBuffer(szRet,RW_WITH_URL); with padded
			TxferBuf.AppendToBuffer(szParam,RW_WITH_URL);
			//
			//
			// Skip Name key seperator for the last entry
			if(i!= MAX_TBL_ENTRIES-1)
				TxferBuf.AppendToBuffer(NAME_SEPERATOR);

		 }// end of for loop
 	}

	if(TxferBuf.IsValidBuffer())
	{

		iRetValue=RWZ_BUFFER_SIZE_INSUFFICIENT;
	}
	
	return iRetValue;

}


DWORD OemTransmitBuffer(HINSTANCE hIns,char *sztxBuffer,DWORD *nInitialSize)
{	
	BOOL bValueExceeded = FALSE;
	
	if(bOemDllLoaded == TRUE)
	{
		DWORD nCount,nLen,nCurrentLen = 0;
		HKEY hOemKey;
			
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n OEM: Inside OemTransmitBuffer" << flush;
		#endif
		
		GetRootOfRegWizRegistry(hIns, &hOemKey);

		OEMDataCount	pOEMDataCount;

		pOEMDataCount = (OEMDataCount) GetProcAddress(hOemDll, "OEMDataCount");
		if (pOEMDataCount == NULL)
		{
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n OEM: OEMDataCount Getproc Error" << flush;
			#endif
			return RWZ_INTERNAL_ERROR;
		}
		
		nCount = (DWORD)pOEMDataCount();
		
		if(nCount > 25)
		{
			nCount = 25;
		}

		for( DWORD index = 1; index <= nCount; index++	)
		{
			_TCHAR szOEMValueName[64];
			_TCHAR szOEMBase[64];
			char szBuffer[1024];
			BOOL   bIsUnicode;
			BYTE lpValue[256] ;
			_TCHAR szValue[256];
		
			LoadString(hIns,IDS_OEMBASEKEY,szOEMBase,64);
		
			_stprintf(szOEMValueName,_T("%s_%i"),szOEMBase,index);

			#ifdef _UNICODE
			  strcpy(szBuffer,ConvertToMB(szOEMValueName));
			#else
			  _tcscpy(szBuffer,szOEMValueName);
			#endif
			
			
			OEMGetData	pOEMGetData;

			pOEMGetData = (OEMGetData) GetProcAddress(hOemDll, "OEMGetData");
			if (pOEMGetData == NULL)
			{
				#ifdef _LOG_IN_FILE
					RW_DEBUG << "\n OEM: OEMGetData Getproc Error"<< flush;
				#endif
				return RWZ_INTERNAL_ERROR;
			}

            nLen = sizeof(lpValue);

			pOEMGetData((WORD)index,&bIsUnicode,lpValue,(WORD)nLen);

			#ifdef _UNICODE
				if(!bIsUnicode)
				{
				  MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpValue, -1, (LPTSTR)szValue, 256);
				}
				else
				{
					_tcscpy((LPTSTR)szValue,(LPCTSTR)lpValue);
				}
			#else
				if(bIsUnicode)
				{
				  WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)lpValue, -1, (LPTSTR)szValue, 256, NULL, NULL);
				}
				else
				{
					_tcscpy((LPTSTR)szValue,(LPCTSTR)lpValue);
				}
			#endif	
			
			if(	_tcscmp((LPCTSTR)szValue,_T("")))
			{
				nLen = strlen("&");
				if( nCurrentLen + nLen >= *nInitialSize )
				{
					bValueExceeded = TRUE;
			 	}
				else
				{
					strcat(sztxBuffer,"&");
				}
				nCurrentLen +=  nLen;

				nLen = URLEncodeLen(szBuffer);
				if( nCurrentLen + nLen >= *nInitialSize )
				{
					bValueExceeded = TRUE;
			 	}
				else
				{
					URLEncode(sztxBuffer+nCurrentLen,szBuffer);
				}

				nCurrentLen +=  nLen-1;
		
				RegSetValueEx(hOemKey,szOEMValueName,NULL,REG_SZ,(CONST BYTE *)szValue,_tcslen((LPCTSTR)szValue));
				
				if(bIsUnicode)
				{
					strcpy(szBuffer,ConvertToMB((TCHAR *)lpValue));
				}
				else
				{
					strcpy(szBuffer,(char *)lpValue);
				}

				#ifdef _LOG_IN_FILE			
		 		 RW_DEBUG << "\n OEM " << index << "\t"<< ConvertToMB(szOEMValueName)<< "\t"
										<< szBuffer <<flush;
				#endif
				
				nLen = strlen("=");
				if( nCurrentLen + nLen >= *nInitialSize )
				{
					bValueExceeded = TRUE;
			 	}
				else
				{
					strcat(sztxBuffer,"=");
				}
				nCurrentLen +=  nLen;

				
				nLen = URLEncodeLen(szBuffer);
				if( nCurrentLen + nLen >= *nInitialSize )
				{
					#ifdef _LOG_IN_FILE
						RW_DEBUG << "\n OEM:Buffer value Exceeded" << flush;
						RW_DEBUG << "\n OEM:Current Length:" << nCurrentLen << flush;
						RW_DEBUG << "\n OEM:Length of present value:" << nLen << flush;
						RW_DEBUG << "\n OEM:Initial Size:" << *nInitialSize << flush;
					#endif
					bValueExceeded = TRUE;
			 	}
				else
				{
					URLEncode(sztxBuffer+nCurrentLen,szBuffer);
				}

				nCurrentLen +=  nLen-1;
			}				
		}
		*nInitialSize = nCurrentLen;
		if(bValueExceeded )
		{
			return RWZ_BUFFER_SIZE_INSUFFICIENT;
		}
		else
		{
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n OEM: OemTransmitBuffer Successful" << flush;
			#endif
			return RWZ_NOERROR;
		}
	}
	else
	{
		*nInitialSize = 0;
	}

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n OEM: OemTransmitBuffer Successful" << flush;
	#endif

	return RWZ_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\atk_inet.cpp ===
//  File	 : ATK_INET.CPP
//  Author   : Suresh Krishnan 
//  Date     : 08/05/97
//  Wrapper for INetCFG.DLL exported functions
//  related  function declarations
//
//

#include <windows.h>
#include <tchar.h>
#include <winnt.h>
#include <wininet.h>
#include <stdio.h>
#include "rw_common.h"






typedef HRESULT (WINAPI *INETGETPROXY)(LPBOOL lpfEnable, LPSTR lpszServer, DWORD cbServer, LPSTR lpszOverride, DWORD cbOverride);
typedef HRESULT (WINAPI *INETCONFIGSYSTEM) ( HWND hWndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef HRESULT (WINAPI *INETGETAUTODIAL) (LPBOOL lpEnable, LPSTR lpszEntryName, DWORD cbEntryName);
typedef HRESULT (WINAPI *INETSETAUTODIAL) (BOOL fEnable, LPCSTR lpszEntryName);

#define ERROR_IN_SET       -1
#define INET_DLL_FAILURE   -1

static HINSTANCE  hINetCfg= NULL;
static INETGETPROXY	    fpGetProxy=NULL;
static INETCONFIGSYSTEM fpGetConfigSystem=NULL;
static INETGETAUTODIAL  fpGetAutoDial=NULL;
static INETSETAUTODIAL  fpSetAutoDial=NULL;
static INETCONFIGSYSTEM fpInetConfig =NULL;  

typedef struct {
	char szActiveConnection[256];
	BOOL fStatus;
    enum ISPStateFlag {NotValidState,ValidState } iState ;
} ISPState; 

static ISPState  gIspState = { "",
						0,
						ISPState::NotValidState};




int INetCfgSetup()
{
	if(hINetCfg) {
		return 1;
	}
	hINetCfg = LoadLibrary( _T("INETCFG.DLL") );  //  Load INetCfg.DLL and store globally
	if( !hINetCfg )
	{                                   
	  //  return if the DLL can not loaded
	  //
	  return 0;
	}
	


	fpGetProxy = (INETGETPROXY) GetProcAddress(hINetCfg,"InetGetProxy");
	fpGetAutoDial = ( INETGETAUTODIAL) GetProcAddress(hINetCfg, "InetGetAutodial");
	fpSetAutoDial = ( INETSETAUTODIAL) GetProcAddress(hINetCfg, "InetSetAutodial");
	fpInetConfig = (INETCONFIGSYSTEM) GetProcAddress(hINetCfg, "InetConfigSystem");
	return 1;
	
}

HRESULT ATK_InetGetAutoDial(LPBOOL lpEnable, LPSTR lpszEntryName, DWORD cbEntryName)
{
	if(INetCfgSetup()) {
	return (*fpGetAutoDial)(lpEnable, lpszEntryName, cbEntryName);
	}else {
		return INET_DLL_FAILURE;
	}
}

HRESULT ATK_InetSetAutoDial(BOOL fEnable, LPCSTR lpszEntryName)
{
	if(INetCfgSetup()) {
		return (*fpSetAutoDial)(fEnable, lpszEntryName);
	}else{
		return INET_DLL_FAILURE;
	}
}

HRESULT ATK_InetConfigSystem( HWND hwndParent,
							 DWORD dwfOptions,
							 LPBOOL lpfNeedsRestart)
{
	if(INetCfgSetup()) {
		return (*fpInetConfig)( hwndParent,dwfOptions, 
			lpfNeedsRestart);
	}else{
		return INET_DLL_FAILURE;
	}

}

HRESULT ATK_InetGetProxy( LPBOOL lpfEnable,
						  LPSTR  lpszServer,
						  DWORD  cbServer,
						  LPSTR  lpszOverride,
						  DWORD  cbOverride)
{
	if(INetCfgSetup()) {
		return (*fpGetProxy)( lpfEnable,
						  lpszServer,
						  cbServer,
						  lpszOverride,
						  cbOverride);
	}else{
		return INET_DLL_FAILURE;
	}


}



void GetAutoDialConfiguration()
{

	DWORD dwError;
	DWORD dwSz=256;
	HRESULT  hr;
	ISPState *pS= &gIspState; 
	hr = ATK_InetGetAutoDial(&pS->fStatus,
		pS->szActiveConnection,
		dwSz);
	if(hr) {
		dwError = GetLastError();

		RW_DEBUG << "\nGet AutoDial :***Error " <<hr  << ":"<<  dwError << flush;
		pS->iState = ISPState::NotValidState;
	}else {
		pS->iState = ISPState::ValidState;
	}
	
}

DWORD SetAutoDialStateThread(void *vp)
{
	ISPState  *pState;
	pState = (ISPState *) vp;
	ATK_InetSetAutoDial(pState->fStatus,
		pState->szActiveConnection);
	RW_DEBUG <<"\nSet Auto Dial Configuration" << pState->szActiveConnection << " =>" << pState->fStatus << flush;
	ExitThread(0);
	return 0;

}

//
//  This function calls the ICW function InetSetAutoDial()
//  this function waits for the above function to be over by 10 seconds 
//  if it does not complete then it calls terminate thread and abondens the operation 
int ChangeInterNetAutoDial(ISPState *pStatus )
{
	int iReturn;
	DWORD dwTimeOut = 10*1000;
	DWORD dwCreationFlags=0; // Start without  CREATE_SUSPENDED 
	DWORD ThreadId;
	
	iReturn = NO_ERROR;

	HANDLE hParent = CreateThread(NULL, 
	0,
	(LPTHREAD_START_ROUTINE) SetAutoDialStateThread,
	(void *) pStatus,
	dwCreationFlags, 
	&ThreadId );
	iReturn = NO_ERROR;

	DWORD dwRet = WaitForSingleObject(hParent,
		dwTimeOut);
	switch(dwRet) {
	case WAIT_ABANDONED :
		break;
	case WAIT_OBJECT_0 :
		CloseHandle(hParent);
		break;
	case WAIT_TIMEOUT :
		//TerminateThread(hParent,0);
		iReturn = ERROR_IN_SET;
		break;
	default:
		break;
	}
	return iReturn;
	

}


int ResetAutoDialConfiguration()
{
	int iRet;
	iRet = NO_ERROR;
	if(gIspState.iState == ISPState::NotValidState ){
		//
		// Not alid So No need to Reset 
		return iRet;
	}
	return ChangeInterNetAutoDial(&gIspState);
}

int DisableAutoDial()
{
	ISPState  IspState = { "",
						0,
						ISPState::NotValidState};
	
	return ChangeInterNetAutoDial(&IspState);
}

void UnLoadInetCfgLib()
{
	if(hINetCfg){
		FreeLibrary(hINetCfg);  //  Load INetCfg.DLL and store globally
		hINetCfg = NULL;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\connect.cpp ===
//#define STRICT
//   Include Files
//
#include <tchar.h>
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
//#include <wininet.h>
#include  <ATKInternet.h>

#include "rwpost.h"
#include "rw_common.h"

#ifdef _DEBUG
#include <iostream.h>
#endif



static void _stdcall  myCallback(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
	);

//
// returns
// #define  RWZ_SITE_CONNECTED   1
// #define  RWZ_FAIL_TOCONNECTTOSITE  0
// #define  RWZ_SITE_REQUIRES_AUTHENTICATION 2
//
DWORD   ChkSiteAvailability( HWND hwndProxyParent, LPCTSTR szIISServer,DWORD   dwTimeOut,LPTSTR szProxyServer ,LPTSTR	szUserName,
				LPTSTR  szPassword)
				
{
	DWORD						dwRet ;
	DWORD						dwLen=1024;
	DWORD						dwAccessType ;
	HANDLE						hEvent;		
	HINTERNET					hSession;
	HINTERNET					hConnect;
	HINTERNET					hHttpFile;
	INTERNET_STATUS_CALLBACK	hI;
	char  bufQuery[32]="" ;

	DWORD dwbufQuery;
	DWORD dwLengthBufQuery;
	BOOL bQuery;

	// Date : 2/4/98
	// The below var are added for incorporatinf IE Auth Dlg
	// We are changing the Connectivity Check Via Proxy using
	// INTERNET_OPEN_PRECONFIG
	DWORD	dwProxyAuthError; // Store error returned by InternetErrorDlg
	LPTSTR  pUserName;
	LPTSTR  pPassword;
	LPTSTR  pProxyServerName;


	
	pUserName		 =_T("");
	pPassword		 =_T("");
	pProxyServerName =NULL;
	

	if(_tcscmp(szProxyServer,_T(""))){
		dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
	}else{
		dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
	}

	#ifdef _DEBUG
		RW_DEBUG << "\nServer   is :" << ConvertToANSIString(szIISServer) <<"\n" <<flush;
		RW_DEBUG << "\nTimeout  is :" << dwTimeOut <<"\n" <<flush;
		if(_tcscmp(szProxyServer,_T(""))){
			RW_DEBUG << "Proxy    is :" << ConvertToANSIString(szProxyServer) <<"\n" <<flush;
		}else{
			RW_DEBUG << "Proxy    is : NULL" <<"\n" <<flush;
		}
	#endif
	
	hSession = ATK_InternetOpen	(	_T("Registration Wizard"),
										dwAccessType,
						                pProxyServerName,
										NULL, // List of Addesss to ByPass
										INTERNET_FLAG_ASYNC
				   					);

	if (hSession == NULL){
		dwRet = RWZ_FAIL_TOCONNECTTOSITE;
		#ifdef _DEBUG
			RW_DEBUG << "InternetOpen Failed\n" << flush;
		#endif
		return dwRet;
	}
    hConnect = ATK_InternetConnect(	hSession,
									szIISServer,
									INTERNET_INVALID_PORT_NUMBER,
									pUserName,
									pPassword,
									INTERNET_SERVICE_HTTP,
									0,
									1
								   );
	if(hConnect == NULL){
		::InternetCloseHandle(hSession);
		#ifdef _DEBUG
		RW_DEBUG << "InternetConnect Failed\n" << flush;
		#endif
		dwRet = RWZ_FAIL_TOCONNECTTOSITE;
		return dwRet;
	}
	hEvent		= CreateEvent(NULL, FALSE,FALSE,_T("HTTPConnect"));
	hHttpFile	= ATK_HttpOpenRequest(	hConnect,
										_T("GET"),
										_T("/register.asp"),	
										HTTP_VERSION,
										NULL,
										0,
										INTERNET_FLAG_DONT_CACHE,
										(DWORD_PTR)hEvent
										);
	if (hHttpFile == NULL){
	#ifdef _DEBUG
			RW_DEBUG << "HttpOpenRequest Failed\n" << flush;
	#endif
		dwRet =  RWZ_FAIL_TOCONNECTTOSITE;
		CloseHandle(hEvent);
		::InternetCloseHandle(hConnect);
		::InternetCloseHandle(hSession);
		return dwRet;
	}
	//
	// Http Open is Success so continue further
	hI = InternetSetStatusCallback(hHttpFile,myCallback);
	BOOL bSendRequest = ATK_HttpSendRequest(hHttpFile, NULL, 0, 0, 0);
	DWORD dwWaitStatus = WaitForSingleObject(hEvent,dwTimeOut) ;
	// Time out Error
	if( dwWaitStatus == WAIT_TIMEOUT ){
		#ifdef _DEBUG
		RW_DEBUG << "Timeout Happened\n" << flush;
		#endif
		RW_DEBUG << "Timeout Happened\n" << flush;
		dwRet = RWZ_FAIL_TOCONNECTTOSITE;
		goto FinishFn;
	}
	if(dwWaitStatus == WAIT_FAILED){
	#ifdef _DEBUG
		RW_DEBUG << "WAIT_FAILED returned from WaitForSingleObject\n" << flush;
	#endif
		dwRet = RWZ_FAIL_TOCONNECTTOSITE;
		goto FinishFn;
	}

	dwLengthBufQuery = sizeof (dwbufQuery);
	//DWORD dwLengthBufQuery = sizeof ( bufQuery);
	bQuery = ATK_HttpQueryInfo(	hHttpFile,
										HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
										//HTTP_QUERY_CONTENT_DESCRIPTION ,
										//HTTP_QUERY_CONTENT_LENGTH ,
										&dwbufQuery,
										//bufQuery ,
				                        &dwLengthBufQuery,
										NULL) ;
	RW_DEBUG << "\nChecking Connection  To Site  via Proxy Returns[" << dwbufQuery << "]" <<flush;
	switch(dwbufQuery) {
		case HTTP_STATUS_OK:
		case HTTP_STATUS_SERVICE_UNAVAIL:
		dwRet = RWZ_SITE_CONNECTED;
		break;
		case HTTP_STATUS_PROXY_AUTH_REQ:
		// Invoking the IE Proxy Server Authentication Dialog
				dwProxyAuthError = 	InternetErrorDlg(hwndProxyParent,hHttpFile,
				ERROR_INTERNET_INCORRECT_PASSWORD,
				FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
				NULL);
				RW_DEBUG << "\nInetErrorDialog REturns " << dwProxyAuthError << flush;
				dwRet = RWZ_SITE_REQUIRES_AUTHENTICATION;
				//
				// We are not checking  for the return value because
				// connection has to be reestablished to really check
				// the info provided is valid
				/**
				02/07/98
				switch (dwProxyAuthError) {
					case ERROR_SUCCESS:
						dwRet = RWZ_SITE_CONNECTED;
						break;
					case ERROR_CANCELLED :
					case ERROR_INTERNET_FORCE_RETRY:
						dwRet = RWZ_SITE_REQUIRES_AUTHENTICATION;
						default:
						break;
					}
					**/
			break; // End of Proxy Auth
		case 0:
		case HTTP_STATUS_SERVER_ERROR:
			dwRet = RWZ_FAIL_TOCONNECTTOSITE;
			RW_DEBUG << "\n Problem in Proxy Server With connection Via Proxy " << dwbufQuery << flush;
			break;
		default:
		dwRet = RWZ_SITE_CONNECTED;
		break;	
	}			

FinishFn :
	CloseHandle(hEvent);
	::InternetCloseHandle(hHttpFile);
	::InternetCloseHandle(hConnect);
	::InternetCloseHandle(hSession);
	return dwRet;
}

void _stdcall myCallback(
						    IN HINTERNET hInternet,
						    IN DWORD_PTR dwContext,
						    IN DWORD dwInternetStatus,
						    IN LPVOID lpvStatusInformation OPTIONAL,
						    IN DWORD dwStatusInformationLength
						)
{

switch(dwInternetStatus)
	{
	case INTERNET_STATUS_RESOLVING_NAME :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: RESOLVING_NAME\n" << flush;
#endif //_DEBUG
		 break;
	case INTERNET_STATUS_NAME_RESOLVED :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_NAME_RESOLVED\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_CONNECTING_TO_SERVER :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTING_TO_SERVER\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_CONNECTED_TO_SERVER :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTED_TO_SERVER\n" << flush;
#endif //_DEBUG
		 //::InternetCloseHandle(hInternet);
 		 break;

	case INTERNET_STATUS_SENDING_REQUEST :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_SENDING_REQUEST\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_REQUEST_SENT :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_REQUEST_SENT\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_RECEIVING_RESPONSE :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_RECEIVING_RESPONSE\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_RESPONSE_RECEIVED :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_RESPONSE_RECEIVED\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_REDIRECT :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_REDIRECT\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_CLOSING_CONNECTION :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_CLOSING_CONNECTION\n" << flush;
#endif //_DEBUG
		 break;

	case INTERNET_STATUS_CONNECTION_CLOSED :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTION_CLOSED\n" << flush;
#endif //_DEBUG
		 break;
	case INTERNET_STATUS_HANDLE_CREATED :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_HANDLE_CREATED\n" << flush;
#endif //_DEBUG
		 break;
	case INTERNET_STATUS_REQUEST_COMPLETE :

#ifdef _DEBUG
		 RW_DEBUG << "\nCallback: INTERNET_STATUS_REQUEST_COMPLETE\n\n" << flush;

		 INTERNET_ASYNC_RESULT *x;
		 x = (INTERNET_ASYNC_RESULT *)lpvStatusInformation;
		 if(x->dwError == ERROR_SUCCESS)
		 {
			RW_DEBUG << "\nERROR_SUCCESS\n" << flush;
		 }
		 else
		 {
			RW_DEBUG << "\nERROR \ndwResult: " << (DWORD)x->dwResult <<flush;
		 }

		 if(dwStatusInformationLength == ERROR_INTERNET_EXTENDED_ERROR)
		 {
			RW_DEBUG << "\n-NO EXTENDED_ERROR\n" << flush;
		 }
			DWORD dwError;
			DWORD dwErrorLen;
			_TCHAR szErrorInfo[256];	
			dwErrorLen = 256;
			
			ATK_InternetGetLastResponseInfo(&dwError,szErrorInfo,&dwErrorLen) ;
			RW_DEBUG << "\nErrorNo:" << dwError ;
			RW_DEBUG << "\nErrorInfo:"<<szErrorInfo<<flush;
			RW_DEBUG << "\n\n" << flush;
#endif //_DEBUG
			
		 SetEvent((HANDLE)dwContext);
		 break;
	case INTERNET_STATUS_HANDLE_CLOSING :

#ifdef _DEBUG
			 RW_DEBUG << "\nCallback: INTERNET_STATUS_HANDLE_CLOSING\n" << flush;
#endif //_DEBUG
		 SetEvent((HANDLE)dwContext);
		 break;
#ifdef _DEBUG
	default :
		 RW_DEBUG <<"\n Callback : default " << flush;
#endif //_DEBUG

	}
}

#if  0
void main(int argc , char ** argv)
{

	if(argc < 2 )
	{
		RW_DEBUG << "\n\n\nThe Executable Requires the following parameters : \n" << endl;
		RW_DEBUG << " \t\tServer Name \n\t\tTimeout value \n\t\tProxyServer name\n\t\tUserName \n\t\tPassword\n\n" << endl;
		RW_DEBUG << "Following Parameters are mandatory\n\t\tServer Name \n\t\tTimeout value \n" << endl;
		return;
	}
	BOOL bRet = ChkSiteAvailability(	argv[1],atol(argv[2]),
			argv[3],argv[4],argv[5]	);

	if(bRet == TRUE)
	{
		RW_DEBUG << "Returned TRUE" << flush;
	}
	else
	{
		RW_DEBUG << "Returned FALSE" << flush;
	}

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\ithread.h ===
#ifndef __InternetThread_h__
#define __InternetThread_h__

#include "ATKinternet.h"
//#include <tchar.h>



//  CInternetThread Class...manages worker thread which POSTS to 
//	Register.msn.com.
//
class CInternetThread
{
public:
   // Construction
   //
   CInternetThread();
   ~CInternetThread();



   // Re-initialized Internet functions. Used after changing access type.
   //
   void ResetSession();
      
   // Manage Buffer where HTML text is placed.
   //
	LPCSTR		GetBuffer()		{	return m_strBuffer; }
	void		SetBuffer(LPSTR strBuffer);
	void		SetBuffer(LPSTR strBuffer, DWORD dwLen);
	DWORD  PostData(HWND hWnd);

	void Initialize(HINSTANCE hIns)
	{
		m_hInstance = hIns;
		m_strIISServer = new TCHAR[256];
		m_strPath      = new TCHAR[256];
		m_UserName     = new TCHAR[256];
		m_Password     = new TCHAR[256];
		m_bPostWithSSL = TRUE;

		LoadString(m_hInstance, IDS_HTTP_SERVER,
			m_strIISServer, 255);
		LoadString(m_hInstance, IDS_HTTP_SERVER_PATH,
			m_strPath, 255);
		LoadString(m_hInstance, IDS_HTTP_USERNAME,
			m_UserName, 255);
		LoadString(m_hInstance, IDS_HTTP_PASSWORD, 
			m_Password, 255);
	}

	//
	//
	void SetHInstance ( HINSTANCE hIns) 
	{
			m_hInstance = hIns;
		//Initialize(hIns);
	}

	HINSTANCE GetHInstance ()
	{  
		return m_hInstance;
	}

	// Proxy Server name.
	//
	BOOL GetSystemProxyServer(  PCHAR szProxy, 
								DWORD dwBufferLength,
								int *ipProxyPort);
	// This gets proxy using ICW call 
	LPCTSTR GetProxyServer()	{	return m_strProxyServer; }
	void SetProxyServer(LPSTR strProxyServer, int iProxyPort);
	void GetSystemProxySettings( PCHAR szProxy, 
							   DWORD dwBufferLength);
	void SetSystemProxySettings( PCHAR szProxy ); 
   // HTTP Server name.
   //
	LPCTSTR GetIISServer()		{	return m_strIISServer; }
	void SetIISServer(LPTSTR strIISServer);

   // HTTP Server Path
   //
	LPCTSTR GetServerPath()		{	return m_strPath; }
	void SetServerPath(LPTSTR strPath);
	
	void SetSSLFlag(BOOL bFlag)	{	m_bPostWithSSL = bFlag;}
	
   // POST the Data in m_strBuffer into 
   //
   //DWORD  PostData(HWND hWnd);

   // Access Type: **** At present Not used  ***
   //
   //int	GetAccessTypeIndex();
   //void SetAccessTypeIndex(int index);

   //
   // General ICW DLL loading  related functions
   HINSTANCE LoadInetCfgDll();
   BOOL InstallModem(HWND hwnd);
   void UnLoadInetCfgDll(); 
//private:
   // Worker thread calls _PostDataWorker.
   static UINT PostDataThread(LPVOID pvThread) ;

   // This is where the actually work is done.
   UINT  _PostDataWorker(HWND hWnd);
   UINT	 GetBackEndResult(HINTERNET hConnect);


   LPTSTR	m_strIISServer;
   LPTSTR	m_strPath;
   LPTSTR	m_strProxyServer;
   DWORD	m_dwAccessType;
   BOOL		m_bPostWithSSL;

  
   LPSTR	 m_strBuffer;		// Buffer to be POSTed to Register.msn.com
   DWORD	 m_dwBufferLen;		// Buffer Len
   HINSTANCE m_hInstance;
   HINTERNET m_hSession;
   LPTSTR    m_UserName;
   LPTSTR    m_Password;
   HINSTANCE m_hICWDllInstance;
};

// Working Thread which does all the actually internet work.
//
UINT PostDataThread(LPVOID pvThreadData);
#endif 


// How to use this class
// 
//
////////// Check if connectivity to a an IIS exists //////////////////////
// i)  Call CInternetThread.SetProxyServer(szProxy) to set the Proxy if any exists.
// ii) Call CInternetThread.SetIISServer(szIISServer) to set the IP Address (URL)
//	   of the Internet Server.
// iii)Call CInternetThread.InternetConnectivityExists() which will return TRUE
//    if connectivity to the ISS server (szIISServer in 1) exists, else FALSE.
//
//
///////// Perform an HTTP Post to an IIS ////////////////////////////////
// i)  Call CInternetThread.SetProxyServer(szProxy) to set the Proxy if any exists.
// ii) Call CInternetThread.SetIISServer(szIISServer) to set the IP Address (URL)
//	   of the Internet Server.
// iii)Call CInternetThread.InternetConnectivityExists() which will return TRUE
//     if connectivity to the ISS (szIISServer in 1) exists, else FALSE.
// iv) Call CInternetThread.SetBuffer(szBuffer) to set the Data that has to be
//	   POSTed of the Internet Server.
// v)  Call CInternetThread.PostData() which will return TRUE, if the Data has been
//	   POSTed successfully to the IIS.
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\phonebk.h ===
#ifndef _PHONE_BOOK_
#define _PHONE_BOOK_
#include "phbk.h"
#ifdef __cplusplus
extern "C" {
#endif

DllExportH PhoneBookLoad(LPCSTR pszISPCode, DWORD_PTR far *pdwPhoneID);
DllExportH PhoneBookSuggestNumbers(DWORD_PTR dwPhoneID, PSUGGESTINFO lpSuggestInfo);
DllExportH PhoneBookDisplaySignUpNumbers (DWORD_PTR dwPhoneID,
														LPSTR far *ppszPhoneNumbers,
														LPSTR far *ppszDunFiles,
														WORD far *pwPhoneNumbers,
														DWORD far *pdwCountry,
														WORD far *pwRegion,
														BYTE fType,
														BYTE bMask,
														HWND hwndParent,
														DWORD dwFlags);


#ifdef __cplusplus
			}
#endif

#endif	// _PHONE_BOOK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\phone.cpp ===
/*

	File : Phone.CPP
*/

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <tchar.h>
#include <ATK_RAS.H>

#include "cntryinf.h"
#include "resource.h"
#include "phonebk.h"
#include "util.h"
#include "rw_common.h"


#define TYPE_SIGNUP_ANY			0x82
#define MASK_SIGNUP_ANY			0xB2

#define TYPE_REGULAR_USAGE		0x42
#define MASK_REGULAR_USAGE		0x73


#define MAX_BUFFER				1024 * 5
#define RAS_ENTRY_NAME			_T("REGWIZ")



//
//  This function expands and substitutes Environment variable
//  in input string
//
//
static void GetAbsolutePath( LPTSTR input,LPTSTR output)
	{
		if(_tcschr(input,_T('%')) == NULL) {
			_tcscpy(output,	input);
			return ;
		}

		if(input[0] == _T('%'))
		{
			LPTSTR token = _tcstok(input,_T("%"));
			if(token != NULL)
			{
				LPTSTR sztemp;
				sztemp = _tgetenv( token );
				if(sztemp != NULL)
				{
					_tcscpy(output ,sztemp);
				}
				token = _tcstok(NULL,_T("\0"));
				if(token != NULL)
				{
					_tcscat(output ,token);
				}
			}
		}
		else
		{
			LPTSTR token = _tcstok(input,_T("%"));
			if(token != NULL)
			{
				_tcscpy(output ,token);
				token = _tcstok(NULL,_T("%"));
				if(token != NULL)
				{
					LPTSTR sztemp;
					sztemp = _tgetenv( token );
					if(sztemp != NULL)
					{
						_tcscat(output ,sztemp);
					}
					token = _tcstok(NULL,_T("\0"));
					if(token != NULL)
					{
						_tcscat(output ,token);
					}
				}
			}
		}
		
		GetAbsolutePath(output,output);
	}




#define MAX_ALTERNATES     5
#define MAX_DUN_ENTRYNAME  256
class DUNFileProcess {
public :
	DUNFileProcess(HINSTANCE hIns, TCHAR *czFile);
	//~DUNFileProcess();
	DWORD CreateRasEntry( RASENTRY	*pRasEntry, // Pointer of the RASENTRY structre to be created
				    LPTSTR szUserName,  // User name of the ISP
				    LPTSTR szPassword); // Password for the ISP

	HINSTANCE m_hInstance;
	TCHAR     m_szDUNFile[MAX_PATH];
	TCHAR     m_szDunEntry[MAX_ALTERNATES][MAX_DUN_ENTRYNAME];
	TCHAR * GetDunFileRoot();
	TCHAR * GetFromResource(int iResId);

};

DUNFileProcess :: DUNFileProcess (HINSTANCE hIns, TCHAR *czFileName)
{
	m_hInstance = hIns;
	_tcscpy(m_szDUNFile,GetDunFileRoot());
	_tcscat(m_szDUNFile, _T("\\"));
	_tcscat(m_szDUNFile,czFileName);
	
		
}



//
// This gets the directory from where the ICWIP.DUN can be found
// The default is the C:\Progra~1\ICW-IN~1\\
//
TCHAR * DUNFileProcess :: GetDunFileRoot()
{
	HKEY    hKey;
	LONG  regStatus;
	TCHAR   czTemp[256];
	//TCHAR  uszRegKey[]="SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE";
	//TCHAR  uszR[ ]= "Path";
	DWORD  dwInfoSize;
	static TCHAR  szDunRoot[256] = _T("c:\\Progra~1\\ICW-IN~1\\");

	dwInfoSize = 256;
	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					GetFromResource(IDS_ICW_DIRECTORY_ENTRY),
					0,KEY_READ ,&hKey);
	if (regStatus == ERROR_SUCCESS) {
		// Get The Path
		dwInfoSize = MAX_PATH;
		RegQueryValueEx(hKey,
			GetFromResource(IDS_ICW_DIRECTORY_ENTRY_VALUE),
			NULL,0,
			(LPBYTE) czTemp,
			&dwInfoSize);
		GetAbsolutePath(czTemp,szDunRoot);
		size_t sLen = _tcslen(szDunRoot);
		szDunRoot[sLen-1] = _T('\0');
			
	}
	else {
		;
	}
	return szDunRoot;

}

TCHAR * DUNFileProcess ::GetFromResource(int iResId)
{
	
	
	static int iCount=0;
	if(iCount == MAX_ALTERNATES ) {
		iCount = 0;
	}
	LoadString(m_hInstance,iResId,m_szDunEntry[iCount],
		MAX_DUN_ENTRYNAME);
	
	return m_szDunEntry[iCount++];
}

void FillIpAddress1(_TCHAR *czStr, RASIPADDR * pRE )
{
	
	_TCHAR czTemp[4];
	int iCount=0;
	int iIndex=0;
	int Location =0;
	for(int Addr=0; Addr< 4; Addr++) {
		iCount = 0;
		for( ;czStr[iIndex] !=_T('.') && iCount <3;  )
		{
			czTemp[iCount] = czStr[iIndex];
			iCount += _tcslen( czTemp + iCount );
			iIndex += _tcslen( czStr + iIndex );

		}	
		iIndex += _tcslen( czStr + iIndex );
		czTemp[iCount] = _T('\0');
		
		switch(Addr) {
		case 0:
			pRE->a = (BYTE) _ttoi(czTemp);
			break;
		case 1:
			pRE->b = (BYTE) _ttoi(czTemp);
			break;
		case 2:
			pRE->c = (BYTE) _ttoi(czTemp);
			break;
		case 3:
			pRE->d = (BYTE) _ttoi(czTemp);
			break;
		default:
		break;
		}
	}


}


void FillIpAddress(_TCHAR *czStr, RASIPADDR * pRE )
{
	_TCHAR czTemp[4];
	int iCount=0;
	int iIndex=0;
	int Location =0;
	for(int Addr=0; Addr< 4; Addr++) {
		iCount = 0;
		for( ;czStr[iIndex] != _T('.') && iCount <3;  ) {
			czTemp[iCount++] =
				czStr[iIndex];
				iIndex++;

		}	
		iIndex++;
		czTemp[iCount] = _T('\0');
		switch(Addr) {
		case 0:
			pRE->a = (BYTE) _ttoi(czTemp);
			break;
		case 1:
			pRE->b = (BYTE) _ttoi(czTemp);
			break;
		case 2:
			pRE->c = (BYTE) _ttoi(czTemp);
			break;
		case 3:
			pRE->d = (BYTE) _ttoi(czTemp);
			break;
		default:
		break;
		}
	}


}






//
// Returns  1 if successful
//          0 failure
//
DWORD DUNFileProcess :: CreateRasEntry(
								   RASENTRY	*pRasEntry,
								   LPTSTR szUserName,
								   LPTSTR szPassword)
{
	TCHAR	szSection[MAX_PATH];
    TCHAR	szValue[MAX_PATH];
    TCHAR   szScript[MAX_PATH];
    TCHAR   szWinPath[MAX_PATH];
	DWORD   dwRead;

	BOOL	bRet= FALSE;

	pRasEntry->dwSize		 = sizeof(RASENTRY);

	pRasEntry->dwfOptions	 = RASEO_UseCountryAndAreaCodes |
							   RASEO_ModemLights;	
							


	// Framing
	//
	pRasEntry->dwFrameSize		  = 0;
	_tcscpy(pRasEntry->szScript, _T(""));

	// Auto-Dial
	//
	_tcscpy(pRasEntry->szAutodialDll, _T(""));
	_tcscpy(pRasEntry->szAutodialFunc, _T(""));

	// Device
	//
	_tcscpy(pRasEntry->szDeviceType, RASDT_Modem);
	// _tcscpy(pRasEntry->szDeviceName, GetModemDeviceInformation(m_hInstance));
	// The Modem entry will be created before creating  the Phone book entry

	// X.25
	//
	_tcscpy(pRasEntry->szX25PadType, _T(""));
	_tcscpy(pRasEntry->szX25Address, _T(""));
	_tcscpy(pRasEntry->szX25Facilities, _T(""));
	_tcscpy(pRasEntry->szX25UserData, _T(""));
	pRasEntry->dwChannels = 0;

	// Phone
	//
	_tcscpy(szSection,GetFromResource(IDS_DUN_PHONE_SECTION));
	
	// Area Code
    DWORD  dwAreaCode  = GetPrivateProfileInt (szSection,
		GetFromResource(IDS_DUN_PHONE_AREACODE),
		0,
		m_szDUNFile);
	_tprintf(pRasEntry->szAreaCode, "%d", dwAreaCode);
	
	// Country Code
	pRasEntry->dwCountryCode = GetPrivateProfileInt (szSection,
		GetFromResource(IDS_DUN_PHONE_COUNTRY),
		1, m_szDUNFile);
    RW_DEBUG <<"\n Country Code "  << pRasEntry->dwCountryCode;
	pRasEntry->dwCountryID = GetPrivateProfileInt (szSection, _T("Country_ID"), 1, m_szDUNFile);

    RW_DEBUG <<"\n Country ID "  << pRasEntry->dwCountryID;
	//
	GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_PHONE_DIALAS),
		GetFromResource(IDS_DUN_VALUE_YES),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	pRasEntry->dwAlternateOffset=0;

	// TODO : Set Phone No from  Phone Book
	_tcscpy(pRasEntry->szLocalPhoneNumber,_T(""));
	
	// Server
	//	

	// Framing Protocol
	_tcscpy(szSection,GetFromResource(IDS_DUN_SERVER_SECTION));
    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_SERVER_TYPE),
		GetFromResource(IDS_DUN_SERVER_TYPE_PPP), // PPP
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);

	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_SERVER_TYPE_PPP))) {
		pRasEntry->dwFramingProtocol  = RASFP_Ppp;
	}


	// SW Compression
    GetPrivateProfileString (szSection,GetFromResource(IDS_DUN_SERVER_SW_COMPRESS),
		GetFromResource(IDS_DUN_VALUE_YES),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);

	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions |=RASEO_SwCompression;
	}
	
	//	Negociate TCP		
    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_SERVER_TCPIP),
		GetFromResource(IDS_DUN_VALUE_YES),
		 szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);

	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfNetProtocols = RASNP_Ip;
	}

	// Disable LCP

    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_SERVER_LCP),
		GetFromResource(IDS_DUN_VALUE_YES),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions |=RASEO_DisableLcpExtensions;
	}


	// TCP/IP
	_tcscpy(szSection, GetFromResource(IDS_DUN_TCP_SECTION));
    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_IPADDRESS),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);

	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions	 |=RASEO_SpecificIpAddr;
	}

    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_SERVERADDRESS),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions	 |=RASEO_SpecificNameServers;
	}

    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_HEADERCOMPRESSION),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions	 |=RASEO_IpHeaderCompression;
	}

    GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_GATEWAY),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {
		pRasEntry->dwfOptions	 |=RASEO_RemoteDefaultGateway;
	}

	GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_TCP_SERVERADDRESS),
		GetFromResource(IDS_DUN_VALUE_NO),
		szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
	if(!_tcsicmp(szValue,GetFromResource(IDS_DUN_VALUE_YES))) {

		dwRead = GetPrivateProfileString (szSection,
			GetFromResource(IDS_DUN_TCP_DNS),
			_T("0"), szValue,
			sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
		if( dwRead >2) {
			FillIpAddress(szValue,&pRasEntry->ipaddrDns);
		}
		//
		//  Get The Secondary Address
		dwRead = GetPrivateProfileString (szSection,
				GetFromResource(IDS_DUN_TCP_DNS_ALT),
				_T("0"), szValue,
			sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
		if(dwRead > 2) {
			FillIpAddress(szValue,&pRasEntry->ipaddrDnsAlt);
		}
		
	}

	// User Section
	_tcscpy(szSection,
		GetFromResource(IDS_DUN_USER_SECTION));
	GetPrivateProfileString (szSection,
	GetFromResource(IDS_DUN_USER_NAME),
		_T(""), szUserName, MAX_PATH, m_szDUNFile);
	GetPrivateProfileString (szSection,
		GetFromResource(IDS_DUN_USER_PASSWORD),
		_T(""), szPassword, MAX_PATH, m_szDUNFile);



	// Scripting
	_tcscpy(szSection, _T("Scripting"));
    GetPrivateProfileString (szSection, _T("Name"), _T(""), szScript, MAX_PATH, m_szDUNFile);


    if ( lstrcmpi(szScript, _T("") ) != 0 ) {
       if (!GetWindowsDirectory(szWinPath, MAX_PATH) )
       {
          #ifdef _LOG_IN_FILE
            RW_DEBUG << "\n CreateRasEntry : Error 1- Fail to Get Windows Directory" << flush;
          #endif
          return TRUE;    
       }
       //APPCOMPAT:Needs specail procesing for win9x
       if ( _T('\\') != szWinPath[_tcslen(szWinPath)-1])
       {
           lstrcat(szWinPath,_T("\\"));
       }
       lstrcat(szWinPath,szScript);
       lstrcpy(szScript,szWinPath);
       if (_tcslen(szScript) >=MAX_PATH)
       {
           #ifdef _LOG_IN_FILE
			  RW_DEBUG << "\n CreateRasEntry : Error 1- Script File Path too long" << flush;
		   #endif
           return TRUE;    
       }

    }

    lstrcpy(pRasEntry->szScript,szScript);    

	// Script_File
	TCHAR	szScriptBuffer[MAX_BUFFER];
	_tcscpy(szSection, _T("Script_File"));
    GetPrivateProfileString (szSection, NULL, _T(""), szScriptBuffer, MAX_BUFFER, m_szDUNFile);
	


	
	// Create the .SCP File and Dump the script data
	PTSTR	pKey=szScriptBuffer;
	HANDLE fileHandle = CreateFile(pRasEntry->szScript, GENERIC_WRITE,0, 0, CREATE_ALWAYS, 0, 0);
	if (fileHandle == INVALID_HANDLE_VALUE)
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Load DUN Strings : Error 1- Fail to create Script File " << flush;
		#endif
		return TRUE;
	}
	

	BOOL bWrite = TRUE;
	DWORD numWrite;
	while (*pKey && bWrite)
	{
        
		GetPrivateProfileString (szSection, pKey , _T(""), szValue, sizeof(szValue)/sizeof(TCHAR), m_szDUNFile);
        _tcscat(szValue, _T("\x0d\x0a"));
#ifdef _UNICODE 
        char *czP;		
        czP = ConvertToANSIString(szValue);
        bWrite = WriteFile(fileHandle, czP, strlen(czP)*sizeof(char), &numWrite, 0);
#else
        bWrite = WriteFile(fileHandle, szValue, _tcslen(szValue)*sizeof(_TCHAR), &numWrite, 0);
#endif
		while (*pKey)
		{
			pKey = _tcsinc(pKey);
		}
		pKey = _tcsinc(pKey);
	}
	CloseHandle(fileHandle);
	return TRUE;
}	

int   GetDeaultCfgAreaCode(HINSTANCE hInstance, DWORD *CountryCode, DWORD *AreaCode)
{
	HKEY    hKey;
	TCHAR   szTel[256] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations");
	TCHAR   szCI [48] = _T("CurrentID");
	TCHAR   szNE [48]  = _T("NumEntries");
	TCHAR   szID  [48] = _T("ID");
	TCHAR   szCountryReg[48] = _T("Country");
	_TCHAR  szAreaCodeReg[48];
	_TCHAR  czLastStr[48];
	_TCHAR  czNewKey[256];
	_TCHAR  szAreaCode[48];
	DWORD   dwCurrentId;
	DWORD   dwNumEntries;
	DWORD   dwId;

	LONG	lStatus;
	DWORD dwInfoSize = 48;
	DWORD   dwAreaCode = 0;
	int    iRetValue;
	iRetValue =0;
	*CountryCode=1;  // Default USA
	*AreaCode = 1; // Default Area Code

	LoadString(hInstance,IDS_TELEPHONE_LOC,szTel,256);
	LoadString(hInstance,IDS_TELEPHONE_CID,szCI,48);
	LoadString(hInstance,IDS_TELEPHONE_NENT,szNE,48);
	LoadString(hInstance,IDS_TELEPHONE_ID,szID,48);
	LoadString(hInstance,IDS_TELEPHONE_COUNTRY,szCountryReg,48);

	lStatus= RegOpenKeyEx(HKEY_LOCAL_MACHINE,szTel,0,KEY_READ,&hKey);
	if (lStatus == ERROR_SUCCESS)
	{
		//  Get Index
		//
		dwInfoSize = sizeof(dwCurrentId);
		lStatus = RegQueryValueEx(hKey,szCI,NULL,0,(  LPBYTE )&dwCurrentId,&dwInfoSize);
		if( lStatus !=  ERROR_SUCCESS)
		{
			RegCloseKey(hKey);
			return iRetValue;
		}
		//
		/*dwInfoSize = sizeof(dwNumEntries);
		lStatus = RegQueryValueEx(hKey,szNE,NULL,0,(  LPBYTE )&dwNumEntries,&dwInfoSize);
		if( lStatus !=  ERROR_SUCCESS)
		{
			RegCloseKey(hKey);
			return iRetValue;
		}*/
		
		RegCloseKey(hKey);

	}

	//
	// Now Contine to scan
	//for (int iCount =0; iCount < dwNumEntries; iCount ++ )
		
	_stprintf(czLastStr,_T("\\Location%d"),dwCurrentId);
	_tcscpy(czNewKey,szTel);
	_tcscat(czNewKey,czLastStr);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n RegKey Location:"<< czNewKey << flush;
	#endif

	lStatus= RegOpenKeyEx(HKEY_LOCAL_MACHINE,czNewKey,0,KEY_READ,&hKey);

	if (lStatus == ERROR_SUCCESS)
	{
			dwInfoSize = sizeof(dwCurrentId);
/*			lStatus = RegQueryValueEx(hKey,szID,NULL,0,(  LPBYTE )&dwId,&dwInfoSize);
			if( lStatus ==  ERROR_SUCCESS)
				if(dwId == dwCurrentId)
					dwInfoSize = sizeof(dwCurrentId);; */
			lStatus = RegQueryValueEx(hKey,szCountryReg,NULL,0,(  LPBYTE )CountryCode,&dwInfoSize);

			LoadString(hInstance,IDS_TAPI_AREA_CODE,szAreaCodeReg,48);
			dwInfoSize = 48;
			lStatus = RegQueryValueEx(hKey,szAreaCodeReg,NULL,0,(  LPBYTE )szAreaCode,&dwInfoSize);
			if( lStatus ==  ERROR_SUCCESS)
			{
				*AreaCode = _ttol(szAreaCode);
			}

			RegCloseKey(hKey);
			return dwAreaCode;
	}
	return iRetValue;
}



//
//  returns 0 if Error
//          1 if Succesful
//
//
DWORD  GetRASEntries(HINSTANCE hInstance,
					 RASENTRY *pRasEntry,
					 LPTSTR szUserName,
					 LPTSTR szPassword)
{
	HKEY    hKey;
	DWORD_PTR	dwPhoneID;
	DWORD	dwCountry;
	DWORD   dwCountryCode;
	DWORD   dwAreaCode = 0;
	TCHAR   szResEntry[256];

	
	dwPhoneID = 0;

	//LoadString(hInstance,IDS_PHONEBOOK_ENTRY,szResEntry,255);
	//
	//  Presently this string is not passed as the Phone bokk is
	//  still not a UNICODE version    CXG 6-0497
	//

	HRESULT hr	= PhoneBookLoad("MSICW", &dwPhoneID);
	if (!dwPhoneID)
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Fn: GetRasEntries : Error-1 Unable to locate MSN.ISP " << flush;
		#endif
		return FALSE;
	}
	//if (!GetTapiCurrentCountry(m_hInst, &dwCountry)) { on6/4/97
	if (!GetTapiCurrentCountry(hInstance, &dwCountry))
	{

		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Fn: GetRasEntries : Error-2  Unable To Get Country Code " << flush;
		#endif
		return FALSE ;
	}
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Fn: GetRasEntries : Get Current Country " <<  dwCountry << flush;
	#endif

	GetDeaultCfgAreaCode(hInstance,&dwCountryCode,&dwAreaCode);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Fn: GetRasEntries : GetDeaultCfgAreaCode  Country " <<  dwCountryCode << "Area " << dwAreaCode << flush;
		RW_DEBUG << "\n Country ID: " << dwCountry << flush;
	#endif

	SUGGESTINFO SuggestInfo;
	SuggestInfo.dwCountryID = dwCountry;
	SuggestInfo.bMask	= MASK_SIGNUP_ANY;
	SuggestInfo.fType	= TYPE_SIGNUP_ANY;
	SuggestInfo.wAreaCode	= dwAreaCode;
	SuggestInfo.wNumber  	= 1;
	
	int nIndex = PhoneBookSuggestNumbers(dwPhoneID, &SuggestInfo);
	if (nIndex != 0)
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Fn: GetRasEntries : Error-3  In Phone Suggest Number" << flush;
		#endif
		return FALSE;
	}
	PACCESSENTRY m_rgAccessEntry = *(SuggestInfo.rgpAccessEntry);
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Fn: GetRasEntries : Phone Book Suggestions " << flush;
		RW_DEBUG << "\n\t Index " << m_rgAccessEntry->dwIndex ;
		RW_DEBUG << "\n\t Phone Number Type "  << m_rgAccessEntry->fType;
		RW_DEBUG << "\n\t StateId " << m_rgAccessEntry->wStateID;
		RW_DEBUG << "\n\t CountryId " << m_rgAccessEntry->dwCountryID;
		RW_DEBUG << "\n\t AreaCode "  <<  m_rgAccessEntry->dwAreaCode ;
		RW_DEBUG << "\n\t CityName " << m_rgAccessEntry-> szCity;
		RW_DEBUG << "\n\t Access Number " << m_rgAccessEntry->szAccessNumber;
		RW_DEBUG << "\n\t Actual Area Code "  << m_rgAccessEntry->szAreaCode << flush;
	#endif

	//BOOL FillRASEntries(RASENTRY	*pRasEntry);

	DUNFileProcess    dfp(hInstance,
		ConvertToUnicode(m_rgAccessEntry->szDataCenter));
	if(!dfp.CreateRasEntry(pRasEntry,szUserName,szPassword))
	{
		#ifdef _LOG_IN_FILE
		  RW_DEBUG << "\n GetRas Entries -Error 4 : Processinfg DUN File "  << flush;	
		#endif
		return FALSE;
	}
	pRasEntry->dwCountryID  = dwCountry;
	GetCountryCodeUsingTapiId(dwCountryCode,&dwCountryCode) ;
	pRasEntry->dwCountryCode  =dwCountryCode;

	_tcscpy(pRasEntry->szLocalPhoneNumber, ConvertToUnicode(m_rgAccessEntry->szAccessNumber));
	_tcscpy(pRasEntry->szAreaCode,ConvertToUnicode(m_rgAccessEntry->szAreaCode));

	RW_DEBUG << "\n Counntry ID " <<pRasEntry->dwCountryID  << " Country Code " << pRasEntry->dwCountryCode  << flush;

	RW_DEBUG << "\n AreaCode: " << ConvertToANSIString(pRasEntry->szAreaCode);
	RW_DEBUG << "Local No Real: " << m_rgAccessEntry->szAccessNumber << flush;
	RW_DEBUG << "Local No: " << ConvertToANSIString(pRasEntry->szLocalPhoneNumber) << flush;


	return TRUE;
}




DWORD ConfigureDUN ( HWND hWnd, HINSTANCE hInstance,
					 RASENTRY	*pRasEntry,
					 TCHAR	*szUserName,
					 TCHAR	*szPassword,
					 int        iModemIndex)
{
	
	DWORD dwEntrySize;
	DWORD dwRet;
	
	// Prepare RASENTRY for Dial-up
	//
	
	if(!GetRASEntries(hInstance,
		pRasEntry,
		szUserName,
		szPassword) )
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Fn : ConfigureDUN   : Error3  Error Getting Ras Entries " << flush;
		#endif
		return FALSE;
	}
	_tcscpy(pRasEntry->szDeviceName, GetModemDeviceInformation(hInstance, iModemIndex));

#ifdef _WIN95
	//
	//  remove Old entry
	//  Verify if name exists in Registry
	//  if so remove the name from Registry
	//
	//
	//
	HANDLE  hRegKey ;
	LONG regStatus;
	DWORD dwInfoSize;
	char  szParam[512];

	regStatus = RegOpenKeyEx(HKEY_CURRENT_USER,
					"RemoteAccess\\Addresses",0,
					KEY_READ,&hRegKey);
	if (regStatus == ERROR_SUCCESS)	{
		//  Key Exists  so search if REG WIZ exists
		dwInfoSize = 512;
		regStatus = RegQueryValueEx(hRegKey,RAS_ENTRY_NAME,NULL,0,
			(unsigned char*) szParam,&dwInfoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			// The Key Exits So delete the Entry
			RegDeleteValue(hRegKey,RAS_ENTRY_NAME);

			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\nRegistry Entry found  "  << RAS_ENTRY_NAME <<
				"  and Deleting the Entry "  <<  flush;
			#endif
			
		}
		 RegCloseKey(hRegKey);

	}
#else
	ATK_RasDeleteEntry(NULL,RAS_ENTRY_NAME);
#endif

	
	dwEntrySize  = sizeof(RASENTRY);
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\nAfter Ras Get Properties :";
		RW_DEBUG << "\n\t Device Name " << ConvertToANSIString(pRasEntry->szDeviceName) << flush;
	#endif

	dwRet = ATK_RasSetEntryProperties( NULL,
						   RAS_ENTRY_NAME,
						   pRasEntry,
						   dwEntrySize ,
						   NULL,
						   0);
	
	if(dwRet ==  ERROR_CANNOT_OPEN_PHONEBOOK )
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nFun  ConfigureDUN : ERROR_CANNOT_OPEN_PHONEBOOK  "  << dwRet  << flush;
		#endif
		return FALSE;
	}
	else
	if(dwRet ==  ERROR_BUFFER_INVALID )
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nFun  ConfigureDUN : ERROR_BUFFER_INVALID  "  << dwRet  << flush;
		#endif
		return FALSE;
	}
	else
	if(dwRet)
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n ConfigureDUN : Unknown/Undocumented  Error "  << dwRet  << flush;
		#endif
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\rwpost.cpp ===
/////////////////////////////////////////
//   File:          RWPost.cpp
//
//////////////////////////////////////////   

//#define STRICT
//   Include Files
//
//Modifications :
//MDX1	03/11/99  Suresh
//	In SendHTTPData() the MSID will be got from Cookie 
//	it will no longer be red from the Registry 
//
//


#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include "resource.h"
#include "Ithread.h"
#include "icw.h"
#include "util.h"
#include "tcp.h"
#include "rw_common.h"
#include "dconv.h"
#include "RwPost.h"
#include "mcm.h"
#include "ATK_RAS.h"
#include "tcp.h"
#define  CONNECTION_TIME_OUT  1000 * 60 
#define  MAX_PROXY_AUTH_RETRY  2

static CInternetThread		theInternetClass;
extern BOOL bOemDllLoaded;
extern HANDLE hOemDll;
static  DWORD dwConnectionStatus = DIALUP_NOT_REQUIRED; 

extern DWORD InvokePost(HWND hWnd,CInternetThread *p);

void InitializeInetThread(HINSTANCE hIns)
{	
	theInternetClass.Initialize(hIns);
}

//
//	Returns 
//	DIALUP_NOT_REQUIRED  : Use Network for tx
//  DIALUP_REQUIRED       : Use Dialupo for Tx  
//  RWZ_ERROR_NOTCPIP      : No TCP/IPO
//  CONNECTION_CANNOT_BE_ESTABLISHED  : No modem or RAS setup

DWORD CheckInternetConnectivityExists(HWND hWnd, HINSTANCE hInstance)
{
	static  int iAuthRetry =0; // Retry count for the number of times to invoke Proxy Auth Dlg
	static	CHAR szProxyServer[MAX_PATH];
	CHAR    szProxySettings[MAX_PATH];
	static  int   iChkInternetConnection = 0; 
	static  DWORD sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED; 
	BOOL	bNeedsReboot;
	BOOL	bRet; 
	DWORD   dwPingStatus;
	DWORD	dwError= RWZ_NOERROR;
	BOOL	bProxyExists;
	MODEMSTATUS  mStatus;
	DWORD	dwTimeOut = CONNECTION_TIME_OUT;
	int		iProxyPort;
	TCHAR	szUserName[48] = _T(""),
			szPassword[48] = _T("");
	int     iDisableAutoDial;

	iDisableAutoDial=1;

	if( sdwConnectionStatus == DIALUP_NOT_REQUIRED )
	return DIALUP_NOT_REQUIRED;
	if( sdwConnectionStatus == DIALUP_REQUIRED  )
	return DIALUP_REQUIRED;

	// Disable Auto Dial only 
	// if there are not active Dialup Connection
	//
	if( ATK_IsRasDllOk() == RAS_DLL_LOADED ) 
	{
			if( IsDialupConnectionActive() ) 
			{
				iDisableAutoDial=0;
			}
	}
	if(iDisableAutoDial) 
	{
		DisableAutoDial();// Disable the Auto Dial
	}
	// Ping Current Host to check if TCP is 
	// installed /configured.
	// 
	// if it is for the first time 

	//  RWZ_PINGSTATUS_NOTCPIP : if no socket library or get hostname fails  
	//  RWZ_PINGSTATUS_SUCCESS : if gethostname and ping is successful 
	//  RWZ_PINGSTATUS_FAIL    : if gethostname is succesful and ping via icmp fails 
	dwPingStatus = PingHost();

	RW_DEBUG  <<"\n Ping To Host (40: No TCP/IP   41: Success  42: Failure)=: "   << dwPingStatus << flush;

	if (dwPingStatus == RWZ_PINGSTATUS_NOTCPIP )
	{
		return RWZ_ERROR_NOTCPIP;
	} 
	if( dwPingStatus == RWZ_PINGSTATUS_SUCCESS ){
		bProxyExists = theInternetClass.GetSystemProxyServer(szProxyServer,MAX_PATH, &iProxyPort);
		if (1 /*bProxyExists*/) 
		{
			//theInternetClass.GetSystemProxySettings(szProxySettings,MAX_PATH);
			//theInternetClass.SetSystemProxySettings(szProxySettings);
			theInternetClass.SetSystemProxySettings("itgproxy");
			
			if(1 /*Ping(szProxyServer)*/) 
			{
				DWORD dwChkSite;
				int   iExit;
				iExit =0;
				RW_DEBUG  <<"\n Ping Success" << flush;
					theInternetClass.m_UserName[0] = _T('\0');
					theInternetClass.m_Password[0] = _T('\0');

				
				do {
					dwChkSite = ChkSiteAvailability(hWnd, theInternetClass.m_strIISServer,
						dwTimeOut,
						(LPTSTR) theInternetClass.GetProxyServer(),
						theInternetClass.m_UserName,theInternetClass.m_Password);
						
						RW_DEBUG  <<"\n After  ChkSiteAvailability : " << dwChkSite  << flush;

						if( dwChkSite == RWZ_SITE_REQUIRES_AUTHENTICATION) {
							if( iAuthRetry++ > MAX_PROXY_AUTH_RETRY) {
								iExit =1;
							}
							// Modified on 2/4/98
							// No Need to call our Proxy Auth Dlg insted use
							// InternetErrorDlg() to invoke Auth Dlg
							//if(GetProxyAuthenticationInfo(hInstance,ConvertToUnicode(szProxyServer),
							//	theInternetClass.m_UserName,theInternetClass.m_Password)) {
							//}


						}else {
							// Exit because  Connectivity is OK 
							iExit = 1;
						}
				}while(!iExit);

				if( dwChkSite == RWZ_SITE_CONNECTED)
				{
					theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
					// Modified on 2/4/98to use the PRECONFIGIED rather than the PROXY specified by
					// the user programatically
					// The INTERNET_OPEN_TYPE_PROXY is changed .....
					// This change is done in order for IE Auth Dlg
					dwError = DIALUP_NOT_REQUIRED;
					sdwConnectionStatus = DIALUP_NOT_REQUIRED;
					dwConnectionStatus = DIALUP_NOT_REQUIRED;
					goto ExitChk;
				}

			}

		}
		
		// No Procy so check for connection using existing LAN 
		// already opened Dialup Connection 
		// Set to NULL Proxy  
		//
				
		theInternetClass.SetProxyServer("",80);// Set it To Null 
		theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
		if( ATK_IsRasDllOk() == RAS_DLL_LOADED ) 
		{
			if( IsDialupConnectionActive() ) 
			{
				// Already Dialup COnnection is Active
				dwError = DIALUP_NOT_REQUIRED;
				sdwConnectionStatus = DIALUP_NOT_REQUIRED;
				dwConnectionStatus = DIALUP_NOT_REQUIRED;
				goto ExitChk;
			}
		}

		//
		// Check Lan Connection
		bRet = CheckHostName( ConvertToANSIString(theInternetClass.m_strIISServer));
		if(bRet)
		{
			theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
			if(ChkSiteAvailability(NULL, theInternetClass.m_strIISServer,
			dwTimeOut,
			_T(""),szUserName,szPassword)) 
			{
				dwError = DIALUP_NOT_REQUIRED;
				sdwConnectionStatus = DIALUP_NOT_REQUIRED;
				dwConnectionStatus = DIALUP_NOT_REQUIRED;
				goto ExitChk;
			}
		}

	}	

	dwError = DIALUP_REQUIRED;	
	sdwConnectionStatus = DIALUP_REQUIRED;
	dwConnectionStatus = DIALUP_NOT_REQUIRED;
	theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
	
	RW_DEBUG << "\n Before  MDMCHK..." << flush;
	//MDMCHK:
	// Install Modem
	//
	/**bNeedsReboot = theInternetClass.InstallModem(hWnd);
	if(bNeedsReboot) 
	{
			// ?????
			//  This will be abnormally terminating the Registration Wizard, 
			//  So support modem installation in  OS which dosent call for a reboot
	}
	**/
	mStatus = MSDetectModemTAPI(hInstance);
	if(mStatus != kMsModemOk ) 
	{
			dwError = CONNECTION_CANNOT_BE_ESTABLISHED;
			sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED;
	}

	if(dwError == DIALUP_REQUIRED ) 
	{
		// Load RASPAI32.DLL and Exit if it can not be loaded
		if( ATK_IsRasDllOk() != RAS_DLL_LOADED ) 
		{
			//
			dwError = CONNECTION_CANNOT_BE_ESTABLISHED;
			sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED;
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n RASAPI32.DLL NOT FOUND ...";
			#endif
		}
	}

ExitChk:
	#ifdef _LOG_IN_FILE
		RW_DEBUG  <<"\n Chk Connection ( 1 = via NTWK, 2 = DIalup , 3 = Problem) "   << dwError << flush;
	#endif
	theInternetClass.UnLoadInetCfgDll();
	return dwError;


}

//
//	Returns 
//	DIALUP_NOT_REQUIRED  : Use Network for tx
//  DIALUP_REQUIRED       : Use Dialupo for Tx  
//  RWZ_ERROR_NOTCPIP      : No TCP/IPO
//  CONNECTION_CANNOT_BE_ESTABLISHED  : No modem or RAS setup

DWORD CheckInternetConnectivityExistsOldLogic(HWND hWnd, HINSTANCE hInstance)
{
	static  int iAuthRetry =0; // Retry count for the number of times to invoke Proxy Auth Dlg
	static	CHAR szProxyServer[MAX_PATH];
	CHAR    szProxySettings[MAX_PATH];
	static  int   iChkInternetConnection = 0; 
	static  DWORD sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED; 
	BOOL	bNeedsReboot;
	BOOL	bRet; 
	DWORD   dwPingStatus;
	DWORD	dwError= RWZ_NOERROR;
	BOOL	bProxyExists;
	MODEMSTATUS  mStatus;
	DWORD	dwTimeOut = CONNECTION_TIME_OUT;
	int		iProxyPort;
	TCHAR	szUserName[48] = _T(""),
			szPassword[48] = _T("");
	int     iDisableAutoDial;

	iDisableAutoDial=1;

	if( sdwConnectionStatus == DIALUP_NOT_REQUIRED )
	return DIALUP_NOT_REQUIRED;
	if( sdwConnectionStatus == DIALUP_REQUIRED  )
	return DIALUP_REQUIRED;

	// Disable Auto Dial only 
	// if there are not active Dialup Connection
	//
	if( ATK_IsRasDllOk() == RAS_DLL_LOADED ) 
	{
			if( IsDialupConnectionActive() ) 
			{
				iDisableAutoDial=0;
			}
	}
	if(iDisableAutoDial) 
	{
		DisableAutoDial();// Disable the Auto Dial
	}
	// Ping Current Host to check if TCP is 
	// installed /configured.
	// 
	// if it is for the first time 

	//  RWZ_PINGSTATUS_NOTCPIP : if no socket library or get hostname fails  
	//  RWZ_PINGSTATUS_SUCCESS : if gethostname and ping is successful 
	//  RWZ_PINGSTATUS_FAIL    : if gethostname is succesful and ping via icmp fails 
	dwPingStatus = PingHost();

	RW_DEBUG  <<"\n Ping To Host (40: No TCP/IP   41: Success  42: Failure)=: "   << dwPingStatus << flush;

	if (dwPingStatus == RWZ_PINGSTATUS_NOTCPIP )
	{
		return RWZ_ERROR_NOTCPIP;
	} 
	if( dwPingStatus == RWZ_PINGSTATUS_SUCCESS ){
		bProxyExists = theInternetClass.GetSystemProxyServer(szProxyServer,MAX_PATH, &iProxyPort);
		if (bProxyExists) 
		{
			theInternetClass.GetSystemProxySettings(szProxySettings,MAX_PATH);
			theInternetClass.SetSystemProxySettings(szProxySettings);
			
			
			if(Ping(szProxyServer)) 
			{
				DWORD dwChkSite;
				int   iExit;
				iExit =0;
				RW_DEBUG  <<"\n Ping Success" << flush;
					theInternetClass.m_UserName[0] = _T('\0');
					theInternetClass.m_Password[0] = _T('\0');

				
				do {
					dwChkSite = ChkSiteAvailability(hWnd, theInternetClass.m_strIISServer,
						dwTimeOut,
						(LPTSTR) theInternetClass.GetProxyServer(),
						theInternetClass.m_UserName,theInternetClass.m_Password);
						
						RW_DEBUG  <<"\n After  ChkSiteAvailability : " << dwChkSite  << flush;

						if( dwChkSite == RWZ_SITE_REQUIRES_AUTHENTICATION) {
							if( iAuthRetry++ > MAX_PROXY_AUTH_RETRY) {
								iExit =1;
							}
							// Modified on 2/4/98
							// No Need to call our Proxy Auth Dlg insted use
							// InternetErrorDlg() to invoke Auth Dlg
							//if(GetProxyAuthenticationInfo(hInstance,ConvertToUnicode(szProxyServer),
							//	theInternetClass.m_UserName,theInternetClass.m_Password)) {
							//}


						}else {
							// Exit because  Connectivity is OK 
							iExit = 1;
						}
				}while(!iExit);

				if( dwChkSite == RWZ_SITE_CONNECTED)
				{
					theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
					// Modified on 2/4/98to use the PRECONFIGIED rather than the PROXY specified by
					// the user programatically
					// The INTERNET_OPEN_TYPE_PROXY is changed .....
					// This change is done in order for IE Auth Dlg
					dwError = DIALUP_NOT_REQUIRED;
					sdwConnectionStatus = DIALUP_NOT_REQUIRED;
					dwConnectionStatus = DIALUP_NOT_REQUIRED;
					goto ExitChk;
				}

			}

		}
		
		// No Procy so check for connection using existing LAN 
		// already opened Dialup Connection 
		// Set to NULL Proxy  
		//
				
		theInternetClass.SetProxyServer("",80);// Set it To Null 
		theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
		if( ATK_IsRasDllOk() == RAS_DLL_LOADED ) 
		{
			if( IsDialupConnectionActive() ) 
			{
				// Already Dialup COnnection is Active
				dwError = DIALUP_NOT_REQUIRED;
				sdwConnectionStatus = DIALUP_NOT_REQUIRED;
				dwConnectionStatus = DIALUP_NOT_REQUIRED;
				goto ExitChk;
			}
		}

		//
		// Check Lan Connection
		bRet = CheckHostName( ConvertToANSIString(theInternetClass.m_strIISServer));
		if(bRet)
		{
			theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
			if(ChkSiteAvailability(NULL, theInternetClass.m_strIISServer,
			dwTimeOut,
			_T(""),szUserName,szPassword)) 
			{
				dwError = DIALUP_NOT_REQUIRED;
				sdwConnectionStatus = DIALUP_NOT_REQUIRED;
				dwConnectionStatus = DIALUP_NOT_REQUIRED;
				goto ExitChk;
			}
		}

	}	

	dwError = DIALUP_REQUIRED;	
	sdwConnectionStatus = DIALUP_REQUIRED;
	dwConnectionStatus = DIALUP_NOT_REQUIRED;
	theInternetClass.m_dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
	
	RW_DEBUG << "\n Before  MDMCHK..." << flush;
//MDMCHK:
	// Install Modem
	//
	bNeedsReboot = theInternetClass.InstallModem(hWnd);
	if(bNeedsReboot) 
	{
			// ?????
			//  This will be abnormally terminating the Registration Wizard, 
			//  So support modem installation in  OS which dosent call for a reboot
	}

	mStatus = MSDetectModemTAPI(hInstance);
	if(mStatus != kMsModemOk ) 
	{
			dwError = CONNECTION_CANNOT_BE_ESTABLISHED;
			sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED;
	}

	if(dwError == DIALUP_REQUIRED ) 
	{
		// Load RASPAI32.DLL and Exit if it can not be loaded
		if( ATK_IsRasDllOk() != RAS_DLL_LOADED ) 
		{
			//
			dwError = CONNECTION_CANNOT_BE_ESTABLISHED;
			sdwConnectionStatus = CONNECTION_CANNOT_BE_ESTABLISHED;
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n RASAPI32.DLL NOT FOUND ...";
			#endif
		}
	}

ExitChk:
	#ifdef _LOG_IN_FILE
		RW_DEBUG  <<"\n Chk Connection ( 1 = via NTWK, 2 = DIalup , 3 = Problem) "   << dwError << flush;
	#endif
	theInternetClass.UnLoadInetCfgDll();
	return dwError;


}


DWORD SendHTTPData(HWND hWnd, HINSTANCE hInstance)
{
	char czB [MAX_BUFFER + 1]; // Buffer for Tx
	DWORD dwBufSize = MAX_BUFFER;
	DWORD dwOemBufSize;
	DWORD dwRet;
	_TCHAR szValue[256];


	DWORD	dwTimeOut = CONNECTION_TIME_OUT;

	// MDX : 03/11/99 
	// Get MSID From Cookie , No need to check from Registry
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n*******Getting Cookie********\n"<< flush;
	#endif
	if(dwConnectionStatus == DIALUP_REQUIRED){
			ChkSiteAvailability(hWnd, theInternetClass.m_strIISServer,
				dwTimeOut,
				NULL,
				theInternetClass.m_UserName,
				theInternetClass.m_Password);
	}
	else{
		ChkSiteAvailability(hWnd, theInternetClass.m_strIISServer,
				dwTimeOut,
				(LPTSTR) theInternetClass.GetProxyServer(),
				theInternetClass.m_UserName,
				theInternetClass.m_Password);
	}

	SetMSID(hInstance);
	
	
	dwRet  = PrepareRegWizTxbuffer(hInstance, czB, &dwBufSize);
	dwOemBufSize = MAX_BUFFER - dwBufSize;
	dwRet  = OemTransmitBuffer(hInstance,czB + dwBufSize,&dwOemBufSize);
	dwBufSize += dwOemBufSize;

	switch(dwRet) 
	{
		case  RWZ_NOERROR:
			theInternetClass.SetBuffer(czB, dwBufSize+1);
			theInternetClass.SetSSLFlag(TRUE);
			dwRet = theInternetClass.PostData(hWnd);
			// dwRet = InvokePost(hWnd, &theInternetClass);

			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n PostData() returned: "<<dwRet << flush;
			#endif

			if( dwRet == RWZ_POST_FAILURE  ||  dwRet == RWZ_POST_WITH_SSL_FAILURE)
			{
				// Try posting without SSL only for the modem
				//if(dwConnectionStatus == DIALUP_REQUIRED)
				//{
					#ifdef _LOG_IN_FILE
						RW_DEBUG << "\n Posting Failure : Sending Data without SSL" << flush;
					#endif
					theInternetClass.SetSSLFlag(FALSE);
					dwRet = theInternetClass.PostData(hWnd);
					//dwRet = InvokePost(hWnd, &theInternetClass);
				//}
			}
			#ifdef _LOG_IN_FILE
				RW_DEBUG  << "\n Success ... \t"  << dwRet << flush;
				RW_DEBUG   <<"\n\n\nBuffer\t\t*[" << czB << "]" << flush;
			#endif
			break;
		case  RWZ_NO_INFO_AVAILABLE :
			#ifdef _LOG_IN_FILE
				RW_DEBUG  << _T("\n No Info Available ")  << flush;
			#endif
			break;
		case  RWZ_INVALID_INFORMATION :
			#ifdef _LOG_IN_FILE
				RW_DEBUG  << _T("\n Invalid Info  " ) << flush;
			#endif
			break;
		case  RWZ_BUFFER_SIZE_INSUFFICIENT :
			#ifdef _LOG_IN_FILE
				RW_DEBUG  <<_T("\n Buffer Length In Sufficient ...") << dwRet;
				RW_DEBUG   <<_T("\n\n\nBuffer\t\t") << czB;
			#endif
			break;
		case    RWZ_INTERNAL_ERROR	 :
			#ifdef _LOG_IN_FILE
				RW_DEBUG  << _T("\n Internal Error ....") ;
			#endif
		default:
			break;
	}
	#ifdef _LOG_IN_FILE
		RW_DEBUG  << flush;
	#endif
	return dwRet;
}


/*DWORD PostHTTPData(HINSTANCE hInstance)
{
	DWORD dwRet = RWZ_POST_FAILURE;
	DWORD dwRetStatus;

	dwRetStatus = CheckWithDisplayInternetConnectivityExists(hInstance,2);

	switch (dwRetStatus)
	{
	case DIALUP_NOT_REQUIRED  :
		if ((dwRet =  PostDataWithWindowMessage(hInstance)) 
				== RWZ_POST_SUCCESS){
			;
		}
		else {
		}
		break;
	case DIALUP_REQUIRED      :
		 dwRet=DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_DIAL), NULL,FDlgProc,
			 (LPARAM)hInstance);
		 if(dwRet == -1 ) {
			 // Error in creating the Dialogue

		 }
		switch ( dwRet)  {
		case RWZ_ERROR_LOCATING_MSN_FILES :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup :Error Locating MSN File " << flush;
			#endif
			break;
		case RWZ_ERROR_LOCATING_DUN_FILES   :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup :Error Locating DUN File " << flush;
			#endif
			break;
		case RWZ_ERROR_MODEM_IN_USE :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup :Error Modem Already in use by another Application " << flush;
			#endif
			break;
		case RWZ_ERROR_MODEM_CFG_ERROR:
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup :Modem Configuration Error " << flush;
			#endif
		case RWZ_ERROR_TXFER_CANCELLED_BY_USER :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup     :HTTP Post Cancelled by User  " << flush;
			#endif
			break;
		case RWZ_ERROR_SYSTEMERROR :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup     : System Resource Allocation Error  " << flush;
			#endif
			break;
		case RWZ_ERROR_NODIALTONE :
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Signup     : Modem Error No Dialtone " << flush;
			#endif
			break;
		default :
			break;
		}

				 
		
	case  CONNECTION_CANNOT_BE_ESTABLISHED  :
	default :
		// It is unexpected . ? to Do
	
	break;
	
	}
	return dwRet;
}
**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\tcp.cpp ===
///////////////////////////////
//   File:          tcp.cpp
//   
//   Description:   

//	#include statements
//
#include <windows.h>
#include <stdio.h>
#include <winsock.h>
#include "tcp.h"
#include "util.h"
#include "rw_common.h"


#define   RW_TCP_NOT_INITILIZED   0
#define   RW_TCP_INITILIZED       1 

#define   RW_ICMP_NOT_INITILIZED   0
#define   RW_ICMP_INITILIZED       1

static int siTcpStatus = RW_TCP_NOT_INITILIZED;
static HINSTANCE  hIcmp= NULL;
static WSADATA wsa;

int ResolveHostByThread(LPSTR pHost);
int ResolveHostByAddrThread(LPSTR pHost);

#define GET_HOST_TOUT (15 * 1000)
#define PING_TOUT     (15 * 1000)
static struct hostent *gphostent= NULL;

BOOL InitForTcp()
{
	BOOL	bRet= FALSE;


	if( siTcpStatus == RW_TCP_INITILIZED ) 
	return TRUE;

	if (! WSAStartup(0x0101, &wsa )) {
		siTcpStatus = RW_TCP_INITILIZED;
		bRet= TRUE;
	}
	return bRet;

}

BOOL InitForIcmp()
{
	if(hIcmp)
		return TRUE;
	hIcmp = LoadLibrary( _T("ICMP.DLL") );  //  Load ICMP.DLL and store globally
	if( ! hIcmp )
	{                                   //  Whine if unable to load the DLL
	  DisplayMessage("Unable to locate ICMP.DLL");
	  return( FALSE );
	}
	return TRUE;

}

void CloseForTcpIcmp()
{
	if (hIcmp)
		FreeLibrary(hIcmp);  //  When app is closed, free the ICMP DLL
	if(siTcpStatus == RW_TCP_INITILIZED)
	WSACleanup();		  //  And clean up sockets
	hIcmp = NULL;
	siTcpStatus = RW_TCP_NOT_INITILIZED;

}
//
// Tries to get the host name and pings using ICMP
// returns
//  RWZ_PINGSTATUS_NOTCPIP : if no socket library or get hostname fails  
//  RWZ_PINGSTATUS_SUCCESS : if gethostname and ping is successful 
//  RWZ_PINGSTATUS_FAIL    : if gethostname is succesful and ping via icmp fails 

DWORD  PingHost()
{
	DWORD 	dwRet= 0;
	char	szIPAddress[80];
	dwRet = RWZ_PINGSTATUS_NOTCPIP;
	if(!InitForTcp()) {
		return dwRet; // Tcp is not installed 
	}
	memset(szIPAddress, '\0', 80);
	if (!gethostname(szIPAddress, 80))
	{
		 
		if (Ping(szIPAddress)){
			dwRet =  RWZ_PINGSTATUS_SUCCESS;
		}else {
			dwRet =  RWZ_PINGSTATUS_FAIL;
		}
	}

	return dwRet;
}


	



BOOL Ping(LPSTR szIPAddress)
{
	BOOL bRet= FALSE;

	if( !InitForIcmp())
		return bRet;

	if(!InitForTcp()) {
		return FALSE; // Tcp is not installed 
	}


	static struct sockaddr_in saDestAddr;

	char szBuffer[64];
	DWORD *dwIPAddr, dwStatus;
	HANDLE hIP;
	struct hostent *phostent;
	PIP_ECHO_REPLY pIpe;

	if(!ResolveHostByThread(szIPAddress)) {
		gphostent = gethostbyname(szIPAddress);
		phostent = gphostent;
	}else {
		phostent= NULL;
	}
	if( ! phostent ){
		RW_DEBUG << "\n Resolving by Address "  << flush;
		int iError;
		iError = 0;
		iError = WSAGetLastError ();
		RW_DEBUG << "\n Get Host By Name Error " << iError  << flush;
		if(iError){
			WSASetLastError (0);
			//return 0;
		}

		saDestAddr.sin_addr.s_addr = inet_addr(szIPAddress);
		if( saDestAddr.sin_addr.s_addr !=INADDR_NONE ) {
			if(!ResolveHostByAddrThread((LPSTR)&saDestAddr.sin_addr.s_addr)) {
				gphostent = gethostbyaddr((LPSTR)&saDestAddr.sin_addr.s_addr,4, PF_INET) ;
				phostent = gphostent;
			}else {
				phostent= NULL;
			}
			
		}
		if(!phostent)
		{
			DisplayMessage(szIPAddress , "Unable to obtain an IP address for %s");
			return bRet;
		}
		
	}
	



    dwIPAddr = (DWORD *)( *phostent->h_addr_list );

	ICMPCREATEFILE	pIcmpCreateFile;
	pIcmpCreateFile = (ICMPCREATEFILE) GetProcAddress(hIcmp, "IcmpCreateFile");
	if (NULL == pIcmpCreateFile)
	{
		DisplayMessage("IcmpCreateFile GetProc Error", "");
		return FALSE;
	}

    ICMPCLOSEHANDLE	pIcmpCloseHandle;
 	pIcmpCloseHandle = (ICMPCLOSEHANDLE) GetProcAddress(hIcmp, "IcmpCloseHandle");
	if (NULL == pIcmpCloseHandle)
	{
		DisplayMessage("IcmpCloseHandle GetProc Error", "");
		return bRet;
	}

	ICMPSENDECHO	pIcmpSendEcho;
	pIcmpSendEcho = (ICMPSENDECHO) GetProcAddress(hIcmp, "IcmpSendEcho");
	if (NULL == pIcmpSendEcho)
	{
		DisplayMessage("IcmpSendEcho GetProc Error", "");
		return bRet;
	}

	if( ! pIcmpCreateFile || ! pIcmpCloseHandle || ! pIcmpSendEcho )
	{
		DisplayMessage("Unable to locate required API functions", "");
		return bRet;
	}


	hIP = pIcmpCreateFile();
	if( hIP == INVALID_HANDLE_VALUE )
	{
	  DisplayMessage("Unable to open PING service");
	  return bRet;
	}

	memset( szBuffer, '\xAA', 64 );
	pIpe = (PIP_ECHO_REPLY)LocalAlloc(LPTR, sizeof(IP_ECHO_REPLY) + 64);
	if (pIpe)
	{
		pIpe->Data = szIPAddress;
		pIpe->DataSize = 64;      

		dwStatus = pIcmpSendEcho( hIP, *dwIPAddr, szBuffer, 64, NULL, pIpe, 
								sizeof(IP_ECHO_REPLY) + 64, PING_TOUT );
		if(dwStatus)
		{
			bRet = TRUE;
		}
		LocalFree(pIpe);
		pIcmpCloseHandle(hIP);
   }
   
   
   return bRet;
}


BOOL  CheckHostName(LPSTR szIISServer)
{
// WSAStartup() is already called	
	if(!InitForTcp()) {
		return FALSE; // Tcp is not installed 
	}
	struct hostent *phostent;
	
	if(!ResolveHostByThread(szIISServer)) {
		phostent = gphostent;
	}else {
		phostent= NULL;
	}
	
	if (phostent == NULL)
		return FALSE;
	else
		return TRUE;
// WSACleanup() will be called later
	
}


//
//  Returns 1 if there is an Error
//          0 if Successful 
DWORD GetHostThread(void *vp)
{
	DWORD dwIsError=1;
	LPSTR  szHost;
	szHost = (LPSTR) vp;
	int iError = 0;

	gphostent = gethostbyname(szHost);
	if( ! gphostent ){
		
		iError = WSAGetLastError ();
		if(iError) {
			WSASetLastError (0); // Reset the  error 
		}
	}
	else {
		dwIsError =0;
	}
	ExitThread(dwIsError);
	return dwIsError;
}

//
//  This function returns Calls the gethostbyname and 
//  returns 0 if Successful and 1 if failure 
//  the return 
//
//
int ResolveHostByThread(LPSTR pHost)
{
	int   iRet=0; 
	DWORD  dwThreadExitCode; 
	DWORD dwCreationFlags=0; // Start CREATE_SUSPENDED 
	DWORD ThreadId;
	RW_DEBUG << "\nResolve " << pHost <<  flush;

	HANDLE hParent = CreateThread(NULL, 
		0,
	(LPTHREAD_START_ROUTINE) GetHostThread,
	(void *) pHost,
	dwCreationFlags, 
	&ThreadId );

	DWORD dwRet = WaitForSingleObject(hParent,GET_HOST_TOUT);
	switch(dwRet) {
	case WAIT_ABANDONED :
		iRet = 1; // Error In Get Host Name 
		break;
	case WAIT_OBJECT_0 :
		RW_DEBUG << "\n\tResolved ( 1 Error, 0 Ok)  ";

		if( GetExitCodeThread(hParent,&dwThreadExitCode) ) {
			iRet = (int) dwThreadExitCode;

		}
		else {
			
		}
		RW_DEBUG << iRet;
		break;
	case WAIT_TIMEOUT :
		RW_DEBUG << "\n\t*** Error  Resolving " << flush;
		iRet = 1; // Error In Get Host Name 
		TerminateThread(hParent,0);
		break;
	default:
		break;
	}
	return iRet;


}


//
//  Returns 1 if there is an Error
//          0 if Successful 
DWORD GetHostByAddrThread(void *vp)
{
	DWORD dwIsError=1;
	LPSTR  szAddr;
	int iError = 0;
	szAddr = (LPSTR) vp;
	
	gphostent = gethostbyaddr(szAddr, 
		4, PF_INET) ;
	if( ! gphostent ){
		
		iError = WSAGetLastError ();
		if(iError) {
			WSASetLastError (0); // Reset the  error 
		}
	}
	else {
		dwIsError =0;
	}
	return dwIsError;
}

//
//  This function returns Calls the gethostbyaddr and 
//  returns 0 if Successful and 1 if failure 
//  the return 
//
//
int ResolveHostByAddrThread(LPSTR pHost)
{
	int   iRet=0; 
	DWORD  dwThreadExitCode; 
	DWORD dwCreationFlags=0; // Start CREATE_SUSPENDED 
	DWORD ThreadId;
	RW_DEBUG << "\nResolve " << pHost << " By Address " << flush;
	HANDLE hParent = CreateThread(NULL, 
		0,
	(LPTHREAD_START_ROUTINE) GetHostByAddrThread,
	(void *) pHost,
	dwCreationFlags, 
	&ThreadId );

	DWORD dwRet = WaitForSingleObject(hParent,GET_HOST_TOUT);
	switch(dwRet) {
	case WAIT_ABANDONED :
		iRet = 1; // Error In Get Host Name 
		break;
	case WAIT_OBJECT_0 :
		RW_DEBUG << "\n\tResolved ( 1 Error, 0 Ok)  ";
		if( GetExitCodeThread(hParent,&dwThreadExitCode) ) {
			iRet = (int) dwThreadExitCode;
		
		}
		else {
			
		}
		RW_DEBUG << iRet << flush;
		break;
	case WAIT_TIMEOUT :
		RW_DEBUG << "\n\t*** Error  Resolving " << flush;
		iRet = 1; // Error In Get Host Name 
		TerminateThread(hParent,0);
		break;
	default:
		break;
	}
	return iRet;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\ithread.cpp ===
#include <windows.h>
#include <stdio.h>
#include "AtkInternet.h"

#include "resource.h"
#include <ithread.h>
#include "icw.h"
#include "util.h"
#include "rw_common.h"
#include "ATK_inet.h"

#define  RWZ_POST_MAX_RETRY  3

struct _MK
{
	DWORD dwQuery;
	char *s;
} ;

#define MK(x) {x,#x}


static  _MK Queries[] =
{
MK(HTTP_QUERY_MIME_VERSION),
MK(HTTP_QUERY_CONTENT_TYPE),
MK(HTTP_QUERY_CONTENT_TRANSFER_ENCODING),
MK(HTTP_QUERY_CONTENT_ID),
MK(HTTP_QUERY_CONTENT_DESCRIPTION),
MK(HTTP_QUERY_CONTENT_LENGTH),
MK(HTTP_QUERY_ALLOW),
MK(HTTP_QUERY_PUBLIC),
MK(HTTP_QUERY_DATE),
MK(HTTP_QUERY_EXPIRES),
MK(HTTP_QUERY_LAST_MODIFIED),
MK(HTTP_QUERY_MESSAGE_ID),
MK(HTTP_QUERY_URI),
MK(HTTP_QUERY_DERIVED_FROM),
MK(HTTP_QUERY_COST),
MK(HTTP_QUERY_PRAGMA),
MK(HTTP_QUERY_VERSION),
MK(HTTP_QUERY_STATUS_CODE),
MK(HTTP_QUERY_STATUS_TEXT),
MK(HTTP_QUERY_RAW_HEADERS),
MK(HTTP_QUERY_RAW_HEADERS_CRLF),
MK(HTTP_QUERY_REQUEST_METHOD)
};
void QueryForInfo(HINTERNET );
void GetQueryInfo(HINTERNET ,DWORD ,char *);

typedef BOOL (WINAPI *LPICP)(HWND,BOOL,BOOL);
LPICP lpICP;


void QueryForInfo(HINTERNET hIntHandle)
{
	int nSize  = sizeof(Queries)/sizeof(_MK);
	for(int i=0;i< nSize;i++)
	{
		GetQueryInfo(hIntHandle,Queries[i].dwQuery,Queries[i].s);
	}
}

void GetQueryInfo(HINTERNET hIntHandle,DWORD dwQuery,char *s)
{
	char  dwbufQuery[512];
	DWORD dwLengthBufQuery;
	BOOL bQuery = ::ATK_HttpQueryInfo(	hIntHandle,
									dwQuery,
									&dwbufQuery,
			                        &dwLengthBufQuery,
									NULL) ;
	
	#ifdef _LOG_IN_FILE
		RW_DEBUG  << "\n" << s << dwbufQuery <<  flush;
	#endif
}



void _stdcall myCallback(   IN HINTERNET hInternet,
							IN DWORD dwContext,
							IN DWORD dwInternetStatus,
							IN LPVOID lpvStatusInformation OPTIONAL,
							IN DWORD dwStatusInformationLength)
{
	int iX= 100;
	iX++;

	switch(dwInternetStatus)
	{
	case INTERNET_STATUS_RESOLVING_NAME :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: RESOLVING_NAME\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_NAME_RESOLVED :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_NAME_RESOLVED\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_CONNECTING_TO_SERVER :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTING_TO_SERVER\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_CONNECTED_TO_SERVER :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTED_TO_SERVER\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_SENDING_REQUEST :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_SENDING_REQUEST\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_REQUEST_SENT :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_REQUEST_SENT\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_RECEIVING_RESPONSE :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_RECEIVING_RESPONSE\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_RESPONSE_RECEIVED :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_RESPONSE_RECEIVED\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_REDIRECT :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_REDIRECT\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_CLOSING_CONNECTION :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_CLOSING_CONNECTION\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_CONNECTION_CLOSED :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_CONNECTION_CLOSED\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_HANDLE_CREATED :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_HANDLE_CREATED\n" << flush;
		#endif
		break;
	case INTERNET_STATUS_REQUEST_COMPLETE :
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nCallback: INTERNET_STATUS_REQUEST_COMPLETE\n" << flush;
		#endif
		break;
	default :
		#ifdef _LOG_IN_FILE
			RW_DEBUG <<"\n Callback : default " << flush;
		#endif
	}
}




void pickup(const char* in, char* out, int *ipProxy)
{
	char czProzy[10]= "80";
	char *pProxy;
	int iCount ;

	pProxy = czProzy;
	
	if( *in == '/' )
		in++;

	if( *in == '/' )
		in++;

	while( *in && (*in != ':') && (*in != ';') )
		*out++ = *in++;
	
	*out = 0;
	
	if(!*in)
		return;

	if ( *in == ':' || *in == ';' )
		*in++;
	
	iCount = 0;
	
	while(*in && ( isspace(*in) || isdigit(*in)) )
	{
		if( isdigit(*in) && iCount < ((sizeof(czProzy) / sizeof(czProzy[0])) - 1) )  // leave room for the terminating NULL
		{
			*pProxy++ = *in;
			iCount++;
		}

		*in++;
	}

	if(iCount)
		*pProxy = 0;
	
	*ipProxy = atoi(czProzy);
}


/* //remove all blabks immediately preceeding ':' and afterwards.
   // eg.  "HELLO WORLD  : 80 " =>
	//     "HELLO WORLD:80"
	Remove all blanks: No blanks are allowed in a machine name?
*/

void RemoveBlank(char *pszStr)
{
	char *p, *q;
	p = pszStr;
	q = p;

	for(;*p;*p++)
	{
		if(!isspace(*p))
		{
			*q++ = *p;
		}
	}
	*q = '\0';
}


int getProxy(const char *in, char *out,int *piPort)
{
	char *s;
	*piPort = 0;	
	if( s= strstr(in, "http://") )
	{
		pickup(s+7,out,piPort);
	}
	else
	if(s= strstr(in, "http=") )
	{
		pickup(s+5,out,piPort);
	}
	else
	if( s= strstr(in, "http:") )
	{
		pickup(s+5,out,piPort);
	}
	else
	if(s= strstr(in, "://") )
	{
		*out = 0;
		return 0;
	}
	else
	if(s= strstr(in, "=") )
	{
		*out = 0;
		return 0;
	}
	else
		pickup(in,out,piPort);	
	return 1;
}


// Constructor
//
CInternetThread::CInternetThread()
    : m_hSession(NULL),
      m_dwAccessType(PRE_CONFIG_INTERNET_ACCESS)
{
	m_strProxyServer = NULL;
	m_strBuffer = NULL;
	m_strIISServer = NULL;
	m_strPath = NULL;
	m_hICWDllInstance  = NULL ; // ICW DLL not loaded
}




// Closes the Internet session so InternetOpen will be called on next PostData.
//
void CInternetThread::ResetSession()
{
   if (m_hSession != NULL)
   {
      ::InternetCloseHandle(m_hSession);
      m_hSession = NULL ;
   }
}


//
//
CInternetThread::~CInternetThread()
{
   if (m_strBuffer)			delete []m_strBuffer;
   if (m_strIISServer)		delete []m_strIISServer;
   if (m_strProxyServer)	delete []m_strProxyServer;
   if (m_UserName) delete []  m_UserName;
   if (m_Password ) delete [] m_Password;
   if (m_strPath) delete [] m_strPath;

   //ResetSession();
   if(m_hICWDllInstance)
   {
	    FreeLibrary(m_hICWDllInstance);
	    #ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Freeing INETCFG.DLL " << flush;
    	#endif
        m_hICWDllInstance = NULL;
   }
}

void CInternetThread ::UnLoadInetCfgDll()
{
	if( m_hICWDllInstance)
	FreeLibrary(m_hICWDllInstance);
	m_hICWDllInstance = NULL;

}

void	CInternetThread::SetBuffer(LPSTR strBuffer)	
{
   if (m_strBuffer)
		delete []m_strBuffer;
   if (strBuffer)
   {
	   m_dwBufferLen = strlen(strBuffer)+1;
	   m_strBuffer = (LPSTR) new CHAR[strlen(strBuffer)+1];
	   strcpy(m_strBuffer, strBuffer);
   }
}

void	CInternetThread::SetBuffer(LPSTR strBuffer, DWORD dwLen)	
{
   if (m_strBuffer)
		delete []m_strBuffer;
   if (strBuffer)
   {
	   m_dwBufferLen = dwLen-1;
	   m_strBuffer = (LPSTR) new CHAR[m_dwBufferLen+1];
	   memset(m_strBuffer, '\0', m_dwBufferLen+1);
	   strncpy(m_strBuffer, strBuffer, m_dwBufferLen);
   }
}

HINSTANCE CInternetThread:: LoadInetCfgDll()
{
	
	if(m_hICWDllInstance)
	{
		return m_hICWDllInstance;
	}
	m_hICWDllInstance = LoadLibrary(_T("INETCFG.DLL"));
	if (NULL == m_hICWDllInstance)
	{
		DisplayMessage("INETCFG.DLL LoadLibrary Failure", "");
		
	}
	return m_hICWDllInstance;

}

BOOL CInternetThread :: InstallModem(HWND hwnd)
{
	RW_DEBUG << "\n---Inside InstallModem" << flush;
#ifdef _WINNT
	/*
	STARTUPINFOA startUpInfo;
	PROCESS_INFORMATION PrcsInfo;
	GetStartupInfoA(&startUpInfo);
	DWORD dwPrS;
	int iErr;
	if( dwPrS=  CreateProcessA( NULL ,
			"rundll32.exe shell32.dll,Control_RunDLL modem.cpl", 0, 0,
			 FALSE,CREATE_NEW_CONSOLE, 0, 0,
			 &startUpInfo, &PrcsInfo) ) {
			WaitForSingleObject(PrcsInfo.hProcess, INFINITE);
	}
	else
	{
		iErr = GetLastError();
		RW_DEBUG << "\n Error In invoking Modem Init  "  << iErr << flush;
	}
	return 0;*/
	BOOL bRet;
	HINSTANCE hInstance = LoadLibrary(_T("modemui.dll"));
	if(hInstance != NULL)
	{
		lpICP = (LPICP) GetProcAddress(hInstance,"InvokeControlPanel");

		// Initialise the Control panel application
		bRet = lpICP(hwnd,FALSE,FALSE);
	
		FreeLibrary(hInstance);
	}
	else
	{
		bRet = FALSE;
		RW_DEBUG << "\n Error Loading modemui.dll" << flush;
	}
	
	return bRet;
	
#else

	HINSTANCE	hInst;
	BOOL        bRestart=FALSE;
	INETCONFIGSYSTEM fpS;

	hInst = LoadInetCfgDll();
	fpS = (INETCONFIGSYSTEM) GetProcAddress(hInst, "InetConfigSystem");
	HRESULT hrs  = (*fpS)(NULL,0x02,&bRestart);
	DWORD dwR = GetLastError();

	return bRestart;
#endif
}

/*
	05/05/97 : Proxy returns as http://XX:port
*/
BOOL CInternetThread::GetSystemProxyServer(PCHAR szProxy,
										   DWORD dwBufferLength,
										   int *piProxyPort)
{
  DWORD size = 0;  
  ATK_InternetQueryOption(NULL, INTERNET_OPTION_PROXY,NULL, &size);  
  #ifdef USE_ASTRATEK_WRAPPER
		BYTE* buf = new BYTE[size];
  #else
		BYTE* buf = new BYTE[size* sizeof(_TCHAR)];
  #endif
  ATK_INTERNET_PROXY_INFO* ipi = (ATK_INTERNET_PROXY_INFO*)buf;
  if (!ATK_InternetQueryOption(NULL, INTERNET_OPTION_PROXY,   ipi, &size))  
  {
		//MessageBox(NULL,_T("InternetQueryOption"),_T("False"),IDOK);
		delete[] buf;   
		return FALSE;  
  }
  else
  {
	  if(ipi->dwAccessType != 3)
	  {
			//MessageBox(NULL,_T("AccessType"),_T("False"),IDOK);
			delete[] buf;   
			return FALSE;
	  }
	  else
	  {
			//MessageBox(NULL,ConvertToUnicode(),ConvertToUnicode((LPSTR)ipi->lpszProxy),IDOK);
		  #ifdef USE_ASTRATEK_WRAPPER
			if( getProxy(ipi->lpszProxy,szProxy,piProxyPort)) 	
		  #else
			if( getProxy(ConvertToANSIString(ipi->lpszProxy),szProxy,piProxyPort)) 	
		  #endif
			{
				  RemoveBlank(szProxy);
				 // MessageBox(NULL,_T("after getproxy"),_T("TRUE"),IDOK);
					#ifdef _LOG_IN_FILE
						RW_DEBUG <<  "\n Actual HTTP Proxy [" <<szProxy << "] Port:" << *piProxyPort  << flush;
					#endif
				  delete[] buf;   
				  return TRUE;
			}
			else 
			{
				//MessageBox(NULL,_T("GetProxy"),_T("False"),IDOK);
	     	    delete[] buf;   
		    	return FALSE;
			}
	  }
  }
	
}

//
// This function gets the Actual proxy settings string
void CInternetThread :: GetSystemProxySettings( PCHAR szProxy,
										   DWORD dwBufferLength)

{
  DWORD size = 0;  
  ATK_InternetQueryOption(NULL, INTERNET_OPTION_PROXY,NULL, &size);  

  #ifdef USE_ASTRATEK_WRAPPER
		BYTE* buf = new BYTE[size];
  #else
		BYTE* buf = new BYTE[size* sizeof(_TCHAR)];
  #endif

  
  ATK_INTERNET_PROXY_INFO* ipi = (ATK_INTERNET_PROXY_INFO*)buf;
  ATK_InternetQueryOption(NULL, INTERNET_OPTION_PROXY,   ipi, &size);
  
  #ifdef USE_ASTRATEK_WRAPPER
		strcpy(szProxy,ipi->lpszProxy);
  #else
		strcpy(szProxy,ConvertToANSIString(ipi->lpszProxy));
  #endif
  
  dwBufferLength = strlen(szProxy) +1;
  delete[] buf;   
	
}

//
// IN Parameters:
// LPSTR strProxyServer : Proxy Server name in ANSI char
// int iProxyPort       : Proxy Server Port
//
void CInternetThread::SetSystemProxySettings(LPSTR strProxyServer)
{

   TCHAR  *pProxy;

   if (m_strProxyServer)
		delete []m_strProxyServer;
	
   if (strProxyServer)
   {
	   pProxy = ConvertToUnicode(strProxyServer);
	   m_strProxyServer = (LPTSTR) new TCHAR[_tcslen(pProxy)+11];
	   _tcscpy(m_strProxyServer, pProxy);
	
   }

}

// IN Parameters:
// LPSTR strProxyServer : Proxy Server name in ANSI char
// int iProxyPort       : Proxy Server Port
void CInternetThread::SetProxyServer(LPSTR strProxyServer, int iProxyPort)
{
   TCHAR  czTemp[10];
   TCHAR  *pProxy;

   if (m_strProxyServer)
		delete []m_strProxyServer;
	
   if (strProxyServer)
   {
	   pProxy = ConvertToUnicode(strProxyServer);
	   m_strProxyServer = (LPTSTR) new TCHAR[_tcslen(pProxy)+11];
	   _tcscpy(m_strProxyServer, pProxy);
	   _stprintf(czTemp,_T(":%d"),iProxyPort);
	   _tcscat(m_strProxyServer,czTemp);
   }

}

void CInternetThread::SetIISServer(LPTSTR strIISServer)
{
   if (m_strIISServer)
		delete []m_strIISServer;

   if (strIISServer)
   {
	  m_strIISServer = (LPTSTR) new TCHAR[_tcslen(strIISServer)+1];
	  _tcscpy(m_strIISServer, strIISServer);
   }
}

void CInternetThread::SetServerPath(LPTSTR strPath)
{
   if (m_strPath)
		delete []m_strPath;

   if (strPath)
   {
	  m_strPath = (LPTSTR) new TCHAR[_tcslen(strPath)+1];
	  _tcscpy(m_strPath, strPath);
   }
}

// Verify that rAddress is partially valid. Start the worker thread to get a web page.
DWORD CInternetThread::PostData(HWND hWnd)
{

	int iRetryCount;
	UINT uiRetVal;
	int iExit;

	iExit =0;
	iRetryCount = 0;
	uiRetVal = RWZ_POST_FAILURE;

	if (!m_strIISServer || !m_strPath)
	{
      DisplayMessage ("IIS Server path not found ");
    }
	/*
	do {
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\nRetry Posting " << iRetryCount+1  << flush;
		#endif
	   uiRetVal = _PostDataWorker();

	   if(uiRetVal != RWZ_POST_SUCCESS) {
		   iRetryCount++;
	   }else {
		   iExit = 1;
	   }
	   if( uiRetVal == RWZ_POST_WITH_SSL_FAILURE) {
		   // Do not Retry if it is an SSL problem
		   iExit= 1;
	   }


	   if(iRetryCount > RWZ_POST_MAX_RETRY ){
		   iExit = 1;
	   }

   }while(!iExit);
   **/
	uiRetVal = _PostDataWorker(hWnd);
   return uiRetVal;
	
}


// This is the thread function.
//
UINT CInternetThread::PostDataThread(LPVOID pvThread)
{
	
   CInternetThread* pInternetThread = (CInternetThread*) pvThread ;
   if (pInternetThread == NULL || (!pInternetThread->m_strIISServer))
   {
      return FALSE;
   }

   return pInternetThread->_PostDataWorker(NULL) ;

}


// This is where all of the actually Internet work is done.
UINT CInternetThread::_PostDataWorker(HWND hWnd)
{
	UINT uiResult = RWZ_POST_FAILURE;
	BOOL bRead;
	HINTERNET hConnect;
	HINTERNET hHttpFile;
	_TCHAR	szHeader[240];
	BOOL bSendRequest;
	DWORD dwCL=0;
	DWORD dwLengthBufQuery ;
	DWORD dwInfoLevel;
	BOOL bQuery;
	CHAR	pBuffer [MAX_PATH] ; // ?? decide with Steve on Bugffer Sz
	DWORD dwBytesRead ;
	// Variables for the SSL / Normal operation
	INTERNET_PORT	nServerPort;
	DWORD			dwFlags;

	// Added for Proxy Server
	LPTSTR  pUserName;
	LPTSTR  pPassword;
	LPTSTR  pProxyServerName;
	pUserName		 =_T("");
	pPassword		 =_T("");
	pProxyServerName =NULL;



	if(m_bPostWithSSL){
		nServerPort	=	INTERNET_DEFAULT_HTTPS_PORT;
		dwFlags		=	INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_SECURE;
	}else {
		nServerPort	=	INTERNET_INVALID_PORT_NUMBER;
		dwFlags		=	INTERNET_FLAG_DONT_CACHE;
	}

	#ifdef _LOG_IN_FILE
				RW_DEBUG << "\nPost Data:\n" << flush;
	#endif

	if (m_hSession == NULL){
      // Initialize the Internet Functions.
		m_hSession = ATK_InternetOpen(_T("Registration Wizard"),
		                              m_dwAccessType,
									  pProxyServerName,
			                          NULL,
					                  0		
									  );

		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n\tInternet Open:" << m_hSession << flush;
		#endif
		
		if (!Succeeded(m_hSession, "InternetOpen"))
		{
			goto EndFn;
		}
   }

   hConnect = ATK_InternetConnect(m_hSession,
                                          m_strIISServer,
										  nServerPort,
										  pUserName, //	 m_UserName, Changed on 2/4/98 for IE Proxy Auth
										  pPassword, //  m_Password,
                                          INTERNET_SERVICE_HTTP,
                                          0,
                                          0);
										


	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n\tInternet Connection:" << ConvertToANSIString(m_strIISServer) << flush;
	//	RW_DEBUG << "\n\tUserName :" << ConvertToANSIString(m_UserName) << flush;
	//	RW_DEBUG << "\n\tPassword :" << ConvertToANSIString(m_Password) << flush;
	#endif
	
	if (!Succeeded(hConnect, "InternetConnect"))
	{
		goto EndFn;
	}

	hHttpFile = ATK_HttpOpenRequest(hConnect,
                                              _T("POST"),
                                              m_strPath,
                                              HTTP_VERSION,
                                              NULL,
                                              NULL, //szAcceptType,
                                              dwFlags,//INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_SECURE,
                                              0) ;
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n\t\tInternet Post :" << ConvertToANSIString(m_strPath) << flush;
	#endif
	
	if (! Succeeded(hHttpFile, "HttpOpenRequest"))
	{
		::InternetCloseHandle(hConnect);
		goto EndFn;
	}

	_tcscpy(szHeader, _T("Accept: */*\nContent-Type: application/x-www-form-urlencoded"));
	bSendRequest = ATK_HttpSendRequest(hHttpFile,
	szHeader, -1L , m_strBuffer, m_dwBufferLen);

	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n\t\tSendData:" << m_strBuffer << flush;
	#endif

	if (!Succeeded1(bSendRequest, "HttpSendRequest"))
	{
		::InternetCloseHandle(hConnect);
		goto EndFn;
	}

	// Get size of file.
	dwInfoLevel = HTTP_QUERY_CONTENT_TRANSFER_ENCODING;
	dwLengthBufQuery = sizeof( DWORD);
	bQuery = ATK_HttpQueryInfo(hHttpFile,
                          HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,
							&dwCL,
                           &dwLengthBufQuery,
                           NULL) ;
			
	#ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Query ContentLength : " << dwCL  << flush;
	#endif
	
	if (! Succeeded1(bQuery, "HttpQueryInfo") )
	{
		::InternetCloseHandle(hConnect);
		goto EndFn;
	}
	memset(pBuffer,0,MAX_PATH);

	bRead = ::InternetReadFile(hHttpFile,	
									pBuffer,	
									MAX_PATH, 	
									&dwBytesRead);	

	#ifdef _LOG_IN_FILE
		RW_DEBUG <<"\n ReturnBuffer " <<  pBuffer << flush;
	#endif
	
	if (!Succeeded1(bRead, "InternetReadFile"))
	{
		DisplayMessage("HTTP POST FAILURE ...");
			::InternetCloseHandle(hConnect);
		goto EndFn;
	}
	
	if(pBuffer[0] == _T('0' ))
	{
		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Post Successful" << flush;
		#endif

		uiResult = RWZ_POST_SUCCESS;
	}
	else {
		// 438
		if ( (pBuffer[0] == _T('4')) &&  (pBuffer[1] == _T('3')) ) {
			uiResult = RWZ_POST_MSN_SITE_BUSY;
			#ifdef _LOG_IN_FILE
				RW_DEBUG << "\n Post Failure " << flush;
			#endif

		}
		else {
		uiResult = RWZ_POST_WITH_SSL_FAILURE;

		#ifdef _LOG_IN_FILE
			RW_DEBUG << "\n Post with SSL  Failure " << flush;
		#endif
		}
	}

	pBuffer[dwBytesRead] = 0 ;
	::InternetCloseHandle(hConnect);


EndFn:
   return uiResult ;
}

DWORD InvokePost(HWND hWnd, CInternetThread *p)
{
	return p->PostData(hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\tcp.h ===
#ifndef __TCP_h__
#define __TCP_h__
/**************************************************************************

   File:          icw.h
   
   Description:   

**************************************************************************/
// === Structures Required by the ICMP.DLL ====================================

typedef struct {
   unsigned char Ttl;                                           // Time To Live
   unsigned char Tos;                                        // Type Of Service
   unsigned char Flags;                                      // IP header flags
   unsigned char OptionsSize;                  // Size in bytes of options data
   unsigned char *OptionsData;                       // Pointer to options data
} IP_OPTION_INFORMATION, * PIP_OPTION_INFORMATION;


typedef struct {
   DWORD Address;                                           // Replying address
   unsigned long  Status;                                       // Reply status
   unsigned long  RoundTripTime;                         // RTT in milliseconds
   unsigned short DataSize;                                   // Echo data size
   unsigned short Reserved;                          // Reserved for system use
   void *Data;                                      // Pointer to the echo data
   IP_OPTION_INFORMATION Options;                              // Reply options
} IP_ECHO_REPLY, * PIP_ECHO_REPLY;


typedef	HANDLE (WINAPI *ICMPCREATEFILE)(VOID);
typedef	BOOL   (WINAPI *ICMPCLOSEHANDLE)(HANDLE);
typedef	DWORD  (WINAPI *ICMPSENDECHO )( 
									HANDLE, DWORD, LPVOID, WORD,
                                    PIP_OPTION_INFORMATION, LPVOID, 
                                    DWORD, DWORD 
									   );

#ifdef __cplusplus
extern "C" 
{
#endif
	DWORD  PingHost();
	BOOL Ping(LPSTR szIPAddress);
	BOOL CheckHostName(LPSTR szIISServer);

#ifdef __cplusplus
}
#endif	

#endif	// __TCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\sysinv\resource.h ===
//-------------------------------------------------
// String Resource ID
//-------------------------------------------------
#define IDS_OEM_INIFILE                 1001
#define IDS_OEM_INISECTION              1002
#define IDS_OEM_INIKEY                  1003
#define IDS_PROCESSOR_ENTRY             1004
#define IDS_CPU_VENDOR_ENTRY            1005
#define IDS_CPU_ENTRY                   1006
#define IDS_PROCESSOR_386               1007
#define IDS_PROCESSOR_486               1008
#define IDS_PROCESSOR_PENTIUM           1009
#define IDS_PROCESSOR_MIPS_R4000        1010
#define IDS_PROCESSOR_ALPHA_21064       1011
#define IDS_SIZE_SUFFIX1                1012
#define IDS_SIZE_SUFFIX2                1013
#define IDS_PLATFORM_WIN                1014
#define IDS_PLATFORM_WINNT              1015
#define IDS_PLATFORM_WIN95              1016
#define IDS_PRODUCT_NAME                1017
#define IDS_PRODUCT_VERSION             1018
#define IDS_PRODUCT_VERSION_DISPLAY     1019
#define IDS_DRV525_0360                 1020
#define IDS_DRV525_1200                 1021
#define IDS_DRV350_0720                 1022
#define IDS_DRV350_1440                 1023
#define IDS_DRV350_2880                 1024
#define IDS_REMOVABLE_MEDIA_ENTRY       1025
#define IDS_REMOVABLE_MEDIA_VALUE       1026
#define IDS_MASS_STRORAGE_ENTRY         1027
#define IDS_OEM_INIKEY2                 1028
#define IDS_ALPHA_PROCESSOR             1029
#define IDS_ALPHA_ARCHITECTURE          1030
#define IDS_ALPHA_IDENTIFIER            1031
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\util.h ===
/**************************************************************************

   File:          util.h
   
   Description:   

**************************************************************************/
#include <tchar.h>

#ifdef __cplusplus
extern "C" 
{
#endif

	BOOL GetRegKeyValue(HINSTANCE hInstance, HKEY hRootKey, LPTSTR szBaseKey,int valueStrID, LPTSTR szValue);
	void DisplayMessage(LPCSTR szMessage, LPCSTR szFormat=0);
	BOOL Succeeded(HANDLE h, LPCSTR strFunctionName);
	BOOL Succeeded1(BOOL h, LPCSTR strFunctionName);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\regwizpost\util.cpp ===
#include <windows.h>
#include <stdio.h>
#include "util.h"
#include "rw_common.h"



/*********************************************************************
Looks for a subkey, under the Registration Database key given in the
szBaseKey parameter, of the form "0000", "0001", etc.  The numerical
equivalent of the subkey is determined by the index value given in
the enumIndex parameter.  The value attached to the valueName
specified in the string resource whose ID is given in valueStrID will
be returned in szValue.

Returns: FALSE if the key specified is not found. 
**********************************************************************/
BOOL GetRegKeyValue(HINSTANCE hInstance, HKEY hRootKey, LPTSTR szBaseKey,int valueStrID, LPTSTR szValue)
{
	BOOL returnVal = FALSE;
	HKEY hKey;
	LONG regStatus = RegOpenKeyEx(hRootKey, szBaseKey, 0, KEY_READ,&hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		_TCHAR szValueName[128];
		//LoadString(hInstance,valueStrID,szValueName,128);
		_tcscpy(szValueName, _T("InternetProfile"));

		unsigned long infoSize = 255;
		//regStatus = RegQueryValueEx(hKey, szValueName, NULL, 0, (unsigned char*) szValue, &infoSize);
		regStatus = RegQueryValueEx(hKey, szValueName, NULL, 0, (LPBYTE) szValue, &infoSize);
		if (regStatus == ERROR_SUCCESS)
		{
			returnVal = TRUE;
		}
		RegCloseKey(hKey);
	}
	return returnVal;
}


void DisplayMessage(LPCSTR szMessage, LPCSTR szFormat) 
{
#ifdef _LOG_IN_FILE
   if (szFormat)
   {
      DWORD dwError = GetLastError() ;
      CHAR errString[1024] ;
	  sprintf(errString, szFormat, szMessage);
	  RW_DEBUG << "\n " << errString << flush;
   }
   else
   {
	   RW_DEBUG << "\n" << szMessage << flush;
   }
#endif
}

BOOL Succeeded1(BOOL h, LPCSTR strFunctionName)
{
   if (h == FALSE)
   {
	  char errString[1024] ;
	  sprintf(errString, "%s returns error %u",
				strFunctionName, GetLastError());

	  #ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Succeeded " << errString << flush;
	  #endif 

      return FALSE;
	
   }
   else
   {
      return TRUE ;
   }
}

BOOL Succeeded(HANDLE h, LPCSTR strFunctionName)
{
   if (h == NULL)
   {
	  char errString[1024] ;
      sprintf(errString, "%s returns error %u", 
				strFunctionName, GetLastError());

	  #ifdef _LOG_IN_FILE
		RW_DEBUG << "\n Succeeded " << errString << flush;
	  #endif 

      return FALSE;
   }
   else
   {
      return TRUE ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\rundll32\precomp.h ===
#ifndef STRICT
#define STRICT
#endif

#define _INC_OLE
#include <windows.h>
#undef _INC_OLE

#include <shell2.h>

#define IDI_DEFAULT     100

#define IDS_UNKNOWNERROR        0x100

#define IDS_LOADERR             0x300

#define IDS_GETPROCADRERR       0x400
#define IDS_CANTLOADDLL         0x401
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\sysinv\sysinv.c ===
/*********************************************************************
 * Hardware inventory check.  Works with Register Wizard 
 *
 * 02/20/97 - Denny Dong	Take the code from Sysinv.cpp
 * Copyright (c) 1998   Microsoft Corporation
 * 7/20/98  - Modified to get driver file name for Mouse,Sound card along with device names
              SCSI Adapter is added to the system inventory list. 
			  List of  Devices where Driver file info is gathered
				1) Mouse ( Pointing Device)
				2) Sound Card
				3) SCSI Adapter
			 Dispaly resolution is changed to  give additional information about color depth	
*  8/6/98   Prefix the Display Adapter with Driver string in the color resolution   
   8/17/98  Display Color Depth bug if Color depth is 32 bits aor more is fixed.The value is increased to DWORD LONG for storing the value
   3/9/99  GetSystemInformation() care is teken to release SetupAPI.Dll 's Buffer 
   5/27/99 ProcessType info for ALPHA  will be taken from the folloeing Registry Key
   HKLM\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment 
   - PROCESSOR_ARCHITECTURE"
   - PROCESSOR_IDENTIFIER
 *********************************************************************/

#include <Windows.h>
#include <stdio.h>
#include "sysinv.h"
#include "resource.h"
#include "SETUPAPI.H"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define ARRAYSIZE(x)    (sizeof(x) / sizeof(x[0]))

// The packed structures below get messed up with optimizations turned on
#pragma optimize( _T(""), off )

typedef struct _DEVIOCTL_REGISTERS
{
    DWORD reg_EBX;
    DWORD_PTR reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DEVIOCTL_REGISTERS, *PDEVIOCTL_REGISTERS;

#define MAX_SEC_PER_TRACK	64
#pragma pack(1)
typedef struct _DEVICEPARAMS
{
	TBYTE	dpSpecFunc;
	TBYTE	dpDevType;
	WORD	dpDevAttr;
	WORD	dpCylinders;
	TBYTE	dpMediaType;
	WORD	dpBytesPerSec;
	TBYTE	dpSecPerClust;
	WORD	dpResSectors;
	TBYTE	dpFATS;
	WORD	dpRootDirEnts;
	WORD	dpSectors;
	TBYTE	dpMedia;
	WORD	dpFATsecs;
	WORD 	dpSecsPerTrack;
	WORD	dpHeads;
	DWORD	dpHiddenSecs;
	DWORD	dpHugeSectors;
    TBYTE    A_BPB_Reserved[6];			 // Unused 6 BPB bytes
    TBYTE    TrackLayout[MAX_SEC_PER_TRACK * 4 + 2];
}DEVICEPARAMS,*PDEVICEPARAMS;
#pragma pack()

#define VWIN32_DIOC_DOS_IOCTL 1
#define kDrive525_0360   0
#define kDrive525_1200   1
#define kDrive350_0720   2
#define kDrive350_1440   7
#define kDrive350_2880   9
#define kDriveFIXED      5
#define kDriveBadDrvNum  0xFF

// Dynamic Registry enumeration declarations
#define DYNDESC_BUFFERSIZE	128
static _TCHAR vrgchDynDataKey[] = _T("Config Manager\\Enum");
static _TCHAR vrgchLocalMachineEnumKey[] = _T("Enum");
static _TCHAR vrgchHardWareKeyValueName[] = _T("HardWareKey");
static _TCHAR vrgchDriverValueName[] = _T("Driver");
static _TCHAR vrgchDeviceDescValueName[] = _T("DeviceDesc");
static _TCHAR vrgchDynNetExclusion[] = _T("Dial-Up Adapter");
static _TCHAR vrgchHardwareIDValueName[] = _T("HardwareID");
static BOOL vfIsFPUAvailable = TRUE;
static _TCHAR vrgchDynProcessorName[DYNDESC_BUFFERSIZE];
typedef enum
{
	dynNet		= 0,
	dynModem	= 1,
	dynMouse	= 2,
	dynCDRom	= 3,	
	dynMedia	= 4,
	dynSCSI     = 5,  
	dynSystem	= 6,
	dynEnd
}DYN;

static _TCHAR vrgchDynKey[dynEnd][12] = 
{
	_T("Net"),
	_T("Modem"),
	_T("Mouse"),
	_T("CDROM"),
	_T("Media"),
	_T("SCSIAdapter"),
	_T("System")
};

static _TCHAR vrgchDynDesc[dynEnd][DYNDESC_BUFFERSIZE] =
{
	_T(""),
	_T(""),
	_T(""),
	_T(""),
	_T(""),
	_T("")
};

static HANDLE hInstance = NULL;
static TCHAR  sszDriverFilename[256];

// Private functions
void EnumerateDynamicDevices( void );
void ProcessSystemDevices(LPTSTR rgchSystemKey);
BOOL GetProcessorTypeStringFromRegistry(LPTSTR);
void GetProcessorTypeStringFromSystem(LPTSTR);
UINT GetDriveTypeInv(UINT nDrive);
BOOL GetDeviceParameters(PDEVICEPARAMS pDeviceParams, UINT nDrive);
BOOL DoIOCTL(PDEVIOCTL_REGISTERS preg);
void GetSystemInformation(LPCTSTR szDeviceID,LPTSTR szDeviceName, LPTSTR szDriverName);
BOOL WINAPI GetSystemInventoryA(INT type, LPSTR szInventory);


/*
 * Function:
 *	BOOL DllMain(HINSTANCE, DWORD, LPVOID)
 *
 * Purpose:
 *	Entry point of DLL.
 */
BOOL WINAPI DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
		hInstance = hDll;
	return TRUE;
}

BOOL WINAPI GetSystemInventoryW(INT type, LPWSTR szInventory)
{

	/*char szInventory[1024];
	wszInventory[0] = 0;
	if (!GetSystemInventoryA(type, szInventory))
		return FALSE;
	if (type == INV_COPRECESSOR)
	{
		wszInventory[0] = szInventory[0];
		return TRUE;
	}
	if (szInventory[0] == 0)
		return TRUE;
	if (MultiByteToWideChar(CP_ACP,0,szInventory,-1,wszInventory,256) == 0)
		return FALSE;
	return TRUE;
	*/
	szInventory[0] = _T('\0');
	
	switch (type)
	{
	case INV_OEM:
		GetOEMString(szInventory);
		return TRUE;
	case INV_PROCESSORTYPE:
		GetProcessorTypeString(szInventory);
		return TRUE;
	case INV_TOTALMEMORY:
		GetTotalMemoryString(szInventory);
		return TRUE;
	case INV_TOTALHDSPACE:
		GetTotalHardDiskSpaceString(szInventory);
		return TRUE;
	case INV_DISPRESOLUTION:
		GetDisplayResolutionString(szInventory);
		return TRUE;
	case INV_DISPCOLORDEPTH:
		GetDisplayColorDepthString(szInventory);
		return TRUE;
	case INV_WINVERSION:
		GetWindowsVersionString(szInventory);
		return TRUE;
	case INV_NETCARD:
		GetNetworkCardString(szInventory);
		return TRUE;
	case INV_MODEM:
		GetModemString(szInventory);
		return TRUE;
	case INV_POINTDEVICE:
		GetPointingDeviceString(szInventory);
		return TRUE;
	case INV_CDROM:
		GetCDRomString(szInventory);
		return TRUE;
	case INV_SOUNDCARD:
		GetSoundCardString(szInventory);
		return TRUE;
	case INV_REMOVEABLEMEDIA:
		GetRemoveableMediaString(szInventory);
		return TRUE;
	case INV_COPRECESSOR:
		szInventory[0] = IsCoProcessorAvailable() ? 1 : 0;
		szInventory[1] = 0;
		return TRUE;
	case INV_SCSIADAPTER :
		GetScsiAdapterString(szInventory);
		return TRUE;
	case INV_DISPLAY_ADAPTER:
		GetDisplayAdapter(szInventory);
		return TRUE;
		break;
	case INV_DISPLAY_WITH_RESOLUTION:
		GetDisplayAdapterWithResolution(szInventory);
		return TRUE;
		break;
	default:
		break;
	}
	return FALSE;
}

BOOL WINAPI GetSystemInventoryA(INT type, LPSTR szInventory)
{
	BOOL bRet;
	int    iMaxOutStrLen;
	ULONG  ulNoOfChars;
	WCHAR  wszInventory[1024];
	iMaxOutStrLen = 256;

	bRet = GetSystemInventoryW(type, wszInventory);

	if(wszInventory[0]) {
		ulNoOfChars = wcslen(wszInventory)+1;
		memset((void *) szInventory,0,iMaxOutStrLen);
		if(WideCharToMultiByte(CP_ACP,0,wszInventory,ulNoOfChars,szInventory,
		iMaxOutStrLen,NULL,NULL) == 0) {
			//dwError = GetLastError();
			//
		}
		
	}else {
		// if empty string
		szInventory[0] = '\0';
	}
	return bRet;
}


/***************************************************************************
Returns TRUE if the file specified by the given pathname actually exists.
****************************************************************************/
BOOL FileExists(LPTSTR szPathName)
{
	SECURITY_ATTRIBUTES sa;
	HANDLE fileHandle;
	BOOL retValue;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;

	fileHandle = CreateFile(szPathName,GENERIC_READ,0,&sa,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	if (fileHandle == INVALID_HANDLE_VALUE)
	{
		retValue = FALSE;
	}
	else
	{
		retValue = TRUE;
		CloseHandle(fileHandle);
	}
	return retValue;
}

/*********************************************************************
Returns a string containing the name of the Original Equipment
Manufacturer.
**********************************************************************/
void GetOEMString(LPTSTR szOEM)
{
	_TCHAR szPathName[512];
	DWORD oemLen;
	UINT pathLen = GetSystemDirectory(szPathName, 256);
	szOEM[0] = 0;
	if (pathLen > 0)
	{
		_TCHAR szIniName[256];
		LoadString(hInstance,IDS_OEM_INIFILE,szIniName,256);
		_tcscat(szPathName,_T("\\"));
		_tcscat(szPathName,szIniName);

		if (FileExists(szPathName))
		{
			_TCHAR szIniSection[64];
			_TCHAR szIniKey[64];
			_TCHAR szDefault[28];
			_TCHAR szModelTmp[128];
			LoadString(hInstance,IDS_OEM_INISECTION,szIniSection,64);
			LoadString(hInstance,IDS_OEM_INIKEY,szIniKey,64);
			szDefault[0] = 0;
			oemLen = GetPrivateProfileString(szIniSection,szIniKey,szDefault,szOEM,sizeof(szOEM)/sizeof(TCHAR),szPathName);

			LoadString(hInstance,IDS_OEM_INIKEY2,szIniKey,64);
			szDefault[0] = 0;
			oemLen = GetPrivateProfileString(szIniSection,szIniKey,szDefault,szModelTmp,sizeof(szModelTmp)/sizeof(TCHAR),szPathName);

			if(oemLen)
			{
				_tcscat(szOEM,_T(" ,"));
				_tcscat(szOEM,szModelTmp);
			}

		}
   }
}


/*********************************************************************
Returns a string that describes the processor in the user's system:
- "80386"
- "80486"
- "PENTIUM"
- "INTEL860"
- "MIPS_R2000"
- "MIPS_R3000"
- "MIPS_R4000"
- "ALPHA_21064"
Note: you must allocate at least 64 bytes for the buffer pointed to
by the szProcessor parameter.
**********************************************************************/
void GetProcessorTypeString(LPTSTR szProcessor)
{
	
	_TCHAR szTmp[256];
	_TCHAR szData[256]; 
	_TCHAR szString[256]; 
	HKEY  hKey; 
	LONG regStatus;
	DWORD dwInfoSize;

	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);

	szProcessor[0] = 0;
	if( PROCESSOR_ALPHA_21064 == systemInfo.dwProcessorType) {
	 
		// Alpha 
		// Default Value 
		LoadString(hInstance, IDS_PROCESSOR_ALPHA_21064,szProcessor,64);

		// Try to get from Registry
		LoadString(hInstance, IDS_ALPHA_PROCESSOR,szTmp,256);
		regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTmp, 0, KEY_READ, &hKey);
		if (regStatus != ERROR_SUCCESS) 
		return;
		
		dwInfoSize = 256;
		LoadString(hInstance, IDS_ALPHA_ARCHITECTURE, szString, 256);

		RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szData, &dwInfoSize);
		_tcscpy(szProcessor, szData);
		_tcscat(szProcessor, _T(", "));
		dwInfoSize = 256;
		
		LoadString(hInstance, IDS_ALPHA_IDENTIFIER, szString, 256);
		
		RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szData, &dwInfoSize);
		_tcscat(szProcessor, szData);
  	    RegCloseKey(hKey);



	}else {
		if (!GetProcessorTypeStringFromRegistry(szProcessor))
		GetProcessorTypeStringFromSystem(szProcessor);
	}
}


/*********************************************************************
Returns a string that describes the processor in the user's system:
- "80386"
- "80486"
- "PENTIUM"
- "INTEL860"
- "MIPS_R2000"
- "MIPS_R3000"
- "MIPS_R4000"
- "ALPHA_21064"
Note: you must allocate at least 64 bytes for the buffer pointed to
by the szProcessor parameter.
**********************************************************************/
void GetProcessorTypeStringFromSystem(LPTSTR szProcessor)
{
	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);
	switch (systemInfo.dwProcessorType)
	{
		case PROCESSOR_INTEL_386:
			LoadString(hInstance, IDS_PROCESSOR_386,szProcessor,64);
			break;
		case PROCESSOR_INTEL_486:
			LoadString(hInstance, IDS_PROCESSOR_486,szProcessor,64);
			break;
		case PROCESSOR_INTEL_PENTIUM:
			LoadString(hInstance, IDS_PROCESSOR_PENTIUM,szProcessor,64);
			break;
/*		case PROCESSOR_INTEL_860:
			LoadString(hInstance, IDS_PROCESSOR_860,szProcessor,64);
			break;
		case PROCESSOR_MIPS_R2000:
			LoadString(hInstance, IDS_PROCESSOR_MIPS_R2000,szProcessor,64);
			break;
		case PROCESSOR_MIPS_R3000:
			LoadString(hInstance, IDS_PROCESSOR_MIPS_R3000,szProcessor,64);
			break;														   */
		case PROCESSOR_MIPS_R4000:
			LoadString(hInstance, IDS_PROCESSOR_MIPS_R4000,szProcessor,64);
			break;
		case PROCESSOR_ALPHA_21064:
			LoadString(hInstance, IDS_PROCESSOR_ALPHA_21064,szProcessor,64);
			break;
		default:
			szProcessor[0] = 0;
			break;
	}
}


/*********************************************************************
Retrieves the name of the processor in use from the Registry.

Returns:
FALSE if the proper key in the Registry does not exist.
**********************************************************************/
BOOL GetProcessorTypeStringFromRegistry(LPTSTR szProcessor)
{
	HKEY  hKey; 
	_TCHAR uszRegKey[256];
	LONG regStatus;
	DWORD dwInfoSize;
	LoadString(hInstance, IDS_PROCESSOR_ENTRY, uszRegKey, 256);

	regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, uszRegKey, 0, KEY_READ, &hKey);
	if (regStatus != ERROR_SUCCESS) 
		return FALSE;
	else
	{
		_TCHAR szData[256]; 
		_TCHAR szString[256]; 
		dwInfoSize = 256;
		LoadString(hInstance, IDS_CPU_VENDOR_ENTRY, szString, 256);

		RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szData, &dwInfoSize);
		_tcscpy(szProcessor, szData);
		_tcscat(szProcessor, _T(", "));
		dwInfoSize = 256;
		
		LoadString(hInstance, IDS_CPU_ENTRY, szString, 256);
		
		RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szData, &dwInfoSize);
		_tcscat(szProcessor, szData);
  	    RegCloseKey(hKey);
	}
	return TRUE;
}

/*********************************************************************
Returns a string that describes the amount of physical RAM available.

Note: you must allocate at least 64 bytes for the buffer pointed to
by the szTotalMemory parameter.
**********************************************************************/
void GetTotalMemoryString(LPTSTR szTotalMemory)
{
	_TCHAR szSuffix[32];
	MEMORYSTATUS memoryStatus;
	DWORD_PTR totalRam;
	memoryStatus.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus(&memoryStatus);
	totalRam = memoryStatus.dwTotalPhys / 1024;
	LoadString(hInstance, IDS_SIZE_SUFFIX1, szSuffix, 31);
	_stprintf(szTotalMemory, _T("%li %s"), totalRam, szSuffix);
}

/*********************************************************************
Returns a string that describes the total amount of disk space
(in KB) available on all hard disk drives attached to the user's
system.

Note: you must allocate at least 64 bytes for the buffer pointed to
by the szTotalMemory parameter.
**********************************************************************/
void GetTotalHardDiskSpaceString(LPTSTR szTotalHardDiskSpace)
{
	_TCHAR szSuffix[32];
	LONG totalHardDiskSpace = GetTotalHardDiskSpace();
	LoadString(hInstance, IDS_SIZE_SUFFIX1, szSuffix, 31);
	_stprintf(szTotalHardDiskSpace, _T("%li %s"), totalHardDiskSpace, szSuffix);
}


/*********************************************************************
Returns a string that describes the horizontal x vertical resolution
(in pixels) of the user's main screen.
It also prefixes teh Display adapter Name
**********************************************************************/
void GetDisplayResolutionString(LPTSTR szDisplayResolution)
{
	int horizResolution, vertResolution;
	int colorBits;
	DWORDLONG colorDepth;
	_TCHAR szSuffix[24];
	char czDispAdapter[256];
	
	
	szSuffix[0] = _T('\0'); // 
	GetDisplayCharacteristics(&horizResolution, &vertResolution, NULL);
	// Color Depth 
	GetDisplayCharacteristics(NULL,NULL,&colorBits);
	colorDepth = (DWORDLONG) 1 << colorBits;
	
	szSuffix[0] = 0;
	if (colorBits > 15)
	{
		colorDepth = colorDepth / 1024;
		LoadString(hInstance,IDS_SIZE_SUFFIX2,szSuffix,24);
	}
	_stprintf(szDisplayResolution, _T("%i x %i x %I64d%s"), horizResolution, vertResolution, colorDepth,szSuffix);
}

void GetDisplayAdapterWithResolution( LPTSTR szDisplayWithResolution)
{
	TCHAR czDispAdapter[256];
	TCHAR czResolution[128];

	GetDisplayAdapter(czDispAdapter);
	GetDisplayResolutionString(czResolution);
	if(czDispAdapter[0] != _T('\0') )  {
		_tcscpy(szDisplayWithResolution,czDispAdapter);
		_tcscat(szDisplayWithResolution,_T("  "));
		_tcscat(szDisplayWithResolution,czResolution);
	}else {
		szDisplayWithResolution[0] = '\0';
	}

}

/*********************************************************************
Returns a string that describes the color depth (number of colors
available).
// We are  getting the 
**********************************************************************/
void GetDisplayColorDepthString(LPTSTR szDisplayColorDepth)
{
	int colorBits;
	LONG colorDepth;
	_TCHAR szSuffix[24];

	GetDisplayCharacteristics(NULL,NULL,&colorBits);
	colorDepth = 1 << colorBits;
	
	szSuffix[0] = 0;
	if (colorBits > 15)
	{
		colorDepth = colorDepth / 1024;
		LoadString(hInstance,IDS_SIZE_SUFFIX2,szSuffix,24);
	}
	_stprintf(szDisplayColorDepth,_T("%li%s"),colorDepth,szSuffix);
}


/*********************************************************************
Returns a string describing the platform and verson of the currently
operating Windows OS.
**********************************************************************/
void GetWindowsVersionString(LPTSTR szVersion)
{
	LONG platform, majorVersion, minorVersion, dwBuildNo;
	_TCHAR szPlatform[64];
	_TCHAR szOsName[128];
	HKEY  hKey; 
	_TCHAR uszRegKey[256];
	LONG dwStatus;
	DWORD dwInfoSize;
	_TCHAR szBuildNo[64];
	_TCHAR szString[64];
	int idsPlatform;

	GetWindowsVersion(&platform, &majorVersion, &minorVersion, &dwBuildNo);

	if (platform == VER_PLATFORM_WIN32_WINDOWS)
		idsPlatform = IDS_PLATFORM_WIN95;
	else if (platform == VER_PLATFORM_WIN32_NT)
		idsPlatform = IDS_PLATFORM_WINNT;
	else
		idsPlatform = IDS_PLATFORM_WIN;
	
	if (idsPlatform == IDS_PLATFORM_WIN95)
	{
		if (SUCCEEDED(StringCchCopy(uszRegKey,
                                            ARRAYSIZE(uszRegKey),
                                            _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")))    &&
		    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 uszRegKey,
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hKey) == ERROR_SUCCESS)
                {
			dwInfoSize = sizeof(szPlatform);
			LoadString(hInstance, IDS_PRODUCT_NAME, szString, ARRAYSIZE(szString));
			RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szPlatform, &dwInfoSize);

  		        dwInfoSize = sizeof(szBuildNo);
			LoadString(hInstance, IDS_PRODUCT_VERSION, szString, ARRAYSIZE(szString));
			RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szBuildNo, &dwInfoSize);

	    	        RegCloseKey(hKey);
		}
                else
                {
                        LoadString(hInstance, idsPlatform, szPlatform, ARRAYSIZE(szPlatform));
                }

		LoadString(hInstance, IDS_PRODUCT_VERSION_DISPLAY, szString, ARRAYSIZE(szString));

		StringCchCopy(szVersion, ARRAYSIZE(szVersion), szPlatform);
		StringCchCat(szVersion, ARRAYSIZE(szVersion), szString);
		StringCchCat(szVersion, ARRAYSIZE(szVersion), szBuildNo);
	}
	else
	{
		// get OS name from Registry
		if (SUCCEEDED(StringCchCopy(uszRegKey,
                                            ARRAYSIZE(uszRegKey),
                                            _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"))) &&
		    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 uszRegKey,
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hKey) == ERROR_SUCCESS)
                {
			dwInfoSize = sizeof(szOsName);
			LoadString(hInstance, IDS_PRODUCT_NAME, szString, ARRAYSIZE(szString));
			RegQueryValueEx(hKey, szString, NULL, 0, (LPBYTE)szOsName, &dwInfoSize);

	       	        RegCloseKey(hKey);
		}


		if (LoadString(hInstance, idsPlatform, szPlatform, ARRAYSIZE(szPlatform)))
                {
                        StringCchPrintf(szVersion,
                                        ARRAYSIZE(szVersion),
                                        szPlatform,
                                        szOsName,
                                        dwBuildNo);
                }
                else
                {
                        LoadString(hInstance, IDS_PRODUCT_VERSION_DISPLAY, szVersion, ARRAYSIZE(szVersion));
                }
	}
}


/*********************************************************************
Returns a string describing the network card installed.  If no card
is installed, an empty string will be returned.
**********************************************************************/
void GetNetworkCardString(LPTSTR szNetwork)
{
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("net"), szNetwork, sszDriverFilename);
	_tcscpy(vrgchDynDesc[dynNet],szNetwork);
}


/*********************************************************************
Returns a string describing the modem (if any) installed. If no modem
is installed, an empty string will be returned.
**********************************************************************/
void GetModemString(LPTSTR szModem)
{

	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("modem"), vrgchDynDesc[dynModem],sszDriverFilename);
	_tcscpy(szModem, vrgchDynDesc[dynModem]);
	

}


/*********************************************************************
Returns a string describing all pointing devices (mouse, tablet, etc.)
available.
**********************************************************************/
void GetPointingDeviceString(LPTSTR szPointingDevice)
{
	TCHAR czTemp[256];
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("mouse"),vrgchDynDesc[dynMouse], sszDriverFilename);
	_tcscpy(szPointingDevice,vrgchDynDesc[dynMouse]);

	if( sszDriverFilename[0] != _T('\0')) {
		// Copy the Driver file Name
		_stprintf(czTemp,_T("  (%s.sys) "),sszDriverFilename);   
		_tcscat(szPointingDevice,czTemp);
	}
	_tcscpy(vrgchDynDesc[dynModem],szPointingDevice);

}


/*********************************************************************
Returns a string describing any CD-Rom devices installed.  If no
CD-ROM device is installed, an empty string will be returned.
**********************************************************************/
void GetCDRomString(LPTSTR szCDRom)
{
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("cdrom"),vrgchDynDesc[dynCDRom],sszDriverFilename);
	_tcscpy(szCDRom,vrgchDynDesc[dynCDRom]);
}

/*********************************************************************
Returns a string describing any sound card with driver  installed.  If none are
installed, an empty string will be returned.
**********************************************************************/
void GetSoundCardString(LPTSTR szSoundCard)
{
	TCHAR czTemp[256];
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("media"),vrgchDynDesc[dynMedia],sszDriverFilename);
	_tcscpy(szSoundCard,vrgchDynDesc[dynMedia]);

	if( sszDriverFilename[0] != _T('\0')) {
		// Copy the Driver file Name
		_stprintf(czTemp,_T("  (%s.sys) "),sszDriverFilename);   
		_tcscat(szSoundCard,czTemp);
	}
	_tcscpy(vrgchDynDesc[dynMedia],szSoundCard);
}

void GetDisplayAdapter( LPTSTR szDisplayAdapter)
{
	TCHAR czTemp[256];
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(_T("Display"),szDisplayAdapter,sszDriverFilename);
	

	if( sszDriverFilename[0] != _T('\0')) {
		// Copy the Driver file Name
		_stprintf(czTemp,_T("  (%s.sys) "),sszDriverFilename);   
		_tcscat(szDisplayAdapter,czTemp);
	}
}

/*
	Returns SCSI Adapter with Driver name persent in the system
*/
void GetScsiAdapterString(LPTSTR szScsiAdapter)
{
	TCHAR czTemp[256];
	sszDriverFilename[0] = _T('\0');
	GetSystemInformation(vrgchDynKey[dynSCSI],vrgchDynDesc[dynSCSI], sszDriverFilename);
	_tcscpy(szScsiAdapter,vrgchDynDesc[dynSCSI]);

	if( sszDriverFilename[0] != _T('\0')) {
		// Copy the Driver file Name
		_stprintf(czTemp,_T("  (%s.sys) "),sszDriverFilename);   
		_tcscat(szScsiAdapter,czTemp);
	}
	_tcscpy(vrgchDynDesc[dynSCSI],szScsiAdapter);

}

/*	Value  -- > "CurrentDriveLetterAssignment"		Data -- > "A"
	Value  -- > "Removable"							Data -- > 01
	Value  -- > "Class"								Data -- > "DiskDrive"*/
#define     REGFIND_ERROR      1
#define     REGFIND_RECURSE    2
#define     REGFIND_FINISH     3

int RegFindValueInAllSubKey(HKEY key, LPCTSTR szSubKeyNameToFind, LPCTSTR szValueToFind, LPTSTR szIdentifier, int nType)
{
	DWORD   dwRet = ERROR_PATH_NOT_FOUND, dwIndex, dwSubkeyLen;
	TCHAR   szSubKey[256], szFloppy[256];
	BOOL    bType = FALSE, bRemovable = FALSE, bPrevMassStorage, bPrevFloppy;
	HKEY    hKey;
	static BOOL bMassStorage = FALSE;
	static BOOL bFloppy = FALSE;
	
	bPrevMassStorage =	bMassStorage;
	bPrevFloppy		=	bFloppy;

	if (szSubKeyNameToFind != NULL)
		dwRet = RegOpenKeyEx(key, szSubKeyNameToFind, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hKey);

	if (dwRet == ERROR_SUCCESS)
	{
		dwIndex = 0;
        while (dwRet == ERROR_SUCCESS )
        {
            dwSubkeyLen = 256;
			dwRet = RegEnumKeyEx(hKey, dwIndex, szSubKey, &dwSubkeyLen,
                           NULL, NULL, NULL, NULL);
 
            if (dwRet == ERROR_NO_MORE_ITEMS)
            {
				_TCHAR		valueName[80];
				DWORD		valueNameSize,valueSize,n = 0;
				TBYTE		value[80];
				
                do
				{
					valueNameSize=80* sizeof(_TCHAR);
					valueSize=80* sizeof(TBYTE);
					dwRet = RegEnumValue(hKey, n, valueName, &valueNameSize,
										 NULL, NULL, (LPBYTE)value, &valueSize);
					if (dwRet == ERROR_SUCCESS)
					{
						if (nType == 1)
						{
							if (!_tcscmp(valueName,_T("Type"))) 
							{
								if (!_tcscmp(szValueToFind,(LPCTSTR)value))
									bType = TRUE;
							}
							if (!_tcscmp(valueName,_T("Identifier"))) 
								_tcscpy(szIdentifier,(LPCTSTR)value);
						}
						else if(nType == 2)
						{
							if (!_tcscmp(valueName,_T("Class"))) 
							{
								if (!_tcscmp(szValueToFind,(LPCTSTR)value))
									bType = TRUE;
							}
							if (!_tcscmp(valueName,_T("DeviceDesc"))) 
							{
// bFloppy and bMassStorage are used for handling the conditions when there are multiple 
// Floppy and mass storage media present.
								_tcscpy(szFloppy,(LPCTSTR)value);
								_tcsupr(szFloppy);
								if(_tcsstr(szFloppy,_T("FLOPPY")) != NULL)
								{
									if(!bFloppy)
									{
										_tcscpy(szFloppy,(LPCTSTR)value);
										bFloppy = TRUE;
									}
								}
								else
// if it is not removable or it is a cdrom the condition for type and removable 
// takes care of it.
								{
									if(!bMassStorage)
										bMassStorage = TRUE;
								}

							}
							if (!_tcscmp(valueName,_T("Removable"))) 
							{
								if (*value == 0x01 )
									bRemovable = TRUE;
							}
						}
						n++;
					}

				} while (dwRet == ERROR_SUCCESS);

				if (nType == 1)
				{
					if(bType)
						return REGFIND_FINISH;
					else
						return REGFIND_RECURSE;
				}
				else if (nType == 2)
				{
					if( bType && bRemovable )
					{
						if (bFloppy != bPrevFloppy )
							_tcscpy(szIdentifier,szFloppy);	
						if (bFloppy && bMassStorage)
						{
							_TCHAR szMassString[64];
							LoadString(hInstance,IDS_MASS_STRORAGE_ENTRY,szMassString,64);
							_tcscat(szIdentifier,szMassString);	
							return REGFIND_FINISH;
						}
						return REGFIND_RECURSE;
					}
// The bMassStorage flag has to be reset to the previous state. 
					else
					{
						bMassStorage = bPrevMassStorage;
						if(bFloppy != bPrevFloppy)
							bFloppy = bPrevFloppy;
						return REGFIND_RECURSE;
					}
				}            
			}
            else
			{
				if (dwRet == ERROR_SUCCESS)
				{
					int nStatus;
					nStatus = RegFindValueInAllSubKey(hKey, szSubKey, szValueToFind, szIdentifier, nType);

					switch(nStatus)
					{
						case REGFIND_FINISH:
							return REGFIND_FINISH;
						case REGFIND_ERROR:
							return REGFIND_ERROR;
						default :
							if (bFloppy != bPrevFloppy)
								bPrevFloppy = bFloppy;
							break;
					}
					dwIndex++;
				}
			}
		}
		RegCloseKey(hKey);
	}
 
	return REGFIND_ERROR;
}

/*********************************************************************
Returns a string describing the capacity and format of removeable
drives.
**********************************************************************/
void GetRemoveableMediaString(LPTSTR szRemoveableMedia)
{
	LONG platform, majorVersion, minorVersion, dwBuildNo;
	GetWindowsVersion(&platform, &majorVersion, &minorVersion, &dwBuildNo);

	if (platform != VER_PLATFORM_WIN32_NT)
	{
		_TCHAR szSubKey[64];
		_TCHAR szSubKeyValue[64];
		LoadString(hInstance, IDS_REMOVABLE_MEDIA_ENTRY, szSubKey, 64);
		LoadString(hInstance, IDS_REMOVABLE_MEDIA_VALUE, szSubKeyValue, 64);
		RegFindValueInAllSubKey(HKEY_LOCAL_MACHINE,szSubKey,szSubKeyValue,szRemoveableMedia,2);
	}
	else
	{
		UINT driveType;
		_TCHAR szDrive[64];
		UINT nDrive;
		const iBufSize = 256;
		szRemoveableMedia[0] = 0;
		for (nDrive = 1; nDrive <= 26; nDrive++)
		{
			szDrive[0] = 0;
			driveType = GetDriveTypeInv(nDrive);
			switch (driveType)
			{
				case kDrive525_0360:
					LoadString(hInstance, IDS_DRV525_0360, szDrive, 64);
					break;
				case kDrive525_1200:
					LoadString(hInstance, IDS_DRV525_1200, szDrive, 64);
					break;
				case kDrive350_0720:
					LoadString(hInstance, IDS_DRV350_0720, szDrive, 64);
					break;
				case kDrive350_1440:
					LoadString(hInstance, IDS_DRV350_1440, szDrive, 64);
					break;
				case kDrive350_2880:
					LoadString(hInstance, IDS_DRV350_2880, szDrive, 64);
					break;
			}
			if (szDrive[0])
			{
				_TCHAR szFormattedDrive[70];
				int iNewStrLen;
				wsprintf(szFormattedDrive,_T("%c: %s"),_T('A') + nDrive - 1,szDrive);
				iNewStrLen = (_tcslen(szRemoveableMedia) +1+ _tcslen(szFormattedDrive) + 1);
				if (iNewStrLen < iBufSize)
				{
					if (szRemoveableMedia[0])
						_tcscat(szRemoveableMedia,_T(", ")); // We added 2 to iNewStrLen above to account to this
					_tcscat(szRemoveableMedia,szFormattedDrive);
				}
			}
		}
	}
}


/*********************************************************************
Returns TRUE if a co-processor is installed in the user's system.
**********************************************************************/
BOOL IsCoProcessorAvailable(void)
{
	EnumerateDynamicDevices();
	return vfIsFPUAvailable;
}


/**********************************************************************
Determines the value associated with the specified Registration
Database key and value name.

Returns:
	The cb of the key data if successful, 0 otherwise.
Notes:
	If hRootKey is NULL, HKEY_CLASSES_ROOT is used for the root
***********************************************************************/
UINT GetRegKeyValue32(HKEY hRootKey, LPTSTR const cszcSubKey, LPTSTR const cszcValueName,
					  PDWORD pdwType, PTBYTE pbData, UINT cbData )
{
	HKEY hSubKey;
	LONG lErr;
	DWORD cbSize = (DWORD)cbData;

	if (hRootKey == NULL)
		hRootKey = HKEY_CLASSES_ROOT;

	lErr = RegOpenKeyEx(hRootKey, cszcSubKey, 0, KEY_READ, &hSubKey);
	if (lErr != ERROR_SUCCESS)
	{
		pdwType[0] = 0;
		return 0;	/* Return 0 if the key doesn't exist */
	}

	lErr = RegQueryValueEx(hSubKey, (LPTSTR)cszcValueName, NULL, pdwType, (LPBYTE)pbData,
						   &cbSize);
	RegCloseKey(hSubKey);
	if (lErr != ERROR_SUCCESS)
	{
		pdwType[0] = 0;
		return 0;	/* Return 0 if the value doesn't exist */
	}

	return (UINT)cbSize;
}

/*********************************************************************
Enumerates through the HKEY_DYN_DATA\Config Manager\Enum branch of
the registry, and retrieves device information for all currently
installed Net cards, modems, pointing devices, CDROMs, and sound
cards.  All this information is stored in the static vrgchDynDesc
global array.
**********************************************************************/
void EnumerateDynamicDevices(void)
{
	HKEY hKey;
	// Open the "HKEY_DYN_DATA\Config Manager\Enum" subkey.
	LONG regStatus = RegOpenKeyEx(HKEY_DYN_DATA, vrgchDynDataKey, 0, KEY_READ, &hKey);
	if (regStatus == ERROR_SUCCESS)
	{
		DWORD dwIndex = 0;
		_TCHAR rgchSubkey[256];
		_TCHAR rgchValue[256];
		DWORD dwSubkeySize;
		LONG lEnumErr;
		DWORD dwType;
		DWORD dwValueSize;
		do
		{
			// Enumerate "HKEY_DYN_DATA\Config Manager\Enum\Cxxxxxxx"
			FILETIME ftLastWrite;
			dwSubkeySize = sizeof(rgchSubkey);
			lEnumErr = RegEnumKeyEx(hKey, dwIndex++, rgchSubkey, &dwSubkeySize,
									NULL,NULL,NULL,&ftLastWrite);
			if (lEnumErr == ERROR_SUCCESS)
			{
				// From each subkey, read the value from the "HardWareKey" value name,
				// and make a new HKEY_LOCAL_MACHINE subkey out of it.
				dwValueSize = GetRegKeyValue32(hKey, rgchSubkey, vrgchHardWareKeyValueName, &dwType,
								(PTBYTE)rgchValue, sizeof(rgchValue) );
				if (dwValueSize > 0 && dwType == REG_SZ)
				{
					_TCHAR rgchDriverKey[256];
					wsprintf(rgchDriverKey,_T("%s\\%s"),vrgchLocalMachineEnumKey,rgchValue);

					// From our HKEY_LOCAL_MACHINE subkey, read the value from the "Driver"
					// value name.
					dwValueSize = GetRegKeyValue32(HKEY_LOCAL_MACHINE, rgchDriverKey, vrgchDriverValueName,
												&dwType, (PTBYTE) rgchValue, sizeof(rgchValue) );
					if (dwValueSize > 0  && dwType == REG_SZ)
					{
						// Get the "main" subkey out of the "driver" value (which is of the
						// form "<main>\xxxx").
						LPTSTR sz = rgchValue;
						WORD wDynIndex = 0;
						BOOL fMatch = FALSE;

						while (*sz && *sz != _T('\\'))
							sz = _tcsinc(sz);
						*sz = 0;

						// If the "main" subkey matches any of our desired device types,
						// we get the description of that device from the "DriverDesc"
						// name value field, and save it in our device array.
						while (wDynIndex < dynEnd && fMatch == FALSE)
						{
							if (vrgchDynDesc[wDynIndex][0] == 0)
							{				
								if (_tcsicmp(vrgchDynKey[wDynIndex], rgchValue) == 0)
								{
									if (wDynIndex == dynSystem)
									{
										ProcessSystemDevices(rgchDriverKey);
										fMatch = TRUE;
									}
									else
									{
										dwValueSize = GetRegKeyValue32(HKEY_LOCAL_MACHINE,rgchDriverKey,
											vrgchDeviceDescValueName, &dwType, (PTBYTE) rgchValue, 
											sizeof(rgchValue) );
										if (dwValueSize > 0  && dwType == REG_SZ)
										{
											if (wDynIndex != dynNet || _tcsicmp(vrgchDynNetExclusion,
												rgchValue) != 0)
											{
												// In case the description value is bigger than our 
												// buffer, truncate it to fit.
												if (DYNDESC_BUFFERSIZE < sizeof(rgchValue))
													rgchValue[DYNDESC_BUFFERSIZE - (1*sizeof(_TCHAR))] = 0;
												_tcscpy(vrgchDynDesc[wDynIndex],rgchValue);
												fMatch = TRUE;
											}
										}
									}
								}
							}
							wDynIndex++;
						}
					}
				}
			}
		}while (lEnumErr == ERROR_SUCCESS);
	}
}


/*********************************************************************
Called when EnumerateDynamicDevices detects a "system" device (i.e.
a processor or FPU entry).  The string passed in rgchSystemKey is the
name of the HKEY_LOCAL_MACHINE subkey under which the "system" device
was found.
**********************************************************************/
void ProcessSystemDevices(LPTSTR rgchSystemKey)
{
	_TCHAR rgchValue[256];
	DWORD dwType, dwValueSize;
	// If we've got all the information we can use, we can bail out immediately
	if (vfIsFPUAvailable == TRUE && vrgchDynProcessorName[0] != 0)
		return;

	dwValueSize = GetRegKeyValue32(HKEY_LOCAL_MACHINE, rgchSystemKey, vrgchHardwareIDValueName,
								&dwType, (PTBYTE) rgchValue, sizeof(rgchValue));
	if (dwValueSize > 0 && dwType == REG_SZ)
	{
		if (_tcsstr(rgchValue,_T("*PNP0C04")))
		{
			vfIsFPUAvailable = TRUE;
		}
		else if (_tcsstr(rgchValue,_T("*PNP0C01")))
		{
			dwValueSize = GetRegKeyValue32(HKEY_LOCAL_MACHINE,rgchSystemKey,_T("CPU"),&dwType, 
				(PTBYTE) vrgchDynProcessorName, sizeof(vrgchDynProcessorName) );
		}
	}					
}


/*********************************************************************
Returns a LONG value representing the total amount of disk space
(in KB) available on all hard disk drives attached to the user's
system.
**********************************************************************/
LONG GetTotalHardDiskSpace(void)
{
	_TCHAR szDrivesBuffer[256];
	DWORD bufferLen = GetLogicalDriveStrings(256, szDrivesBuffer);
	LPTSTR szDrive = szDrivesBuffer;
	LONG totalHardDiskSpace = 0;
	while (szDrive[0] != 0)
	{
		UINT driveType = GetDriveType(szDrive);
		if (driveType == DRIVE_FIXED)
		{
			DWORD  sectorsPerCluster; 		
			DWORD  bytesPerSector;
			DWORD  freeClusters;
			DWORD  clusters;
			LONG kilobytesPerCluster;

			if (GetDiskFreeSpace(szDrive,&sectorsPerCluster,&bytesPerSector,&freeClusters,&clusters))
            {
			    kilobytesPerCluster = (bytesPerSector * sectorsPerCluster)/1024;
			    totalHardDiskSpace += kilobytesPerCluster * clusters;
            }
		}
		szDrive += ((_tcslen(szDrive)+1) );
	}
	return totalHardDiskSpace;
}


/*********************************************************************
Returns the horizontal and vertical resolution (in pixels) of the 
user's main screen, as well as the color depth (bits per pixel).

Note: NULL can be passed for any parameter that is not of interest.
**********************************************************************/
void GetDisplayCharacteristics(PINT lpHorizResolution, PINT lpVertResolution,PINT lpColorDepth)
{
	HWND hwnd = GetDesktopWindow();
	HDC hdc = GetDC(hwnd);
	if (lpHorizResolution) *lpHorizResolution = GetDeviceCaps(hdc,HORZRES);
	if (lpVertResolution) *lpVertResolution = GetDeviceCaps(hdc,VERTRES);
	if (lpColorDepth) *lpColorDepth = GetDeviceCaps(hdc,BITSPIXEL);
	ReleaseDC(hwnd,hdc);
}


/*********************************************************************
Returns integers representing the platform, major version number, and
minor version number of the currently running Windows OS.

Platform:
VER_PLATFORM_WIN32_NT:		Windows NT
VER_PLATFORM_WIN32s: 		Win32s with Windows 3.1
VER_PLATFORM_WIN32_WINDOWS:	Win32 on Windows 4.0 or later

Note: NULL can be passed for any parameter that is not of interest.
**********************************************************************/
void GetWindowsVersion(LONG* lpPlatform, LONG* lpMajorVersion,LONG* lpMinorVersion,LONG* lpBuildNo)
{
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if (lpMajorVersion) *lpMajorVersion = osvi.dwMajorVersion;
	if (lpMinorVersion) *lpMinorVersion = osvi.dwMinorVersion;
	if (lpPlatform) *lpPlatform = osvi.dwPlatformId;
	if (lpBuildNo) *lpBuildNo = osvi.dwBuildNumber;
}


/*********************************************************************
For the disk drive specified by the nDrive parameter (1 = A, 2 = B, 
etc), GetDriveTypeInv returns a code specifying the drive format.  The 
returned value will be one of the following:

driveSize:
- kDrive525_0360:	5.25", 360K floppy
- kDrive525_0720:	5.25", 720K floppy
- kDrive350_0720:	3.5", 720K floppy
- kDrive350_1440:	3.5", 1.4M floppy
- kDrive350_2880:	3.5", 2.88M floppy
- kDriveFixed:		Hard disk, any size
- kDriveBadDrvNum:	Bad drive number
**********************************************************************/
UINT GetDriveTypeInv(UINT nDrive)
{
	DEVICEPARAMS deviceParams;

	// Must initialize dpDevType, because if nDrive refers to a network
	// drive or a drive letter with no volume attached, DeviceIOControl
	// does not return an error - it just doesn't change .dpDevType at
	// all.
	deviceParams.dpDevType = kDriveBadDrvNum;
	GetDeviceParameters(&deviceParams,nDrive);
	return deviceParams.dpDevType;
}


/*********************************************************************
Returns a block of device parameters for the drive specified by the
nDrive parameter (a zero-based index).
**********************************************************************/
BOOL GetDeviceParameters(PDEVICEPARAMS pDeviceParams, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;

    reg.reg_EAX = 0x440D;      			 /* IOCTL for block devices */
    reg.reg_EBX = nDrive;      			 /* zero-based drive ID     */
    reg.reg_ECX = 0x0860;      			 /* Get Device Parameters command    */
    reg.reg_EDX = (DWORD_PTR) pDeviceParams; /* receives device parameters info  */

    if (!DoIOCTL(&reg))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    return TRUE;
}



/*********************************************************************
Performs an IOCTL (Int21h) call via the System virtual device driver.
**********************************************************************/
BOOL DoIOCTL(PDEVIOCTL_REGISTERS preg)
{
    HANDLE hDevice;
    BOOL fResult;
    DWORD cb;

    preg->reg_Flags = 0x8000; /* assume error (carry flag set) */

	 hDevice = CreateFile(_T("\\\\.\\vxdfile"),
        GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (LPSECURITY_ATTRIBUTES) NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL);

    if (hDevice == (HANDLE) INVALID_HANDLE_VALUE) 
        return FALSE;
    else
    { 
        fResult = DeviceIoControl(hDevice, VWIN32_DIOC_DOS_IOCTL,
								  preg, sizeof(*preg), preg, sizeof(*preg), &cb, 0);
        if (!fResult)
            return FALSE;
    }    
                                        
    CloseHandle(hDevice);

    return TRUE;
}

void GetSystemInformation(LPCTSTR szDeviceID, LPTSTR szDeviceName, LPTSTR szDriverName)
{
	HDEVINFO hDevInfo;
	DWORD dwMemberIndex = 0;
	SP_DEVINFO_DATA DeviceInfoData;
	DWORD dwPropertyRegDataType;
	DWORD dwPropertyBufferSize = 256;
	_TCHAR szPropertyBuffer[256];
	DWORD dwRequiredSize;
	DWORD dwReqSize;
	DWORD dwError = 0;
	DWORD dwClassGuidListSize = 256;
	GUID ClassGuidList[256];
	GUID * pGUID;
	DWORD i;
	
	_tcscpy(szPropertyBuffer,_T(""));

	SetupDiClassGuidsFromName(szDeviceID, ClassGuidList, dwClassGuidListSize, &dwRequiredSize);
	pGUID = ClassGuidList;
	DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

	for (i = 0; i < dwRequiredSize; i++)
	{
		hDevInfo  = NULL;
		hDevInfo = SetupDiGetClassDevs(pGUID++,	NULL, NULL,	DIGCF_PRESENT);
		dwMemberIndex = 0;
		do
		{
			BOOL bRet = SetupDiEnumDeviceInfo(hDevInfo, dwMemberIndex++, &DeviceInfoData);
			if (bRet == TRUE)
			{ 
				bRet = SetupDiGetDeviceRegistryProperty
						(hDevInfo, &DeviceInfoData, SPDRP_DEVICEDESC,
						 &dwPropertyRegDataType, /* optional */
						 (PBYTE)szPropertyBuffer, dwPropertyBufferSize,
						 &dwReqSize /* optional */
						); 
			
				if(!_tcscmp(szDeviceID,_T("net")))
				{
					if(!_tcsnicmp(szPropertyBuffer,_T("Dial-Up"),7))
						continue;
					if(!_tcsnicmp(szPropertyBuffer,_T("Microsoft Virtual Private Networking"),36))
						continue;
				}
				bRet = SetupDiGetDeviceRegistryProperty
						(hDevInfo, &DeviceInfoData, SPDRP_SERVICE,
						 &dwPropertyRegDataType, /* optional */
						 (PBYTE)szDriverName, dwPropertyBufferSize,
						 &dwReqSize /* optional */
						); 
				break;
			}
			else
				dwError = GetLastError();
		}
		while( dwError != ERROR_NO_MORE_ITEMS);
		if(hDevInfo != NULL) {
			SetupDiDestroyDeviceInfoList(hDevInfo);
		}	

	}
	_tcscpy(szDeviceName,szPropertyBuffer);
}

#pragma optimize( _T(""), on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\res\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RegWizCtrl.rc
//
#define IDS_KEY1                        1
#define IDS_KEY2                        2
#define IDS_KEY3                        3
#define IDS_KEY4                        4
#define IDS_INFOKEY1                    5
#define IDS_INFOKEY2                    6
#define IDS_INFOKEY3                    7
#define IDS_INFOKEY4                    8
#define IDS_INFOKEY5                    9
#define IDS_INFOKEY6                    10
#define IDS_INFOKEY7                    11
#define IDS_INFOKEY8                    12
#define IDS_INFOKEY9                    13
#define IDS_INFOKEY10                   14
#define IDS_INFOKEY11                   15
#define IDS_INFOKEY12                   16
#define IDS_INFOKEY13                   17
#define IDS_INFOKEY14                   18
#define IDS_INFOKEY15                   19
#define IDS_INFOKEY16                   20
#define IDS_INFOKEY17                   21
#define IDS_INFOKEY18                   22
#define IDS_INFOKEY19                   23
#define IDS_INFOKEY20                   24
#define IDS_INFOKEY21                   25
#define IDS_INFOKEY22                   26
#define IDS_INFOKEY23                   27
#define IDS_INFOKEY24                   28
#define IDS_INFOKEY25                   29
#define IDS_INFOKEY26                   30
#define IDS_INFOKEY27                   31
#define IDS_INFOKEY28                   32
#define IDS_INFOKEY29                   33
#define IDS_INFOKEY30                   34
#define IDS_INFOKEY31                   35
#define IDS_INFOKEY32                   36
#define IDS_INFOKEY33                   37
#define IDS_INFOKEY34                   38
#define IDS_INFOKEY35                   39
#define IDS_INFOKEY36                   40
#define IDS_INFOKEY37                   41
#define IDS_INFOKEY38                   42
#define IDS_INFOKEY39                   43
#define IDS_INFOKEY40                   44
#define IDS_INFOKEY41                   45
#define IDS_PROCESSOR_386               47
#define IDS_PROCESSOR_486               48
#define IDS_PROCESSOR_PENTIUM           49
#define IDS_PROCESSOR_MIPS_R2000        50
#define IDS_PROCESSOR_MIPS_R3000        51
#define IDS_PROCESSOR_MIPS_R4000        52
#define IDS_PROCESSOR_ALPHA_21064       53
#define IDS_PROCESSOR_860               54
#define IDS_SIZE_SUFFIX1                55
#define IDS_INVENTORY1                  56
#define IDS_INVENTORY2                  57
#define IDS_INVENTORY3                  58
#define IDS_INVENTORY4                  59
#define IDS_INVENTORY5                  60
#define IDS_INVENTORY6                  61
#define IDS_INVENTORY7                  62
#define IDS_INVENTORY8                  63
#define IDS_INVENTORY9                  64
#define IDS_INVENTORY10                 65
#define IDS_INVENTORY11                 66
#define IDS_INVENTORY12                 67
#define IDS_INVENTORY13                 68
#define IDS_SIZE_SUFFIX2                69
#define IDS_PLATFORM_WIN                79
#define IDS_PLATFORM_WINNT              80
#define IDS_PLATFORM_WIN95              81
#define IDS_PRODUCTBASEKEY              82
#define IDS_INPUT_PRODUCTNAME           83
#define IDS_INPUT_PRODUCTID             84
#define IDS_INPUT_INVENTORYPATH         85
#define IDS_INPUT_ISREGISTERED          86
#define IDS_CNTRY_MAXCODE               87
#define IDS_CNTRY_UNIQUECOUNT           88
#define IDS_BAD_PREFIX                  89
#define IDS_BAD_FIRSTNAME               90
#define IDS_BAD_LASTNAME                91
#define IDS_BAD_ADDRESS                 92
#define IDS_BAD_ADDRESS2                93
#define IDS_BAD_COMPANY                 94
#define IDS_BAD_CITY                    95
#define IDS_BAD_STATE                   96
#define IDS_BAD_POSTALCODE              97
#define IDS_BAD_PHONE                   98
#define IDS_BAD_SYSINV                  100
#define IDD_WELCOME                     101
#define IDS_BAD_PRODINV                 101
#define IDT_TEXT1                       102
#define IDDIAL                          102
#define IDT_TEXT2                       103
#define IDT_TEXT3                       104
#define IDB_BITMAP1                     104
#define IDT_TEXT4                       105
#define IDB_BITMAP2                     105
#define IDT_TEXT5                       106
#define IDD_NAME                        106
#define IDD_ADDRESS                     107
#define IDT_TEXT13                      107
#define IDT_TEXT7                       108
#define IDD_PID                         108
#define IDT_TEXT14                      108
#define IDT_TEXT8                       109
#define IDD_INVENTORY                   109
#define IDD_PRODINVENTORY               110
#define IDT_TEXT10                      110
#define IDD_REGISTER                    111
#define IDT_TEXT12                      111
#define IDB_BITMAP3                     113
#define IDI_REGWIZ                      117
#define IDD_CANCEL                      118
#define IDD_INPUTPARAM_ERR              121
#define IDC_ICON1                       122
#define IDI_BADREGWIZ                   122
#define IDD_MODEM_ERR                   122
#define IDB_SYSINV_ICONS                123
#define IDD_NOMODEM                     124
#define IDD_SIGNUP_ERR                  125
#define IDD_ALREADY_REGISTERED          126
#define IDB_BITMAP4                     126
#define IDI_WORLD                       127
#define IDD_INVALID_DLG                 127
#define IDB_BITMAP5                     128
#define IDD_MODEM_TOO_SLOW              128
#define IDI_ENVELOPE                    129
#define IDD_LOGFILE_QUERY               129
#define IDD_RESELLER                    130
#define IDS_ADDRDLG_TEXT1A              132
#define IDS_ADDRDLG_TEXT1B              133
#define IDS_ADDRDLG_TEXT2A              134
#define IDS_ADDRDLG_TEXT2B              135
#define IDS_WELCDLG_TEXT2A              136
#define IDS_WELCDLG_TEXT2B              137
#define IDS_PROJNAME                    150
#define IDR_REGWIZCTRL                  151
#define IDD_DIALUP_ERROR                160
#define IDD_RAS_ERROR                   161
#define IDB_WORLD                       201
#define IDD_VERIFY_CONNECTION           202
#define IDD_POST_ERROR                  203
#define IDD_SUCCESSFUL_REGISTRATION     204
#define IDD_WELCOME_FOR98               205
#define IDR_ACCELERATOR                 206
#define IDD_POST_PROBLEM                207
#define IDD_CFG_PROBLEM                 208
#define IDD_PROXY_LOG                   209
#define IDD_CONNECTION_STSTUS           210
#define IDD_CONNECTION_STATUS           210
#define IDD_PROXY_CFG                   211
#define IDD_MODEM_CFG_ERROR             212
#define IDD_NETWORK_CFG_ERROR           214
#define IDD_ANOTHERCOPY_ERROR           215
#define IDB_BANNER                      217
#define IDB_WATERMARK                   218
#define IDD_ERROR_INVALIDBINARY         219
#define IDD_ADDRESS_FE                  220
#define IDD_NAME_FE                     221
#define IDI_SIICON1                     222
#define IDI_SIICON2                     223
#define IDI_SIICON3                     224
#define IDI_SIICON4                     225
#define IDI_SIICON5                     226
#define IDI_SIICON6                     227
#define IDI_SIICON7                     228
#define IDI_SIICON8                     229
#define IDI_SIICON9                     230
#define IDI_SIICON10                    231
#define IDI_SIICON11                    232
#define IDI_SIICON12                    233
#define IDI_SIICON13                    234
#define IDI_SIICON14                    235
#define IDI_SIICON15                    236
#define IDI_SIICON16                    237
#define IDI_SIICON17                    238
#define IDI_SIICON18                    239
#define IDI_SIICON19                    240
#define IDI_SIICON20                    241
#define IDI_SIICONLAST                  249
#define IDI_DIALUP                      250
#define IDD_FAILURE_REGISTRATION        255
#define idh_installmodemyes             410
#define idh_installmodemno              411
#define IDT_TEXT11                      500
#define IDD_DIAL                        501
#define ID_LABELDIAL                    502
#define IDD_ADDRESSEMAIL                503
#define IDD_INFORM                      504
#define ID_LABELCONNECT                 505
#define IDD_HOME_QUESTIONS              506
#define ID_LABELCANCEL                  507
#define IDD_BUSINESS_QUESTIONS          508
#define ID_LABELCANCELLING              509
#define ID_LABELDISCONNECT              510
#define ID_LABELTRANSFER                511
#define ID_LABELINIT                    512
#define ID_LABELTRANSFERDONE            513
#define ID_LABELPHONEDONE               514
#define ID_LABELTASKFILE                515
#define ID_LABELTASKPHONE               516
#define ID_LABELCALLONE                 517
#define ID_LABELNUMBER                  518
#define ID_BTNSETTINGS                  519
#define IDC_DISCONNECT                  520
#define IDB_BACK                        1000
#define IDB_NEXT                        1001
#define IDB_EXIT                        1002
#define IDC_EDIT1                       1005
#define IDC_EDIT2                       1006
#define IDC_EDIT3                       1007
#define IDC_EDIT4                       1008
#define IDC_EDIT5                       1009
#define IDC_EDIT6                       1010
#define IDC_EDIT7                       1011
#define IDT_TEXT9                       1012
#define IDC_CHECK1                      1013
#define IDC_RADIO1                      1015
#define IDC_RADIO2                      1016
#define IDC_GROUP1                      1017
#define IDC_GROUP2                      1018
#define IDC_PICTFRAME                   1019
#define IDC_LIST1                       1021
#define IDC_STATIC1                     1022
#define IDC_COMBO1                      1023
#define IDB_YES                         1024
#define IDB_NO                          1025
#define IDT_VERSION                     1026
#define IDB_CANCEL                      1026
#define IDT_TEXT6                       1027
#define IDC_ETCHEDLINE                  1028
#define IDC_ETCHEDLINE2                 1029
#define IDC_ENVELOPE                    1030
#define IDC_WORLD                       1031
#define IDC_TEXT1                       1033
#define IDC_TITLE                       1034
#define IDC_SUBTITLE                    1035
#define IDT_SUBTITLE                    1036
#define IDB_REG_LATER                   1037
#define IDC_TEXT3                       1038
#define IDC_MSN_TEXT1                   1039
#define IDC_MSN_TEXT2                   1040
#define IDC_BUTTON1                     1041
#define IDEND                           1041
#define IDC_INCENTIVE                   1042
#define IDC_TEXT5                       1043
#define IDC_TEXT4                       1044
#define IDC_TEXT6                       1045
#define IDC_EDIT8                       1046
#define IDC_TEXT7                       1046
#define IDC_TEXT9                       1047
#define IDC_TEXT8                       1047
#define IDC_USERNAME                    1048
#define IDC_TEXT10                      1048
#define IDC_PASSWORD                    1049
#define IDC_TEXT11                      1049
#define IDC_EDIT9                       1049
#define IDC_CHECK2                      1050
#define IDC_TEXT12                      1050
#define IDC_CHECK3                      1051
#define IDC_CHECK6                      1052
#define IDC_CHECK7                      1053
#define IDC_CHECK4                      1054
#define IDC_MODEM_NAME                  1054
#define IDC_CHECK5                      1055
#define IDC_AREACODE                    1055
#define IDC_CHECK8                      1056
#define IDT_AREACODE                    1056
#define IDT_DIVISION                    1057
#define IDC_DIVISION                    1058
#define IDT_USERID                      1059
#define IDC_USERID                      1060
#define IDC_LIST2                       1067
#define IDC_LIST4                       1069
#define IDC_LIST5                       1070
#define IDC_COMBO2                      1072
#define IDC_COMPUTER_MODEL              1075
#define IDC_PHONENUMBER                 1077
#define IDC_TEXT2                       1078
#define IDC_ERROR                       1079
#define IDC_YESNOGRP                    1080
#define iszLoginKey                     2000
#define IDS_CURRENTCOMMDEV              2001
#define iszLocations                    2002
#define iszUserInfo                     2003
#define iszPref                         2004
#define iszComPort                      2005
#define iszBaud                         2006
#define iszMarvelError                  2007
#define IDS_ERRORTITLE                  2008
#define IDS_TIMEOUTRANGE                2009
#define IDS_EMPTYPASSWORD               2010
#define IDS_NOTSAMEPASSWORD             2011
#define IDS_INVALIDPASSWORD             2012
#define IDS_CHANGEDPASSWORD             2013
#define IDS_GUIDEEXENAME                2014
#define IDS_MARVEL                      2015
#define IDS_ADDMODEMCOMMAND             2016
#define IDS_ADDMODEMERROR               2017
#define IDS_DIALINGPROPERTIES           2017
#define IDS_ADDMODEMERROR_V             2018
#define IDS_INVALIDNEWPASSWORD          2019
#define IDS_PHONENO                     2020
#define IDS_BACKUPPHONENO               2021
#define IDS_SETUPMARVELKEY              2022
#define IDS_NOTAPIERROR                 2023
#define IDS_MODEMTOOSLOW                2024
#define IDS_TAPIINIFILECORRUPT          2025
#define IDS_WINCURRENT                  2026
#define IDS_REGOWNER                    2027
#define IDS_REGORG                      2028
#define IDS_SIGNUPLOC_KEY               2029
#define IDS_SYSINV_NOTFOUND             2038
#define IDS_YES                         2039
#define IDS_NO                          2040
#define IDS_OEM_INIFILE                 2045
#define IDS_OEM_INISECTION              2046
#define IDS_OEM_INIKEY                  2047
#define IDS_DRV525_0360                 2048
#define IDS_DRV525_1200                 2049
#define IDS_DRV350_0720                 2050
#define IDS_DRV350_1440                 2051
#define IDS_DRV350_2880                 2052
#define IDS_MAKERCOMPANY                2053
#define IDS_SIGNUPLOC_VALUENAME         2054
#define IDS_SIGNUPLOC_FILENAME          2055
#define IDS_CNTRY_DEFAULT               2056
#define IDS_CNTRY_AFGHANISTAN           2057
#define IDS_CNTRY_ALBANIA               2058
#define IDS_CNTRY_ALGERIA               2059
#define IDS_CNTRY_AMERICAN_SAMOA        2060
#define IDS_CNTRY_ANDORRA               2061
#define IDS_CNTRY_ANGOLA                2062
#define IDS_CNTRY_ANGUILLA              2063
#define IDS_CNTRY_ANTIGUA               2064
#define IDS_CNTRY_ARGENTINA             2065
#define IDS_CNTRY_ARMENIA               2066
#define IDS_CNTRY_ARUBA                 2067
#define IDS_CNTRY_ASCENSION_ISLAND      2068
#define IDS_CNTRY_AUSTRALIA             2069
#define IDS_CNTRY_AUSTRALIAN_ANTARCTIC_TERRITORY 2070
#define IDS_CNTRY_AUSTRIA               2071
#define IDS_CNTRY_AZERBAIJAN            2072
#define IDS_CNTRY_BAHAMAS               2073
#define IDS_CNTRY_BAHRAIN               2074
#define IDS_CNTRY_BANGLADESH            2075
#define IDS_CNTRY_BARBADOS              2076
#define IDS_CNTRY_BARBUDA               2077
#define IDS_CNTRY_BELARUS               2078
#define IDS_CNTRY_BELGIUM               2079
#define IDS_CNTRY_BELIZE                2080
#define IDS_CNTRY_BENIN                 2081
#define IDS_CNTRY_BERMUDA               2082
#define IDS_CNTRY_BHUTAN                2083
#define IDS_CNTRY_BOLIVIA               2084
#define IDS_CNTRY_BOSNIA_AND_HERZEGOVINA 2085
#define IDS_CNTRY_BOTSWANA              2086
#define IDS_CNTRY_BRAZIL                2087
#define IDS_CNTRY_BRITISH_VIRGIN_ISLANDS 2088
#define IDS_CNTRY_BRUNEI                2089
#define IDS_CNTRY_BULGARIA              2090
#define IDS_CNTRY_BURKINA_FASO          2091
#define IDS_CNTRY_BURUNDI               2092
#define IDS_CNTRY_CAMEROON              2093
#define IDS_CNTRY_CANADA                2094
#define IDS_CNTRY_CAPE_VERDE_ISLANDS    2095
#define IDS_CNTRY_CAYMAN_ISLANDS        2096
#define IDS_CNTRY_CENTRAL_AFRICAN_REPUBLIC 2097
#define IDS_CNTRY_CHAD                  2098
#define IDS_CNTRY_CHILE                 2099
#define IDS_CNTRY_CHINA                 2100
#define IDS_CNTRY_CHRISTMAS_ISLAND      2101
#define IDS_CNTRY_COCOS_KEELING_ISLANDS 2102
#define IDS_CNTRY_COLOMBIA              2103
#define IDS_CNTRY_COMOROS               2104
#define IDS_CNTRY_CONGO                 2105
#define IDS_CNTRY_COOK_ISLANDS          2106
#define IDS_CNTRY_COSTA_RICA            2107
#define IDS_CNTRY_CROATIA               2108
#define IDS_CNTRY_CUBA                  2109
#define IDS_CNTRY_CYPRUS                2110
#define IDS_CNTRY_CZECH_REPUBLIC        2111
#define IDS_CNTRY_DENMARK               2112
#define IDS_CNTRY_DIEGO_GARCIA          2113
#define IDS_CNTRY_DJIBOUTI              2114
#define IDS_CNTRY_DOMINICA              2115
#define IDS_CNTRY_DOMINICAN_REPUBLIC    2116
#define IDS_CNTRY_ECUADOR               2117
#define IDS_CNTRY_EGYPT                 2118
#define IDS_CNTRY_EL_SALVADOR           2119
#define IDS_CNTRY_EQUATORIAL_GUINEA     2120
#define IDS_CNTRY_ESTONIA               2121
#define IDS_CNTRY_ETHIOPIA              2122
#define IDS_CNTRY_FAEROE_ISLANDS        2123
#define IDS_CNTRY_FALKLAND_ISLANDS      2124
#define IDS_CNTRY_FIJI_ISLANDS          2125
#define IDS_CNTRY_FINLAND               2126
#define IDS_CNTRY_FRANCE                2127
#define IDS_CNTRY_FRENCH_ANTILLES       2128
#define IDS_CNTRY_FRENCH_GUIANA         2129
#define IDS_CNTRY_FRENCH_POLYNESIA      2130
#define IDS_CNTRY_GABON                 2131
#define IDS_CNTRY_GAMBIA                2132
#define IDS_CNTRY_GEORGIA               2133
#define IDS_CNTRY_GERMANY               2134
#define IDS_CNTRY_GHANA                 2135
#define IDS_CNTRY_GIBRALTAR             2136
#define IDS_CNTRY_GREECE                2137
#define IDS_CNTRY_GREENLAND             2138
#define IDS_CNTRY_GRENADA               2139
#define IDS_CNTRY_GUADELOUPE            2140
#define IDS_CNTRY_GUAM                  2141
#define IDS_CNTRY_GUANTANAMO_BAY        2142
#define IDS_CNTRY_GUATEMALA             2143
#define IDS_CNTRY_GUINEA                2144
#define IDS_CNTRY_GUINEA_BISSAU         2145
#define IDS_CNTRY_GUYANA                2146
#define IDS_CNTRY_HAITI                 2147
#define IDS_CNTRY_HONDURAS              2148
#define IDS_CNTRY_HONG_KONG             2149
#define IDS_CNTRY_HUNGARY               2150
#define IDS_CNTRY_ICELAND               2151
#define IDS_CNTRY_INDIA                 2152
#define IDS_CNTRY_INDONESIA             2153
#define IDS_CNTRY_INMARSAT_ATLANTIC_EAST 2154
#define IDS_CNTRY_INMARSAT_ATLANTIC_WEST 2155
#define IDS_CNTRY_INMARSAT_INDIAN       2156
#define IDS_CNTRY_INMARSAT_PACIFIC      2157
#define IDS_CNTRY_IRAN                  2158
#define IDS_CNTRY_IRAQ                  2159
#define IDS_CNTRY_IRELAND               2160
#define IDS_CNTRY_ISRAEL                2161
#define IDS_CNTRY_ITALY                 2162
#define IDS_CNTRY_IVORY_COAST           2163
#define IDS_CNTRY_JAMAICA               2164
#define IDS_CNTRY_JAPAN                 2165
#define IDS_CNTRY_JORDAN                2166
#define IDS_CNTRY_KAZAKHSTAN            2167
#define IDS_CNTRY_KENYA                 2168
#define IDS_CNTRY_CAMBODIA              2169
#define IDS_CNTRY_KIRIBATI_REPUBLIC     2170
#define IDS_CNTRY_KOREA_NORTH           2171
#define IDS_CNTRY_KOREA_SOUTH           2172
#define IDS_CNTRY_KUWAIT                2173
#define IDS_CNTRY_KYRGYZSTAN            2174
#define IDS_CNTRY_LAOS                  2175
#define IDS_CNTRY_LATVIA                2176
#define IDS_CNTRY_LEBANON               2177
#define IDS_CNTRY_LESOTHO               2178
#define IDS_CNTRY_LIBERIA               2179
#define IDS_CNTRY_LIBYA                 2180
#define IDS_CNTRY_LIECHTENSTEIN         2181
#define IDS_CNTRY_LITHUANIA             2182
#define IDS_CNTRY_LUXEMBOURG            2183
#define IDS_CNTRY_MACAO                 2184
#define IDS_CNTRY_FORMER_YUGOSLAV_REPUBLIC_OF_MACEDONIA 2185
#define IDS_CNTRY_MADAGASCAR            2186
#define IDS_CNTRY_MALAWI                2187
#define IDS_CNTRY_MALAYSIA              2188
#define IDS_CNTRY_MALDIVES              2189
#define IDS_CNTRY_MALI                  2190
#define IDS_CNTRY_MALTA                 2191
#define IDS_CNTRY_MARSHALL_ISLANDS      2192
#define IDS_CNTRY_MARTINIQUE            2193
#define IDS_CNTRY_MAURITANIA            2194
#define IDS_CNTRY_MAURITIUS             2195
#define IDS_CNTRY_MAYOTTE_ISLAND        2196
#define IDS_CNTRY_MEXICO                2197
#define IDS_CNTRY_MICRONESIA            2198
#define IDS_CNTRY_MOLDOVA               2199
#define IDS_CNTRY_MONACO                2200
#define IDS_CNTRY_MONGOLIA              2201
#define IDS_CNTRY_MONTSERRAT            2203
#define IDS_CNTRY_MOROCCO               2204
#define IDS_CNTRY_MOZAMBIQUE            2205
#define IDS_CNTRY_MYANMAR               2206
#define IDS_CNTRY_NAMIBIA               2207
#define IDS_CNTRY_NAURU                 2208
#define IDS_CNTRY_NEPAL                 2209
#define IDS_CNTRY_NETHERLANDS           2210
#define IDS_CNTRY_NETHERLANDS_ANTILLES  2211
#define IDS_CNTRY_NEVIS                 2212
#define IDS_CNTRY_NEW_CALEDONIA         2213
#define IDS_CNTRY_NEW_ZEALAND           2214
#define IDS_CNTRY_NICARAGUA             2215
#define IDS_CNTRY_NIGER                 2216
#define IDS_CNTRY_NIGERIA               2217
#define IDS_CNTRY_NIUE                  2218
#define IDS_CNTRY_NORFOLK_ISLAND        2219
#define IDS_CNTRY_ERITREA               2220
#define IDS_CNTRY_NORWAY                2221
#define IDS_CNTRY_OMAN                  2222
#define IDS_CNTRY_PAKISTAN              2223
#define IDS_CNTRY_PALAU                 2224
#define IDS_CNTRY_PANAMA                2225
#define IDS_CNTRY_PAPUA_NEW_GUINEA      2226
#define IDS_CNTRY_PARAGUAY              2227
#define IDS_CNTRY_PERU                  2228
#define IDS_CNTRY_PHILIPPINES           2229
#define IDS_CNTRY_POLAND                2230
#define IDS_CNTRY_PORTUGAL              2231
#define IDS_CNTRY_QATAR                 2232
#define IDS_CNTRY_REUNION_ISLAND        2233
#define IDS_CNTRY_ROMANIA               2234
#define IDS_CNTRY_ROTA_ISLAND           2235
#define IDS_CNTRY_RUSSIA                2236
#define IDS_CNTRY_RWANDA                2237
#define IDS_CNTRY_SAIPAN_ISLAND         2238
#define IDS_CNTRY_SAN_MARINO            2239
#define IDS_CNTRY_SAO_TOME_AND_PRINCIPE 2240
#define IDS_CNTRY_SAUDI_ARABIA          2241
#define IDS_CNTRY_SENEGAL_REPUBLIC      2242
#define IDS_CNTRY_YUGOSLAVIA            2243
#define IDS_CNTRY_SEYCHELLE_ISLANDS     2244
#define IDS_CNTRY_SIERRA_LEONE          2245
#define IDS_CNTRY_SINGAPORE             2246
#define IDS_CNTRY_SLOVAK_REPUBLIC       2247
#define IDS_CNTRY_SLOVENIA              2248
#define IDS_CNTRY_SOLOMON_ISLANDS       2249
#define IDS_CNTRY_SOMALIA               2250
#define IDS_CNTRY_SOUTH_AFRICA          2251
#define IDS_CNTRY_SPAIN                 2252
#define IDS_CNTRY_SRI_LANKA             2253
#define IDS_CNTRY_ST_HELENA             2254
#define IDS_CNTRY_ST_KITTS              2255
#define IDS_CNTRY_ST_PIERRE_AND_MIQUELON 2256
#define IDS_CNTRY_ST_VINCENT_AND_THE_GRENADINES 2257
#define IDS_CNTRY_SUDAN                 2258
#define IDS_CNTRY_SURINAME              2259
#define IDS_CNTRY_SWAZILAND             2260
#define IDS_CNTRY_SWEDEN                2261
#define IDS_CNTRY_SWITZERLAND           2262
#define IDS_CNTRY_SYRIA                 2263
#define IDS_CNTRY_TAIWAN                2264
#define IDS_CNTRY_TAJIKISTAN            2265
#define IDS_CNTRY_TANZANIA              2266
#define IDS_CNTRY_THAILAND              2267
#define IDS_CNTRY_TINIAN_ISLAND         2268
#define IDS_CNTRY_TOGO                  2269
#define IDS_CNTRY_TOKELAU               2270
#define IDS_CNTRY_TONGA                 2271
#define IDS_CNTRY_TRINIDAD_AND_TOBAGO   2272
#define IDS_CNTRY_TUNISIA               2273
#define IDS_CNTRY_TURKEY                2274
#define IDS_CNTRY_TURKMENISTAN          2275
#define IDS_CNTRY_TURKS_AND_CAICOS_ISLANDS 2276
#define IDS_CNTRY_TUVALU                2277
#define IDS_CNTRY_UGANDA                2278
#define IDS_CNTRY_UKRAINE               2279
#define IDS_CNTRY_UNITED_ARAB_EMIRATES  2280
#define IDS_CNTRY_UNITED_KINGDOM        2281
#define IDS_CNTRY_URUGUAY               2282
#define IDS_CNTRY_UZBEKISTAN            2283
#define IDS_CNTRY_VANUATU               2284
#define IDS_CNTRY_VATICAN_CITY          2285
#define IDS_CNTRY_VENEZUELA             2286
#define IDS_CNTRY_VIETNAM               2287
#define IDS_CNTRY_WALLIS_AND_FUTUNA_ISLANDS 2288
#define IDS_CNTRY_WESTERN_SAMOA         2289
#define IDS_CNTRY_YEMEN                 2291
#define IDS_CNTRY_ZAIRE                 2292
#define IDS_CNTRY_ZAMBIA                2293
#define IDS_CNTRY_ZIMBABWE              2294
#define IDS_CNTRY_UNITED_STATES_OF_AMERICA 2295
#define IDS_CNTRY_UNITED_STATES_VIRGIN_ISLANDS 2296
#define IDS_CNTRY_PUERTO_RICO           2297
#define IDS_CNTRY_SAINT_LUCIA           2298
#define IDS_CNTRY_END                   2299
#define IDS_TAB_ADDRESS                 2300
#define IDS_HTTP_SERVER_PATH            2301
#define IDS_HTTP_SERVER                 2302
#define IDS_HTTP_USERNAME               2303
#define IDS_HTTP_PASSWORD               2304
#define IDS_OPENPORT                    2305
#define IDS_PORTOPENED                  2306
#define IDS_CONNECTDEVICE               2307
#define IDS_DEVICECONNECTED             2308
#define IDS_AUTHENTICATE                2309
#define IDS_AUTHNOTIFY                  2310
#define IDS_AUTHRETRY                   2311
#define IDS_AUTHCALLBACK                2312
#define IDS_CONNECTED                   2313
#define IDS_DISCONNECTED                2314
#define IDS_ALLDEVICESCONNECTED         2315
#define IDS_AUTHCHANGEPASSWORD          2316
#define IDS_AUTHPROJECT                 2317
#define IDS_AUTHLINKSPEED               2318
#define IDS_AUTHACK                     2319
#define IDS_REAUTHENTICATE              2320
#define IDS_AUTHENTICATED               2321
#define IDS_PREPAREFORCALLBACK          2322
#define IDS_WAITFORMODEMRESET           2323
#define IDS_WAITFORCALLBACK             2324
#define IDS_INTERACTIVE                 2325
#define IDS_RETRYAUTHENTICATION         2326
#define IDS_CALLBACKSETBYCALLER         2327
#define IDS_PASSWORDEXPIRED             2328
#define IDS_RAS_UNDEFINED_ERROR         2329
#define IDS_MODEM_ALREADY_INUSE         2330
#define IDS_TELEPHONE_DETAILS           2331
#define IDS_OUTSIDE_ACCESS              2332
#define IDS_LONGDISTANCE_ACCESS         2333
#define IDS_TAPI_COUNTRY_CODE           2334
#define IDS_NT_NETWORK_ENTRY            2335
#define IDS_NT_NETWORK_DESCRIPTION      2336
#define IDS_NT_MODEM_ENTRY              2337
#define IDS_NT_MODEM_DESCRIPTION        2338
#define IDS_PHONEBOOK_ENTRY             2339
#define IDS_ICW_DIRECTORY_ENTRY         2340
#define IDS_ICW_DIRECTORY_ENTRY_VALUE   2341
#define IDS_DUN_PHONE_SECTION           2342
#define IDS_DUN_PHONE_AREACODE          2343
#define IDS_DUN_PHONE_COUNTRY           2344
#define IDS_DUN_VALUE_YES               2345
#define IDS_DUN_VALUE_NO                2346
#define IDS_DUN_PHONE_DIALAS            2347
#define IDS_DUN_SERVER_SECTION          2348
#define IDS_DUN_SERVER_TYPE             2349
#define IDS_DUN_SERVER_TYPE_PPP         2350
#define IDS_DUN_SERVER_SW_COMPRESS      2351
#define IDS_DUN_SERVER_TCPIP            2352
#define IDS_DUN_SERVER_LCP              2353
#define IDS_DUN_TCP_SECTION             2354
#define IDS_DUN_TCP_IPADDRESS           2355
#define IDS_DUN_TCP_SERVERADDRESS       2356
#define IDS_DUN_TCP_HEADERCOMPRESSION   2357
#define IDS_DUN_TCP_GATEWAY             2358
#define IDS_DUN_TCP_DNS                 2359
#define IDS_DUN_TCP_DNS_ALT             2360
#define IDS_DUN_USER_SECTION            2361
#define IDS_DUN_USER_NAME               2362
#define IDS_DUN_USER_PASSWORD           2363
#define IDS_NT_CDROM_ENTRY              2364
#define IDS_NT_POINTINGDEVICE_ENTRY     2365
#define IDS_NT_SOUNDCARD_DRIVER_DESC_ENTRY 2366
#define IDS_NT_SOUNDCARD_DRIVER_ENTRY   2367
#define IDS_NT_SOUNDCARD_DRIVER_VALUE   2368
#define IDS_OEM_DLL_ENTRY               2369
#define IDS_OEMBASEKEY                  2370
#define IDS_REMOVABLE_MEDIA_ENTRY       2371
#define IDS_HWID                        2372
#define IDS_MSID                        2373
#define IDS_PROCESSOR_ENTRY             2374
#define IDS_MASS_STRORAGE_ENTRY         2375
#define IDS_CPU_VENDOR_ENTRY            2376
#define IDS_CPU_ENTRY                   2377
#define IDS_PRODUCT_NAME                2378
#define IDS_PRODUCT_VERSION             2379
#define IDS_PRODUCT_VERSION_DISPLAY     2380
#define IDS_NT_POINTINGDEVICE_VALUE     2381
#define IDS_NT_CDROM_VALUE              2382
#define IDS_REMOVABLE_MEDIA_VALUE       2383
#define IDS_COMPANY_NAME                2384
#define IDS_WELCOMESCREEN_PROD_SEARCH   2385
#define IDS_WELCOME_SCR_TEXT21          2386
#define IDS_WELCOME_SCR_TEXT22          2387
#define IDS_ENTRY_FOR_WELCOME           2388
#define IDS_DIALING_MESSAGE             2389
#define IDS_POST_MESSAGE                2390
#define IDS_WINDOWS_CAPTION             2391
#define IDS_MODEM_NODIALTONE            2392
#define IDS_MODEM_ERROR                 2393
#define IDS_WELCOME_SCR_CONNECTOR       2394
#define IDD_MICROSOFT_ABOUT_MSG         2395
#define IDD_MICROSOFT_ABOUT_CAPTION     2396
#define IDS_TAPI_AREA_CODE              2397
#define IDS_MODEM_NOANSWER              2398
#define IDS_MODEM_LINE_BUSY             2399
#define IDS_HARDWARE_FAILURE            2400
#define IDS_REREGISTER_OS1              2401
#define IDS_REREGISTER_OS2              2402
#define IDS_WELCOME_SCR_TITLE           2403
#define IDS_WELCOME_SCR_STITLE          2404
#define IDS_INFORM_SCR_TITLE            2405
#define IDS_INFORM_SCR_STITLE           2406
#define IDS_NAME_SCR_TITLE              2407
#define IDS_NAME_SCR_STITLE             2408
#define IDS_ADDRESS_SCR_TITLE           2409
#define IDS_ADDRESS_SCR_STITLE          2410
#define IDS_RESELLER_SCR_TITLE          2411
#define IDS_RESELLER_SCR_STITLE         2412
#define IDS_SYSINV_SCR_TITLE            2413
#define IDS_SYSINV_SCR_STITLE           2414
#define IDS_PRODINV_SCR_TITLE           2415
#define IDS_PRODINV_SCR_STITLE          2416
#define IDS_REGISTER_SCR_TITLE          2417
#define IDS_REGISTER_SCR_STITLE         2418
#define IDS_DIALUP_SCR_TITLE            2419
#define IDS_DIALUP_SCR_STITLE           2420
#define IDS_LARGEFONTNAME               2421
#define IDS_LARGEFONTSIZE               2422
#define IDS_REGISTERLATER_BUTTONTEXT    2423
#define IDS_CANCEL_BUTTONTEXT           2424
#define IDS_FINAL_CANCEL_MSG            2425
#define IDS_FINAL_ERROR_MSG             2426
#define IDS_FINAL_MODEMCFG_MSG1         2427
#define IDS_FINAL_MODEMCFG_MSG2         2428
#define IDS_FINAL_NOTCP_MSG1            2429
#define IDS_FINAL_NOTCP_MSG2            2430
#define IDS_FINAL_POSTBUSY_MSG          2431
#define IDS_FINAL_POSTSUCCESS_MSG       2432
#define IDS_FINAL_NOTCP1_MSG            2433
#define IDS_FINAL_NOTCP2_MSG            2434
#define IDS_FINAL_MODEMCFG1_MSG         2435
#define IDS_FINAL_MODEMCFG2_MSG         2436
#define IDS_FINAL_SYSTEMERROR_MSG       2437
#define IDS_FINAL_SITEBUSY_MSG          2438
#define IDS_FINAL_REGISTERLATER_MSG     2439
#define IDS_FINAL_RASCFG_MSG            2441
#define IDS_FINAL_MODEMINUSE_MSG        2442
#define IDS_TELEPHONE_LOC               2443
#define IDS_TELEPHONE_CID               2444
#define IDS_TELEPHONE_NENT              2445
#define IDS_TELEPHONE_ID                2446
#define IDS_TELEPHONE_COUNTRY           2447
#define IDS_DUMMY_REMOVEDEY             2448
#define IDS_DIVISIONNAME_KEY            2449
#define IDS_USERID_KEY                  2450
#define IDS_AREACODE_KEY                2451
#define IDS_INFOKEY_51                  2452
#define IDS_HOMEQ1                      2452
#define IDS_INFOKEY_53                  2453
#define IDS_HOMEQ2                      2453
#define IDS_INFOKEY_54                  2454
#define IDS_HOMEQ3                      2454
#define IDS_INFOKEY_55                  2455
#define IDS_BUSINESSQ1                  2455
#define IDS_SCSI_ADAPTER                2456
#define IDS_COMPUTER_MODEL              2457
#define IDS_INFOKEY_58                  2458
#define IDS_MIDDLE_NAME                 2458
#define IDS_INFOKEY_59                  2459
#define IDS_INFOKEY_60                  2460
#define IDS_INFOKEY_61                  2461
#define IDS_INFOKEY_62                  2462
#define IDS_INFOKEY_63                  2463
#define IDS_INFOKEY_64                  2464
#define IDS_FECOUNTRY_LIST              2465
#define IDS_BUSINESSUSER_SCR_TITLE      2466
#define IDS_BUSINESSUSER_SCR_STITLE     2467
#define IDS_HOMEUSER_SCR_TITLE          2468
#define IDS_HOMEUSER_SCR_STITLE         2469
#define IDS_BUSINESSROLE_LIST           2470
#define IDS_SI_DEVICENAME               2471
#define IDS_SI_DEVICEDESCRIPTION        2472
#define IDS_STRING2473                  2473
#define IDS_SUCCESS_TEXT                2473
#define IDS_FINAL_UNSUCCESS_PREFIX      2474
#define IDS_FINAL_UNSUCCESS_SUFFIX      2475
#define IDS_NOTUSED                     2476
#define IDS_OSBUILDNUMBER               2477

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        256
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1081
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\rundll32\rundll.h ===
#ifndef STRICT
#define STRICT
#endif

#include <nt.h>             // We need these header files for the auto-version
#include <ntrtl.h>          // patching stuff...
#include <nturtl.h>

#define _INC_OLE
#include <windows.h>
#undef _INC_OLE

#include <shlobj.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlobjp.h>
#include <imagehlp.h>

#define IDI_DEFAULT     100

#define IDS_UNKNOWNERROR        0x100

#define IDS_LOADERR             0x300

#define IDS_GETPROCADRERR       0x400
#define IDS_CANTLOADDLL         0x401
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\runonce\debug.c ===
#include "precomp.h"
#pragma  hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "runonce"
#define SZ_MODULE           "RUNONCE"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\regwiz\sysinv\sysinv.h ===
#ifndef __sysinv__
#define __sysinv__

#ifdef  __cplusplus
extern "C" {
#endif

/*
 * Function:
 *	BOOL WINAPI GetSystemInventory(INT type, LPTSTR szInventory);
 *
 * Description:
 *	Get system inventory information by type caller asked
 *
 * Parameters:
 *	INT type:	specify what type information caller.  Should be one of INV_* constants
 *	LPTSTR szInventory:	The description of specific item information on return.  The contents depends on item type.
 *						The length of the buffer has to be at least 256.
 *
 * Return Value:
 *	TRUE on success.
 *	FALSE on failure.  szInventory[0] is also assigned 0
 */
BOOL WINAPI GetSystemInventory(INT, LPTSTR);

#define INV_OEM				1	// szInventory: Descriptive string
#define INV_PROCESSORTYPE	2	// szInventory: Descriptive string
#define INV_TOTALMEMORY		3	// szInventory: Descriptive string
#define INV_TOTALHDSPACE	4	// szInventory: Descriptive string
#define INV_DISPRESOLUTION	5	// szInventory: Descriptive string
#define INV_DISPCOLORDEPTH	6	// szInventory: Descriptive string
#define INV_WINVERSION		7	// szInventory: Descriptive string
#define INV_NETCARD			8	// szInventory: Descriptive string
#define INV_MODEM			9	// szInventory: Descriptive string
#define INV_POINTDEVICE		10	// szInventory: Descriptive string
#define INV_CDROM			11	// szInventory: Descriptive string
#define INV_SOUNDCARD		12	// szInventory: Descriptive string
#define INV_REMOVEABLEMEDIA	13	// szInventory: Descriptive string
#define INV_COPRECESSOR		14	// szInventory[0] = 1 for available, 0 for nonavailable
#define INV_SCSIADAPTER     15  //  
#define INV_DISPLAY_ADAPTER 16  // Display Adapter with Driver
#define INV_DISPLAY_WITH_RESOLUTION 17 // Display Adapter and Color resolution
#ifdef __cplusplus
}   /* ... extern "C" */
#endif

#endif


#include <tchar.h>

void GetOEMString(LPTSTR);
void GetProcessorTypeString(LPTSTR);
void GetTotalMemoryString(LPTSTR);
void GetTotalHardDiskSpaceString(LPTSTR);
void GetDisplayResolutionString(LPTSTR);
void GetDisplayColorDepthString(LPTSTR);
void GetWindowsVersionString(LPTSTR);
void GetNetworkCardString(LPTSTR);
void GetModemString(LPTSTR);
void GetPointingDeviceString(LPTSTR);
void GetCDRomString(LPTSTR);
void GetSoundCardString(LPTSTR);
void GetRemoveableMediaString(LPTSTR);
void GetScsiAdapterString(LPTSTR szInventory);
void GetDisplayAdapter(LPTSTR szDisplayAdapter);
void GetDisplayAdapterWithResolution(LPTSTR);


BOOL IsCoProcessorAvailable(void);
LONG GetTotalHardDiskSpace(void);
void GetDisplayCharacteristics(PINT, PINT, PINT);
void GetWindowsVersion(LONG*, LONG*, LONG*,LONG*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\rundll32\rundll.c ===
#include "rundll.h"

#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define IsPathSep(ch)       ((ch) == TEXT('\\') || (ch) == TEXT('/'))
#define Reference(x) ((x)=(x))
#define BLOCK

void WINAPI RunDllErrMsg(HWND hwnd, UINT idStr, LPCTSTR pszTitle, LPCTSTR psz1, LPCTSTR psz2);
int PASCAL WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);

TCHAR const g_szAppName [] = TEXT("RunDLL");
TCHAR const c_szNULL[] = TEXT("");
TCHAR const c_szLocalizeMe[] = TEXT("RUNDLL");

HANDLE g_hActCtx = INVALID_HANDLE_VALUE;
ULONG_PTR g_dwActCtx = 0;
BOOL g_fCatchExceptions = TRUE;

HINSTANCE g_hinst;
HICON g_hIcon;

HINSTANCE g_hModule;
HWND g_hwndStub;
BOOL g_fUseCCV6 = FALSE;

#ifdef WX86
#include <wx86dll.h>

WX86LOADX86DLL_ROUTINE pWx86LoadX86Dll = NULL;
WX86THUNKPROC_ROUTINE pWx86ThunkProc = NULL;
HMODULE g_hWx86Dll = NULL;
#endif

RUNDLLPROC g_lpfnCommand;
BOOL g_fCmdIsANSI;   // TRUE if g_lpfnCommand() expects ANSI strings

LPTSTR PASCAL StringChr(LPCTSTR lpStart, TCHAR ch)
{
    for (; *lpStart; lpStart = CharNext(lpStart))
    {
        if (*lpStart == ch)
            return (LPTSTR)lpStart;
    }
    return NULL;
}

LPTSTR PASCAL StringHasPathChar(LPCTSTR lpStart)
{
    for (; *lpStart; lpStart = CharNext(lpStart))
    {
        if (IsPathSep(*lpStart))
            return (LPTSTR)lpStart;
    }
    return NULL;
}

// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) 
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) 
    {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}


BOOL PASCAL ParseCommand(LPTSTR lpszCmdLine, UINT cchCmdLine, int nCmdShow)
{
    LPTSTR lpStart, lpEnd, lpFunction;
    ACTCTX act;
    TCHAR szManifest[MAX_PATH];
    LPTSTR pszFullPath;
    TCHAR szPath[MAX_PATH];
    TCHAR kszManifest[] = TEXT(".manifest");
    LPTSTR pszName;
    BOOL bManifest = FALSE;

#ifdef DEBUG
OutputDebugString(TEXT("RUNDLL: Command: "));
OutputDebugString(lpszCmdLine);
OutputDebugString(TEXT("\r\n"));
#endif

    for (lpStart = lpszCmdLine; ; )
    {
        // Skip leading blanks
        while (*lpStart == TEXT(' '))
        {
            ++lpStart;
        }

        // Check if there are any switches
        if (*lpStart != TEXT('/'))
        {
            break;
        }

        // Look at all the switches; ignore unknown ones
        for (++lpStart; ; ++lpStart)
        {
            switch (*lpStart)
            {
            case TEXT(' '):
            case TEXT('\0'):
                goto EndSwitches;
                break;

            // Put any switches we care about here
            case TEXT('d'):
            case TEXT('D'):
                // Disable exception catching.
                g_fCatchExceptions = FALSE;
                break;

            default:
                break;
            }
        }
EndSwitches:
       ;
    }

    // If the path is double-quoted, search for the next
    // quote, otherwise, look for a space 
            
    lpEnd = lpStart;
    if ( *lpStart == TEXT('\"') )
    {
        // Skip opening quote
        lpStart++;
                    
        // Scan, and skip over, subsequent characters until
        // another double-quote or a null is encountered.
            
        while ( *++lpEnd && (*lpEnd != TEXT('\"')) )
            NULL;
        if (!*lpEnd)
            return FALSE;
                        
        *lpEnd++ = TEXT('\0');
    }
    else
    {
        // No quotes, so run until a space or a comma
        while ( *lpEnd && (*lpEnd != TEXT(' ')) && (*lpEnd != TEXT(',')))
            lpEnd++;
        if (!*lpEnd)
            return FALSE;

        *lpEnd++ = TEXT('\0');
    }

    // At this point we're just past the terminated dll path.   We
    // then skip spaces and commas, which should take us to the start of the 
    // entry point (lpFunction)

    while ( *lpEnd && ((*lpEnd == TEXT(' ')) || (*lpEnd == TEXT(','))))
        lpEnd++;
    if (!*lpEnd)
        return FALSE;

    lpFunction = lpEnd;

    // If there's a space after the function name, we need to terminate 
    // the function name and move the end pointer, because that's where
    // the arguments to the function live.

    lpEnd = StringChr(lpFunction, TEXT(' '));
    if (lpEnd)
        *lpEnd++ = TEXT('\0');

    // If there is a path component in the function name, bail out.
    if (StringHasPathChar(lpFunction))
        return FALSE;

    // Load the library and get the procedure address
    // Note that we try to get a module handle first, so we don't need
    // to pass full file names around
    //

    // Get the full name of the DLL
    pszFullPath = lpStart;

    // If the path is not specified, find it
    if (GetFileAttributes(lpStart) == -1)
    {
        if (SearchPath(NULL, lpStart, NULL, ARRAYSIZE(szPath), szPath, &pszName) > 0)
        {
            pszFullPath = szPath;
        }
    }

    // First see if there is an blah.dll.manifest
    act.cbSize = sizeof(act);
    act.dwFlags = 0;

    if (SUCCEEDED(StringCchCopy(szManifest, ARRAYSIZE(szManifest), pszFullPath)) &&
            SUCCEEDED(StringCchCat(szManifest, ARRAYSIZE(szManifest), kszManifest)))
    {
        bManifest = TRUE;
    }

    if (bManifest && GetFileAttributes(szManifest) != -1)
    {
        act.lpSource = szManifest;

        g_hActCtx = CreateActCtx(&act);
    }
    else
    {
        // No? See if there is one in the binary.
        act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpSource = pszFullPath;
        act.lpResourceName = MAKEINTRESOURCE(123);

        g_hActCtx = CreateActCtx(&act);
    }

    if (g_hActCtx != INVALID_HANDLE_VALUE)
        ActivateActCtx(g_hActCtx, &g_dwActCtx);

    g_hModule = LoadLibrary(lpStart);

#ifdef WX86

    //
    // If the load fails try it thru wx86, since it might be an
    // x86 on risc binary
    //

    if (g_hModule==NULL) 
    {
        g_hWx86Dll = LoadLibrary(TEXT("wx86.dll"));
        if (g_hWx86Dll) 
        {
            pWx86LoadX86Dll = (PVOID)GetProcAddress(g_hWx86Dll, "Wx86LoadX86Dll");
            pWx86ThunkProc  = (PVOID)GetProcAddress(g_hWx86Dll, "Wx86ThunkProc");
            if (pWx86LoadX86Dll && pWx86ThunkProc) 
            {
                g_hModule = pWx86LoadX86Dll(lpStart, 0);
            }
        }

        if (!g_hModule) 
        {
            if (g_hWx86Dll) 
            {
                FreeLibrary(g_hWx86Dll);
                g_hWx86Dll = NULL;
            }
        }
    }
#endif


    if (g_hModule==NULL)
    {
        TCHAR szSysErrMsg[MAX_PATH];
        BOOL fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                            NULL, GetLastError(), 0, szSysErrMsg, ARRAYSIZE(szSysErrMsg), NULL);
        if (fSuccess)
        {
            RunDllErrMsg(NULL, IDS_CANTLOADDLL, c_szLocalizeMe, lpStart, szSysErrMsg);
        }
        return FALSE;
    }

    BLOCK
    {
        //
        // Check whether we need to run as a different windows version
        //
        // Stolen from ntos\mm\procsup.c
        //
        //
        PPEB Peb = NtCurrentPeb();
        PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)g_hModule;
        PIMAGE_NT_HEADERS pHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)g_hModule + pDosHeader->e_lfanew);
        PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
        ULONG ReturnedSize;

        if (pHeader->FileHeader.SizeOfOptionalHeader != 0 &&
            pHeader->OptionalHeader.Win32VersionValue != 0)
        {
            Peb->OSMajorVersion = pHeader->OptionalHeader.Win32VersionValue & 0xFF;
            Peb->OSMinorVersion = (pHeader->OptionalHeader.Win32VersionValue >> 8) & 0xFF;
            Peb->OSBuildNumber  = (USHORT)((pHeader->OptionalHeader.Win32VersionValue >> 16) & 0x3FFF);
            Peb->OSPlatformId   = (pHeader->OptionalHeader.Win32VersionValue >> 30) ^ 0x2;
        }

        ImageConfigData = ImageDirectoryEntryToData( Peb->ImageBaseAddress,
                                                        TRUE,
                                                        IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                        &ReturnedSize
                                                );
        if (ImageConfigData != NULL && ImageConfigData->CSDVersion != 0)
        {
            Peb->OSCSDVersion = ImageConfigData->CSDVersion;
        }
    }

    // Special case: load function by ordinal
    // '#' was used by GetProcAddress in the Win16 days
    if (lpFunction[0] == TEXT('#') && lpFunction[1] != TEXT('\0'))
    {
        g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, MAKEINTRESOURCEA(_wtoi(lpFunction + 1)));
        // Support Unicode exports only
        g_fCmdIsANSI = FALSE;
    } 
    else
    {
        /*
        * Look for a 'W' tagged Unicode function.
        * If it is not there, then look for the 'A' tagged ANSI function
        * if we cant find that one either, then look for an un-tagged function
        */
        LPSTR lpstrFunctionName;
        UINT cchLength;

        cchLength = lstrlen(lpFunction)+1;
        g_fCmdIsANSI = FALSE;

        lpstrFunctionName = (LPSTR)LocalAlloc(LMEM_FIXED, (cchLength+1)*2);    // +1 for "W",  *2 for DBCS

        if (lpstrFunctionName && (WideCharToMultiByte (CP_ACP, 0, lpFunction, cchLength,
                            lpstrFunctionName, cchLength*2, NULL, NULL))) 
        {
            cchLength = lstrlenA(lpstrFunctionName);
            lpstrFunctionName[cchLength] = 'W';        // convert name to Wide version
            lpstrFunctionName[cchLength+1] = '\0';

            g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, lpstrFunctionName);

            if (g_lpfnCommand == NULL) 
            {
                // No UNICODE version, try for ANSI
                lpstrFunctionName[cchLength] = 'A';        // convert name to ANSI version
                g_fCmdIsANSI = TRUE;

                g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, lpstrFunctionName);

                if (g_lpfnCommand == NULL) 
                {
                    // No ANSI version either, try for non-tagged
                    lpstrFunctionName[cchLength] = '\0';        // convert name to ANSI version

                    g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, lpstrFunctionName);
                }
            }
        }
        if (lpstrFunctionName) 
        {
            LocalFree((LPVOID)lpstrFunctionName);
        }
    }

#ifdef WX86
    if (g_lpfnCommand && g_hWx86Dll) 
    {
        g_lpfnCommand = pWx86ThunkProc(g_lpfnCommand, (PVOID)4, TRUE);
    }
#endif

    if (!g_lpfnCommand)
    {
        RunDllErrMsg(NULL, IDS_GETPROCADRERR, c_szLocalizeMe, lpStart, lpFunction);
        FreeLibrary(g_hModule);
        return(FALSE);
    }

    // Copy the rest of the command parameters down
    //
    if (lpEnd)
    {
        return SUCCEEDED(StringCchCopy(lpszCmdLine, cchCmdLine, lpEnd));
    }
    else
    {
        *lpszCmdLine = TEXT('\0');
    }

    return(TRUE);
}

LRESULT PASCAL StubNotify(HWND hWnd, WPARAM wParam, RUNDLL_NOTIFY FAR *lpn)
{
    switch (lpn->hdr.code)
    {
    case RDN_TASKINFO:
// don't need to set title too
//      SetWindowText(hWnd, lpn->lpszTitle ? lpn->lpszTitle : c_szNULL);
        g_hIcon = lpn->hIcon ? lpn->hIcon :
                LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_DEFAULT));

        SetClassLongPtr(hWnd, GCLP_HICON, (DWORD_PTR)g_hIcon);

        return 0L;

    default:
        return(DefWindowProc(hWnd, WM_NOTIFY, wParam, (LPARAM)lpn));
    }
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    switch(iMessage)
    {
    case WM_CREATE:
        g_hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_DEFAULT));
        break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        return(StubNotify(hWnd, wParam, (RUNDLL_NOTIFY *)lParam));

#ifdef COOLICON
    case WM_QUERYDRAGICON:
        return(MAKELRESULT(g_hIcon, 0));
#endif

    default:
        return DefWindowProc(hWnd, iMessage, wParam, lParam);
    }

    return 0L;
}


BOOL PASCAL InitStubWindow(HINSTANCE hInst, HINSTANCE hPrevInstance)
{
    WNDCLASS wndclass;

    if (!hPrevInstance)
    {
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = WndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = 0;
        wndclass.hInstance     = hInst;
#ifdef COOLICON
        wndclass.hIcon         = NULL;
#else
        wndclass.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDI_DEFAULT));
#endif
        wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
        wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = g_szAppName;

        if (!RegisterClass(&wndclass))
        {
            return(FALSE);
        }
    }

    g_hwndStub = CreateWindowEx(WS_EX_TOOLWINDOW,
                                g_szAppName, c_szNULL, WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL, hInst, NULL);

    return(g_hwndStub != NULL);
}


void PASCAL CleanUp(void)
{
    DestroyWindow(g_hwndStub);

    FreeLibrary(g_hModule);
}


int PASCAL WinMainT (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    LPTSTR lpszCmdLineCopy;
    HANDLE hFusionManifest;
    LPVOID pchCmdLine;

    UINT cchCmdLine = lstrlen(lpszCmdLine) + 1;

    g_hinst = hInstance;

    // make a copy of lpCmdLine, since ParseCommand modifies the string
    lpszCmdLineCopy = LocalAlloc(LPTR, cchCmdLine * sizeof(TCHAR));
    if (!lpszCmdLineCopy)
    {
        goto Error0;
    }
    if (FAILED(StringCchCopy(lpszCmdLineCopy, cchCmdLine, lpszCmdLine)) ||
        !ParseCommand(lpszCmdLineCopy, cchCmdLine, nCmdShow))
    {
        goto Error1;
    }

    // turn off critical error message box
    SetErrorMode(g_fCatchExceptions ? (SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS) : SEM_NOOPENFILEERRORBOX);

    if (!InitStubWindow(hInstance, hPrevInstance))
    {
        goto Error2;
    }

    
    pchCmdLine = lpszCmdLineCopy;

    if (g_fCmdIsANSI) 
    {
        int cchCmdLineW = lstrlen(lpszCmdLineCopy) + 1;
        int cbCmdLineA;

        cbCmdLineA = WideCharToMultiByte(CP_ACP, 0, lpszCmdLineCopy, cchCmdLineW, NULL, 0, NULL, NULL);
        pchCmdLine = LocalAlloc( LMEM_FIXED, cbCmdLineA );
        if (pchCmdLine == NULL) 
        {
            RunDllErrMsg(NULL, IDS_LOADERR+00, c_szLocalizeMe, lpszCmdLineCopy, NULL);
            goto Error3;
        }

        WideCharToMultiByte(CP_ACP, 0, lpszCmdLineCopy, cchCmdLineW, pchCmdLine, cbCmdLineA, NULL, NULL);
    }

    if (g_fCatchExceptions)
    {
        try
        {
            g_lpfnCommand(g_hwndStub, hInstance, pchCmdLine, nCmdShow);
        }
        _except (EXCEPTION_EXECUTE_HANDLER)
        {
            RunDllErrMsg(NULL, IDS_LOADERR+17, c_szLocalizeMe, lpszCmdLine, NULL);
        }
    }
    else
    {
        g_lpfnCommand(g_hwndStub, hInstance, pchCmdLine, nCmdShow);
    }

Error3:
    if (g_fCmdIsANSI) 
    {
        LocalFree(pchCmdLine);
    }

Error2:
    CleanUp();
Error1:
    LocalFree(lpszCmdLineCopy);
Error0:
    if (g_hActCtx != INVALID_HANDLE_VALUE)
    {
        DeactivateActCtx(0, g_dwActCtx);
        ReleaseActCtx(g_hActCtx);
        g_hActCtx = NULL;
    }

    return(FALSE);
}

void WINAPI RunDllErrMsg(HWND hwnd, UINT idStr, LPCTSTR pszTitle, LPCTSTR psz1, LPCTSTR psz2)
{
    TCHAR szTmp[200];
    TCHAR szMsg[200 + MAX_PATH];

    if (LoadString(g_hinst, idStr, szTmp, ARRAYSIZE(szTmp)))
    {
        StringCchPrintf(szMsg, ARRAYSIZE(szMsg), szTmp, psz1, psz2);
        MessageBox(hwnd, szMsg, pszTitle, MB_OK|MB_ICONHAND);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\runonce\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by RUNONCE.RC
//
#define IDS_NEED_REBOOT                 1
#define IDS_NEED_RESTART                2
#define IDS_PAMPER                      3
#define IDD_RUNONCE                     101
#define IDB_BACK_WASH                   103
#define IDD_WASH                        104
#define IDB_BITMAP1                     105
#define IDI_SETUP                       106
#define IDC_LIST2                       1002
#define IDC_WASH_BMP                    1003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\runonce\precomp.h ===
#define OEMRESOURCE
#include <windows.h>
#include <ccstock.h>
#include <debug.h>

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
BOOL   RunOnceFill(HWND hWnd);
LRESULT CALLBACK dlgProcRunOnce(
                HWND hWnd,         // window handle
                UINT message,      // type of message
                WPARAM uParam,     // additional information
                LPARAM lParam);     // additional information
void WashCreate(HWND hwndParent);

BOOL   CreateGlobals(HWND hwndCtl);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);
BOOL TopLeftWindow(HWND hwndChild, HWND hwndParent);

extern SIZE g_SizeTextExt;
extern int g_cxIcon;
extern int g_cyIcon;
extern int g_cxSmIcon;
extern int g_cySmIcon;
extern HFONT g_hfont;
extern HBRUSH g_hbrBkGnd;
extern HFONT g_hBoldFont;
extern HINSTANCE hInst;
extern HWND g_hWash;

#define MAX_TITLE 32
#define MAX_TEXT 128

typedef struct tagTASK
{
     TCHAR Text[MAX_TEXT+1];
     WORD wHeight;
     HICON hIcon;
     TCHAR Cmd[MAX_PATH+1];
} TASK,  * PTASK;

// Bit fields for command line switches.
#define CMD_DO_CHRIS 1
#define CMD_DO_REBOOT 2
#define CMD_DO_RESTART 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\runonce\init.c ===
//---------------------------------------------------------------------------
// Windows 4.0 Task Switcher. Copyright Microsoft Corp. 1993.
// Insept: May 1993     IanEl.
// Bastardised for RunOnce by FelixA.
//---------------------------------------------------------------------------
// #include <windows.h>
#include "precomp.h"

//---------------------------------------------------------------------------
// Global to everybody...
HINSTANCE g_hinst;
HWND g_hwndLB = NULL;
HWND g_hwndMain = NULL;
HWND g_hwndStatus = NULL;
const TCHAR g_szNull[] = TEXT("");

// Icon sizes.
int g_cxIcon = 0;
int g_cyIcon = 0;
int g_cxSmIcon = 0;
int g_cySmIcon = 0;
// Extent of text in buttons.
DWORD g_dwBTextExt = 0;
SIZE g_SizeTextExt;

//---------------------------------------------------------------------------
// Global to this file only...

HFONT g_hfont = NULL;
HFONT g_hBoldFont=NULL;

static int g_iItemCur = 0;
static TCHAR g_szLotsaWs[] = TEXT("WWWWWWWWWW");
HBRUSH g_hbrBkGnd = NULL;

//---------------------------------------------------------------------------
BOOL   CreateGlobals(HWND hwndCtl)
{
    LOGFONT lf;
    HDC hdc;
    HFONT hfontOld;

    g_cxIcon = GetSystemMetrics(SM_CXICON);
    g_cyIcon = GetSystemMetrics(SM_CYICON);
    g_cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    g_cySmIcon = GetSystemMetrics(SM_CYSMICON);
    g_hbrBkGnd = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
//    if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0))
    if ( (hfontOld = (HFONT)(WORD)SendMessage( hwndCtl, WM_GETFONT, 0, 0L )) != NULL )
    {
        if ( GetObject( hfontOld, sizeof(LOGFONT), (LPTSTR) &lf ) )
        {
            lf.lfWeight=400;
            g_hfont = CreateFontIndirect(&lf);
            lf.lfWeight=700;
            // lf.lfItalic=TRUE;
            g_hBoldFont = CreateFontIndirect(&lf);
        }
    }
        
    if (g_hfont)
    {
        // Calc sensible size for text in buttons.
        hdc = GetDC(NULL);
        hfontOld = SelectObject(hdc, g_hfont);
        GetTextExtentPoint(hdc, g_szLotsaWs, lstrlen(g_szLotsaWs), &g_SizeTextExt);
        SelectObject(hdc, hfontOld);
        ReleaseDC(NULL, hdc);
        return TRUE;
    }
    return FALSE;
}

//---------------------------------------------------------------------------
VOID   DestroyGlobals(void)
{
        if (g_hfont)
                DeleteObject(g_hfont);
        if (g_hBoldFont)
                DeleteObject(g_hBoldFont);
        if (g_hbrBkGnd)
                DeleteObject(g_hbrBkGnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1989 - 1999

!ENDIF

SEC_DIR = ..\..

C_DEFINES   = $(C_DEFINES) -DSTRICT -DUNICODE -D_UNICODE

USE_ATL=1
USE_MSVCRT=1
INCLUDES=\
    ..;\
    $(SEC_DIR)\inc;\

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

#
# Define PROFILE to enable IceCAP profiling.
#
!IF "$(PROFILE)" == "1"
USE_ICECAP=1
C_DEFINES=$(C_DEFINES) -DPROFILE
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\runonce\rodlg.c ===
// **************************************************************************
//
// rodlg.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1993
//  All rights reserved
//
//  RunOnce wrapper. This encapsulates all applications that would like
//  to run the first time we re-boot. It lists these apps for the user
//      and allows the user to launce the apps (like apple at ease).
//
//      5 June 1994     FelixA  Started
//  8 June  Felix   Defined registry strings and functionality.
//                  Got small buttons displayed, but not working.
//  9 June  Felix   Both big and small buttons. Nice UI.
//                  Got single click app launching.
//
// 23 June  Felix   Moving it to a Chicago make thingy not Dolphin
//
// *************************************************************************/
//
#include "precomp.h"
#include <shlobj.h>
#include <stdlib.h>
#include <regstr.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <strsafe.h>
// #include <shsemip.h>

extern int g_iState;    // Command line args.

extern HINSTANCE g_hInst;          // current instance

#define WM_FINISHED (WM_USER+0x123)

#include "resource.h"

int g_fCleanBoot;
TCHAR c_szRunOnce[]=REGSTR_PATH_RUNONCE;
TCHAR c_szSetup[]=REGSTR_PATH_SETUP;
TCHAR g_szWallpaper[] = TEXT("wallpaper");
TCHAR szTileWall[] = TEXT("TileWallpaper");
TCHAR szFallback[] = TEXT("*DisplayFallback");
const TCHAR c_szTimeChangedRunOnce[] = TEXT("WarnTimeChanged"); //kernel32 and explorer use this

// Run time can be set for big or small buttons.
int g_Small=0;
HDC g_hdcMem=NULL;
DWORD g_dwThread;

//***************************************************************************
//
// <Function>()
// <Explanation>
//
// ENTRY:
//      <Params>
//
// EXIT:
//      <Params>
//
//***************************************************************************

//***************************************************************************
//
// DoAnyRandomOneTimeStuff()
//   Just a place to toss random stuff for RunOnce app to do.
//
// ENTRY:
//      void
//
// EXIT:
//      void
//
//***************************************************************************
void DoAnyRandomOneTimeStuff(void)
{
    HKEY runonce;

    // remove any time-changed warning added by kernel32 during boot
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRunOnce, 0, KEY_SET_VALUE, &runonce) == ERROR_SUCCESS)
    {
        RegDeleteValue(runonce, (LPCTSTR)c_szTimeChangedRunOnce);
        RegCloseKey(runonce);
    }
}

//***************************************************************************
//
// RunOnceFill()
//   Fills the List box in the run-once dlg.
//
// ENTRY:
//      HWND of the thing to fill.
//
// EXIT:
//      <Params>
// BOOL NEAR PASCAL RunRegApps(HKEY hkeyParent, LPCSTR szSubkey, BOOL fDelete, BOOL fWait)
//
//***************************************************************************
BOOL   RunOnceFill(HWND hWnd)
{
    HKEY hkey;
    // HKEY hDescKey;
    BOOL fShellInit = FALSE;
    HKEY hkeyParent = HKEY_LOCAL_MACHINE;
    TCHAR szSubkey[MAX_PATH];
    BOOL fDelete=FALSE;
    BOOL fWait=FALSE;

    // Enumerate HKLM\Runonce\Setup - *.*
    StringCchCopy(szSubkey, ARRAYSIZE(szSubkey), c_szRunOnce);
    StringCchCat(szSubkey, ARRAYSIZE(szSubkey), TEXT("\\Setup"));
    if (RegOpenKeyEx(hkeyParent, szSubkey, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        DWORD cbData, cchValue, dwType, i;
        TCHAR szValueName[MAX_PATH], szCmdLine[MAX_PATH];
        LRESULT lRes;
        DWORD dwNumSubkeys=1, dwNumValues=5;

        for (i = 0; ; i++)
        {
            cchValue = sizeof(szValueName) / sizeof(TCHAR);
            cbData = sizeof(szCmdLine);

            if (RegEnumValue(hkey, i, szValueName, &cchValue, NULL, &dwType, (LPBYTE) szCmdLine, &cbData) != ERROR_SUCCESS)
                break;

            if (dwType == REG_SZ)
            {
                PTASK pTask;
                pTask = (PTASK)LocalAlloc( LPTR ,sizeof(TASK));
                StringCchCopy(pTask->Text, ARRAYSIZE(pTask->Text) - 1, szValueName);
                StringCchCopy(pTask->Cmd, ARRAYSIZE(pTask->Cmd) - 1, szCmdLine);
                lRes = SendMessage( hWnd, LB_ADDSTRING,  0, (LPARAM)pTask );
                if( lRes == LB_ERR || lRes == LB_ERRSPACE )
                {
                    LocalFree(pTask);
                    pTask=NULL;
                }
            }
        }
        RegCloseKey(hkey);
    }

    return(fShellInit);
}

//***************************************************************************
//
// LaunchApp()
//  Given an index into the list box, will spawn the task, wait for it to
// finish.
//
// ENTRY:
//      Index into list.
//
// EXIT:
//      <Params>
//
//***************************************************************************
int LaunchApp(HWND hWnd, WORD wItem )
{
    LPTSTR lpszCmdLine;
    STARTUPINFO startup;
#ifndef DEBUG
    PROCESS_INFORMATION pi;
#endif
    PTASK pTask;
    RECT rWnd;

    GetWindowRect(hWnd, &rWnd);
    SendMessage(hWnd,LB_SETCURSEL,wItem,0);
    pTask = (PTASK)SendMessage( hWnd, LB_GETITEMDATA, wItem, 0L);
    if(pTask != (PTASK)LB_ERR )
    {
        lpszCmdLine = &pTask->Cmd[0];

        // Now exec it.
        startup.cb = sizeof(startup);
        startup.lpReserved = NULL;
        startup.lpDesktop = NULL;
        startup.lpTitle = NULL;
        startup.dwFlags = STARTF_USEPOSITION; // Set start position
        startup.dwX=rWnd.right+5;
        startup.dwY=rWnd.top+5;
        startup.cbReserved2 = 0;
        startup.lpReserved2 = NULL;

#ifdef DEBUG
        MessageBox(hWnd, lpszCmdLine,TEXT("DebugRun"),MB_OK);
#else
        if (CreateProcess(NULL, lpszCmdLine, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP,
                    NULL, NULL, &startup, &pi))
        {
            WaitForSingleObjectEx(pi.hProcess, INFINITE, TRUE);
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
        else
        {
            MessageBeep( MB_ICONEXCLAMATION );
        }
#endif
    }
    else
    {
        MessageBeep( MB_ICONEXCLAMATION );
    }



    // Remove any selection after the app terminates.
    SendMessage( hWnd, LB_SETCURSEL, (WPARAM)-1, 0);
    return FALSE;
}

//***************************************************************************
//
// RunAppsInList()
// Enumerates all the items in the list box, spawning each in turn.
//
// ENTRY:
//      HWND of Parent.
//
// EXIT:
//      <Params>
//
//***************************************************************************
DWORD WINAPI RunAppsInList(LPVOID lp)
{
    HWND hWnd=(HWND)lp;
    WORD i,iNumItems;
    TCHAR szSubkey[MAX_PATH];
    TCHAR szWallpaper[MAX_PATH];
    DWORD cbSize;
    DWORD dwType;

    // Run all the applications in the list
    iNumItems = (WORD)SendMessage(hWnd,LB_GETCOUNT,0,0L);
    for(i=0;i<iNumItems;i++)
    {
        LaunchApp(hWnd,i);
    }

    // Delete the runonce subkey for setup.
#ifdef DEBUG
    MessageBox( hWnd, szSubkey, TEXT("Delete Key - not done"), MB_OK);
#else
    StringCchCopy(szSubkey, ARRAYSIZE(szSubkey), c_szRunOnce);
    StringCchCat(szSubkey, ARRAYSIZE(szSubkey), TEXT("\\Setup"));
    RegDeleteKey( HKEY_LOCAL_MACHINE, szSubkey );
#endif


    // Now see if we should reboot/restart.
    if (g_iState & (CMD_DO_REBOOT|CMD_DO_RESTART))
    {
        HKEY hkey;
        TCHAR achTitle[80];
        DWORD dwSetupFlags=0;

        //
        // because we are going to reboot, remove the VGA fallback.
        // line from OneRunce.
        //
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRunOnce, 0, KEY_SET_VALUE, &hkey) == ERROR_SUCCESS)
        {
            RegDeleteValue(hkey, szFallback);
            RegCloseKey(hkey);
        }

        szWallpaper[0]=0;
        LoadString(g_hInst, IDS_PAMPER, szWallpaper, sizeof(szWallpaper) / sizeof(TCHAR));
        GetWindowText(GetParent(hWnd), achTitle, sizeof(achTitle) / sizeof(TCHAR));

        // Get the setup flags.
        if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSetup, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
        {
            cbSize=sizeof(dwSetupFlags);
            if(RegQueryValueEx(hkey, REGSTR_VAL_SETUPFLAGS, NULL , &dwType, (LPBYTE)&dwSetupFlags, &cbSize) != ERROR_SUCCESS )
                dwSetupFlags=0;
            RegCloseKey(hkey);
        }
        //
        //  always reboot the system, dont give the user a choice.
        //
        //  alow OEMs not to have to click OK.
#ifdef DEBUG
        MessageBox(hWnd,dwSetupFlags & SUF_BATCHINF?TEXT("Batchfile used"):TEXT("No batch"),TEXT("Batch"),MB_OK);
#endif
        if( !(dwSetupFlags & SUF_BATCHINF) || !GetPrivateProfileInt(TEXT("Setup"),TEXT("NoPrompt2Boot"),0,TEXT("MSBATCH.INF")))
            MessageBox(GetParent(hWnd),szWallpaper,achTitle,MB_OK|MB_ICONEXCLAMATION);
#ifndef DEBUG
        ExitWindowsEx(EWX_REBOOT, 0);
#endif
    }

    PostMessage(GetParent(hWnd),WM_FINISHED,0,0L);
    return 0;
}


//***************************************************************************
//
// <Function>()
// <Explanation>
//
// ENTRY:
//      <Params>
//
// EXIT:
//      <Params>
//
//***************************************************************************
#define CXBORDER 3

LRESULT   _HandleLBMeasureItem(HWND hwndLB, MEASUREITEMSTRUCT  *lpmi)
{
    RECT    rWnd;
    int     wWnd;
    HDC     hDC;
    HFONT   hfontOld;
    PTASK   pTask;

    // Get the Height and Width of the child window
    GetWindowRect (hwndLB, &rWnd);
    wWnd = rWnd.right - rWnd.left;

    lpmi->itemWidth = wWnd;

    pTask = (PTASK)lpmi->itemData;

    hDC= GetDC(NULL);
    if( (hfontOld  = SelectObject(hDC,g_hBoldFont)) != 0 )
    {
        rWnd.top    = 0;
        rWnd.left   = CXBORDER*2 + g_cxSmIcon;
        rWnd.right  = lpmi->itemWidth - rWnd.left - CXBORDER*2 - g_cxSmIcon;
        rWnd.bottom = 0;
        DrawText(hDC,pTask->Text, lstrlen(pTask->Text),&rWnd, DT_CALCRECT | DT_WORDBREAK );
        SelectObject(hDC, hfontOld);
    }
    ReleaseDC(NULL,hDC);

    lpmi->itemHeight = rWnd.bottom + 2*CXBORDER;

    return TRUE;
}

//---------------------------------------------------------------------------
//***************************************************************************
//
// <Function>()
// <Explanation>
//
// ENTRY:
//      <Params>
//
// EXIT:
//      <Params>
//
//***************************************************************************
LRESULT   _HandleMeasureItem(HWND hwnd, MEASUREITEMSTRUCT  *lpmi)
{
    if (lpmi->CtlType == ODT_LISTBOX)
        return _HandleLBMeasureItem(hwnd, lpmi);
    return TRUE;
}

//---------------------------------------------------------------------------
//***************************************************************************
//
// _HandleLBDrawItem()
//  Draws the Title, Text, and icon for an entry.
//
// ENTRY:
//      HWND and the Item to draw.
//
// EXIT:
//      <Params>
//
//***************************************************************************
LRESULT   _HandleLBDrawItem(HWND hwndLB, DRAWITEMSTRUCT  *lpdi)
{
    RECT rc;
    HFONT hfontOld;
    int xArrow,y;
    PTASK pTask;
    BITMAP bm;
    HGDIOBJ hbmArrow,hbmOld;

    // Don't draw anything for an empty list.
    if ((int)lpdi->itemID < 0)
        return TRUE;

    pTask = (PTASK)lpdi->itemData;
    if(pTask == (PTASK)LB_ERR || !pTask )
        return FALSE;

    if ((lpdi->itemAction & ODA_SELECT) || (lpdi->itemAction & ODA_DRAWENTIRE))
    {
        // Put in the Title text
        hfontOld  = SelectObject(lpdi->hDC,(lpdi->itemState & ODS_SELECTED)?g_hBoldFont:g_hfont);
        ExtTextOut(lpdi->hDC,
                lpdi->rcItem.left+ CXBORDER*2 + g_cxSmIcon,
                lpdi->rcItem.top+CXBORDER,
                ETO_OPAQUE,
                &lpdi->rcItem,
                NULL, 0,
                NULL);
        rc.top    = lpdi->rcItem.top    + CXBORDER;
        rc.left   = lpdi->rcItem.left   + CXBORDER*2 + g_cxSmIcon;
        rc.right  = lpdi->rcItem.right;
        rc.bottom = lpdi->rcItem.bottom;
        DrawText( lpdi->hDC,
                pTask->Text, lstrlen(pTask->Text),
                &rc,
                DT_WORDBREAK);
        SelectObject(lpdi->hDC, hfontOld);

        // Draw the little triangle thingies.
        if(lpdi->itemState & ODS_SELECTED)
        {
            if (!g_hdcMem)
            {
                g_hdcMem = CreateCompatibleDC(lpdi->hDC);
            }
            // selected SRCSTENCIL=0x00d8074a
            // not selected SRCAND.
            if (g_hdcMem)
            {
                hbmArrow = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_MNARROW));
                GetObject(hbmArrow, sizeof(bm), &bm);
                hbmOld = SelectObject(g_hdcMem, hbmArrow);
                xArrow = lpdi->rcItem.left + CXBORDER; // - bm.bmWidth;
                y = ((g_SizeTextExt.cy - bm.bmHeight)/2) + CXBORDER + lpdi->rcItem.top;
                BitBlt(lpdi->hDC, xArrow, y, bm.bmWidth, bm.bmHeight, g_hdcMem, 0, 0, SRCAND); // dwRop);
                SelectObject(g_hdcMem, hbmOld);
                DeleteObject(hbmArrow);
            }
        }
    }
    return TRUE;
}

//---------------------------------------------------------------------------
LRESULT   _HandleCtlColorListbox(HWND hwnd, HDC hdc)
{
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
    return (LRESULT) g_hbrBkGnd;
}

//---------------------------------------------------------------------------
LRESULT   _HandleDrawItem(HWND hwnd, DRAWITEMSTRUCT  *lpdi)
{
    if (lpdi->CtlType == ODT_LISTBOX)
        return _HandleLBDrawItem(hwnd, lpdi);
    return TRUE;
}

//---------------------------------------------------------------------------
LRESULT   _HandleDeleteItem(HWND hwnd, DELETEITEMSTRUCT  *lpdi)
{
    if(lpdi)
        if(lpdi->itemData)
        {
            LocalFree( (HLOCAL)lpdi->itemData );
            return TRUE;
        }
    return FALSE;
}

//***************************************************************************
//
// ShrinkToFit()
//     Makes the List box no bigger then it has to be
//     makes the parent window rsize to the LB size.
//
// ENTRY:
//     hwnd Parent
//     hwnd List box
//
// EXIT:
//
//***************************************************************************
void ShrinkToFit( HWND hWnd, HWND hLb )
{
    LONG lCount;
    LONG lNumItems;
    LONG lTotalHeight;
    LONG lHeight;
    RECT rWnd;
    LONG lChange;

    lNumItems = (LONG)SendMessage( hLb, LB_GETCOUNT, 0, 0L );
    lTotalHeight =0;
    for( lCount=0;lCount<lNumItems; lCount++ )
    {
        lHeight = (LONG)SendMessage( hLb, LB_GETITEMHEIGHT, lCount, 0L );
        lTotalHeight+=lHeight;
    }

    // Set the height of the ListBox to the number of items in it.
    GetWindowRect (hLb, &rWnd);
    SetWindowPos( hLb, hWnd, 0,0,
            rWnd.right - rWnd.left - (CXBORDER*2 + g_cxSmIcon) ,
            lTotalHeight,
            SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER );

    // Work out how much it changed in height
    lChange = lTotalHeight - (rWnd.bottom-rWnd.top);

    // Size the parent to fit around the child.
    GetWindowRect(hWnd, &rWnd);
    SetWindowPos( hWnd,0, 0,0,
            rWnd.right - rWnd.left,
            rWnd.bottom-rWnd.top + lChange,
            SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER );
}


//***************************************************************************
//
// <Function>()
// <Explanation>
//
// ENTRY:
//      <Params>
//
// EXIT:
//      <Params>
//
//***************************************************************************
LRESULT CALLBACK dlgProcRunOnce(
        HWND hWnd,         // window handle
        UINT message,      // type of message
        WPARAM uParam,     // additional information
        LPARAM lParam)     // additional information
{
    int wmId, wmEvent;
    HANDLE hThread;

    switch (message)
    {
        case WM_DELETEITEM:
            return _HandleDeleteItem( hWnd, (LPDELETEITEMSTRUCT)lParam );

        case WM_MEASUREITEM:
            return _HandleMeasureItem(hWnd, (MEASUREITEMSTRUCT  *) lParam);

        case WM_DRAWITEM:
            return _HandleDrawItem(hWnd, (DRAWITEMSTRUCT  *) lParam);

        case WM_INITDIALOG:
            CreateGlobals( hWnd );
            DoAnyRandomOneTimeStuff();
            g_fCleanBoot = GetSystemMetrics(SM_CLEANBOOT);
            TopLeftWindow( hWnd, GetParent(hWnd) );
            RunOnceFill( GetDlgItem(hWnd,IDC_LIST2) );
            // Now calculate the size needed for the LB and resize LB and parent.
            ShrinkToFit( hWnd, GetDlgItem(hWnd,IDC_LIST2));
            hThread = CreateThread(NULL, 0, RunAppsInList, (LPVOID)GetDlgItem(hWnd,IDC_LIST2),0, &g_dwThread );
            CloseHandle(hThread);
            break;

        case WM_FINISHED:
            EndDialog(hWnd,0);
            // DestroyWindow(hWnd);
            break;

        case WM_CTLCOLORLISTBOX:
            return _HandleCtlColorListbox((HWND)lParam, (HDC)uParam);

        case WM_COMMAND:  // message: command from application menu
            wmId    = LOWORD(uParam);
            wmEvent = HIWORD(uParam);
            if( wmEvent==LBN_SELCHANGE )
            {
                // LaunchApp( (HWND) lParam, LOWORD(uParam) );
                // De-select the item now.
                break;
            }
            else
                switch (wmId)
                {
                    case IDOK:
                        EndDialog( hWnd, wmId);
                        break;

                    default:
                        // return (DefWindowProc(hWnd, message, uParam, lParam));
                        break;
                }
            break;


        default:          // Passes it on if unproccessed
            // return (DefWindowProc(hWnd, message, uParam, lParam));
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\ace.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ace.cpp
//
//  This file contains the implementation of the CAce class
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include "sddl.h"       // ConvertSidToStringSid


CAce::CAce(PACE_HEADER pAce):pszInheritSourceName(NULL),
                             iInheritSourceLevel(0)
{
    ULONG nSidLength = 0;
    ULONG nAceLength = SIZEOF(KNOWN_ACE) - SIZEOF(ULONG);

    ZeroMemory(this, SIZEOF(CAce));
    sidType = SidTypeInvalid;

	InheritedObjectType = GUID_NULL;

    if (pAce != NULL)
    {
        PSID psidT;

        // Copy the header and mask
        *(PACE_HEADER)this = *pAce;
        Mask = ((PKNOWN_ACE)pAce)->Mask;

        // Is this an object ACE?
        if (IsObjectAceType(pAce))
        {
            GUID *pGuid;

            nAceLength = SIZEOF(KNOWN_OBJECT_ACE) - SIZEOF(ULONG);

            // Copy the object type guid if present
            pGuid = RtlObjectAceObjectType(pAce);
            if (pGuid)
            {
                Flags |= ACE_OBJECT_TYPE_PRESENT;
                ObjectType = *pGuid;
                nAceLength += SIZEOF(GUID);
            }

            //
            //ACE_INHERITED_OBJECT_TYPE_PRESENT is invalid without
            //either of container inherit or object inherit flags.
            //NTRAID#NTBUG9-287737-2001/01/23-hiteshr
            //
            if (pAce->AceFlags & ACE_INHERIT_ALL)
            {

                //Copy the inherit type guid if present
                pGuid = RtlObjectAceInheritedObjectType(pAce);
                if (pGuid)
                {
                    Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                    InheritedObjectType = *pGuid;
                    nAceLength += SIZEOF(GUID);
                }
            }
        }

        // Copy the SID
        psidT = GetAceSid(pAce);
        nSidLength = GetLengthSid(psidT);

        psid = (PSID)LocalAlloc(LPTR, nSidLength);
        if (psid)
            CopyMemory(psid, psidT, nSidLength);
    }

    AceSize = (USHORT)(nAceLength + nSidLength);
}


CAce::~CAce()
{
    if (psid != NULL)
        LocalFree(psid);
    LocalFreeString(&pszName);
    LocalFreeString(&pszType);
    LocalFreeString(&pszAccessType);
    LocalFreeString(&pszInheritType);
    LocalFreeString(&pszInheritSourceName);
}

void 
CAce::SetInheritSourceInfo(LPCTSTR psz, INT level)
{
#define MAX_BUFFER 1000 
    iInheritSourceLevel = level;
    if(psz != NULL)
    {
        SetString(&pszInheritSourceName,psz); 
    }
    else
    {
        WCHAR Buffer[MAX_BUFFER];
        if(IsInheritedAce())
        {
            LoadString(::hModule, IDS_FROM_PARENT, Buffer, ARRAYSIZE(Buffer));
            SetString(&pszInheritSourceName,Buffer); 
            iInheritSourceLevel = -1;
        }
        else
        {
            LoadString(::hModule, IDS_NOT_INHERITED, Buffer, ARRAYSIZE(Buffer));
            SetString(&pszInheritSourceName,Buffer); 
            iInheritSourceLevel = 0;
        }
    }
}

LPTSTR
CAce::LookupName(LPCTSTR pszServer, LPSECURITYINFO2 psi2)
{
    if (SidTypeInvalid == sidType)
    {
        PUSER_LIST pUserList = NULL;
        LPCTSTR pszN = NULL;
        LPCTSTR pszL = NULL;

        sidType = SidTypeUnknown;

        if (LookupSid(psid, pszServer, psi2, &pUserList))
        {
            sidType = pUserList->rgUsers[0].SidType;
            pszN = pUserList->rgUsers[0].pszName;
            pszL = pUserList->rgUsers[0].pszLogonName;
        }

        SetName(pszN, pszL);

        if (pUserList)
            LocalFree(pUserList);
    }

    return pszName;
}


void
CAce::SetName(LPCTSTR pszN, LPCTSTR pszL)
{
    LocalFreeString(&pszName);
    if (!BuildUserDisplayName(&pszName, pszN, pszL) && psid)
        ConvertSidToStringSid(psid, &pszName);
}


void
CAce::SetSid(PSID p, LPCTSTR pszName, LPCTSTR pszLogonName, SID_NAME_USE type)
{
    ULONG nSidLength = 0;
    ULONG nAceLength = SIZEOF(KNOWN_ACE) - SIZEOF(ULONG);

    if (psid != NULL)
    {
        LocalFree(psid);
        psid = NULL;
    }

    if (p != NULL)
    {
        nSidLength = GetLengthSid(p);

        psid = (PSID)LocalAlloc(LPTR, nSidLength);
        if (psid)
            CopyMemory(psid, p, nSidLength);
    }

    if (Flags != 0)
    {
        nAceLength = SIZEOF(KNOWN_OBJECT_ACE) - SIZEOF(ULONG);

        if (Flags & ACE_OBJECT_TYPE_PRESENT)
            nAceLength += SIZEOF(GUID);

        if (Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
            nAceLength += SIZEOF(GUID);
    }

    AceSize = (USHORT)(nAceLength + nSidLength);

    sidType = type;
    SetName(pszName, pszLogonName);
}


void
CAce::SetString(LPTSTR *ppszDest, LPCTSTR pszSrc)
{
    LocalFreeString(ppszDest);
    if (NULL != pszSrc)
        LocalAllocString(ppszDest, pszSrc);
}


PACE_HEADER
CAce::Copy() const
{
    PACE_HEADER pAceCopy = (PACE_HEADER)LocalAlloc(LPTR, AceSize);
    CopyTo(pAceCopy);
    return pAceCopy;
}


void
CAce::CopyTo(PACE_HEADER pAceDest) const
{
    if (pAceDest)
    {
        ULONG nAceLength = SIZEOF(KNOWN_ACE) - SIZEOF(ULONG);
        ULONG nSidLength;

        // Copy the header and mask
        *pAceDest = *(PACE_HEADER)this;
        ((PKNOWN_ACE)pAceDest)->Mask = Mask;

        // Is this an object ACE?
        if (IsObjectAceType(this))
        {
            GUID *pGuid;

            nAceLength = SIZEOF(KNOWN_OBJECT_ACE) - SIZEOF(ULONG);

            // Copy the object flags
            ((PKNOWN_OBJECT_ACE)pAceDest)->Flags = Flags;

            // Copy the object type guid if present
            pGuid = RtlObjectAceObjectType(pAceDest);
            if (pGuid)
            {
                *pGuid = ObjectType;
                nAceLength += SIZEOF(GUID);
            }

            // Copy the inherit type guid if present
            pGuid = RtlObjectAceInheritedObjectType(pAceDest);
            if (pGuid)
            {
                *pGuid = InheritedObjectType;
                nAceLength += SIZEOF(GUID);
            }
        }

        // Copy the SID
        nSidLength = GetLengthSid(psid);
        CopyMemory(GetAceSid(pAceDest), psid, nSidLength);

        // The size should already be correct, but set it here to be sure.
        pAceDest->AceSize = (USHORT)(nAceLength + nSidLength);
    }
}


int
CAce::CompareType(const CAce *pAceCompare) const
{
    //
    // Determine which ACE preceeds the other in canonical ordering.
    //
    // Return negative if this ACE preceeds pAceCompare, positive if
    // pAceCompare preceeds this ACE, and 0 if they are equivalent in
    // canonical ordering.
    //
    BOOL b1;
    BOOL b2;

    //
    // First check inheritance. Inherited ACEs follow non-inherited ACEs.
    //
    b1 = AceFlags & INHERITED_ACE;
    b2 = pAceCompare->AceFlags & INHERITED_ACE;

    if (b1 != b2)
    {
        // One (and only one) of the ACEs is inherited.
        return (b1 ? 1 : -1);
    }

    //
    // Next, Allow ACEs follow Deny ACEs.
    // Note that allow/deny has no effect on the ordering of Audit ACEs.
    //
    b1 = (AceType == ACCESS_ALLOWED_ACE_TYPE ||
          AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE);
    b2 = (pAceCompare->AceType == ACCESS_ALLOWED_ACE_TYPE ||
          pAceCompare->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE);

    if (b1 != b2)
    {
        // One of the ACEs is an Allow ACE.
        return (b1 ? 1 : -1);
    }

    //
    // Next, Object ACEs follow non-object ACEs.
    //
    b1 = (AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
          AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE);
    b2 = (pAceCompare->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
          pAceCompare->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE);

    if (b1 != b2)
    {
        // One of the ACEs is an Object ACE.
        return (b1 ? 1 : -1);
    }

    return 0;
}


DWORD
CAce::Merge(const CAce *pAce2)
{
    DWORD dwStatus;
    DWORD dwMergeFlags = 0;
    DWORD dwResult;

    if (pAce2 == NULL)
        return MERGE_FAIL;

    //if either of the ace is inherited and they are not from the same parent
    if( GetInheritSourceLevel() != pAce2->GetInheritSourceLevel() )
        return MERGE_FAIL;

    //
    // The ACEs have to be the same basic type and have the same SID or
    // there's no hope.
    //
    if (!IsEqualACEType(AceType, pAce2->AceType) ||
        !EqualSid(psid, pAce2->psid))
        return MERGE_FAIL;

    if (!IsEqualGUID(InheritedObjectType, pAce2->InheritedObjectType))
        return MERGE_FAIL;  // incompatible inherit object types

    if (Flags & ACE_OBJECT_TYPE_PRESENT)
        dwMergeFlags |= MF_OBJECT_TYPE_1_PRESENT;

    if (pAce2->Flags & ACE_OBJECT_TYPE_PRESENT)
        dwMergeFlags |= MF_OBJECT_TYPE_2_PRESENT;

    if (IsEqualGUID(ObjectType, pAce2->ObjectType))
        dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;

    if (IsAuditAlarmACE(AceType))
        dwMergeFlags |= MF_AUDIT_ACE_TYPE;

    dwStatus = MergeAceHelper(AceFlags,
                              Mask,
                              pAce2->AceFlags,
                              pAce2->Mask,
                              dwMergeFlags,
                              &dwResult);

    switch (dwStatus)
    {
    case MERGE_MODIFIED_FLAGS:
        AceFlags = (UCHAR)dwResult;
        break;

    case MERGE_MODIFIED_MASK:
        Mask = dwResult;
        break;
    }

    return dwStatus;
}


BOOL
IsEqualACEType(DWORD dwType1, DWORD dwType2)
{
    if (dwType1 >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
        dwType1 <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)
        dwType1 -= (ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE);

    if (dwType2 >= ACCESS_MIN_MS_OBJECT_ACE_TYPE &&
        dwType2 <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)
        dwType2 -= (ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE);

    return (dwType1 == dwType2);
}


DWORD
MergeAceHelper(DWORD dwAceFlags1,
               DWORD dwMask1,
               DWORD dwAceFlags2,
               DWORD dwMask2,
               DWORD dwMergeFlags,
               LPDWORD pdwResult)
{
    // Assumptions:
    //   The ACEs are the same basic type.
    //   The SIDs are the same for both.
    //   The Inherit object type is the same for both.

    if (pdwResult == NULL)
        return MERGE_FAIL;

    *pdwResult = 0;

    if (dwMergeFlags & MF_OBJECT_TYPE_EQUAL)
    {
        if (dwAceFlags1 == dwAceFlags2)
        {
            //
            // Everything matches except maybe the mask, which
            // can be combined here.
            //
            if (AllFlagsOn(dwMask1, dwMask2))
                return MERGE_OK_1;
            else if (AllFlagsOn(dwMask2, dwMask1))
                return MERGE_OK_2;

            *pdwResult = dwMask1 | dwMask2;
            return MERGE_MODIFIED_MASK;
        }
        else if ((dwAceFlags1 & VALID_INHERIT_FLAGS) == (dwAceFlags2 & VALID_INHERIT_FLAGS) &&
                dwMask1 == dwMask2)
		{
			// If 2 audit aces are identical except for the audit
            // type (success/fail), the flags can be combined.
			if (dwMergeFlags & MF_AUDIT_ACE_TYPE)        
            {
                *pdwResult = dwAceFlags1 | dwAceFlags2;
                return MERGE_MODIFIED_FLAGS;
            }
        }
        else if ((dwAceFlags1 & (NO_PROPAGATE_INHERIT_ACE | INHERITED_ACE | FAILED_ACCESS_ACE_FLAG | SUCCESSFUL_ACCESS_ACE_FLAG))
                    == (dwAceFlags2 & (NO_PROPAGATE_INHERIT_ACE | INHERITED_ACE | FAILED_ACCESS_ACE_FLAG | SUCCESSFUL_ACCESS_ACE_FLAG)))
        {
            // The NO_PROPAGATE_INHERIT_ACE bit is the same for both
            if (dwMask1 == dwMask2)
            {
                // The masks are the same, so we can combine inherit flags
                *pdwResult = dwAceFlags1;

                // INHERIT_ONLY_ACE should be turned on only if it is
                // already on in both ACEs, otherwise leave it off.
                if (!(dwAceFlags2 & INHERIT_ONLY_ACE))
                    *pdwResult &= ~INHERIT_ONLY_ACE;

                // Combine the remaining inherit flags and return
                *pdwResult |= dwAceFlags2 & (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
                return MERGE_MODIFIED_FLAGS;
            }
            else if (AllFlagsOn(dwMask1, dwMask2))
            {
                // mask1 contains mask2. If Ace1 is inherited onto all of the
                // same things that Ace2 is, then Ace2 is redundant.
                if ((!(dwAceFlags1 & INHERIT_ONLY_ACE) || (dwAceFlags2 & INHERIT_ONLY_ACE))
                    && AllFlagsOn(dwAceFlags1 & ACE_INHERIT_ALL, dwAceFlags2 & ACE_INHERIT_ALL))
                    return MERGE_OK_1;
            }
            else if (AllFlagsOn(dwMask2, dwMask1))
            {
                // Same as above, reversed.
                if ((!(dwAceFlags2 & INHERIT_ONLY_ACE) || (dwAceFlags1 & INHERIT_ONLY_ACE))
                    && AllFlagsOn(dwAceFlags2 & ACE_INHERIT_ALL, dwAceFlags1 & ACE_INHERIT_ALL))
                    return MERGE_OK_2;
            }
        }
    }
    else if (dwAceFlags1 == dwAceFlags2)
    {
        if (!(dwMergeFlags & MF_OBJECT_TYPE_1_PRESENT) &&
                 AllFlagsOn(dwMask1, dwMask2))
        {
            //
            // The other ACE has a non-NULL object type but this ACE has no object
            // type and a mask that includes all of the bits in the other one.
            // I.e. This ACE implies the other ACE.
            //
            return MERGE_OK_1;
        }
        else if (!(dwMergeFlags & MF_OBJECT_TYPE_2_PRESENT) &&
                 AllFlagsOn(dwMask2, dwMask1))
        {
            //
            // This ACE has a non-NULL object type but the other ACE has no object
            // type and a mask that includes all of the bits in this one.
            // I.e. The other ACE implies this ACE.
            //
            return MERGE_OK_2;
        }
    }

    return MERGE_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\aceedit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       aceedit.cpp
//
//  This file contains the implementation for the advanced ACE editor
//  page.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include "sddl.h"       // ConvertSidToStringSid

#define PWM_SELECT_PAGE             (WM_APP - 1)

//
//  Context Help IDs.
//
const static DWORD aAcePermHelpIDs[] =
{
    IDC_ACEE_INHERITWARNING,        IDH_NOHELP,
    IDC_ACEE_NAME_STATIC,           IDH_ACEE_PERM_NAME,
    IDC_ACEE_NAME,                  IDH_ACEE_PERM_NAME,
    IDC_ACEE_NAMEBUTTON,            IDH_ACEE_PERM_NAMEBUTTON,
    IDC_ACEE_APPLYONTO_STATIC,      IDH_ACEE_PERM_INHERITTYPE,
    IDC_ACEE_INHERITTYPE,           IDH_ACEE_PERM_INHERITTYPE,
    IDC_ACEE_ACCESS,                IDH_ACEE_PERM_LIST,
    IDC_ACEE_ALLOW,                 IDH_ACEE_PERM_LIST,
    IDC_ACEE_DENY,                  IDH_ACEE_PERM_LIST,
    IDC_ACEE_LIST,                  IDH_ACEE_PERM_LIST,
    IDC_ACEE_INHERITIMMEDIATE,      IDH_ACEE_PERM_INHERITIMMEDIATE,
    IDC_ACEE_CLEAR,                 IDH_ACEE_PERM_CLEAR,
    0, 0
};
const static DWORD aAceAuditHelpIDs[] =
{
    IDC_ACEE_INHERITWARNING,        IDH_NOHELP,
    IDC_ACEE_NAME_STATIC,           IDH_ACEE_AUDIT_NAME,
    IDC_ACEE_NAME,                  IDH_ACEE_AUDIT_NAME,
    IDC_ACEE_NAMEBUTTON,            IDH_ACEE_AUDIT_NAMEBUTTON,
    IDC_ACEE_APPLYONTO_STATIC,      IDH_ACEE_AUDIT_INHERITTYPE,
    IDC_ACEE_INHERITTYPE,           IDH_ACEE_AUDIT_INHERITTYPE,
    IDC_ACEE_ACCESS,                IDH_ACEE_AUDIT_LIST,
    IDC_ACEE_ALLOW,                 IDH_ACEE_AUDIT_LIST,
    IDC_ACEE_DENY,                  IDH_ACEE_AUDIT_LIST,
    IDC_ACEE_LIST,                  IDH_ACEE_AUDIT_LIST,
    IDC_ACEE_INHERITIMMEDIATE,      IDH_ACEE_AUDIT_INHERITIMMEDIATE,
    IDC_ACEE_CLEAR,                 IDH_ACEE_AUDIT_CLEAR,
    0, 0
};


class CACEPage : public CSecurityPage
{
private:
    PACE            m_pAce;
    HDPA           *m_phEntries;
    PSID            m_pSid;
    DWORD           m_siFlags;
    DWORD          *m_pdwResult;
    GUID            m_guidInheritType;
    BOOL            m_fInheritImmediateEnabled;
    BOOL            m_fPreviousImmediateSetting;
    BOOL            m_fReadOnly;
    BOOL            m_fPageDirty;
    SI_INHERIT_TYPE m_siInheritUnknown;
	CACEPage		*m_pOtherPage;
	HWND			m_hwnd;

public:
    CACEPage(LPSECURITYINFO psi,
             SI_PAGE_TYPE siType,
             PACE pAce,
             BOOL bReadOnly,
             DWORD dwFlags,
             DWORD *pdwResult,
             HDPA *phEntries);
    virtual ~CACEPage();

private:
    virtual BOOL DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Prevent propsheet callbacks from reaching the object that invoked us
    virtual UINT PSPageCallback(HWND, UINT, LPPROPSHEETPAGE) { return 1; }

    void EmptyCheckList(HWND hwndList);
    LONG CheckPermBoxes(HWND hwndList, PACE pAce, DWORD dwState);
    LONG InitCheckList(HWND hDlg, PACE pAce);
    LONG ReInitCheckList(HWND hDlg, HDPA hEntries);
	VOID DisplayNoControlMessage(HWND hDlg, BOOL bDisplay);
    void HideInheritedAceWarning(HWND hDlg);
    void InitDlg(HWND hDlg);
    BOOL OnChangeName(HWND hDlg);
    BOOL OnClearAll(HWND hDlg);
    void HandleSelChange(HWND hDlg, HWND hWnd);
    LONG OnApply(HWND hDlg, BOOL bClose);
	HWND m_hwndNoPerm;
	BOOL IsAclBloated(HWND hDlg);
	HDPA GetAceList(HWND hDlg);
};
typedef class CACEPage *LPACEPAGE;

CACEPage::CACEPage(LPSECURITYINFO psi,
                   SI_PAGE_TYPE siType,
                   PACE pAce,
                   BOOL bReadOnly,
                   DWORD dwFlags,
                   DWORD *pdwResult,
                   HDPA *phEntries)
: CSecurityPage(psi, siType), m_pAce(pAce), m_fReadOnly(bReadOnly),
    m_siFlags(dwFlags), m_pdwResult(pdwResult), m_phEntries(phEntries),
	m_hwndNoPerm(NULL),m_pOtherPage(NULL)
{
    if (m_pdwResult)
        *m_pdwResult = 0;
}

CACEPage::~CACEPage()
{
    if (m_pSid)
        LocalFree(m_pSid);
	if(m_hwndNoPerm)
		DestroyWindow(m_hwndNoPerm);
}


void
CACEPage::EmptyCheckList(HWND hwndList)
{
    SendMessage(hwndList, CLM_RESETCONTENT, 0, 0);
}


LONG
CACEPage::CheckPermBoxes(HWND hwndList, PACE pAce, DWORD dwState)
{
    LONG nLastChecked = -1;
    UINT cItems;
    BOOL bColumnAllow = FALSE;
    BOOL bColumnDeny = FALSE;

    //
    // Check all boxes that correspond to a particular ACE
    //

    if (hwndList == NULL || pAce == NULL)
        return -1;

    if (pAce->AceFlags & INHERITED_ACE)
        dwState |= CLST_DISABLED;

    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        // Only check one column (either allow or deny)

        if (IsEqualACEType(pAce->AceType, ACCESS_ALLOWED_ACE_TYPE))
            bColumnAllow = TRUE;        // Access allowed
        else if (IsEqualACEType(pAce->AceType, ACCESS_DENIED_ACE_TYPE))
            bColumnDeny = TRUE;         // Access denied
        else
            return -1;  // Bogus ACE
    }
    else if (m_siPageType == SI_PAGE_AUDIT)
    {
        // Either or both columns can be checked for audits

        if (pAce->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
            bColumnAllow = TRUE;        // Audit successful access

        if (pAce->AceFlags & FAILED_ACCESS_ACE_FLAG)
            bColumnDeny = TRUE;         // Audit failed access
    }
    else
        return -1;

    cItems = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    while (cItems > 0)
    {
        PSI_ACCESS pAccess;

        --cItems;
        pAccess = (PSI_ACCESS)SendMessage(hwndList, CLM_GETITEMDATA, cItems, 0);

        //
        // The below expression tests to see if this access mask enables
        // this access "rights" line.  It could have more bits enabled, but
        // as long as it has all of the ones from the pAccess->mask then
        // it effectively has that option enabled.
        //

        if (pAccess &&
            AllFlagsOn(pAce->Mask, pAccess->mask) &&
            (!(pAce->Flags & ACE_OBJECT_TYPE_PRESENT) ||
             IsSameGUID(pAccess->pguid, &pAce->ObjectType)))
        {
            WPARAM wItem;

            nLastChecked = cItems;


            if (bColumnAllow)
            {
                wItem = MAKELONG((WORD)cItems, COLUMN_ALLOW);
                SendMessage(hwndList,
                            CLM_SETSTATE,
                            wItem,
                            (LPARAM)dwState);
            }

            if (bColumnDeny)
            {
                wItem = MAKELONG((WORD)cItems, COLUMN_DENY);
                SendMessage(hwndList,
                            CLM_SETSTATE,
                            wItem,
                            (LPARAM)dwState);
            }
        }
    }

    return nLastChecked;
}


LONG
CACEPage::InitCheckList(HWND hDlg, PACE pAce)
{
    LONG nTopItemChecked;
    HDPA hList = NULL;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::InitCheckList");
    TraceAssert(hDlg != NULL);

    if (m_siPageType == SI_PAGE_AUDIT)
        SendDlgItemMessage(hDlg, IDC_ACEE_LIST, CLM_SETCOLUMNWIDTH, 0, 40);

    hList = DPA_Create(1);
    if (hList && pAce)
        DPA_AppendPtr(hList, pAce->Copy());

    nTopItemChecked = ReInitCheckList(hDlg, hList);

    if (hList)
        DestroyDPA(hList);

    TraceLeaveValue(nTopItemChecked);
}


LONG
CACEPage::ReInitCheckList(HWND hDlg, HDPA hEntries)
{
    LONG nTopItemChecked = -1;
    HWND hwndList;
    DWORD dwFlags;
    HRESULT hr;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_ACEEDIT, "CACEPage::ReInitCheckList");
    TraceAssert(hDlg != NULL);

    hwndList = GetDlgItem(hDlg, IDC_ACEE_LIST);

    EmptyCheckList(hwndList);

    dwFlags = SI_ADVANCED;

    if (m_siPageType == SI_PAGE_AUDIT)
        dwFlags |= SI_EDIT_AUDITS;

    if (m_siFlags == SI_ACCESS_PROPERTY)
        dwFlags |= SI_EDIT_PROPERTIES;

    //
    // Enumerate the permissions and add to the checklist
    //
    hr = _InitCheckList(hwndList,
                        m_psi,
                        &m_guidInheritType,
                        dwFlags,
                        m_siObjectInfo.hInstance,
                        m_siFlags,
                        NULL);
    if (SUCCEEDED(hr))
    {
        UINT cItems = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);
		
		//
		//On object page display the message if number
		//cItems is zero.
		//
		if(m_siFlags == SI_ACCESS_SPECIFIC)
			DisplayNoControlMessage(hDlg, !cItems);

        ULONG cAces = 0;
        
        if (hEntries)
            cAces = DPA_GetPtrCount(hEntries);

        //
        // Check the appropriate boxes
        //
        nTopItemChecked = MAXLONG;
        while (cAces > 0)
        {
            PACE_HEADER pAceHeader;

            --cAces;
            pAceHeader = (PACE_HEADER)DPA_FastGetPtr(hEntries, cAces);
            if (pAceHeader)
            {
                CAce Ace(pAceHeader);
                LONG nTop = CheckPermBoxes(hwndList, &Ace, CLST_CHECKED);
                if (-1 != nTop)
                    nTopItemChecked = min(nTopItemChecked, nTop);
            }
        }
        if (MAXLONG == nTopItemChecked)
            nTopItemChecked = -1;

        // Make sure the top item checked is scrolled into view.
        // (-1 scrolls to the top, same as 0.)
        SendMessage(hwndList, CLM_ENSUREVISIBLE, nTopItemChecked, 0);

        // Disable all of the boxes if we're in read-only mode
        if (m_fReadOnly)
            SendMessage(hwndList, WM_ENABLE, FALSE, 0);
    }

    SetCursor(hcur);
    TraceLeaveValue(nTopItemChecked);
}

VOID CACEPage::DisplayNoControlMessage(HWND hDlg, BOOL bDisplay)
{
	RECT rc;
	if(bDisplay)
	{
		ShowWindow(m_hwndNoPerm, SW_SHOW);
	}
	else
	{
		ShowWindow(m_hwndNoPerm, SW_HIDE);
	}
}

void CACEPage::HideInheritedAceWarning(HWND hDlg)
// Hides the message informing the user that the current ACE is inherited from
// the parent. Also moves and resizes controls as appropriate.
{
    // Array of control IDs to move up
    static UINT rgMoveControls[] =
    {
        IDC_ACEE_NAME_STATIC,
        IDC_ACEE_NAME,
        IDC_ACEE_NAMEBUTTON,
        IDC_ACEE_APPLYONTO_STATIC,
        IDC_ACEE_INHERITTYPE,
        IDC_ACEE_ACCESS,
        IDC_ACEE_ALLOW,
        IDC_ACEE_DENY,
    };

    // Get the message window dimensions
    HWND hwndControl = GetDlgItem(hDlg, IDC_ACEE_INHERITWARNING);
    RECT rect;
    GetWindowRect(hwndControl, &rect);

    // We need to move controls up this amount:
    int nMoveUpAmount = rect.bottom - rect.top;

    // Rather than hide the message window, destroy it altogether so WinHelp
    // doesn't confuse it with the "Name:" static during WM_CONTEXTMENU.
    DestroyWindow(hwndControl);

    // Move each of the controls we need to move up
    for (int nControl = 0; nControl < ARRAYSIZE(rgMoveControls); nControl++)
    {
        hwndControl = GetDlgItem(hDlg, rgMoveControls[nControl]);
        GetWindowRect(hwndControl, &rect);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rect, 2);
        SetWindowPos(hwndControl,
                     NULL,
                     rect.left,
                     rect.top - nMoveUpAmount,
                     0,
                     0,
                     SWP_NOSIZE | SWP_NOZORDER);
    }

    // Finally, we need to resize the list control, including adjusting its height
    hwndControl = GetDlgItem(hDlg, IDC_ACEE_LIST);
    GetWindowRect(hwndControl, &rect);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rect, 2);
    SetWindowPos(hwndControl,
                 NULL,
                 rect.left,
                 rect.top - nMoveUpAmount,
                 rect.right - rect.left,
                 rect.bottom - (rect.top - nMoveUpAmount),
                 SWP_NOZORDER);
}


//
// Default "Apply onto" strings for when GetInheritTypes
// fails or we don't find a matching inherit type.
//
// If desirable, different strings can be created for
// CONTAINER_INHERIT_ACE vs OBJECT_INHERIT_ACE.
//
static const UINT s_aInheritTypes[] =
{
    IDS_THIS_OBJECT_ONLY,           // 0 = <no inheritance>
    IDS_THIS_OBJECT_AND_SUBOBJECTS, // 1 = OBJECT_INHERIT_ACE
    IDS_THIS_OBJECT_AND_SUBOBJECTS, // 2 = CONTAINER_INHERIT_ACE
    IDS_THIS_OBJECT_AND_SUBOBJECTS, // 3 = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
};

// These are used when INHERIT_ONLY_ACE is present
static const UINT s_aInheritOnlyTypes[] =
{
    IDS_INVALID_INHERIT,            // 0 = <invalid>
    IDS_SUBOBJECTS_ONLY,            // 1 = OBJECT_INHERIT_ACE
    IDS_SUBOBJECTS_ONLY,            // 2 = CONTAINER_INHERIT_ACE
    IDS_SUBOBJECTS_ONLY,            // 3 = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
};


static int
_AddInheritType(HWND hInheritType,
                PSI_INHERIT_TYPE psiInheritType,
                HINSTANCE hInstance)
{
    UINT iIndex;
    TCHAR szName[MAX_PATH];
    LPCTSTR pszName = psiInheritType->pszName;

    if (IS_INTRESOURCE(pszName))
    {
        if (LoadString(hInstance,
                       (ULONG)((ULONG_PTR)pszName),
                       szName,
                       ARRAYSIZE(szName)) == 0)
        {
            LoadString(::hModule,
                       IDS_UNKNOWN,
                       szName,
                       ARRAYSIZE(szName));
        }
        pszName = szName;
    }

    iIndex = (UINT)SendMessage(hInheritType, CB_ADDSTRING, 0, (LPARAM)pszName);

    if (CB_ERR != iIndex)
        SendMessage(hInheritType, CB_SETITEMDATA, iIndex, (LPARAM)psiInheritType);

    return iIndex;
}

void
CACEPage::InitDlg(HWND hDlg)
{
#define X_COR 7
#define Y_COR 7
    UCHAR   AceFlags = 0;
    PSID    pSid = NULL;
    LPCTSTR pszName = NULL;
    LPTSTR  pszNameT = NULL;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    HRESULT hr;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::InitDlg");

	//
	//Store the hDlg
	//

	m_hwnd = hDlg;
	if(m_siFlags == SI_ACCESS_SPECIFIC)
	{
		//
		//Create a label to show message when no generic 
		//permissions exist for the object
		//

		WCHAR szName[1024];
		LoadString(::hModule, IDS_NO_OBJECT_PERM, szName, ARRAYSIZE(szName));

		RECT rc;
		GetWindowRect(GetDlgItem(hDlg,IDC_ACEE_LIST),&rc);
		// Create a new label control
		m_hwndNoPerm = CreateWindowEx(0,
									  TEXT("STATIC"),
									  szName,
									  WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP | SS_NOPREFIX,
									  X_COR,
									  Y_COR,
									  rc.right - rc.left - 2*X_COR,
									  rc.bottom - rc.top - 2*Y_COR,
									  GetDlgItem(hDlg,IDC_ACEE_LIST),
									  (HMENU)IntToPtr(0xffff),
									  ::hModule,
									  NULL);
		// Set the font
		SendMessage(m_hwndNoPerm,
					WM_SETFONT,
					SendMessage(hDlg, WM_GETFONT, 0, 0),
					0);
	}


    if (m_pAce)
    {
        AceFlags = m_pAce->AceFlags;
        m_guidInheritType = m_pAce->InheritedObjectType;
        pSid = m_pAce->psid;
        pszName = m_pAce->LookupName(m_siObjectInfo.pszServerName, m_psi2);
    }
    else
    {
        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
            AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;

        pSid = QuerySystemSid(UI_SID_World);
    }

    // Make sure the AceFlags are valid
    ACCESS_MASK Mask = 0;
    m_psi->MapGeneric(&m_guidInheritType, &AceFlags, &Mask);

    // Hide the inherit warning and adjust other control positions
    if (!(AceFlags & INHERITED_ACE))
        HideInheritedAceWarning(hDlg);

    // Make a copy of the sid and get the name
    if (pSid)
    {
        PUSER_LIST pUserList = NULL;

        m_pSid = LocalAllocSid(pSid);

        if (pszName == NULL)
        {
            // This should only happen when m_pAce is NULL and we're
            // using UI_SID_World
            if (LookupSid(pSid, m_siObjectInfo.pszServerName, m_psi2, &pUserList))
            {
                TraceAssert(NULL != pUserList);
                TraceAssert(1 == pUserList->cUsers);

                if (BuildUserDisplayName(&pszNameT,
                                         pUserList->rgUsers[0].pszName,
                                         pUserList->rgUsers[0].pszLogonName)
                    || ConvertSidToStringSid(pSid, &pszNameT))
                {
                    pszName = pszNameT;
                }
            }
        }

        SetDlgItemText(hDlg, IDC_ACEE_NAME, pszName);

        if (NULL != pUserList)
            LocalFree(pUserList);
    }

    // Get the list of permissions and initialize the check boxes
    InitCheckList(hDlg, m_pAce);


    HWND hInheritType = GetDlgItem(hDlg, IDC_ACEE_INHERITTYPE);
    HWND hInheritImmed = GetDlgItem(hDlg, IDC_ACEE_INHERITIMMEDIATE);

    if (m_siObjectInfo.dwFlags & SI_NO_TREE_APPLY)
    {
        ShowWindow(hInheritImmed, SW_HIDE);
        EnableWindow(hInheritImmed, FALSE);
    }

    //
    // Get inherit types from callback
    //
    ULONG cItems = 0;
    PSI_INHERIT_TYPE psiInheritType = NULL;

    hr = m_psi->GetInheritTypes(&psiInheritType, &cItems);
    if (SUCCEEDED(hr))
    {
        // Check these inherit bits for a match
        DWORD dwInheritMask = INHERIT_ONLY_ACE | ACE_INHERIT_ALL;

        // Don't check INHERIT_ONLY_ACE if the ACE inherit type
        // matches the current object
        if ((m_siObjectInfo.dwFlags & SI_OBJECT_GUID) &&
            IsSameGUID(&m_siObjectInfo.guidObjectType, &m_guidInheritType))
        {
            dwInheritMask &= ~INHERIT_ONLY_ACE;
        }

        //
        // Add inherit types to combobox
        //
        for ( ; cItems > 0; cItems--, psiInheritType++)
        {
            UINT iIndex = _AddInheritType(hInheritType,
                                          psiInheritType,
                                          m_siObjectInfo.hInstance);

            // See if this entry matches the incoming ACE
            if ((psiInheritType->dwFlags & dwInheritMask) == (ULONG)(AceFlags & dwInheritMask)
                && IsSameGUID(&m_guidInheritType, psiInheritType->pguid))
            {
                // Got a match, select this entry
                SendMessage(hInheritType, CB_SETCURSEL, iIndex, 0);
            }
        }
    }

    //
    // If GetInheritTypes failed, or we failed to find a match,
    // pick a default string and build an appropriate inherit type.
    //
    if (FAILED(hr) || CB_ERR == SendMessage(hInheritType, CB_GETCURSEL, 0, 0))
    {
        // Pick a default string
        UINT ids = IDS_SPECIAL;
        if (IsNullGUID(&m_guidInheritType))
        {
            if (AceFlags & INHERIT_ONLY_ACE)
                ids = s_aInheritOnlyTypes[AceFlags & ACE_INHERIT_ALL];
            else
                ids = s_aInheritTypes[AceFlags & ACE_INHERIT_ALL];
        }

        // Fill in m_siInheritUnknown with the pertinent info
        m_siInheritUnknown.pguid   = &m_guidInheritType;
        m_siInheritUnknown.dwFlags = AceFlags & (INHERIT_ONLY_ACE | ACE_INHERIT_ALL);
        m_siInheritUnknown.pszName = MAKEINTRESOURCE(ids);

        // Insert and select it
        UINT iIndex = _AddInheritType(hInheritType,
                                      &m_siInheritUnknown,
                                      ::hModule);
        SendMessage(hInheritType, CB_SETCURSEL, iIndex, 0);

        if (FAILED(hr))
        {
            // GetInheritTypes failed, which means the only entry is the
            // default one we just added.  Disable the combo.
            EnableWindow(hInheritType, FALSE);
        }
    }


    //
    // Select the options which match the incoming ace
    //

    if (!(AceFlags & (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE)))
    {
        SendMessage(hInheritImmed, BM_SETCHECK, BST_UNCHECKED, 0);
        EnableWindow(hInheritImmed, FALSE);
        m_fInheritImmediateEnabled = FALSE;
        m_fPreviousImmediateSetting = BST_UNCHECKED;
    }
    else
    {
        SendMessage(hInheritImmed,
                    BM_SETCHECK,
                    (AceFlags & NO_PROPAGATE_INHERIT_ACE) ? BST_CHECKED : BST_UNCHECKED,
                    0);
        m_fInheritImmediateEnabled = TRUE;
    }

    if (!(m_siObjectInfo.dwFlags & SI_CONTAINER) || m_fReadOnly || (AceFlags & INHERITED_ACE))
    {
        // Disable all inheritance
        EnableWindow(hInheritType, FALSE);
        EnableWindow(hInheritImmed, FALSE);
    }

    if (m_fReadOnly || (AceFlags & INHERITED_ACE))
    {
        // Disable the "change name" and "clear all" buttons
        EnableWindow(GetDlgItem(hDlg, IDC_ACEE_NAMEBUTTON), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ACEE_CLEAR), FALSE);
    }

	PropSheet_QuerySiblings(GetParent(hDlg),0,(LPARAM)this);

    LocalFreeString(&pszNameT);
    SetCursor(hcur);

    TraceLeaveVoid();
}

BOOL
CACEPage::OnChangeName(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;
    BOOL bResult = FALSE;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::OnChangeName");

    if (S_OK == GetUserGroup(hDlg, FALSE, &pUserList))
    {
        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        // Free up previous sid
        if (m_pSid)
            LocalFree(m_pSid);

        // Copy the new sid
        m_pSid = LocalAllocSid(pUserList->rgUsers[0].pSid);
        if (m_pSid)
        {
            SetDlgItemText(hDlg, IDC_ACEE_NAME, pUserList->rgUsers[0].pszName);
            bResult = TRUE;
        }
        LocalFree(pUserList);
    }

    TraceLeaveValue(bResult);
}

BOOL
CACEPage::OnClearAll(HWND hDlg)
{
    HWND hwndList;
    ULONG cPermissions;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::OnClearAll");
    TraceAssert(!m_fReadOnly);

    hwndList = GetDlgItem(hDlg, IDC_ACEE_LIST);
    cPermissions = (ULONG)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    while (cPermissions != 0)
    {
        WORD wCol = COLUMN_ALLOW;

        cPermissions--;

        while (wCol == COLUMN_ALLOW || wCol == COLUMN_DENY)
        {
            WPARAM wItem = MAKELONG((WORD)cPermissions, wCol);

            if (!(CLST_DISABLED & SendMessage(hwndList, CLM_GETSTATE, wItem, 0)))
                SendMessage(hwndList, CLM_SETSTATE, wItem, CLST_UNCHECKED);

            wCol++;
        }
    }

    TraceLeaveValue(TRUE);
}

void
CACEPage::HandleSelChange(HWND hDlg, HWND hWnd) // inherit type change
{
    PSI_INHERIT_TYPE psiInheritType;
    BOOL fEnableInheritImmediate = FALSE;
    const GUID *pguidInheritType = &GUID_NULL;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::HandleSelChange");

    psiInheritType = (PSI_INHERIT_TYPE)SendMessage(hWnd,
                                                   CB_GETITEMDATA,
                                                   SendMessage(hWnd, CB_GETCURSEL, 0, 0),
                                                   0);

    if (psiInheritType != (PSI_INHERIT_TYPE)CB_ERR && psiInheritType != NULL)
    {
        if (psiInheritType->dwFlags & (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE))
            fEnableInheritImmediate = TRUE;
        if( psiInheritType->pguid )
            pguidInheritType = psiInheritType->pguid;
    }

    if (fEnableInheritImmediate != m_fInheritImmediateEnabled)
    {
        HWND hInheritImmediate = GetDlgItem(hDlg, IDC_ACEE_INHERITIMMEDIATE);

        if (fEnableInheritImmediate)
        {
            SendMessage(hInheritImmediate, BM_SETCHECK, m_fPreviousImmediateSetting, 0);
        }
        else
        {
            m_fPreviousImmediateSetting = (BOOL)SendMessage(hInheritImmediate,
                                                            BM_GETCHECK,
                                                            0,
                                                            0);
            SendMessage(hInheritImmediate, BM_SETCHECK, BST_UNCHECKED, 0);
        }

        EnableWindow(hInheritImmediate, fEnableInheritImmediate);
        m_fInheritImmediateEnabled = fEnableInheritImmediate;
    }

    // If the inherit type GUID has changed, reinitialize the checklist.
    if (!IsSameGUID(pguidInheritType, &m_guidInheritType))
    {
        HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        HDPA hNewEntries = DPA_Create(4);

        if (hNewEntries)
        {
            GetAcesFromCheckList(GetDlgItem(hDlg, IDC_ACEE_LIST),
                                 m_pSid,
                                 m_siPageType == SI_PAGE_ADVPERM,
                                 TRUE,
                                 0,         // don't care about flags
                                 NULL,      // or inherit type here
                                 hNewEntries);

            // Save new inherit type and reset the checklist
            m_guidInheritType = *pguidInheritType; 
            ReInitCheckList(hDlg, hNewEntries);
            DestroyDPA(hNewEntries);
        }

        SetCursor(hcur);
    }

    TraceLeaveVoid();
}

void
HandleListClick(PNM_CHECKLIST pnmc, 
                SI_PAGE_TYPE siType, 
                BOOL bInheritFlags, 
                HDSA *phAllowUncheckedAccess, 
                HDSA *phDenyUncheckedAccess, 
                BOOL bCustomPresent)
{
    HWND            hChkList;
    UINT            iRow;
    WORD            wCol;
    PSI_ACCESS      pAccess;
    DWORD           dwState;
    BOOL            bNullGuid;
    UINT            iRowCompare;
    PSI_ACCESS      pAccessCompare;

    TraceEnter(TRACE_MISC, "HandleListClick");
    TraceAssert(pnmc != NULL);

    hChkList = pnmc->hdr.hwndFrom;
    iRow    = pnmc->iItem;
    wCol    = (WORD)pnmc->iSubItem;       // 1 = Allow, 2 = Deny
    pAccess = (PSI_ACCESS)pnmc->dwItemData;
    dwState = pnmc->dwState;

    if (pAccess == NULL)
        TraceLeaveVoid();

    if( phAllowUncheckedAccess )
    {
        *phAllowUncheckedAccess = DSA_Create(SIZEOF(PSI_ACCESS), 4);
        if (*phAllowUncheckedAccess == NULL)
        {
            TraceMsg("DSA_Create failed");
            TraceLeaveVoid();
        }
    }
    if( phDenyUncheckedAccess )
    {
        *phDenyUncheckedAccess = DSA_Create(SIZEOF(PSI_ACCESS), 4);
        if (*phDenyUncheckedAccess == NULL)
        {
            TraceMsg("DSA_Create failed");
            TraceLeaveVoid();
        }
    }


    bNullGuid = IsNullGUID(pAccess->pguid);

    iRowCompare = (UINT)SendMessage(hChkList, CLM_GETITEMCOUNT, 0, 0);

    //Custom checkbox is handled Separately
    if( bCustomPresent )
        --iRowCompare;

    while (iRowCompare != 0)
    {
        WPARAM wItem;
        DWORD  dwStateCompareOriginal;
        DWORD  dwStateCompare;
        WORD   wColCompare;
        BOOL   bSameGuid;
        BOOL   bNullGuidCompare;

        --iRowCompare;
        pAccessCompare = (PSI_ACCESS)SendMessage(hChkList, CLM_GETITEMDATA, iRowCompare, 0);

        if (!pAccessCompare)
            continue;

        bSameGuid = IsSameGUID(pAccessCompare->pguid, pAccess->pguid);
        bNullGuidCompare = IsNullGUID(pAccessCompare->pguid);

        // If the GUIDs are incompatible, then we can't do anything
        if (!(bSameGuid || bNullGuid || bNullGuidCompare))
            continue;

        //
        // Yukky, complicated mechanism to determine whether to
        // turn on or off the allow or deny check marks.
        //
        // REVIEW: This algorithm of changing check marks based on other
        // checkmarks handles a lot of cases, but it doesn't handle a
        // two good ones.
        //
        // (1) If you have a right which implies other rights and you turn,
        // it off, then maybe we should turn off all of the implied ones
        // too. For example, you turn off change (which is the combination
        // of read and write) maybe we should turn off both read and write.
        //
        // (2) If you turn on all of the component rights of one which
        // implies them all, then we should turn on that one (because
        // it implies them all).
        //
#ifdef NO_RADIOBUTTON_BEHAVIOR
        wColCompare = wCol;
#else
        for (wColCompare = COLUMN_ALLOW; wColCompare <= COLUMN_DENY; wColCompare++)
#endif
        {
            wItem = MAKELONG((WORD)iRowCompare, wColCompare);
            dwStateCompareOriginal = (DWORD)SendMessage(hChkList, CLM_GETSTATE, wItem, 0);

            //
            // If the other box is disabled, then it represents an
            // inherited right so don't do anything with it.
            //
            // nb: Depending on NO_RADIOBUTTON_BEHAVIOR, this may continue to the
            // for(wColCompare) loop or the while(iRowCompare) loop as appropriate
            //
            if (dwStateCompareOriginal & CLST_DISABLED)
                continue;

            dwStateCompare = dwStateCompareOriginal;

            if (dwState & CLST_CHECKED)
            {
                if (wCol == wColCompare)
                {
                    //
                    // If this right implies some other right,
                    // then turn it on too.
                    //
                    if ((bSameGuid || bNullGuid) && AllFlagsOn(pAccess->mask, pAccessCompare->mask))
                    {
                        if (!bInheritFlags ||
                            AllFlagsOn(pAccess->dwFlags & ACE_INHERIT_ALL, pAccessCompare->dwFlags & ACE_INHERIT_ALL))
                        {
                            dwStateCompare |= CLST_CHECKED;
                        }
                    }
                }
                else
                {
#ifndef NO_RADIOBUTTON_BEHAVIOR
                    //
                    // If this right implies or is implied by some other
                    // right in the other column, then turn it off.
                    //
                    if ( (siType == SI_PAGE_PERM || siType == SI_PAGE_ADVPERM) &&
                         (((bSameGuid || bNullGuid) && AllFlagsOn(pAccess->mask, pAccessCompare->mask)) ||
                          ((bSameGuid || bNullGuidCompare) && AllFlagsOn(pAccessCompare->mask, pAccess->mask))) )
                    {
                        if (!bInheritFlags ||
                            (AllFlagsOn(pAccessCompare->dwFlags & ACE_INHERIT_ALL, pAccess->dwFlags & ACE_INHERIT_ALL) ||
                             AllFlagsOn(pAccess->dwFlags & ACE_INHERIT_ALL, pAccessCompare->dwFlags & ACE_INHERIT_ALL)) )
                        {
                            dwStateCompare &= ~(CLST_CHECKED);
                        }
                    }
#endif
                }
            }
            else
            {
                if (wCol == wColCompare)
                {
                    //
                    // If this right is implied by some other right, then
                    // turn it off too.
                    //
                    if ((bSameGuid || bNullGuidCompare) && AllFlagsOn(pAccessCompare->mask, pAccess->mask))
                    {
                        if (!bInheritFlags ||
                            AllFlagsOn(pAccessCompare->dwFlags & ACE_INHERIT_ALL, pAccess->dwFlags & ACE_INHERIT_ALL))
                        {
                            dwStateCompare &= ~(CLST_CHECKED);
                        }
                    }
                }
            }

            if (dwStateCompareOriginal != dwStateCompare)
            {
                SendMessage(hChkList, CLM_SETSTATE, wItem, (LPARAM)dwStateCompare);
                //If a checkbox was intially checked and and now unchecked, add to 
                //h[Allow|Deny]UncheckedAccess.
                if( dwStateCompareOriginal & CLST_CHECKED && !(dwStateCompare & CLST_CHECKED) )
                {
                    if( phDenyUncheckedAccess && ( wColCompare == COLUMN_DENY ) )
                        DSA_AppendItem(*phDenyUncheckedAccess, &pAccessCompare);
                    if( phAllowUncheckedAccess && ( wColCompare == COLUMN_ALLOW ) )
                        DSA_AppendItem(*phAllowUncheckedAccess, &pAccessCompare);
                }

            }
        }
    }

    TraceLeaveVoid();
}


UINT
GetAcesFromCheckList(HWND hChkList,
                     PSID pSid,                 // All aces get this SID
                     BOOL fPerm,                // Create ACCESS or AUDIT aces?
                     BOOL fAceFlagsProvided,    // Use uAceFlagsAll instead of pAccess->dwFlags
                     UCHAR uAceFlagsAll,        // All aces get these flags
                     const GUID *pInheritGUID,  // All aces get this inherit GUID
                     HDPA hEntries)             // Store new aces here
{
    UINT cCheckRows;
    UINT iCheckRow;
    UINT cbSidSize;
    UINT iCount;
    BOOL bInheritTypePresent = FALSE;

    TraceEnter(TRACE_MISC, "GetAcesFromCheckList");
    TraceAssert(hChkList != NULL);
    TraceAssert(pSid != NULL);
    TraceAssert(hEntries != NULL);

    cbSidSize = GetLengthSid(pSid);

    if (pInheritGUID == NULL)
        pInheritGUID = &GUID_NULL;
    else if (!IsNullGUID(pInheritGUID))
        bInheritTypePresent = TRUE;

    //
    // First clear out the old HDPA
    //
    iCount = DPA_GetPtrCount(hEntries);
    while (iCount != 0)
    {
        --iCount;
        LocalFree(DPA_FastGetPtr(hEntries, iCount));
        DPA_DeletePtr(hEntries, iCount);
    }

    cCheckRows = (UINT)SendMessage(hChkList, CLM_GETITEMCOUNT, 0, 0);
    for (iCheckRow = 0; iCheckRow < cCheckRows; iCheckRow++)
    {
        PSI_ACCESS pAccess;
        DWORD dwObjectFlagsNew;
        WORD wCol;
        UCHAR uAceFlagsNew;

        pAccess = (PSI_ACCESS)SendMessage(hChkList, CLM_GETITEMDATA, iCheckRow, 0);

        uAceFlagsNew = (UCHAR)(fAceFlagsProvided ? uAceFlagsAll : pAccess->dwFlags);

        dwObjectFlagsNew = 0;
        if (!IsNullGUID(pAccess->pguid))
            dwObjectFlagsNew |= ACE_OBJECT_TYPE_PRESENT;

        if (bInheritTypePresent)
            dwObjectFlagsNew |= ACE_INHERITED_OBJECT_TYPE_PRESENT;

        wCol = COLUMN_ALLOW;
        while (wCol == COLUMN_ALLOW || wCol == COLUMN_DENY)
        {
            WPARAM        wItem;
            DWORD         dwState;

            wItem = MAKELONG((WORD)iCheckRow, wCol);
            dwState = (DWORD)SendMessage(hChkList, CLM_GETSTATE, wItem, 0);

            if ((dwState & CLST_CHECKED) && !(dwState & CLST_DISABLED))
            {
                //
                // Ok, time to make an ACE for this check mark, see if we
                // can merge it into an already existing ACE, or whether we
                // we need to create a new entry
                //
                UCHAR uAceTypeNew;
                DWORD dwMaskNew = pAccess->mask;
                UINT cbSize = SIZEOF(KNOWN_ACE);

                if (fPerm)
                {
                    if (wCol == COLUMN_ALLOW)
                        uAceTypeNew = ACCESS_ALLOWED_ACE_TYPE;
                    else
                        uAceTypeNew = ACCESS_DENIED_ACE_TYPE;
                }
                else
                {
                    uAceTypeNew = SYSTEM_AUDIT_ACE_TYPE;
                    uAceFlagsNew &= ~(SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG);

                    if (wCol == COLUMN_ALLOW)
                        uAceFlagsNew |= SUCCESSFUL_ACCESS_ACE_FLAG;
                    else
                        uAceFlagsNew |= FAILED_ACCESS_ACE_FLAG;
                }

                if (dwObjectFlagsNew != 0)
                {
                    uAceTypeNew += (ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE);
                    cbSize = SIZEOF(KNOWN_OBJECT_ACE);

                    if (dwObjectFlagsNew & ACE_OBJECT_TYPE_PRESENT)
                        cbSize += SIZEOF(GUID);

                    if (dwObjectFlagsNew & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                        cbSize += SIZEOF(GUID);
                }

                cbSize += cbSidSize - SIZEOF(ULONG);

                //
                // See if it exists
                //
                iCount = DPA_GetPtrCount(hEntries);
                while(iCount != 0)
                {
                    PACE_HEADER pAce;
                    BOOL bObjectTypePresent = FALSE;
                    const GUID *pObjectType = NULL;

                    --iCount;
                    pAce = (PACE_HEADER)DPA_FastGetPtr(hEntries, iCount);

                    if (IsObjectAceType(pAce))
                        pObjectType = RtlObjectAceObjectType(pAce);

                    if (!pObjectType)
                        pObjectType = &GUID_NULL;
                    else
                        bObjectTypePresent = TRUE;

                    //
                    // Test the new ACE against each existing ACE to see if
                    // we can combine them.
                    //
                    if (IsEqualACEType(pAce->AceType, uAceTypeNew))
                    {
                        DWORD dwMergeFlags = 0;
                        DWORD dwMergeStatus;
                        DWORD dwMergeResult;

                        if (dwObjectFlagsNew & ACE_OBJECT_TYPE_PRESENT)
                            dwMergeFlags |= MF_OBJECT_TYPE_1_PRESENT;

                        if (bObjectTypePresent)
                            dwMergeFlags |= MF_OBJECT_TYPE_2_PRESENT;

                        if (!(dwMergeFlags & (MF_OBJECT_TYPE_1_PRESENT | MF_OBJECT_TYPE_2_PRESENT)))
                        {
                            // Neither are present, so they are the same
                            dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;
                        }
                        else if (IsSameGUID(pAccess->pguid, pObjectType))
                            dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;

                        if (!fPerm)
                            dwMergeFlags |= MF_AUDIT_ACE_TYPE;

                        dwMergeStatus = MergeAceHelper(uAceFlagsNew,
                                                       dwMaskNew,
                                                       pAce->AceFlags,
                                                       ((PKNOWN_ACE)pAce)->Mask,
                                                       dwMergeFlags,
                                                       &dwMergeResult);

                        if (dwMergeStatus == MERGE_MODIFIED_FLAGS)
                        {
                            uAceFlagsNew = (UCHAR)dwMergeResult;
                            dwMergeStatus = MERGE_OK_1;
                        }
                        else if (dwMergeStatus == MERGE_MODIFIED_MASK)
                        {
                            dwMaskNew = dwMergeResult;
                            dwMergeStatus = MERGE_OK_1;
                        }

                        if (dwMergeStatus == MERGE_OK_1)
                        {
                            //
                            // The new ACE implies the existing ACE, so
                            // the existing one can be removed.
                            //
                            LocalFree(pAce);
                            DPA_DeletePtr(hEntries, iCount);
                            //
                            // Keep looking.  Maybe we can remove some more entries
                            // before adding the new one.
                            //
                        }
                        else if (dwMergeStatus == MERGE_OK_2)
                        {
                            iCount = 1;     // non-zero for match found
                            break;
                        }
                    }
                }

                //
                // Otherwise, add it
                //
                if (iCount == 0)
                {
                    PACE_HEADER pAce = (PACE_HEADER)LocalAlloc(LPTR, cbSize);

                    if (pAce)
                    {
                        PSID pSidT;

                        pAce->AceType  = uAceTypeNew;
                        pAce->AceFlags = uAceFlagsNew;
                        pAce->AceSize  = (USHORT)cbSize;
                        ((PKNOWN_ACE)pAce)->Mask = dwMaskNew;
                        pSidT = &((PKNOWN_ACE)pAce)->SidStart;

                        if (dwObjectFlagsNew != 0)
                        {
                            GUID *pGuid;

                            ((PKNOWN_OBJECT_ACE)pAce)->Flags = dwObjectFlagsNew;

                            pGuid = RtlObjectAceObjectType(pAce);
                            if (pGuid)
                            {
                                if (pAccess->pguid)
                                    *pGuid = *pAccess->pguid;
                                else
                                    *pGuid = GUID_NULL;
                            }

                            pGuid = RtlObjectAceInheritedObjectType(pAce);
                            if (pGuid)
                                *pGuid = *pInheritGUID;

                            pSidT = RtlObjectAceSid(pAce);
                        }

                        CopyMemory(pSidT, pSid, cbSidSize);
                        DPA_AppendPtr(hEntries, pAce);
                    }
                }
            }

            wCol++;
        }
    }

    iCount = DPA_GetPtrCount(hEntries);
    TraceLeaveValue(iCount);
}

LONG
CACEPage::OnApply(HWND hDlg, BOOL /*bClose*/)
{
    const GUID *pInheritGUID;
    UCHAR uAceFlagsNew = 0;
    HDPA hEntries;
	BOOL bAclBloated = FALSE;
	//
	//If this page is property page and user has not clicked on
	//the object page, aclbloat must be checked from this page
	//only.
	//
	if((m_siFlags == SI_ACCESS_PROPERTY) && !m_pOtherPage)
		bAclBloated = IsAclBloated(hDlg);

	if(m_siFlags != SI_ACCESS_PROPERTY)
		bAclBloated = IsAclBloated(hDlg);
	
	if(bAclBloated)
		return PSNRET_INVALID_NOCHANGEPAGE;
    
	if (!m_fPageDirty)
        return PSNRET_NOERROR;

    TraceEnter(TRACE_ACEEDIT, "CACEPage::Apply");


	
    //
    // Determine inheritance for containers
    //
    pInheritGUID = &GUID_NULL;
    if ((m_siObjectInfo.dwFlags & SI_CONTAINER) != 0)
    {
        PSI_INHERIT_TYPE psiInheritType = NULL;
        HWND hInheritType = GetDlgItem( hDlg, IDC_ACEE_INHERITTYPE);

        int iSel = (int)SendMessage(hInheritType, CB_GETCURSEL, 0,0);

        if (iSel != CB_ERR)
        {
            psiInheritType = (PSI_INHERIT_TYPE)SendMessage(hInheritType,
                                                           CB_GETITEMDATA,
                                                           iSel,
                                                           0);
        }

        if (psiInheritType != (PSI_INHERIT_TYPE)CB_ERR && psiInheritType != NULL)
        {
            pInheritGUID = psiInheritType->pguid;
            uAceFlagsNew = (UCHAR)(psiInheritType->dwFlags & VALID_INHERIT_FLAGS);
        }
        else if (m_pAce)
        {
            uAceFlagsNew = m_pAce->AceFlags;
        }

        if (m_fInheritImmediateEnabled)
        {
            if (IsDlgButtonChecked(hDlg, IDC_ACEE_INHERITIMMEDIATE) == BST_CHECKED)
                uAceFlagsNew |= NO_PROPAGATE_INHERIT_ACE;
            else
                uAceFlagsNew &= ~NO_PROPAGATE_INHERIT_ACE;
        }
    }

    if (m_phEntries != NULL)
    {
        if (*m_phEntries == NULL)
            *m_phEntries = DPA_Create(4);

        GetAcesFromCheckList(GetDlgItem(hDlg, IDC_ACEE_LIST),
                             m_pSid,
                             m_siPageType == SI_PAGE_ADVPERM,
                             TRUE,
                             uAceFlagsNew,
                             pInheritGUID,
                             *m_phEntries);
    }

    if (m_pdwResult)
        *m_pdwResult |= (m_siFlags == SI_ACCESS_PROPERTY ? EAE_NEW_PROPERTY_ACE : EAE_NEW_OBJECT_ACE);
    m_fPageDirty = FALSE;

    TraceLeaveValue(PSNRET_NOERROR);
}

BOOL
CACEPage::IsAclBloated(HWND hDlg)
{
    TraceEnter(TRACE_MISC, "CACEPage::ShowAclBloat");
    
	HDPA hEntries = NULL;
	HDPA hPropEntries = NULL;
	
	BOOL bReturn = FALSE;

	hEntries = GetAceList(hDlg);

	if(m_pOtherPage)
	{
		hPropEntries = m_pOtherPage->GetAceList(m_pOtherPage->m_hwnd);
	}

	CACLBloat bloat(m_psi,
					m_psi2,
					m_siPageType,
					&m_siObjectInfo,
					hEntries,
					hPropEntries);	
	if(bloat.IsAclBloated())
		bReturn = bloat.DoModalDialog(hDlg);

	if(hEntries)
		DestroyDPA(hEntries);

	if(hPropEntries)
		DestroyDPA(hPropEntries);

	return bReturn;
}


HDPA
CACEPage::GetAceList(HWND hDlg)
{
	TraceEnter(TRACE_ACEEDIT, "CACEPage::GetAceList");
    
	if (!m_fPageDirty)
		return NULL;
    //
    // Determine inheritance for containers
    //
    const GUID *pInheritGUID = &GUID_NULL;
	UCHAR uAceFlagsNew = 0;
	HDPA hEntries = NULL;

    if ((m_siObjectInfo.dwFlags & SI_CONTAINER) != 0)
    {
        PSI_INHERIT_TYPE psiInheritType = NULL;
        HWND hInheritType = GetDlgItem( hDlg, IDC_ACEE_INHERITTYPE);

        int iSel = (int)SendMessage(hInheritType, CB_GETCURSEL, 0,0);

        if (iSel != CB_ERR)
        {
            psiInheritType = (PSI_INHERIT_TYPE)SendMessage(hInheritType,
                                                           CB_GETITEMDATA,
                                                           iSel,
                                                           0);
        }

        if (psiInheritType != (PSI_INHERIT_TYPE)CB_ERR && psiInheritType != NULL)
        {
            pInheritGUID = psiInheritType->pguid;
            uAceFlagsNew = (UCHAR)(psiInheritType->dwFlags & VALID_INHERIT_FLAGS);
        }
        else if (m_pAce)
        {
            uAceFlagsNew = m_pAce->AceFlags;
        }

        if (m_fInheritImmediateEnabled)
        {
            if (IsDlgButtonChecked(hDlg, IDC_ACEE_INHERITIMMEDIATE) == BST_CHECKED)
                uAceFlagsNew |= NO_PROPAGATE_INHERIT_ACE;
            else
                uAceFlagsNew &= ~NO_PROPAGATE_INHERIT_ACE;
        }
    }

	hEntries = DPA_Create(4);

	if(hEntries)
	{
		GetAcesFromCheckList(GetDlgItem(hDlg, IDC_ACEE_LIST),
							 m_pSid,
							 m_siPageType == SI_PAGE_ADVPERM,
							 TRUE,
							 uAceFlagsNew,
							 pInheritGUID,
							 hEntries);
	}
	return hEntries;
}



BOOL
CACEPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_DESTROY:
        EmptyCheckList(GetDlgItem(hDlg, IDC_ACEE_LIST));
        break;

    case PWM_SELECT_PAGE:
        PropSheet_SetCurSel(GetParent(hDlg), lParam, wParam);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_ACEE_NAMEBUTTON:
            if (OnChangeName(hDlg))
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case IDC_ACEE_INHERITTYPE:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
            {
                HandleSelChange(hDlg, (HWND)lParam);
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case IDC_ACEE_INHERITIMMEDIATE:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case IDC_ACEE_CLEAR:
            if (OnClearAll(hDlg))
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case CLN_CLICK:
            if (lParam)
            {
                HandleListClick((PNM_CHECKLIST)lParam, m_siPageType, FALSE);
                PropSheet_Changed(GetParent(hDlg), hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case CLN_GETCOLUMNDESC:
            {
                PNM_CHECKLIST pnmc = (PNM_CHECKLIST)lParam;
                GetDlgItemText(hDlg,
                               IDC_ACEE_ALLOW - 1 + pnmc->iSubItem,
                               pnmc->pszText,
                               pnmc->cchTextMax);
            }
            break;

        case PSN_APPLY:
            SetWindowLongPtr(hDlg,
                             DWLP_MSGRESULT,
                             OnApply(hDlg, (BOOL)(((LPPSHNOTIFY)lParam)->lParam)));
            break;


        }
        break;

	case PSM_QUERYSIBLINGS: 
		{
			BOOL bSendQuery = !m_pOtherPage;
			if(this != (CACEPage*)lParam)
				m_pOtherPage = (CACEPage*)lParam;

			if(bSendQuery)
				PostMessage(GetParent(hDlg),PSM_QUERYSIBLINGS,0,(LPARAM)this);
		}

		break;


    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            const DWORD *pdwHelpIDs = aAcePermHelpIDs;

            if (m_siPageType == SI_PAGE_AUDIT)
                pdwHelpIDs = aAceAuditHelpIDs;

            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szAcluiHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)pdwHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            HWND hwnd = (HWND)wParam;
            const DWORD *pdwHelpIDs = aAcePermHelpIDs;

            if (m_siPageType == SI_PAGE_AUDIT)
                pdwHelpIDs = aAceAuditHelpIDs;

            //
            // Some of the checkboxes may be scrolled out of view, but
            // they are still detected by WinHelp, so we jump through
            // a few extra hoops here.
            //
            if (hwnd == hDlg)
            {
                POINT pt;
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);

                ScreenToClient(hDlg, &pt);
                hwnd = ChildWindowFromPoint(hDlg, pt);
                if (hDlg == hwnd)
                    break;
            }

            //
            // WinHelp looks for child windows, but we don't have help id's
            // for the permission checkboxes.  If the request is for the
            // checklist window, fake out WinHelp by referring to one of
            // the static labels just above the list.
            //
            if (GetDlgCtrlID(hwnd) == IDC_ACEE_LIST)
                hwnd = GetWindow((HWND)wParam, GW_HWNDPREV);    // Static label "Deny"

            WinHelp(hwnd,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)pdwHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

HPROPSHEETPAGE
CreateACEPage(LPSECURITYINFO psi,
              SI_PAGE_TYPE siType,
              PACE pAce,
              BOOL bReadOnly,
              DWORD dwFlags,
              DWORD *pdwResult,
              HDPA *phEntries)
{
    HPROPSHEETPAGE hPage = NULL;
    LPCTSTR pszTitle = NULL;
    LPACEPAGE pPage;

    TraceEnter(TRACE_ACEEDIT, "CreateACEPage");
    TraceAssert(psi != NULL);
    TraceAssert(phEntries != NULL);

    pPage = new CACEPage(psi,
                         siType,
                         pAce,
                         bReadOnly,
                         dwFlags,
                         pdwResult,
                         phEntries);
    if (pPage)
    {
        int iDlgTemplate = IDD_ACEENTRY_PERM_PAGE;

        if (siType == SI_PAGE_AUDIT)
            iDlgTemplate = IDD_ACEENTRY_AUDIT_PAGE;

        if (dwFlags == SI_ACCESS_PROPERTY)
            pszTitle = MAKEINTRESOURCE(IDS_ACEE_PROPERTY_TITLE);

        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(iDlgTemplate), pszTitle);
    }

    TraceLeaveValue(hPage);
}

BOOL
EditACEEntry(HWND hwndOwner,
             LPSECURITYINFO psi,
             PACE pAce,
             SI_PAGE_TYPE siType,
             LPCTSTR pszObjectName,
             BOOL bReadOnly,
             DWORD *pdwResult,
             HDPA *phEntries,
             HDPA *phPropertyEntries,
             UINT nStartPage)
{
    HPROPSHEETPAGE hPage[2];
    UINT cPages = 0;
    BOOL bResult = FALSE;

    TraceEnter(TRACE_ACEEDIT, "EditACEEntry");
    TraceAssert(psi != NULL);

    if (phEntries)
    {
        hPage[cPages] = CreateACEPage(psi,
                                      siType,
                                      pAce,
                                      bReadOnly,
                                      SI_ACCESS_SPECIFIC,
                                      pdwResult,
                                      phEntries);
        if (hPage[cPages])
            cPages++;
    }

    if (phPropertyEntries)
    {
        hPage[cPages] = CreateACEPage(psi,
                                      siType,
                                      pAce,
                                      bReadOnly,
                                      SI_ACCESS_PROPERTY,
                                      pdwResult,
                                      phPropertyEntries);
        if (hPage[cPages])
            cPages++;
    }

    if (cPages)
    {
        // Build dialog title string
        LPTSTR pszCaption = NULL;
        FormatStringID(&pszCaption,
                       ::hModule,
                       siType == SI_PAGE_AUDIT ? IDS_ACEE_AUDIT_TITLE : IDS_ACEE_PERM_TITLE,
                       pszObjectName);

        PROPSHEETHEADER psh;
        psh.dwSize = SIZEOF(psh);
        psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
        psh.hwndParent = hwndOwner;
        psh.hInstance = ::hModule;
        psh.pszCaption = pszCaption;
        psh.nPages = cPages;
        psh.nStartPage = 0;
        psh.phpage = &hPage[0];

        if (nStartPage < cPages)
            psh.nStartPage = nStartPage;

        bResult = (PropertySheet(&psh) == IDOK);

        LocalFreeString(&pszCaption);
    }

    TraceLeaveValue(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\ace.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ace.h
//
//  This file contains definitions and prototypes for the ACE abstraction
//  class (CAce)
//
//--------------------------------------------------------------------------

#ifndef _ACE_H_
#define _ACE_H_

class CAce : public ACE_HEADER
{
public:
  //UCHAR           AceType;        // Inherited from ACE_HEADER
  //UCHAR           AceFlags;
  //USHORT          AceSize;
    ACCESS_MASK     Mask;
    ULONG           Flags;          // ACE_OBJECT_TYPE_PRESENT, etc.
    GUID            ObjectType;
    GUID            InheritedObjectType;
    PSID            psid;
    SID_NAME_USE    sidType;
private:
    LPTSTR          pszName;
    LPTSTR          pszType;
    LPTSTR          pszAccessType;
    LPTSTR          pszInheritType;
    BOOL            bPropertyAce;
    LPTSTR          pszInheritSourceName;
    INT            iInheritSourceLevel;
public:
    CAce(PACE_HEADER pAceHeader = NULL);
    ~CAce();

    LPTSTR GetName()        const { return pszName;         }
    LPTSTR GetType()        const { return pszType;         }
    LPTSTR GetAccessType()  const { return pszAccessType;   }
    LPTSTR GetInheritType() const { return pszInheritType;  }
    LPTSTR GetInheritSourceName() const { return pszInheritSourceName; }
    INT   GetInheritSourceLevel() const { return iInheritSourceLevel; }
    BOOL   IsPropertyAce()  const { return bPropertyAce;    }
    BOOL   IsInheritedAce() const { return AceFlags & INHERITED_ACE; }

    LPTSTR LookupName(LPCTSTR pszServer = NULL, LPSECURITYINFO2 psi2 = NULL);
    void SetInheritSourceInfo(LPCTSTR psz, INT level);
    void SetName(LPCTSTR pszN, LPCTSTR pszL = NULL);
    void SetType(LPCTSTR psz)        { SetString(&pszType, psz);        }
    void SetAccessType(LPCTSTR psz)  { SetString(&pszAccessType, psz);  }
    void SetInheritType(LPCTSTR psz) { SetString(&pszInheritType, psz); }
    void SetPropertyAce(BOOL b)      { bPropertyAce = b;                }
    void SetSid(PSID p, LPCTSTR pszName, LPCTSTR pszLogonName, SID_NAME_USE type);
    PACE_HEADER Copy() const;
    void CopyTo(PACE_HEADER pAceDest) const;
    int  CompareType(const CAce *pAceCompare) const;
    DWORD Merge(const CAce *pAce2);

private:
    void SetString(LPTSTR *ppszDest, LPCTSTR pszSrc);
};
typedef CAce *PACE;

#define AllFlagsOn(dw1, dw2)        (((dw1) & (dw2)) == (dw2))  // equivalent to ((dw1 | dw2) == dw1)
#define IsAuditAlarmACE(type) ( ((type) == SYSTEM_AUDIT_ACE_TYPE)        || \
                                ((type) == SYSTEM_AUDIT_OBJECT_ACE_TYPE) || \
                                ((type) == SYSTEM_ALARM_ACE_TYPE)        || \
                                ((type) == SYSTEM_ALARM_OBJECT_ACE_TYPE) )

BOOL
IsEqualACEType(DWORD dwType1, DWORD dwType2);

DWORD
MergeAceHelper(DWORD dwAceFlags1,
               DWORD dwMask1,
               DWORD dwAceFlags2,
               DWORD dwMask2,
               DWORD dwMergeFlags,
               LPDWORD pdwResult);

// CAce::Merge and MergeAceHelper return values
#define MERGE_FAIL              0   // Unable to merge ACEs
#define MERGE_OK_1              1   // ACE 1 (this) implies ACE 2
#define MERGE_OK_2              2   // ACE 2 implies ACE 1 (this)
#define MERGE_MODIFIED_FLAGS    3   // ACEs can be merged by modifying flags (new flags in *pdwResult)
#define MERGE_MODIFIED_MASK     4   // ACEs can be merged by modifying mask (new mask in *pdwResult)

// Values for MergeAceHelper dwMergeFlags parameter
#define MF_OBJECT_TYPE_1_PRESENT    1
#define MF_OBJECT_TYPE_2_PRESENT    2
#define MF_OBJECT_TYPE_EQUAL        4
#define MF_AUDIT_ACE_TYPE           8


#endif  // _ACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\acelist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       acelist.cpp
//
//  This file contains the implementation for the advanced ACE list editor
//  permission and auditing pages.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include <accctrl.h>
//Functions selects an Item in ListView. It first 
//Clears all exisiting selections
VOID 
SelectSingleItemInLV( HWND hListView, INT iSelected )
{
    INT cCount = ListView_GetItemCount( hListView );
    for( INT i = 0; i < cCount; ++i )
        ListView_SetItemState( hListView, 
                              i, 
                              0, 
                              LVIS_SELECTED | LVIS_FOCUSED );

    //Now select the iSelected
    ListView_SetItemState( hListView, 
                          iSelected, 
                          LVIS_SELECTED | LVIS_FOCUSED, 
                          LVIS_SELECTED | LVIS_FOCUSED );
    return;



}

//This function checks if any of the aces selected in the listbox
//is of type 
//type = fAppliedDirect ? Applied Directly on this object :
//                        Inhereted from parent  
BOOL AnySelectedAceofType( HWND hListView, BOOL fAppliedDirect )
{
    LVITEM lvi = {0};
    UINT cSelectedCount = 0;  //Number of item selected in listbox
    lvi.iItem    = -1;
    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;

    cSelectedCount = ListView_GetSelectedCount(hListView);                     
    
    while( cSelectedCount-- )
    {
        lvi.iItem = ListView_GetNextItem(hListView, lvi.iItem, LVNI_SELECTED);

        if (lvi.iItem != -1)
        {
            lvi.lParam   = NULL;

            ListView_GetItem(hListView, &lvi);
            if( fAppliedDirect && ( (((PACE)lvi.lParam)->AceFlags & INHERITED_ACE) == 0 ) )
                return TRUE;
            if( !fAppliedDirect && ((PACE)lvi.lParam)->AceFlags & INHERITED_ACE )
                return TRUE;

        }
    }
    return FALSE;
}


LPARAM
GetSelectedItemData(HWND hListView, int *pIndex)
{
    int iSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);

    if (pIndex)
        *pIndex = iSelected;

    if (iSelected == -1)
        return NULL;


    LV_ITEM lvi;

    lvi.mask     = LVIF_PARAM;
    lvi.iItem    = iSelected;
    lvi.iSubItem = 0;
    lvi.lParam   = NULL;

    ListView_GetItem(hListView, &lvi);

    return lvi.lParam;
}


void
SelectListViewItem(HWND hListView, int iSelected)
{
    ListView_SetItemState(hListView,
                          iSelected,
                          LVIS_SELECTED | LVIS_FOCUSED,
                          LVIS_SELECTED | LVIS_FOCUSED);
    ListView_EnsureVisible(hListView, iSelected, FALSE);
}

void
EnsureListViewSelectionIsVisible(HWND hListView)
{
    int iSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);
    if (-1 != iSelected)
        ListView_EnsureVisible(hListView, iSelected, FALSE);
}


INT_PTR
_ConfirmAclProtectProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        Static_SetIcon(GetDlgItem(hDlg, IDC_CONFIRM_ICON), LoadIcon(NULL, IDI_QUESTION));
        return TRUE;

    case WM_COMMAND:
        if (BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam))
        {
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            return TRUE;
        }
        break;
    }
    return FALSE;
}

int
ConfirmAclProtect(HWND hwndParent, BOOL bDacl)
{
    return (int)DialogBox(::hModule,
                          MAKEINTRESOURCE(bDacl ? IDD_CONFIRM_DACL_PROTECT : IDD_CONFIRM_SACL_PROTECT),
                          hwndParent,
                          _ConfirmAclProtectProc);
}


//
//  Context Help IDs.
//
const static DWORD aAceListPermHelpIDs[] =
{
    IDC_ACEL_DETAILS,           IDH_ACEL_PERM_DETAILS,
    IDC_ACEL_ADD,               IDH_ACEL_PERM_ADD,
    IDC_ACEL_REMOVE,            IDH_ACEL_PERM_REMOVE,
    IDC_ACEL_EDIT,              IDH_ACEL_PERM_EDIT,
    IDC_ACEL_RESET,             IDH_ACEL_PERM_RESET,
    IDC_ACEL_DEFAULT_STATIC,         IDH_ACEL_PERM_RESET,
    IDC_ACEL_PROTECT,           IDH_ACEL_PERM_PROTECT,
    IDC_ACEL_DESCRIPTION,       IDH_NOHELP,
    IDC_ACEL_RESET_ACL_TREE,    IDH_ACEL_PERM_RESET_ACL_TREE,
    IDC_ACEL_STATIC,            -1,    
    0, 0
};

const static DWORD aAceListAuditHelpIDs[] =
{
    IDC_ACEL_DETAILS,           IDH_ACEL_AUDIT_DETAILS,
    IDC_ACEL_ADD,               IDH_ACEL_AUDIT_ADD,
    IDC_ACEL_REMOVE,            IDH_ACEL_AUDIT_REMOVE,
    IDC_ACEL_EDIT,              IDH_ACEL_AUDIT_EDIT,
    IDC_ACEL_RESET,             IDH_ACEL_AUDIT_RESET,
    IDC_ACEL_DEFAULT_STATIC,    IDH_ACEL_AUDIT_RESET,
    IDC_ACEL_PROTECT,           IDH_ACEL_AUDIT_PROTECT,
    IDC_ACEL_DESCRIPTION,       IDH_NOHELP,
    IDC_ACEL_RESET_ACL_TREE,    IDH_ACEL_AUDIT_RESET_ACL_TREE,
    IDC_ACEL_STATIC,            -1,
    0, 0
};


class CAdvancedListPage : public CSecurityPage
{
private:
    PSI_ACCESS          m_pAccess;
    ULONG               m_cAccesses;
    PSI_INHERIT_TYPE    m_pInheritType;
    ULONG               m_cInheritTypes;
    int                 m_iLastColumnClick;
    int                 m_iSortDirection;
    BOOL                m_fPageDirty:1;
    BOOL                m_bReadOnly:1;
    BOOL                m_bAuditPolicyOK:1;
    BOOL                m_bWasDenyAcl:1;
    DWORD               m_cInheritableAces;

public:
    CAdvancedListPage( LPSECURITYINFO psi, SI_PAGE_TYPE siType )
        : CSecurityPage(psi, siType), 
          m_iLastColumnClick(-1), 
          m_iSortDirection(1),
          m_cInheritableAces(0){}

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    PACL GetACL(PSECURITY_DESCRIPTOR *ppSD, LPBOOL pbProtected, BOOL bDefault);
    void FillAceList(HWND hListView, PACL pAcl, BOOL bSortList = TRUE);
    void InitDlg( HWND hDlg );
    int AddAce(HWND hListView, PACE_HEADER pAceHeader, int iRow, LPCTSTR pszInheritSource, int level);
    int AddAce(HWND hListView, PACE pAce, int iRow, LPCTSTR pszInheritSource, int level);
    LPCTSTR TranslateAceIntoRights(DWORD dwAceFlags,
                                   DWORD dwMask,
                                   const GUID *pObjectType,
                                   const GUID *pInheritedObjectType,
                                   LPCTSTR *ppszInheritType);
    LPCTSTR GetItemString(LPCTSTR pszItem, LPTSTR pszBuffer, UINT ccBuffer);
    void UpdateButtons(HWND hDlg);
    //NTRAID#NTBUG9-555470-2002/03/29-hiteshr
    HRESULT BuildAcl(HWND hListView,
                  PACL *ppAcl);
    HRESULT ApplyAudits(HWND hDlg, HWND hListView, BOOL fProtected);
    HRESULT ApplyPermissions(HWND hDlg, HWND hListView, BOOL fProtected);
    void OnApply(HWND hDlg, BOOL bClose);
    void OnAdd(HWND hDlg);
    void OnRemove(HWND hDlg);
    void OnReset(HWND hDlg);
    void OnProtect(HWND hDlg);
    void OnEdit(HWND hDlg);
    int AddAcesFromDPA(HWND hListView, HDPA hEntries, int iSelected);
    void EditAce(HWND hDlg, PACE pAce, BOOL bDeleteSelection, LONG iSelected = MAXLONG);
    void CheckAuditPolicy(HWND hwndOwner);
};
typedef CAdvancedListPage *PADVANCEDLISTPAGE;


int CALLBACK
AceListCompareProc(LPARAM lParam1,
                   LPARAM lParam2,
                   LPARAM lParamSort)
{
    int iResult = 0;
    PACE pAce1 = (PACE)lParam1;
    PACE pAce2 = (PACE)lParam2;
    short iColumn = LOWORD(lParamSort);
    short iSortDirection = HIWORD(lParamSort);
    LPTSTR psz1 = NULL;
    LPTSTR psz2 = NULL;

    TraceEnter(TRACE_ACELIST, "AceListCompareProc");

    if (iSortDirection == 0)
        iSortDirection = 1;

    if (pAce1 && pAce2)
    {
        switch (iColumn)
        {
        case 0:
            psz1 = pAce1->GetType();
            psz2 = pAce2->GetType();
            break;                
        case 1:
            psz1 = pAce1->GetName();
            psz2 = pAce2->GetName();
            break;

        case 2:
            psz1 = pAce1->GetAccessType();
            psz2 = pAce2->GetAccessType();
            break;

        case 3:
            psz1 = pAce1->GetInheritSourceName();
            psz2 = pAce2->GetInheritSourceName();
            break;
        case 4:
            psz1 = pAce1->GetInheritType();
            psz2 = pAce2->GetInheritType();
            break;
        }

        if (iResult == 0 && psz1 && psz2)
        {
            iResult = CompareString(LOCALE_USER_DEFAULT, 0, psz1, -1, psz2, -1) - 2;
        }

        iResult *= iSortDirection;
    }

    TraceLeaveValue(iResult);
}

//
//This function is used for cannonical sorting of the list
//
int CALLBACK
AceListCompareProcCanno(LPARAM lParam1,
                   LPARAM lParam2,
                   LPARAM lParamSort)
{
    int iResult = 0;
    PACE pAce1 = (PACE)lParam1;
    PACE pAce2 = (PACE)lParam2;
    short iColumn = LOWORD(lParamSort);
    short iSortDirection = HIWORD(lParamSort);
    LPTSTR psz1 = NULL;
    LPTSTR psz2 = NULL;

    TraceEnter(TRACE_ACELIST, "AceListCompareProc");

    if (iSortDirection == 0)
        iSortDirection = 1;

    if (pAce1 && pAce2)
    {
        switch (iColumn)
        {
        case 0:
            iResult = pAce1->CompareType(pAce2);
        // Fall through and use the name to differentiate ACEs of the same type
        case 1:
            psz1 = pAce1->GetName();
            psz2 = pAce2->GetName();
            break;

        }

        if (iResult == 0 && psz1 && psz2)
        {
            iResult = CompareString(LOCALE_USER_DEFAULT, 0, psz1, -1, psz2, -1) - 2;
        }

        iResult *= iSortDirection;
    }

    TraceLeaveValue(iResult);
}


//
// CAdvancedListPage implementation
//
LPCTSTR
CAdvancedListPage::TranslateAceIntoRights(DWORD dwAceFlags,
                                          DWORD dwMask,
                                          const GUID *pObjectType,
                                          const GUID *pInheritedObjectType,
                                          LPCTSTR *ppszInheritType)
{
    LPCTSTR     pszName = NULL;
    PSI_ACCESS  pAccess = m_pAccess;
    ULONG       cAccess = m_cAccesses;
    UINT        iItem;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::TranslateAceIntoRights");
    TraceAssert(pObjectType != NULL);
    TraceAssert(pInheritedObjectType != NULL);
    TraceAssert(!m_bAbortPage);

    // If this ACE applies to a different object type, ask the client
    // for the appropriate SI_ACCESS list.
    if ((m_siObjectInfo.dwFlags & SI_OBJECT_GUID)
        && !IsNullGUID(pInheritedObjectType)
        && !IsSameGUID(pInheritedObjectType, &m_siObjectInfo.guidObjectType))
    {
        ULONG iDefaultAccess;
        DWORD dwFlags = SI_ADVANCED;
        if (m_siPageType == SI_PAGE_AUDIT)
            dwFlags |= SI_EDIT_AUDITS;
        if (FAILED(m_psi->GetAccessRights(pInheritedObjectType,
                                          dwFlags,
                                          &pAccess,
                                          &cAccess,
                                          &iDefaultAccess)))
        {
            pAccess = m_pAccess;
            cAccess = m_cAccesses;
        }
    }

    if (pAccess && cAccess)
    {
        // Look for a name for the mask
        for (iItem = 0; iItem < cAccess; iItem++)
        {
            if ( dwMask == pAccess[iItem].mask &&
                 IsSameGUID(pObjectType, pAccess[iItem].pguid) )
            {
                pszName = pAccess[iItem].pszName;
                break;
            }
        }
    }

    // Look for a name for the inheritance type
    if ((m_siObjectInfo.dwFlags & SI_CONTAINER) && ppszInheritType)
    {
        // Check these inherit bits for a match
        DWORD dwInheritMask = INHERIT_ONLY_ACE | ACE_INHERIT_ALL;

        // Don't check INHERIT_ONLY_ACE if the ACE inherit type
        // matches the current object
        if ((m_siObjectInfo.dwFlags & SI_OBJECT_GUID) &&
            IsSameGUID(&m_siObjectInfo.guidObjectType, pInheritedObjectType))
        {
            dwInheritMask &= ~INHERIT_ONLY_ACE;
        }

        *ppszInheritType = NULL;

        for (iItem = 0; iItem < m_cInheritTypes; iItem++)
        {
            if ((m_pInheritType[iItem].dwFlags & dwInheritMask) == (ULONG)(dwAceFlags & dwInheritMask)
                && IsSameGUID(pInheritedObjectType, m_pInheritType[iItem].pguid))
            {
                *ppszInheritType = m_pInheritType[iItem].pszName;
                break;
            }
        }
    }

    TraceLeaveValue(pszName);
}


LPCTSTR
CAdvancedListPage::GetItemString(LPCTSTR pszItem,
                                 LPTSTR pszBuffer,
                                 UINT ccBuffer)
{
    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::GetItemString");

    if (pszItem == NULL)
    {
        LoadString(::hModule, IDS_SPECIAL, pszBuffer, ccBuffer);
        pszItem = pszBuffer;
    }
    else if (IS_INTRESOURCE(pszItem))
    {
        if (LoadString(m_siObjectInfo.hInstance,
                       (UINT)((ULONG_PTR)pszItem),
                       pszBuffer,
                       ccBuffer) == 0)
        {
            LoadString(::hModule, IDS_SPECIAL, pszBuffer, ccBuffer);
        }
        pszItem = pszBuffer;
    }

    TraceLeaveValue(pszItem);
}


int
CAdvancedListPage::AddAce(HWND hListView, 
                          PACE_HEADER pAceHeader, 
                          int iRow, 
                          LPCTSTR pszInheritSource,
                          int level)
{
    PACE pAce = new CAce(pAceHeader);
    if (pAce)
    {
        iRow = AddAce(hListView, pAce, iRow,pszInheritSource, level);
    }
    return iRow;
}

int
CAdvancedListPage::AddAce(HWND hListView, PACE pAceNew, int iRow,LPCTSTR pszInheritSource, int level)
{
    PACE    pAceCompare;
    TCHAR   szBuffer[MAX_COLUMN_CHARS];
    LPCTSTR pszInheritType;
    LPCTSTR pszRights;
    LV_ITEM lvi;
    UINT    id = IDS_UNKNOWN;
    int     iItem;
    int     cItems;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::AddAce");
    TraceAssert(hListView != NULL);
    TraceAssert(!m_bAbortPage);

    if (pAceNew == NULL)
        TraceLeaveValue(-1);

    pAceNew->SetInheritSourceInfo(pszInheritSource, level);
    m_psi->MapGeneric(&pAceNew->ObjectType, &pAceNew->AceFlags, &pAceNew->Mask);

    //
    // Try to merge the new ACE with an existing entry in the list.
    //
    cItems = ListView_GetItemCount(hListView);
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;

    while (cItems > 0)
    {
        --cItems;
        lvi.iItem = cItems;

        ListView_GetItem(hListView, &lvi);
        pAceCompare = (PACE)lvi.lParam;

        if (pAceCompare != NULL)
        {
            switch (pAceNew->Merge(pAceCompare))
            {
            case MERGE_MODIFIED_FLAGS:
            case MERGE_MODIFIED_MASK:
                // The ACEs were merged into pAceNew.
            case MERGE_OK_1:
                //
                // The new ACE implies the existing ACE, so the existing
                // ACE can be removed.
                //
                // First copy the name so we don't have to look
                // it up again.  (Don't copy the other strings
                // since they may be different.)
                //
                // Then keep looking.  Maybe we can remove some more entries
                // before adding the new one.
                //
                if (pAceNew->GetName() == NULL)
                    pAceNew->SetName(pAceCompare->GetName());
                ListView_DeleteItem(hListView, cItems);
                iRow = cItems;  // try to insert here
                break;

            case MERGE_OK_2:
                //
                // The existing ACE implies the new ACE, so we don't
                // need to do anything here.
                //
                delete pAceNew;
                TraceLeaveValue(cItems);
                break;
            }
        }
    }


    //
    // Make sure we have a name for the SID.
    //
    pAceNew->LookupName(m_siObjectInfo.pszServerName, m_psi2);

    //
    // Get the Access Type and Inherit Type strings
    //
    pszRights = TranslateAceIntoRights(pAceNew->AceFlags,
                                       pAceNew->Mask,
                                       &pAceNew->ObjectType,
                                       &pAceNew->InheritedObjectType,
                                       &pszInheritType);

    //
    // If this is a property ACE, give it a name like "Read property" or
    // "Write property".  Also, remember that it's a property ACE so we
    // can show the Property page first when editing this ACE.
    //
    // This is a bit slimy, since it assumes DS property access bits are
    // the only ones that will ever be used on the properties page.
    //
    if ((m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES) &&
        (pAceNew->Flags & ACE_OBJECT_TYPE_PRESENT) &&
        (pAceNew->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)) &&
        !(pAceNew->Mask & ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))
    {
        pAceNew->SetPropertyAce(TRUE);

        if (pszRights == NULL)
        {
            UINT idString = 0;

            switch (pAceNew->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP))
            {
            case ACTRL_DS_READ_PROP:
                idString = IDS_READ_PROP;
                break;

            case ACTRL_DS_WRITE_PROP:
                idString = IDS_WRITE_PROP;
                break;

            case (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP):
                idString = IDS_READ_WRITE_PROP;
                break;
            }

            if (idString)
            {
                LoadString(::hModule, idString, szBuffer, ARRAYSIZE(szBuffer));
                pszRights = szBuffer;
            }
        }
    }

    pszRights = GetItemString(pszRights, szBuffer, ARRAYSIZE(szBuffer));
    pAceNew->SetAccessType(pszRights);

    if (m_siObjectInfo.dwFlags & SI_CONTAINER)
    {
        pszInheritType = GetItemString(pszInheritType,
                                       szBuffer,
                                       ARRAYSIZE(szBuffer));
        pAceNew->SetInheritType(pszInheritType);
    }

    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.state = 0;
    lvi.stateMask = LVIS_CUT;
    lvi.iItem = iRow;
    lvi.iSubItem = 0;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    lvi.lParam = (LPARAM)pAceNew;

    if (pAceNew->AceFlags & INHERITED_ACE)
    {
#ifdef USE_OVERLAY_IMAGE
        lvi.state = LVIS_CUT | INDEXTOOVERLAYMASK(1);
#else
        lvi.state = LVIS_CUT;
#endif
    }


    //
    // Get the string ID for the Type column
    //
    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        switch(pAceNew->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                id = IDS_ALLOW;
                break;

            case ACCESS_DENIED_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                id = IDS_DENY;
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                id = IDS_AUDIT;
                break;

            case SYSTEM_ALARM_ACE_TYPE:
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                id = IDS_ALARM;
                break;
        }
    }
    else
    {

        switch(pAceNew->AceFlags & (SUCCESSFUL_ACCESS_ACE_FLAG|FAILED_ACCESS_ACE_FLAG))
        {
            case SUCCESSFUL_ACCESS_ACE_FLAG:
                id = IDS_AUDITPASS;
                break;

            case FAILED_ACCESS_ACE_FLAG:
                id = IDS_AUDITFAIL;
                break;

            case SUCCESSFUL_ACCESS_ACE_FLAG | FAILED_ACCESS_ACE_FLAG:
                id = IDS_AUDITBOTH;
                break;
        }
    }

    // Load the Type string
    LoadString(::hModule, id, szBuffer, ARRAYSIZE(szBuffer));
    pAceNew->SetType(szBuffer);

    //
    // Finally, insert the item into the list
    //
    iItem = ListView_InsertItem(hListView, &lvi);

    if (iItem == -1)
        delete pAceNew;

    TraceLeaveValue(iItem);
}


void
CAdvancedListPage::UpdateButtons( HWND hDlg )
{
    HWND hListView;
    BOOL fEnableButtons = FALSE;
    LVITEM lvi = {0};
    UINT cSelectedCount = 0;  //Number of item selected in listbox

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::UpdateButtons");

    hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);
    cSelectedCount = ListView_GetSelectedCount(hListView);

    if (!m_bAbortPage)
    {
        //If SelectedCount > 1, disable View\Edit button
        if( cSelectedCount <= 1 )
        {                       
            lvi.iItem = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);

            // Decide whether or not to enable edit button and decide what description
            // to display for the ACE
            if (lvi.iItem != -1)
                fEnableButtons = TRUE;
        }

        HWND hwndEdit = GetDlgItem(hDlg, IDC_ACEL_EDIT);

        // If we're disabling the edit button, make sure it doesn't have
        // focus or keyboard access gets hosed.
        if (!fEnableButtons && GetFocus() == hwndEdit)
            SetFocus(hListView);

        EnableWindow(hwndEdit, fEnableButtons);
    }

    if (m_bReadOnly)
    {
        const int idDisable[] =
        {
            IDC_ACEL_ADD,
            IDC_ACEL_REMOVE,
            IDC_ACEL_RESET,
            IDC_ACEL_PROTECT,
            IDC_ACEL_RESET_ACL_TREE,
        };
        for (int i = 0; i < ARRAYSIZE(idDisable); i++)
            EnableWindow(GetDlgItem(hDlg, idDisable[i]), FALSE);
    }
    else
    {
        // The Remove button is enabled if any selected ace is direct
        if ( AnySelectedAceofType( hListView, TRUE ) )
            fEnableButtons = TRUE;
        else
            fEnableButtons = FALSE;

        HWND hwndRemove = GetDlgItem(hDlg, IDC_ACEL_REMOVE);

        // If we're disabling the remove button, make sure it doesn't have
        // focus or keyboard access gets hosed.
        if (!fEnableButtons && GetFocus() == hwndRemove)
            SetFocus(hListView);

        EnableWindow(hwndRemove, fEnableButtons);
    }

    TraceLeaveVoid();
}


PACL
CAdvancedListPage::GetACL(PSECURITY_DESCRIPTOR *ppSD, LPBOOL pbProtected, BOOL bDefault)
{
    PACL pAcl = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
    DWORD dwRevision;
    BOOL bPresent;
    HRESULT hr;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::GetACL");
    TraceAssert(ppSD != NULL);
    TraceAssert(pbProtected != NULL);
    TraceAssert(m_psi != NULL);
    TraceAssert(!m_bAbortPage);


    *pbProtected = FALSE;

    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        hr = m_psi->GetSecurity(DACL_SECURITY_INFORMATION, ppSD, bDefault);

        if (SUCCEEDED(hr) && *ppSD != NULL)
        {
            GetSecurityDescriptorControl(*ppSD, &sdControl, &dwRevision);
            *pbProtected = ((sdControl & SE_DACL_PROTECTED) != 0);
            GetSecurityDescriptorDacl(*ppSD, &bPresent, &pAcl, &bDefault);
        }
    }
    else
    {
        DWORD dwPriv = SE_SECURITY_PRIVILEGE;
        HANDLE hToken = EnablePrivileges(&dwPriv, 1);

        hr = m_psi->GetSecurity(SACL_SECURITY_INFORMATION, ppSD, bDefault);

        ReleasePrivileges(hToken);

        if (SUCCEEDED(hr))
        {
            if (*ppSD != NULL)
            {
                GetSecurityDescriptorControl(*ppSD, &sdControl, &dwRevision);
                *pbProtected = ((sdControl & SE_SACL_PROTECTED) != 0);
                GetSecurityDescriptorSacl(*ppSD, &bPresent, &pAcl, &bDefault);
            }
        }
        else
        {
            // If we can't read the SACL, we can't write it either
            m_bReadOnly = TRUE;
        }
    }

    //Get the count of inheritable aces
    m_cInheritableAces = GetCountOfInheritableAces(pAcl);


    TraceLeaveValue(pAcl);
}


void
CAdvancedListPage::FillAceList(HWND hListView, PACL pAcl, BOOL bSortList)
{
    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::FillAceList");
    TraceAssert(!m_bAbortPage);
    
    //
    // Enumerate the ACL into the ListView
    //
    // Turn off redraw and empty out the list
    SendMessage(hListView, WM_SETREDRAW, FALSE, 0);
    ListView_DeleteAllItems(hListView);


    if (pAcl)
    {
        PACE_HEADER pAceHeader;
        UINT AceCount;
        int iRow = 0;
        HRESULT hr = S_OK;
        
        SECURITY_INFORMATION si = (m_siPageType == SI_PAGE_ADVPERM) ? DACL_SECURITY_INFORMATION :SACL_SECURITY_INFORMATION;
        
        PINHERITED_FROM pInheritArray = NULL;
        if(m_psoti)
        {
            DWORD dwPriv = SE_SECURITY_PRIVILEGE;
            HANDLE hToken = EnablePrivileges(&dwPriv, 1);
            hr = m_psoti->GetInheritSource(si, pAcl, &pInheritArray);
            ReleasePrivileges(hToken);
        }            
        //
        // Enumerate all of the ACEs, putting the data into the list view
        //
        ULONG i = 0;
        for (AceCount = pAcl->AceCount, pAceHeader = (PACE_HEADER)FirstAce(pAcl);
             AceCount > 0;
             AceCount--, pAceHeader = (PACE_HEADER)NextAce(pAceHeader), ++i)
        {
            iRow = AddAce(hListView, 
                          pAceHeader, 
                          iRow,
                          pInheritArray? pInheritArray[i].AncestorName : NULL,
                          pInheritArray? pInheritArray[i].GenerationGap :0
                          ) + 1;
        }
        
        LocalFree(pInheritArray);
    }

    if (bSortList)
    {
        //
        // Sort the list,if no column is clicked so far,
        // sort in the cannonical order else in the last column clicked order
        //
        if(m_iLastColumnClick == -1)
        {            
            ListView_SortItems(hListView,
                               AceListCompareProcCanno,
                               MAKELPARAM(0, 1));
        }
        else
        {
            ListView_SortItems(hListView,
                               AceListCompareProc,
                               MAKELPARAM(m_iLastColumnClick, m_iSortDirection));
        }
    }

    //
    // Now select the first item
    //
    SelectListViewItem(hListView, 0);

    // Redraw the list
    SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
    ListView_RedrawItems(hListView, 0, -1);

    TraceLeaveVoid();
}



COL_FOR_LV perm_col_for_container[] =
{
    IDS_ACE_PERM_COLUMN_TYPE,       10,
    IDS_ACE_PERM_COLUMN_NAME,       25,
    IDS_ACE_PERM_COLUMN_ACCESS,     20,
    IDS_ACE_PERM_COLUMN_PARENT,     20,
    IDS_ACE_PERM_COLUMN_INHERIT,    25,
};

COL_FOR_LV perm_col_for_noncontainer[] =
{
    IDS_ACE_PERM_COLUMN_TYPE,       10,
    IDS_ACE_PERM_COLUMN_NAME,       35,
    IDS_ACE_PERM_COLUMN_ACCESS,     20,
    IDS_ACE_PERM_COLUMN_PARENT,     35,
};

COL_FOR_LV audit_col_for_container[] =
{
    IDS_ACE_AUDIT_COLUMN_TYPE,      13,
    IDS_ACE_AUDIT_COLUMN_NAME,      25,
    IDS_ACE_AUDIT_COLUMN_ACCESS,    20,
    IDS_ACE_PERM_COLUMN_PARENT,     20,
    IDS_ACE_AUDIT_COLUMN_INHERIT,   25,
};

COL_FOR_LV audit_col_for_noncontainer[] =
{
    IDS_ACE_AUDIT_COLUMN_TYPE,      10,
    IDS_ACE_AUDIT_COLUMN_NAME,      35,
    IDS_ACE_AUDIT_COLUMN_ACCESS,    20,
    IDS_ACE_PERM_COLUMN_PARENT,     35,
};


void
CAdvancedListPage::InitDlg( HWND hDlg )
{
    HWND        hListView;
    RECT        rc;
    TCHAR       szBuffer[MAX_COLUMN_CHARS];
    LV_COLUMN   col;
    UINT        iTotal = 0;
    HCURSOR     hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::InitDlg");

    // Hide the Reset button if it isn't supported.
    if (!(m_siObjectInfo.dwFlags & SI_RESET) &&
        !((m_siPageType == SI_PAGE_ADVPERM) && (m_siObjectInfo.dwFlags & SI_RESET_DACL)) &&
        !((m_siPageType == SI_PAGE_AUDIT) && (m_siObjectInfo.dwFlags & SI_RESET_SACL)) )
    {
        HWND hwnd = GetDlgItem(hDlg, IDC_ACEL_RESET);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
        hwnd = GetDlgItem(hDlg, IDC_ACEL_DEFAULT_STATIC);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }

    if (m_siObjectInfo.dwFlags & SI_NO_ACL_PROTECT)
    {
        // Hide the "Inherit permissions" box
        HWND hwnd = GetDlgItem(hDlg, IDC_ACEL_PROTECT);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }

    if (!(m_siObjectInfo.dwFlags & SI_CONTAINER) ||
        !(m_siObjectInfo.dwFlags & (m_siPageType == SI_PAGE_ADVPERM ? SI_RESET_DACL_TREE : SI_RESET_SACL_TREE)))
    {
        // Hide the "Reset ACL" box
        HWND hwnd = GetDlgItem(hDlg, IDC_ACEL_RESET_ACL_TREE);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }

    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        m_bReadOnly = !!(m_siObjectInfo.dwFlags & SI_READONLY);
    }

     //If readonly, change edit button to view
     if(m_bReadOnly)
     {
        LoadString(::hModule, IDS_VIEW, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hDlg,IDC_ACEL_EDIT,szBuffer);
        LoadString(::hModule, 
                   (m_siPageType == SI_PAGE_ADVPERM)?IDS_ACL_EDIT_MORE_INFO:IDS_ACL_EDIT_MORE_INFO_1, 
                   szBuffer, 
                   ARRAYSIZE(szBuffer));
        SetDlgItemText(hDlg,IDC_ACEL_STATIC,szBuffer);      
     }


    hListView = GetDlgItem( hDlg, IDC_ACEL_DETAILS );

    if (m_bAbortPage)
    {
        //
        // Disable everything
        //
        m_bReadOnly = TRUE;
        EnableWindow(hListView, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ACEL_EDIT), FALSE);
    }
    else
    {
        //
        // Get the ACL
        //
        PSECURITY_DESCRIPTOR pSD = NULL;
        BOOL        fProtected = FALSE;
        PACL        pAcl = GetACL(&pSD, &fProtected, FALSE);

        if (m_siPageType == SI_PAGE_AUDIT)
        {
            if (pAcl && pAcl->AceCount)
            {
                // Audits are already in place, don't bother checking
                // whether auditing is enabled later.
                m_bAuditPolicyOK = TRUE;
            }

                //Check if any of the ace in SACL is Callback type
                //if yes hide all the controls and show the error
                //message.
                if(IsCallBackAcePresentInAcl(pAcl))
                {
                    HWND hwnd;
                    for (hwnd = GetWindow(hDlg, GW_CHILD);
                            hwnd != NULL;
                            hwnd = GetWindow(hwnd, GW_HWNDNEXT))
                    {
                            ShowWindow(hwnd, SW_HIDE);
                            EnableWindow(hwnd, FALSE);
                    }
                    // Enable and show the "No Security" message
                    hwnd = GetDlgItem(hDlg, IDC_SPP_CALLBACK_PERMISSIONS);
                    EnableWindow(hwnd, TRUE);
                    ShowWindow(hwnd, SW_SHOW);
                    if (pSD)
                        LocalFree(pSD);     // We're done with it, now free it
                    return;
                }
        }
        else
        {
            DWORD dwFullControl = GENERIC_ALL;
            UCHAR aceFlags = 0;

            m_psi->MapGeneric(NULL, &aceFlags, &dwFullControl);
            if (IsDenyACL(pAcl,
                          fProtected,
                          dwFullControl,
                          NULL))
            {
                // Already have Deny ACEs, don't bother warning again later.
                m_bWasDenyAcl = TRUE;
            }
        }

        //
        // Set up the listview control
        //

        // Set extended LV style for whole line selection with InfoTips
        ListView_SetExtendedListViewStyleEx(hListView,
                                            LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP,
                                            LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

        //
        // Add appropriate columns
        //
        GetClientRect(hListView, &rc);
        if (pAcl && pAcl->AceCount > 10)
            rc.right -= GetSystemMetrics(SM_CYHSCROLL); // Make room for scrollbar

        COL_FOR_LV *cfl;
        UINT iColCount;

        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
        {
            // Get the inherit types for filling in the inherit column
            m_cInheritTypes = 0;
            m_pInheritType = NULL;
            m_psi->GetInheritTypes(&m_pInheritType, &m_cInheritTypes);

            cfl = perm_col_for_container;
            iColCount = ARRAYSIZE(perm_col_for_container);

            if (m_siPageType == SI_PAGE_AUDIT)
            {
                cfl = audit_col_for_container;
                iColCount = ARRAYSIZE(audit_col_for_container);
            }
        }
        else
        {
            // There is no inherit column for non-containers

            cfl = perm_col_for_noncontainer;
            iColCount = ARRAYSIZE(perm_col_for_noncontainer);

            if (m_siPageType == SI_PAGE_AUDIT)
            {
                cfl = audit_col_for_noncontainer;
                iColCount = ARRAYSIZE(audit_col_for_noncontainer);
            }
        }

        UINT iCol;

        iCol = 0;
        while (iCol < iColCount)
        {
            LoadString(::hModule, cfl[iCol].idText,
                       szBuffer, ARRAYSIZE(szBuffer));
            col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
            col.fmt = LVCFMT_LEFT;
            col.pszText = szBuffer;
            col.iSubItem = iCol;

            if (iCol == iColCount - 1)
                col.cx = rc.right - iTotal;
            else
                col.cx = (rc.right * cfl[iCol].iPercent) / 100;

            ListView_InsertColumn(hListView, iCol, &col);
            iTotal += col.cx;
            iCol++;
        }

        //
        // Get the access list for filling in the Rights column
        //
        ULONG iDefaultAccess;
        DWORD dwFlags = SI_ADVANCED;
        if (m_siPageType == SI_PAGE_AUDIT)
            dwFlags |= SI_EDIT_AUDITS;
        m_psi->GetAccessRights(NULL,
                               dwFlags,
                               &m_pAccess,
                               &m_cAccesses,
                               &iDefaultAccess);

        //
        // Enumerate the ACL into the ListView
        //
        FillAceList(hListView, pAcl, FALSE);

        // Set the protection checkbox
        CheckDlgButton(hDlg, IDC_ACEL_PROTECT, !fProtected);

        if (pSD)
            LocalFree(pSD);     // We're done with it, now free it
    } // !m_bAbortPage

    // Update the other controls
    UpdateButtons(hDlg);

    SetCursor(hcur);

    TraceLeaveVoid();
}

//NTRAID#NTBUG9-555470-2002/03/29-hiteshr
HRESULT
CAdvancedListPage::BuildAcl(HWND hListView,
                            PACL *ppAcl)
{
    long cAces;
    long iEntry;
    long iLength = SIZEOF(ACL);
    PACE pAce;
    PACL pACL = NULL;
    LV_ITEM lvi;
    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.lParam   = NULL;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::BuildAcl");
    TraceAssert(hListView != NULL);
    TraceAssert(ppAcl != NULL);

    *ppAcl = NULL;

    cAces = ListView_GetItemCount(hListView);

    //
    // Iterate through all of the ace's counting up size.
    // If there are no ACEs, create an empty ACL.
    //
    for (iEntry = 0; iEntry < cAces; iEntry++)
    {
        lvi.iItem = iEntry;
        ListView_GetItem(hListView, &lvi);

        pAce = (PACE)lvi.lParam;
        if (pAce)
        {
            if (!(pAce->AceFlags & INHERITED_ACE))
                iLength += pAce->AceSize;
        }
    }

    pACL = (PACL)LocalAlloc(LPTR, iLength);
    if (pACL)
    {
        PACE_HEADER pAceDest;

        InitializeAcl(pACL, iLength, ACL_REVISION);

        for (iEntry = 0, pAceDest = (PACE_HEADER)FirstAce(pACL);
             iEntry < cAces;
             iEntry++)
        {
            lvi.iItem = iEntry;
            ListView_GetItem(hListView, &lvi);

            pAce = (PACE)lvi.lParam;
            if (pAce)
            {
                if (!(pAce->AceFlags & INHERITED_ACE))
                {
                    //Remveod the special casing for CREATOR_OWNER
                    //NTRAID#NTBUG9-467049-2001/11/29-hiteshr

                    pAce->CopyTo(pAceDest);
                    pACL->AceCount++;
                    pAceDest = (PACE_HEADER)NextAce(pAceDest);

                    // Is this an object ACE?  If so, reset the ACL revision.
                    if (pAce->Flags != 0 && pACL->AclRevision < ACL_REVISION_DS)
                        pACL->AclRevision = ACL_REVISION_DS;
                }
            }
        }

        iLength = (ULONG)((PBYTE)pAceDest - (PBYTE)pACL);
        TraceAssert(pACL->AclSize >= iLength);

        if (pACL->AclSize > iLength)
            pACL->AclSize = (WORD)iLength;

        TraceAssert(IsValidAcl(pACL));
    }
    else
    {
        TraceLeaveResult(E_OUTOFMEMORY);
    }

    *ppAcl = pACL;

    TraceLeaveResult(S_OK);
}


HRESULT
CAdvancedListPage::ApplyPermissions(HWND hDlg,
                                    HWND hListView,
                                    BOOL fProtected)
{
    HRESULT hr = S_OK;
    PACL pACL = NULL;
    SECURITY_DESCRIPTOR sd;
    SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
    BOOL bIsDenyAcl = FALSE;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::ApplyPermissions");
    TraceAssert(hDlg != NULL);
    TraceAssert(hListView != NULL);
    TraceAssert(!m_bReadOnly);
    TraceAssert(!m_bAbortPage);

    if (IsDlgButtonChecked(hDlg, IDC_ACEL_RESET_ACL_TREE))
    {
        // Confirm this operation
        if (IDNO == MsgPopup(hDlg,
                             MAKEINTRESOURCE(IDS_RESET_DACL_WARNING),
                             MAKEINTRESOURCE(IDS_SECURITY),
                             MB_YESNO | MB_ICONWARNING,
                             ::hModule,
                             m_siObjectInfo.pszObjectName))
        {
            // Return PSNRET_INVALID to abort the Apply and tell the sheet to
            // select this page as the active page.
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            ExitGracefully(hr, S_OK, "ApplyPermissions aborting");
        }

        si |= SI_RESET_DACL_TREE;
    }

    // Make sure the DACL is in canonical order.  Note that OnApply
    // will re-read the DACL and reinitialize the list with the
    // current sort order.
    ListView_SortItems(hListView,
                       AceListCompareProcCanno,
                       MAKELPARAM(0, 1));

    // Build the new DACL
    //NTRAID#NTBUG9-555470-2002/03/29-hiteshr
    hr = BuildAcl(hListView, &pACL);
    if(FAILED(hr))
        TraceLeaveResult(hr);


    // Check for Deny ACEs in the ACL
    if (!m_bWasDenyAcl)
    {
        DWORD dwWarning = 0;
        DWORD dwFullControl = GENERIC_ALL;
        UCHAR aceFlags = 0;

        m_psi->MapGeneric(NULL, &aceFlags, &dwFullControl);
        bIsDenyAcl = IsDenyACL(pACL,
                               fProtected,
                               dwFullControl,
                               &dwWarning);
        if (bIsDenyAcl)
        {
            TraceAssert(dwWarning != 0);

            // Warn the user about Deny ACEs
            if (IDNO == MsgPopup(hDlg,
                                 MAKEINTRESOURCE(dwWarning),
                                 MAKEINTRESOURCE(IDS_SECURITY),
                                 MB_YESNO | MB_ICONWARNING,
                                 ::hModule,
                                 m_siObjectInfo.pszObjectName))
            {
                // Return PSNRET_INVALID to abort the Apply and tell the sheet to
                // select this page as the active page.
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                ExitGracefully(hr, S_OK, "ApplyPermissions aborting");
            }
        }
    }

    // Build the security descriptor
    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
     {
         DWORD dwErr = GetLastError();
         ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"InitializeSecurityDescriptor failed");
     }

    if(!SetSecurityDescriptorDacl(&sd, !!(pACL), pACL, FALSE))
     {
         DWORD dwErr = GetLastError();
         ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"SetSecurityDescriptorDacl failed");
     }

    sd.Control |= SE_DACL_AUTO_INHERIT_REQ;

    if (fProtected)
        sd.Control |= SE_DACL_PROTECTED;

    if(IsAclBloated(hDlg, si, &sd, m_cInheritableAces,m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES))
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        ExitGracefully(hr, S_FALSE, "ApplyPermissions aborting");
    }
    
    // Write out the new DACL
    hr = m_psi->SetSecurity(si, &sd);
    

    if (bIsDenyAcl && S_OK == hr)
        m_bWasDenyAcl = TRUE;

exit_gracefully:

    if (pACL)
        LocalFree(pACL);

    TraceLeaveResult(hr);
}


HRESULT
CAdvancedListPage::ApplyAudits(HWND hDlg,
                               HWND hListView,
                               BOOL fProtected)
{
    HRESULT hr = S_OK;
    PACL pACL = NULL;
    SECURITY_DESCRIPTOR sd;
    SECURITY_INFORMATION si = SACL_SECURITY_INFORMATION;
    DWORD dwPriv = SE_SECURITY_PRIVILEGE;
    HANDLE hToken = INVALID_HANDLE_VALUE;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::ApplyAudits");
    TraceAssert(!m_bReadOnly);
    TraceAssert(!m_bAbortPage);

    if (IsDlgButtonChecked(hDlg, IDC_ACEL_RESET_ACL_TREE))
        si |= SI_RESET_SACL_TREE;

    // Build the SACL
    //NTRAID#NTBUG9-555470-2002/03/29-hiteshr
    hr = BuildAcl(hListView, &pACL);
    if(FAILED(hr))
        TraceLeaveResult(hr);


    // Build the security descriptor
    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
    {
         DWORD dwErr = GetLastError();
         ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"InitializeSecurityDescriptor failed");
    }

    if(!SetSecurityDescriptorSacl(&sd, !!(pACL), pACL, FALSE))
    {
         DWORD dwErr = GetLastError();
         ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"SetSecurityDescriptorSacl failed");
    }
    sd.Control |= SE_SACL_AUTO_INHERIT_REQ;

    if (fProtected)
        sd.Control |= SE_SACL_PROTECTED;

    // Enable the security privilege and write out the new SACL
    hToken = EnablePrivileges(&dwPriv, 1);

    if(IsAclBloated(hDlg, si, &sd, m_cInheritableAces,m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES))
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        hr = S_FALSE;
    }
    else
        hr = m_psi->SetSecurity(si, &sd);

    ReleasePrivileges(hToken);


    if (S_OK == hr)
        CheckAuditPolicy(hDlg);

exit_gracefully:

    if (pACL)
        LocalFree(pACL);

    TraceLeaveResult(hr);
}


void
CAdvancedListPage::OnApply(HWND hDlg, BOOL bClose)
{
    HRESULT hr = S_OK;
    HWND hListView;
    BOOL fProtected;

    if (!m_fPageDirty)
        return;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::OnApply");
    TraceAssert(hDlg != NULL);
    TraceAssert(!m_bReadOnly);
    TraceAssert(!m_bAbortPage);

    hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);
    fProtected = !IsDlgButtonChecked(hDlg, IDC_ACEL_PROTECT);

    if (m_siPageType == SI_PAGE_ADVPERM)
    {
        hr = ApplyPermissions(hDlg, hListView, fProtected);
    }
    else
    {
        hr = ApplyAudits(hDlg, hListView, fProtected);
    }

    if (FAILED(hr))
    {
        // Tell the user there was a problem.  If they choose to cancel
        // and the dialog is closing, do nothing (let the dialog close).
        // Otherwise, tell the property sheet that we had a problem.
        UINT nMsgID = IDS_PERM_WRITE_FAILED;
        if (m_siPageType == SI_PAGE_AUDIT)
            nMsgID = IDS_AUDIT_WRITE_FAILED;

        if (IDCANCEL != SysMsgPopup(hDlg,
                                    MAKEINTRESOURCE(nMsgID),
                                    MAKEINTRESOURCE(IDS_SECURITY),
                                    (bClose ? MB_RETRYCANCEL : MB_OK) | MB_ICONERROR,
                                    ::hModule,
                                    hr,
                                    m_siObjectInfo.pszObjectName))
        {
            // Return PSNRET_INVALID to abort the Apply and cause the sheet to
            // select this page as the active page.
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        }
    }
    else if (S_FALSE == hr)
    {
        // S_FALSE is silent failure (the client should put up UI
        // during SetSecurity before returning S_FALSE).
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
    }
    else
    {
        m_fPageDirty = FALSE;

        // If ApplyPermissions bailed due to user action ("No"),
        // then the dialog won't be closing
        if (PSNRET_INVALID == GetWindowLongPtr(hDlg, DWLP_MSGRESULT))
            bClose = FALSE;

        if (!bClose)
        {
            //
            // Re-read the security descriptor and reinitialize the dialog
            //
            //Inform the Effective Permission tab that
            //Permissions are changed
            if(m_siPageType == SI_PAGE_ADVPERM)
                PropSheet_QuerySiblings(GetParent(hDlg),0,0);

            PSECURITY_DESCRIPTOR pSD = NULL;
            BOOL        fACLProtected = FALSE;
            PACL pAcl = GetACL(&pSD, &fACLProtected, FALSE);
            FillAceList(hListView, pAcl);


            // Set the button states
             CheckDlgButton(hDlg, IDC_ACEL_PROTECT, !fACLProtected);
            CheckDlgButton(hDlg, IDC_ACEL_RESET_ACL_TREE, BST_UNCHECKED);
            UpdateButtons(hDlg);

            if (pSD)
                LocalFree(pSD);     // We're done with it, now free it
        }
    }

    TraceLeaveVoid();
}

void
CAdvancedListPage::OnAdd(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::OnAdd");
    TraceAssert(!m_bReadOnly);

    if (S_OK == GetUserGroup(hDlg, FALSE, &pUserList))
    {
        // Build an empty ACE (mask = 0) using the SID we just
        // got in pUserList.
        CAce ace;

        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        if (m_siPageType == SI_PAGE_AUDIT)
            ace.AceType = SYSTEM_AUDIT_ACE_TYPE;

        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
            ace.AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;

        ace.SetSid(pUserList->rgUsers[0].pSid,
                   pUserList->rgUsers[0].pszName,
                   pUserList->rgUsers[0].pszLogonName,
                   pUserList->rgUsers[0].SidType);

        // Done with this now
        LocalFree(pUserList);

        // Edit the ACE
        EditAce(hDlg, &ace, FALSE);
    }

    TraceLeaveVoid();
}


BOOL CanDeleteDirectAces( HWND hDlg )
{
    TCHAR szBuffer[1024];
    TCHAR szCaption[1024];
    if( !LoadString( ::hModule, IDS_CONFIRM_MULTIPLE_DELETION, szBuffer, 1024 ) )
        return FALSE;
    if( !LoadString( ::hModule, IDS_SECURITY, szCaption, 1024 ) )
        return FALSE;

    return (IDYES == MessageBox( hDlg, szBuffer, szCaption, MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL ));
}
void
CAdvancedListPage::OnRemove(HWND hDlg)
{

    HWND hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);

    //if Any selected Ace is inherited from parent
    //Ask user if to proceed with deletion of direct aces
    if( AnySelectedAceofType(hListView, FALSE) && !CanDeleteDirectAces( hDlg ) )
        return;

    //Remember the positon of first selected permissons
    //In end select the item at this position
    int iFirstSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);
    LVITEM lvi = {0};
    lvi.iItem = iFirstSelected;
    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;
    while( lvi.iItem != -1 )
    {

        lvi.lParam   = NULL;
        ListView_GetItem(hListView, &lvi);
        if( (((PACE)lvi.lParam)->AceFlags & INHERITED_ACE) == 0 )
        {
            ListView_DeleteItem(hListView, lvi.iItem);
            //Start from one item back as current item is deleted
            --lvi.iItem;
        }
        lvi.iItem = ListView_GetNextItem(hListView, lvi.iItem, LVNI_SELECTED);
    }


    if (ListView_GetItemCount(hListView) <= iFirstSelected )
            --iFirstSelected;

        SelectListViewItem(hListView, iFirstSelected);

        PropSheet_Changed(GetParent(hDlg),hDlg);
        m_fPageDirty = TRUE;
    
}


void
CAdvancedListPage::OnReset(HWND hDlg)
{
    //
    // Get a default ACL and enumerate it into the ListView
    //
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL fProtected = FALSE;

    FillAceList(GetDlgItem(hDlg, IDC_ACEL_DETAILS),
                GetACL(&pSD, &fProtected, TRUE /*default*/));

    // Set the button states
    CheckDlgButton(hDlg, IDC_ACEL_PROTECT, !fProtected);
    UpdateButtons(hDlg);

    if (pSD)
        LocalFree(pSD);     // We're done with it, now free it

    // Notify the property sheet that we've changed
    PropSheet_Changed(GetParent(hDlg),hDlg);
    m_fPageDirty = TRUE;
}


void
CAdvancedListPage::OnProtect(HWND hDlg)
{
    // The "Inherit permissions" checkbox was clicked

    if (!IsDlgButtonChecked(hDlg, IDC_ACEL_PROTECT))
    {
        BOOL bHaveInheritedAces = FALSE;
        HWND hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);
        int cItems = ListView_GetItemCount(hListView);
        int i;
        PACE pAce;
        LV_ITEM lvItem;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;

        // Are there any inherited aces?
        for (i = 0; i < cItems && !bHaveInheritedAces; i++)
        {
            lvItem.iItem = i;
            ListView_GetItem(hListView, &lvItem);
            pAce = (PACE)lvItem.lParam;
            if (pAce)
                bHaveInheritedAces = (pAce->AceFlags & INHERITED_ACE);
        }

        if (bHaveInheritedAces)
        {
            int nResult;
            int iSelected;

            // Turning protection on.  Ask the user whether to convert
            // inherited aces to non-inherited aces, or delete them.
            nResult = ConfirmAclProtect(hDlg, m_siPageType == SI_PAGE_ADVPERM);

            if (nResult == IDCANCEL)
            {
                // Reset the checkbox and bail
                CheckDlgButton(hDlg, IDC_ACEL_PROTECT, BST_CHECKED);
                return;
            }

            //
            // Remember the current selection, if any.
            //
            iSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);

            //
            // Convert or delete inherited aces
            //
            while (cItems > 0)
            {
                --cItems;
                lvItem.iItem = cItems;

                //
                // The AddAce call below merges entries, which
                // can potentially remove entries from the list,
                // so check the return value here.  This also
                // means we could see the same item more than
                // once here, but after the first time it won't
                // have the INHERITED_ACE flag set.
                //
                if (!ListView_GetItem(hListView, &lvItem))
                    continue;

                pAce = (PACE)lvItem.lParam;

                if (pAce && (pAce->AceFlags & INHERITED_ACE))
                {
                    if (nResult == IDC_CONFIRM_REMOVE)
                    {
                        // Delete it
                        ListView_DeleteItem(hListView, cItems);
                    }
                    else
                    {
                        //
                        // Convert it to non-inherited.  Do this
                        // by deleting and re-adding without
                        // INHERITED_ACE set.  AddAce will try
                        // to merge into existing entries.
                        //
                        // Before deleting, be sure to set
                        // lParam to zero so pAce doesn't
                        // get freed.
                        //
                        pAce->AceFlags &= ~INHERITED_ACE;
                        lvItem.lParam = 0;
                        ListView_SetItem(hListView, &lvItem);
                        ListView_DeleteItem(hListView, cItems);
                        AddAce(hListView, pAce, cItems, NULL,0);
                    }
                }
            }

            //
            // Reset the selection
            //
            iSelected = min(ListView_GetItemCount(hListView)-1, iSelected);
            SelectListViewItem(hListView, iSelected);
        }
    }

    PropSheet_Changed(GetParent(hDlg), hDlg);
    m_fPageDirty = TRUE;
}


void
CAdvancedListPage::OnEdit(HWND hDlg)
{
    HWND hListView;
    PACE pAce;
    int  iSelected;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::OnEdit");
    TraceAssert(hDlg != NULL);
    TraceAssert(!m_bAbortPage);

    hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);
    pAce = (PACE)GetSelectedItemData(hListView, &iSelected);
     if(iSelected != -1)
     {
        EditAce(hDlg, pAce, TRUE, iSelected);
     }

    TraceLeaveVoid();
}


int
CAdvancedListPage::AddAcesFromDPA(HWND hListView, HDPA hEntries, int iSelected)
{
    UINT iItems = 0;

    if (hEntries)
        iItems = DPA_GetPtrCount(hEntries);

    while (iItems)
    {
        --iItems;
        iSelected = AddAce(hListView,
                           (PACE_HEADER)DPA_FastGetPtr(hEntries, iItems),
                           iSelected,
                           NULL,0) + 1;
    }

    return iSelected;
}

void
CAdvancedListPage::EditAce(HWND hDlg, PACE pAce, BOOL bDeleteSelection, LONG iSelected)
{
    HWND hListView;
    HDPA hEntries = NULL;
    HDPA hPropertyEntries = NULL;
    UINT iItems = 0;
    UINT iPropertyItems = 0;
    BOOL bUpdateList;
    UINT nStartPage = 0;
    DWORD dwResult = 0;

    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::EditAce");
    TraceAssert(hDlg != NULL);
    TraceAssert(!m_bAbortPage);

    hListView = GetDlgItem(hDlg, IDC_ACEL_DETAILS);

    if (pAce)
    {
        // If the ACE is inherited, don't delete it.
        if (pAce->AceFlags & INHERITED_ACE)
            bDeleteSelection = FALSE;

        // If this is a property ACE, we want to show the property page first.
        if (pAce->IsPropertyAce())
        {
            TraceAssert(m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES);
            nStartPage = 1;
        }
    }

    bUpdateList = EditACEEntry(hDlg,
                               m_psi,
                               pAce,
                               m_siPageType,
                               m_siObjectInfo.pszObjectName,
                               m_bReadOnly,
                               &dwResult,
                               &hEntries,
                               (m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES) ? &hPropertyEntries : NULL,
                               nStartPage)
                  && !m_bReadOnly;

    if (bUpdateList)
    {
        if (hEntries)
            iItems = DPA_GetPtrCount(hEntries);

        if (hPropertyEntries)
            iPropertyItems = DPA_GetPtrCount(hPropertyEntries);

        if (iItems + iPropertyItems)
        {
            if (bDeleteSelection)
            {
                if ((nStartPage == 0 && iItems != 0) || (nStartPage == 1 && iPropertyItems != 0))
                {
                    // The previous ace was modified, so delete it here.
                    ListView_DeleteItem(hListView, iSelected);
                }
                else if (iPropertyItems != 0 &&
                         !(pAce->Flags & ACE_OBJECT_TYPE_PRESENT) &&
                         (pAce->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))
                {
                    //
                    // iPropertyItems != 0 implies nStartPage = 0 or else the
                    // "if" condition above would be true.  nStartPage = 0
                    // implies iItems = 0 for the same reason.  That means the
                    // ace has more in it that just property stuff (or it's a
                    // control access right), but the only changes occurred on the
                    // Property page.  Make sure we get rid of any property bits
                    // in the original ace so that we don't incorrectly merge
                    // property changes into the original ace.
                    //
                    // An example of this:
                    // Suppose pAce->Mask == READ_CONTROL | ACTRL_DS_READ_PROP and
                    // no property GUID is present.  Suppose the user edits the ace
                    // and clicks on the Property tab, then unchecks a bunch of
                    // things, including "Read all properties".  The result
                    // "should be" a bunch of "Read <specific property>" aces.
                    // If we don't remove ACTRL_DS_READ_PROP from the original ace,
                    // then all of the "Read <specific property>" aces get merged
                    // back into the original ace for no net effect.
                    //
                    // The reverse situation (nStartPage = 1, iPropertyItems = 0,
                    // iItems != 0) is not a problem.  In that case merging will
                    // occur correctly,
                    //

                    // Make a copy with everything except the property bits
                    if (pAce->Mask & ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP))
                    {
EditAce_MakeCopyWithoutProperties:
                        PACE_HEADER pAceHeader = pAce->Copy();
                        if (pAceHeader != NULL)
                        {
                            // Turn off property bits
                            ((PKNOWN_ACE)pAceHeader)->Mask &= ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP);
                            TraceAssert(((PKNOWN_ACE)pAceHeader)->Mask != 0);
                            // 370573
                            // Add it to hPropertyEntries instead of hEntries,
                            // since hEntries can be NULL here but we know
                            // hPropertyEntries is non-NULL (iPropertyItems!=0)
                            DPA_AppendPtr(hPropertyEntries, pAceHeader);
                        }
                    }
                    // Delete the old ace
                    ListView_DeleteItem(hListView, iSelected);
                }
            }

            //
            // Now merge the new aces into the existing list
            //
            iSelected = AddAcesFromDPA(hListView, hEntries, iSelected);
            iSelected = AddAcesFromDPA(hListView, hPropertyEntries, iSelected);

            //
            // Now select the last item inserted
            //
            SelectSingleItemInLV( hListView, iSelected -1 );
            // Re-sort the list so the new and/or modified entries
            // appear in the right place.
            if(m_iLastColumnClick == -1)
            {            
                ListView_SortItems(hListView,
                                   AceListCompareProcCanno,
                                   MAKELPARAM(0, 1));
            }
            else
            {
                ListView_SortItems(hListView,
                                   AceListCompareProc,
                                   MAKELPARAM(m_iLastColumnClick, m_iSortDirection));
            }

            // After sorting, make sure the selection is visible.
            EnsureListViewSelectionIsVisible(hListView);
        }
        else if (bDeleteSelection && dwResult)
        {
            // Everything succeeded, something was edited, but nothing was created
            // (probably all boxes were unchecked).  Delete the previous selection.

            // 370573
            // If the only change occurred on the Properties page, then we
            // only want to turn off the property bits. We don't want to
            // delete the whole thing.
            if (EAE_NEW_PROPERTY_ACE == dwResult &&
                (pAce->Mask & ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))
            {
                if (!hPropertyEntries)
                    hPropertyEntries = DPA_Create(1);
                if (hPropertyEntries)
                    goto EditAce_MakeCopyWithoutProperties;
            }

            // Delete the previous selection.
            ListView_DeleteItem(hListView, iSelected);
        }

        // Was anything edited?
        if (dwResult)
        {
            PropSheet_Changed(GetParent(hDlg),hDlg);
            m_fPageDirty = TRUE;
        }
    }

    if (hEntries)
        DestroyDPA(hEntries);

    if (hPropertyEntries)
        DestroyDPA(hPropertyEntries);

    TraceLeaveVoid();
}


void
CAdvancedListPage::CheckAuditPolicy(HWND hwndOwner)
{
    //
    // Check whether auditing is turned on and warn the user if not.
    //
    TraceEnter(TRACE_ACELIST, "CAdvancedListPage::CheckAuditPolicy");

    if (!m_bAuditPolicyOK)
    {
        LSA_HANDLE hPolicy = GetLSAConnection(m_siObjectInfo.pszServerName,
                                              POLICY_VIEW_AUDIT_INFORMATION);

        if (hPolicy != NULL)
        {
            PPOLICY_AUDIT_EVENTS_INFO pAuditInfo = NULL;

            LsaQueryInformationPolicy(hPolicy,
                                      PolicyAuditEventsInformation,
                                      (PVOID*)&pAuditInfo);

            if (pAuditInfo != NULL)
            {
                // We don't need to do this work again
                m_bAuditPolicyOK = TRUE;

                if (!pAuditInfo->AuditingMode)
                {
                    // Auditing is not on... warn the user
                    MsgPopup(hwndOwner,
                             MAKEINTRESOURCE(IDS_AUDIT_OFF_WARNING),
                             MAKEINTRESOURCE(IDS_SECURITY),
                             MB_OK | MB_ICONWARNING,
                             ::hModule);
                }

                LsaFreeMemory(pAuditInfo);
            }
            else
            {
                TraceMsg("LsaQueryInformationPolicy failed");
            }

            LsaClose(hPolicy);
        }
        else
        {
            TraceMsg("Unable to open LSA policy handle");
        }
    }

    TraceLeaveVoid();
}


BOOL
CAdvancedListPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PACE pAce;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)lParam;

            // Set default return value
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

            switch (pnmh->code)
            {
            case NM_DBLCLK:
                if (pnmh->idFrom == IDC_ACEL_DETAILS)
                    OnEdit(hDlg);
                break;

            case LVN_ITEMCHANGED:
                if (pnmlv->uChanged & LVIF_STATE)
                    UpdateButtons(hDlg);
                break;

            case LVN_DELETEITEM:
                pAce = (PACE)pnmlv->lParam;
                delete pAce;
                break;

            case LVN_KEYDOWN:
                if (((LPNMLVKEYDOWN)pnmh)->wVKey == VK_DELETE)
                    if( IsWindowEnabled( GetDlgItem( hDlg, IDC_ACEL_REMOVE ) ) )
                        SendMessage(hDlg,
                                    WM_COMMAND,
                                    GET_WM_COMMAND_MPS(IDC_ACEL_REMOVE, NULL, 0));
                break;

#define lvi (((NMLVDISPINFO*)lParam)->item)

            case LVN_GETDISPINFO:
                pAce = (PACE)lvi.lParam;
                if ((lvi.mask & LVIF_TEXT) && pAce)
                {
                    switch (lvi.iSubItem)
                    {
                    case 0:
                        lvi.pszText = pAce->GetType();
                        break;

                    case 1:
                        lvi.pszText = pAce->GetName();
                        break;

                    case 2:
                        lvi.pszText = pAce->GetAccessType();
                        break;
                    case 3:
                        lvi.pszText = pAce->GetInheritSourceName();
                        break;
                    case 4:
                        lvi.pszText = pAce->GetInheritType();
                        break;
                    }
                }
                break;
#undef lvi

            case LVN_COLUMNCLICK:
                if (m_iLastColumnClick == pnmlv->iSubItem)
                    m_iSortDirection = -m_iSortDirection;
                else
                    m_iSortDirection = 1;
                m_iLastColumnClick = pnmlv->iSubItem;
                ListView_SortItems(pnmh->hwndFrom,
                                   AceListCompareProc,
                                   MAKELPARAM(m_iLastColumnClick, m_iSortDirection));
                EnsureListViewSelectionIsVisible(pnmh->hwndFrom);
                break;

            case PSN_APPLY:
                OnApply(hDlg, (BOOL)(((LPPSHNOTIFY)lParam)->lParam));
                break;
            
            case NM_CLICK:
            case NM_RETURN:
            {
                if(wParam == IDC_EFF_STATIC)
                {
                    if(m_siPageType == SI_PAGE_AUDIT)
                    {
                        HtmlHelp(hDlg,
                                 c_szAuditHelpLink,
                                 HH_DISPLAY_TOPIC,
                                 0);
                    }
                    else
                    {
                        HtmlHelp(hDlg,
                                 c_szPermHelpLink,
                                 HH_DISPLAY_TOPIC,
                                 0);

                    }
                }
            }
            break;

            }
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_ACEL_ADD:
            OnAdd(hDlg);
            break;

        case IDC_ACEL_REMOVE:
            OnRemove(hDlg);
            break;

        case IDC_ACEL_EDIT:
            OnEdit(hDlg);
            break;

        case IDC_ACEL_RESET:
            OnReset(hDlg);
            break;

        case IDC_ACEL_RESET_ACL_TREE:
            if (!m_fPageDirty)
            {
                PropSheet_Changed(GetParent(hDlg),hDlg);
                m_fPageDirty = TRUE;
            }
            break;

        case IDC_ACEL_PROTECT:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED
                && !m_bReadOnly)
            {
                OnProtect(hDlg);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            const DWORD *pdwHelpIDs = aAceListPermHelpIDs;

            if (m_siPageType == SI_PAGE_AUDIT)
                pdwHelpIDs = aAceListAuditHelpIDs;

            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szAcluiHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)pdwHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            const DWORD *pdwHelpIDs = aAceListPermHelpIDs;

            if (m_siPageType == SI_PAGE_AUDIT)
                pdwHelpIDs = aAceListAuditHelpIDs;

            WinHelp(hDlg,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)pdwHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

HPROPSHEETPAGE
CreateAdvPermissionPage( LPSECURITYINFO psi )
{
    HPROPSHEETPAGE hPage = NULL;
    PADVANCEDLISTPAGE pPage;

    TraceEnter(TRACE_ACELIST, "CreateAdvPermissionPage");

    pPage = new CAdvancedListPage( psi, SI_PAGE_ADVPERM );

    if (pPage)
    {
        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_ACELIST_PERM_PAGE));

        if (!hPage)
            delete pPage;
    }

    TraceLeaveValue(hPage);
}

HPROPSHEETPAGE
CreateAdvAuditPage( LPSECURITYINFO psi )
{
    HPROPSHEETPAGE hPage = NULL;
    PADVANCEDLISTPAGE pPage;

    TraceEnter(TRACE_ACELIST, "CreateAdvAuditPage");

    pPage = new CAdvancedListPage( psi, SI_PAGE_AUDIT );

    if (pPage)
    {
        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_ACELIST_AUDIT_PAGE));

        if (!hPage)
            delete pPage;
    }

    TraceLeaveValue(hPage);
}


//
// Expose an api to get at the ace list editor
//
BOOL
ACLUIAPI
EditSecurityEx(HWND hwndOwner, 
               LPSECURITYINFO psi, 
               PPERMPAGE pPermPage, 
               UINT nStartPage,
               BOOL &refbNoReadWriteCanWriteOwner)
{
    HPROPSHEETPAGE hPage[4];
    UINT cPages = 0;
    BOOL bResult = FALSE;
    SI_OBJECT_INFO siObjectInfo = {0};
    HRESULT hr;

    TraceEnter(TRACE_ACELIST, "EditSecurityEx");

    // Get flags and object name information
    hr = psi->GetObjectInformation(&siObjectInfo);

    if (FAILED(hr))
    {
        SysMsgPopup(hwndOwner,
                    MAKEINTRESOURCE(IDS_OPERATION_FAILED),
                    MAKEINTRESOURCE(IDS_SECURITY),
                    MB_OK | MB_ICONERROR,
                    ::hModule,
                    hr);
        TraceLeaveValue(FALSE);
    }

    hPage[cPages] = CreateAdvPermissionPage( psi );
    if (hPage[cPages])
        cPages++;

    if (siObjectInfo.dwFlags & SI_EDIT_AUDITS)
    {
        hPage[cPages] = CreateAdvAuditPage( psi );
        if (hPage[cPages])
            cPages++;
    }

    if (siObjectInfo.dwFlags & SI_EDIT_OWNER)
    {
        hPage[cPages] = CreateOwnerPage( psi, &siObjectInfo, refbNoReadWriteCanWriteOwner );
        if (hPage[cPages])
            cPages++;
    }

    if((siObjectInfo.dwFlags & SI_EDIT_EFFECTIVE) &&  pPermPage->IsEffective())
    {
        hPage[cPages] = CreateEffectivePermPage( psi, &siObjectInfo );
        if (hPage[cPages])
        {
//            pPermPage->SetEffectivePerm(hPage[cPages]);
            cPages++;
        }
    }

    if (cPages)
    {
        // Build dialog title string
        LPTSTR pszCaption = NULL;
        FormatStringID(&pszCaption, ::hModule, IDS_ACEL_TITLE, siObjectInfo.pszObjectName);

        PROPSHEETHEADER psh = {0};
        psh.dwSize = SIZEOF(psh);
        psh.dwFlags = PSH_DEFAULT;
        psh.hwndParent = hwndOwner;
        psh.hInstance = ::hModule;
        psh.pszCaption = pszCaption;
        psh.nPages = cPages;
        psh.nStartPage = 0;
        psh.phpage = &hPage[0];

        if (nStartPage < cPages)
            psh.nStartPage = nStartPage;

        bResult = (BOOL)(PropertySheet(&psh) + 1);

        LocalFreeString(&pszCaption);
    }

    TraceLeaveValue(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\runonce\romain.c ===
// **************************************************************************
//
// ROMain.C
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1993
//  All rights reserved
//
//  The window/messages pump for RunOnce
//
//      5 June 1994     FelixA  Started
//
//     23 June 94       FelixA  Moved to Shell tree. Changed UI.
//
// *************************************************************************/

#include "precomp.h"
#include "regstr.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shellapi.h>
#include <winuserp.h>
#include <shlobj.h>
#include <shlobjp.h>
#include "resource.h"

#include <runonce.c>    // shared runonce code

// needed to make this code compile (legacy runonce.c baggage from explorer\initcab.cpp)
BOOL g_fCleanBoot = FALSE;
BOOL g_fEndSession = FALSE;


HINSTANCE g_hInst;          // current instance
BOOL InitROInstance( HINSTANCE hInstance, int nCmdShow);


typedef void (WINAPI *RUNONCEEXPROCESS)(HWND, HINSTANCE, LPSTR, int);

int ParseCmdLine(LPCTSTR lpCmdLine)
{
    int Res=0;

    while(*lpCmdLine)
    {
        while( *lpCmdLine && *lpCmdLine!=TEXT('-') && *lpCmdLine!=TEXT('/'))
            lpCmdLine++;

        if (!(*lpCmdLine)) {
            return Res;
        }

        // skip over the '/'
        lpCmdLine++;

        if (lstrcmpi(lpCmdLine, TEXT("RunOnce6432")) == 0)
        {
            if (IsOS(OS_WOW6432))
            {
                // this means we have to process the 32-bit RunOnce keys for wow64
                Res =  Cabinet_EnumRegApps(HKEY_LOCAL_MACHINE,
                                           REGSTR_PATH_RUNONCE,
                                           RRA_DELETE | RRA_WAIT,
                                           ExecuteRegAppEnumProc,
                                           0);
            }   
            return Res;
        }
        else if (lstrcmpi(lpCmdLine, TEXT("RunOnceEx6432")) == 0)
        {
            if (IsOS(OS_WOW6432))
            {
                // this means that we have to process the 32-bit RunOnceEx keys for wow64
                HINSTANCE hLib;

                hLib = LoadLibrary(TEXT("iernonce.dll"));
                if (hLib)
                {
                    // Note: if ew ant TS install mode for wow64 apps we need to enable/disable install mode here
                    RUNONCEEXPROCESS pfnRunOnceExProcess = (RUNONCEEXPROCESS)GetProcAddress(hLib, "RunOnceExProcess");
                    if (pfnRunOnceExProcess)
                    {
                        // the four param in the function is due to the function cab be called
                        // from RunDLL which will path in those params.  But RunOnceExProcess ignore all
                        // of them.  Therefore, I don't pass any meaningful thing here.
                        //
                        pfnRunOnceExProcess(NULL, NULL, NULL, 0);

                        Res = 1;
                    }
                    FreeLibrary(hLib);
                }
            }
            return Res;
        }
        else if (lstrcmpi(lpCmdLine, TEXT("Run6432")) == 0)
        {
            if (IsOS(OS_WOW6432))
            {
                // this means that we have to process the 32-bit Run keys for wow64
                Res =  Cabinet_EnumRegApps(HKEY_LOCAL_MACHINE,
                                           REGSTR_PATH_RUN,
                                           RRA_NOUI,
                                           ExecuteRegAppEnumProc,
                                           0);
            }
            return Res;
        }

        switch(*lpCmdLine)
        {
            case TEXT('r'):
                Res|=CMD_DO_CHRIS;
                break;
            case TEXT('b'):
                Res|=CMD_DO_REBOOT;
                break;
            case TEXT('s'):
                Res|=CMD_DO_RESTART;
                break;
        }
        lpCmdLine++;
    }
    return Res;
}

/****************************************************************************

        FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

        PURPOSE: calls initialization function, processes message loop

****************************************************************************/
int g_iState=0;
int __stdcall WinMainT(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPTSTR lpCmdLine,
        int nCmdShow)
{
    if (!hPrevInstance)
    {       // Other instances of app running?
        if (!InitApplication(hInstance))
        { // Initialize shared things
             return (FALSE);     // Exits if unable to initialize
        }
    }

    // see if we have a commnand line switch - in a VERY bad way.
    g_iState = ParseCmdLine(GetCommandLine());
    if(g_iState & CMD_DO_CHRIS )
    {
        // Go do chris's runonce stuff.
        if (!InitROInstance(hInstance, nCmdShow))
            return (FALSE);
        return TRUE;
    }
    else
    {
        /* Perform initializations that apply to a specific instance */
        if (!InitInstance(hInstance, nCmdShow))
            return (FALSE);
    }
    return (FALSE);
}


/****************************************************************************

        FUNCTION: InitApplication(HINSTANCE)


****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
//    CreateGlobals();
    return TRUE;
}


/****************************************************************************

        FUNCTION:  InitInstance(HINSTANCE, int)

****************************************************************************/

BOOL InitInstance( HINSTANCE hInstance, int nCmdShow)
{
    HWND hShell=GetShellWindow();
    g_hInst = hInstance; // Store instance handle in our global variable

    DialogBox(hInstance, MAKEINTRESOURCE(IDD_RUNONCE),NULL,dlgProcRunOnce);
    return (TRUE);              // We succeeded...
}

BOOL InitROInstance( HINSTANCE hInstance, int nCmdShow)
{
    g_hInst = hInstance; // Store instance handle in our global variable

    // Ideally this should be sufficient.
    Cabinet_EnumRegApps(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, RRA_DELETE| RRA_WAIT, ExecuteRegAppEnumProc, 0);
    return TRUE;
}

BOOL TopLeftWindow( HWND hwndChild, HWND hwndParent)
{
    return SetWindowPos(hwndChild, NULL, 32, 32, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

/****************************************************************************

        FUNCTION: CenterWindow (HWND, HWND)

        PURPOSE:  Center one window over another

        COMMENTS:

        Dialog boxes take on the screen position that they were designed at,
        which is not always appropriate. Centering the dialog over a particular
        window usually results in a better position.

****************************************************************************/

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;


    // Get the display limits
    hdc = GetDC (hwndChild);
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Get the Height and Width of the parent window
    if( !GetWindowRect (hwndParent, &rParent) )
    {
        rParent.right = wScreen;
        rParent.left  = 0;
        rParent.top = 0;
        rParent.bottom = hScreen;
    }

        wParent = rParent.right - rParent.left;
        hParent = rParent.bottom - rParent.top;

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0)
    {
        xNew = 0;
    }
    else
    if ((xNew+wChild) > wScreen)
    {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0)
    {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen)
    {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


// stolen from the CRT, used to shirink our code
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\aclbloat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       aclbloat.h
//	
//	This file contains the definition for ACLBLOAT class which controls the 
//  dialog box for aclbloat
//
//	Author		hiteshr 4th April 2001
//
//--------------------------------------------------------------------------

#ifndef _ACLBLOAT_H
#define _ACLBLOAT_H


class CACLBloat
{
private:
	LPSECURITYINFO		m_psi;
	LPSECURITYINFO2		m_psi2;
	SI_PAGE_TYPE		m_siPageType;
	SI_OBJECT_INFO*		m_psiObjectInfo;
	HDPA				m_hEntries;
	HDPA				m_hPropEntries;
	HDPA				m_hMergedEntries;
	HFONT				m_hFont;
public:
    CACLBloat(LPSECURITYINFO	psi, 
			  LPSECURITYINFO2   psi2,
			  SI_PAGE_TYPE		m_siPageType,
			  SI_OBJECT_INFO*   psiObjectInfo,
			  HDPA				hEntries,
			  HDPA				hPropEntries);

	~CACLBloat();

	BOOL DoModalDialog(HWND hParent);
	BOOL IsAclBloated();

private:

	static INT_PTR _DlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	HRESULT InitDlg( HWND hDlg );
	
	BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);

    BOOL OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);
    
	HRESULT AddAce(HDPA hEntries, 
                  PACE_HEADER pAceHeader);

	HRESULT AddAce(HDPA hEntries, PACE pAceNew);


    LPCTSTR TranslateAceIntoRights(DWORD dwMask, const GUID *pObjectType,
                                   PSI_ACCESS  pAccess, ULONG       cAccess);
    
	LPCTSTR GetItemString(LPCTSTR pszItem, LPTSTR pszBuffer, UINT ccBuffer);

    HRESULT AddAcesFromDPA(HWND hListView, HDPA hEntries);

	HRESULT MergeAces(HDPA hEntries, HDPA hPropEntries, HDPA hMergedList);

};
typedef CACLBloat *PACLBLOAT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\aclbloat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       aclbloat.h
//	
//	This file contains the implementation of ACLBLOAT class which controls the 
//  dialog box for aclbloat
//
//	Author		hiteshr 4th April 2001
//
//--------------------------------------------------------------------------

#include "aclpriv.h"


//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::CACLBloat
//
//  Synopsis:   Constructor
//
//
//  History:    04-April 2001 hiteshr Created
//
//---------------------------------------------------------------------------

CACLBloat::CACLBloat(LPSECURITYINFO	psi, 
					 LPSECURITYINFO2 psi2,
					 SI_PAGE_TYPE    siPageType,
					 SI_OBJECT_INFO* psiObjectInfo,
					 HDPA hEntries,
					 HDPA hPropEntries):m_psi(psi),
										m_psi2(psi2),
										m_siPageType(siPageType),
										m_psiObjectInfo(psiObjectInfo),
										m_hEntries(hEntries),
										m_hPropEntries(hPropEntries),
										m_hMergedEntries(NULL),
										m_hFont(NULL)
{
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::CACLBloat");
	if(m_psi)
		m_psi->AddRef();
	if(m_psi2)
		m_psi2->AddRef();
}

CACLBloat::~CACLBloat()
{
	if(m_psi)
		m_psi->Release();
	if(m_psi2)
		m_psi2->Release();

	if(m_hMergedEntries)
	{
		UINT cItems = DPA_GetPtrCount(m_hMergedEntries);
		for(UINT iItems = 0; iItems < cItems; ++iItems)
		{
			delete (PACE)DPA_FastGetPtr(m_hMergedEntries, iItems);
		}
		DPA_Destroy(m_hMergedEntries);
	}

	if(m_hFont)
		DeleteObject(m_hFont);
}
//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::IsAclBloated
//
//  Synopsis:   ACL is bloated if number of entries which inherits to child objects
//				is more than 8
//
//
//  History:    04-April 2001 hiteshr Created
//
//---------------------------------------------------------------------------
BOOL
CACLBloat::IsAclBloated()
{
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::IsAclBloated");
	
	if(!m_hMergedEntries)
	{
		m_hMergedEntries = DPA_Create(4);
		if(!m_hMergedEntries)
			return FALSE;
	}

	if(SUCCEEDED(MergeAces(m_hEntries, m_hPropEntries, m_hMergedEntries)))
	{
		int cItems = DPA_GetPtrCount(m_hMergedEntries);
		if(cItems > ACL_BLOAT_LIMIT)
			return TRUE;
	}
	return FALSE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::DoModalDialog
//
//  Synopsis:   Creates modal dialogbox
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//
//  Returns:    Dialog's return code
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------

BOOL
CACLBloat::DoModalDialog(HWND hwndParent)
{
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::CACLBloat");
    
	INT_PTR iResult = DialogBoxParam(::hModule,
                                     MAKEINTRESOURCE(IDD_ACLBLOAT),
                                     hwndParent,
                                     CACLBloat::_DlgProc,
			                         (LPARAM) this);
    return static_cast<BOOL>(iResult);
}


//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::_DlgProc
//
//  Synopsis:   Dialog box callback
//
//  Returns:    Dialog's return code
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
INT_PTR CALLBACK
CACLBloat::_DlgProc(HWND hDlg,
					UINT uMsg,
					WPARAM wParam,
					LPARAM lParam)
{
    BOOL bReturn = TRUE;    
	CACLBloat *pThis = (CACLBloat *)GetWindowLongPtr(hDlg, DWLP_USER);
    if (!pThis && uMsg != WM_INITDIALOG)
    {
        return FALSE;
    }

    switch (uMsg)
    {
		case WM_INITDIALOG:
			pThis = (CACLBloat*) lParam;
			ASSERT(pThis);
			SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pThis);
			pThis->InitDlg(hDlg);
			break;

		case WM_COMMAND:
			bReturn = pThis->OnCommand(hDlg, wParam, lParam);
			break;

		case WM_NOTIFY:
			bReturn = pThis->OnNotify(hDlg, wParam, lParam);
			break;


		default:
			bReturn = FALSE;
			break;
    }
    
	return bReturn;
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::InitDlg
//
//  Synopsis:   Initialize the ACL bloat dialog box
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT 
CACLBloat::InitDlg( HWND hDlg )
{    
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::CACLBloat");

	HRESULT hr = S_OK;
    
	HCURSOR     hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));


	//
    // Set up the listview control
    //		
	
	HWND        hListView = GetDlgItem( hDlg, IDC_ACEL_BLOAT );
	//
    // Set extended LV style for whole line selection with InfoTips
	//
    ListView_SetExtendedListViewStyleEx(hListView,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);
	//
    // Add appropriate columns
    //
	RECT        rc;
    GetClientRect(hListView, &rc);	

    LV_COLUMN col;    
    col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.iSubItem = 0;
    col.cx = rc.right;
    ListView_InsertColumn(hListView, 0, &col);

	//
	//Add the aces to listview
	//
	hr = AddAcesFromDPA(hListView, m_hMergedEntries);
	if(FAILED(hr))
		return hr;

	//
	//Add a warning icon
	//
	// add the warning icon			
	HICON hWarn = LoadIcon(NULL, IDI_WARNING);
	SendDlgItemMessage(hDlg,  // dialog box window handle 
					   IDC_BLOAT_WARN_ICON,              // icon identifier 
					   STM_SETIMAGE,          // message to send 
					   (WPARAM) IMAGE_ICON,   // image type 
					   (LPARAM) hWarn); // icon handle 


	//
	//Set the title of dialog box
	//
    LPTSTR pszCaption = NULL;
    if(FormatStringID(&pszCaption,
					 ::hModule,
					  m_siPageType == SI_PAGE_AUDIT ? IDS_ACEE_AUDIT_TITLE : IDS_ACEE_PERM_TITLE,
					  m_psiObjectInfo->pszObjectName))
	{
		SetWindowText(hDlg, pszCaption);
		LocalFreeString(&pszCaption);
	}

	//
	//Set the warning message
	//
	UINT cItem = DPA_GetPtrCount(m_hMergedEntries);
	WCHAR buffer[34];
	_itow(cItem,buffer,10);
	if(FormatStringID(&pszCaption,
					  ::hModule,
					   m_siPageType == SI_PAGE_AUDIT ? IDS_BLOAT_AUDIT_WARN : IDS_BLOAT_PERM_WARN,
					   buffer))
	{
		SetDlgItemText(hDlg, IDC_BLOAT_LV_STATIC, pszCaption);
		LocalFreeString(&pszCaption);
	}

	//
	//Set the line 1
	//
	WCHAR szBuffer[1024];
	if(LoadString(::hModule, 
			   m_siPageType == SI_PAGE_AUDIT ? IDS_BLOAT_AUDIT_LINE1: IDS_BLOAT_PERM_LINE1,
			   szBuffer, 
			   1024))
		SetDlgItemText(hDlg,IDC_BLOAT_LINE1_STATIC, szBuffer);

	//
	//Set the line 2
	//
	if(LoadString(::hModule, 
			   m_siPageType == SI_PAGE_AUDIT ? IDS_BLOAT_AUDIT_LINE2: IDS_BLOAT_PERM_LINE2,
			   szBuffer, 
			   1024))
		SetDlgItemText(hDlg,IDC_BLOAT_LINE2_STATIC, szBuffer);

	//
	//make warning bold
	//
	MakeBold(GetDlgItem(hDlg,IDC_ACLB_WARNING), &m_hFont);

	SetCursor(hcur);
	
	return hr;
}

BOOL 
CACLBloat::OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	LPNMHDR pnmh = (LPNMHDR)lParam;
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)lParam;
    // Set default return value
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

    switch (pnmh->code)
    {

#define lvi (((NMLVDISPINFO*)lParam)->item)
		case LVN_GETDISPINFO:
		{
			PACE pAce = (PACE)lvi.lParam;
            if ((lvi.mask & LVIF_TEXT) && pAce)
            {
				if (0 == lvi.iSubItem)
                {
					lvi.pszText = pAce->GetAccessType();
				}
			}
		}
        break;
#undef lvi

	}

	return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::MergeAces
//
//  Synopsis:   Merges the aces from Object and Property Pages in to single
//				List
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------

HRESULT 
CACLBloat::MergeAces(HDPA hEntries, HDPA hPropEntries, HDPA hMergedList)
{
	
	if(!hMergedList || (!hEntries && !hPropEntries))
		return E_POINTER;

	
	HRESULT hr = S_OK;
	if(hEntries)
	{
		UINT cItems = DPA_GetPtrCount(hEntries);
		for(UINT iItems = 0; iItems < cItems; ++iItems)
		{
			hr = AddAce(hMergedList,
					   (PACE_HEADER)DPA_FastGetPtr(hEntries, iItems));
			if(FAILED(hr))
				return hr;
		}
	}

	if(hPropEntries)
	{
		UINT cItems = DPA_GetPtrCount(hPropEntries);
		for(UINT iItems = 0; iItems < cItems; ++iItems)
		{
			hr = AddAce(hMergedList,
					   (PACE_HEADER)DPA_FastGetPtr(hPropEntries, iItems));
			if(FAILED(hr))
				return hr;
		}
	}
	return S_OK;
}						   

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::AddAce
//
//  Synopsis:   Converts AceHeader to ACLUI Ace structure 
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT
CACLBloat::AddAce(HDPA hEntries, 
                  PACE_HEADER pAceHeader)
{
	//
	//This Ace doesn't propogate to child objects,
	//so we don't show this.
	//
	if(!(pAceHeader->AceFlags  & CONTAINER_INHERIT_ACE))
		return S_OK;

    PACE pAce = new CAce(pAceHeader);
    if (pAce)
    {
        return AddAce(hEntries, pAce);
    }
    else
		return E_OUTOFMEMORY;
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::AddAce
//
//  Synopsis:   Add an Ace to list. First it tries to merge it with existing 
//				aces in the list.
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT 
CACLBloat::AddAce(HDPA hEntries, 
				  PACE pAceNew)
{
	TraceEnter(TRACE_ACLBLOAT, "CACLBloat::AddAce");
    TraceAssert(hEntries != NULL);
	TraceAssert(pAceNew != NULL);
    
    if (pAceNew == NULL)
        return E_POINTER;

    m_psi->MapGeneric(&pAceNew->ObjectType, &pAceNew->AceFlags, &pAceNew->Mask);

    //
    // Try to merge the new ACE with an existing entry in the list.
    //
    int cItems = DPA_GetPtrCount(hEntries);
    for( int iItems = 0; iItems < cItems; ++iItems)
    {
        PACE pAceCompare = (PACE)DPA_FastGetPtr(hEntries, iItems);

        if (pAceCompare != NULL)
        {
            switch (pAceNew->Merge(pAceCompare))
            {
            case MERGE_MODIFIED_FLAGS:
            case MERGE_MODIFIED_MASK:
                // The ACEs were merged into pAceNew.
            case MERGE_OK_1:
                //
                // The new ACE implies the existing ACE, so the existing
                // ACE can be removed.
                //
                // First copy the name so we don't have to look
                // it up again.  (Don't copy the other strings
                // since they may be different.)
                //
                // Then keep looking.  Maybe we can remove some more entries
                // before adding the new one.
                //
                DPA_DeletePtr(hEntries, iItems);
				delete pAceCompare;
                --cItems;
				--iItems;
                break;

            case MERGE_OK_2:
                //
                // The existing ACE implies the new ACE, so we don't
                // need to do anything here.
                //
                delete pAceNew;
                return S_OK;
                break;
            }
        }
    }

	DPA_AppendPtr(hEntries, pAceNew);
	return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::GetItemString
//
//  Synopsis:  Gets a display name for the item.
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
LPCTSTR
CACLBloat::GetItemString(LPCTSTR pszItem,
						 LPTSTR pszBuffer,
                         UINT ccBuffer)
{
    TraceEnter(TRACE_ACELIST, "CACLBloat::GetItemString");

    if (pszItem == NULL)
    {
        LoadString(::hModule, IDS_SPECIAL, pszBuffer, ccBuffer);
        pszItem = pszBuffer;
    }
    else if (IS_INTRESOURCE(pszItem))
    {
        if (LoadString(m_psiObjectInfo->hInstance,
                       (UINT)((ULONG_PTR)pszItem),
                       pszBuffer,
                       ccBuffer) == 0)
        {
            LoadString(::hModule, IDS_SPECIAL, pszBuffer, ccBuffer);
        }
        pszItem = pszBuffer;
    }

    TraceLeaveValue(pszItem);
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::TranslateAceIntoRights
//
//  Synopsis:  Converts Aces Mask in to a string taking into account
//			   the Object Guid.
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
LPCTSTR
CACLBloat::TranslateAceIntoRights(DWORD dwMask,
                                  const GUID *pObjectType,
							      PSI_ACCESS  pAccess,
								  ULONG       cAccess)
{
    TraceEnter(TRACE_ACELIST, "CACLBloat::TranslateAceIntoRights");
    TraceAssert(pObjectType != NULL);
	if(!pAccess || !cAccess)
		return NULL;
	

	LPCTSTR     pszName = NULL;
    if (pAccess && cAccess)
    {
		//
        // Look for a name for the mask
		//
        for (UINT iItem = 0; iItem < cAccess; iItem++)
        {
            if ( dwMask == pAccess[iItem].mask &&
                 IsSameGUID(pObjectType, pAccess[iItem].pguid) )
            {
                pszName = pAccess[iItem].pszName;
                break;
            }
        }
    }

    TraceLeaveValue(pszName);
}

//+--------------------------------------------------------------------------
//
//  Member:     CACLBloat::AddAcesFromDPA
//
//  Synopsis:  Add ace from list to ListView control.
//
//
//  History:    04-April-2001 hiteshr Created
//
//---------------------------------------------------------------------------
HRESULT
CACLBloat::AddAcesFromDPA(HWND hListView, HDPA hEntries)
{
	ULONG iDefaultAccess = 0;
	PSI_ACCESS  pAccess = NULL;
    ULONG       cAccess = 0;
	HRESULT hr = S_OK;

	if(!hEntries)
		return E_POINTER;

	//
	//Get the count of items
	// 
	int cItems = DPA_GetPtrCount(hEntries);
	GUID* pGUID = NULL;

	PACE pAce = (PACE)DPA_FastGetPtr(hEntries, 0);
	if(pAce)
	{
		//
		//Get the AccessRight array for the guid
		//
		hr = m_psi->GetAccessRights(&pAce->InheritedObjectType, 
									SI_ADVANCED|SI_EDIT_EFFECTIVE, 
									&pAccess,
									&cAccess, 
									&iDefaultAccess);

		if(FAILED(hr))
			return hr;
		pGUID = &pAce->InheritedObjectType;
	}

    for( int iItem = 0; iItem < cItems; ++iItem)
    {
		pAce = (PACE)DPA_FastGetPtr(hEntries, iItem);
		if(pAce)
		{
			if(!IsSameGUID(pGUID, &pAce->InheritedObjectType))
			{
				//
				//if Guid is not same as one for which we have access right info,
				//fetch access right info for new guid
				//
				hr = m_psi->GetAccessRights(&pAce->InheritedObjectType, 
											SI_ADVANCED | SI_EDIT_EFFECTIVE, 
											&pAccess,
											&cAccess, 
											&iDefaultAccess);

				if(FAILED(hr))
					return hr;
				pGUID = &pAce->InheritedObjectType;
			}
	
			TCHAR   szBuffer[MAX_COLUMN_CHARS];
		    LPCTSTR pszRights = NULL;
		    pszRights = TranslateAceIntoRights(pAce->Mask,
											   &pAce->ObjectType,
											   pAccess,
											   cAccess);

			//
			// If this is a property ACE, give it a name like "Read property" or
			// "Write property".  Also, remember that it's a property ACE so we
			// can show the Property page first when editing this ACE.
			//
			// This is a bit slimy, since it assumes DS property access bits are
			// the only ones that will ever be used on the properties page.
			//
			if ((m_psiObjectInfo->dwFlags & SI_EDIT_PROPERTIES) &&
				(pAce->Flags & ACE_OBJECT_TYPE_PRESENT) &&
				(pAce->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)) &&
				!(pAce->Mask & ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP)))
			{
				pAce->SetPropertyAce(TRUE);

				if (pszRights == NULL)
				{
					UINT idString = 0;

					switch (pAce->Mask & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP))
					{
					case ACTRL_DS_READ_PROP:
						idString = IDS_READ_PROP;
						break;

					case ACTRL_DS_WRITE_PROP:
						idString = IDS_WRITE_PROP;
						break;

					case (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP):
						idString = IDS_READ_WRITE_PROP;
						break;
					}

					if (idString)
					{
						LoadString(::hModule, idString, szBuffer, ARRAYSIZE(szBuffer));
						pszRights = szBuffer;
					}
				}
			}

			pszRights = GetItemString(pszRights, szBuffer, ARRAYSIZE(szBuffer));
			pAce->SetAccessType(pszRights);
		    
			LV_ITEM lvi;
			lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
			lvi.state = 0;
			lvi.stateMask = LVIS_CUT;
			lvi.iItem = iItem;
			lvi.iSubItem = 0;
			lvi.pszText = LPSTR_TEXTCALLBACK;
			lvi.lParam = (LPARAM)pAce;

			//
			// insert the item into the list
			//
			iItem = ListView_InsertItem(hListView, &lvi);

			if (iItem == -1)
				delete pAce;


		}
	}
	return hr;
}


BOOL
CACLBloat::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDOK:
        EndDialog(hDlg, FALSE);
        break;

    case IDCANCEL:
        EndDialog(hDlg, TRUE);
        break;

	case IDHELP:
		HtmlHelp(NULL,					
				 L"aclui.chm::/ACLUI_acl_BP.htm",
				 HH_DISPLAY_TOPIC,
				 0);
		break;
		
    default:
        fHandled = FALSE;
        break;
    }
    return fHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\chklist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chklist.cpp
//
//  This file contains the implementation of the CheckList control.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

//
// Text and Background colors
//
#define TEXT_COLOR  COLOR_WINDOWTEXT
#define BK_COLOR    COLOR_WINDOW

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    40
#define DEFAULT_CHECK_WIDTH     9
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8


//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
//

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK


TCHAR const c_szStaticClass[]   = TEXT("STATIC");
TCHAR const c_szButtonClass[]   = TEXT("BUTTON");


class CCheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_nCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;
    LONG m_cxCheckColumn;
    HWND m_hwndCheckFocus;
    LPTSTR m_pszColumnDesc[MAX_CHECK_COLUMNS];

    int m_cWheelDelta;
    static UINT g_ucScrollLines;

private:
    CCheckList(HWND hWnd, LPCREATESTRUCT lpcs);
    ~CCheckList(void);

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgMouseWheel(HWND hWnd, WORD fwFlags, int zDelta);
    void MsgButtonDown(HWND hWnd, WPARAM fwFlags, int xPos, int yPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);
    void MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd);
    void SetTopIndex(HWND hWnd, LONG nIndex)
    { m_cWheelDelta = 0; MsgVScroll(hWnd, SB_THUMBPOSITION, nIndex * m_rcItemLabel.bottom); }
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw);
    void GetColumnDescriptions(HWND hWnd);

public:
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
};


BOOL RegisterCheckListWndClass(void)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CCheckList::WindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(BK_COLOR+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT(WC_CHECKLIST);

    return (BOOL)RegisterClass(&wc);
}


UINT CCheckList::g_ucScrollLines = (UINT)-1;


CCheckList::CCheckList(HWND hWnd, LPCREATESTRUCT lpcs)
: m_cItems(0), m_hwndCheckFocus(NULL), m_cWheelDelta(0)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::CCheckList");
    TraceAssert(hWnd != NULL);
    TraceAssert(lpcs != NULL);

    //
    // Get number of check columns
    //
    m_cSubItems = lpcs->style & CLS_CHECKMASK;

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
    rc.top = rc.bottom = 0;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_cxCheckBox = rc.left;
    m_cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.right = 10;              // bogus (unused)
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_rcItemLabel = rc;

    //
    // Get info for mouse wheel scrolling
    //
    if ((UINT)-1 == g_ucScrollLines)
    {
        g_ucScrollLines = 3; // default
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }

    TraceLeaveVoid();
}

CCheckList::~CCheckList(void)
{
    for (LONG j = 0; j < m_cSubItems; j++)
    {
        LocalFreeString(&m_pszColumnDesc[j]);
    }
}

LRESULT
CCheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgCommand");

    // Should only get notifications from visible, enabled, check boxes
    TraceAssert(GET_ITEM(idCmd) < m_cItems);
    TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
    TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));

    switch (wNotify)
    {
    case BN_CLICKED:
        {
            NM_CHECKLIST nmc;
            nmc.hdr.hwndFrom = hWnd;
            nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
            nmc.hdr.code = CLN_CLICK;
            nmc.iItem = GET_ITEM(idCmd);
            nmc.iSubItem = GET_SUBITEM(idCmd);
            nmc.dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
            if (!IsWindowEnabled(hwndCtrl))
                nmc.dwState |= CLST_DISABLED;
            nmc.dwItemData = GetWindowLongPtr(GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                              GWLP_USERDATA);
            nmc.cchTextMax = 0;
            nmc.pszText = NULL;

            SendMessage(GetParent(hWnd),
                        WM_NOTIFY,
                        nmc.hdr.idFrom,
                        (LPARAM)&nmc);
        }
        break;

    case BN_SETFOCUS:
        if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
        {
            // Remember where the focus is
            m_hwndCheckFocus = hwndCtrl;

            // Make sure the row is scrolled into view
            EnsureVisible(hWnd, GET_ITEM(idCmd));
        }
        // Always draw the focus rect
        DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
        break;

    case BN_KILLFOCUS:
        // Remove the focus rect
        m_hwndCheckFocus = NULL;
        DrawCheckFocusRect(hWnd, hwndCtrl, FALSE);
        break;
    }

    TraceLeaveValue(0);
}


void
CCheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CCheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    UINT cScrollUnitsPerLine;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    cScrollUnitsPerLine = m_rcItemLabel.bottom;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - cScrollUnitsPerLine;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + cScrollUnitsPerLine;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void
CCheckList::MsgMouseWheel(HWND hWnd, WORD fwFlags, int iWheelDelta)
{
    int cDetants;

    if ((fwFlags & (MK_SHIFT | MK_CONTROL)) || 0 == g_ucScrollLines)
        return;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgMouseWheel");

    // Update count of scroll amount
    m_cWheelDelta -= iWheelDelta;
    cDetants = m_cWheelDelta / WHEEL_DELTA;
    if (0 == cDetants)
        TraceLeaveVoid();
    m_cWheelDelta %= WHEEL_DELTA;

    if (WS_VSCROLL & GetWindowLong(hWnd, GWL_STYLE))
    {
        SCROLLINFO  si;
        UINT        cScrollUnitsPerLine;
        UINT        cLinesPerPage;
        UINT        cLinesPerDetant;

        // Get the scroll amount of one line
        cScrollUnitsPerLine = m_rcItemLabel.bottom;
        TraceAssert(cScrollUnitsPerLine > 0);

        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_PAGE | SIF_POS;
        if (!GetScrollInfo(hWnd, SB_VERT, &si))
            TraceLeaveVoid();

        // The size of a page is at least one line, and
        // leaves one line of overlap
        cLinesPerPage = (si.nPage - cScrollUnitsPerLine) / cScrollUnitsPerLine;
        cLinesPerPage = max(1, cLinesPerPage);

        // Don't scroll more than one page per detant
        cLinesPerDetant = min(cLinesPerPage, g_ucScrollLines);

        si.nPos += cDetants * cLinesPerDetant * cScrollUnitsPerLine;

        MsgVScroll(hWnd, SB_THUMBTRACK, si.nPos);
    }
    TraceLeaveVoid();
}


void
CCheckList::MsgButtonDown(HWND hWnd, WPARAM /*fwFlags*/, int /*xPos*/, int yPos)
{
    LONG nItemIndex;
    HWND hwndCheck;
    RECT rc;

    // Get position of the top visible item in client coords
    nItemIndex = GetTopIndex(hWnd);
    hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, 0));
    GetWindowRect(hwndCheck, &rc);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);

    // Find nearest item
    nItemIndex += (yPos - rc.top + m_rcItemLabel.top/2)/m_rcItemLabel.bottom;
    nItemIndex = max(0, min(nItemIndex, m_cItems - 1)); // 0 <= y < m_cItems

    // Set focus to first subitem that is enabled
    for (LONG j = 1; j <= m_cSubItems; j++)
    {
        hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, j));
        if (IsWindowEnabled(hwndCheck))
        {
            SetFocus(hwndCheck);
            break;
        }
    }
}


void
CCheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
    static BOOL bInMsgEnable = FALSE;

    if (!bInMsgEnable)
    {
        bInMsgEnable = TRUE;
        for (LONG i = 0; i < m_cItems; i++)
        {
            for (LONG j = 1; j <= m_cSubItems; j++)
            {
                EnableWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)), fEnabled);
            }
        }
        if (!fEnabled)
            EnableWindow(hWnd, TRUE);
        bInMsgEnable = FALSE;
    }
}


void
CCheckList::MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgSize");
    TraceAssert(hWnd != NULL);

    if (dwSizeType == SIZE_RESTORED)
    {
        RECT rc;
        SCROLLINFO si;

        si.cbSize = sizeof(si);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = m_cItems * m_rcItemLabel.bottom + m_rcItemLabel.top - 1;
        si.nPage = nHeight;                         // ^^^^^^^^^ extra space

        SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

        // Don't trust the width value passed in, since SetScrollInfo may
        // affect it if the scroll bar is turning on or off.
        GetClientRect(hWnd, &rc);
        nWidth = rc.right;

        // If the scrollbar is turned on, artificially bump up the width
        // by the width of the scrollbar, so the boxes don't jump to the left
        // when we have a scrollbar.
        if ((UINT)si.nMax >= si.nPage)
            nWidth += GetSystemMetrics(SM_CYHSCROLL);

        SetColumnWidth(hWnd, nWidth, m_cxCheckColumn);
    }

    TraceLeaveVoid();
}


LONG
CCheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
    HWND hwndNew;
    HWND hwndPrev;
    RECT rc;
    LONG cyOffset;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::AddItem");
    TraceAssert(hWnd != NULL);
    TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));

    // If this is the first item, get column descriptions
    if (0 == m_cItems)
        GetColumnDescriptions(hWnd);

    // Calculate the position of the new static label
    rc = m_rcItemLabel;
    cyOffset = m_cItems * m_rcItemLabel.bottom;
    OffsetRect(&rc, 0, cyOffset);

    // Create a new label control
    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                             c_szStaticClass,
                             pszLabel,
                             WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP | SS_NOPREFIX,// | WS_GROUP,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top,
                             hWnd,
                             (HMENU)IntToPtr(MAKE_LABEL_ID(m_cItems)),
                             hModule,
                             NULL);
    if (!hwndNew)
        TraceLeaveValue(-1);

    // Save item data
    SetWindowLongPtr(hwndNew, GWLP_USERDATA, lParam);

    // Set the font
    SendMessage(hwndNew,
                WM_SETFONT,
                SendMessage(GetParent(hWnd), WM_GETFONT, 0, 0),
                0);

    // Set Z-order position just after the last checkbox. This keeps
    // tab order correct.
    if (m_cItems > 0)
    {
        hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    // Create new checkboxes
    for (LONG j = 0; j < m_cSubItems; j++)
    {
        // Build window text for the control. The text is
        // hidden, but used for accessibility. (341042)
        LPCTSTR pszCheckText = pszLabel;
        LPTSTR pszT = NULL;
        if (m_pszColumnDesc[j] &&
            FormatStringID(&pszT, hModule, IDS_FMT_CHECKLABEL, pszLabel, m_pszColumnDesc[j]))
        {
            pszCheckText = pszT;
        }

        hwndPrev = hwndNew;
        hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                 c_szButtonClass,
                                 pszCheckText,
                                 WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_NOTIFY | BS_FLAT | BS_AUTOCHECKBOX,
                                 m_nCheckPos[j],
                                 rc.top,
                                 m_cxCheckBox,
                                 rc.bottom - rc.top,
                                 hWnd,
                                 (HMENU)IntToPtr(MAKE_CTRL_ID(m_cItems, j + 1)),
                                 hModule,
                                 NULL);

        LocalFreeString(&pszT);

        if (!hwndNew)
        {
            while (j >= 0)
            {
                DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
                j--;
            }

            TraceLeaveValue(-1);
        }

        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    // We now officially have a new item
    m_cItems++;

    //
    // The last thing is to calculate the scroll range
    //
    LONG nBottom = rc.bottom;
    GetClientRect(hWnd, &rc);

    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_RANGE | SIF_PAGE;
    si.nMin = 0;
    si.nMax = nBottom + m_rcItemLabel.top - 1;
    si.nPage = rc.bottom; // ^^^^^^^^^ extra space

    SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

    TraceLeaveValue(m_cItems - 1);  // return the index of the new item
}


void
CCheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
    if (hwndCtrl != NULL)
    {
        SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
        EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
    }

    TraceLeaveVoid();
}


LONG
CCheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
    LONG lState = 0;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::GetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

    if (hwndCtrl != NULL)
    {
        lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
        TraceAssert(!(lState & BST_INDETERMINATE));

        if (!IsWindowEnabled(hwndCtrl))
            lState |= CLST_DISABLED;
    }

    TraceLeaveValue(lState);
}


void
CCheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
{
    LONG j;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetColumnWidth");
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);

    m_cxCheckColumn = cxColumn;

    if (m_cSubItems > 0)
    {
        m_nCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
                                    - m_rcItemLabel.left            // right margin
                                    - (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox

        for (j = m_cSubItems - 1; j > 0; j--)
            m_nCheckPos[j-1] = m_nCheckPos[j] - cxColumn;

        //              (leftmost check pos) - (horz margin)
        m_rcItemLabel.right = m_nCheckPos[0] - m_rcItemLabel.left;
    }
    else
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

    for (LONG i = 0; i < m_cItems; i++)
    {
        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nBottom - nTop,
                   FALSE);

        for (j = 0; j < m_cSubItems; j++)
        {
            MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_nCheckPos[j],
                       nTop,
                       m_cxCheckBox,
                       nBottom - nTop,
                       FALSE);
        }

        nTop += m_rcItemLabel.bottom;
        nBottom += m_rcItemLabel.bottom;
    }

    TraceLeaveVoid();
}


void
CCheckList::ResetContent(HWND hWnd)
{
    for (LONG i = 0; i < m_cItems; i++)
        for (LONG j = 0; j <= m_cSubItems; j++)
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));

  // Hide the scroll bar
  ShowScrollBar(hWnd, SB_VERT, FALSE);
  m_cItems = 0;
}


LONG
CCheckList::GetVisibleCount(HWND hWnd)
{
    LONG nCount = 1;
    RECT rc;

    if (GetClientRect(hWnd, &rc) && m_rcItemLabel.bottom > 0)
        nCount = max(1, rc.bottom / m_rcItemLabel.bottom);

    return nCount;
}


LONG
CCheckList::GetTopIndex(HWND hWnd)
{
    LONG nIndex = 0;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
        nIndex = max(0, si.nPos / m_rcItemLabel.bottom);

    return nIndex;
}


void
CCheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG nTopIndex = GetTopIndex(hWnd);

    // Note that the top item may only be partially visible,
    // so we need to test for equality here.  Raid #208449
    if (nItemIndex <= nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
            SetTopIndex(hWnd, nItemIndex - nVisible + 1);
    }
}


void
CCheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;
    HDC hdc;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::DrawCheckFocusRect");
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(BK_COLOR));

        if (fDraw)
        {
            SetTextColor(hdc, GetSysColor(TEXT_COLOR));
            SetBkColor(hdc, GetSysColor(BK_COLOR));
            DrawFocusRect(hdc, &rcCheck);
        }

        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}


void
CCheckList::GetColumnDescriptions(HWND hWnd)
{
    //
    // Get column descriptions for accessibility
    //
    TCHAR szDescription[MAX_PATH];
    NM_CHECKLIST nmc;
    nmc.hdr.hwndFrom = hWnd;
    nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
    nmc.hdr.code = CLN_GETCOLUMNDESC;
    nmc.iItem = 0;
    nmc.dwState = 0;
    nmc.dwItemData = 0;
    nmc.cchTextMax = ARRAYSIZE(szDescription);
    nmc.pszText = szDescription;

    for (LONG j = 0; j < m_cSubItems; j++)
    {
        szDescription[0] = TEXT('\0');
        nmc.iSubItem = j+1;

        SendMessage(GetParent(hWnd),
                    WM_NOTIFY,
                    nmc.hdr.idFrom,
                    (LPARAM)&nmc);

        LocalFreeString(&m_pszColumnDesc[j]);
        if (szDescription[0])
            LocalAllocString(&m_pszColumnDesc[j], szDescription);
    }
}


LRESULT
CALLBACK
CCheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    CCheckList *pThis = (CCheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CHECKLIST, "CCheckList::WindowProc");
    TraceAssert(hWnd != NULL);

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CCheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_NCDESTROY:
        delete pThis;
        break;

    case WM_COMMAND:
        TraceAssert(pThis != NULL);
        lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_CTLCOLORSTATIC:
        TraceAssert(pThis != NULL);
        SetBkMode((HDC)wParam, TRANSPARENT);
        SetTextColor((HDC)wParam, GetSysColor(TEXT_COLOR));
        SetBkColor((HDC)wParam, GetSysColor(BK_COLOR));
        lResult = (LRESULT)GetSysColorBrush(BK_COLOR);
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL);
        pThis->MsgPaint(hWnd, (HDC)wParam);
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL);
        pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        break;

    case WM_MOUSEWHEEL:
        TraceAssert(pThis != NULL);
        pThis->MsgMouseWheel(hWnd,
                             LOWORD(wParam),
                             (int)(short)HIWORD(wParam));
        break;

    case WM_LBUTTONDOWN:
        TraceAssert(pThis != NULL);
        pThis->MsgButtonDown(hWnd,
                             wParam,
                             (int)(short)LOWORD(lParam),
                             (int)(short)HIWORD(lParam));
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL);
        pThis->MsgEnable(hWnd, (BOOL)wParam);
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL);
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_SIZE:
        TraceAssert(pThis != NULL);
        pThis->MsgSize(hWnd, (DWORD)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL);
        lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->m_cItems;
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL);
        pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL);
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        SetWindowLongPtr(GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                         GWLP_USERDATA,
                         lParam);
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        lResult = GetWindowLongPtr(GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                   GWLP_USERDATA);
        break;

    case CLM_RESETCONTENT:
        TraceAssert(pThis != NULL);
        pThis->ResetContent(hWnd);
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetVisibleCount(hWnd);
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetTopIndex(hWnd);
        break;

    case CLM_SETTOPINDEX:
        TraceAssert(pThis != NULL);
        pThis->SetTopIndex(hWnd, (LONG)wParam);
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL);
        pThis->EnsureVisible(hWnd, (LONG)wParam);
        break;

    //
    // Always refer to the chklist window for help. Don't pass
    // one of the child window handles here.
    //
    case WM_HELP:
        ((LPHELPINFO)lParam)->hItemHandle = hWnd;
        lResult = SendMessage(GetParent(hWnd), uMsg, wParam, lParam);
        break;
    case WM_CONTEXTMENU:
        lResult = SendMessage(GetParent(hWnd), uMsg, (WPARAM)hWnd, lParam);
        break;

    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.h
//
//--------------------------------------------------------------------------

#ifndef __cstrings_h
#define __cstrings_h

extern TCHAR const c_szDllName[];
extern TCHAR const c_szAcluiHelpFile[];
extern TCHAR const c_szEffPermHelpLink[];
extern TCHAR const c_szOwnerHelpLink[];
extern TCHAR const c_szAuditHelpLink[];
extern TCHAR const c_szPermHelpLink[];
#endif  // __cstrings_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\aclpriv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       aclpriv.h
//
//--------------------------------------------------------------------------

#ifndef _ACLUI_
#define _ACLUI_

#ifndef UNICODE
#error "No ANSI support yet"
#endif


extern "C"
{
    #include <nt.h>         // SE_TAKE_OWNERSHIP_PRIVILEGE, etc
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <seopaque.h>   // RtlObjectAceSid, etc.
}

#define INC_OLE2
#include <windows.h>
#include <commctrl.h>
#include "resource.h"   // resource ID's
#include "idh.h"        // help ID's

#ifndef RC_INVOKED

#include <windowsx.h>
#include <atlconv.h>    // ANSI/Unicode conversion support
#include<shellapi.h>
#include<shlapip.h>
#include <shlobj.h>
#include<shlobjp.h>

#include <shfusion.h>
#include <accctrl.h>
#include <aclui.h>
#include <comctrlp.h>   // DPA/DSA
#include <objsel.h>     // DS Object Picker
#include "lmaccess.h"
#include <htmlhelp.h>
#include <common.h>
#include "misc.h"
#include "pagebase.h"
#include "chklist.h"
#include "ace.h"
#include "perm.h"
#include "cstrings.h"
#include "sidcache.h"
#include "aclbloat.h"
// These are here for NT4 SP4 builds (comctrlp.h added these for NT5)
#ifndef DA_LAST
#define DA_LAST     (0x7FFFFFFF)
#endif
#ifndef DPA_AppendPtr
#define DPA_AppendPtr(hdpa, pitem)  DPA_InsertPtr(hdpa, DA_LAST, pitem)
#endif
#ifndef DSA_AppendItem
#define DSA_AppendItem(hdsa, pitem) DSA_InsertItem(hdsa, DA_LAST, pitem)
#endif

extern HINSTANCE hModule;
extern HINSTANCE g_hGetUserLib;
extern UINT UM_SIDLOOKUPCOMPLETE;
extern UINT g_cfDsSelectionList;
extern UINT g_cfSidInfoList;

// Magic debug flags
#define TRACE_PERMPAGE      0x00000001
#define TRACE_PRINCIPAL     0x00000002
#define TRACE_SI            0x00000004
#define TRACE_PERMSET       0x00000008
#define TRACE_ACELIST       0x00000010
#define TRACE_ACEEDIT       0x00000020
#define TRACE_OWNER         0x00000040
#define TRACE_MISC          0x00000080
#define TRACE_CHECKLIST     0x00000100
#define TRACE_SIDCACHE      0x00000200
#define TRACE_EFFPERM       0x00000400
#define TRACE_ACLBLOAT		0x00000800
#define TRACE_ALWAYS        0xffffffff          // use with caution

#define MAX_COLUMN_CHARS    100

#define COLUMN_ALLOW    1
#define COLUMN_DENY     2

#define ACE_INHERIT_ALL     (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

#define SI_ACCESS_CUSTOM   0x10000000  //This flag is used is SI_ACCESS to indicate
                                       //Custom checkbox which comes in first screen for 
                                       //custom permission

#define ACL_BLOAT_LIMIT 8


BOOL
ACLUIAPI
EditSecurityEx(HWND hwndOwner,
               LPSECURITYINFO psi,
               PPERMPAGE pPermPage,
               UINT nStartPage,
               BOOL &refbNoReadWriteCanWriteOwner);

BOOL
EditACEEntry(HWND hwndOwner,
             LPSECURITYINFO psi,
             PACE pAce,
             SI_PAGE_TYPE siType,
             LPCTSTR pszObjectName,
             BOOL bReadOnly,
             DWORD *pdwResult,
             HDPA *phEntries,
             HDPA *phPropertyEntries,
             UINT nStartPage = 0);

// EditACEEntry result values. Set if something was edited on the
// corresponding page, otherwise clear.
#define EAE_NEW_OBJECT_ACE      0x0001
#define EAE_NEW_PROPERTY_ACE    0x0002

LPARAM
GetSelectedItemData(HWND hList, int *pIndex);

int
ConfirmAclProtect(HWND hwndParent, BOOL bDacl);

HPROPSHEETPAGE
CreateOwnerPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo, BOOL &refbNoReadWriteCanWriteOwner);

HPROPSHEETPAGE
CreateEffectivePermPage(LPSECURITYINFO psi,SI_OBJECT_INFO *psiObjectInfo);


STDMETHODIMP
_InitCheckList(HWND           hwndList,
               LPSECURITYINFO psi,
               const GUID *   pguidObjectType,
               DWORD          dwFlags,
               HINSTANCE      hInstance,
               DWORD          dwType,
               PSI_ACCESS *   ppDefaultAccess);

void
HandleListClick(PNM_CHECKLIST pnmc, 
                SI_PAGE_TYPE siType, 
                BOOL bContainerFlags, 
                HDSA * phAllowUncheckedAccess= NULL,
                HDSA * phDenyUncheckedAccess= NULL,
                BOOL bCustomPresent = FALSE);

UINT
GetAcesFromCheckList(HWND hChkList,
                     PSID pSid,
                     BOOL fPerm,
                     BOOL fAceFlagsProvided,
                     UCHAR uAceFlagsNew,
                     const GUID *pInheritGUID,
                     HDPA hEntries);

typedef struct _col_for_listview
{
    UINT    idText;     // Resource Id for column name
    UINT    iPercent;   // Percent of width
} COL_FOR_LV;


#endif // RC_INVOKED
#endif // _ACLUI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\chklist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       chklist.h
//
//  Definitions and protytypes for the checklist pseudo-control.
//
//--------------------------------------------------------------------------

#ifndef _CHKLIST_H_
#define _CHKLIST_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// CheckList window class name
//
#define WC_CHECKLIST        "CHECKLIST_ACLUI"

BOOL RegisterCheckListWndClass(void);


//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)

//
// CheckList window styles
//
#define CLS_1CHECK          0x0001
#define CLS_2CHECK          0x0002
//#define CLS_3CHECK          0x0003
//#define CLS_4CHECK          0x0004
#define CLS_CHECKMASK       0x000f

//
// CheckList messages
//
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible

//
// CheckList notification messages
//
#define CLN_FIRST           (1000U)         // commctrl use negative values
#define CLN_LAST            (1049U)
#define CLN_CLICK           (CLN_FIRST+0)   // lparam = PNM_CHECKLIST
#define CLN_GETCOLUMNDESC   (CLN_FIRST+1)

typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;
    DWORD_PTR dwItemData;
    ULONG cchTextMax;
    LPTSTR pszText;
} NM_CHECKLIST, *PNM_CHECKLIST;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _CHKLIST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\dll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dll.cpp
//
//  Core entry points for the DLL
//
//--------------------------------------------------------------------------

#include "aclpriv.h"


/*----------------------------------------------------------------------------
/ Globals
/----------------------------------------------------------------------------*/

HINSTANCE hModule = NULL;
HINSTANCE g_hGetUserLib = NULL;

UINT UM_SIDLOOKUPCOMPLETE = 0;
UINT g_cfDsSelectionList = 0;
UINT g_cfSidInfoList = 0;


/*-----------------------------------------------------------------------------
/ DllMain
/ -------
/   Main entry point.  We are passed reason codes and assored other
/   information when loaded or closed down.
/
/ In:
/   hInstance = our instance handle
/   dwReason = reason code
/   pReserved = depends on the reason code.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDAPI_(BOOL)
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*pReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        hModule = hInstance;
        DebugProcessAttach();
        TraceSetMaskFromRegKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AclUI"));
#ifndef DEBUG
        DisableThreadLibraryCalls(hInstance);
#endif
        SHFusionInitializeFromModuleID(hInstance, SHFUSION_DEFAULT_RESOURCE_ID);
        RegisterCheckListWndClass();
		LinkWindow_RegisterClass();

        UM_SIDLOOKUPCOMPLETE = RegisterWindowMessage(TEXT("ACLUI SID Lookup Complete"));
        g_cfDsSelectionList = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
        g_cfSidInfoList = RegisterClipboardFormat(CFSTR_ACLUI_SID_INFO_LIST);
    	break;

    case DLL_PROCESS_DETACH:
        FreeSidCache();
        if (g_hGetUserLib)
            FreeLibrary(g_hGetUserLib);
        SHFusionUninitialize();
		LinkWindow_UnregisterClass(hInstance);
        DebugProcessDetach();
        break;

    case DLL_THREAD_DETACH:
        DebugThreadDetach();
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.cpp
//
//  Constant strings used by this module
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

TCHAR const c_szDllName[]           = TEXT("aclui.dll");
TCHAR const c_szAcluiHelpFile[]     = TEXT("aclui.hlp");
TCHAR const c_szEffPermHelpLink[]   = TEXT("aclui.chm::/acl_effective_perm.htm");
TCHAR const c_szOwnerHelpLink[]   = TEXT("aclui.chm::/sag_SEconceptsUnOwn.htm");
TCHAR const c_szAuditHelpLink[]   = TEXT("audit.chm::/sag_SEconceptsAudit.htm");
TCHAR const c_szPermHelpLink[] = TEXT("aclui.chm::/acl_topnode.htm");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\idh.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       idh.h
//
//--------------------------------------------------------------------------

#define IDH_NOHELP                      ((DWORD)-1)

#define IDH_SPP_PRINCIPALS              1000
#define IDH_SPP_ADD                     1001
#define IDH_SPP_REMOVE                  1002
#define IDH_SPP_RESET                   1003
#define IDH_SPP_PERMS                   1004
#define IDH_SPP_ADVANCED                1005
#define IDH_SPP_PROTECT                 1007

#define IDH_ACEL_PERM_DETAILS           2001
#define IDH_ACEL_PERM_ADD               2002
#define IDH_ACEL_PERM_REMOVE            2003
#define IDH_ACEL_PERM_EDIT              2004
#define IDH_ACEL_PERM_RESET             2005
#define IDH_ACEL_PERM_PROTECT           2006
#define IDH_ACEL_PERM_RESET_ACL_TREE    2008

#define IDH_ACEL_AUDIT_DETAILS          3001
#define IDH_ACEL_AUDIT_ADD              3002
#define IDH_ACEL_AUDIT_REMOVE           3003
#define IDH_ACEL_AUDIT_EDIT             3004
#define IDH_ACEL_AUDIT_RESET            3005
#define IDH_ACEL_AUDIT_PROTECT          3006
#define IDH_ACEL_AUDIT_RESET_ACL_TREE   3008

#define IDH_ACEE_PERM_NAMEBUTTON        4000
#define IDH_ACEE_PERM_NAME              4001
#define IDH_ACEE_PERM_INHERITTYPE       4002
#define IDH_ACEE_PERM_INHERITIMMEDIATE  4003
#define IDH_ACEE_PERM_LIST              4004
#define IDH_ACEE_PERM_CLEAR             4009

#define IDH_ACEE_AUDIT_NAMEBUTTON       4100
#define IDH_ACEE_AUDIT_NAME             4101
#define IDH_ACEE_AUDIT_INHERITTYPE      4102
#define IDH_ACEE_AUDIT_INHERITIMMEDIATE 4103
#define IDH_ACEE_AUDIT_LIST             4104
#define IDH_ACEE_AUDIT_CLEAR            4109

#define IDH_OWN_CURRENTOWNER            5001
#define IDH_OWN_OWNERLIST               5002
#define IDH_OWN_RESET                   5003
#define IDH_OWN_RECURSE                 5004


#define IDH_EFF_NAME                    6001
#define IDH_EFF_SELECT                  6002
#define IDH_EFF_PERM_LIST               6003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\effperm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       owner.cpp
//
//  This file contains the implementation of the Owner page.
//
//--------------------------------------------------------------------------
#include "aclpriv.h"
#include <initguid.h> // needed to get the GUIDs defined in oleacc.h
#include <oleacc.h> // contains IAccProp* definitions


//Context Help IDs
const static DWORD aEffHelpIDs[] =
{
    IDC_EFF_NAME_STATIC,        IDH_EFF_NAME,
    IDC_EFF_NAME,               IDH_EFF_NAME,
    IDC_EFF_SELECT,             IDH_EFF_SELECT,
    IDC_EFF_PERMISSION_STATIC,  IDH_EFF_PERM_LIST,
    IDC_EFF_PERM_LIST,          IDH_EFF_PERM_LIST,
	IDC_EFF_ERROR,			IDH_EFF_PERM_LIST,
    IDC_EFF_STATIC,             -1,
    0, 0
};


LPCWSTR g_ListStateMap = 
    L"A:0"
    L":0:0x50" // checked, disabled - STATE_SYSTEM_READONLY | STATE_SYSTEM_CHECKED
    L":1:0x40" // disabled - STATE_SYSTEM_READONLY
    L":";


LPCWSTR g_ListRoleMap = 
    L"A:0"
    L":0:0x2C" // checkbox - ROLE_SYSTEM_CHECKBUTTON (ie. checkbox)
    L":1:0x2C"
    L":";


int LV_ADDITEM(HWND hwndList, 
               LPCTSTR pszName, 
               int index, 
               PSI_ACCESS pAccess, 
               BOOL bChecked)
{
    LVITEM lvItem;    
    TraceAssert(pAccess != NULL);
    TraceAssert(pszName != NULL);

    lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvItem.iItem = index;
    lvItem.iSubItem = 0;
    lvItem.pszText = (LPTSTR)pszName;
    lvItem.lParam = (LPARAM)pAccess;
    lvItem.iImage = bChecked ? 0 : 1;

    // Insert item into list
    index = ListView_InsertItem(hwndList, &lvItem);
    ListView_SetCheckState(hwndList,index,bChecked);
    
    return index;
}

typedef struct _EffCacheItem
{    
    POBJECT_TYPE_LIST pObjectTypeList;
    ULONG cObjectTypeListLength;
    PACCESS_MASK pGrantedAccessList;
    PSID pSid;
}EFFCACHEITEM,*PEFFCACHEITEM;


//This Function checks is pAccess is granted.
BOOL IsChecked( PSI_ACCESS pAccess,
                PEFFCACHEITEM pCacheItem)
{
    TraceEnter(TRACE_EFFPERM, "IsChecked");
    TraceAssert(pCacheItem != NULL);
    TraceAssert(pAccess != NULL);

    POBJECT_TYPE_LIST pObjectTypeList = pCacheItem->pObjectTypeList;
    ULONG cObjectTypeListLength = pCacheItem->cObjectTypeListLength;
    PACCESS_MASK pGrantedAccessList = pCacheItem->pGrantedAccessList;

    //0th Grant is for full object. 
    if( (pAccess->mask & pGrantedAccessList[0]) == pAccess->mask )
        return TRUE;

    BOOL bGuidNULL = pAccess->pguid ?IsEqualGUID(*(pAccess->pguid), GUID_NULL): TRUE;
    LPGUID pguid;        

    for( UINT i = 1; i < cObjectTypeListLength; ++i )
    {
        pguid = pObjectTypeList[i].ObjectType;
        if( pguid == NULL ||
            IsEqualGUID(*pguid, GUID_NULL) ||
            (!bGuidNULL && IsEqualGUID(*pguid,*(pAccess->pguid))) )
        {
            if( (pAccess->mask & pGrantedAccessList[i]) == pAccess->mask )
                return TRUE;
        }
    }
    return FALSE;
}



class CEffPage: public CSecurityPage
{
public:
    CEffPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo);
    virtual ~CEffPage();

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL InitDlg(HWND hDlg);
    void OnSelect(HWND hDlg);
    void InitListBox(HWND hDlg);
    HRESULT GetEffectivePerm(PSID pSid, PEFFCACHEITEM *ppCacheItem);
    PSID GetSelectedSID(){ return m_pSid; }

private:
    PSID m_pSid;    //Sid of the security principal for which permissions are displayed
   
    PSI_ACCESS m_pAccess;
    ULONG m_cAccesses;
};


HPROPSHEETPAGE
CreateEffectivePermPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo)
{
    HPROPSHEETPAGE hPage = NULL;
    CEffPage *pPage;
    
    TraceEnter(TRACE_EFFPERM, "CreateEffectivePermPage");
    TraceAssert(psi!=NULL);
    TraceAssert(psiObjectInfo);

    pPage = new CEffPage(psi, psiObjectInfo);

    if (pPage)
    {
        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_EFFECTIVE_PERM_PAGE));

        if (!hPage)
            delete pPage;
    }

    TraceLeaveValue(hPage);
}


CEffPage::CEffPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo)
: CSecurityPage(psi, SI_PAGE_OWNER) , m_pSid(NULL),
  m_pAccess(NULL), m_cAccesses(0)
{
    // Lookup known SIDs asynchronously so the dialog
    // will initialize faster
}

CEffPage::~CEffPage()
{
    if (m_pSid)
        LocalFree(m_pSid);
}
BOOL 
CEffPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bResult = TRUE;
    LPPSHNOTIFY lpsn;
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;


    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_EFF_SELECT:
            OnSelect(hDlg);
            break;
        default:
            bResult = FALSE;
        }
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                            c_szAcluiHelpFile,
                            HELP_WM_HELP,
                            (DWORD_PTR)aEffHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)aEffHelpIDs);
        }
        break;
    case PSM_QUERYSIBLINGS:
        if(GetSelectedSID())
            InitListBox(hDlg);                
        break;

	case WM_NOTIFY:
		if(wParam == IDC_EFF_STATIC)
		{
		    switch (((NMHDR FAR*)lParam)->code)
			{
				//
				//Show the help popup for Examples
				//
				case NM_CLICK:
				case NM_RETURN:
				{
					HtmlHelp(hDlg,
							 c_szEffPermHelpLink,
							 HH_DISPLAY_TOPIC,
							 0);

					return TRUE;
				}
				break;
			}
		}
		break;
    default:
        bResult = FALSE;
    }

    return bResult;
}


BOOL
CEffPage::InitDlg( HWND hDlg )
{

    HWND hwndList;
    RECT rc;
    LV_COLUMN col;
    TCHAR szBuffer[MAX_COLUMN_CHARS];
    HRESULT hr = S_OK;
    ULONG iDefaultAccess;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_EFFPERM, "CEffPage::InitDlg");
    TraceAssert(hDlg != NULL);
    TraceAssert(m_psi != NULL);
    TraceAssert(m_pei != NULL);

    hwndList = GetDlgItem(hDlg, IDC_EFF_PERM_LIST);

    //
    // Create & set the image list for the listview.  If there is a
    // problem CreateSidImageList will return NULL which won't hurt
    // anything. In that case we'll just continue without an image list.
    //
    ListView_SetImageList(hwndList,
                          LoadImageList(::hModule, MAKEINTRESOURCE(IDB_CHECKBOX)),
                          LVSIL_SMALL);


    // Set extended LV style for whole line selection with InfoTips
    ListView_SetExtendedListViewStyleEx(hwndList,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP, 
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);


	IAccPropServices * pAccPropSvc = NULL;
	hr = CoCreateInstance( CLSID_AccPropServices, NULL, CLSCTX_SERVER, IID_IAccPropServices, (void **) & pAccPropSvc );
	if( hr == S_OK && pAccPropSvc )
	{
		// Don't have to check HRESULT here, since if they fail we just ignore anyway,
		// but may want to log it while debugging.
		pAccPropSvc->SetHwndPropStr(hwndList, OBJID_CLIENT, 0, PROPID_ACC_ROLEMAP, g_ListRoleMap );
		pAccPropSvc->SetHwndPropStr(hwndList, OBJID_CLIENT, 0, PROPID_ACC_STATEMAP, g_ListStateMap );
		pAccPropSvc->Release();
	}



    //
    // Add appropriate listview columns
    //
    GetClientRect(hwndList, &rc);

    LoadString(::hModule, IDS_PERMISSIONS, szBuffer, ARRAYSIZE(szBuffer));
    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.pszText = szBuffer;
    col.iSubItem = 0;
    col.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(hwndList, 0, &col);


    //Get the access Rights
    hr = m_psi->GetAccessRights(&GUID_NULL,
                                SI_ADVANCED|SI_EDIT_EFFECTIVE,
                                &m_pAccess,
                                &m_cAccesses,
                                &iDefaultAccess);
    FailGracefully(hr, "GetAccessRights Failed");    
    //Initialize the List box
    InitListBox(hDlg);

exit_gracefully:


    SetCursor(hcur);

    if (FAILED(hr))
    {
        HWND hwnd;
        // Hide and disable everything
        for (hwnd = GetWindow(hDlg, GW_CHILD);
             hwnd != NULL;
             hwnd = GetWindow(hwnd, GW_HWNDNEXT))
        {
            ShowWindow(hwnd, SW_HIDE);
            EnableWindow(hwnd, FALSE);
        }

        // Enable and show the "No Security" message
        hwnd = GetDlgItem(hDlg, IDC_NO_EFFECTIVE);
        EnableWindow(hwnd, TRUE);
        ShowWindow(hwnd, SW_SHOW);
    }

    TraceLeaveValue(TRUE);
}

VOID
CEffPage::OnSelect(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;
    LPEFFECTIVEPERMISSION pei;
    HRESULT hr = S_OK;

    TraceEnter(TRACE_EFFPERM, "CEffPage::OnSelect");

    if (S_OK == GetUserGroup(hDlg, FALSE, &pUserList))
    {
        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        // Free up previous sid
        if (m_pSid)
            LocalFree(m_pSid);

        // Copy the new sid
        m_pSid = LocalAllocSid(pUserList->rgUsers[0].pSid);
        if (m_pSid)
        {
            SetDlgItemText(hDlg, IDC_EFF_NAME, pUserList->rgUsers[0].pszName);
        }
        LocalFree(pUserList);
        InitListBox(hDlg); 
    }    
}


VOID
CEffPage::InitListBox(HWND hDlg)
{
    HWND hwndList;
    BOOL bProperties;

    PSI_ACCESS pAccess;
    ULONG cAccesses;
    DWORD dwType;
    TCHAR szName[MAX_PATH];
    PSID pSid = NULL;
    PEFFCACHEITEM pCacheItem = NULL; 
    int index;
    TraceEnter(TRACE_EFFPERM, "CEffPage::InitListBox");
    TraceAssert( m_pAccess != NULL );
    TraceAssert(m_cAccesses != 0 );

    HRESULT hr = S_OK;
    hwndList = GetDlgItem(hDlg, IDC_EFF_PERM_LIST);

    if(!IsWindowEnabled(hwndList))
    {        
        //Hide Error Message
        HWND hwnd = GetDlgItem(hDlg, IDC_EFF_ERROR);
        EnableWindow(hwnd, FALSE);
        ShowWindow(hwnd, SW_HIDE);
        //Show List box
        EnableWindow(hwndList, TRUE);
        ShowWindow(hwndList, SW_SHOW);
    }

    //Clear all items
    ListView_DeleteAllItems(hwndList);

    pAccess = m_pAccess;
    cAccesses = m_cAccesses;
    dwType = SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY;
    
    //Get the current sid
    pSid = GetSelectedSID();
    if( pSid )
    {
        hr = GetEffectivePerm(pSid, &pCacheItem);
        FailGracefully(hr,"GetEffectivePermission Failed");
    }

    index = 0;        
    // Enumerate the permissions and add to the checklist
    ULONG i;
    for (i = 0; i < cAccesses; i++, pAccess++)
    {
        LPCTSTR pszName;

        // Only add permissions that have any of the flags specified in dwType
        if (!(pAccess->dwFlags & dwType))
            continue;

        //Don't Add Permission which have inherit only on
        if( pAccess->dwFlags & INHERIT_ONLY_ACE )
            continue;

        pszName = pAccess->pszName;
        if (IS_INTRESOURCE(pszName))
        {
            TraceAssert(m_siObjectInfo.hInstance != NULL);

            if (LoadString(m_siObjectInfo.hInstance,
                           (UINT)((ULONG_PTR)pszName),
                           szName,
                           ARRAYSIZE(szName)) == 0)
            {
                LoadString(::hModule,
                           IDS_UNKNOWN,
                           szName,
                           ARRAYSIZE(szName));
            }
            pszName = szName;
        }
        
        BOOL bChecked = FALSE;
        if(pSid)
        {
            bChecked = IsChecked( pAccess, pCacheItem );
        }
        index = LV_ADDITEM( hwndList, pszName, index, pAccess, bChecked);
        index++;
    }    
    if(index)
    {
        SelectListViewItem(hwndList, 0);
        // Redraw the list
        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
        ListView_RedrawItems(hwndList, 0, -1);
    }



exit_gracefully:
    if(pCacheItem)
    {
        if(pCacheItem->pGrantedAccessList)
            LocalFree(pCacheItem->pGrantedAccessList);
        LocalFree(pCacheItem);
    }
    if(FAILED(hr))
    {
        //Hide List box
        HWND hwnd = GetDlgItem(hDlg, IDC_EFF_PERM_LIST);
        EnableWindow(hwnd, FALSE);
        ShowWindow(hwnd, SW_HIDE);
        
        //Format Error Message To Display
        WCHAR buffer[MAX_PATH];
        LPWSTR pszCaption = NULL;
        GetWindowText(GetDlgItem(hDlg, IDC_EFF_NAME),
                      buffer, 
                      MAX_PATH-1);
        FormatStringID(&pszCaption, ::hModule, IDS_EFF_ERROR, buffer);
        
        //Show Error Message
        hwnd = GetDlgItem(hDlg, IDC_EFF_ERROR);
        EnableWindow(hwnd, TRUE);
        SetWindowText(hwnd,pszCaption);
        ShowWindow(hwnd, SW_SHOW);
        LocalFreeString(&pszCaption);
    }
    TraceLeaveVoid();
}

//Calling function frees *ppCacheItem->pGrantedAccessList
//and *ppCacheItem

HRESULT
CEffPage::GetEffectivePerm(PSID pSid,
                           PEFFCACHEITEM *ppCacheItem )
{
    PSECURITY_DESCRIPTOR pSD;
    
    HRESULT hr = S_OK;
    ULONG cItems = 0;
    PEFFCACHEITEM pCacheTemp = NULL;

    TraceEnter(TRACE_EFFPERM, "CEffPage::GetEffectivePerm");
    TraceAssert(pSid != NULL);
    TraceAssert(ppCacheItem != NULL);

    pCacheTemp = (PEFFCACHEITEM)LocalAlloc( LPTR, sizeof(EFFCACHEITEM) + GetLengthSid(pSid));
    
    if(!pCacheTemp)
        ExitGracefully(hr, E_OUTOFMEMORY, "Lcoal Alloc Failed");
    pCacheTemp->pSid = (PSID)(pCacheTemp + 1);
    CopySid(GetLengthSid(pSid), pCacheTemp->pSid, pSid);

    
    if(m_psi)
    {
        hr = m_psi->GetSecurity(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                &pSD,
                                FALSE);
        FailGracefully(hr, "GetSecurity Failed");
    }
    
    if( m_pei)
    {
        DWORD dwTemp;
        hr = m_pei->GetEffectivePermission(&(m_siObjectInfo.guidObjectType),
                                           pCacheTemp->pSid,
                                           m_siObjectInfo.pszServerName,
                                           //NULL,
                                           pSD,
                                           &(pCacheTemp->pObjectTypeList),
                                           &(pCacheTemp->cObjectTypeListLength),
                                           &(pCacheTemp->pGrantedAccessList),
                                           &dwTemp);
        if(SUCCEEDED(hr))
        {
            if(!pCacheTemp->pObjectTypeList || !pCacheTemp->pGrantedAccessList)
                hr = E_FAIL;
        }

        FailGracefully(hr, "GetEffectivePermission Failed");
        
    }
exit_gracefully:
    
    if( !SUCCEEDED(hr) )
    {
        LocalFree(pCacheTemp);
        pCacheTemp = NULL;
    }
    *ppCacheItem = pCacheTemp;

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\misc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       misc.h
//
//  Definitions and prototypes for miscellaneous stuff
//
//--------------------------------------------------------------------------

#ifndef _MISC_H_
#define _MISC_H_

typedef struct _USER_INFO
{
    PSID pSid;
    LPCTSTR pszName;
    LPCTSTR pszLogonName;
    SID_NAME_USE SidType;
} USER_INFO, *PUSER_INFO;

typedef struct _USER_LIST
{
    ULONG cUsers;
    USER_INFO rgUsers[ANYSIZE_ARRAY];
} USER_LIST, *PUSER_LIST;

PSID GetAceSid(PACE_HEADER pAce);
PSID LocalAllocSid(PSID pOriginal);
void DestroyDPA(HDPA hList);

extern "C" {
#include <ntlsa.h>
}
LSA_HANDLE GetLSAConnection(LPCTSTR pszServer, DWORD dwAccessDesired);

BOOL LookupSid(PSID pSid,
               LPCTSTR pszServer,
               LPSECURITYINFO2 psi2,
               PUSER_LIST *ppUserList);
BOOL LookupSids(HDPA hSids,
                LPCTSTR pszServer,
                LPSECURITYINFO2 psi2,
                PUSER_LIST *ppUserList);
BOOL LookupSidsAsync(HDPA hSids,
                     LPCTSTR pszServer,
                     LPSECURITYINFO2 psi2,
                     HWND hWndNotify,
                     UINT uMsgNotify,
                     PHANDLE phThread = NULL);
BOOL BuildUserDisplayName(LPTSTR *ppszDisplayName,
                          LPCTSTR pszName,
                          LPCTSTR pszLogonName = NULL);

// Indexes into the SID image list
typedef enum
{
    SID_IMAGE_UNKNOWN = 0,
    SID_IMAGE_COMPUTER,
    SID_IMAGE_GROUP,
    SID_IMAGE_LOCALGROUP,
    SID_IMAGE_USER
} SID_IMAGE_INDEX;

HIMAGELIST LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID);
SID_IMAGE_INDEX GetSidImageIndex(PSID psid, SID_NAME_USE sidType);

BOOL IsStandalone(LPCTSTR pszMachine, PBOOL pbIsDC = NULL);


BOOL IsDACLCanonical(PACL pDacl);
BOOL IsDenyACL(PACL pDacl,
               BOOL fProtected,
               DWORD dwFullControlMask,
               LPDWORD pdwWarning);


//
// Possible SIDs that can be retrieved using QuerySystemSid.
//
enum UI_SystemSid
{
    // Well-known / universal
    UI_SID_World = 0,
    UI_SID_CreatorOwner,
    UI_SID_CreatorGroup,
    UI_SID_Dialup,
    UI_SID_Network,
    UI_SID_Batch,
    UI_SID_Interactive,
    UI_SID_Service,
    UI_SID_AnonymousLogon,
    UI_SID_Proxy,
    UI_SID_EnterpriseDC,
    UI_SID_Self,
    UI_SID_AuthenticatedUser,
    UI_SID_RestrictedCode,
    UI_SID_TerminalServer,
    UI_SID_LocalSystem,
    // Aliases ("BUILTIN")
    UI_SID_Admins,
//    UI_SID_Users,
//    UI_SID_Guests,
//    UI_SID_PowerUsers,
//    UI_SID_AccountOps,
//    UI_SID_SystemOps,
//    UI_SID_PrintOps,
//    UI_SID_BackupOps,
//    UI_SID_Replicator,
//    UI_SID_RasServers,

    // Special value that gives the number of valid UI_SID_* types.
    // Don't add any new types after this value (add them before).
    UI_SID_Count,

    // This special value can be used for initializing enum UI_SystemSid
    // variables with a known unused quantity.  This value should never
    // be passed to QuerySystemSid.
    UI_SID_Invalid = -1
};
#define COUNT_SYSTEM_SID_TYPES          ((int)UI_SID_Count)
#define COUNT_WELL_KNOWN_SYSTEM_SIDS    ((int)UI_SID_Admins)

PSID QuerySystemSid(UI_SystemSid SystemSidType);

#define IsNTAuthority(pSid)             EqualPrefixSid(pSid, QuerySystemSid(UI_SID_LocalSystem))
#define IsAliasSid(pSid)                EqualPrefixSid(pSid, QuerySystemSid(UI_SID_Admins))
#define IsCreatorSid(pSid)              EqualPrefixSid(pSid, QuerySystemSid(UI_SID_CreatorOwner))
#define EqualSystemSid(pSid, uiSid)     EqualSid(pSid, QuerySystemSid(uiSid))

//
// Possible SIDs that can be retrieved using QueryTokenSid.
//
enum UI_TokenSid
{
    UI_TSID_CurrentProcessUser = 0, // Always the logged on user SID
    UI_TSID_CurrentProcessOwner,    // Generally logged on user SID, but sometimes not (e.g. Administrators)
    UI_TSID_CurrentProcessPrimaryGroup,
    UI_TSID_Count,
    UI_TSID_Invalid = -1
};
#define COUNT_TOKEN_SID_TYPES           ((int)UI_TSID_Count)

PSID QueryTokenSid(UI_TokenSid TokenSidType);


PSID GetAuthenticationID(LPCWSTR pszServer);

int CopyUnicodeString(LPTSTR pszDest, ULONG cchDest, PLSA_UNICODE_STRING pSrc);
int CopyUnicodeString(LPTSTR *ppszResult, PLSA_UNICODE_STRING pSrc);

BOOL IsSameGUID(const GUID *p1, const GUID *p2);
#define IsNullGUID(p)   (!(p) || IsSameGUID((p), &GUID_NULL))

//
//Get the count of inheritable aces in the acl
//
DWORD GetCountOfInheritableAces(PACL pAcl);

DWORD GetCountOfInheritableAces(PSECURITY_DESCRIPTOR pSD);

BOOL IsAclBloated(HWND hDlg, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD, DWORD dwOrgInheritAceCount, BOOL bShowHelp);
HRESULT MakeBold (HWND hwnd, HFONT * phNewFont);
BOOL
DoDisabledCheck(IN HWND hWnd,
					 IN PDS_SELECTION_LIST pDsSelList);

BOOL
IsCallBackAcePresentInSD(PSECURITY_DESCRIPTOR pSD);

BOOL 
IsCallBackAcePresentInAcl(PACL pAcl);




#endif  // _MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\owner.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       owner.cpp
//
//  This file contains the implementation of the Owner page.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include "sddl.h"       // ConvertSidToStringSid


//
//  Context Help IDs.
//
const static DWORD aOwnerHelpIDs[] =
{
    IDC_OWN_CURRENTOWNER_STATIC,    IDH_OWN_CURRENTOWNER,
    IDC_OWN_CURRENTOWNER,           IDH_OWN_CURRENTOWNER,
    IDC_OWN_OWNERLIST_STATIC,       IDH_OWN_OWNERLIST,
    IDC_OWN_OWNERLIST,              IDH_OWN_OWNERLIST,
    IDC_OWN_RECURSE,                IDH_OWN_RECURSE,
    IDC_OWN_RESET,                  IDH_OWN_RESET,
    IDC_ACEL_STATIC,                -1,
    0, 0
};

//
// These SIDs are always added to the list of possible owners
//
const static UI_TokenSid g_uiTokenSids[] =
{
    UI_TSID_CurrentProcessUser,
    UI_TSID_CurrentProcessOwner,
    //UI_TSID_CurrentProcessPrimaryGroup,
};

struct Owner_LV_Entry
{
    PSID pSid;
    LPWSTR pszName;
};

Owner_LV_Entry*
MakeOwnerEntry(PSID pSid,LPWSTR pszName)
{
    Owner_LV_Entry * pEntry = 
        (Owner_LV_Entry *)LocalAlloc(LPTR,sizeof(Owner_LV_Entry));
    if(!pEntry)
        return NULL;

    pEntry->pSid = pSid;
    pEntry->pszName = pszName;
    return pEntry;
}

void
FreeOwnerEntry(Owner_LV_Entry* pEntry)
{
    if(pEntry)
    {
        if(pEntry->pSid)
            LocalFree(pEntry->pSid);
        if(pEntry->pszName)
            LocalFree(pEntry->pszName);
        LocalFree(pEntry);
    }
}

//Function for sorting the list view entries
int CALLBACK
OwnerCompareProc(LPARAM lParam1,
                 LPARAM lParam2,
                 LPARAM /*lParamSort*/)
{
    int iResult = 0;
    Owner_LV_Entry* pEntry1 = (Owner_LV_Entry*)lParam1;
    Owner_LV_Entry* pEntry2 = (Owner_LV_Entry*)lParam2;

    if(!pEntry1 && !pEntry2)
        return 0;       //Equal

    //lParam is null for "other users and groups..." and 
    //it should always be the last entry
    if(!pEntry1)
        return 1;

    if(!pEntry2)
        return -1;

    LPWSTR psz1 = pEntry1->pszName;
    LPWSTR psz2 = pEntry2->pszName;

    if (psz1 && psz2)
    {
        iResult = CompareString(LOCALE_USER_DEFAULT, 0, psz1, -1, psz2, -1) - 2;
    }

    TraceLeaveValue(iResult);
}

class COwnerPage : public CSecurityPage
{
private:
    PSID    m_psidOriginal;
    PSID    m_psidNetID;
    HANDLE  m_hSidThread;
    BOOL&    m_refbNoReadWriteCanWriteOwner;

public:
    COwnerPage(LPSECURITYINFO psi, 
               SI_OBJECT_INFO *psiObjectInfo,
               BOOL &refbNoReadWriteCanWriteOwner);
    virtual ~COwnerPage(void);

private:
    void OnSelect(HWND hDlg);
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
    int  AddSid(HWND hOwner, PSID psid, LPCTSTR pszServerName = NULL);
    void OnApply(HWND hDlg, BOOL bClose);
    void OnReset(HWND hDlg);
};


HPROPSHEETPAGE
CreateOwnerPage(LPSECURITYINFO psi, SI_OBJECT_INFO *psiObjectInfo, BOOL &refbNoReadWriteCanWriteOwner)
{
    HPROPSHEETPAGE hPage = NULL;
    COwnerPage *pPage;

    TraceEnter(TRACE_OWNER, "CreateOwnerPage");

    pPage = new COwnerPage(psi, psiObjectInfo,refbNoReadWriteCanWriteOwner);

    if (pPage)
    {
        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_OWNER_PAGE));

        if (!hPage)
            delete pPage;
    }

    TraceLeaveValue(hPage);
}


COwnerPage::
COwnerPage(LPSECURITYINFO psi, 
           SI_OBJECT_INFO *psiObjectInfo,
           BOOL& refbNoReadWriteCanWriteOwner)
           : CSecurityPage(psi, SI_PAGE_OWNER), 
           m_psidOriginal(NULL), 
           m_psidNetID(NULL),
           m_hSidThread(NULL),
           m_refbNoReadWriteCanWriteOwner(refbNoReadWriteCanWriteOwner)
{
    // Lookup known SIDs asynchronously so the dialog
    // will initialize faster
    HDPA hSids = DPA_Create(ARRAYSIZE(g_uiTokenSids));
    if (hSids)
    {
        USES_CONVERSION;

        LPCWSTR pszServer = NULL;
        if (psiObjectInfo)
            pszServer = psiObjectInfo->pszServerName;

        for (int i = 0; i < ARRAYSIZE(g_uiTokenSids); i++)
            DPA_AppendPtr(hSids, QueryTokenSid(g_uiTokenSids[i]));

        m_psidNetID = GetAuthenticationID(pszServer);
        if (m_psidNetID)
            DPA_AppendPtr(hSids, m_psidNetID);

        LookupSidsAsync(hSids, W2CT(pszServer), m_psi2, NULL, 0, &m_hSidThread);
        DPA_Destroy(hSids);
    }
}


COwnerPage::~COwnerPage(void)
{
    if (m_hSidThread)
        CloseHandle(m_hSidThread);

    if (m_psidOriginal)
        LocalFree(m_psidOriginal);

    if (m_psidNetID)
        LocalFree(m_psidNetID);
}

int
COwnerPage::AddSid(HWND hOwner, PSID psid, LPCTSTR pszServerName)
{
    PUSER_LIST pUserList = NULL;
    SID_NAME_USE sidType = SidTypeUnknown;
    LPCTSTR pszName = NULL;
    LPCTSTR pszLogonName = NULL;
    int iItem = -1;
    int cItems;
    LV_ITEM lvItem;

    TraceEnter(TRACE_OWNER, "COwnerPage::AddSid");
    TraceAssert(!m_bAbortPage);

    if (!psid || !IsValidSid(psid))
        ExitGracefully(iItem, -1, "Bad SID parameter");

    // Get the name for this SID
    if (LookupSid(psid, pszServerName, m_psi2, &pUserList))
    {
        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        sidType = pUserList->rgUsers[0].SidType;
        pszName = pUserList->rgUsers[0].pszName;
        pszLogonName = pUserList->rgUsers[0].pszLogonName;
    }

    switch (sidType)
    {
    case SidTypeDomain:
    case SidTypeDeletedAccount:
    case SidTypeInvalid:
    case SidTypeUnknown:
    case SidTypeComputer:
        ExitGracefully(iItem, -1, "SID invalid on target");
        break;
    }

    cItems = ListView_GetItemCount(hOwner);
    lvItem.mask     = LVIF_PARAM;
    lvItem.iSubItem = 0;
    

    // See if this SID is already in the list
    for (iItem = 0; iItem < cItems; iItem++)
    {
        lvItem.iItem    = iItem;
        lvItem.lParam   = NULL;
        ListView_GetItem(hOwner, &lvItem);
        Owner_LV_Entry *pLvEntry = (Owner_LV_Entry *)lvItem.lParam;

        if (pLvEntry && pLvEntry->pSid && EqualSid(psid, pLvEntry->pSid))
        {
            // This is a hack.  We often see alias sids more than once when
            // filling the list, e.g. BUILTIN\Administrators.  We want to use
            // the version of the name that includes the target domain, if
            // provided.  That is, if pszServerName is non-NULL here, switch
            // to the version of the name that goes with pszServerName.
            if (pszServerName)
            {
                lvItem.mask = LVIF_TEXT;
                lvItem.pszText = NULL;
                if (BuildUserDisplayName(&lvItem.pszText, pszName, pszLogonName)
                    || ConvertSidToStringSid(psid, &lvItem.pszText))
                {
                    if(pLvEntry->pszName)
                        LocalFree(pLvEntry->pszName);
                    pLvEntry->pszName = lvItem.pszText;
                    ListView_SetItem(hOwner, &lvItem);
                 }
            }
            break;
        }
    }

    if (iItem == cItems)
    {
        // The SID doesn't exist in the list.  Add a new entry.

        PSID psidCopy = LocalAllocSid(psid);
        if (psidCopy)
        {
            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvItem.iItem = 0;
            lvItem.iSubItem = 0;
            lvItem.pszText = NULL;
            if (!BuildUserDisplayName(&lvItem.pszText, pszName, pszLogonName))
                ConvertSidToStringSid(psid, &lvItem.pszText);
            lvItem.iImage = GetSidImageIndex(psid, sidType);            
            lvItem.lParam = (LPARAM)MakeOwnerEntry(psidCopy,lvItem.pszText);
            // Insert principal into list
            iItem = ListView_InsertItem(hOwner, &lvItem);            
        }
    }

exit_gracefully:

    if (NULL != pUserList)
        LocalFree(pUserList);

    TraceLeaveValue(iItem);
}



VOID
COwnerPage::OnSelect(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;
    LPEFFECTIVEPERMISSION pei;
    HRESULT hr = S_OK;

    TraceEnter(TRACE_OWNER, "COwnerPage::OnSelect");

    if (S_OK == GetUserGroup(hDlg, FALSE, &pUserList))
    {
        TraceAssert(NULL != pUserList);
        TraceAssert(1 == pUserList->cUsers);

        // Copy the new sid
        PSID pSid = (PSID)pUserList->rgUsers[0].pSid;
        if (pSid)
        {
            HWND hwndList = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
            int iIndex = AddSid(hwndList,
                                pSid,
                                m_siObjectInfo.pszServerName);

            PropSheet_Changed(GetParent(hDlg), hDlg);
            SelectListViewItem(hwndList, iIndex);
            //Sort the listview
            ListView_SortItems(hwndList,OwnerCompareProc,NULL);
        }
        LocalFree(pUserList);
    }    
}


void
COwnerPage::InitDlg(HWND hDlg)
{
    TCHAR       szBuffer[MAX_PATH];
    BOOL        bReadOnly;
    HWND        hOwner = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
    HCURSOR     hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_OWNER, "COwnerPage::InitDlg");

    // Hide the Reset button if it isn't supported.
    if (!(m_siObjectInfo.dwFlags & SI_RESET) &&
        !(m_siObjectInfo.dwFlags & SI_RESET_OWNER))
    {
        ShowWindow(GetDlgItem(hDlg, IDC_OWN_RESET), SW_HIDE);
    }

    // Hide the Recurse checkbox if it isn't supported.
    if ((m_siObjectInfo.dwFlags & (SI_OWNER_RECURSE | SI_CONTAINER)) != (SI_OWNER_RECURSE | SI_CONTAINER))
    {
        m_siObjectInfo.dwFlags &= ~SI_OWNER_RECURSE;
        HWND hwndRecurse = GetDlgItem(hDlg, IDC_OWN_RECURSE);
        ShowWindow(hwndRecurse, SW_HIDE);
        EnableWindow(hwndRecurse, FALSE);
    }

    if (m_bAbortPage)
    {
        //
        // Disable everything
        //
        bReadOnly = TRUE;
    }
    else
    {
        // Create & set the image list for the listview
        ListView_SetImageList(hOwner,
                              LoadImageList(::hModule, MAKEINTRESOURCE(IDB_SID_ICONS)),
                              LVSIL_SMALL);

        //
        // Add the "Name" column (the only column on this page)
        //
        RECT rc;
        GetClientRect(hOwner, &rc);

        LoadString(::hModule, IDS_NAME, szBuffer, ARRAYSIZE(szBuffer));

        LV_COLUMN col;
        col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
        col.fmt = LVCFMT_LEFT;
        col.pszText = szBuffer;
        col.iSubItem = 0;
        col.cx = rc.right;
        ListView_InsertColumn(hOwner, 0, &col);


        //
        // Make a copy of the current owner sid
        //
        PSECURITY_DESCRIPTOR pSD = NULL;

        HRESULT hr = m_psi->GetSecurity(OWNER_SECURITY_INFORMATION, &pSD, FALSE);
        if (pSD)
        {
            PSID psidOwner = NULL;
            BOOL bDefaulted;

            GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted);

            if (psidOwner)
            {
                UINT iLength = GetLengthSid(psidOwner);
                m_psidOriginal = LocalAlloc(LPTR, iLength);
                if (m_psidOriginal)
                    CopyMemory(m_psidOriginal, psidOwner, iLength);
            }
            LocalFree(pSD);
        }

        // Test for writeability
        bReadOnly = !!(m_siObjectInfo.dwFlags & SI_OWNER_READONLY);
    } // !m_bAbortPage

    //
    // Iterate through the groups on this process's token looking for
    // the SE_GROUP_OWNER attribute.
    //
    if (!bReadOnly)
    {
        HANDLE hProcessToken = NULL;

        //
        // Wait for the known SIDs to be resolved so we don't try
        // to look them up twice.
        //
        if (m_hSidThread)
        {
            WaitForSingleObject(m_hSidThread, INFINITE);
            CloseHandle(m_hSidThread);
            m_hSidThread = NULL;
        }

        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
        {
            // Allocate a buffer for the TOKEN_GROUPS information
            ULONG  cbBuffer = 1024; // start with 1k
            LPVOID pBuffer = LocalAlloc(LPTR, cbBuffer);

            if (pBuffer)
            {
                if (!GetTokenInformation(hProcessToken,
                                         TokenGroups,
                                         pBuffer,
                                         cbBuffer,
                                         &cbBuffer))
                {
                    LocalFree(pBuffer);
                    pBuffer = NULL;

                    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        pBuffer = LocalAlloc(LPTR, cbBuffer);// size returned above
                        if (pBuffer && !GetTokenInformation(hProcessToken,
                                                            TokenGroups,
                                                            pBuffer,
                                                            cbBuffer,
                                                            &cbBuffer))
                        {
                            LocalFree(pBuffer);
                            pBuffer = NULL;
                        }
                    }
                }

                if (pBuffer)
                {
                    PTOKEN_GROUPS ptg = (PTOKEN_GROUPS)pBuffer;
                    for (ULONG i = 0; i < ptg->GroupCount; i++)
                    {
                        DWORD dwAttr = ptg->Groups[i].Attributes;
                        if ((dwAttr & SE_GROUP_OWNER) && !(dwAttr & SE_GROUP_LOGON_ID))
                        {
                            AddSid(hOwner, ptg->Groups[i].Sid, m_siObjectInfo.pszServerName);
                        }
                    }
                }
                if (pBuffer != NULL)
                    LocalFree(pBuffer);
            }
            CloseHandle(hProcessToken);
        }

        //
        // Now add in the additional possible sids
        //
        for (int i = 0; i < ARRAYSIZE(g_uiTokenSids); i++)
            AddSid(hOwner, QueryTokenSid(g_uiTokenSids[i]));

        AddSid(hOwner, m_psidNetID, m_siObjectInfo.pszServerName);
    }

    if (!m_bAbortPage)
    {
        PUSER_LIST pUserList = NULL;

        LoadString(::hModule, IDS_OWNER_CANT_DISPLAY, szBuffer, ARRAYSIZE(szBuffer));

        // Finally, look up a name for the original SID.
        if (m_psidOriginal)
        {
            LPTSTR pszName = NULL;

            // Get the "S-1-5-blah" form of the SID in case the lookup fails
            if (ConvertSidToStringSid(m_psidOriginal, &pszName))
            {
                lstrcpyn(szBuffer, pszName, ARRAYSIZE(szBuffer));
                LocalFreeString(&pszName);
            }

            if (LookupSid(m_psidOriginal, m_siObjectInfo.pszServerName, m_psi2, &pUserList))
            {
                TraceAssert(NULL != pUserList);
                TraceAssert(1 == pUserList->cUsers);

                if (BuildUserDisplayName(&pszName, pUserList->rgUsers[0].pszName, pUserList->rgUsers[0].pszLogonName))
                {
                    lstrcpyn(szBuffer, pszName, ARRAYSIZE(szBuffer));
                    LocalFreeString(&pszName);
                }
                LocalFree(pUserList);
            }
        }
        SetDlgItemText(hDlg, IDC_OWN_CURRENTOWNER, szBuffer);
    }

    //
    // If the current user cannot change owners, gray out the list box.
    //
    if (bReadOnly)
    {
        // Disable the list and notify the user that it's read-only.
        EnableWindow(hOwner, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_OWN_RESET), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_OWN_RECURSE), FALSE);

        //
        // If we're aborting, then the user should have been notified
        // during the propsheetpage callback.  Don't put up another
        // message here.
        //
        if (S_OK == m_hrLastPSPCallbackResult)
        {
            MsgPopup(hDlg,
                     MAKEINTRESOURCE(IDS_OWNER_READONLY),
                     MAKEINTRESOURCE(IDS_SECURITY),
                     MB_OK | MB_ICONINFORMATION,
                     ::hModule,
                     m_siObjectInfo.pszObjectName);
        }
    }
    
    ListView_SortItems(GetDlgItem(hDlg, IDC_OWN_OWNERLIST),OwnerCompareProc,NULL);
    SetCursor(hcur);

    TraceLeaveVoid();
}

void
COwnerPage::OnApply(HWND hDlg, BOOL bClose)
{
    int  iSelected = -1;
    HWND hwndOwnerList = NULL;
    PSID psid = NULL;
    BOOL bRecurse = FALSE;
    SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION;
    BOOL bEqualSid = FALSE;

    TraceEnter(TRACE_OWNER, "COwnerPage::OnApply");

    hwndOwnerList = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
    Owner_LV_Entry * pLVEntry = (Owner_LV_Entry *)GetSelectedItemData(hwndOwnerList, &iSelected);

    if(pLVEntry)
    {
        psid = pLVEntry->pSid;
    }

    // If there is no selection, use the original
    if (!psid)
        psid = m_psidOriginal;

    // If no selection and no original, then we can't do anything
    if (!psid)
        TraceLeaveVoid();


    if ((m_siObjectInfo.dwFlags & SI_OWNER_RECURSE)
        && IsDlgButtonChecked(hDlg, IDC_OWN_RECURSE) == BST_CHECKED)
    {
        bRecurse = TRUE;
    }

    // Has anything changed?
    if (m_psidOriginal
        && ( (m_psidOriginal == psid) || EqualSid(m_psidOriginal, psid) )
        && !bRecurse)
    {
        // Nothing has changed
        TraceLeaveVoid();
    }

    SECURITY_DESCRIPTOR sd = {0};
    DWORD dwPrivs[] = { SE_TAKE_OWNERSHIP_PRIVILEGE, SE_RESTORE_PRIVILEGE };

    HANDLE hToken = INVALID_HANDLE_VALUE;

    TraceAssert(!m_bAbortPage);

    HRESULT hr = S_OK;

    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"InitializeSecurityDescriptor failed");
    }

    if(!SetSecurityDescriptorOwner(&sd, psid, FALSE))
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"SetSecurityDescriptorOwner failed");
    }

    // 
    // ISecurityInformation::SetSecurity doesn't have a parameter to indicate
    // that the owner should be recursively applied.  We could add a parameter,
    // but for now, just use one of the unused SECURITY_INFORMATION bits.
    // The security descriptor structure is unlikely to change so this should
    // be ok for now.
    if (bRecurse)
        si |= SI_OWNER_RECURSE;

    hToken = EnablePrivileges(dwPrivs, ARRAYSIZE(dwPrivs));

    hr = m_psi->SetSecurity(si, &sd);

    ReleasePrivileges(hToken);

    if (S_FALSE == hr)
    {
        // S_FALSE is silent failure (the client should put up UI
        // during SetSecurity before returning S_FALSE).
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
    }
    else if (S_OK == hr && !bClose)
    {
        if(m_refbNoReadWriteCanWriteOwner)
        {
            MsgPopup(hDlg,
                     MAKEINTRESOURCE(IDS_REFRESH_PROPERTYSHEET),
                     MAKEINTRESOURCE(IDS_SECURITY),
                     MB_OK | MB_ICONINFORMATION,
                     ::hModule);         

            m_refbNoReadWriteCanWriteOwner = FALSE;
        }

        //Inform the Effective Permission tab that
        //Permissions are changed
        PropSheet_QuerySiblings(GetParent(hDlg),0,0);

        UINT iLength = GetLengthSid(psid);
        
        if (-1 != iSelected)
        {
            TCHAR szName[MAX_PATH];
            szName[0] = TEXT('\0');
            ListView_GetItemText(hwndOwnerList, iSelected, 0, szName, ARRAYSIZE(szName));
            SetDlgItemText(hDlg, IDC_OWN_CURRENTOWNER, szName);
        }
        
        if (!(m_psidOriginal && 
           ((m_psidOriginal == psid) || EqualSid(m_psidOriginal, psid))))
        {
            if (m_psidOriginal)
            {
                UINT iLengthOriginal = (UINT)LocalSize(m_psidOriginal);
                if (iLengthOriginal < iLength)
                {
                    LocalFree(m_psidOriginal);
                    m_psidOriginal = NULL;
                }
                else
                {
                    ZeroMemory(m_psidOriginal, iLengthOriginal);
                }
            }

            if (!m_psidOriginal)
                m_psidOriginal = LocalAlloc(LPTR, iLength);

            if (m_psidOriginal)
            {
                CopyMemory(m_psidOriginal, psid, iLength);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (m_siObjectInfo.dwFlags & SI_OWNER_RECURSE)
            CheckDlgButton(hDlg, IDC_OWN_RECURSE, BST_UNCHECKED);
    }

exit_gracefully:

    if (FAILED(hr))
    {
        if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_OWNER))
        {
            MsgPopup(hDlg,
                     MAKEINTRESOURCE(IDS_NO_RESTORE_PRIV),
                     MAKEINTRESOURCE(IDS_SECURITY),
                     MB_OK | MB_ICONERROR,
                     ::hModule,
                     m_siObjectInfo.pszObjectName);         
        }
        else
        {
            SysMsgPopup(hDlg,
                        MAKEINTRESOURCE(IDS_OWNER_WRITE_FAILED),
                        MAKEINTRESOURCE(IDS_SECURITY),
                        MB_OK | MB_ICONERROR,
                        ::hModule,
                        hr,
                        m_siObjectInfo.pszObjectName);
        }

    }

    TraceLeaveVoid();
}

void
COwnerPage::OnReset(HWND hDlg)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    HWND hOwner;
    PSID psid;
    HRESULT hr;

    TraceEnter(TRACE_OWNER, "COwnerPage::OnReset");
    TraceAssert(!m_bAbortPage);

    hOwner = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
    psid = (PSID)GetSelectedItemData(hOwner, NULL);

    hr = m_psi->GetSecurity(OWNER_SECURITY_INFORMATION, &pSD, TRUE);
    if (SUCCEEDED(hr))
    {
        PSID psidDefault = NULL;
        BOOL bDefaulted;

        if (pSD)
            GetSecurityDescriptorOwner(pSD, &psidDefault, &bDefaulted);

        if (psidDefault && !EqualSid(psidDefault, psid))
        {
            int iSel = AddSid(hOwner, psidDefault, m_siObjectInfo.pszServerName);

            if (iSel != -1)
            {
                ListView_SetItemState(hOwner, iSel, LVIS_SELECTED, LVIS_SELECTED);
                PropSheet_Changed(GetParent(hDlg), hDlg);
                ListView_SortItems(hOwner,OwnerCompareProc,NULL);
            }           
        }
        LocalFree(pSD);
    }
    else
    {
        SysMsgPopup(hDlg,
                    MAKEINTRESOURCE(IDS_OPERATION_FAILED),
                    MAKEINTRESOURCE(IDS_SECURITY),
                    MB_OK | MB_ICONERROR,
                    ::hModule,
                    hr);
    }

    TraceLeaveVoid();
}

BOOL
COwnerPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bResult = TRUE;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        {
            LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)lParam;

            switch (((LPNMHDR)lParam)->code)
            {
            case LVN_ITEMCHANGED:
                if (pnmlv->uChanged & LVIF_STATE)
                {
                    //if "Other users or group" entry is selected, 
                    //no action is required
                    LVITEM lv;
                    ZeroMemory(&lv,sizeof(LVITEM));
                    lv.mask = LVIF_PARAM;
                    lv.iItem = pnmlv->iItem;
                    ListView_GetItem(((LPNMHDR)lParam)->hwndFrom,&lv);

                    //A user or group is selected
                    if(lv.lParam)
                    {
                        // item *gaining* selection
                        if ((pnmlv->uNewState & LVIS_SELECTED) &&
                            !(pnmlv->uOldState & LVIS_SELECTED))
                        {
                            PropSheet_Changed(GetParent(hDlg), hDlg);
                        }
                    }
                }
                break;

            case LVN_DELETEITEM:
                if (pnmlv->lParam)
                    FreeOwnerEntry((Owner_LV_Entry*)pnmlv->lParam);
                break;

            case NM_SETFOCUS:
                if (((LPNMHDR)lParam)->idFrom == IDC_OWN_OWNERLIST)
                {
                    // Make sure the listview is always focused on something,
                    // otherwise you can't tab into the control.
                    HWND hwndLV = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
                    if (-1 == ListView_GetNextItem(hwndLV, -1, LVNI_FOCUSED))
                        ListView_SetItemState(hwndLV, 0, LVIS_FOCUSED, LVIS_FOCUSED);
                }
                break;

            case PSN_QUERYINITIALFOCUS:
                {
                    // Set initial focus to the list of potential owners
                    HWND hwndLV = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
                    if (IsWindowEnabled(hwndLV))
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)hwndLV);
                    else
                        bResult = FALSE;
                }
                break;

            case PSN_APPLY:
                OnApply(hDlg, (BOOL)(((LPPSHNOTIFY)lParam)->lParam));
                break;


            case NM_CLICK:
            case NM_RETURN:
            {
                if(wParam == IDC_EFF_STATIC)
                {
                    HtmlHelp(hDlg,
                             c_szOwnerHelpLink,
                             HH_DISPLAY_TOPIC,
                            0);
                }
            }
            break;

            default:
                bResult = FALSE;
            }
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_OWN_RECURSE:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
            {
                //If there is no original and no sid is selected
                //don't enable apply
                int iSelected = -1;
                HWND hwndOwnerList = NULL;
                PSID psid = NULL;
                hwndOwnerList = GetDlgItem(hDlg, IDC_OWN_OWNERLIST);
                Owner_LV_Entry * pLVEntry = (Owner_LV_Entry *)GetSelectedItemData(hwndOwnerList, &iSelected);

                if(pLVEntry)
                {
                    psid = pLVEntry->pSid;
                }

                // If there is no selection, use the original
                if (!psid)
                    psid = m_psidOriginal;

                // If no selection and no original, then we can't do anything
                if (psid)
                    PropSheet_Changed(GetParent(hDlg), hDlg);
            }
            break;

        case IDC_OWN_RESET:
            OnReset(hDlg);
            break;

        case IDC_OWN_OTHER_USER:
            OnSelect(hDlg);
            break;

        default:
            bResult = FALSE;
        }
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szAcluiHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)aOwnerHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)aOwnerHelpIDs);
        }
        break;

    default:
        bResult = FALSE;
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\pagebase.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pagebase.cpp
//
//  This file contains the implementation of the CSecurityPage base class.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

CSecurityPage::CSecurityPage( LPSECURITYINFO psi, SI_PAGE_TYPE siType )
: m_siPageType(siType), m_psi(psi), m_psi2(NULL),m_pei(NULL), m_pObjectPicker(NULL),
  m_psoti(NULL),
  m_flLastOPOptions(DWORD(-1))
{
    ZeroMemory(&m_siObjectInfo, sizeof(m_siObjectInfo));

    // Initialize COM incase our client hasn't
    m_hrComInit = CoInitialize(NULL);

    if (m_psi != NULL)
    {
        m_psi->AddRef();

        // It's normal for this to fail
        m_psi->QueryInterface(IID_ISecurityInformation2, (LPVOID*)&m_psi2);
        m_psi->QueryInterface(IID_IEffectivePermission, (LPVOID*)&m_pei);
        m_psi->QueryInterface(IID_ISecurityObjectTypeInfo, (LPVOID*)&m_psoti);
    }
}

CSecurityPage::~CSecurityPage( void )
{
    DoRelease(m_psi);
    DoRelease(m_psi2);
    DoRelease(m_pObjectPicker);
    DoRelease(m_pei);
    DoRelease(m_psoti);

    if (SUCCEEDED(m_hrComInit))
        CoUninitialize();
}

HPROPSHEETPAGE
CSecurityPage::CreatePropSheetPage(LPCTSTR pszDlgTemplate, LPCTSTR pszDlgTitle)
{
    PROPSHEETPAGE psp;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USECALLBACK ;
    psp.hInstance   = ::hModule;
    psp.pszTemplate = pszDlgTemplate;
    psp.pszTitle    = pszDlgTitle;
    psp.pfnDlgProc  = CSecurityPage::_DlgProc;
    psp.lParam      = (LPARAM)this;
    psp.pfnCallback = CSecurityPage::_PSPageCallback;

    if (pszDlgTitle != NULL)
        psp.dwFlags |= PSP_USETITLE;

    return CreatePropertySheetPage(&psp);
}

HRESULT
CSecurityPage::GetObjectPicker(IDsObjectPicker **ppObjectPicker)
{
    HRESULT hr = S_OK;

    if (!m_pObjectPicker)
    {
        if (!m_psi)
            return E_UNEXPECTED;

        // See if the object supports IDsObjectPicker
        hr = m_psi->QueryInterface(IID_IDsObjectPicker, (LPVOID*)&m_pObjectPicker);

        // If the object doesn't support IDsObjectPicker, create one.
        if (FAILED(hr))
        {
            hr = CoCreateInstance(CLSID_DsObjectPicker,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDsObjectPicker,
                                  (LPVOID*)&m_pObjectPicker);
        }
    }

    if (ppObjectPicker)
    {
        *ppObjectPicker = m_pObjectPicker;
        // Return a reference (caller must Release)
        if (m_pObjectPicker)
            m_pObjectPicker->AddRef();
    }

    return hr;
}


//
// Stuff used for initializing the Object Picker below
//
#define DSOP_FILTER_COMMON1 ( DSOP_FILTER_INCLUDE_ADVANCED_VIEW \
                            | DSOP_FILTER_USERS                 \
                            | DSOP_FILTER_UNIVERSAL_GROUPS_SE   \
                            | DSOP_FILTER_GLOBAL_GROUPS_SE      \
                            | DSOP_FILTER_COMPUTERS             \
                            )
#define DSOP_FILTER_COMMON2 ( DSOP_FILTER_COMMON1               \
                            | DSOP_FILTER_WELL_KNOWN_PRINCIPALS \
                            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE\
                            )
#define DSOP_FILTER_COMMON3 ( DSOP_FILTER_COMMON2               \
                            | DSOP_FILTER_BUILTIN_GROUPS        \
                            )
#define DSOP_FILTER_DL_COMMON1      ( DSOP_DOWNLEVEL_FILTER_USERS           \
                                    | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS   \
                                    )
#define DSOP_FILTER_DL_COMMON2      ( DSOP_FILTER_DL_COMMON1                    \
                                    | DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS  \
                                    )
#define DSOP_FILTER_DL_COMMON3      ( DSOP_FILTER_DL_COMMON2                \
                                    | DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS    \
                                    )

#if 0
{   // DSOP_SCOPE_INIT_INFO
    cbSize,
    flType,
    flScope,
    {   // DSOP_FILTER_FLAGS
        {   // DSOP_UPLEVEL_FILTER_FLAGS
            flBothModes,
            flMixedModeOnly,
            flNativeModeOnly
        },
        flDownlevel
    },
    pwzDcName,
    pwzADsPath,
    hr // OUT
}
#endif

#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f|DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }

// The domain to which the target computer is joined.
// Make 2 scopes, one for uplevel domains, the other for downlevel.
#define JOINED_DOMAIN_SCOPE(f)  \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,(f),0,(DSOP_FILTER_COMMON2 & ~(DSOP_FILTER_UNIVERSAL_GROUPS_SE|DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE)),DSOP_FILTER_COMMON2,0), \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,(f),0,0,0,DSOP_FILTER_DL_COMMON2)

// The domain for which the target computer is a Domain Controller.
// Make 2 scopes, one for uplevel domains, the other for downlevel.
#define JOINED_DOMAIN_SCOPE_DC(f)  \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,(f),0,(DSOP_FILTER_COMMON3 & ~DSOP_FILTER_UNIVERSAL_GROUPS_SE),DSOP_FILTER_COMMON3,0), \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,(f),0,0,0,DSOP_FILTER_DL_COMMON3)

// Target computer scope.  Computer scopes are always treated as
// downlevel (i.e., they use the WinNT provider).
#define TARGET_COMPUTER_SCOPE(f)\
DECLARE_SCOPE(DSOP_SCOPE_TYPE_TARGET_COMPUTER,(f),0,0,0,DSOP_FILTER_DL_COMMON3)

// The Global Catalog
#define GLOBAL_CATALOG_SCOPE(f) \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_GLOBAL_CATALOG,(f),DSOP_FILTER_COMMON1|DSOP_FILTER_WELL_KNOWN_PRINCIPALS,0,0,0)

// The domains in the same forest (enterprise) as the domain to which
// the target machine is joined.  Note these can only be DS-aware
#define ENTERPRISE_SCOPE(f)     \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,(f),DSOP_FILTER_COMMON1,0,0,0)

// Domains external to the enterprise but trusted directly by the
// domain to which the target machine is joined.
#define EXTERNAL_SCOPE(f)       \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN|DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,\
    (f),DSOP_FILTER_COMMON1,0,0,DSOP_DOWNLEVEL_FILTER_USERS|DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS)

// Workgroup scope.  Only valid if the target computer is not joined
// to a domain.
#define WORKGROUP_SCOPE(f)      \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_WORKGROUP,(f),0,0,0, DSOP_FILTER_DL_COMMON1|DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS )

//
// Array of Default Scopes
//
static const DSOP_SCOPE_INIT_INFO g_aDefaultScopes[] =
{
    JOINED_DOMAIN_SCOPE(DSOP_SCOPE_FLAG_STARTING_SCOPE),
    TARGET_COMPUTER_SCOPE(0),
    GLOBAL_CATALOG_SCOPE(0),
    ENTERPRISE_SCOPE(0),
    EXTERNAL_SCOPE(0),
};

//
// Same as above, but without the Target Computer
// Used when the target is a Domain Controller
//
static const DSOP_SCOPE_INIT_INFO g_aDCScopes[] =
{
    JOINED_DOMAIN_SCOPE_DC(DSOP_SCOPE_FLAG_STARTING_SCOPE),
    GLOBAL_CATALOG_SCOPE(0),
    ENTERPRISE_SCOPE(0),
    EXTERNAL_SCOPE(0),
};

//
// Array of scopes for standalone machines
//
static const DSOP_SCOPE_INIT_INFO g_aStandAloneScopes[] =
{
//
//On Standalone machine Both User And Groups are selected by default
//
    TARGET_COMPUTER_SCOPE(DSOP_SCOPE_FLAG_STARTING_SCOPE|DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS),
};

//
// Attributes that we want the Object Picker to retrieve
//
static const LPCTSTR g_aszOPAttributes[] =
{
    TEXT("ObjectSid"),
	 TEXT("userAccountControl"),
};


HRESULT
CSecurityPage::InitObjectPicker(BOOL bMultiSelect)
{
    HRESULT hr = S_OK;
    DSOP_INIT_INFO InitInfo;
    PCDSOP_SCOPE_INIT_INFO pScopes;
    ULONG cScopes;

    USES_CONVERSION;

    TraceEnter(TRACE_MISC, "InitObjectPicker");

    hr = GetObjectPicker();
    if (FAILED(hr))
        TraceLeaveResult(hr);

    TraceAssert(m_pObjectPicker != NULL);

    InitInfo.cbSize = sizeof(InitInfo);
    // We do the DC check at WM_INITDIALOG
    InitInfo.flOptions = DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK;
    if (bMultiSelect)
        InitInfo.flOptions |= DSOP_FLAG_MULTISELECT;

    // flOptions is the only thing that changes from call to call,
    // so optimize this by only reinitializing if flOptions changes.
    if (m_flLastOPOptions == InitInfo.flOptions)
        TraceLeaveResult(S_OK); // Already initialized

    m_flLastOPOptions = (DWORD)-1;

    pScopes = g_aDefaultScopes;
    cScopes = ARRAYSIZE(g_aDefaultScopes);

    if (m_bStandalone)
    {
        cScopes = ARRAYSIZE(g_aStandAloneScopes);
        pScopes = g_aStandAloneScopes;
    }
    else if (m_siObjectInfo.dwFlags & SI_SERVER_IS_DC)
    {
        cScopes = ARRAYSIZE(g_aDCScopes);
        pScopes = g_aDCScopes;
    }

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //
    InitInfo.pwzTargetComputer = T2CW(m_siObjectInfo.pszServerName);
    InitInfo.cDsScopeInfos = cScopes;
    InitInfo.aDsScopeInfos = (PDSOP_SCOPE_INIT_INFO)LocalAlloc(LPTR, sizeof(*pScopes)*cScopes);
    if (!InitInfo.aDsScopeInfos)
        TraceLeaveResult(E_OUTOFMEMORY);
    CopyMemory(InitInfo.aDsScopeInfos, pScopes, sizeof(*pScopes)*cScopes);
    InitInfo.cAttributesToFetch = ARRAYSIZE(g_aszOPAttributes);
    InitInfo.apwzAttributeNames = (LPCTSTR*)g_aszOPAttributes;

    if (m_siObjectInfo.dwFlags & SI_SERVER_IS_DC) 
    {
        for (ULONG i = 0; i < cScopes; i++)
        {
            // Set the DC name if appropriate
            if ((m_siObjectInfo.dwFlags & SI_SERVER_IS_DC) &&
                (InitInfo.aDsScopeInfos[i].flType & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN))
            {
                InitInfo.aDsScopeInfos[i].pwzDcName = InitInfo.pwzTargetComputer;
            }

        }
    }

    hr = m_pObjectPicker->Initialize(&InitInfo);

    if (SUCCEEDED(hr))
    {
        // Remember the Options for next time
        m_flLastOPOptions = InitInfo.flOptions;
    }

    LocalFree(InitInfo.aDsScopeInfos);

    TraceLeaveResult(hr);
}


HRESULT
CSecurityPage::GetUserGroup(HWND hDlg, BOOL bMultiSelect, PUSER_LIST *ppUserList)
{
    HRESULT hr;
    LPDATAOBJECT pdoSelection = NULL;
    STGMEDIUM medium = {0};
    FORMATETC fe = { (CLIPFORMAT)g_cfDsSelectionList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    PDS_SELECTION_LIST pDsSelList = NULL;
    HCURSOR hcur = NULL;
    PSIDCACHE pSidCache = NULL;
    UINT idErrorMsg = IDS_GET_USER_FAILED;

    TraceEnter(TRACE_MISC, "GetUserGroup");
    TraceAssert(ppUserList != NULL);

    *ppUserList = NULL;

    //
    // Create and initialize the Object Picker object
    //
    hr = InitObjectPicker(bMultiSelect);
    FailGracefully(hr, "Unable to initialize Object Picker object");

    //
    // Create the global sid cache object, if necessary
    //
    pSidCache = GetSidCache();
    if (pSidCache == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create SID cache");

    //
    // Bring up the object picker dialog
    //
    hr = m_pObjectPicker->InvokeDialog(hDlg, &pdoSelection);
    FailGracefully(hr, "IDsObjectPicker->Invoke failed");
    if (S_FALSE == hr)
        ExitGracefully(hr, S_FALSE, "IDsObjectPicker->Invoke cancelled by user");

    hr = pdoSelection->GetData(&fe, &medium);
    FailGracefully(hr, "Unable to get CFSTR_DSOP_DS_SELECTION_LIST from DataObject");

    pDsSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);
    if (!pDsSelList)
        ExitGracefully(hr, E_FAIL, "Unable to lock stgmedium.hGlobal");

    TraceAssert(pDsSelList->cItems > 0);
    Trace((TEXT("%d items selected"), pDsSelList->cItems));

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

	 //Check if there is any disabled items
	 if(!DoDisabledCheck(hDlg,
							   pDsSelList))
	 {
		 return S_FALSE;
	 }




    //
    // Lookup the names/sids and cache them
    //
    if (!pSidCache->LookupNames(pDsSelList,
                                m_siObjectInfo.pszServerName,
                                ppUserList,
                                m_bStandalone))
    {
        hr = E_FAIL;
        idErrorMsg = IDS_SID_LOOKUP_FAILED;
    }

    SetCursor(hcur);

exit_gracefully:
    
    if (pSidCache)
        pSidCache->Release();

    if (FAILED(hr))
    {
        SysMsgPopup(hDlg,
                    MAKEINTRESOURCE(idErrorMsg),
                    MAKEINTRESOURCE(IDS_SECURITY),
                    MB_OK | MB_ICONERROR,
                    ::hModule,
                    hr);
    }

    if (pDsSelList)
        GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    DoRelease(pdoSelection);

    TraceLeaveResult(hr);
}

UINT
CSecurityPage::PSPageCallback(HWND hwnd,
                              UINT uMsg,
                              LPPROPSHEETPAGE /*ppsp*/)
{
    m_hrLastPSPCallbackResult = E_FAIL;

    if (m_psi != NULL)
    {
        m_hrLastPSPCallbackResult = m_psi->PropertySheetPageCallback(hwnd, uMsg, m_siPageType);
        if (m_hrLastPSPCallbackResult == E_NOTIMPL)
            m_hrLastPSPCallbackResult = S_OK;
    }

    return SUCCEEDED(m_hrLastPSPCallbackResult);
}

INT_PTR
CALLBACK
CSecurityPage::_DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPSECURITYPAGE pThis = (LPSECURITYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    // The following messages arrive before WM_INITDIALOG
    // which means pThis is NULL for them.  We don't need these
    // messages so let DefDlgProc handle them.
    //
    // WM_SETFONT
    // WM_NOTIFYFORMAT
    // WM_NOTIFY (LVN_HEADERCREATED)

    if (uMsg == WM_INITDIALOG)
    {
        pThis = (LPSECURITYPAGE)(((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);

        if (pThis)
        {
            if (!pThis->PSPageCallback(hDlg, PSPCB_SI_INITDIALOG, NULL))
                pThis->m_bAbortPage = TRUE;

            if (pThis->m_psi)
            {
                BOOL bIsDC = FALSE;
                pThis->m_psi->GetObjectInformation(&pThis->m_siObjectInfo);
                pThis->m_bStandalone = IsStandalone(pThis->m_siObjectInfo.pszServerName, &bIsDC);
                if (bIsDC)
                    pThis->m_siObjectInfo.dwFlags |= SI_SERVER_IS_DC;
            }
        }
    }

    if (pThis != NULL)
        return pThis->DlgProc(hDlg, uMsg, wParam, lParam);

    return FALSE;
}

UINT
CALLBACK
CSecurityPage::_PSPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    LPSECURITYPAGE pThis = (LPSECURITYPAGE)ppsp->lParam;

    if (pThis)
    {
        UINT nResult = pThis->PSPageCallback(hWnd, uMsg, ppsp);

        switch (uMsg)
        {
        case PSPCB_CREATE:
            if (!nResult)
                pThis->m_bAbortPage = TRUE;
            break;

        case PSPCB_RELEASE:
            delete pThis;
            break;
        }
    }

    //
    // Always return non-zero or else our tab will disappear and whichever
    // property page becomes active won't repaint properly.  Instead, use
    // the m_bAbortPage flag during WM_INITDIALOG to disable the page if
    // the callback failed.
    //
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\pagebase.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pagebase.h
//
//  This file contains the definition of the CSecurityPage base class
//
//--------------------------------------------------------------------------

#ifndef _PAGEBASE_H_
#define _PAGEBASE_H_

class CSecurityPage
{
protected:
    SI_PAGE_TYPE            m_siPageType;
    LPSECURITYINFO          m_psi;
    LPSECURITYINFO2         m_psi2;
    LPEFFECTIVEPERMISSION   m_pei;
    LPSecurityObjectTypeInfo m_psoti;
    HRESULT                 m_hrComInit;
    IDsObjectPicker         *m_pObjectPicker;
    SI_OBJECT_INFO          m_siObjectInfo;
    DWORD                   m_flLastOPOptions;
    BOOL                    m_bStandalone;
    BOOL                    m_bAbortPage;
    HRESULT                 m_hrLastPSPCallbackResult;

public:
    CSecurityPage( LPSECURITYINFO psi, SI_PAGE_TYPE siType );
    virtual ~CSecurityPage( void );

    HPROPSHEETPAGE CreatePropSheetPage(LPCTSTR pszDlgTemplate, LPCTSTR pszDlgTitle = NULL);
    HRESULT GetObjectPicker(IDsObjectPicker **ppObjectPicker = NULL);
    HRESULT GetUserGroup(HWND hDlg, BOOL bMultiSelect, PUSER_LIST *ppUserList);
    BOOL IsEffective(){ return (m_pei != NULL) ;}

protected:
    HRESULT InitObjectPicker(BOOL bMultiSelect);

    virtual BOOL DlgProc(HWND, UINT, WPARAM, LPARAM) = 0;
    virtual UINT PSPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

    static INT_PTR CALLBACK _DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK _PSPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
};

typedef class CSecurityPage *LPSECURITYPAGE;

#endif  /* _PAGEBASE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\perm.cpp ===
#include "aclpriv.h"

//Function for checking the Custom checkbox
VOID 
CheckCustom(HWND hwndList,
            WORD wColumn,      //Allow or Deny column
            DWORD dwState )
{
    //Custom is always the last checkbox
    UINT cRights = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    //Don't check if the column is already checked. This fucntion is first
    //called for explicit and then for inherited aces. Effect is if explict aces are there
    //checkbox is enabled.

    DWORD dwStateCurrent = (DWORD)SendMessage(hwndList,
                                       CLM_GETSTATE,
                                       MAKELONG((WORD)(cRights -1), wColumn),
                                       0);

    if (dwStateCurrent & CLST_CHECKED) 
        return;
    //
    //Custom Checkbox is always disabled
    //

    SendMessage(hwndList,
                CLM_SETSTATE,
                MAKELONG((WORD)(cRights -1), wColumn),
                dwState|CLST_DISABLED);
}
VOID 
ClearCustom(HWND hwndList,
            WORD wColumn)      //Allow or Deny column
{
    //Custom is always the last checkbox
    UINT cRights = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);
    //
    //Custom Checkbox is always disabled
    //
    SendMessage(hwndList,
                CLM_SETSTATE,
                MAKELONG((WORD)(cRights -1), wColumn),
                CLST_DISABLED);
}


//
// CPrincipal implementation
//

CPrincipal::~CPrincipal()
{
    if (NULL != m_pSID)
        LocalFree(m_pSID);

    LocalFreeString(&m_pszName);
    LocalFreeString(&m_pszDisplayName);
    if( m_hAdditionalAllow != NULL )
        DSA_Destroy( m_hAdditionalAllow );
    if( m_hAdditionalDeny != NULL )
        DSA_Destroy( m_hAdditionalDeny );
}


BOOL
CPrincipal::SetPrincipal(PSID pSID,
                         SID_NAME_USE sidType,
                         LPCTSTR pszName,
                         LPCTSTR pszLogonName)
{
    DWORD dwLength;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::SetPrincipal");
    TraceAssert(pSID != NULL);
    TraceAssert(IsValidSid(pSID));

    if (NULL != m_pSID)
        LocalFree(m_pSID);

    m_pSID = LocalAllocSid(pSID);

    SetSidType(sidType);
    SetName(pszName, pszLogonName);

    TraceLeaveValue(NULL != m_pSID);
}


BOOL
CPrincipal::SetName(LPCTSTR pszName, LPCTSTR pszLogonName)
{
    LocalFreeString(&m_pszName);
    m_bHaveRealName = FALSE;

    if (BuildUserDisplayName(&m_pszName, pszName, pszLogonName))
        m_bHaveRealName = TRUE;
    else
        ConvertSidToStringSid(m_pSID, &m_pszName);
    
    if(pszName)
    {
        LocalFreeString(&m_pszDisplayName);
        LocalAllocString(&m_pszDisplayName, pszName);
    }           

    return (NULL != m_pszName);
}


CPermissionSet*
CPrincipal::GetPermSet(DWORD dwType, BOOL bInherited)
{
    CPermissionSet *pPermSet = NULL;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::GetPermSet");

    switch (dwType)
    {
    case ACCESS_DENIED_ACE_TYPE:
        if (bInherited)
            pPermSet = &m_permInheritedDeny;
        else
            pPermSet = &m_permDeny;
        break;

    case ACCESS_ALLOWED_ACE_TYPE:
        if (bInherited)
            pPermSet = &m_permInheritedAllow;
        else
            pPermSet = &m_permAllow;
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        // We don't handle compound ACEs
        TraceMsg("Ignoring ACCESS_ALLOWED_COMPOUND_ACE");
        break;

#ifdef DEBUG
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
    default:
        // We only process the various ACCESS_ALLOWED_* and ACCESS_DENIED_*
        // ACE types, except for ACCESS_ALLOWED_COMPOUND_ACE_TYPE, and these
        // are all accounted for above.  Something is very wrong if we get
        // an audit/alarm ACE or some unknown/future ACE type.
        TraceAssert(FALSE);
        break;
#endif
    }

    TraceLeaveValue(pPermSet);
}

BOOL
CPrincipal::AddNormalAce(DWORD dwType, DWORD dwFlags, ACCESS_MASK mask, const GUID *pObjectType)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::AddNormalAce");

    CPermissionSet *pPermSet = GetPermSet(dwType, (BOOL)(dwFlags & INHERITED_ACE));
    if (pPermSet)
        fResult = pPermSet->AddAce(pObjectType, mask, dwFlags);

    TraceLeaveValue(fResult);
}


BOOL
CPrincipal::AddAdvancedAce(DWORD dwType, PACE_HEADER pAce)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::AddAdvancedAce");

    CPermissionSet *pPermSet = GetPermSet(dwType, AceInherited(pAce));
    if (pPermSet)
        fResult = pPermSet->AddAdvancedAce(pAce);

    TraceLeaveValue(fResult);
}


BOOL
CPrincipal::AddAce(PACE_HEADER pAce)
{
    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::AddAce");
    TraceAssert(pAce != NULL);

    BOOL fResult = FALSE;
    const GUID *pObjectType = NULL;
    UCHAR AceType = pAce->AceType;
    UCHAR AceFlags = pAce->AceFlags;
    ACCESS_MASK AccessMask = ((PKNOWN_ACE)pAce)->Mask;
    ULONG ulObjectFlags = 0;

    // Get the object type GUID from object ACEs
    if (IsObjectAceType(pAce))
    {
        AceType -= (ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE);
        ulObjectFlags = ((PKNOWN_OBJECT_ACE)pAce)->Flags;

        if (m_pPage->m_wDaclRevision < ACL_REVISION_DS)
            m_pPage->m_wDaclRevision = ACL_REVISION_DS;

        pObjectType = RtlObjectAceObjectType(pAce);
    }

    if (!pObjectType)
        pObjectType = &GUID_NULL;

    // Map any generic bits to standard & specific bits.
    m_pPage->m_psi->MapGeneric(pObjectType, &AceFlags, &AccessMask);

    // Can't have INHERIT_ONLY_ACE without either CONTAINER_INHERIT_ACE or
    // OBJECT_INHERIT_ACE, so if we find one of these, skip it.
    if ((AceFlags & (INHERIT_ONLY_ACE | ACE_INHERIT_ALL)) != INHERIT_ONLY_ACE)
    {
        //
        //ACE_INHERITED_OBJECT_TYPE_PRESENT is invalid without
        //either of container inherit or object inherit flags.
        //NTRAID#NTBUG9-287737-2001/01/23-hiteshr
        //
        if (ulObjectFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT && 
            AceFlags & ACE_INHERIT_ALL)
        {
            // If we have an inherit object type without INHERIT_ONLY_ACE,
            // and the inherit object type matches the current object,
            // then it applies to this object.  Simulate this (per the
            // ACL inheritance spec) with 2 ACEs: one with no inheritance
            // at all, and one with the inherit type + INHERIT_ONLY_ACE.

            // Does it apply to this object?
            if ((m_pPage->m_siObjectInfo.dwFlags & SI_OBJECT_GUID) &&
                !(AceFlags & INHERIT_ONLY_ACE) &&
                IsSameGUID(&m_pPage->m_siObjectInfo.guidObjectType, RtlObjectAceInheritedObjectType(pAce)))
            {
                // Mask out all flags except INHERITED_ACE and add it
                AddNormalAce(AceType, (AceFlags & INHERITED_ACE), AccessMask, pObjectType);

                // Turn on INHERIT_ONLY_ACE before adding the "advanced" ACE.
                pAce->AceFlags |= INHERIT_ONLY_ACE;
            }

            // The ACE does not apply directly to this object
            fResult = AddAdvancedAce(AceType, pAce);
        }
        else
        {
            fResult = AddNormalAce(AceType, AceFlags, AccessMask, pObjectType);
        }
    }

    TraceLeaveValue(fResult);
}


ULONG
CPrincipal::GetAclLength(DWORD dwFlags)
{
    // Return an estimate of the buffer size needed to hold the
    // requested ACEs. The size of the ACL header is NOT INCLUDED.

    // The following flags are always assumed:
    // ACL_DENY | ACL_ALLOW | ACL_NONOBJECT | ACL_OBJECT

    ULONG nAclLength = 0;
    ULONG nSidLength;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::GetAclLength");
    TraceAssert(NULL != m_pSID);

    if (NULL == m_pSID)
        TraceLeaveValue(0);

    nSidLength = GetLengthSid(m_pSID);

    if (dwFlags & ACL_NONINHERITED)
    {
        nAclLength += m_permDeny.GetAclLength(nSidLength);
        nAclLength += m_permAllow.GetAclLength(nSidLength);
    }

    if (dwFlags & ACL_INHERITED)
    {
        nAclLength += m_permInheritedDeny.GetAclLength(nSidLength);
        nAclLength += m_permInheritedAllow.GetAclLength(nSidLength);
    }

    TraceLeaveValue(nAclLength);
}

BOOL
CPrincipal::AppendToAcl(PACL pAcl,
                        DWORD dwFlags,
                        PACE_HEADER *ppAcePos)  // position to copy first ACE
{
    PACE_HEADER pAceT;

    TraceEnter(TRACE_PRINCIPAL, "CPrincipal::AppendToAcl");
    TraceAssert(pAcl != NULL && IsValidAcl(pAcl));
    TraceAssert(ppAcePos != NULL);
    TraceAssert(NULL != m_pSID);

    if (NULL == m_pSID)
        TraceLeaveValue(FALSE);

    pAceT = *ppAcePos;

    // Build the ACL in the following order:
    //      Deny
    //      Allow
    //      Inherited Deny
    //      Inherited Allow

    if (dwFlags & ACL_NONINHERITED)
    {
        if (dwFlags & ACL_DENY)
            m_permDeny.AppendToAcl(pAcl, ppAcePos, m_pSID, FALSE, dwFlags);

        if (dwFlags & ACL_ALLOW)
            m_permAllow.AppendToAcl(pAcl, ppAcePos, m_pSID, TRUE, dwFlags);
    }

    if (dwFlags & ACL_INHERITED)
    {
        if (dwFlags & ACL_DENY)
            m_permInheritedDeny.AppendToAcl(pAcl, ppAcePos, m_pSID, FALSE, dwFlags);

        if (dwFlags & ACL_ALLOW)
            m_permInheritedAllow.AppendToAcl(pAcl, ppAcePos, m_pSID, TRUE, dwFlags);
    }

    //Remveod the special casing for CREATOR_OWNER
    //NTRAID#NTBUG9-467049-2001/11/29-hiteshr

    TraceAssert(IsValidAcl(pAcl));
    TraceLeaveValue(TRUE);
}


BOOL
CPrincipal::HaveInheritedAces(void)
{
    return (m_permInheritedAllow.GetPermCount(TRUE) || m_permInheritedDeny.GetPermCount(TRUE));
}


void
CPrincipal::ConvertInheritedAces(BOOL bDelete)
{
    if (bDelete)
    {
        m_permInheritedDeny.Reset();
        m_permInheritedAllow.Reset();
    }
    else
    {
        m_permDeny.ConvertInheritedAces(m_permInheritedDeny);
        m_permAllow.ConvertInheritedAces(m_permInheritedAllow);
    }
}


void
CPrincipal::AddPermission(BOOL bAllow, PPERMISSION pperm)
{
    if (bAllow)
        m_permAllow.AddPermission(pperm);
    else
        m_permDeny.AddPermission(pperm);
}


void
CPrincipal::RemovePermission(BOOL bAllow, PPERMISSION pperm)
{
    if (bAllow)
        m_permAllow.RemovePermission(pperm);
    else
        m_permDeny.RemovePermission(pperm);
}


//
// CPermPage implementation
//

void
CPermPage::InitPrincipalList(HWND hDlg, PACL pDacl)
{
    TraceEnter(TRACE_PERMPAGE, "CPermPage::InitPrincipalList");
    TraceAssert(hDlg != NULL);

    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    TraceAssert(hwndList != NULL);

    // Save the DACL revision
    if (pDacl != NULL)
    {
        m_wDaclRevision = pDacl->AclRevision;
    }

    // If we have a selection, remember the SID for later
    PSID psidTemp = NULL;
    LPPRINCIPAL pPrincipal = (LPPRINCIPAL)GetSelectedItemData(hwndList, NULL);
    if (pPrincipal != NULL)
        psidTemp = LocalAllocSid(pPrincipal->GetSID());

    // Empty out the list
    ListView_DeleteAllItems(hwndList);

    // Enumerate the new DACL and fill the list
    EnumerateAcl(hwndList, pDacl);

    // Try to re-select the previously selection
    if (psidTemp != NULL)
    {
        int cItems = ListView_GetItemCount(hwndList);

        LV_ITEM lvItem;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;

        // Look for the previously selected principal in the list
        while (cItems > 0)
        {
            --cItems;
            lvItem.iItem = cItems;

            ListView_GetItem(hwndList, &lvItem);
            pPrincipal = (LPPRINCIPAL)lvItem.lParam;

            if (EqualSid(psidTemp, pPrincipal->GetSID()))
            {
                SelectListViewItem(hwndList, cItems);
                break;
            }
        }

        LocalFree(psidTemp);
    }

    TraceLeaveVoid();
}



STDMETHODIMP
_InitCheckList(HWND hwndList,
               LPSECURITYINFO psi,
               const GUID* pguidObjectType,
               DWORD dwFlags,
               HINSTANCE hInstance,
               DWORD dwType,
               PSI_ACCESS *ppDefaultAccess)
{
    HRESULT hr;
    PSI_ACCESS pAccess;
    ULONG cAccesses;
    ULONG iDefaultAccess;
    TCHAR szName[MAX_PATH];

    TraceEnter(TRACE_MISC, "_InitCheckList");
    TraceAssert(psi != NULL);

    //
    // Retrieve the permission list
    //
    hr = psi->GetAccessRights(pguidObjectType,
                              dwFlags,
                              &pAccess,
                              &cAccesses,
                              &iDefaultAccess);
    if (SUCCEEDED(hr) && cAccesses > 0)
    {
        if (ppDefaultAccess != NULL)
            *ppDefaultAccess = &pAccess[iDefaultAccess];

        // Enumerate the permissions and add to the checklist
        for (ULONG i = 0; i < cAccesses; i++, pAccess++)
        {
            LPCTSTR pszName;

            // Only add permissions that have any of the flags specified in dwType
            if (!(pAccess->dwFlags & dwType))
                continue;

            pszName = pAccess->pszName;
            if (IS_INTRESOURCE(pszName))
            {
                TraceAssert(hInstance != NULL);

                if (LoadString(hInstance,
                               (UINT)((ULONG_PTR)pszName),
                               szName,
                               ARRAYSIZE(szName)) == 0)
                {
                    LoadString(::hModule,
                               IDS_UNKNOWN,
                               szName,
                               ARRAYSIZE(szName));
                }
                pszName = szName;
            }

            if (SendMessage(hwndList,
                            CLM_ADDITEM,
                            (WPARAM)pszName,
                            (LPARAM)pAccess) == -1)
            {
                DWORD dwErr = GetLastError();
                ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Failed to add item to checklist");
            }
        }
    }

exit_gracefully:

    TraceLeaveResult(hr);
}



HRESULT
CPermPage::InitCheckList(HWND hDlg)
{
    HRESULT hr;
    TCHAR szName[MAX_PATH];
    PSI_ACCESS pAccess;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::InitCheckList");
    TraceAssert(hDlg != NULL);


    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);    // checklist window
    TraceAssert(hwndList != NULL);

    DWORD dwType = SI_ACCESS_GENERAL;
    if (m_siObjectInfo.dwFlags & SI_CONTAINER)
        dwType |= SI_ACCESS_CONTAINER;

    // Enumerate the permissions and add to the checklist
    hr = _InitCheckList(hwndList,
                        m_psi,
                        NULL,
                        0,
                        m_siObjectInfo.hInstance,
                        dwType,
                        &m_pDefaultAccess);
    if (SUCCEEDED(hr))
    {
        //Add Custom Checkbox at the   bottom of checklist. Custom checkbox is added only if
        //Advanced Page is there
        if(m_bCustomPermission)
        {
                pAccess = &m_CustomAccess;
                ZeroMemory(pAccess, sizeof(SI_ACCESS));
            
                pAccess->dwFlags = SI_ACCESS_CUSTOM; 

                LoadString(::hModule, IDS_CUSTOM, szName, ARRAYSIZE(szName));

                if (SendMessage(hwndList, CLM_ADDITEM, (WPARAM)szName, (LPARAM)pAccess) == -1)
                {
                    DWORD dwErr = GetLastError();
                    ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Failed to add item to checklist");
                }
                //
                //Disable the custom checkbox
                //                
                ClearCustom(hwndList,1);
                ClearCustom(hwndList,2);
        }
    }
exit_gracefully:        
    TraceLeaveResult(hr);
}


//
// CAUTION  - This function modifies the ACEs in the ACL by setting
//            the AceType to 0xff (an invalid ACE type).
//
//This function goes through the ACL and groups the aces
//according to SID in PRINCIPAL objects.

void
CPermPage::EnumerateAcl(HWND hwndList, PACL pAcl)
{
    LPPRINCIPAL pPrincipal;
    PACE_HEADER pAce;
    int         iEntry;
    int         iTemp;
    PACE_HEADER paceTemp;
    HDPA        hSids = NULL;

    if (pAcl == NULL)
        return;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::EnumerateAcl");

    TraceAssert(IsValidAcl(pAcl));
    TraceAssert(hwndList != NULL);

    hSids = DPA_Create(4);

    if (NULL == hSids)
        TraceLeaveVoid();

    for (iEntry = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
         iEntry < pAcl->AceCount;
         iEntry++, pAce = (PACE_HEADER)NextAce(pAce))
    {
        // Skip ACEs that we've already seen
        if (pAce->AceType == 0xff)
            continue;

        // Found an ACE we haven't seen yet, must be a new principal
        pPrincipal = new CPrincipal(this);
        if (pPrincipal == NULL)
            continue;  // memory error (try to continue)

        // Initialize new principal
        if (!pPrincipal->SetPrincipal(GetAceSid(pAce)))
        {
            delete pPrincipal;
            continue;  // probably memory error (try to continue)
        }

        // Remember the SIDs so that later we can look up all the names
        // at once and then add them to the listview.
        DPA_AppendPtr(hSids, pPrincipal->GetSID());

         // The current ACE belongs to this principal, so add it
        pPrincipal->AddAce(pAce);

        // Mark the ACE so we don't look at it again
        pAce->AceType = 0xff;

        // Loop through the rest of the ACEs in the ACL looking
        // for the same SID
        paceTemp = pAce;
        for (iTemp = iEntry + 1; iTemp < pAcl->AceCount; iTemp++)
        {
            // Move pointer to the current ACE
            paceTemp = (PACE_HEADER)NextAce(paceTemp);

            // If this ACE belongs to the current principal, add it
            if (paceTemp->AceType != 0xff &&
                EqualSid(GetAceSid(paceTemp), pPrincipal->GetSID()))
            {
                // Same principal, add the ACE
                pPrincipal->AddAce(paceTemp);

                // Mark the ACE so we don't look at it again
                paceTemp->AceType = 0xff;
            }
        }

        if (-1 == AddPrincipalToList(hwndList, pPrincipal))
        {
            delete pPrincipal;
        }
    }

    // Launch thread to look up sids
    m_fBusy = TRUE;
    LookupSidsAsync(hSids,
                    m_siObjectInfo.pszServerName,
                    m_psi2,
                    GetParent(hwndList),
                    UM_SIDLOOKUPCOMPLETE);
    DPA_Destroy(hSids);

    TraceLeaveVoid();
}


HRESULT
CPermPage::SetPrincipalNamesInList(HWND hwndList, PSID pSid)
{
    TraceEnter(TRACE_PERMPAGE, "CPermPage::SetPrincipalNamesInList");

    HRESULT hr = S_OK;
    PUSER_LIST  pUserList = NULL;
    LPPRINCIPAL pPrincipal = NULL;
    LVITEM lvItem = {0};
    int cListItems;
    int iListItem;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Enumerate through each entry in the list view
    cListItems = ListView_GetItemCount(hwndList);
    for (iListItem = 0; iListItem < cListItems; iListItem++)
    {
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iListItem;
        lvItem.iSubItem = 0;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            pPrincipal = (LPPRINCIPAL) lvItem.lParam;

            if (pPrincipal != NULL)
            {
                // Are we looking for a particular principal?
                if (pSid && !EqualSid(pSid, pPrincipal->GetSID()))
                    continue;

                // Do we already have a good name?
                if (pPrincipal->HaveRealName())
                {
                    if (pSid)
                        break;  // only care about this principal, stop here
                    else
                        continue;   // skip this one and check the rest
                }

                // Lookup the SID for this principal in the cache
                LookupSid(pPrincipal->GetSID(),
                          m_siObjectInfo.pszServerName,
                          m_psi2,
                          &pUserList);

                if ((pUserList != NULL) && (pUserList->cUsers == 1))
                {
                    // The list should contain a single item
                    PUSER_INFO pUserInfo = &pUserList->rgUsers[0];

                    // Update the principal with this new name information
                    pPrincipal->SetSidType(pUserInfo->SidType);
                    pPrincipal->SetName(pUserInfo->pszName, pUserInfo->pszLogonName);

                    // Set the text of this item to the name we've found
                    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
                    lvItem.pszText = (LPTSTR)pPrincipal->GetName();
                    lvItem.iImage = pPrincipal->GetImageIndex();
                    ListView_SetItem(hwndList, &lvItem);

                    LocalFree(pUserList);
                }
            }
        }
    }

    SetCursor(hcur);

    TraceLeaveResult(hr);
}


int
CPermPage::AddPrincipalToList(HWND hwndList, LPPRINCIPAL pPrincipal)
{
    LVITEM lvItem;
    int iIndex = -1;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::AddPrincipalToList");
    TraceAssert(hwndList != NULL);
    TraceAssert(pPrincipal != NULL);

    // Insert new principal into listview
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;
    lvItem.lParam = (LPARAM)pPrincipal;
    lvItem.pszText = (LPTSTR)pPrincipal->GetName();
    lvItem.iImage = pPrincipal->GetImageIndex();

    iIndex = ListView_InsertItem(hwndList, &lvItem);

    TraceLeaveValue(iIndex);
}

VOID 
CPermPage::SetPermLabelText(HWND hDlg)
{
    RECT rcLabel;
    WCHAR szBuffer[MAX_COLUMN_CHARS];
    HWND hwndLabel;
    HWND hwndList;
    LPTSTR pszCaption = NULL;
    SIZE size;
    LPCWSTR pszUserName = NULL;
    CPrincipal * pPrincipal = NULL;
    int iIndex = 0;

    //Get the text to display
    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    pPrincipal = (LPPRINCIPAL)GetSelectedItemData(hwndList, &iIndex);
    if(pPrincipal)
        pszUserName = pPrincipal->GetDisplayName();

    if(pszUserName)
        FormatStringID(&pszCaption, ::hModule, IDS_DYNAMIC_PERMISSION,pszUserName);
    else    
        FormatStringID(&pszCaption, ::hModule, IDS_PERMISSIONS, NULL);

    //Get Label Dimension
    hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS);
    GetClientRect(hwndLabel, &rcLabel);

    //Get the device context and set its font to font of label
    HDC hdc = GetDC(hwndLabel);
    SelectObject(hdc,(HGDIOBJ)SendMessage(hwndLabel,WM_GETFONT,0,0));

    BOOL bUseBig = false;
    RECT rcText = {0};
    if( DrawText(hdc, pszCaption, wcslen(pszCaption), &rcText, DT_CALCRECT)
       && rcText.right > rcLabel.right )
    {
       bUseBig = true;
    }

   if(bUseBig)
   {
       hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS);
       EnableWindow(hwndLabel, FALSE);
       ShowWindow(hwndLabel,SW_HIDE);
       hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS_BIG);
       EnableWindow(hwndLabel, TRUE);
       ShowWindow(hwndLabel,SW_SHOW);
       SetWindowText(hwndLabel,pszCaption);
   }
   else
   {
       hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS_BIG);
       EnableWindow(hwndLabel, FALSE);
       ShowWindow(hwndLabel,SW_HIDE);
       hwndLabel = GetDlgItem(hDlg, IDC_SPP_ACCESS);
       EnableWindow(hwndLabel, TRUE);
       ShowWindow(hwndLabel,SW_SHOW);
       SetWindowText(hwndLabel,pszCaption);
   }

   LocalFreeString(&pszCaption);
   ReleaseDC(hDlg, hdc);
}


BOOL
CPermPage::InitDlg(HWND hDlg)
{
    HRESULT hr = S_OK;
    HWND hwnd;
    HWND hwndList;
    RECT rc;
    LV_COLUMN col;
    TCHAR szBuffer[MAX_COLUMN_CHARS];
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL bUserNotified = FALSE;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
     BOOL bCallBackAces = FALSE;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::InitDlg");
    TraceAssert(hDlg != NULL);
    TraceAssert(m_psi != NULL);

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    
    //
    // Create & set the image list for the listview.  If there is a
    // problem CreateSidImageList will return NULL which won't hurt
    // anything. In that case we'll just continue without an image list.
    //
    ListView_SetImageList(hwndList,
                          LoadImageList(::hModule, MAKEINTRESOURCE(IDB_SID_ICONS)),
                          LVSIL_SMALL);

    // Set extended LV style for whole line selection with InfoTips
    ListView_SetExtendedListViewStyleEx(hwndList,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP,
                                        LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

    //
    // Add appropriate listview columns
    //
    GetClientRect(hwndList, &rc);

    col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.iSubItem = 0;
    col.cx = rc.right;
    ListView_InsertColumn(hwndList, 0, &col);


    if (!(m_siObjectInfo.dwFlags & SI_ADVANCED))
    {
        // Hide the Advanced button
        hwnd = GetDlgItem(hDlg, IDC_SPP_ADVANCED);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
        hwnd = GetDlgItem(hDlg, IDC_SPP_STATIC_ADV);
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }


    if (S_FALSE == m_hrLastPSPCallbackResult)
    {
        // The propsheetpage callback told us to not show any messages here.
        bUserNotified = TRUE;
    }

    //Additional Permissions?
    m_bCustomPermission =  (m_siObjectInfo.dwFlags & SI_ADVANCED) 
                            && !(m_siObjectInfo.dwFlags & SI_NO_ADDITIONAL_PERMISSION);
    
    if (m_bAbortPage)
    {
        // Disable everything except the Advanced button
        m_siObjectInfo.dwFlags |= SI_READONLY;
        EnableWindow(hwndList, FALSE);

        // The user should have been notified during the propsheetpage
        // callback, so don't put up another message now.
        bUserNotified = TRUE;
    }
    else
    {
        //
        // Initialize the checklist window
        //
        hr = InitCheckList(hDlg);
        FailGracefully(hr, "Failed to initialize checklist");

        //
        // Retrieve the DACL from the object and set it into the dialog
        //
        hr = m_psi->GetSecurity(DACL_SECURITY_INFORMATION, &pSD, FALSE);

        if(hr == S_FALSE)
        {
            //ISecuirtyInformation impelmentation has already shown
            //error message. This is fatal failure and we should
            //disable all the controls
            hr = E_FAIL;
            FailGracefully(hr, "GetSecurity returned S_FALSE");
        }
        else if (SUCCEEDED(hr))
        {

               //Check if there are any call back aces. We don't support
               //callback aces
                if(bCallBackAces = IsCallBackAcePresentInSD(pSD))
                {
                    hr = E_FAIL;
                    FailGracefully(hr, "Callback Aces present");
                }               
            // We always disable the advanced button until the SID name cache
            // is filled on our other thread. See the DlgProc handler for
            // UM_SIDLOOKUPCOMPLETE
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_ADVANCED), FALSE);

            hr = SetDacl(hDlg, pSD);
            FailGracefully(hr, "SetDacl failed");
        }
        else if (hr == E_ACCESSDENIED)
        {
            if (!bUserNotified)
            {
                //
                // Can't read the DACL or Owner, figure out what we CAN do.
                //
                UINT idMsg = IDS_PERM_NO_ACCESS;
                UINT mbType = MB_OK | MB_ICONWARNING;

                if (!(m_siObjectInfo.dwFlags & SI_READONLY))
                {
                    if(!( m_siObjectInfo.dwFlags & SI_MAY_WRITE))
                        idMsg = IDS_PERM_CANT_READ_CAN_WRITE_DACL;
                    else
                        idMsg = IDS_PERM_CANT_READ_MAY_WRITE_DACL;
                }
                else
                {
                    //
                    // Can't write the DACL, can we write the owner or edit the SACL?
                    //
                    DWORD dwFlags = m_siObjectInfo.dwFlags & (SI_EDIT_AUDITS | SI_OWNER_READONLY);

                    // If we're not editing the owner, then we can't write it.
                    if (!(m_siObjectInfo.dwFlags & SI_EDIT_OWNER))
                        dwFlags |= SI_OWNER_READONLY;

                    switch(dwFlags)
                    {
                    case 0:
                        {
                            // Can write the Owner but can't edit the SACL
                            idMsg = IDS_PERM_CANT_READ_CAN_WRITE_OWNER;
                            m_bNoReadWriteCanWriteOwner = TRUE;
                        }
                        break;

                    case SI_EDIT_AUDITS:
                        {
                            // Can edit the SACL and write the Owner
                            m_bNoReadWriteCanWriteOwner = TRUE;
                            idMsg = IDS_PERM_CANT_READ_CAN_AUDIT_WRITE_OWNER;
                        }
                        break;

                    case SI_OWNER_READONLY:
                        // No Access
                        break;

                    case SI_OWNER_READONLY | SI_EDIT_AUDITS:
                        // Can edit the SACL but can't write the Owner
                        idMsg = IDS_PERM_CANT_READ_CAN_AUDIT;
                        break;
                    }
                }

                if (idMsg == IDS_PERM_NO_ACCESS)
                    mbType = MB_OK | MB_ICONERROR;

                MsgPopup(hDlg,
                         MAKEINTRESOURCE(idMsg),
                         MAKEINTRESOURCE(IDS_SECURITY),
                         mbType,
                         ::hModule,
                         m_siObjectInfo.pszObjectName);
                bUserNotified = TRUE;
            }

            EnablePrincipalControls(hDlg, FALSE);
            hr = S_OK;
        }
        else
        {
            FailGracefully(hr, "GetSecurity failed");
        }
    } // !m_bAbortPage

    if (m_siObjectInfo.dwFlags & SI_READONLY)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_ADD), FALSE);
        EnablePrincipalControls(hDlg, FALSE);
    }

exit_gracefully:

    if (pSD != NULL)
        LocalFree(pSD);

    SetCursor(hcur);

    if (FAILED(hr))
    {
        // Hide and disable everything
        for (hwnd = GetWindow(hDlg, GW_CHILD);
             hwnd != NULL;
             hwnd = GetWindow(hwnd, GW_HWNDNEXT))
        {
            ShowWindow(hwnd, SW_HIDE);
            EnableWindow(hwnd, FALSE);
        }

          if(bCallBackAces)
          {
              WCHAR szBuf[1024];
              LoadString(::hModule,IDS_CALLBACK_ACE_PRESENT,szBuf,ARRAYSIZE(szBuf));
              SetDlgItemText(hDlg,IDC_SPP_NO_SECURITY,szBuf);
          }
        // Enable and show the "No Security" message
        hwnd = GetDlgItem(hDlg, IDC_SPP_NO_SECURITY);
        EnableWindow(hwnd, TRUE);
        ShowWindow(hwnd, SW_SHOW);
    }

    TraceLeaveValue(TRUE);
}


BOOL
CPermPage::OnNotify(HWND hDlg, int /*idCtrl*/, LPNMHDR pnmh)
{
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pnmh;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnNotify");
    TraceAssert(hDlg != NULL);
    TraceAssert(pnmh != NULL);

    // Set default return value
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

    switch (pnmh->code)
    {
    case LVN_ITEMCHANGED:
        if (pnmlv->uChanged & LVIF_STATE)
        {
            OnSelChange(hDlg);
            // item *gaining* selection
            if ((pnmlv->uNewState & LVIS_SELECTED) &&
                !(pnmlv->uOldState & LVIS_SELECTED))
            {
               //here bClearCustom should be False. We don't need to clear 
               //Custom when we select another principal. 
               //Build Additional List for it.
            }
            // item *losing* selection
            else if (!(pnmlv->uNewState & LVIS_SELECTED) &&
                     (pnmlv->uOldState & LVIS_SELECTED))
            {
                // Post ourselves a message to check for a new selection later.
                // If we haven't gotten a new selection by the time we process
                // this message, then assume the user clicked inside the listview
                // but not on an item, thus causing the listview to remove the
                // selection.  In that case, disable the combobox & Remove button.
                //
                // Do this via WM_COMMAND rather than WM_NOTIFY so we don't
                // have to allocate/free a NMHDR structure.
                PostMessage(hDlg,
                            WM_COMMAND,
                            GET_WM_COMMAND_MPS(pnmh->idFrom, pnmh->hwndFrom, IDN_CHECKSELECTION));
            }
        }
        break;

    case LVN_DELETEITEM:
        delete (LPPRINCIPAL)pnmlv->lParam;
        break;

    case LVN_KEYDOWN:
        if (((LPNMLVKEYDOWN)pnmh)->wVKey == VK_DELETE)
        {
            //Get the status of Remove button. Only if remove is 
            //enabled do something bug 390243
            if( IsWindowEnabled( GetDlgItem( hDlg,IDC_SPP_REMOVE )) )
                OnRemovePrincipal(hDlg);
        }
        break;

#ifdef UNUSED
    case NM_DBLCLK:
        if (pnmh->idFrom == IDC_SPP_PRINCIPALS)
        {
            // Must have a selection to get here
            TraceAssert(ListView_GetSelectedCount(pnmh->hwndFrom) == 1);

            // do something here
        }
        break;
#endif

    case CLN_CLICK:
        if (pnmh->idFrom == IDC_SPP_PERMS)
        {
            LPPRINCIPAL pPrincipal;
            int iIndex = -1;
            
            pPrincipal = (LPPRINCIPAL)GetSelectedItemData(GetDlgItem(hDlg, IDC_SPP_PRINCIPALS), &iIndex);
            if (pPrincipal)
            {
                PNM_CHECKLIST   pnmc    = (PNM_CHECKLIST)pnmh;
                PSI_ACCESS      pAccess = (PSI_ACCESS)pnmc->dwItemData;
                
                //Custom checkbox is clicked, reqiures special handling
                if( pAccess->dwFlags & SI_ACCESS_CUSTOM )
                {
                    if (pnmc->dwState & CLST_CHECKED)
                    {                                            
                        //Uncheck the Checkbox. Can checkbox be prevented from checked?
                        SendMessage(pnmc->hdr.hwndFrom,
                                    CLM_SETSTATE,
                                    MAKELONG((WORD)pnmc->iItem, (WORD)pnmc->iSubItem),
                                    0
                                    );       
                        
                        //Show the message box
                        MsgPopup(hDlg,
                                 MAKEINTRESOURCE(IDS_CUSTOM_CHECKBOX_WARNING),
                                 MAKEINTRESOURCE(IDS_SECURITY),
                                 MB_OK | MB_ICONINFORMATION,
                                 ::hModule);
                                          
                    }
                    else
                    {
                        SetDirty(hDlg);
                        //Clear the Special Checkbox and Permissions
                        BOOL bClearAllow = (1 == pnmc->iSubItem);    // 1 = Allow, 2 = Deny
                        OnSelChange(hDlg, TRUE, bClearAllow, !bClearAllow);
                    }
                    //Break out of Switch
                    break;
                }
            }


            //
            // HandleListClick decides which boxes should be checked and
            // unchecked, however, we can't rely only on that to generate
            // ACLs (we used to).  Suppose the principal has Full Control and
            // the user unchecks "Delete" which is a single bit.  If there is
            // no checkbox corresponding to "Full Control minus Delete" then
            // the principal would also lose other bits, such as WRITE_DAC.
            //
            // So let HandleListClick do its thing. Then remove permission
            // bits according to what was checked or unchecked.
            //
            // But wait, there's more. Removing permission bits turns off
            // too much. For example, if the principal has Full Control and
            // the user turns off Full Control, then the principal ends up
            // with nothing, even though HandleListClick leaves Modify
            // checked.
            //
            // So after removing what was just (un)checked, build new
            // permissions from what is still checked and add them.
            //
            // This yields the correct results, and also keeps the principal
            // up-to-date so we don't need to call CommitCurrent anywhere else.
            //
            // Raid 260952
            //

            //HandleListClick decides which boxes should be checked and unchecked.
            //If FullControl was intially Checked, we uncheck Read, Full Control is
            //also unchecked. If a checkbox was intially checked and unchecked in 
            //HandleListClick, its added to h[Allow/Deny]UncheckedAccess list.
            //Permission corresponding to these checkboxes is removed.
            

            // Check/uncheck appropriate boxes in both columns
            HDSA hAllowUncheckedAccess = NULL;
            HDSA hDenyUncheckedAccess = NULL;

            //Does appropriate check-uncheck.

            HandleListClick((PNM_CHECKLIST)pnmh,
                            SI_PAGE_PERM,
                            m_siObjectInfo.dwFlags & SI_CONTAINER,
                            &hAllowUncheckedAccess,
                            &hDenyUncheckedAccess,
                            m_bCustomPermission);

            pPrincipal = (LPPRINCIPAL)GetSelectedItemData(GetDlgItem(hDlg, IDC_SPP_PRINCIPALS), &iIndex);
            if (pPrincipal)
            {
                PNM_CHECKLIST   pnmc    = (PNM_CHECKLIST)pnmh;
                PSI_ACCESS      pAccess = (PSI_ACCESS)pnmc->dwItemData;
                PERMISSION      perm    = { pAccess->mask, 0, 0 };

                //If we uncheck Allow Read, Allow Read Checkbox goes into HandleListClick as
                //unchecked and is not in hAllowUncheckedAccess. Perm Corresponding to it 
                //especially removed.
                if(!(pnmc->dwState & CLST_CHECKED))
                {
                    // Which column was clicked?
                    BOOL bRemoveFromAllow = (1 == pnmc->iSubItem);    // 1 = Allow, 2 = Deny

                    if (pAccess->pguid)
                        perm.guid = *pAccess->pguid;

                    if (m_siObjectInfo.dwFlags & SI_CONTAINER)
                        perm.dwFlags = pAccess->dwFlags & VALID_INHERIT_FLAGS;

                    pPrincipal->RemovePermission(bRemoveFromAllow, &perm);
                }

                if( hAllowUncheckedAccess )
                {
                    UINT cItems = DSA_GetItemCount(hAllowUncheckedAccess);
                    PERMISSION permTemp;
                    while (cItems)
                    {
                        --cItems;
                        DSA_GetItem(hAllowUncheckedAccess, cItems, &pAccess);
                        permTemp.mask = pAccess->mask;
                        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
                            permTemp.dwFlags = pAccess->dwFlags & VALID_INHERIT_FLAGS;
                        if( pAccess->pguid )
                            permTemp.guid = *pAccess->pguid;
                    
                        pPrincipal->RemovePermission(TRUE, &permTemp);
                    }
                    DSA_Destroy(hAllowUncheckedAccess);
                }

                if( hDenyUncheckedAccess )
                {
                    UINT cItems = DSA_GetItemCount(hDenyUncheckedAccess);
                    PERMISSION permTemp;
                    PSI_ACCESS pAccess2 = NULL;
                    while (cItems)
                    {
                        --cItems;
                        DSA_GetItem(hDenyUncheckedAccess, cItems, &pAccess2);
                        permTemp.mask = pAccess2->mask;
                        if (m_siObjectInfo.dwFlags & SI_CONTAINER)
                            permTemp.dwFlags = pAccess2->dwFlags & VALID_INHERIT_FLAGS;
                        if( pAccess2->pguid )
                            permTemp.guid = *pAccess2->pguid;
                    
                        pPrincipal->RemovePermission(FALSE, &permTemp);
                    }
                    DSA_Destroy(hDenyUncheckedAccess);
                }
            }

            SetDirty(hDlg);

            // Add perms according to what is still checked. This is required, since 
            // when i uncheck Read, full control is also unchecked and permission corresponding to 
            // it is removed. This will remove Write also, though its still checked.
            //CommitCurrent will add permission for checkboxes which are still checked.
            CommitCurrent(hDlg, iIndex);

            //Here i should add additional list to main list, but no need to rebuild addtional list

            // Reset the "There is more stuff" message
            OnSelChange(hDlg, FALSE);
        }
        break;

    case CLN_GETCOLUMNDESC:
        {
            PNM_CHECKLIST pnmc = (PNM_CHECKLIST)pnmh;
            GetDlgItemText(hDlg,
                           IDC_SPP_ALLOW - 1 + pnmc->iSubItem,
                           pnmc->pszText,
                           pnmc->cchTextMax);
        }
        break;

    case PSN_APPLY:
        OnApply(hDlg, (BOOL)(((LPPSHNOTIFY)pnmh)->lParam));
        break;
    default:
        TraceLeaveValue(FALSE); // message not handled
    }

    TraceLeaveValue(TRUE);  // message handled
}


    

BOOL
CheckPermissions(HWND hwndList,
                 CPermissionSet &PermSet,
                 WORD wColumn,
                 BOOL bDisabled,
                 BOOL bInheritFlags,
                 BOOL bCustom,      //Does Custom Checkbox exist?
                 BOOL bClearCustom,
                 HDSA hAdditional )//Clear Custom Permissions?
{
    UINT cRights = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    //Custom Checkbox is handled separately the end.
    if( bCustom )
        --cRights;
    
    UINT cAces = PermSet.GetPermCount();
    BOOL bMorePresent = FALSE;
    WORD wOtherColumn;
    DWORD dwState = CLST_CHECKED;

    TraceEnter(TRACE_MISC, "CheckPermissions");

    HDSA hPermList;     //Temp List of PPERMISSION pointers
    if( bClearCustom )
    {
       hPermList = DSA_Create(SIZEOF(PPERMISSION), 4);
       if (hPermList == NULL)
       {
           TraceMsg("DSA_Create failed");
           TraceLeaveValue(FALSE);
       }
    }

    if (wColumn == 1)
        wOtherColumn = 2;
    else
        wOtherColumn = 1;

    if (bDisabled)
        dwState |= CLST_DISABLED;

    for (UINT j = 0; j < cAces; j++)
    {
        ACCESS_MASK maskChecked = 0;
        PPERMISSION pPerm = PermSet[j];
        BOOL bIsNullGuid = IsNullGUID(&pPerm->guid);
        //Igonre custom here
        for (UINT i = 0; i < cRights ; i++)
        {
            PSI_ACCESS pAccess = (PSI_ACCESS)SendMessage(hwndList,
                                                         CLM_GETITEMDATA,
                                                         i,
                                                         0);
            //
            // The below expression tests to see if this access mask enables
            // this access "rights" line.  It could have more bits enabled, but
            // as long as it has all of the ones from the pAccess[i].mask then
            // it effectively has that option enabled.
            //
            if ( (pPerm->mask & pAccess->mask) == pAccess->mask &&
                 (bIsNullGuid || IsSameGUID(&pPerm->guid, pAccess->pguid)) )
            {
                DWORD dwStateCompare;

                //
                // Next, check the inherit flags.
                //
                if (bInheritFlags)
                {
                    DWORD dwCommonFlags = pPerm->dwFlags & pAccess->dwFlags;

                    //
                    // This expression tests to see whether the ACE applies
                    // to all objects that this access rights line applies to.
                    // The ACE must have at least as many of (CONTAINER_INHERIT_ACE,
                    // OBJECT_INHERIT_ACE) turned on as the rights line, and
                    // if the ACE has INHERIT_ONLY_ACE, then so must the rights line.
                    //
                    if (!((dwCommonFlags & ACE_INHERIT_ALL) == (pAccess->dwFlags & ACE_INHERIT_ALL)
                          && (dwCommonFlags & INHERIT_ONLY_ACE) == (pPerm->dwFlags & INHERIT_ONLY_ACE)))
                    continue;
                }

                // The bits say it's checked. We may not actually check the box
                // below, but for other reasons. In any case, we don't want the
                // "Additional stuff is here but I can't show it" message to
                // display because of this perm.
                maskChecked |= pAccess->mask;

                //
                // Ok, the bits say that this box should be checked, but
                // if the other column is already checked and has the same
                // enabled/disabled state, then we don't check this one.
                // This keeps us from having both Allow and Deny checked &
                // enabled on the same line (nonsense) or checked & disabled
                // on the same line (both inherited; we must show both as 
                // Allow Inherited can preceede Deny Inherited and we 
                // don't know the order at this point.
                //
                
                if( !(pPerm->dwFlags & INHERITED_ACE) )
                {
                    dwStateCompare = (DWORD)SendMessage(hwndList,
                                                        CLM_GETSTATE,
                                                        MAKELONG((WORD)i, wOtherColumn),
                                                        0);
                    if ((dwStateCompare & CLST_CHECKED) &&
                        ((dwStateCompare & CLST_DISABLED) == (dwState & CLST_DISABLED)))
                        continue;
                }
                //
                // Next, see if the box is already checked. If so, leave it
                // alone. Note that we don't compare the enabled/disabled
                // state.  The effect here is that the first check wins.
                // Raid 326000
                //
                dwStateCompare = (DWORD)SendMessage(hwndList,
                                                    CLM_GETSTATE,
                                                    MAKELONG((WORD)i, wColumn),
                                                    0);
                if (dwStateCompare & CLST_CHECKED)
                    continue;

                //
                // Finally, check the box.
                //
                SendMessage(hwndList,
                            CLM_SETSTATE,
                            MAKELONG((WORD)i, wColumn),
                            dwState);
            }
        }

        if( bClearCustom )
        {
            //If an ace don't check anyof the checkboxes,( i.e. maskchecked = 0 ),
            //it should be removed when custom is unchecked.
            if( !maskChecked )
            {
                DSA_AppendItem(hPermList, &pPerm);
                maskChecked = pPerm->mask;      //this is done to make sure maskchecked is false          
            }
            //Ace checks some checkbox ( maskChecked), so it mask should be maskChecked
            else
                pPerm->mask = maskChecked;
        }

        // Does this ACE have bits that aren't shown on this dialog?
        if (maskChecked != pPerm->mask)
        {   
            ACCESS_MASK maskTemp = 0;
            //Add this ace to the list of additional aces,
            //but only the bits which are additional
            if( hAdditional )    
            {
                maskTemp = pPerm->mask;
                pPerm->mask &= ~maskChecked;
                DSA_AppendItem(hAdditional, pPerm);
                pPerm->mask = maskTemp;
            }
            bMorePresent = TRUE;
        }
    }

    if( bClearCustom )
    {
        UINT cItems = DSA_GetItemCount(hPermList);
        PPERMISSION pTemp = NULL;
        while (cItems)
        {
            --cItems;
            DSA_GetItem(hPermList, cItems, &pTemp);
            //Removes only the permission which match its inheritance flag, not others.
            //For example it this permission is read applied to subobjects and hence appear as
            //custom permission. On clearing the custom checkbox, only read permission applied to
            //subobjects should go, not the read permission applied to this object ( and/or subobjects)
            // which can be shown in other checkboxes.
            PermSet.RemovePermission(pTemp, TRUE);
            --cAces;
        }
      
        PermSet.ResetAdvanced();
        DSA_Destroy(hPermList);
    }

    // Does this permission set have "advanced" ACEs that aren't shown
    // on this dialog?
    if (!bMorePresent && cAces != PermSet.GetPermCount(TRUE))
        bMorePresent = TRUE;

    if( bMorePresent && bCustom )
        CheckCustom( hwndList, wColumn, dwState );

    TraceLeaveValue(bMorePresent);
}


void
CPermPage::OnSelChange(HWND hDlg, BOOL bClearFirst, BOOL bClearCustomAllow, BOOL bClearCustomDeny)
{
    BOOL bDisabled = m_siObjectInfo.dwFlags & SI_READONLY;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnSelChange");
    TraceAssert(hDlg != NULL);

    //
    // If the principal list is empty or there is no selection, then we need
    // to disable all of the controls that operate on items in the listbox.
    //
    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    TraceAssert(hwndList != NULL);

    // Get the selected principal
    LPPRINCIPAL pPrincipal = (LPPRINCIPAL)GetSelectedItemData(hwndList, NULL);

    // Enable/disable the other controls
    if (!bDisabled)
        EnablePrincipalControls(hDlg, pPrincipal != NULL);

    //Change the permission label to reflect the new User/Group
    SetPermLabelText(hDlg);

    if (pPrincipal == NULL)
        TraceLeaveVoid();   // no selection or empty list

    //
    // Check/uncheck the permission boxes
    //

    hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);
    TraceAssert(hwndList != NULL);

    if (bClearFirst)
    {
        // First need to uncheck everything
        ClearPermissions(hwndList, bDisabled);
    }

    BOOL bIsContainer = m_siObjectInfo.dwFlags & SI_CONTAINER;
    BOOL bMorePresent = FALSE;

    //Clear the Custom Checkboxes. This is the only place where Custom Checkbox is cleared
    if(m_bCustomPermission)
    {
        ClearCustom(hwndList,1);
        ClearCustom(hwndList,2);
    }

    if( !pPrincipal->m_hAdditionalAllow )
    {
       pPrincipal->m_hAdditionalAllow = DSA_Create(SIZEOF(PERMISSION), 4);
       if (pPrincipal->m_hAdditionalAllow == NULL)
       {
           TraceMsg("DSA_Create failed");
           TraceLeaveVoid();
       }

    }
    if( !pPrincipal->m_hAdditionalDeny )
    {
       pPrincipal->m_hAdditionalDeny = DSA_Create(SIZEOF(PERMISSION), 4);
       if (pPrincipal->m_hAdditionalDeny == NULL)
       {
           TraceMsg("DSA_Create failed");
           TraceLeaveVoid();
       }

    }
    
    UINT cItems = DSA_GetItemCount(pPrincipal->m_hAdditionalAllow);
    PPERMISSION pPermTemp;
    while (cItems)
    {
        --cItems;
        pPermTemp = (PPERMISSION)DSA_GetItemPtr(pPrincipal->m_hAdditionalAllow, cItems );
        if(pPermTemp)
            pPrincipal->AddPermission(TRUE, pPermTemp);
    }
    DSA_DeleteAllItems(pPrincipal->m_hAdditionalAllow);

    cItems = DSA_GetItemCount(pPrincipal->m_hAdditionalDeny);
    while (cItems)
    {
        --cItems;
        pPermTemp = (PPERMISSION)DSA_GetItemPtr(pPrincipal->m_hAdditionalDeny, cItems );
        if(pPermTemp)
            pPrincipal->AddPermission(FALSE, pPermTemp);
    }
    DSA_DeleteAllItems(pPrincipal->m_hAdditionalDeny);

    bMorePresent |= CheckPermissions(hwndList, 
                                     pPrincipal->m_permDeny, 
                                     2, 
                                     bDisabled, 
                                     bIsContainer, 
                                     m_bCustomPermission, 
                                     bClearCustomDeny,
                                     pPrincipal->m_hAdditionalDeny);
    bMorePresent |= CheckPermissions(hwndList, 
                                     pPrincipal->m_permAllow, 
                                     1, 
                                     bDisabled, 
                                     bIsContainer, 
                                     m_bCustomPermission, 
                                     bClearCustomAllow,
                                     pPrincipal->m_hAdditionalAllow);
    bMorePresent |= CheckPermissions(hwndList, 
                                     pPrincipal->m_permInheritedDeny, 
                                     2, 
                                     TRUE, 
                                     bIsContainer, 
                                     m_bCustomPermission, 
                                     FALSE, 
                                     NULL);
    bMorePresent |= CheckPermissions(hwndList, 
                                     pPrincipal->m_permInheritedAllow, 
                                     1, 
                                     TRUE, 
                                     bIsContainer, 
                                     m_bCustomPermission, 
                                     FALSE,NULL);

    if (m_siObjectInfo.dwFlags & SI_ADVANCED)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_SPP_MORE_MSG),
                   (bMorePresent ? SW_SHOW : SW_HIDE));

        
    }
    else if (bMorePresent)
    {
        TraceMsg("Ignoring unknown permissions");
    }

    TraceLeaveVoid();
}

void
CPermPage::OnApply(HWND hDlg, BOOL bClose)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSD;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnApply");

    // Build a new DACL without the inherited ACEs.
    if (m_fPageDirty && SUCCEEDED(hr = BuildDacl(hDlg, &pSD, FALSE)) && (hr != S_FALSE))
    {
        PISECURITY_DESCRIPTOR psd = (PISECURITY_DESCRIPTOR)pSD;
        DWORD dwWarning = 0;
        SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;

        TraceAssert(pSD != NULL);
        TraceAssert(m_psi != NULL);

        // Check for Deny ACEs in the ACL
        if (!m_bWasDenyAcl)
        {
            DWORD dwFullControl = GENERIC_ALL;
            UCHAR aceFlags = 0;

            m_psi->MapGeneric(NULL, &aceFlags, &dwFullControl);
            if (IsDenyACL(psd->Dacl,
                          (psd->Control & SE_DACL_PROTECTED),
                          dwFullControl,
                          &dwWarning))
            {
                TraceAssert(dwWarning != 0);

                // Warn the user about Deny ACEs
                if (IDNO == MsgPopup(hDlg,
                                     MAKEINTRESOURCE(dwWarning),
                                     MAKEINTRESOURCE(IDS_SECURITY),
                                     MB_YESNO | MB_ICONWARNING,
                                     ::hModule,
                                     m_siObjectInfo.pszObjectName))
                {
                    hr = S_FALSE;
                }
            }
        }

        if (S_FALSE != hr)
        {
            if(!IsAclBloated(hDlg, si, pSD, m_cInheritableAces, m_siObjectInfo.dwFlags & SI_EDIT_PROPERTIES))
            {
                // Apply the new security descriptor on the object
                hr = m_psi->SetSecurity(si, pSD);
            }
            else
                hr = S_FALSE;
        }

        if (S_OK == hr)
        {
            LocalFree(pSD);
            pSD = NULL;
            m_fPageDirty = FALSE;

            if (!bClose)
            {
                //
                // Read the new DACL back from the object.  This ensures that we
                // have the "real" current DACL in case it was modified by the
                // object.  For example, inherited aces may have been added.
                //
                // This also resets the dialog to the initial state if the
                // user chose No in the confirmation dialog above.
                //
                if (SUCCEEDED(m_psi->GetSecurity(DACL_SECURITY_INFORMATION, &pSD, FALSE)))
                    SetDacl(hDlg, pSD);
            }
        }
        else if (S_FALSE == hr)
        {
            // S_FALSE is silent failure (the client should put up UI
            // during SetSecurity before returning S_FALSE).
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        }

        if (pSD != NULL)
            LocalFree(pSD);
    }

    if (FAILED(hr))
    {
        // Tell the user there was a problem.  If they choose to cancel
        // and the dialog is closing, do nothing (let the dialog close).
        // Otherwise, tell the property sheet that we had a problem.
        if (IDCANCEL != SysMsgPopup(hDlg,
                                    MAKEINTRESOURCE(IDS_PERM_WRITE_FAILED),
                                    MAKEINTRESOURCE(IDS_SECURITY),
                                    (bClose ? MB_RETRYCANCEL : MB_OK) | MB_ICONERROR,
                                    ::hModule,
                                    hr,
                                    m_siObjectInfo.pszObjectName))
        {
            // Return PSNRET_INVALID to abort the Apply and cause the sheet to
            // select this page as the active page.
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        }
    }

    TraceLeaveVoid();
}

/*-----------------------------------------------------------------------------
/ BuildDacl
/ -------
/  Convert the listbox entries into SD. If the size of security descriptor
/  is more than Max allowed shows a dialog box.
/  ppSD can be NULL for the cases where we want to verify if the SD size is
/  not execeeding the max size.
/
/----------------------------------------------------------------------------*/

HRESULT
CPermPage::BuildDacl(HWND hDlg,
                     PSECURITY_DESCRIPTOR *ppSD,
                     BOOL fIncludeInherited)
{
    PISECURITY_DESCRIPTOR pSD;
    ULONG nAclSize;
    LPPRINCIPAL pPrincipal;
    int cPrincipals = 0;
    DWORD dwFlags;
    int i, j;
    HCURSOR hcur = NULL;
    HWND hwndList = NULL;
    LV_ITEM lvItem;
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;

    static DWORD dwCanonicalFlags[] =
    {
        ACL_DENY | ACL_NONOBJECT,
        ACL_DENY | ACL_OBJECT,
        ACL_ALLOW | ACL_NONOBJECT,
        ACL_ALLOW | ACL_OBJECT
    };

    TraceEnter(TRACE_PERMPAGE, "CPermPage::BuildDacl");
    TraceAssert(hDlg != NULL);

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Estimate the size of the buffer necessary to build the
    // Security Descriptor.
    //

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    cPrincipals = ListView_GetItemCount(hwndList);

    dwFlags = ACL_NONINHERITED;
    if (fIncludeInherited)
        dwFlags |= ACL_INHERITED;

    WORD nMaxAclSize = 0xffff;
    nAclSize = SIZEOF(ACL);

    for (i = 0; i < cPrincipals; i++)
    {
        lvItem.iItem = i;
        if (ListView_GetItem(hwndList, &lvItem))
        {
            pPrincipal = (LPPRINCIPAL)lvItem.lParam;
            nAclSize += pPrincipal->GetAclLength(dwFlags);
        }
        if(nAclSize > nMaxAclSize)
        {
            //
            //itow converts upto 33 bytes so 34bytes is fine
            //
            WCHAR buffer[34];
            _itow((cPrincipals - i),buffer,10);
            ULONG nMsgId = IDS_ACL_SIZE_ERROR;
            if(!ppSD)
                nMsgId = IDS_ACL_SIZE_ERROR_ADV;

            MsgPopup(hDlg,
                     MAKEINTRESOURCE(nMsgId),
                     MAKEINTRESOURCE(IDS_SECURITY),
                     MB_OK | MB_ICONERROR,
                     ::hModule,
                     buffer);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            //
            //Do a silent failure since we have already shown the error message
            //
            return S_FALSE;
        }
    }

    if(!ppSD)
        return S_OK;

    *ppSD = NULL;

    //
    // Now that we have the size estimate, allocate the buffer.  Note that
    // we allocate enough memory for a self-relative security descriptor, but
    // don't set the SE_SELF_RELATIVE flag in pSD->Control.  This lets us
    // use pSD->Dacl, etc. as pointers rather than offsets.
    //

    *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + nAclSize);
    if (*ppSD == NULL)
        TraceLeaveResult(E_OUTOFMEMORY);

    if(!InitializeSecurityDescriptor(*ppSD, SECURITY_DESCRIPTOR_REVISION))
    {
        LocalFree(*ppSD);
        *ppSD = NULL;
        DWORD dwErr = GetLastError();
        TraceLeaveResult(HRESULT_FROM_WIN32(dwErr));
    }

    pSD = (PISECURITY_DESCRIPTOR)*ppSD;

    //
    // Finally, build the security descriptor
    //
    pSD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ
                    | (m_wSDControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

    if (nAclSize > 0)
    {
        pSD->Dacl = (PACL)(pSD + 1);
        pSD->Dacl->AclRevision = ACL_REVISION;
        pSD->Dacl->AclSize = (WORD)nAclSize;
        pSD->Dacl->AceCount = 0;

        PACE_HEADER pAcePos = (PACE_HEADER)FirstAce(pSD->Dacl);

        DWORD dwExtraFlags = fIncludeInherited ? 0 : ACL_CHECK_CREATOR;

        // Build the DACL in the following order:
        //      Deny
        //      Allow
        //      Inherited Deny
        //      Inherited Allow

        for (j = 0; j < ARRAYSIZE(dwCanonicalFlags); j++)
        {
            for (i = 0; i < cPrincipals; i++)
            {
                lvItem.iItem = i;
                if (ListView_GetItem(hwndList, &lvItem))
                {
                    pPrincipal = (LPPRINCIPAL)lvItem.lParam;
                    pPrincipal->AppendToAcl(pSD->Dacl,
                                            ACL_NONINHERITED | dwCanonicalFlags[j] | dwExtraFlags,
                                            &pAcePos);
                }
            }
        }

        if (fIncludeInherited)
        {
            for (j = 0; j < ARRAYSIZE(dwCanonicalFlags); j++)
            {
                for (i = 0; i < cPrincipals; i++)
                {
                    lvItem.iItem = i;
                    if (ListView_GetItem(hwndList, &lvItem))
                    {
                        pPrincipal = (LPPRINCIPAL)lvItem.lParam;
                        pPrincipal->AppendToAcl(pSD->Dacl,
                                                ACL_INHERITED | dwCanonicalFlags[j] | dwExtraFlags,
                                                &pAcePos);
                    }
                }
            }
        }

        // Set accurate size information for the ACL
        nAclSize = (ULONG)((PBYTE)pAcePos - (PBYTE)pSD->Dacl);
        TraceAssert(nAclSize >= SIZEOF(ACL));
        TraceAssert(pSD->Dacl->AclSize >= nAclSize);

        if (pSD->Dacl->AclSize > nAclSize)
            pSD->Dacl->AclSize = (WORD)nAclSize;

        TraceAssert(m_psi2 || IsDACLCanonical(pSD->Dacl));
    }

    TraceAssert(pSD && IsValidSecurityDescriptor(pSD));

    SetCursor(hcur);

    TraceLeaveResult(S_OK);
}


HRESULT
CPermPage::SetDacl(HWND hDlg,
                   PSECURITY_DESCRIPTOR pSD,
                   BOOL bDirty)
{
    HRESULT hr = S_OK;
    PACL pAcl = NULL;
    PACL paclAllowAll = NULL;
    BOOL bDefaulted;
    BOOL bPresent;
    SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
    PSECURITY_DESCRIPTOR pSDDefault = NULL;
    DWORD dwRevision;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::SetDacl");
    TraceAssert(hDlg != NULL);

    if (pSD != NULL && !IsValidSecurityDescriptor(pSD))
        TraceLeaveResult(E_INVALIDARG);

    if (pSD != NULL)
        GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);

    // Save the DACL protection and auto-inherited bits
    m_wSDControl &= ~(SE_DACL_DEFAULTED | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED);
    m_wSDControl |= (wSDControl & (SE_DACL_DEFAULTED | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

    // Get a pointer to the new DACL
    if (pSD != NULL)
        GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefaulted);

    if (!(m_siObjectInfo.dwFlags & SI_READONLY))
    {
        // Check for canonical ordering (Deny, Allow, Inherited Deny, Inherited Allow)
        if ((m_psi2 && !m_psi2->IsDaclCanonical(pAcl))
            || (!m_psi2 && !IsDACLCanonical(pAcl)))
        {
            TraceMsg("DACL not in canonical order!");

            // Ask the user whether to canonicalize the DACL or
            // blow it away completely.
            if (IDCANCEL == MsgPopup(hDlg,
                                     MAKEINTRESOURCE(IDS_PERM_NOT_CANONICAL),
                                     MAKEINTRESOURCE(IDS_SECURITY),
                                     MB_OKCANCEL | MB_ICONWARNING,
                                     ::hModule,
                                     m_siObjectInfo.pszObjectName))
            {
                // Blow it away and start over.
                pAcl = NULL;

                // Does the caller support a default ACL?  If so, get it now.
                if (m_siObjectInfo.dwFlags & SI_RESET)
                {
                    hr = m_psi->GetSecurity(DACL_SECURITY_INFORMATION,
                                            &pSDDefault,
                                            TRUE);

                    if (SUCCEEDED(hr) && pSDDefault != NULL)
                    {
                        // Save the DACL control bits
                        GetSecurityDescriptorControl(pSDDefault, &wSDControl, &dwRevision);
                        m_wSDControl &= ~(SE_DACL_DEFAULTED | SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED);
                        m_wSDControl |= SE_DACL_DEFAULTED | (wSDControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

                        // Get a pointer to the new DACL
                        GetSecurityDescriptorDacl(pSDDefault, &bPresent, &pAcl, &bDefaulted);
                    }
                    // else go with a NULL DACL
                }
            }
            // else simply continuing and re-saving will
            // cause the DACL to get sorted correctly

            // This causes a PropSheet_Changed notification to be sent below
            bDirty = TRUE;
        }
    }

    m_bWasDenyAcl = FALSE;

    // A NULL ACL implies "Everyone Full control", so
    // create such an ACL here
    if (pAcl == NULL)
    {
        PSID psidWorld = QuerySystemSid(UI_SID_World);
        DWORD dwSidLength = GetLengthSid(psidWorld);
        DWORD dwAclLength = SIZEOF(ACL) + SIZEOF(ACCESS_ALLOWED_ACE)
                            - SIZEOF(DWORD) + dwSidLength;

        m_wDaclRevision = ACL_REVISION;

        paclAllowAll = (PACL)LocalAlloc(LPTR, dwAclLength);
        if (paclAllowAll != NULL)
        {
            paclAllowAll->AclRevision = ACL_REVISION;
            paclAllowAll->AclSize = (WORD)dwAclLength;
            paclAllowAll->AceCount = 1;

            PACE_HEADER pAce = (PACE_HEADER)FirstAce(paclAllowAll);
            pAce->AceType = ACCESS_ALLOWED_ACE_TYPE;
            pAce->AceFlags = ACE_INHERIT_ALL;
            pAce->AceSize = (WORD)dwAclLength - SIZEOF(ACL);
            ((PACCESS_ALLOWED_ACE)pAce)->Mask = GENERIC_ALL;
            CopyMemory(&((PACCESS_ALLOWED_ACE)pAce)->SidStart, psidWorld, dwSidLength);
            pAcl = paclAllowAll;
        }
    }
    else
    {
        DWORD dwFullControl = GENERIC_ALL;
        UCHAR aceFlags = 0;

        m_psi->MapGeneric(NULL, &aceFlags, &dwFullControl);
        if (IsDenyACL(pAcl,
                      (m_wSDControl & SE_DACL_PROTECTED),
                      dwFullControl,
                      NULL))
        {
            // Already have Deny ACEs, don't bother warning again later.
            m_bWasDenyAcl = TRUE;
        }
    }

    // Reset the list of principals
    InitPrincipalList(hDlg, pAcl);

    //Get the count of inheritable aces
    m_cInheritableAces = GetCountOfInheritableAces(pAcl);


    // If there aren't any entries, fake a sel change to update
    // (i.e. disable) the other controls.
    if (pAcl == NULL || pAcl->AceCount == 0)
        OnSelChange(hDlg);

    if (bDirty)
        SetDirty(hDlg, TRUE);

    if (paclAllowAll != NULL)
        LocalFree(paclAllowAll);

    if (pSDDefault != NULL)
        LocalFree(pSDDefault);

    TraceLeaveResult(hr);
}


void
CPermPage::OnAddPrincipal(HWND hDlg)
{
    PUSER_LIST pUserList = NULL;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnAddPrincipal");
    TraceAssert(hDlg != NULL);
    
    if (S_OK == GetUserGroup(hDlg, TRUE, &pUserList))
    {
        PUSER_INFO pUserInfo;
        DWORD i;
        BOOL fPageModified = FALSE;
        int iItem = -1;

        TraceAssert(NULL != pUserList);

        HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
        TraceAssert(hwndList != NULL);

        for (i = 0; i < pUserList->cUsers; i++)
        {
            int cItems;
            LV_ITEM lvItem;
            LPPRINCIPAL pPrincipal;
            BYTE buffer[SIZEOF(KNOWN_OBJECT_ACE) + SIZEOF(GUID)];
            PACE_HEADER pAce = (PACE_HEADER)buffer;

            pUserInfo = &pUserList->rgUsers[i];
            iItem = -1;

            // Check whether the new principal is already in our list.
            // If so, don't add it again.
            cItems = ListView_GetItemCount(hwndList);
            lvItem.iSubItem = 0;
            lvItem.mask = LVIF_PARAM;
            while (cItems > 0)
            {
                LPPRINCIPAL pPrincipal2 = NULL;

                --cItems;
                lvItem.iItem = cItems;

                ListView_GetItem(hwndList, &lvItem);
                pPrincipal2 = (LPPRINCIPAL)lvItem.lParam;

                if (EqualSid(pPrincipal2->GetSID(), pUserInfo->pSid))
                {
                    iItem = lvItem.iItem;
                    break;
                }
            }

            // Did we find it?
            if (iItem != -1)
                continue;

            // ListView_FindItem failed to find a match.  Add a
            // new principal.

            pPrincipal = new CPrincipal(this);
            if (!pPrincipal)
                continue;

            // Initialize principal
            if (!pPrincipal->SetPrincipal(pUserInfo->pSid,
                                          pUserInfo->SidType,
                                          pUserInfo->pszName,
                                          pUserInfo->pszLogonName))
            {
                delete pPrincipal;
                continue;
            }

            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvItem.iItem = 0;
            lvItem.iSubItem = 0;
            lvItem.pszText = (LPTSTR)pPrincipal->GetName();
            lvItem.iImage = pPrincipal->GetImageIndex();
            lvItem.lParam = (LPARAM)pPrincipal;

            // Insert principal into list
            iItem = ListView_InsertItem(hwndList, &lvItem);
            if (-1 == iItem)
            {
                delete pPrincipal;
                continue;
            }

            // Add ace with default access
            pAce->AceType = ACCESS_ALLOWED_ACE_TYPE;
            pAce->AceFlags = 0;
            pAce->AceSize = SIZEOF(ACCESS_ALLOWED_ACE);
            ((PACCESS_ALLOWED_ACE)pAce)->Mask = m_pDefaultAccess->mask;

            if (m_siObjectInfo.dwFlags & SI_CONTAINER)
            {
                // Pick up inherit bits from the default access
                pAce->AceFlags = (UCHAR)(m_pDefaultAccess->dwFlags & (VALID_INHERIT_FLAGS & ~INHERITED_ACE));

                //Remveod the special casing for CREATOR_OWNER
                //NTRAID#NTBUG9-467049-2001/11/29-hiteshr
            }

            if (!IsNullGUID(m_pDefaultAccess->pguid))
            {
                pAce->AceType = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
                pAce->AceSize = SIZEOF(KNOWN_OBJECT_ACE) + SIZEOF(GUID);
                ((PKNOWN_OBJECT_ACE)pAce)->Flags = ACE_OBJECT_TYPE_PRESENT;
                *RtlObjectAceObjectType(pAce) = *m_pDefaultAccess->pguid;
            }

            pPrincipal->AddAce(pAce);
            fPageModified = TRUE;
        }

        // Done with this now
        LocalFree(pUserList);

        if (fPageModified)
        {
            // If we've added items, resize the Name column
            //ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

            SetDirty(hDlg);
        }

        if (iItem != -1)
        {
            // Select the last one inserted.
            SelectListViewItem(hwndList, iItem);
        }
    }

    TraceLeaveVoid();
}


void
CPermPage::OnRemovePrincipal(HWND hDlg)
{
    HWND hwndList;
    int iIndex;
    LPPRINCIPAL pPrincipal;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnRemovePrincipal");

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    pPrincipal = (LPPRINCIPAL)GetSelectedItemData(hwndList, &iIndex);

    if (pPrincipal)
    {
        BOOL bDirty = FALSE;

        if (pPrincipal->GetAclLength(ACL_INHERITED) > 0)
        {
            // This principal has inherited ACEs so we can't remove the principal
            // from the list. Instead, simply remove the non-inherited ACEs from
            // the principal.
            if (pPrincipal->GetAclLength(ACL_NONINHERITED) > 0)
            {
                pPrincipal->m_permDeny.Reset();
                pPrincipal->m_permAllow.Reset();
                DSA_DeleteAllItems(pPrincipal->m_hAdditionalAllow);
                DSA_DeleteAllItems(pPrincipal->m_hAdditionalDeny);


                bDirty = TRUE;

                // Update the other controls (this happens automatically in the
                // ListView_DeleteItem case below).
                OnSelChange(hDlg);
            }
            else
            {
                // Notify the user that we can't remove inherited ACEs.
                MsgPopup(hDlg,
                         MAKEINTRESOURCE(IDS_PERM_CANT_REMOVE),
                         MAKEINTRESOURCE(IDS_SECURITY),
                         MB_OK | MB_ICONWARNING,
                         ::hModule,
                         pPrincipal->GetName());
            }
        }
        else
        {
             ListView_DeleteItem(hwndList, iIndex);
            //
            // If we just removed the only item, move the focus to the Add button
            // (the Remove button will be disabled in OnSelChange).
            //
            int cItems = ListView_GetItemCount(hwndList);
            if (cItems == 0)
                SetFocus(GetDlgItem(hDlg, IDC_SPP_ADD));
            else
            {
                // If we deleted the last one, select the previous one
                if (cItems <= iIndex)
                    --iIndex;

                SelectListViewItem(hwndList, iIndex);
                //
                //Key board focus is getting lost at this point
                //set it to REMOVE button.
                //
                SetFocus(GetDlgItem(hDlg, IDC_SPP_REMOVE));
            }
            bDirty = TRUE;
        }

        // Notify the property sheet that we've changed
        if (bDirty)
            SetDirty(hDlg);
    }

    TraceLeaveVoid();
}


void
CPermPage::OnAdvanced(HWND hDlg)
{
    LPSECURITYINFO psi;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnAdvanced");

    //
    //Don't go to Advanced page, if DACL size is more than
    //maximum allowed. 
    //
    if (m_fPageDirty && (S_FALSE == BuildDacl(hDlg, NULL, FALSE)))
        TraceLeaveVoid();

    //
    // Create an ISecurityInformation wrapper to give to the advanced
    // dialog.  The wrapper intercepts GetSecurity & SetSecurity.
    //
    psi = new CSecurityInfo(this, hDlg);

    if (psi != NULL)
    {
        // Invoke the advanced ACL editor
        EditSecurityEx(hDlg, psi,this, 0,m_bNoReadWriteCanWriteOwner);
        psi->Release();   // release initial reference
    }
    else
    {
        MsgPopup(hDlg,
                 MAKEINTRESOURCE(IDS_OUT_OF_MEMORY),
                 MAKEINTRESOURCE(IDS_SECURITY),
                 MB_OK | MB_ICONERROR,
                 ::hModule);
    }

    TraceLeaveVoid();
}

void
CPermPage::EnablePrincipalControls(HWND hDlg, BOOL fEnable)
{
    TraceEnter(TRACE_PERMPAGE, "CPermPage::EnablePrincipalControls");

    EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), fEnable);

    if (!fEnable)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_SPP_MORE_MSG), SW_HIDE);
    }
    else
    {
#if 0
        LPPRINCIPAL pPrincipal
            = (LPPRINCIPAL)GetSelectedItemData(GetDlgItem(hDlg, IDC_SPP_PRINCIPALS),
                                               NULL);

        // If the selected principal has only inherited ACEs, then disable
        // the Remove button.
        if (pPrincipal &&
            pPrincipal->GetAclLength(ACL_INHERITED) > 0 &&
            pPrincipal->GetAclLength(ACL_NONINHERITED) == 0)
        {
            fEnable = FALSE;
        }
#endif
    }
    EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), fEnable);

    TraceLeaveVoid();
}

void
CPermPage::CommitCurrent(HWND hDlg, int iPrincipal)
{
    // Commit any outstanding bit changes

    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);

    TraceEnter(TRACE_PERMPAGE, "CPermPage::CommitCurrent");

    // If an index isn't provided, get the index of the currently
    // selected principal.
    if (iPrincipal == -1)
        iPrincipal = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    if (iPrincipal != -1)
    {
        // Get the Principal from the selection.
        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iPrincipal;
        lvItem.iSubItem = 0;
        lvItem.lParam = 0;

        ListView_GetItem(hwndList, &lvItem);
        LPPRINCIPAL pPrincipal = (LPPRINCIPAL)lvItem.lParam;

        if (pPrincipal != NULL)
        {
            // Get new ACEs from the checklist window

            HDPA hAceEntries = DPA_Create(4);

            if (hAceEntries != NULL)
            {
                hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);
                UINT iCount = GetAcesFromCheckList(hwndList,
                                                   pPrincipal->GetSID(),
                                                   TRUE,
                                                   FALSE,
                                                   0,
                                                   &GUID_NULL,
                                                   hAceEntries);

                // Merge new ACEs into the principal
                while (iCount != 0)
                {
                    --iCount;
                    PACE_HEADER pAce = (PACE_HEADER)DPA_FastGetPtr(hAceEntries, iCount);
                    // Shouldn't get any inherited ACEs here
                    TraceAssert(!(pAce->AceFlags & INHERITED_ACE));
                    pPrincipal->AddAce(pAce);
                    LocalFree(pAce);
                    DPA_DeletePtr(hAceEntries, iCount);
                }

                TraceAssert(DPA_GetPtrCount(hAceEntries) == 0);
                DPA_Destroy(hAceEntries);
            }
        }
    }

    TraceLeaveVoid();
}


void
CPermPage::OnSize(HWND hDlg, DWORD dwSizeType, ULONG /*nWidth*/, ULONG /*nHeight*/)
{
    RECT rc;
    RECT rcDlg;
    LONG dx;
    LONG dy;
    HWND hwndAdvButton;
    HWND hwndPermList;
    HWND hwndPrincipalList;
    HWND hwndBottom;
    HWND hwnd;
    LONG i;

    TraceEnter(TRACE_PERMPAGE, "CPermPage::OnSize");

    if (dwSizeType != SIZE_RESTORED)
        TraceLeaveVoid();

    hwndPrincipalList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    hwndPermList = GetDlgItem(hDlg, IDC_SPP_PERMS);
    hwndAdvButton = GetDlgItem(hDlg, IDC_SPP_ADVANCED);
    GetClientRect(hDlg, &rcDlg);

    GetWindowRect(hwndPrincipalList, &rc);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);   // map from screen to dlg

    InflateRect(&rcDlg, -rc.left, -rc.top);         // account for margins

    if (GetWindowLong(hwndAdvButton, GWL_STYLE) & WS_VISIBLE)
    {
        hwndBottom = hwndAdvButton;
    }
    else
    {
        hwndBottom = hwndPermList;
    }

    GetWindowRect(hwndBottom, &rc);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);

    dy = rcDlg.bottom - rc.bottom;

    GetWindowRect(hwndPermList, &rc);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);

    dx = rcDlg.right - rc.right;

    //
    // Never make things smaller, and only make things
    // bigger if the change is worthwhile.
    //
    dx = max(dx, 0);
    if (dx < 5)
        dx = 0;
    dy = max(dy, 0);
    if (dy < 5)
        dy = 0;

    //
    // Reposition and/or resize all controls
    //
    if (dx > 0 || dy > 0)
    {
        // Add, Remove, Reset buttons
        for (i = IDC_SPP_ADD; i <= IDC_SPP_REMOVE; i++)
        {
            hwnd = GetDlgItem(hDlg, i);
            GetWindowRect(hwnd, &rc);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
            SetWindowPos(hwnd,
                         NULL,
                         rc.left + dx,
                         rc.top + dy/2,
                         0,
                         0,
                         SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
        }
    }

    if (dx > 0 || dy > 0)
    {
        // Listview containing User/Group names
        GetWindowRect(hwndPrincipalList, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwndPrincipalList,
                     NULL,
                     0,
                     0,
                     rc.right - rc.left + dx,
                     rc.bottom - rc.top + dy/2,
                     SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);

        // Widen the name column if necessary
        GetClientRect(hwndPrincipalList, &rc);
        if (ListView_GetColumnWidth(hwndPrincipalList, 0) < rc.right)
            ListView_SetColumnWidth(hwndPrincipalList, 0, rc.right);
    }

    if (dy > 0 || dx > 0)
    {
        // Static control "Access"
        hwnd = GetDlgItem(hDlg, IDC_SPP_ACCESS);
        GetWindowRect(hwnd, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwnd,
                     NULL,
                     rc.left,
                     rc.top + dy/2,
                     rc.right - rc.left + dx,
                     rc.bottom - rc.top,
                     SWP_NOACTIVATE |  SWP_NOZORDER);
        //Static control Big Permission Label
        hwnd = GetDlgItem(hDlg, IDC_SPP_ACCESS_BIG);
        GetWindowRect(hwnd, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwnd,
                     NULL,
                     rc.left,
                     rc.top + dy/2,
                     rc.right - rc.left + dx,
                     rc.bottom - rc.top,
                     SWP_NOACTIVATE |  SWP_NOZORDER);

    }

    if (dx > 0 || dy > 0)
    {
        // Static controls "Allow" and "Deny"
        for (i = IDC_SPP_ALLOW; i <= IDC_SPP_DENY; i++)
        {
            hwnd = GetDlgItem(hDlg, i);
            GetWindowRect(hwnd, &rc);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
            SetWindowPos(hwnd,
                         NULL,
                         rc.left + dx,
                         rc.top + dy/2,
                         0,
                         0,
                         SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
        }

        // List of permission checkboxes
        GetWindowRect(hwndPermList, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwndPermList,
                     NULL,
                     rc.left,
                     rc.top + dy/2,
                     rc.right - rc.left + dx,
                     rc.bottom - rc.top + dy/2,
                     SWP_NOACTIVATE | SWP_NOZORDER);
    }

    if (dy > 0 || dx > 0)
    {
        // Advanced button
        GetWindowRect(hwndAdvButton, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwndAdvButton,
                     NULL,
                     rc.left + dx,
                     rc.top + dy,
                     0,
                     0,
                     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);

        // "More stuff is present but not viewable" message
        hwnd = GetDlgItem(hDlg, IDC_SPP_STATIC_ADV);
        GetWindowRect(hwnd, &rc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        SetWindowPos(hwnd,
                     NULL,
                     rc.left,
                     rc.top + dy,
                     0,
                     0,
                     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);

    }

    TraceLeaveVoid();
}


void
CPermPage::ClearPermissions(HWND hwndList, BOOL bDisabled)
{
    // Uncheck everything
    UINT cRights = 0;
    DWORD dwState = CLST_UNCHECKED;

    if (bDisabled)
        dwState |= CLST_DISABLED;

    if (hwndList)
        cRights = (UINT)SendMessage(hwndList, CLM_GETITEMCOUNT, 0, 0);

    while (cRights > 0)
    {
        cRights--;
        SendMessage(hwndList, CLM_SETSTATE, MAKELONG((WORD)cRights, 1), dwState);
        SendMessage(hwndList, CLM_SETSTATE, MAKELONG((WORD)cRights, 2), dwState);
    }

    if(m_bCustomPermission)
    {
        ClearCustom(hwndList,1);
        ClearCustom(hwndList,2);
    }
}


void
CPermPage::SetDirty(HWND hDlg, BOOL bDefault)
{
    if (!bDefault)
        m_wSDControl &= ~SE_DACL_DEFAULTED;
    m_fPageDirty = TRUE;
    PropSheet_Changed(GetParent(hDlg), hDlg);
}


BOOL
CPermPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // First check to see if its time to update listview names
    if (uMsg == UM_SIDLOOKUPCOMPLETE)
    {
        HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
        SetPrincipalNamesInList(hwndList, (PSID)lParam);
        SetPermLabelText(hDlg);

        // lParam is zero when all remaining names are looked up
        if (0 == lParam)
        {
            // Sort using the real names
            ListView_SortItems(hwndList, NULL, 0);

            // Make sure the selected item is visible
            int iSelItem;
            if (NULL == GetSelectedItemData(hwndList, &iSelItem))
            {
                // No selection, select the first item
                SelectListViewItem(hwndList, 0);
            }
            else
            {
                ListView_EnsureVisible(hwndList, iSelItem, FALSE);
            }

            // Show normal cursor now
            m_fBusy = FALSE;
            SetCursor(LoadCursor(NULL, IDC_ARROW));

            // Enable the Advanced button if appropriate
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_ADVANCED),
                (m_siObjectInfo.dwFlags & SI_ADVANCED));
        }
        return TRUE;
    }

    switch(uMsg)
    {
    case WM_SETCURSOR:
        if (m_fBusy)
        {
            SetCursor(m_hcurBusy);
            SetWindowLong(hDlg, DWLP_MSGRESULT, TRUE);
            return TRUE;
        }
        else
            return FALSE;
        break;

    case WM_INITDIALOG:
        return InitDlg(hDlg);

    case WM_NOTIFY:
        return OnNotify(hDlg, (int)wParam, (LPNMHDR)lParam);

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_SPP_ADD:
            OnAddPrincipal(hDlg);
            break;

        case IDC_SPP_REMOVE:
            OnRemovePrincipal(hDlg);
            break;

        case IDC_SPP_ADVANCED:
            OnAdvanced(hDlg);
            break;

        case IDC_SPP_PRINCIPALS:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == IDN_CHECKSELECTION)
            {
                // See if we have gotten a new selection.  If not, then the
                // user must have clicked inside the listview but not on an item,
                // thus causing the listview to remove the selection.  In that
                // case, disable the other controls

                if (ListView_GetSelectedCount(GET_WM_COMMAND_HWND(wParam, lParam)) == 0)
                {
                    // Uncheck everything first
                    ClearPermissions(GetDlgItem(hDlg, IDC_SPP_PERMS));
                    EnablePrincipalControls(hDlg, FALSE);
                }
            }
            break;

        default:
            // Command not handled
            return FALSE;
        }
        break;

    case WM_SIZE:
        OnSize(hDlg, (LONG)wParam, (ULONG)LOWORD(lParam), (ULONG)HIWORD(lParam));
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_szAcluiHelpFile,
                    HELP_WM_HELP,
                    (DWORD_PTR)aPermPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            HWND hwnd = (HWND)wParam;

            //
            // Some of the checkboxes may be scrolled out of view, but
            // they are still detected by WinHelp, so we jump through
            // a few extra hoops here.
            //
            if (hwnd == hDlg)
            {
                POINT pt;
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);

                ScreenToClient(hDlg, &pt);
                hwnd = ChildWindowFromPoint(hDlg, pt);
                if (hDlg == hwnd)
                    break;
            }

            //
            // WinHelp looks for child windows, but we don't have help id's
            // for the permission checkboxes.  If the request is for the
            // checklist window, fake out WinHelp by referring to one of
            // the static labels just above the list.
            //
            if (GetDlgCtrlID(hwnd) == IDC_SPP_PERMS)
                hwnd = GetDlgItem(hDlg, IDC_SPP_ACCESS);

            WinHelp(hwnd,
                    c_szAcluiHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)aPermPageHelpIDs);
        }
        break;

    default:
        // Message not handled
        return FALSE;
    }

    return TRUE;
}


//
// CSecurityInfo implementation
//
STDMETHODIMP_(ULONG)
CSecurityInfo::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CSecurityInfo::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CSecurityInfo::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
        *ppv = static_cast<LPSECURITYINFO>(this);
    else if (IsEqualIID(riid, IID_ISecurityInformation2))
    {
        if (m_pPage->m_psi2)
            *ppv = static_cast<LPSECURITYINFO2>(this);
    }
    else if (IsEqualIID(riid, IID_IEffectivePermission))
    {
        if(m_pPage->m_pei)
           *ppv = static_cast<LPEFFECTIVEPERMISSION>(this);
    }
    else if (IsEqualIID(riid, IID_ISecurityObjectTypeInfo))
    {
        if(m_pPage->m_psoti)
            *ppv = static_cast<LPSecurityObjectTypeInfo>(this);

    }

    else if (IsEqualIID(riid, IID_IDsObjectPicker))
        *ppv = static_cast<IDsObjectPicker*>(this);

    if (*ppv)
    {
        m_cRef++;
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP
CSecurityInfo::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    TraceEnter(TRACE_SI, "CSecurityInfo::GetObjectInformation");
    TraceAssert(m_pPage != NULL);

    *pObjectInfo = m_pPage->m_siObjectInfo;

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CSecurityInfo::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    HRESULT hr;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetSecurity");
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);
    TraceAssert(m_pPage != NULL);
    TraceAssert(m_hDlg != NULL);

    *ppSD = NULL;


//Effective permission page calls with si = DACL + OWNER + GROUP and it should
//return Actual Security Descriptor. Other pages calls with only one thing at a time
//and we build dacl and return it if its dirty.
    if (!fDefault && (si == DACL_SECURITY_INFORMATION) && m_pPage->m_fPageDirty)
    {
        // We only get asked for one thing at a time
        TraceAssert(si == DACL_SECURITY_INFORMATION);

        // Return current DACL, including inherited ACEs
        hr = m_pPage->BuildDacl(m_hDlg, ppSD, TRUE);
    }
    else
    {
        TraceAssert(m_pPage->m_psi != NULL);

        // Get it from the object
        hr = m_pPage->m_psi->GetSecurity(si, ppSD, fDefault);
    }

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::SetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SI, "CSecurityInfo::SetSecurity");
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);
    TraceAssert(m_pPage != NULL);
    TraceAssert(m_hDlg != NULL);

    // Write out the new security descriptor
    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->SetSecurity(si, pSD);

    if (S_OK == hr && (si & DACL_SECURITY_INFORMATION))
    {
        PSECURITY_DESCRIPTOR psd = NULL;

        m_pPage->m_fPageDirty = FALSE;

        // Read the new DACL back from the object, that is, don't use the one
        // from the passed-in security descriptor.  This ensures that we have
        // the "real" current DACL in case it was modified somewhere en route.
        if (SUCCEEDED(m_pPage->m_psi->GetSecurity(DACL_SECURITY_INFORMATION, &psd, FALSE)))
            pSD = psd;

        // Reinitialize the dialog using the new DACL
        m_pPage->SetDacl(m_hDlg, pSD);

        if (psd != NULL)
            LocalFree(psd);
    }

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::GetAccessRights(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetAccessRights");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->GetAccessRights(pguidObjectType,
                                             dwFlags,
                                             ppAccess,
                                             pcAccesses,
                                             piDefaultAccess);
    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::MapGeneric(const GUID* pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SI, "CSecurityInfo::MapGeneric");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->MapGeneric(pguidObjectType, pAceFlags, pmask);

    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetInheritTypes");
    TraceAssert(m_pPage != NULL);
    TraceAssert(ppInheritTypes != NULL);
    TraceAssert(pcInheritTypes != NULL);

    *ppInheritTypes = NULL;
    *pcInheritTypes = 0;

    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->GetInheritTypes(ppInheritTypes,
                                             pcInheritTypes);
    TraceLeaveResult(hr);
}

STDMETHODIMP
CSecurityInfo::PropertySheetPageCallback(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_SI, "CSecurityInfo::PropertySheetPageCallback");
    TraceAssert(m_pPage != NULL);

    //
    // Pass the call on to the client
    //
    if (m_pPage->m_psi != NULL)
        hr = m_pPage->m_psi->PropertySheetPageCallback(hwnd, uMsg, uPage);

    //
    // If the simple perm page is disabled, make sure the advanced perm
    // page is as well.
    //
    if (SUCCEEDED(hr) && uPage == SI_PAGE_ADVPERM && m_pPage->m_bAbortPage)
        hr = E_FAIL;

    TraceLeaveResult(hr);
}


//
// ISecurityInformation2 methods
//
STDMETHODIMP_(BOOL)
CSecurityInfo::IsDaclCanonical(PACL pDacl)
{
    BOOL bResult = TRUE;

    TraceEnter(TRACE_SI, "CSecurityInfo::IsDaclCanonical");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psi2 != NULL)
        bResult = m_pPage->m_psi2->IsDaclCanonical(pDacl);

    TraceLeaveValue(bResult);
}

STDMETHODIMP
CSecurityInfo::LookupSids(ULONG cSids, PSID *rgpSids, LPDATAOBJECT *ppdo)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter(TRACE_SI, "CSecurityInfo::LookupSids");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psi2 != NULL)
        hr = m_pPage->m_psi2->LookupSids(cSids, rgpSids, ppdo);

    TraceLeaveResult(hr);
}


//
// IDsObjectPicker methods
//
STDMETHODIMP CSecurityInfo::Initialize(PDSOP_INIT_INFO pInitInfo)
{
    HRESULT hr;
    IDsObjectPicker *pObjectPicker = NULL;

    hr = m_pPage->GetObjectPicker(&pObjectPicker);

    if (SUCCEEDED(hr))
    {
        if (m_pPage->m_flLastOPOptions != pInitInfo->flOptions)
        {
            m_pPage->m_flLastOPOptions = (DWORD)-1;

            hr = pObjectPicker->Initialize(pInitInfo);

            if (SUCCEEDED(hr))
            {
                m_pPage->m_flLastOPOptions = pInitInfo->flOptions;
            }
        }
        pObjectPicker->Release();
    }

    return hr;
}

STDMETHODIMP CSecurityInfo::InvokeDialog(HWND hwndParent,
                                         IDataObject **ppdoSelection)
{
    HRESULT hr;
    IDsObjectPicker *pObjectPicker = NULL;

    hr = m_pPage->GetObjectPicker(&pObjectPicker);

    if (SUCCEEDED(hr))
    {
        hr = pObjectPicker->InvokeDialog(hwndParent, ppdoSelection);
        pObjectPicker->Release();
    }

    return hr;
}


STDMETHODIMP CSecurityInfo::GetInheritSource(SECURITY_INFORMATION si,
                                              PACL pACL, 
                                              PINHERITED_FROM *ppInheritArray)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetInheritSource");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_psoti)
        hr = m_pPage->m_psoti->GetInheritSource(si, pACL, ppInheritArray);

    TraceLeaveResult(hr);
}

STDMETHODIMP CSecurityInfo::GetEffectivePermission( THIS_ const GUID* pguidObjectType,
                                                    PSID pUserSid,
                                                    LPCWSTR pszServerName,
                                                    PSECURITY_DESCRIPTOR pSD,
                                                    POBJECT_TYPE_LIST *ppObjectTypeList,
                                                    ULONG *pcObjectTypeListLength,
                                                    PACCESS_MASK *ppGrantedAccessList,
                                                    ULONG *pcGrantedAccessListLength)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter(TRACE_SI, "CSecurityInfo::GetEffectivePermission");
    TraceAssert(m_pPage != NULL);

    if (m_pPage->m_pei)
        hr = m_pPage->m_pei->GetEffectivePermission(pguidObjectType,
                                                    pUserSid,
                                                    pszServerName,
                                                    pSD,
                                                    ppObjectTypeList,
                                                    pcObjectTypeListLength,
                                                    ppGrantedAccessList,
                                                    pcGrantedAccessListLength);

    TraceLeaveResult(hr);
}




//
// Expose an api to get at the simple permission editor
//

HPROPSHEETPAGE
ACLUIAPI
CreateSecurityPage(LPSECURITYINFO psi)
{
    HPROPSHEETPAGE hPage = NULL;
    PPERMPAGE pPage;
    PSIDCACHE pSidCache;

    TraceEnter(TRACE_PERMPAGE, "CreateSecurityPage");

    // Create the global SID Cache
    pSidCache = GetSidCache();

    if (NULL == psi)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(NULL);
    }

    pPage = new CPermPage(psi);

    if (pPage)
    {
        SI_OBJECT_INFO siObjectInfo = {0};
        LPCTSTR pszTitle = NULL;

        if (SUCCEEDED(psi->GetObjectInformation(&siObjectInfo)) &&
            (siObjectInfo.dwFlags & SI_PAGE_TITLE))
        {
            pszTitle = siObjectInfo.pszPageTitle;
        }

        hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_SIMPLE_PERM_PAGE), pszTitle);

        if (!hPage)
            delete pPage;
    }

    if (pSidCache)
        pSidCache->Release();

    TraceLeaveValue(hPage);
}

BOOL
ACLUIAPI
EditSecurity( HWND hwndOwner, LPSECURITYINFO psi )
{
    HPROPSHEETPAGE hPage[1];
    UINT cPages = 0;
    BOOL bResult = FALSE;
    SI_OBJECT_INFO siObjectInfo = {0};
    HRESULT hr;

    TraceEnter(TRACE_PERMPAGE, "EditSecurity");

    // Get object name for dialog title
    hr = psi->GetObjectInformation(&siObjectInfo);

    if (FAILED(hr))
    {
        if (!GetLastError())
            SetLastError(hr);

        TraceLeaveValue(FALSE);
    }

    hPage[cPages] = CreateSecurityPage( psi );
    if (hPage[cPages])
        cPages++;

    if (cPages)
    {
        // Build dialog title string
        LPTSTR pszCaption = NULL;

        PROPSHEETHEADER psh;
        psh.dwSize = SIZEOF(psh);
        psh.dwFlags = PSH_DEFAULT;
        psh.hwndParent = hwndOwner;
        psh.hInstance = ::hModule;
        psh.nPages = cPages;
        psh.nStartPage = 0;
        psh.phpage = &hPage[0];

// There has been a request for customization of this dialog title,
// but this probably isn't the best way to do it, since the dlg title
// and page title will be the same.
#if 0
        if ((siObjectInfo.dwFlags & SI_PAGE_TITLE)
            && siObjectInfo.pszPageTitle
            && siObjectInfo.pszPageTitle[0])
        {
            psh.pszCaption = siObjectInfo.pszPageTitle;
        }
        else
#endif
        {
            FormatStringID(&pszCaption, ::hModule, IDS_SPP_TITLE, siObjectInfo.pszObjectName);
            psh.pszCaption = pszCaption;
        }

        bResult = (BOOL)(PropertySheet(&psh) + 1);

        LocalFreeString(&pszCaption);
    }

    TraceLeaveValue(bResult);
}
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       misc.cpp
//
//  This file contains miscellaneous helper functions.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

/*******************************************************************

    NAME:       GetAceSid

    SYNOPSIS:   Gets pointer to SID from an ACE

    ENTRY:      pAce - pointer to ACE

    EXIT:

    RETURNS:    Pointer to SID if successful, NULL otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

PSID
GetAceSid(PACE_HEADER pAce)
{
    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        return (PSID)&((PKNOWN_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        return (PSID)&((PKNOWN_COMPOUND_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        return RtlObjectAceSid(pAce);
    }

    return NULL;
}


/*******************************************************************

    NAME:       LocalAllocSid

    SYNOPSIS:   Copies a SID

    ENTRY:      pOriginal - pointer to SID to copy

    EXIT:

    RETURNS:    Pointer to SID if successful, NULL otherwise

    NOTES:      Caller must free the returned SID with LocalFree

    HISTORY:
        JeffreyS    12-Apr-1999     Created

********************************************************************/

PSID
LocalAllocSid(PSID pOriginal)
{
    PSID pCopy = NULL;
    if (pOriginal && IsValidSid(pOriginal))
    {
        DWORD dwLength = GetLengthSid(pOriginal);
        pCopy = (PSID)LocalAlloc(LMEM_FIXED, dwLength);
        if (NULL != pCopy)
            CopyMemory(pCopy, pOriginal, dwLength);
    }
    return pCopy;
}


/*******************************************************************

    NAME:       DestroyDPA

    SYNOPSIS:   LocalFree's all pointers in a Dynamic Pointer
                Array and then frees the DPA.

    ENTRY:      hList - handle of list to destroy

    EXIT:

    RETURNS:    nothing

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

int CALLBACK
_LocalFreeCB(LPVOID pVoid, LPVOID /*pData*/)
{
    if (pVoid)
        LocalFree(pVoid);
    return 1;
}

void
DestroyDPA(HDPA hList)
{
    if (hList != NULL)
        DPA_DestroyCallback(hList, _LocalFreeCB, 0);
}



/*******************************************************************

    NAME:       GetLSAConnection

    SYNOPSIS:   Wrapper for LsaOpenPolicy

    ENTRY:      pszServer - the server on which to make the connection

    EXIT:

    RETURNS:    LSA_HANDLE if successful, NULL otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

LSA_HANDLE
GetLSAConnection(LPCTSTR pszServer, DWORD dwAccessDesired)
{
    LSA_HANDLE hPolicy = NULL;
    LSA_UNICODE_STRING uszServer = {0};
    LSA_UNICODE_STRING *puszServer = NULL;
    LSA_OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;

    sqos.Length = SIZEOF(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    oa.SecurityQualityOfService = &sqos;

    if (pszServer &&
        *pszServer &&
        RtlCreateUnicodeString(&uszServer, pszServer))
    {
        puszServer = &uszServer;
    }

    LsaOpenPolicy(puszServer, &oa, dwAccessDesired, &hPolicy);

    if (puszServer)
        RtlFreeUnicodeString(puszServer);

    return hPolicy;
}


/*******************************************************************

    NAME:       LookupSid

    SYNOPSIS:   Gets the qualified account name for a given SID

    ENTRY:      pszServer - the server on which to do the lookup
                pSid - the SID to lookup

    EXIT:       *ppszName contains the account name. This buffer
                must be freed by the caller with LocalFree.

                *pSidType contains the SID type. pSidType is optional.

    RETURNS:    TRUE if successful, FALSE otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created
        JeffreyS    16-Jan-1998     Converted to HDPA (multiple lookup)

********************************************************************/

BOOL
LookupSids(HDPA hSids, LPCTSTR pszServer, LPSECURITYINFO2 psi2, PUSER_LIST *ppUserList)
{
    PSIDCACHE pSidCache;

    if (NULL == hSids)
        return FALSE;

    if (ppUserList != NULL)
        *ppUserList = NULL;

    pSidCache = GetSidCache();

    if (NULL != pSidCache)
    {
        BOOL bRet = pSidCache->LookupSids(hSids, pszServer, psi2, ppUserList);
        pSidCache->Release();
        return bRet;
    }

    return FALSE;
}

BOOL
LookupSid(PSID pSid, LPCTSTR pszServer, LPSECURITYINFO2 psi2, PUSER_LIST *ppUserList)
{
    BOOL fResult;
    HDPA hSids = NULL;

    if (NULL == pSid)
        return FALSE;

    hSids = DPA_Create(1);

    if (NULL == hSids)
        return FALSE;

    DPA_AppendPtr(hSids, pSid);

    fResult = LookupSids(hSids, pszServer, psi2, ppUserList);

    if (NULL != hSids)
        DPA_Destroy(hSids);

    return fResult;
}

// Private data structure used by LookupSidsAsync to pass
// data needed by the thread
typedef struct _LOOKUPSIDSDATA
{
    HDPA hSids;
    LPTSTR pszServer;
    HWND hWndNotify;
    UINT uMsgNotify;
} LOOKUPSIDSDATA, *PLOOKUPSIDSDATA;


DWORD WINAPI
_LookupSidsAsyncProc(LPVOID pv)
{
    PLOOKUPSIDSDATA pdata = (PLOOKUPSIDSDATA)pv;

    if (pdata)
    {
        PSIDCACHE pSidCache = GetSidCache();

        if (NULL != pSidCache)
        {
            pSidCache->LookupSidsAsync(pdata->hSids,
                                       pdata->pszServer,
                                       NULL,
                                       pdata->hWndNotify,
                                       pdata->uMsgNotify);
            pSidCache->Release();
        }

        PostMessage(pdata->hWndNotify, pdata->uMsgNotify, 0, 0);

        DestroyDPA(pdata->hSids);
        LocalFreeString(&pdata->pszServer);
        LocalFree(pdata);
    }

    FreeLibraryAndExitThread(GetModuleHandle(c_szDllName), 0);
    return 0;
}

BOOL
LookupSidsAsync(HDPA hSids,
                LPCTSTR pszServer,
                LPSECURITYINFO2 psi2,
                HWND hWndNotify,
                UINT uMsgNotify,
                PHANDLE phThread)
{
    PLOOKUPSIDSDATA pdata;

    if (phThread)
        *phThread = NULL;

    if (NULL == hSids)
        return FALSE;

    if (psi2)
    {
        // Should marshal psi2 into a stream and do this on the
        // other thread.  Well No one has implemented psi2 so its fine.
        BOOL bResult = LookupSids(hSids, pszServer, psi2, NULL);
        PostMessage(hWndNotify, uMsgNotify, 0, 0);
        return bResult;
    }

    //
    // Copy all of the data so the thread can be abandoned if necessary
    //
    pdata = (PLOOKUPSIDSDATA)LocalAlloc(LPTR, SIZEOF(LOOKUPSIDSDATA));
    if (pdata)
    {
        int cSids;
        int i;
        HINSTANCE hInstThisDll;
        DWORD dwThreadId;
        HANDLE hThread;

        cSids = DPA_GetPtrCount(hSids);
        pdata->hSids = DPA_Create(cSids);

        if (!pdata->hSids)
        {
            LocalFree(pdata);
            return FALSE;
        }

        for (i = 0; i < cSids; i++)
        {
            PSID p2 = LocalAllocSid((PSID)DPA_FastGetPtr(hSids, i));
            if (p2)
            {
                DPA_AppendPtr(pdata->hSids, p2);
            }
        }

        if (pszServer)
            LocalAllocString(&pdata->pszServer, pszServer);

        pdata->hWndNotify = hWndNotify;
        pdata->uMsgNotify = uMsgNotify;

        // Give the thread we are about to create a ref to the dll,
        // so that the dll will remain for the lifetime of the thread
        hInstThisDll = LoadLibrary(c_szDllName);

        hThread = CreateThread(NULL,
                               0,
                               _LookupSidsAsyncProc,
                               pdata,
                               NULL,
                               &dwThreadId);
        if (hThread != NULL)
        {
            if (phThread)
                *phThread = hThread;
            else
                CloseHandle(hThread);
            return TRUE;
        }
        else
        {
            // Thread creation has failed; clean up
            DestroyDPA(pdata->hSids);
            LocalFreeString(&pdata->pszServer);
            LocalFree(pdata);
            FreeLibrary(hInstThisDll);
        }
    }
    return FALSE;
}

BOOL
BuildUserDisplayName(LPTSTR *ppszDisplayName,
                     LPCTSTR pszName,
                     LPCTSTR pszLogonName)
{
    TCHAR szDisplayName[MAX_PATH];

    if (NULL == ppszDisplayName || NULL == pszName)
        return FALSE;

    *ppszDisplayName = NULL;

    if (NULL != pszLogonName && *pszLogonName)
    {
        return (BOOL)FormatStringID(ppszDisplayName,
                                    ::hModule,
                                    IDS_FMT_USER_DISPLAY,
                                    pszName,
                                    pszLogonName);
    }

    return SUCCEEDED(LocalAllocString(ppszDisplayName, pszName));
}


/*******************************************************************

    NAME:       LoadImageList

    SYNOPSIS:   Creates an image list from a bitmap resource

    ENTRY:      hInstance - the bitmap lives here
                pszBitmapID - resource ID of the bitmap

    EXIT:

    RETURNS:    HIMAGELIST if successful, NULL otherwise

    NOTES:
        In order to calculate the number of images, it is assumed
        that the width and height of a single image are the same.

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

HIMAGELIST
LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID)
{
    HIMAGELIST himl = NULL;
    HBITMAP hbm = LoadBitmap(hInstance, pszBitmapID);

    if (hbm != NULL)
    {
        BITMAP bm;
        GetObject(hbm, SIZEOF(bm), &bm);

        himl = ImageList_Create(bm.bmHeight,    // height == width
                                bm.bmHeight,
                                ILC_COLOR | ILC_MASK,
                                bm.bmWidth / bm.bmHeight,
                                0);  // don't need to grow
        if (himl != NULL)
            ImageList_AddMasked(himl, hbm, CLR_DEFAULT);

        DeleteObject(hbm);
    }

    return himl;
}


/*******************************************************************

    NAME:       GetSidImageIndex

    SYNOPSIS:   Gets the image index for the given SID type

    ENTRY:      sidType - type of SID
                sidSys - well-known group type
                fRemoteUser - TRUE if SID is a user on a remote system

    EXIT:

    RETURNS:    index into image list

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

SID_IMAGE_INDEX
GetSidImageIndex(PSID psid,
                 SID_NAME_USE sidType)
{
    SID_IMAGE_INDEX idBitmap;

    switch (sidType)
    {
    case SidTypeUser:
        idBitmap = SID_IMAGE_USER;
        break;

    case SidTypeAlias:
    case SidTypeGroup:
    case SidTypeWellKnownGroup:
        idBitmap = SID_IMAGE_GROUP;
        break;

    case SidTypeComputer:
        idBitmap = SID_IMAGE_COMPUTER;
        break;

    default:
        idBitmap = SID_IMAGE_UNKNOWN;
        break;
    }

    return idBitmap;
}


#include <dsrole.h>
BOOL IsStandalone(LPCTSTR pszMachine, PBOOL pbIsDC)
{
    BOOL bStandalone = TRUE;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsRole = NULL;

    //
    // Find out if target machine is a standalone machine or joined to
    // an NT domain.
    //

    __try
    {
        if (pbIsDC)
            *pbIsDC = FALSE;

        DsRoleGetPrimaryDomainInformation(pszMachine,
                                          DsRolePrimaryDomainInfoBasic,
                                          (PBYTE*)&pDsRole);
    }
    __finally
    {
    }

    if (NULL != pDsRole)
    {
        if (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation ||
            pDsRole->MachineRole == DsRole_RoleStandaloneServer)
        {
            bStandalone = TRUE;
        }
        else
            bStandalone = FALSE;

        if (pbIsDC)
        {
            if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                pDsRole->MachineRole == DsRole_RoleBackupDomainController)
            {
                *pbIsDC = TRUE;
            }
        }

        DsRoleFreeMemory(pDsRole);
    }

    return bStandalone;
}



/*******************************************************************

    NAME:       IsDACLCanonical

    SYNOPSIS:   Checks a DACL for canonical ordering

    ENTRY:      pDacl - points to DACL to check

    EXIT:

    RETURNS:    Nonzero if DACL is in canonical order, zero otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created
        JeffreyS    03-Oct-1997     Make object aces same as non-object aces

********************************************************************/

enum ACELEVEL
{
    alNonInheritAccessDenied,
    alNonInheritAccessAllowed,
    alInheritedAces,
};

BOOL
IsDACLCanonical(PACL pDacl)
{
    PACE_HEADER pAce;
    ACELEVEL currentAceLevel;
    DWORD dwAceCount;

    if (pDacl == NULL)
        return TRUE;

    currentAceLevel = alNonInheritAccessDenied;
    dwAceCount = pDacl->AceCount;

    if (dwAceCount == 0)
        return TRUE;

    for (pAce = (PACE_HEADER)FirstAce(pDacl);
         dwAceCount > 0;
         --dwAceCount, pAce = (PACE_HEADER)NextAce(pAce))
    {
        ACELEVEL aceLevel;

        //
        // NOTE: We do not skip INHERIT_ONLY aces because we want them in
        // canonical order too.
        //

        if (pAce->AceFlags & INHERITED_ACE)
        {
            aceLevel = alInheritedAces;      // don't check order here
        }
        else
        {
            switch(pAce->AceType)
            {
            case ACCESS_DENIED_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                aceLevel = alNonInheritAccessDenied;
                break;

            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                aceLevel = alNonInheritAccessAllowed;
                break;

            default:
                return FALSE;
            }
        }

        //
        // If the ace type is less than the level we are currently at,
        // then it is not canonical.
        //
        if (aceLevel < currentAceLevel)
            return FALSE;

        //
        // Update the current ace level.
        //
        currentAceLevel = aceLevel;
    }

    //
    // If we get here, then the DACL is in canonical order.
    //
    return TRUE;
}


/*******************************************************************

    NAME:       IsDenyACL

    SYNOPSIS:   Checks a DACL for Deny ACEs.  Also looks for "Deny
                All" ACEs.

    ENTRY:      pDacl - points to DACL to check

    EXIT:       *pdwWarning is 0, IDS_PERM_DENY, or IDS_PERM_DENY_ALL 

    RETURNS:    Nonzero if DACL contains any Deny ACEs, zero otherwise

    NOTES:

    HISTORY:
        JeffreyS    05-Sep-1997     Created

********************************************************************/

BOOL
IsDenyACL(PACL pDacl,
          BOOL fProtected,
          DWORD dwFullControlMask,
          LPDWORD pdwWarning)
{
    DWORD dwWarning = 0;

    TraceEnter(TRACE_MISC, "IsDenyACL");

    // NULL DACL implies "Allow Everyone Full Control"
    if (pDacl == NULL)
        goto exit_gracefully;

    // Check for empty DACL (no access to anyone)
    if (pDacl->AceCount == 0)
    {
        if (fProtected)
            dwWarning = IDS_PERM_DENY_EMPTY_DACL;
        // else the object will inherit permissions from the parent.
    }
    else
    {
        PACE_HEADER pAce;
        int iEntry;

        // Iterate through the ACL looking for "Deny All"
        for (iEntry = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
             iEntry < pDacl->AceCount;
             iEntry++, pAce = (PACE_HEADER)NextAce(pAce))
        {
            if (pAce->AceType != ACCESS_DENIED_ACE_TYPE &&
                pAce->AceType != ACCESS_DENIED_OBJECT_ACE_TYPE)
            {
                // Assuming the ACL is in canonical order, we can
                // stop as soon as we find something that isn't
                // a Deny ACE.  (Deny ACEs come first)
                break;
            }

            // Found a Deny ACE
            dwWarning = IDS_PERM_DENY;

            // Check for "Deny Everyone Full Control". Don't look
            // for ACCESS_DENIED_OBJECT_ACE_TYPE here since Object
            // aces don't have as wide an effect as normal aces.
            if (pAce->AceType == ACCESS_DENIED_ACE_TYPE &&
                ((PKNOWN_ACE)pAce)->Mask == dwFullControlMask &&
                EqualSid(GetAceSid(pAce), QuerySystemSid(UI_SID_World)))
            {
                // Found "Deny All"
                dwWarning = IDS_PERM_DENY_EVERYONE_GROUP;
                break;
            }
        }
    }

exit_gracefully:

    if (pdwWarning != NULL)
        *pdwWarning = dwWarning;

    TraceLeaveValue(dwWarning != 0);
}


/*******************************************************************

    NAME:       QuerySystemSid

    SYNOPSIS:   Retrieves the requested SID

    ENTRY:      SystemSidType - Which SID to retrieve

    EXIT:

    RETURNS:    PSID if successful, NULL otherwise

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

//
// Global array of static system SIDs, corresponding to UI_SystemSid
//
const struct
{
    SID sid;            // contains 1 subauthority
    DWORD dwSubAuth[1]; // we currently need at most 2 subauthorities
} g_StaticSids[COUNT_SYSTEM_SID_TYPES] =
{
    {{SID_REVISION,1,SECURITY_WORLD_SID_AUTHORITY,  {SECURITY_WORLD_RID}},              {0}                             },
    {{SID_REVISION,1,SECURITY_CREATOR_SID_AUTHORITY,{SECURITY_CREATOR_OWNER_RID}},      {0}                             },
    {{SID_REVISION,1,SECURITY_CREATOR_SID_AUTHORITY,{SECURITY_CREATOR_GROUP_RID}},      {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_DIALUP_RID}},             {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_NETWORK_RID}},            {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_BATCH_RID}},              {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_INTERACTIVE_RID}},        {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_SERVICE_RID}},            {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_ANONYMOUS_LOGON_RID}},    {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_PROXY_RID}},              {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_ENTERPRISE_CONTROLLERS_RID}},{0}                          },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_PRINCIPAL_SELF_RID}},     {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_AUTHENTICATED_USER_RID}}, {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_RESTRICTED_CODE_RID}},    {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_TERMINAL_SERVER_RID}},    {0}                             },
    {{SID_REVISION,1,SECURITY_NT_AUTHORITY,         {SECURITY_LOCAL_SYSTEM_RID}},       {0}                             },
    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_ADMINS}       },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_USERS}        },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_GUESTS}       },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_POWER_USERS}  },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_ACCOUNT_OPS}  },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_SYSTEM_OPS}   },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_PRINT_OPS}    },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_BACKUP_OPS}   },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_REPLICATOR}   },
//    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_RAS_SERVERS}  },
};

PSID
QuerySystemSid(UI_SystemSid SystemSidType)
{
    if (SystemSidType == UI_SID_Invalid || SystemSidType >= UI_SID_Count)
        return NULL;

    return (PSID)&g_StaticSids[SystemSidType];
}


//
// Global array of cached token SIDs
//
struct
{
    SID sid;            // SID contains 1 subauthority
    DWORD dwSubAuth[SID_MAX_SUB_AUTHORITIES - 1];
} g_TokenSids[COUNT_TOKEN_SID_TYPES] = {0};

PSID
QueryTokenSid(UI_TokenSid TokenSidType)
{
    if (TokenSidType == UI_TSID_Invalid || TokenSidType >= UI_TSID_Count)
        return NULL;

    if (0 == *GetSidSubAuthorityCount((PSID)&g_TokenSids[TokenSidType]))
    {
        HANDLE hProcessToken;

        // Get the current process's user's SID
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
        {
            BYTE buffer[sizeof(TOKEN_USER) + sizeof(g_TokenSids[0])];
            ULONG cbBuffer = sizeof(buffer);

            switch (TokenSidType)
            {
            case UI_TSID_CurrentProcessUser:
                if (GetTokenInformation(hProcessToken,
                                        TokenUser,
                                        buffer,
                                        cbBuffer,
                                        &cbBuffer))
                {
                    PTOKEN_USER ptu = (PTOKEN_USER)buffer;
                    CopyMemory(&g_TokenSids[UI_TSID_CurrentProcessUser],
                               ptu->User.Sid,
                               GetLengthSid(ptu->User.Sid));
                }
                break;

            case UI_TSID_CurrentProcessOwner:
                if (GetTokenInformation(hProcessToken,
                                        TokenOwner,
                                        buffer,
                                        cbBuffer,
                                        &cbBuffer))
                {
                    PTOKEN_OWNER pto = (PTOKEN_OWNER)buffer;
                    CopyMemory(&g_TokenSids[UI_TSID_CurrentProcessOwner],
                               pto->Owner,
                               GetLengthSid(pto->Owner));
                }
                break;

            case UI_TSID_CurrentProcessPrimaryGroup:
                if (GetTokenInformation(hProcessToken,
                                        TokenPrimaryGroup,
                                        buffer,
                                        cbBuffer,
                                        &cbBuffer))
                {
                    PTOKEN_PRIMARY_GROUP ptg = (PTOKEN_PRIMARY_GROUP)buffer;
                    CopyMemory(&g_TokenSids[UI_TSID_CurrentProcessPrimaryGroup],
                               ptg->PrimaryGroup,
                               GetLengthSid(ptg->PrimaryGroup));
                }
                break;
            }
            CloseHandle(hProcessToken);
        }

        if (0 == *GetSidSubAuthorityCount((PSID)&g_TokenSids[TokenSidType]))
            return NULL;
    }

    return (PSID)&g_TokenSids[TokenSidType];
}


/*******************************************************************

    NAME:       GetAuthenticationID

    SYNOPSIS:   Retrieves the SID associated with the credentials
                currently being used for network access.
                (runas /netonly credentials)

    ENTRY:      pszServer = server on which to lookup the account.
                            NULL indicates local system.

    EXIT:

    RETURNS:    PSID if successful, NULL otherwise.  Caller must
                free with LocalFree.

    HISTORY:
        JeffreyS    05-Aug-1999     Created

********************************************************************/
PSID
GetAuthenticationID(LPCWSTR pszServer)
{
    PSID pSid = NULL;
    HANDLE hLsa;
    NTSTATUS Status;

    //
    // These LSA calls are delay-loaded from secur32.dll using the linker's
    // delay-load mechanism.  Therefore, wrap with an exception handler.
    //
    __try
    {
        Status = LsaConnectUntrusted(&hLsa);

        if (Status == 0)
        {
            NEGOTIATE_CALLER_NAME_REQUEST Req = {0};
            PNEGOTIATE_CALLER_NAME_RESPONSE pResp;
            ULONG cbSize;
            NTSTATUS SubStatus;

            Req.MessageType = NegGetCallerName;

            Status = LsaCallAuthenticationPackage(
                            hLsa,
                            0,
                            &Req,
                            sizeof(Req),
                            (void**)&pResp,
                            &cbSize,
                            &SubStatus);

            if ((Status == 0) && (SubStatus == 0))
            {
                BYTE sid[sizeof(SID) + (SID_MAX_SUB_AUTHORITIES - 1)*sizeof(DWORD)];
                PSID psid = (PSID)sid;
                DWORD cbSid = sizeof(sid);
                WCHAR szDomain[MAX_PATH];
                DWORD cchDomain = ARRAYSIZE(szDomain);
                SID_NAME_USE sidType;

                if (LookupAccountNameW(pszServer,
                                       pResp->CallerName,
                                       psid,
                                       &cbSid,
                                       szDomain,
                                       &cchDomain,
                                       &sidType))
                {
                    pSid = LocalAllocSid(psid);
                }

                LsaFreeReturnBuffer(pResp);
            }

            LsaDeregisterLogonProcess(hLsa);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return pSid;
}


/*******************************************************************

    NAME:       CopyUnicodeString

    SYNOPSIS:   Allocates a buffer and copies a string from
                a UNICODE_STRING sources.

    ENTRY:      pszDest - pointer to destination buffer
                cchDest - # of chars in pszDest (bytes for MBCS)
                pSrc - pointer to UNICODE_STRING to copy

    EXIT:       pszDest - containing copy of string

    RETURNS:    # of chars copied, or 0 if not successful.

    NOTES:

    HISTORY:
        JeffreyS    22-Jan-1998     Created

********************************************************************/

int
CopyUnicodeString(LPTSTR pszDest, ULONG cchDest, PLSA_UNICODE_STRING pSrc)
{
    int nResult;
    ULONG cchSrc;

    // If UNICODE, cchDest is size of destination buffer in chars
    // Else (MBCS) cchDest is size of destination buffer in bytes

    if (pszDest == NULL || 0 == cchDest)
        return 0;

    *pszDest = TEXT('\0');

    if (pSrc == NULL || pSrc->Buffer == NULL)
        return 0;

    // Get # of chars in source (not including NULL)
    cchSrc = pSrc->Length/sizeof(WCHAR);


    //
    // Note that pSrc->Buffer may not be NULL terminated so we can't just
    // call lstrcpynW with cchDest.  Also, if we call lstrcpynW with cchSrc,
    // it copies the correct # of chars, but then overwrites the last char
    // with NULL giving an incorrect result.  If we call lstrcpynW with
    // (cchSrc+1) it reads past the end of the buffer, which may fault (360251)
    // causing lstrcpynW's exception handler to return 0 without NULL-
    // terminating the resulting string.
    //
    // So let's just copy the bits.
    //
    nResult = min(cchSrc, cchDest);
    CopyMemory(pszDest, pSrc->Buffer, sizeof(WCHAR)*nResult);
    if (nResult == (int)cchDest)
        --nResult;
    pszDest[nResult] = L'\0';

    return nResult;
}


/*******************************************************************

    NAME:       CopyUnicodeString

    SYNOPSIS:   Allocates a buffer and copies a string from
                a UNICODE_STRING sources.

    ENTRY:      pSrc - pointer to UNICODE_STRING to copy

    EXIT:       *ppszResult - points to LocalAlloc'd buffer containing copy.

    RETURNS:    # of chars copied, or 0 if not successful.

    NOTES:

    HISTORY:
        JeffreyS    22-Jan-1998     Created

********************************************************************/

int
CopyUnicodeString(LPTSTR *ppszResult, PLSA_UNICODE_STRING pSrc)
{
    int nResult = 0;

    if (NULL == ppszResult)
        return 0;

    *ppszResult = NULL;

    if (NULL != pSrc)
    {
        ULONG cchResult;

        *ppszResult = NULL;

        // Get # of chars in source (including NULL)
        cchResult = pSrc->Length/SIZEOF(WCHAR) + 1;

        // Allocate buffer big enough for either UNICODE or MBCS result
        *ppszResult = (LPTSTR)LocalAlloc(LPTR, cchResult * 2);

        if (*ppszResult)
        {
            nResult = CopyUnicodeString(*ppszResult, cchResult, pSrc);

            if (0 == nResult)
            {
                LocalFree(*ppszResult);
                *ppszResult = NULL;
            }
        }
    }

    return nResult;
}


//
// Test GUIDs safely
//
BOOL IsSameGUID(const GUID *p1, const GUID *p2)
{
    BOOL bResult = FALSE;

    if (!p1) p1 = &GUID_NULL;
    if (!p2) p2 = &GUID_NULL;

    __try
    {
        bResult = InlineIsEqualGUID(*p1, *p2);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return bResult;
}

/*******************************************************************

    NAME:       GetCountOfInheritableAces

    SYNOPSIS:   Get the count of aces in ACL which can be 
				inherited to child objects

    RETURNS:    Count of Aces

********************************************************************/
DWORD GetCountOfInheritableAces(PACL pAcl)
{
	if(!pAcl)
		return 0;

	DWORD dwCount = 0;
	PACE_HEADER pAce = NULL;
	int iEntry = 0;
	for (iEntry = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
         iEntry < pAcl->AceCount;
         iEntry++, pAce = (PACE_HEADER)NextAce(pAce))
	{
			 //
			 //Consider only explicit aces
			 //
			 if((!(pAce->AceFlags & INHERITED_ACE))&&(pAce->AceFlags & (OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE)))
				 dwCount++;
	}
	
	return dwCount;
}
/*******************************************************************

    NAME:       GetCountOfInheritableAces

    SYNOPSIS:   Get the count of aces in SACL or DACL which can be 
				inherited to child objects

    RETURNS:    Count of Aces

********************************************************************/
DWORD GetCountOfInheritableAces(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
	if(!pSD)
		return 0;
	
	PACL pAcl = NULL;
	BOOL bPresent;
	BOOL bDefault;
	
	if(si & DACL_SECURITY_INFORMATION)
	{
		if(GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefault))
		{
			return GetCountOfInheritableAces(pAcl);
		}
	}
	else if(si & SACL_SECURITY_INFORMATION)
	{
		if(GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefault))
		{
			return GetCountOfInheritableAces(pAcl);
		}
	}

	return 0;
}

typedef struct AclBloatInfo{
	DWORD dwInheriteAceCount;
	SECURITY_INFORMATION si;
	HFONT hFont;
	BOOL bShowHelp;
}ACL_BLOAT_INFO;

INT_PTR CALLBACK
AclBloatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ACL_BLOAT_INFO * pInfo= (ACL_BLOAT_INFO*)lParam;
			ASSERT(pInfo);
			SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pInfo);
			
			//
			//Add a warning icon
			//
			// add the warning icon			
			HICON hWarn = LoadIcon(NULL, IDI_WARNING);
			SendDlgItemMessage(hDlg,  // dialog box window handle 
							   IDC_BLOAT_WARN_ICON,              // icon identifier 
							   STM_SETIMAGE,          // message to send 
							   (WPARAM) IMAGE_ICON,   // image type 
							   (LPARAM) hWarn); // icon handle 


			//
			//Set the title of dialog box
			//
			LPTSTR pszCaption = NULL;
			if(FormatStringID(&pszCaption,
							  ::hModule,
							  pInfo->si & DACL_SECURITY_INFORMATION ? IDS_PERMISSIONS : IDS_AUDITING))
			{
				SetWindowText(hDlg, pszCaption);
				LocalFreeString(&pszCaption);
			}

			//
			//Set the warning message
			//
			UINT cItem = pInfo->dwInheriteAceCount;
			WCHAR buffer[34];
			_itow(cItem,buffer,10);
			if(FormatStringID(&pszCaption,
							  ::hModule,
							  pInfo->si & DACL_SECURITY_INFORMATION ? IDS_ACLBLOAT_NO_LIST_LINE1:IDS_ACLBLOAT_NO_LIST_SACL_LINE1,
							  buffer))
			{
				SetDlgItemText(hDlg, IDC_ACLBLOAT_LINE1, pszCaption);
				LocalFreeString(&pszCaption);
			}

			//
			//make warning bold
			//
			MakeBold(GetDlgItem(hDlg,IDC_ACLB_WARNING), &(pInfo->hFont));

			//
			//Set the line2, hide the Help button and move other buttons.
			//
			if(!pInfo->bShowHelp)
			{
				if(FormatStringID(&pszCaption,
								  ::hModule,
								  pInfo->si & DACL_SECURITY_INFORMATION ? IDS_BLOAT_PERM_LINE2_NOHELP : IDS_BLOAT_AUDIT_LINE2_NOHELP))
				{
					SetDlgItemText(hDlg, IDC_ACLB_LINE3, pszCaption);
					LocalFreeString(&pszCaption);
				}
			
				RECT rcHelp, rcCancel;
				GetWindowRect(GetDlgItem(hDlg, IDHELP), &rcHelp);
				MapWindowPoints(NULL, hDlg, (LPPOINT)&rcHelp, 2);
				GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &rcCancel);
				MapWindowPoints(NULL, hDlg, (LPPOINT)&rcCancel, 2);
				
				//
				//Hide the Help button, Move Cancel to help position 
				//and Ok to Cancel positon.
				//
				ShowWindow(GetDlgItem(hDlg, IDHELP),FALSE);				
				SetWindowPos(GetDlgItem(hDlg, IDCANCEL),
					         NULL,
						     rcHelp.left,
							 rcHelp.top,
							 0,
                             0,
                             SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
				
				SetWindowPos(GetDlgItem(hDlg, IDOK),
					         NULL,
						     rcCancel.left,
							 rcCancel.top,
							 0,
                             0,
                             SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);

			}

            break;
        }

        case WM_COMMAND:
        {
            WORD wControlID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (wControlID)
            {
				case IDOK:
				{	
					ACL_BLOAT_INFO * pInfo = (ACL_BLOAT_INFO *)GetWindowLongPtr(hDlg, DWLP_USER);
					if(pInfo->hFont)
						DeleteObject(pInfo->hFont);
					pInfo->hFont = NULL;
					EndDialog(hDlg, FALSE);
					break;
				}
				case IDCANCEL:
				{
					ACL_BLOAT_INFO * pInfo = (ACL_BLOAT_INFO *)GetWindowLongPtr(hDlg, DWLP_USER);
					if(pInfo->hFont)
						DeleteObject(pInfo->hFont);
					pInfo->hFont = NULL;

					EndDialog(hDlg, TRUE);
					break;
				}

				case IDHELP:
					HtmlHelp(NULL,					
							 L"aclui.chm::/ACLUI_acl_BP.htm",
							 HH_DISPLAY_TOPIC,
							 0);
					return TRUE;				
		
            }
            break;
        }
    }
    return FALSE;
}

//
// This function displays the "An error has occured [Continue] [Cancel]" message
//
// Returns IDOK or IDCANCEL
//
BOOL
IsAclBloated(HWND hWndParent, SECURITY_INFORMATION si, DWORD dwInheritAceCount, int idd, BOOL bShowHelp)
{
	AclBloatInfo info;
	info.dwInheriteAceCount = dwInheritAceCount;
	info.si = si;
	info.hFont = NULL;
	info.bShowHelp = bShowHelp;
    return (BOOL)DialogBoxParam(::hModule,
                               MAKEINTRESOURCE(idd),
                               hWndParent,
                               AclBloatDialogProc,
                               (LPARAM)(&info));
}

BOOL IsAclBloated(HWND hDlg, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD, DWORD dwOrgInheritAceCount, BOOL bShowHelp)
{
	ASSERT(pSD);
	BOOL fReturn = FALSE;

	DWORD dwNewInheritAceCount = GetCountOfInheritableAces(si, pSD);
	if( ((int)dwNewInheritAceCount - (int)dwOrgInheritAceCount) > ACL_BLOAT_LIMIT )
		fReturn = IsAclBloated(hDlg, 
					           si,
							   dwNewInheritAceCount - dwOrgInheritAceCount,							   
							   si & DACL_SECURITY_INFORMATION ? IDD_BLOAT_NO_LIST : IDD_BLOAT_NO_LIST_SACL,
							   bShowHelp);

	return fReturn;
}

//
//Sets the font style to bold for the hwnd.
//phNewFont gets handle to newFont which
//is to freed after hwnd is destroyed.
//
HRESULT MakeBold (HWND hwnd, HFONT *phNewFont)
{
	HRESULT hr = S_OK;
	HFONT hFont = NULL;
	*phNewFont = NULL;
	LOGFONT LogFont;

	if(!hwnd || !phNewFont)
		return E_POINTER;


	hFont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	if (!hFont)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
    

	if (!GetObject(hFont,sizeof(LOGFONT),(LPVOID)(&LogFont)))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}

	LogFont.lfWeight = FW_BOLD;

	if (!(*phNewFont = CreateFontIndirect(&LogFont)))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}

	SendMessage(hwnd,WM_SETFONT,(WPARAM)(*phNewFont),MAKELPARAM(FALSE,0));

	return S_OK;	
}

//+----------------------------------------------------------------------------
//  Function:DoDisabledCheck   
//  Synopsis:Check if any of the object in pDsSelList is disabled. if yes,
//				 function displays a dialog box to user. 
//  Returns: TRUE if to add objects in list to acl else no.   
//-----------------------------------------------------------------------------
BOOL
DoDisabledCheck(IN HWND hWnd,
					 IN PDS_SELECTION_LIST pDsSelList)
{
	if(!pDsSelList)
	{
		return FALSE;
	}

	HRESULT hr = S_OK;
	int cNames = pDsSelList->cItems;
	BOOL bDisabled = FALSE;

	//
	//Check if account of any of the object in the list is disbled
	//
   for (int i = 0; i < cNames; i++)
   {
	  //Second element in the array is pointer to UserAccountControl
      LPVARIANT pvarUAC = pDsSelList->aDsSelection[i].pvarFetchedAttributes + 1;

      if (NULL == pvarUAC || (VT_I4 != V_VT(pvarUAC)))
		{
			continue;
		}
		if(bDisabled = V_I4(pvarUAC) & UF_ACCOUNTDISABLE)
			break;
	}

	BOOL bReturn = TRUE;
	if(bDisabled)
	{
		WCHAR szBuffer[1024];
		WCHAR szCaption[1024];
		LoadString(::hModule, IDS_DISABLED_USER, szBuffer, ARRAYSIZE(szBuffer));
		LoadString(::hModule, IDS_SECURITY, szCaption, ARRAYSIZE(szCaption));
		if(IDCANCEL == MessageBox(hWnd, 
									    szBuffer, 
										 szCaption, 
									    MB_OKCANCEL | MB_ICONWARNING | MB_APPLMODAL ))
		{
			bReturn = FALSE;
		}
	}

	return bReturn;
}


BOOL
IsCallBackAcePresentInSD(PSECURITY_DESCRIPTOR pSD)
{
   if (pSD == NULL || !IsValidSecurityDescriptor(pSD))
		return FALSE;

	PACL pAcl = NULL;
   BOOL bDefaulted = FALSE;
   BOOL bPresent = FALSE;

	if(!GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefaulted))
		return FALSE;

	if(!bPresent || !pAcl)
		return FALSE;
	
	return IsCallBackAcePresentInAcl(pAcl);
}

BOOL 
IsCallBackAcePresentInAcl(PACL pAcl)
{
	 if(!pAcl)
		 return FALSE;

   DWORD dwAceCount = pAcl->AceCount;

   if (dwAceCount == 0)
        return FALSE;

	PACE_HEADER pAce;
   for (pAce = (PACE_HEADER)FirstAce(pAcl);
        dwAceCount > 0;
        --dwAceCount, pAce = (PACE_HEADER)NextAce(pAce))
	{
		if(pAce->AceType >= ACCESS_ALLOWED_CALLBACK_ACE_TYPE &&
			pAce->AceType <= SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE)
		{
			return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\perm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       perm.cpp
//
//  This file contains the implementation for the simple permission
//  editor page.
//
//--------------------------------------------------------------------------

#include "permset.h"
#include "sddl.h"       // ConvertSidToStringSid

#define IDN_CHECKSELECTION  1

void SelectListViewItem(HWND hwndList, int iItem);


//
//  Context Help IDs.
//
const static DWORD aPermPageHelpIDs[] =
{
    IDC_SPP_GROUP_USER_NAME,    IDH_SPP_PRINCIPALS,
    IDC_SPP_PRINCIPALS,         IDH_SPP_PRINCIPALS,
    IDC_SPP_ADD,                IDH_SPP_ADD,
    IDC_SPP_REMOVE,             IDH_SPP_REMOVE,
    IDC_SPP_ACCESS,             IDH_SPP_PERMS,
    IDC_SPP_ACCESS_BIG,         IDH_SPP_PERMS,
    IDC_SPP_ALLOW,              IDH_SPP_PERMS,
    IDC_SPP_DENY,               IDH_SPP_PERMS,
    IDC_SPP_PERMS,              IDH_SPP_PERMS,
    IDC_SPP_STATIC_ADV,         IDH_SPP_ADVANCED,
    IDC_SPP_ADVANCED,           IDH_SPP_ADVANCED,
    IDC_SPP_MORE_MSG,           IDH_NOHELP,
    0, 0,
};


class CPrincipal;
typedef class CPrincipal *LPPRINCIPAL;
class CSecurityInfo;


class CPermPage : public CSecurityPage
{
private:
    SECURITY_DESCRIPTOR_CONTROL m_wSDControl;
    WORD            m_wDaclRevision;
    PSI_ACCESS      m_pDefaultAccess;
    BOOL            m_fPageDirty;
    BOOL            m_fBusy;
    BOOL            m_bWasDenyAcl;
    BOOL            m_bCustomPermission;
    HCURSOR         m_hcurBusy;
    HWND            m_hEffectivePerm;
	DWORD			m_cInheritableAces;
	SI_ACCESS		m_CustomAccess;
    //This is set to true when user cannot read and write dacl however
    //has right to change owner. After changing owner, user will be able 
    //to read/write acl. ACLUI doesn't have refresh function so user needs
    //to close and reopen the property sheet. So if m_CustomAccess is set
    //to true and user changes owner we will show an error message to close
    //and reopen the property sheet.
    //NTRAID#NTBUG9-621338-2002/05/23-hiteshr
    BOOL            m_bNoReadWriteCanWriteOwner;

public:
    CPermPage(LPSECURITYINFO psi)
        : CSecurityPage(psi, SI_PAGE_PERM), 
          m_wDaclRevision(ACL_REVISION),
          m_hEffectivePerm(NULL),
		  m_cInheritableAces(0),
          m_bNoReadWriteCanWriteOwner(FALSE)
          { m_hcurBusy = LoadCursor(NULL, IDC_APPSTARTING); }

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL InitDlg(HWND hDlg);
    void InitPrincipalList(HWND hDlg, PACL pDacl);
    HRESULT InitCheckList(HWND hDlg);
    void EnumerateAcl(HWND hwndList, PACL pAcl);
    HRESULT SetPrincipalNamesInList(HWND hwndList, PSID pSid = NULL);

    int AddPrincipalToList(HWND hwndList, LPPRINCIPAL pPrincipal);
    BOOL OnNotify(HWND hDlg, int idCtrl, LPNMHDR pnmh);
    void OnSelChange(HWND hDlg, BOOL bClearFirst = TRUE, BOOL bClearCustomAllow = FALSE, BOOL bClearCustomDeny = FALSE);
    void OnApply(HWND hDlg, BOOL bClose);
    HRESULT BuildDacl(HWND hDlg,
                      PSECURITY_DESCRIPTOR *ppSD,
                      BOOL fIncludeInherited);
    HRESULT SetDacl(HWND hDlg,
                    PSECURITY_DESCRIPTOR psd,
                    BOOL bDirty = FALSE);
    void OnAddPrincipal(HWND hDlg);
    void OnRemovePrincipal(HWND hDlg);
    void OnAdvanced(HWND hDlg);
    void EnablePrincipalControls(HWND hDlg, BOOL fEnable);
    void CommitCurrent(HWND hDlg, int iPrincipal = -1);
    void OnSize(HWND hDlg, DWORD dwSizeType, ULONG nWidth, ULONG nHeight);
    void ClearPermissions(HWND hwndList, BOOL bDisabled = TRUE);
    void SetDirty(HWND hDlg, BOOL bDefault = FALSE);
    void SetEffectivePerm(HWND hwnd){m_hEffectivePerm = hwnd;}
    VOID SetPermLabelText(HWND hDlg);

    friend class CPrincipal;
    friend class CSecurityInfo;
};
typedef class CPermPage *PPERMPAGE;

class CPrincipal
{
private:
    PPERMPAGE       m_pPage;
    LPTSTR          m_pszName;
    LPTSTR          m_pszDisplayName;  //This is only name. Doesn't include Logon Name
    PSID            m_pSID;
    SID_IMAGE_INDEX m_nImageIndex;
    BOOL            m_bHaveRealName;

public:
    CPermissionSet  m_permDeny;
    CPermissionSet  m_permAllow;
    CPermissionSet  m_permInheritedDeny;
    CPermissionSet  m_permInheritedAllow;

    HDSA            m_hAdditionalAllow;
    HDSA            m_hAdditionalDeny;

public:
    CPrincipal(CPermPage *pPage) : m_pPage(pPage), m_nImageIndex(SID_IMAGE_UNKNOWN), 
                                   m_pszDisplayName(NULL)  {}
    ~CPrincipal();

    BOOL    SetPrincipal(PSID pSID,
                         SID_NAME_USE sidType = SidTypeUnknown,
                         LPCTSTR pszName = NULL,
                         LPCTSTR pszLogonName = NULL);
    BOOL    SetName(LPCTSTR pszName, LPCTSTR pszLogonName = NULL);
    void    SetSidType(SID_NAME_USE sidType) { m_nImageIndex = GetSidImageIndex(m_pSID, sidType); }
    PSID    GetSID()  const { return m_pSID; }
    LPCTSTR GetName() const { return m_pszName; }
    LPCTSTR GetDisplayName() const{ return m_pszDisplayName ? m_pszDisplayName : m_pszName; }
    int     GetImageIndex() const { return m_nImageIndex; }

    BOOL    HaveRealName() { return m_bHaveRealName; }

    BOOL    AddAce(PACE_HEADER pAce);
    ULONG   GetAclLength(DWORD dwFlags);
    BOOL    AppendToAcl(PACL pAcl, DWORD dwFlags, PACE_HEADER *ppAcePos);

    BOOL    HaveInheritedAces(void);
    void    ConvertInheritedAces(BOOL bDelete);

    void    AddPermission(BOOL bAllow, PPERMISSION pperm);
    void    RemovePermission(BOOL bAllow, PPERMISSION pperm);

private:
    CPermissionSet* GetPermSet(DWORD dwType, BOOL bInherited);
    BOOL AddNormalAce(DWORD dwType, DWORD dwFlags, ACCESS_MASK mask, const GUID *pObjectType);
    BOOL AddAdvancedAce(DWORD dwType, PACE_HEADER pAce);
};

// flag bits for GetAclLength & AppendToAcl
#define ACL_NONINHERITED    0x00010000L
#define ACL_INHERITED       0x00020000L
#define ACL_DENY            0x00040000L
#define ACL_ALLOW           0x00080000L
#define ACL_CHECK_CREATOR   0x00100000L
#define ACL_NONOBJECT       PS_NONOBJECT
#define ACL_OBJECT          PS_OBJECT


//
// Wrapper for ISecurityInformation.  Used when invoking
// the advanced ACL editor
//
class CSecurityInfo : public ISecurityInformation, ISecurityInformation2, 
                      IEffectivePermission, ISecurityObjectTypeInfo
    , IDsObjectPicker
{
private:
    ULONG       m_cRef;
    PPERMPAGE   m_pPage;
    HWND        m_hDlg;

public:
    CSecurityInfo(PPERMPAGE pPage, HWND hDlg)
        : m_cRef(1), m_pPage(pPage), m_hDlg(hDlg) {}

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISecurityInformation methods
    STDMETHODIMP GetObjectInformation(PSI_OBJECT_INFO pObjectInfo);
    STDMETHODIMP GetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR *ppSD,
                             BOOL fDefault);
    STDMETHODIMP SetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD);
    STDMETHODIMP GetAccessRights(const GUID* pguidObjectType,
                                 DWORD dwFlags,
                                 PSI_ACCESS *ppAccess,
                                 ULONG *pcAccesses,
                                 ULONG *piDefaultAccess);
    STDMETHODIMP MapGeneric(const GUID* pguidObjectType,
                            UCHAR *pAceFlags,
                            ACCESS_MASK *pmask);
    STDMETHODIMP GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                 ULONG *pcInheritTypes);
    STDMETHODIMP PropertySheetPageCallback(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage);

    // ISecurityInformation2 methods
    STDMETHODIMP_(BOOL) IsDaclCanonical(PACL pDacl);
    STDMETHODIMP        LookupSids(ULONG cSids, PSID *rgpSids, LPDATAOBJECT *ppdo);

    // IDsObjectPicker methods
    STDMETHODIMP Initialize(PDSOP_INIT_INFO pInitInfo);
    STDMETHODIMP InvokeDialog(HWND hwndParent, IDataObject **ppdoSelection);

    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray);

    STDMETHOD(GetEffectivePermission) (  THIS_ const GUID* pguidObjectType,
                                         PSID pUserSid,
                                         LPCWSTR pszServerName,
                                         PSECURITY_DESCRIPTOR pSD,
                                         POBJECT_TYPE_LIST *ppObjectTypeList,
                                         ULONG *pcObjectTypeListLength,
                                         PACCESS_MASK *ppGrantedAccessList,
                                         ULONG *pcGrantedAccessListLength);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\permset.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       permset.cpp
//
//  This file contains the implementation for the CPermissionSet class
//
//--------------------------------------------------------------------------

#include "aclpriv.h"
#include "permset.h"


void
CPermissionSet::Reset()
{
    TraceEnter(TRACE_PERMSET, "CPermissionSet::Reset");

    // Clear the lists

    if (m_hPermList != NULL)
    {
        DSA_Destroy(m_hPermList);
        m_hPermList = NULL;
    }

    DestroyDPA(m_hAdvPermList);
    m_hAdvPermList = NULL;

    m_fObjectAcesPresent = FALSE;

    TraceLeaveVoid();
}

void
CPermissionSet::ResetAdvanced()
{
    TraceEnter(TRACE_PERMSET, "CPermissionSet::ResetAdvanced");

    DestroyDPA(m_hAdvPermList);
    m_hAdvPermList = NULL;

    TraceLeaveVoid();
}


BOOL
CPermissionSet::AddAce(LPCGUID pguid, ACCESS_MASK mask, DWORD dwFlags)
{
    PERMISSION perm = { mask, dwFlags, 0 };

    if (pguid != NULL)
        perm.guid = *pguid;

    return AddPermission(&perm);
}


BOOL
CPermissionSet::AddPermission(PPERMISSION pPerm)
{
    BOOL bObjectTypePresent = FALSE;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::AddAce");
    TraceAssert(pPerm != NULL);

    if (!IsEqualGUID(pPerm->guid, GUID_NULL))
        bObjectTypePresent = TRUE;

    if (m_hPermList == NULL)
    {
        m_hPermList = DSA_Create(SIZEOF(PERMISSION), 4);
        if (m_hPermList == NULL)
            TraceLeaveValue(FALSE);
    }
    else
    {
        //
        // Try to merge with an existing entry in the list.
        //
        UINT cItems = DSA_GetItemCount(m_hPermList);
        while (cItems > 0)
        {
            PPERMISSION pPermCompare;
            DWORD dwMergeFlags;
            DWORD dwMergeResult;
            DWORD dwMergeStatus;

            --cItems;
            pPermCompare = (PPERMISSION)DSA_GetItemPtr(m_hPermList, cItems);

            dwMergeFlags = 0;

            if (bObjectTypePresent)
                dwMergeFlags |= MF_OBJECT_TYPE_1_PRESENT;

            if (!IsEqualGUID(pPermCompare->guid, GUID_NULL))
                dwMergeFlags |= MF_OBJECT_TYPE_2_PRESENT;

            if (!(dwMergeFlags & (MF_OBJECT_TYPE_1_PRESENT | MF_OBJECT_TYPE_2_PRESENT)))
            {
                // Neither are present, so they are the same
                dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;
            }
            else if (IsEqualGUID(pPermCompare->guid, pPerm->guid))
                dwMergeFlags |= MF_OBJECT_TYPE_EQUAL;

            dwMergeStatus = MergeAceHelper(pPerm->dwFlags,         // #1
                                           pPerm->mask,
                                           pPermCompare->dwFlags,  // #2
                                           pPermCompare->mask,
                                           dwMergeFlags,
                                           &dwMergeResult);

            if (dwMergeStatus == MERGE_MODIFIED_FLAGS)
            {
                pPerm->dwFlags = dwMergeResult;
                dwMergeStatus = MERGE_OK_1;
            }
            else if (dwMergeStatus == MERGE_MODIFIED_MASK)
            {
                pPerm->mask = dwMergeResult;
                dwMergeStatus = MERGE_OK_1;
            }

            if (dwMergeStatus == MERGE_OK_1)
            {
                //
                // The new permission implies the existing permission, so
                // the existing one can be removed.
                //
                DSA_DeleteItem(m_hPermList, cItems);
                //
                // Keep looking.  Maybe we can remove some more entries
                // before adding the new one.
                //
            }
            else if (dwMergeStatus == MERGE_OK_2)
            {
                //
                // The existing permission implies the new permission, so
                // there is nothing to do here.
                //
                TraceLeaveValue(TRUE);
            }
        }
    }

    // Ok, add the new permission to the list.
    DSA_AppendItem(m_hPermList, pPerm);

    if (bObjectTypePresent)
        m_fObjectAcesPresent = TRUE;

    TraceLeaveValue(TRUE);
}


BOOL
CPermissionSet::AddAdvancedAce(PACE_HEADER pAce)
{
    TraceEnter(TRACE_PERMSET, "CPermissionSet::AddAdvancedAce");
    TraceAssert(pAce != NULL);

    // Create list if necessary
    if (m_hAdvPermList == NULL)
    {
        m_hAdvPermList = DPA_Create(4);
        if (m_hAdvPermList == NULL)
        {
            TraceMsg("DPA_Create failed");
            TraceLeaveValue(FALSE);
        }
    }

    // This is as big as we need, but sometimes incoming ACEs are extra big.
    UINT nAceLen = SIZEOF(KNOWN_OBJECT_ACE) + 2*SIZEOF(GUID) - SIZEOF(DWORD)
        + GetLengthSid(GetAceSid(pAce));

    // Use the incoming AceSize only if it's smaller
    if (pAce->AceSize < nAceLen)
        nAceLen = pAce->AceSize;

    // Copy the ACE and add it to the list.
    PACE_HEADER pAceCopy = (PACE_HEADER)LocalAlloc(LMEM_FIXED, nAceLen);
    if (pAceCopy == NULL)
    {
        TraceMsg("LocalAlloc failed");
        TraceLeaveValue(FALSE);
    }

    CopyMemory(pAceCopy, pAce, nAceLen);
    pAceCopy->AceSize = (USHORT)nAceLen;
    DPA_AppendPtr(m_hAdvPermList, pAceCopy);

    TraceLeaveValue(TRUE);
}


UINT
CPermissionSet::GetPermCount(BOOL fIncludeAdvAces) const
{
    ULONG cAces = 0;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::GetPermCount");

    if (m_hPermList != NULL)
        cAces = DSA_GetItemCount(m_hPermList);

    if (fIncludeAdvAces && m_hAdvPermList != NULL)
        cAces += DPA_GetPtrCount(m_hAdvPermList);

    TraceLeaveValue(cAces);
}


ULONG
CPermissionSet::GetAclLength(ULONG cbSid) const
{
    // Return an estimate of the buffer size needed to hold the
    // requested ACEs. The size of the ACL header is NOT INCLUDED.

    ULONG nAclLength = 0;
    ULONG cAces;
    ULONG nAceSize = SIZEOF(KNOWN_ACE) - SIZEOF(DWORD) + cbSid;
    ULONG nObjectAceSize = SIZEOF(KNOWN_OBJECT_ACE) + SIZEOF(GUID) - SIZEOF(DWORD) + cbSid;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::GetAclLength");

    if (m_hPermList != NULL)
    {
        cAces = DSA_GetItemCount(m_hPermList);
        if (m_fObjectAcesPresent)
            nAclLength += cAces * nObjectAceSize;
        else
            nAclLength += cAces * nAceSize;
    }

    if (m_hAdvPermList != NULL)
    {
        cAces = DPA_GetPtrCount(m_hAdvPermList);
        nAclLength += cAces * (nObjectAceSize + SIZEOF(GUID));
    }

    TraceLeaveValue(nAclLength);
}


BOOL
CPermissionSet::AppendToAcl(PACL pAcl,
                            PACE_HEADER *ppAcePos,  // position to copy first ACE
                            PSID pSid,
                            BOOL fAllowAce,
                            DWORD dwFlags) const
{
    PACE_HEADER pAce;
    UINT cAces;
    DWORD dwSidSize;
    DWORD dwAceSize;
    PPERMISSION pPerm;
    UCHAR uAceType;
    PSID psidT;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::AppendToAcl");
    TraceAssert(pAcl != NULL);
    TraceAssert(ppAcePos != NULL);
    TraceAssert(pSid != NULL);

    if (*ppAcePos == NULL || (ULONG_PTR)*ppAcePos < (ULONG_PTR)FirstAce(pAcl))
        *ppAcePos = (PACE_HEADER)FirstAce(pAcl);

    TraceAssert((ULONG_PTR)*ppAcePos >= (ULONG_PTR)FirstAce(pAcl) &&
                (ULONG_PTR)*ppAcePos <= (ULONG_PTR)ByteOffset(pAcl, pAcl->AclSize));

    dwSidSize = GetLengthSid(pSid);
    dwAceSize = SIZEOF(KNOWN_ACE) - SIZEOF(DWORD) + dwSidSize;
    uAceType = (UCHAR)(fAllowAce ? ACCESS_ALLOWED_ACE_TYPE : ACCESS_DENIED_ACE_TYPE);

    cAces = GetPermCount();
    while (cAces > 0)
    {
        BOOL bObjectAce;

        pPerm = (PPERMISSION)DSA_GetItemPtr(m_hPermList, --cAces);
        if (pPerm == NULL)
            continue;

        bObjectAce = !IsEqualGUID(pPerm->guid, GUID_NULL);

        if (bObjectAce && !(dwFlags & PS_OBJECT))
            continue;
        else if (!bObjectAce && !(dwFlags & PS_NONOBJECT))
            continue;

        pAce = *ppAcePos;

        // Make sure the buffer is large enough.
        if ((ULONG_PTR)ByteOffset(*ppAcePos, dwAceSize) > (ULONG_PTR)ByteOffset(pAcl, pAcl->AclSize))
        {
            TraceMsg("ACL buffer too small");
            TraceAssert(FALSE);
            TraceLeaveValue(FALSE);
        }
        TraceAssert(!IsBadWritePtr(*ppAcePos, dwAceSize));

        // Copy the header and mask
        pAce->AceType = uAceType;
        pAce->AceFlags = (UCHAR)pPerm->dwFlags;
        pAce->AceSize = (USHORT)dwAceSize;
        ((PKNOWN_ACE)pAce)->Mask = pPerm->mask;

        // Get the normal SID location
        psidT = &((PKNOWN_ACE)pAce)->SidStart;

        if (bObjectAce)
        {
            //
            // The Object ACEs that we deal with directly do not have an
            // Inherit GUID present. Those ACEs end up in m_hAdvPermList.
            //
            GUID *pGuid;

            // Adjust AceType and AceSize and set the object Flags
            pAce->AceType += ACCESS_ALLOWED_OBJECT_ACE_TYPE - ACCESS_ALLOWED_ACE_TYPE;
            pAce->AceSize += SIZEOF(KNOWN_OBJECT_ACE) - SIZEOF(KNOWN_ACE) + SIZEOF(GUID);
            ((PKNOWN_OBJECT_ACE)pAce)->Flags = ACE_OBJECT_TYPE_PRESENT;

            // Get the object type guid location
            pGuid = RtlObjectAceObjectType(pAce);

            // We just set the flag for this, so it can't be NULL
            TraceAssert(pGuid);

            // Make sure the buffer is large enough.
            if ((ULONG_PTR)ByteOffset(pAce, pAce->AceSize) > (ULONG_PTR)ByteOffset(pAcl, pAcl->AclSize))
            {
                TraceMsg("ACL buffer too small");
                TraceAssert(FALSE);
                TraceLeaveValue(FALSE);
            }
            TraceAssert(!IsBadWritePtr(pGuid, SIZEOF(GUID)));

            // Copy the object type guid
            *pGuid = pPerm->guid;

            // Get new SID location
            psidT = RtlObjectAceSid(pAce);

            // Adjust ACL revision
            if (pAcl->AclRevision < ACL_REVISION_DS)
                pAcl->AclRevision = ACL_REVISION_DS;
        }

        // Copy the SID
        TraceAssert(!IsBadWritePtr(psidT, dwSidSize));
        CopyMemory(psidT, pSid, dwSidSize);

        // Move to next ACE position
        pAcl->AceCount++;
        *ppAcePos = (PACE_HEADER)NextAce(pAce);
    }

    if ((dwFlags & PS_OBJECT) && m_hAdvPermList != NULL)
    {
        cAces = DPA_GetPtrCount(m_hAdvPermList);
        while (cAces > 0)
        {
            pAce = (PACE_HEADER)DPA_FastGetPtr(m_hAdvPermList, --cAces);
            if (pAce == NULL)
                continue;

            // Make sure the buffer is large enough.
            if ((ULONG_PTR)ByteOffset(*ppAcePos, pAce->AceSize) > (ULONG_PTR)ByteOffset(pAcl, pAcl->AclSize))
            {
                TraceMsg("ACL buffer too small");
                TraceAssert(FALSE);
                TraceLeaveValue(FALSE);
            }
            TraceAssert(!IsBadWritePtr(*ppAcePos, pAce->AceSize));

            // Copy the ACE
            CopyMemory(*ppAcePos, pAce, pAce->AceSize);

            // Adjust ACL revision
            if (IsObjectAceType(pAce) && pAcl->AclRevision < ACL_REVISION_DS)
                pAcl->AclRevision = ACL_REVISION_DS;

            // Move to next ACE position
            pAcl->AceCount++;
            *ppAcePos = (PACE_HEADER)NextAce(*ppAcePos);
        }
    }

    TraceLeaveValue(TRUE);
}


void
CPermissionSet::ConvertInheritedAces(CPermissionSet &permInherited)
{
    UINT cItems;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::ConvertInheritedAces");

    if (permInherited.m_hPermList != NULL)
    {
        PPERMISSION pPerm;

        cItems = DSA_GetItemCount(permInherited.m_hPermList);
        while (cItems)
        {
            --cItems;
            pPerm = (PPERMISSION)DSA_GetItemPtr(permInherited.m_hPermList, cItems);
            if (pPerm != NULL)
            {
                pPerm->dwFlags &= ~INHERITED_ACE;
                AddPermission(pPerm);
            }
        }
    }

    if (permInherited.m_hAdvPermList != NULL)
    {
        PACE_HEADER pAceHeader;

        cItems = DPA_GetPtrCount(permInherited.m_hAdvPermList);
        while (cItems)
        {
            --cItems;
            pAceHeader = (PACE_HEADER)DPA_FastGetPtr(permInherited.m_hAdvPermList, cItems);
            if (pAceHeader != NULL)
            {
                pAceHeader->AceFlags &= ~INHERITED_ACE;
                AddAdvancedAce(pAceHeader);
            }
        }
    }

    permInherited.Reset();

    TraceLeaveVoid();
}

//Removes permission. If bInheritFlag, match inheritance flags before
//removing permission
void
CPermissionSet::RemovePermission(PPERMISSION pPerm, BOOL bInheritFlag )
{
    BOOL bObjectAcePresent = FALSE;

    TraceEnter(TRACE_PERMSET, "CPermissionSet::RemovePermission");
    TraceAssert(pPerm != NULL);

    if (m_hPermList)
    {
        BOOL bNullGuid = IsEqualGUID(pPerm->guid, GUID_NULL);
        UINT cItems = DSA_GetItemCount(m_hPermList);
        while (cItems > 0)
        {
            PPERMISSION pPermCompare;
            BOOL bNullGuidCompare;

            --cItems;
            pPermCompare = (PPERMISSION)DSA_GetItemPtr(m_hPermList, cItems);

            bNullGuidCompare = IsEqualGUID(pPermCompare->guid, GUID_NULL);

            if (bNullGuid || bNullGuidCompare || IsEqualGUID(pPermCompare->guid, pPerm->guid))
            {
                if( !bInheritFlag || ( (pPermCompare->dwFlags & VALID_INHERIT_FLAGS) == (pPerm->dwFlags & VALID_INHERIT_FLAGS) ) )
                {
                    pPermCompare->mask &= ~pPerm->mask;
                    if (0 == pPermCompare->mask)
                        DSA_DeleteItem(m_hPermList, cItems);
                    else if (!bNullGuidCompare)
                        bObjectAcePresent = TRUE;
                }
            }
            else if (!bNullGuidCompare)
                bObjectAcePresent = TRUE;
        }
    }

    m_fObjectAcesPresent = bObjectAcePresent;

    TraceLeaveVoid();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\permset.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       permset.h
//
//  This file contains the definition of the CPermissionSet class
//
//--------------------------------------------------------------------------

#ifndef _PERMSET_H_
#define _PERMSET_H_

typedef struct _PERMISSION
{
    ACCESS_MASK mask;       // permission bits
    DWORD       dwFlags;    // AceFlags (e.g. inheritance bits)
    GUID        guid;       // often GUID_NULL
} PERMISSION, *PPERMISSION;

class CPermissionSet
{
private:
    HDSA m_hPermList;       // Dynamic array of PERMISSION structures
    HDPA m_hAdvPermList;    // Dynamic array of ACE pointers
    BOOL m_fObjectAcesPresent;

public:
    CPermissionSet() : m_hPermList(NULL), m_hAdvPermList(NULL), m_fObjectAcesPresent(FALSE) {}
    ~CPermissionSet() { Reset(); }

    void Reset();
    void ResetAdvanced();
    BOOL AddAce(const GUID *pguid, ACCESS_MASK mask, DWORD dwFlags);
    BOOL AddPermission(PPERMISSION pPerm);
    BOOL AddAdvancedAce(PACE_HEADER pAce);
    UINT GetPermCount(BOOL fIncludeAdvAces = FALSE) const;
    PPERMISSION GetPermission(UINT i) const { if (m_hPermList) return (PPERMISSION)DSA_GetItemPtr(m_hPermList, i); return NULL; }
    PPERMISSION operator[](UINT i) const { return GetPermission(i); }
    ULONG GetAclLength(ULONG cbSid) const;
    BOOL AppendToAcl(PACL pAcl, PACE_HEADER *ppAcePos, PSID pSid, BOOL fAllowAce, DWORD dwFlags) const;
    void ConvertInheritedAces(CPermissionSet &permInherited);
    void RemovePermission(PPERMISSION pPerm, BOOL bInheritFlag = FALSE);
};

// Flags for AppendToAcl
#define PS_NONOBJECT        0x00000001L
#define PS_OBJECT           0x00000002L


#endif  // _PERMSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ACLUI.rc
//
#define IDS_SECURITY                    1
#define IDS_NAME                        2
#define IDS_VIEW                        3
#define IDS_INITDLG_FAILED              4
#define IDS_OUT_OF_MEMORY               5
#define IDS_OPERATION_FAILED            6
#define IDS_SID_UNKNOWN                 7
#define IDS_SID_DELETED                 8
#define IDS_GET_USER_FAILED             9
#define IDS_SID_LOOKUP_FAILED           10
#define IDS_RESET_DACL_WARNING          11
#define IDS_FMT_USER_DISPLAY            12
#define IDS_FMT_CHECKLABEL              13
#define IDS_PERM_READONLY               16
#define IDS_PERM_WRITE_FAILED           17
#define IDS_PERM_NOT_CANONICAL          18
#define IDS_PERM_DENY_ALL               19
#define IDS_PERM_DENY_EVERYONE_GROUP    19
#define IDS_PERM_CANT_REMOVE            20
#define IDS_PERM_CANT_READ_CAN_WRITE_DACL 21
#define IDS_PERM_CANT_READ_CAN_WRITE_OWNER 22
#define IDS_PERM_CANT_READ_CAN_AUDIT    23
#define IDS_PERM_CANT_READ_CAN_AUDIT_WRITE_OWNER 24
#define IDS_PERM_NO_ACCESS              25
#define IDS_AUDIT_WRITE_FAILED          26
#define IDS_AUDIT_OFF_WARNING           27
#define IDS_OWNER_READONLY              28
#define IDS_OWNER_WRITE_FAILED          29
#define IDS_OWNER_CANT_DISPLAY          30
#define IDS_PERM_DENY                   31
#define IDS_SPP_TITLE                   32
#define IDS_ACEL_TITLE                  33
#define IDS_ACEE_PERM_TITLE             34
#define IDS_ACEE_AUDIT_TITLE            35
#define IDS_ACEE_PROPERTY_TITLE         36
#define IDS_ACE_PERM_COLUMN_TYPE        37
#define IDS_ACE_PERM_COLUMN_NAME        38
#define IDS_ACE_PERM_COLUMN_ACCESS      39
#define IDS_ACE_PERM_COLUMN_INHERIT     40
#define IDS_ACE_AUDIT_COLUMN_TYPE       41
#define IDS_ACE_AUDIT_COLUMN_NAME       42
#define IDS_ACE_AUDIT_COLUMN_ACCESS     43
#define IDS_ACE_AUDIT_COLUMN_INHERIT    44
#define IDS_ALLOW                       48
#define IDS_DENY                        49
#define IDS_AUDIT                       50
#define IDS_ALARM                       51
#define IDS_UNKNOWN                     52
#define IDS_SPECIAL                     53
#define IDS_AUDITPASS                   54
#define IDS_AUDITFAIL                   55
#define IDS_AUDITBOTH                   56
#define IDS_READ_PROP                   57
#define IDS_WRITE_PROP                  58
#define IDS_READ_WRITE_PROP             59
#define IDS_THIS_OBJECT_ONLY            60
#define IDS_THIS_OBJECT_AND_SUBOBJECTS  61
#define IDS_SUBOBJECTS_ONLY             62
#define IDS_INVALID_INHERIT             63
#define IDS_SELCHANGE_WARNING           64
#define IDS_FMT_ACE_DESC                65
#define IDS_PERMISSION_LOCALACE_DESC    66
#define IDS_AUDITENTRY_LOCALACE_DESC    67
#define IDS_PERMISSION_INHERITEDACE_DESC 68
#define IDS_AUDITENTRY_INHERITEDACE_DESC 69
#define IDS_PERMISSION_INHERITEDONLYACE_DESC 70
#define IDS_AUDITENTRY_INHERITEDONLYACE_DESC 71
#define IDS_PERMISSION_NOINHERIT_DESC   72
#define IDS_AUDITENTRY_NOINHERIT_DESC   73
#define IDS_PERMISSION_DOESINHERIT_DESC 74
#define IDS_AUDITENTRY_DOESINHERIT_DESC 75
#define IDS_CUSTOM                      76
#define IDS_CUSTOM_CHECKBOX_WARNING     77
#define IDS_PERM_CANT_READ_MAY_WRITE_DACL 78
#define IDS_CONFIRM_MULTIPLE_DELETION   79
#define IDS_PERMISSIONS                 80
#define IDS_PERMISSION_INHERITEDONLYACE_DESC_PARENT 81
#define IDS_AUDITENTRY_INHERITEDONLYACE_DESC_PARENT 82
#define IDS_PERMISSION_INHERITEDACE_DESC_PARENT 83
#define IDS_AUDITENTRY_INHERITEDACE_DESC_PARENT 84
#define IDS_DYNAMIC_PERMISSION          85
#define IDS_ACE_PERM_COLUMN_PARENT      86
#define IDS_FROM_PARENT                 87
#define IDS_NOT_INHERITED               88
#define IDS_EFF_ERROR                   89
#define IDS_SID_DELETED_1               90
#define IDS_SID_UNKNOWN_1               91
#define IDS_NO_OBJECT_PERM              92
#define IDS_ACL_SIZE_ERROR              93
#define IDS_ACL_SIZE_ERROR_ADV          94
#define IDS_BLOAT_AUDIT_WARN            95
#define IDS_BLOAT_PERM_WARN             96
#define IDS_BLOAT_AUDIT_LINE1           97
#define IDS_BLOAT_PERM_LINE1            98
#define IDS_BLOAT_AUDIT_LINE2           99
#define IDS_BLOAT_PERM_LINE2            100
#define IDB_SID_ICONS                   101
#define IDS_AUDITING                    101
#define IDB_LOCKS                       102
#define IDS_ACLBLOAT_NO_LIST_LINE1      102
#define IDD_SIMPLE_PERM_PAGE            103
#define IDS_ACLBLOAT_NO_LIST_SACL_LINE1 103
#define IDD_ACELIST_PERM_PAGE           104
#define IDS_BLOAT_AUDIT_LINE2_NOHELP    104
#define IDD_ACELIST_AUDIT_PAGE          105
#define IDS_BLOAT_PERM_LINE2_NOHELP     105
#define IDD_ACEENTRY_PERM_PAGE          106
#define IDS_DISABLED_USER               106
#define IDD_ACEENTRY_AUDIT_PAGE         107
#define IDS_CALLBACK_ACE_PRESENT        107
#define IDD_OWNER_PAGE                  108
#define IDS_OTHER_OWNERS                108
#define IDD_CONFIRM_DACL_PROTECT        109
#define IDS_ACL_EDIT_MORE_INFO          109
#define IDD_CONFIRM_SACL_PROTECT        110
#define IDS_ACL_EDIT_MORE_INFO_1        110
#define IDD_EFFECTIVE_PERM_PAGE         111
#define IDS_NO_RESTORE_PRIV             111
#define IDB_CHECKBOX                    112
#define IDS_PERM_DENY_EMPTY_DACL        112
#define IDD_ACLBLOAT                    113
#define IDS_REFRESH_PROPERTYSHEET       113
#define IDD_BLOAT_NO_LIST               126
#define IDD_BLOAT_NO_LIST_SACL          127
#define IDC_SPP_PRINCIPALS              1000
#define IDC_SPP_ADD                     1001
#define IDC_SPP_REMOVE                  1002
#define IDC_SPP_PERMS                   1004
#define IDC_SPP_ADVANCED                1005
#define IDC_SPP_MORE_MSG                1006
#define IDC_SPP_PROTECT                 1007
#define IDC_SPP_ACCESS                  1008
#define IDC_ACLBLOAT_LINE1              1008
#define IDC_SPP_ALLOW                   1009
#define IDC_SPP_DENY                    1010
#define IDC_SPP_DONTCARE                1011
#define IDC_SPP_NO_SECURITY             1012
#define IDC_SPP_GROUP_USER_NAME         1013
#define IDC_ACEL_DETAILS                2001
#define IDC_ACEL_ADD                    2002
#define IDC_ACEL_REMOVE                 2003
#define IDC_ACEL_EDIT                   2004
#define IDC_ACEL_RESET                  2005
#define IDC_ACEL_PROTECT                2006
#define IDC_ACEL_DESCRIPTION            2007
#define IDC_ACEL_RESET_ACL_TREE         2008
#define IDC_ACEE_NAMEBUTTON             4000
#define IDC_ACEE_NAME                   4001
#define IDC_ACEE_INHERITTYPE            4002
#define IDC_ACEE_INHERITIMMEDIATE       4003
#define IDC_ACEE_LIST                   4004
#define IDC_ACEE_ACCESS                 4005
#define IDC_ACEE_ALLOW                  4006
#define IDC_ACEE_DENY                   4007
#define IDC_ACEE_DONTCARE               4008
#define IDC_ACEE_CLEAR                  4009
#define IDC_ACEE_NAME_STATIC            4010
#define IDC_ACEE_APPLYONTO_STATIC       4011
#define IDC_ACEE_INHERITWARNING         4012
#define IDC_OWN_CURRENTOWNER            5001
#define IDC_OWN_OWNERLIST               5002
#define IDC_OWN_RESET                   5003
#define IDC_OWN_RECURSE                 5004
#define IDC_OWN_CURRENTOWNER_STATIC     5005
#define IDC_OWN_OWNERLIST_STATIC        5006
#define IDC_OWN_OTHER_USER              5007
#define IDC_CONFIRM_ICON                6001
#define IDC_CONFIRM_MESSAGE             6002
#define IDC_CONFIRM_COPY                6003
#define IDC_CONFIRM_REMOVE              6004
#define IDC_EFF_SELECT                  7007
#define IDC_EFF_PERM_LIST               7009
#define IDC_EFF_NAME                    7013
#define IDC_EFF_NAME_STATIC             7014
#define IDC_EFF_PERMISSION_STATIC       7015
#define IDC_NO_EFFECTIVE                7016
#define IDC_ACEL_DEFAULT_STATIC         7019
#define IDC_ACEL_STATIC                 7020
#define IDC_EFF_STATIC                  7021
#define IDC_EFF_ERROR                   7023
#define IDC_SPP_ACCESS_BIG              7024
#define IDC_EDIT1                       7025
#define IDC_SPP_STATIC_ADV              7026
#define IDC_STATIC_NO_PERM              7027
#define IDC_ACEL_BLOAT                  7028
#define IDC_ACLB_WARNING                7029
#define IDC_BLOAT_LV_STATIC             7030
#define IDC_BLOAT_WARN_ICON             7031
#define IDC_BLOAT_LINE1_STATIC          7032
#define IDC_BLOAT_LINE2_STATIC          7033
#define IDC_WARNING                     7034
#define IDC_ACLB_LINE3                  7037
#define IDC_SPP_CALLBACK_PERMISSIONS    7038
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         7039
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\sidcache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sidcache.h
//
//  This file contains definitions and prototypes for SID/Name cache.
//
//--------------------------------------------------------------------------

#ifndef _SIDCACHE_H_
#define _SIDCACHE_H_

#include <comctrlp.h>   // DPA

DWORD WaitOnThread(HANDLE *phThread);

#define BUCKET_COUNT    31

typedef struct _sid_cache_entry
{
    DWORD   dwLastAccessTime;
    SID_NAME_USE SidType;
    PSID    pSid;
    LPCTSTR pszName;
    LPCTSTR pszLogonName;
} SID_CACHE_ENTRY, *PSID_CACHE_ENTRY;


class CSidCache
{
private:
    HDPA m_dpaSidHashTable[BUCKET_COUNT];
    CRITICAL_SECTION m_csHashTableLock;
    CRITICAL_SECTION m_csDomainNameLock;
    CRITICAL_SECTION m_csDcNameLock;
    LPTSTR m_pszCachedServer;
    LPTSTR m_pszCachedDomain;
    HANDLE m_hInitThread;
    LPTSTR m_pszLastDc;
    LPTSTR m_pszLastDomain;
    LONG   m_cRef;

public:
    CSidCache();
    ~CSidCache();

    // used to control lifetime of the object
    ULONG AddRef();
    ULONG Release();

    BOOL LookupSids(HDPA hSids, LPCTSTR pszServer, LPSECURITYINFO2 psi2, PUSER_LIST *ppUserList);
    BOOL LookupSidsAsync(HDPA hSids, LPCTSTR pszServer, LPSECURITYINFO2 psi2, HWND hWndNotify, UINT uMsgNotify);

    BOOL LookupNames(PDS_SELECTION_LIST pDsSelList, LPCTSTR pszServer, PUSER_LIST *ppUserList, BOOL bStandalone);

    void GetDomainName(LPCTSTR pszServer, LPTSTR pszDomain, ULONG cchDomain);
    void GetDcName(LPCTSTR pszDomain, LPTSTR pszDC, ULONG cchDC);

    PSID_CACHE_ENTRY FindSid(PSID pSid);
    PSID_CACHE_ENTRY MakeEntry(PSID pSid,
                               SID_NAME_USE SidType,
                               LPCTSTR pszName,
                               LPCTSTR pszLogonName = NULL);
    BOOL AddEntry(PSID_CACHE_ENTRY pEntry);

    BOOL BuildUserList(HDPA hEntryList,
                       LPCTSTR pszServer,
                       PUSER_LIST *ppUserList);

private:
    int HashSid(PSID pSid);
    static int CALLBACK CompareSid(LPVOID p1, LPVOID p2, LPARAM lParam);

    void GetUserFriendlyName(LPCTSTR pszSamLogonName,
                             LPCTSTR pszSamAccountName,
                             LPCTSTR pszServer,
                             BOOL    bUseSamCompatibleInfo,
                             BOOL    bIsStandalone,
                             BSTR   *pstrLogonName,
                             BSTR   *pstrDisplayName);
    BSTR GetNT4DisplayName(LPCTSTR pszAccount,
                           LPCTSTR pszName,
                           LPCTSTR pszServer,
                           BOOL bStandalone);

    BOOL InternalLookupSids(HDPA hSids,
                            LPCTSTR pszServer,
                            LPSECURITYINFO2 psi2,
                            HDPA hEntryList,
                            HWND hWndNotify = NULL,
                            UINT uMsgNotify = 0);
    BOOL LookupSidsHelper(HDPA hSids,
                          LPCTSTR pszServer,
                          HDPA hEntryList,
                          HWND hWndNotify = NULL,
                          UINT uMsgNotify = 0,
                          BOOL bSecondTry = FALSE,
								  BOOL bWellKnown = FALSE);
    HRESULT LookupSidsFromObject(HDPA hSids, LPSECURITYINFO2 psi2, HDPA hEntryList);


    BOOL InternalLookupNames(PDS_SELECTION_LIST pDsSelList,
                             LPCTSTR pszServer,
                             HDPA hEntryList,
                             BOOL bStandalone);


    static DWORD WINAPI InitThread(LPVOID pvThreadData);

    void Lock()     { EnterCriticalSection(&m_csHashTableLock); }
    void Unlock()   { LeaveCriticalSection(&m_csHashTableLock); }

    void LockDomain()   { EnterCriticalSection(&m_csDomainNameLock); }
    void UnlockDomain() { LeaveCriticalSection(&m_csDomainNameLock); }

    void LockDc()   { EnterCriticalSection(&m_csDcNameLock); }
    void UnlockDc() { LeaveCriticalSection(&m_csDcNameLock); }
};
typedef CSidCache *PSIDCACHE;

//
// Helper functions for creating/deleting the global SID Cache
//
PSIDCACHE GetSidCache();
void FreeSidCache();

#endif  // _SIDCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\uuid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       uuid.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <aclui.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\sources.inc ===
TARGETNAME=aclui
TARGETPATH=obj
TARGETTYPE=DYNLINK

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}

DLLDEF=$(O)\$(TARGETNAME).def
DLLENTRY=DllMain
USE_NTDLL=1

INCLUDES=..;..\..\inc;$(BASE_INC_PATH)

DELAYLOAD=netapi32.dll;secur32.dll
DLOAD_ERROR_HANDLER = kernel32

# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.ServerGroup.sec
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=sec.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_MANIFEST_RESOURCE_ID=123
SXS_NO_BINPLACE=1


LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

LINKLIBS=\
    ..\..\common\winnt\$(O)\common.lib     \

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\gdi32.lib       \
    $(SDK_LIB_PATH)\shlwapi.lib     \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\oleaut32.lib    \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\netapi32.lib    \
    $(SDK_LIB_PATH)\adsiid.lib      \
    $(SDK_LIB_PATH)\secur32.lib     \
    $(SDK_LIB_PATH)\htmlhelp.lib       \
    $(SHELL_LIB_PATH)\shfusion.lib    \
    $(SHELL_LIB_PATH)\shell32p.lib    \

SOURCES=\
    ..\aclui.rc     \
    ..\uuid.c       \
    ..\dll.cpp      \
    ..\ace.cpp      \
    ..\acelist.cpp  \
    ..\owner.cpp    \
    ..\aceedit.cpp  \
    ..\chklist.cpp  \
    ..\misc.cpp     \
    ..\pagebase.cpp \
    ..\perm.cpp     \
    ..\permset.cpp  \
    ..\cstrings.cpp \
    ..\sidcache.cpp \
    ..\effperm.cpp  \
    ..\aclbloat.cpp \


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\aclpriv.h
PRECOMPILED_PCH=aclpriv.pch
PRECOMPILED_OBJ=aclpriv.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       version.h
//
//--------------------------------------------------------------------------

// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Security Descriptor Editor"
#define VER_INTERNALNAME_STR            "aclui.dll"
#define VER_LEGALCOPYRIGHT_YEARS        "1998"
#define VER_ORIGINALFILENAME_STR        "aclui.dll"

#include <ntverp.h>
#include <common.ver>

#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\aclui\sidcache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sidcache.cpp
//
//  This file contains the implementation of a SID/Name cache.
//
//--------------------------------------------------------------------------

#include "aclpriv.h"

#include <dsgetdc.h>    // DsGetDcName
#include <iads.h>


#define SECURITY_WIN32
#include <security.h>   // TranslateName
#include <lm.h>         // NetApiBufferFree
#include <shlwapi.h>    // StrChr, StrRChr

// 10 minutes
#define SID_CACHE_AGE_LIMIT     (10*60*1000)

TCHAR const c_szNTProvider[]    = TEXT("WinNT://");
#define NTPROV_LEN              (ARRAYSIZE(c_szNTProvider)-1)

#define ACLUI_ALIGNED_SID_LENGTH(p) ((PtrAlignSize(RtlLengthSid((p)))))

PSIDCACHE g_pSidCache = NULL;

PSIDCACHE GetSidCache()
{
    if (NULL == g_pSidCache)
    {
        // The cache starts with an extra ref here that will be released
        // during our DLL_PROCESS_DETACH
        g_pSidCache = new CSidCache;

        if (g_pSidCache)
        {
            g_pSidCache->AddRef();
        }
    }
    else
    {
        g_pSidCache->AddRef();
    }

    return g_pSidCache;
}

void FreeSidCache()
{
    if (g_pSidCache)
    {
        g_pSidCache->Release();
        g_pSidCache = NULL;
    }
}

//
// CSidCache implementation
//

CSidCache::CSidCache()
: m_pszCachedServer(NULL), m_pszCachedDomain(NULL),
  m_hInitThread(NULL), m_pszLastDc(NULL), m_pszLastDomain(NULL),
  m_cRef(1)
{
    HINSTANCE hInstThisDll;
    DWORD dwThreadID;

    ZeroMemory(m_dpaSidHashTable, SIZEOF(m_dpaSidHashTable));
    ExceptionPropagatingInitializeCriticalSection(&m_csHashTableLock);
    ExceptionPropagatingInitializeCriticalSection(&m_csDomainNameLock);
    ExceptionPropagatingInitializeCriticalSection(&m_csDcNameLock);

    // Give the thread we are about to create a ref to the dll,
    // so that the dll will remain for the lifetime of the thread
    hInstThisDll = LoadLibrary(c_szDllName);
    if (hInstThisDll != NULL)
    {
        // also do an AddRef() for the worker thread to release later
        AddRef();

        // Start a thread to cache the well-known and built-in SIDs
        m_hInitThread = CreateThread(NULL, 0, InitThread, this, 0, &dwThreadID);

        if (!m_hInitThread)
        {
            // Failed to create the thread, do cleanup
            FreeLibrary(hInstThisDll);
            Release();
        }
    }
}

ULONG
CSidCache::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG
CSidCache::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CSidCache::~CSidCache()
{
    int i;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::~CSidCache");

    Lock();
    for (i = 0; i < BUCKET_COUNT; i++)
    {
        DestroyDPA(m_dpaSidHashTable[i]);
        m_dpaSidHashTable[i] = NULL;
    }
    Unlock();

    LockDomain();
    LocalFreeString(&m_pszCachedServer);
    LocalFreeString(&m_pszCachedDomain);
    UnlockDomain();

    LockDc();
    LocalFreeString(&m_pszLastDc);
    LocalFreeString(&m_pszLastDomain);
    UnlockDc();

    DeleteCriticalSection(&m_csHashTableLock);
    DeleteCriticalSection(&m_csDomainNameLock);
    DeleteCriticalSection(&m_csDcNameLock);


    if (m_hInitThread != NULL)
    {
        CloseHandle(m_hInitThread);
    }

    TraceLeaveVoid();
}


BOOL
CSidCache::LookupSids(HDPA hSids,
                      LPCTSTR pszServer,
                      LPSECURITYINFO2 psi2,
                      PUSER_LIST *ppUserList)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupSids");
    TraceAssert(hSids != NULL);

    if (NULL == hSids)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    if (NULL != ppUserList)
        *ppUserList = NULL;

    if (0 != DPA_GetPtrCount(hSids))
    {
        HDPA hEntryList = DPA_Create(4);

        if (NULL == hEntryList)
            TraceLeaveValue(FALSE);

        InternalLookupSids(hSids, pszServer, psi2, hEntryList);

        if (0 != DPA_GetPtrCount(hEntryList) && NULL != ppUserList)
            fResult = BuildUserList(hEntryList, pszServer, ppUserList);

        DPA_Destroy(hEntryList);
    }

    TraceLeaveValue(fResult);
}


BOOL
CSidCache::LookupSidsAsync(HDPA hSids,
                           LPCTSTR pszServer,
                           LPSECURITYINFO2 psi2,
                           HWND hWndNotify,
                           UINT uMsgNotify)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupSids");
    TraceAssert(hSids != NULL);

    if (NULL == hSids)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    if (0 != DPA_GetPtrCount(hSids))
    {
        fResult = InternalLookupSids(hSids,
                                     pszServer,
                                     psi2,
                                     NULL,
                                     hWndNotify,
                                     uMsgNotify);
    }

    TraceLeaveValue(fResult);
}


BOOL
CSidCache::LookupNames(PDS_SELECTION_LIST pDsSelList,
                       LPCTSTR pszServer,
                       PUSER_LIST *ppUserList,
                       BOOL bStandalone)
{
    BOOL fResult = FALSE;
    HDPA hEntryList;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupNames");
    TraceAssert(pDsSelList != NULL);
    TraceAssert(ppUserList != NULL);

    if (NULL == pDsSelList)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    if (NULL != ppUserList)
        *ppUserList = NULL;

    hEntryList = DPA_Create(4);

    if (NULL == hEntryList)
        TraceLeaveValue(FALSE);

    InternalLookupNames(pDsSelList, pszServer, hEntryList, bStandalone);

    if (0 != DPA_GetPtrCount(hEntryList))
    {
        fResult = TRUE; // so far, so good

        if (NULL != ppUserList)
            fResult = BuildUserList(hEntryList, pszServer, ppUserList);
    }

    DPA_Destroy(hEntryList);

    TraceLeaveValue(fResult);
}



void
CSidCache::GetDomainName(LPCTSTR pszServer, LPTSTR pszDomain, ULONG cchDomain)
{
    TraceEnter(TRACE_SIDCACHE, "CSidCache::GetDomainName");
    TraceAssert(NULL != pszDomain);
    TraceAssert(0 != cchDomain);

    pszDomain[0] = TEXT('\0');

    LockDomain();

    if (m_pszCachedDomain == NULL ||
        (pszServer == NULL && m_pszCachedServer != NULL) ||
        (pszServer != NULL && (m_pszCachedServer == NULL ||
         CompareString(LOCALE_USER_DEFAULT,
                       0,
                       pszServer,
                       -1,
                       m_pszCachedServer,
                       -1) != CSTR_EQUAL)))
    {
        //
        // It's a different server than last time, so ask LSA
        // for the domain name.
        //
        LocalFreeString(&m_pszCachedDomain);
        LocalFreeString(&m_pszCachedServer);

        if (pszServer != NULL)
            LocalAllocString(&m_pszCachedServer, pszServer);

        LSA_HANDLE hLSA = GetLSAConnection(pszServer, POLICY_VIEW_LOCAL_INFORMATION);
        if (hLSA != NULL)
        {
            PPOLICY_ACCOUNT_DOMAIN_INFO pDomainInfo = NULL;

            LsaQueryInformationPolicy(hLSA,
                                      PolicyAccountDomainInformation,
                                      (PVOID*)&pDomainInfo);
            if (pDomainInfo != NULL)
            {
                CopyUnicodeString(&m_pszCachedDomain, &pDomainInfo->DomainName);
                LsaFreeMemory(pDomainInfo);

                Trace((TEXT("Domain for %s is %s"), pszServer, m_pszCachedDomain));
            }
            LsaClose(hLSA);
        }
        else if (NULL != pszServer) // use the server name
        {
            // Skip leading backslashes
            while (TEXT('\\') == *pszServer)
                pszServer++;

            LocalAllocString(&m_pszCachedDomain, pszServer);

            if (m_pszCachedDomain)
            {
                // If there is a period, truncate the name at that point so
                // that something like "nttest.microsoft.com" becomes "nttest"
                LPTSTR pszDot = StrChr(m_pszCachedDomain, TEXT('.'));
                if (pszDot)
                    *pszDot = TEXT('\0');
            }
        }
    }

    if (m_pszCachedDomain)
        lstrcpyn(pszDomain, m_pszCachedDomain, cchDomain);

    UnlockDomain();

    TraceLeaveVoid();
}


DWORD
_GetDcName(LPCTSTR pszServer, LPCTSTR pszDomain, LPTSTR *ppszDC)
{
    DWORD dwErr;

    if (!ppszDC)
        return ERROR_INVALID_PARAMETER;

    *ppszDC = NULL;


    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    TraceMsg("Calling DsGetDcName");
    dwErr = DsGetDcName(pszServer,
                        pszDomain,
                        NULL,
                        NULL,
                        DS_IS_FLAT_NAME,
                        &pDCInfo);
    if (ERROR_SUCCESS == dwErr)
    {
        TraceAssert(NULL != pDCInfo);
        LocalAllocString(ppszDC, pDCInfo->DomainControllerName);
        NetApiBufferFree(pDCInfo);
    }

    if (ERROR_SUCCESS == dwErr && !*ppszDC)
        dwErr = ERROR_OUTOFMEMORY;

    return dwErr;
}

void
CSidCache::GetDcName(LPCTSTR pszDomain, LPTSTR pszDC, ULONG cchDC)
{
    TraceEnter(TRACE_SIDCACHE, "CSidCache::GetDcName");
    TraceAssert(NULL != pszDC);
    TraceAssert(0 != cchDC);

    pszDC[0] = TEXT('\0');

    LockDc();

    if (m_pszLastDc == NULL ||
        (pszDomain == NULL && m_pszLastDomain != NULL) ||
        (pszDomain != NULL && (m_pszLastDomain == NULL ||
         CompareString(LOCALE_USER_DEFAULT,
                       0,
                       pszDomain,
                       -1,
                       m_pszLastDomain,
                       -1) != CSTR_EQUAL)))
    {
        //
        // It's a different domain than last time, so look for a DC
        //
        LocalFreeString(&m_pszLastDc);
        LocalFreeString(&m_pszLastDomain);

        if (pszDomain != NULL)
            LocalAllocString(&m_pszLastDomain, pszDomain);

        _GetDcName(NULL, pszDomain, &m_pszLastDc);

        Trace((TEXT("DC for %s is %s"), pszDomain, m_pszLastDc));
    }

    if (m_pszLastDc)
        lstrcpyn(pszDC, m_pszLastDc, cchDC);

    UnlockDc();

    TraceLeaveVoid();
}


BSTR
CSidCache::GetNT4DisplayName(LPCTSTR pszAccount,
                             LPCTSTR pszName,
                             LPCTSTR pszServer,
                             BOOL bStandalone)
{
    BSTR strResult = NULL;
    TCHAR szComputer[UNCLEN];
    LPTSTR pszT = NULL;
    PUSER_INFO_2 pui = NULL;

    if (!pszAccount || !*pszAccount || !pszName || !*pszName)
        return NULL;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::GetNT4DisplayName");

    if (!bStandalone
        && (pszT = StrChr(pszAccount, TEXT('\\'))))
    {
        // Copy the domain name
        TCHAR szDomain[DNLEN + 1];
        lstrcpyn(szDomain,
                 pszAccount,
                 min((size_t)(pszT - pszAccount + 1), ARRAYSIZE(szDomain)));

        // See if we can use pszServer for NetUserGetInfo
        TCHAR szAccountDomain[DNLEN +1];
        szAccountDomain[0] = TEXT('\0');
        GetDomainName(pszServer, szAccountDomain, ARRAYSIZE(szAccountDomain));

        if (lstrcmpi(szDomain, szAccountDomain))
        {
            // Different domain, find a DC
            szComputer[0] = TEXT('\0');
            GetDcName(szDomain, szComputer, ARRAYSIZE(szComputer));
            if (TEXT('\0') != szComputer[0])
                pszServer = szComputer;
        }
    }

    TraceMsg("Calling NetUserGetInfo");
    if (NERR_Success == NetUserGetInfo(pszServer, pszName, 2, (LPBYTE *)&pui)
        && NULL != pui->usri2_full_name
        && *pui->usri2_full_name)
    {
        strResult = SysAllocString(pui->usri2_full_name);
    }

    NetApiBufferFree(pui);

    Trace((TEXT("Returning Full Name '%s' for '%s'"), strResult, pszAccount));
    TraceLeaveValue(strResult);
}


int
CSidCache::HashSid(PSID pSid)
{
    DWORD dwHash = 0;

    if (NULL != pSid)
    {
        PBYTE pbSid    = (PBYTE)pSid;
        PBYTE pbEndSid = pbSid + GetLengthSid(pSid);

        while (pbSid < pbEndSid)
            dwHash += *pbSid++;
    }

    return dwHash % BUCKET_COUNT;
}


int CALLBACK
CSidCache::CompareSid(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    int nResult = 0;
    PSID_CACHE_ENTRY pEntry1 = (PSID_CACHE_ENTRY)p1;
    PSID_CACHE_ENTRY pEntry2 = (PSID_CACHE_ENTRY)p2;
    PSID pSid1 = NULL;
    PSID pSid2 = NULL;

    if (pEntry1)
        pSid1 = pEntry1->pSid;
    else if (lParam)
        pSid1 = (PSID)lParam;

    if (pEntry2)
        pSid2 = pEntry2->pSid;

    if (pSid1 == NULL)
        nResult = -1;
    else if (pSid2 == NULL)
        nResult = 1;
    else
    {
        DWORD dwLength = GetLengthSid(pSid1);

        // Compare SID lengths
        nResult = dwLength - GetLengthSid(pSid2);

        if (nResult == 0)
        {
            // Lengths are equal, compare the bits
            PBYTE pbSid1 = (PBYTE)pSid1;
            PBYTE pbSid2 = (PBYTE)pSid2;

            // Could compare Identifier Authorities and SubAuthorities instead
            while (nResult == 0 && dwLength != 0)
            {
                dwLength--;
                nResult = *pbSid1++ - *pbSid2++;
            }
        }
    }

    return nResult;
}


PSID_CACHE_ENTRY
CSidCache::FindSid(PSID pSid)
{
    PSID_CACHE_ENTRY pEntry = NULL;
    int iBucket;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::FindSid");
    TraceAssert(pSid != NULL);
    TraceAssert(IsValidSid(pSid));

    iBucket = HashSid(pSid);

    Lock();

    if (m_dpaSidHashTable[iBucket] != NULL)
    {
        int iEntry = DPA_Search(m_dpaSidHashTable[iBucket],
                                NULL,
                                0,
                                CompareSid,
                                (LPARAM)pSid,
                                DPAS_SORTED);
        if (iEntry != -1)
        {
            pEntry = (PSID_CACHE_ENTRY)DPA_FastGetPtr(m_dpaSidHashTable[iBucket],
                                                      iEntry);
            TraceAssert(pEntry != NULL);
            TraceAssert(EqualSid(pSid, pEntry->pSid));

            if (0 != pEntry->dwLastAccessTime)
            {
                DWORD dwCurrentTime = GetTickCount();

                if ((dwCurrentTime - pEntry->dwLastAccessTime) > SID_CACHE_AGE_LIMIT)
                {
                    // The entry has aged out, remove it.
                    Trace((TEXT("Removing stale entry: %s"), pEntry->pszName));
                    DPA_DeletePtr(m_dpaSidHashTable[iBucket], iEntry);
                    LocalFree(pEntry);
                    pEntry = NULL;
                }
                else
                    pEntry->dwLastAccessTime = dwCurrentTime;
            }
        }
    }

    Unlock();

    TraceLeaveValue(pEntry);
}


PSID_CACHE_ENTRY
CSidCache::MakeEntry(PSID pSid,
                     SID_NAME_USE SidType,
                     LPCTSTR pszName,
                     LPCTSTR pszLogonName)
{
    PSID_CACHE_ENTRY pEntry = NULL;
    ULONG cbSid;
    ULONG cbName = 0;
    ULONG cbLogonName = 0;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::MakeEntry");
    TraceAssert(pSid != NULL);

    cbSid = GetLengthSid(pSid);
    if (NULL != pszName && *pszName)
        cbName = StringByteSize(pszName);
    if (NULL != pszLogonName && *pszLogonName)
        cbLogonName = StringByteSize(pszLogonName);

    pEntry = (PSID_CACHE_ENTRY)LocalAlloc(LPTR,
                                          SIZEOF(SID_CACHE_ENTRY)
                                           + cbSid
                                           + cbName
                                           + cbLogonName);
    if (pEntry != NULL)
    {
        PBYTE pData = (PBYTE)(pEntry+1);

        pEntry->SidType = SidType;

        pEntry->pSid = (PSID)pData;
        CopyMemory(pData, pSid, cbSid);
        pData += cbSid;

        if (0 != cbName)
        {
            pEntry->pszName = (LPCTSTR)pData;
            CopyMemory(pData, pszName, cbName);
            pData += cbName;
        }

        if (0 != cbLogonName)
        {
            pEntry->pszLogonName = (LPCTSTR)pData;
            CopyMemory(pData, pszLogonName, cbLogonName);
            //pData += cbLogonName;
        }

        // Well-known entries never age out
        if (SidTypeWellKnownGroup == SidType || IsAliasSid(pSid))
            pEntry->dwLastAccessTime = 0;
        else
            pEntry->dwLastAccessTime = GetTickCount();
    }

    TraceLeaveValue(pEntry);
}


BOOL
CSidCache::AddEntry(PSID_CACHE_ENTRY pEntry)
{
    BOOL fResult = FALSE;
    int iSidBucket;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::AddEntry");
    TraceAssert(pEntry != NULL);

    if (NULL == pEntry)
        TraceLeaveValue(FALSE);

    iSidBucket = HashSid(pEntry->pSid);

    Lock();

    if (m_dpaSidHashTable[iSidBucket] == NULL)
        m_dpaSidHashTable[iSidBucket] = DPA_Create(4);

    if (NULL != m_dpaSidHashTable[iSidBucket])
    {
        DPA_AppendPtr(m_dpaSidHashTable[iSidBucket], pEntry);
        DPA_Sort(m_dpaSidHashTable[iSidBucket], CompareSid, 0);
        fResult = TRUE;
    }

    Unlock();

    TraceLeaveValue(fResult);
}


BOOL
CSidCache::BuildUserList(HDPA hEntryList,
                         LPCTSTR pszServer,
                         PUSER_LIST *ppUserList)
{
    ULONG cEntries;
    TCHAR szAliasDomain[MAX_PATH];
    PSID_CACHE_ENTRY pEntry;
    ULONG cb = 0;
	ULONG cSidsLen = 0;
    ULONG cbAliasDomain = 0;
    ULONG i;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::BuildUserList");
    TraceAssert(hEntryList != NULL);
    TraceAssert(ppUserList != NULL);

    cEntries = DPA_GetPtrCount(hEntryList);
    TraceAssert(0 != cEntries);

    //
    // This name replaces "BUILTIN" for Alias SIDs
    //
    GetDomainName(pszServer, szAliasDomain, ARRAYSIZE(szAliasDomain));
    cbAliasDomain = StringByteSize(szAliasDomain);

    //
    // Add the sizes
    //
    cb = SIZEOF(USER_LIST) + ((cEntries - 1) * SIZEOF(USER_INFO));
    for (i = 0; i < cEntries; i++)
    {
        pEntry = (PSID_CACHE_ENTRY)DPA_FastGetPtr(hEntryList, i);
        TraceAssert(NULL != pEntry);
		
		cSidsLen += ACLUI_ALIGNED_SID_LENGTH(pEntry->pSid);
        
        if (SidTypeAlias == pEntry->SidType)
            cb += cbAliasDomain;
        else if (pEntry->pszLogonName)
            cb += StringByteSize(pEntry->pszLogonName);

        if (pEntry->pszName)
            cb += StringByteSize(pEntry->pszName);
    }

	cb += cSidsLen;
    //
    // Allocate and build the return buffer
    //
    *ppUserList = (PUSER_LIST)LocalAlloc(LPTR, cb);

    if (NULL == *ppUserList)
        TraceLeaveValue(FALSE);

    (*ppUserList)->cUsers = cEntries;

	PBYTE pData = NULL;
	PBYTE pCharData = NULL;

	//
	//NTRAID#NTBUG9-364410-2001/20/23-hiteshr
	//Sids were non aligned if cEntries > 1
	//
    pData = (PBYTE)&(*ppUserList)->rgUsers[cEntries];
	pCharData = pData + cSidsLen;

    for (i = 0; i < cEntries; i++)
    {
        pEntry = (PSID_CACHE_ENTRY)DPA_FastGetPtr(hEntryList, i);
        TraceAssert(NULL != pEntry);

        (*ppUserList)->rgUsers[i].SidType = pEntry->SidType;

        TraceAssert(NULL != pEntry->pSid);
        (*ppUserList)->rgUsers[i].pSid = (PSID)pData;
        cb = GetLengthSid(pEntry->pSid);
        CopyMemory(pData, pEntry->pSid, cb);
        pData += cb;

        if (SidTypeAlias == pEntry->SidType)
        {
            (*ppUserList)->rgUsers[i].pszLogonName = (LPCTSTR)pCharData;

            // Copy the "BUILTIN" domain name
            if (cbAliasDomain)
            {
                CopyMemory(pCharData, szAliasDomain, cbAliasDomain);
                pCharData += cbAliasDomain - SIZEOF(TCHAR);

                if (NULL != pEntry->pszName)
                    *(LPTSTR)pCharData = TEXT('\\');
                else
                    *(LPTSTR)pCharData = TEXT('\0');

                pCharData += SIZEOF(TCHAR);
            }
            // The rest of the name is copied below
        }
        else  if (NULL != pEntry->pszLogonName)
        {
            (*ppUserList)->rgUsers[i].pszLogonName = (LPCTSTR)pCharData;
            cb = StringByteSize(pEntry->pszLogonName);
            CopyMemory(pCharData, pEntry->pszLogonName, cb);
            pCharData += cb;
        }

        if (NULL != pEntry->pszName)
        {
            (*ppUserList)->rgUsers[i].pszName = (LPCTSTR)pCharData;
            cb = StringByteSize(pEntry->pszName);
            CopyMemory(pCharData, pEntry->pszName, cb);
            pCharData += cb;
        }
    }

    TraceLeaveValue(TRUE);
}


//
// Wrapper around sspi's TranslateName that automatically handles
// the buffer sizing
//
HRESULT
TranslateNameInternal(LPCTSTR pszAccountName,
                      EXTENDED_NAME_FORMAT AccountNameFormat,
                      EXTENDED_NAME_FORMAT DesiredNameFormat,
                      BSTR *pstrTranslatedName)
{

#if DBG
    //
    // These match up with the EXTENDED_NAME_FORMAT enumeration.
    // They're for debugger output only.
    //
    static const LPCTSTR rgpszFmt[] = { 
                                TEXT("NameUnknown"),
                                TEXT("FullyQualifiedDN"),
                                TEXT("NameSamCompatible"),
                                TEXT("NameDisplay"),
                                TEXT("NameDomainSimple"),
                                TEXT("NameEnterpriseSimple"),
                                TEXT("NameUniqueId"),
                                TEXT("NameCanonical"),
                                TEXT("NameUserPrincipal"),
                                TEXT("NameCanonicalEx"),
                                TEXT("NameServicePrincipal") };
#endif // DBG

    TraceEnter(TRACE_SIDCACHE, "TranslateNameInternal");
    Trace((TEXT("Calling TranslateName for \"%s\""), pszAccountName));
    Trace((TEXT("Translating %s -> %s"), 
              rgpszFmt[AccountNameFormat], rgpszFmt[DesiredNameFormat]));

    if (!pszAccountName || !*pszAccountName || !pstrTranslatedName)
        TraceLeaveResult(E_INVALIDARG);

    HRESULT hr = NOERROR;
    //
    // cchTrans is static so that if a particular installation's
    // account names are really long, we'll not be resizing the
    // buffer for each account.
    //
    static ULONG cchTrans = MAX_PATH;
    ULONG cch = cchTrans;

    *pstrTranslatedName = SysAllocStringLen(NULL, cch);
    if (NULL == *pstrTranslatedName)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to allocate name buffer");

    **pstrTranslatedName = L'\0';

    //
    // TranslateName is delay-loaded from secur32.dll using the linker's
    // delay-load mechanism.  Therefore, wrap with an exception handler.
    //
    __try
    {
        while(!::TranslateName(pszAccountName,
                               AccountNameFormat,
                               DesiredNameFormat,
                               *pstrTranslatedName,
                               &cch))
        {
            if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
                Trace((TEXT("Resizing buffer to %d chars"), cch));
                if (!SysReAllocStringLen(pstrTranslatedName, NULL, cch))
                    ExitGracefully(hr, E_OUTOFMEMORY, "Unable to reallocate name buffer");

                **pstrTranslatedName = L'\0';
            }
            else
            {
                hr = E_FAIL;
                break;
            }
        }

        cchTrans = max(cch, cchTrans);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
    }

exit_gracefully:

    if (FAILED(hr))
    {
        SysFreeString(*pstrTranslatedName);
        *pstrTranslatedName = NULL;
    }

    TraceLeaveResult(hr);
}


void
CSidCache::GetUserFriendlyName(LPCTSTR pszSamLogonName,
                               LPCTSTR pszSamAccountName,
                               LPCTSTR pszServer,
                               BOOL    bUseSamCompatibleInfo,
                               BOOL    bIsStandalone,
                               BSTR   *pstrLogonName,
                               BSTR   *pstrDisplayName)
{
    BSTR strFQDN = NULL;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::GetUserFriendlyName");
    TraceAssert(NULL != pszSamLogonName);

    //
    // Start by getting the FQDN.  Cracking is most efficient when the
    // FQDN is the starting point.
    //
    // TranslateName takes a while to complete, so bUseSamCompatibleInfo
    // should be TRUE whenever possible, e.g. for local accounts on a non-DC
    // or anything where we know a FQDN doesn't exist.
    //
    if (!bUseSamCompatibleInfo &&
        FAILED(TranslateNameInternal(pszSamLogonName,
                                     NameSamCompatible,
                                     NameFullyQualifiedDN,
                                     &strFQDN)))
    {
        //
        // No FQDN available for this account.  Must be an NT4
        // account.  Return SAM-compatible info to the caller.
        //
        bUseSamCompatibleInfo = TRUE;
    }

    if (NULL != pstrLogonName)
    {
        *pstrLogonName = NULL;

        if (!bUseSamCompatibleInfo)
        {
            TranslateNameInternal(strFQDN,
                                  NameFullyQualifiedDN,
                                  NameUserPrincipal,
                                  pstrLogonName);
        }
    }

    if (NULL != pstrDisplayName)
    {
        *pstrDisplayName = NULL;

        if (bUseSamCompatibleInfo ||
            FAILED(TranslateNameInternal(strFQDN,
                                         NameFullyQualifiedDN,
                                         NameDisplay,
                                         pstrDisplayName)))
        {
            *pstrDisplayName = GetNT4DisplayName(pszSamLogonName,
                                                 pszSamAccountName,
                                                 pszServer,
                                                 bIsStandalone);
        }
    }

    SysFreeString(strFQDN);

    TraceLeaveVoid();
}


BOOL
CSidCache::InternalLookupSids(HDPA hSids,
                              LPCTSTR pszServer,
                              LPSECURITYINFO2 psi2,
                              HDPA hEntryList,
                              HWND hWndNotify,
                              UINT uMsgNotify)
{
    ULONG cSids;
    HDPA hUnknownSids;
    PSID_CACHE_ENTRY pEntry;
    ULONG i;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::InternalLookupSids");
    TraceAssert(hSids != NULL);

    if (hSids == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    cSids = DPA_GetPtrCount(hSids);
    TraceAssert(0 != cSids);

    hUnknownSids = DPA_Create(4);

    if (NULL == hUnknownSids)
        TraceLeaveValue(FALSE);

    //
    // See if any exist in the cache already
    //
    for (i = 0; i < cSids; i++)
    {
        pEntry = FindSid((PSID)DPA_FastGetPtr(hSids, i));

        if (pEntry)
        {
            if (hWndNotify)
                PostMessage(hWndNotify, uMsgNotify, 0, (LPARAM)pEntry->pSid);
            else if (hEntryList)
                DPA_AppendPtr(hEntryList, pEntry);
        }
        else
            DPA_AppendPtr(hUnknownSids, DPA_FastGetPtr(hSids, i));
    }

    //
    // Call LSA to lookup any that we don't have cached
    //
    if (0 != DPA_GetPtrCount(hUnknownSids))
    {
        if (!psi2 ||
            FAILED(LookupSidsFromObject(hUnknownSids, psi2, hEntryList)))
        {
            LookupSidsHelper(hUnknownSids,
                             pszServer,
                             hEntryList,
                             hWndNotify,
                             uMsgNotify);
        }
    }

    DPA_Destroy(hUnknownSids);

    TraceLeaveValue(TRUE);
}


#include <adsnms.h>     // USER_CLASS_NAME, etc.

TCHAR const c_szForeignSecurityPrincipal[]  = TEXT("foreignSecurityPrincipal");

static const struct
{
    LPCTSTR pszClass;
    SID_NAME_USE sidType;
} c_aSidClasses[] =
{
    USER_CLASS_NAME,                    SidTypeUser,
    GROUP_CLASS_NAME,                   SidTypeGroup,
    GLOBALGROUP_CLASS_NAME,             SidTypeGroup,
    LOCALGROUP_CLASS_NAME,              SidTypeGroup,
    COMPUTER_CLASS_NAME,                SidTypeComputer,
    c_szForeignSecurityPrincipal,       SidTypeGroup,
};

SID_NAME_USE
GetSidType(PSID pSid, LPCTSTR pszClass)
{
    SID_NAME_USE sidType = SidTypeUnknown;

    TraceEnter(TRACE_SIDCACHE, "GetSidType");

    if (pSid)
    {
        TraceAssert(IsValidSid(pSid));

        if (EqualSystemSid(pSid, UI_SID_World) || IsCreatorSid(pSid))
            TraceLeaveValue(SidTypeWellKnownGroup);

        if (IsAliasSid(pSid))
            TraceLeaveValue(SidTypeAlias);

        if (*GetSidSubAuthorityCount(pSid) == 1 && IsNTAuthority(pSid))
        {
            DWORD sa = *GetSidSubAuthority(pSid, 0);
            if (sa && sa <= SECURITY_RESTRICTED_CODE_RID && sa != SECURITY_LOGON_IDS_RID)
                TraceLeaveValue(SidTypeWellKnownGroup);
            if (SECURITY_LOCAL_SYSTEM_RID == sa)
                TraceLeaveValue(SidTypeWellKnownGroup);
        }
    }

    if (pszClass)
    {
        // Didn't recognize the SID, try the class name
        for (int i = 0; i < ARRAYSIZE(c_aSidClasses); i++)
        {
            if (!lstrcmpi(pszClass, c_aSidClasses[i].pszClass))
                TraceLeaveValue(c_aSidClasses[i].sidType);
        }
        Trace((TEXT("Unexpected class type: %s"), pszClass));
    }

    // Don't know what type it is, so take a guess.  This is just
    // for picking an icon, so it doesn't matter too much.
    TraceLeaveValue(SidTypeUser); // SidTypeGroup would be just as valid
}

HRESULT
CSidCache::LookupSidsFromObject(HDPA hSids,
                                LPSECURITYINFO2 psi2,
                                HDPA hEntryList)
{
    HRESULT hr;
    ULONG cSids;
    LPDATAOBJECT pdoNames = NULL;
    STGMEDIUM medium = {0};
    FORMATETC fe = { (CLIPFORMAT)g_cfSidInfoList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    PSID_INFO_LIST pSidList = NULL;
    UINT i;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupSidsFromObject");
    TraceAssert(hSids != NULL);
    TraceAssert(psi2 != NULL);

    cSids = DPA_GetPtrCount(hSids);
    TraceAssert(cSids != 0);

    hr = psi2->LookupSids(cSids, DPA_GetPtrPtr(hSids), &pdoNames);
    FailGracefully(hr, "ISecurityInformation2::LookupSids failed");

    hr = pdoNames->GetData(&fe, &medium);
    FailGracefully(hr, "Unable to get CFSTR_ACLUI_SID_INFO_LIST from DataObject");

    pSidList = (PSID_INFO_LIST)GlobalLock(medium.hGlobal);
    if (!pSidList)
        ExitGracefully(hr, E_FAIL, "Unable to lock stgmedium.hGlobal");

    TraceAssert(pSidList->cItems > 0);

    for (i = 0; i < pSidList->cItems; i++)
    {
        PSID_CACHE_ENTRY pEntry = MakeEntry(pSidList->aSidInfo[i].pSid,
                                            GetSidType(pSidList->aSidInfo[i].pSid,
                                                       pSidList->aSidInfo[i].pwzClass),
                                            pSidList->aSidInfo[i].pwzCommonName,
                                            pSidList->aSidInfo[i].pwzUPN);
        if (pEntry)
        {
            if (AddEntry(pEntry))
            {
                if (hEntryList)
                    DPA_AppendPtr(hEntryList, pEntry);
            }
            else
                LocalFree(pEntry);
        }
    }

exit_gracefully:

    if (pSidList)
        GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    DoRelease(pdoNames);

    TraceLeaveResult(hr);
}

BOOL
CSidCache::LookupSidsHelper(HDPA hSids,
                            LPCTSTR pszServer,
                            HDPA hEntryList,
                            HWND hWndNotify,
                            UINT uMsgNotify,
                            BOOL bSecondTry,
									 BOOL bWellKnown)
{
    BOOL fResult = FALSE;
    ULONG cSids;
    LSA_HANDLE hlsa = NULL;
    PLSA_REFERENCED_DOMAIN_LIST pRefDomains = NULL;
    PLSA_TRANSLATED_NAME pTranslatedNames = NULL;
    DWORD dwStatus;
    BOOL bIsDC = FALSE;
    BOOL bIsStandalone = FALSE;
    HDPA hUnknownSids = NULL;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::LookupSidsHelper");
    TraceAssert(hSids != NULL);

    cSids = DPA_GetPtrCount(hSids);
    if (!cSids)
        TraceLeaveValue(FALSE);

    //
    // Call LSA to lookup SIDs for the names
    //
    hlsa = GetLSAConnection(pszServer, POLICY_LOOKUP_NAMES);
    if (NULL == hlsa && NULL != pszServer && !bSecondTry)
    {
        // Try the local machine
        pszServer = NULL;
        hlsa = GetLSAConnection(NULL, POLICY_LOOKUP_NAMES);
    }
    if (NULL == hlsa)
        TraceLeaveValue(FALSE);

    dwStatus = LsaLookupSids(hlsa,
                             cSids,
                             DPA_GetPtrPtr(hSids),
                             &pRefDomains,
                             &pTranslatedNames);

    bIsStandalone = IsStandalone(pszServer, &bIsDC);

    if (STATUS_SUCCESS == dwStatus || STATUS_SOME_NOT_MAPPED == dwStatus)
    {
        TraceAssert(pTranslatedNames);
        TraceAssert(pRefDomains);

        //
        // Build cache entries with NT4 style names
        //
        for (ULONG i = 0; i < cSids; i++)
        {
            BOOL bTryUPN = TRUE;
            BSTR strLogonName = NULL;
            BSTR strDisplayName = NULL;
            LPTSTR pszDeletedAccount = NULL;
            LPTSTR pszSID = NULL;

            PLSA_TRANSLATED_NAME pLsaName = &pTranslatedNames[i];
            PLSA_TRUST_INFORMATION pLsaDomain = NULL;
            PSID pSid = DPA_FastGetPtr(hSids, i);

            TCHAR szAccountName[MAX_PATH];
            TCHAR szDomainName[MAX_PATH];

            BOOL bNoCache = FALSE;

            szAccountName[0] = TEXT('\0');
            szDomainName[0] = TEXT('\0');

            // Get the referenced domain, if any
            if (pLsaName->DomainIndex >= 0 && pRefDomains)
            {
                TraceAssert((ULONG)pLsaName->DomainIndex < pRefDomains->Entries);
                pLsaDomain = &pRefDomains->Domains[pLsaName->DomainIndex];
            }

            // Make NULL-terminated copies of the domain and account name strings
            CopyUnicodeString(szAccountName, ARRAYSIZE(szAccountName), &pLsaName->Name);
            if (pLsaDomain)
                CopyUnicodeString(szDomainName, ARRAYSIZE(szDomainName), &pLsaDomain->Name);

            // Some optimization to avoid TranslateName when possible
            if (!bIsDC)
            {
                if (bIsStandalone)
                {
                    // Non-DC, standalone, therefore no UPN
                    bTryUPN = FALSE;
                }
                else if (SidTypeUser == pLsaName->Use)
                {
                    TCHAR szTargetDomain[DNLEN + 1];
                    szTargetDomain[0] = TEXT('\0');
                    GetDomainName(pszServer, szTargetDomain, ARRAYSIZE(szTargetDomain));
                    if (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT,
                                                    NORM_IGNORECASE,
                                                    szTargetDomain,
                                                    -1,
                                                    szDomainName,
                                                    -1))
                    {
                        // Local account on non-DC, therefore no UPN
                        bTryUPN = FALSE;
                    }
                }
            }

            //
            // Build NT4 "domain\user" style name
            //
            if (szDomainName[0] != TEXT('\0'))
            {
                StringCchCat(szDomainName,ARRAYSIZE(szDomainName),TEXT("\\"));
                StringCchCat(szDomainName, ARRAYSIZE(szDomainName), szAccountName);
            }

            // What we've got so far is our baseline.
            // Adjust these based on SID type.
            LPTSTR pszName = szAccountName;
            LPTSTR pszLogonName = szDomainName;

            switch (pLsaName->Use)
            {
            case SidTypeUser:               // 1
                // Get "User Principal Name" etc.
                GetUserFriendlyName(pszLogonName,
                                    pszName,
                                    pszServer,
                                    !bTryUPN,
                                    bIsStandalone,
                                    &strLogonName,
                                    &strDisplayName);
                if (strLogonName)
                    pszLogonName = strLogonName;
                if (strDisplayName)
                    pszName = strDisplayName;
                break;

            case SidTypeGroup:              // 2
            case SidTypeDomain:             // 3
                // nothing
                break;

            case SidTypeAlias:              // 4
                if (!IsAliasSid(pSid))
                {
                    // Sometimes get SidTypeAlias for non-BUILTIN sids,
                    // e.g. Domain Local Groups. Treat these as groups
                    // so we don't replace the Domain name.
                    // Raid #383755
                    pLsaName->Use = SidTypeGroup;
                    break;
                }
                // else Fall Through
            case SidTypeWellKnownGroup:     // 5
                // No logon name for these
                pszLogonName = NULL;
                break;

            case SidTypeDeletedAccount:     // 6
                // Display "Account Deleted(Sid)"
                ConvertSidToStringSid(pSid, &pszSID);
                if(FormatStringID(&pszDeletedAccount,
                                 ::hModule,
                                 IDS_SID_DELETED_1,
                                 pszSID))
				{
					if (pszSID)
						LocalFreeString(&pszSID);
					if (pszDeletedAccount)
						pszName = pszDeletedAccount;
					pszLogonName = NULL;
				}
				else
				{
					bNoCache = TRUE;
				}
                break;

            case SidTypeInvalid:            // 7
                bNoCache = TRUE;
                break;

            case SidTypeUnknown:            // 8
                // Some SIDs can only be looked up on a DC, so
                // if pszServer is not a DC, remember them and
                // look them up on a DC after this loop is done.
                if (!bSecondTry && !bIsStandalone && !bIsDC)
                {
                    if (!hUnknownSids)
                        hUnknownSids = DPA_Create(4);
                    if (hUnknownSids)
                        DPA_AppendPtr(hUnknownSids, pSid);

						  bNoCache = TRUE;
                }
					else if(bWellKnown)
						bNoCache = TRUE;
					else
					{
						// Display "Account Unknown(Sid)"
						ConvertSidToStringSid(pSid, &pszSID);
						if(FormatStringID(&pszDeletedAccount,
										::hModule,
										IDS_SID_UNKNOWN_1,
										pszSID))
						{
							if (pszSID)
								LocalFreeString(&pszSID);
							if (pszDeletedAccount)
								pszName = pszDeletedAccount;
							pszLogonName = NULL;
						}
						else
						{
							bNoCache = TRUE;
						}
               }
               break;


            case SidTypeComputer:           // 9
                if (*pszName)
                {
                    // Strip the trailing '$'
                    int nLen = lstrlen(pszName);
                    if (nLen && pszName[nLen-1] == TEXT('$'))
                    {
                        pszName[nLen-1] = TEXT('\0');
                    }
                }
                break;

            }

            if (!bNoCache)
            {
                //
                // Make a cache entry and save it
                //
                PSID_CACHE_ENTRY pEntry = MakeEntry(pSid,
                                                    pLsaName->Use,
                                                    pszName,
                                                    pszLogonName);
                if (pEntry)
                {
                    if (AddEntry(pEntry))
                    {
                        fResult = TRUE; // we added something to the cache

                        if (hWndNotify)
                            PostMessage(hWndNotify, uMsgNotify, 0, (LPARAM)pEntry->pSid);
                        else if (hEntryList)
                            DPA_AppendPtr(hEntryList, pEntry);
                    }
                    else
                        LocalFree(pEntry);
                }
            }

            if (strLogonName)
                SysFreeString(strLogonName);
            if (strDisplayName)
                SysFreeString(strDisplayName);
            LocalFreeString(&pszDeletedAccount);
        }
    }
    else if (STATUS_NONE_MAPPED == dwStatus && !bSecondTry && !bIsStandalone && !bIsDC)
    {
        hUnknownSids = DPA_Clone(hSids, NULL);
    }

    // Cleanup
    if (pTranslatedNames)
        LsaFreeMemory(pTranslatedNames);
    if (pRefDomains)
        LsaFreeMemory(pRefDomains);
    LsaClose(hlsa);


    if (hUnknownSids)
    {
        //
        // Some (or all) SIDs were unknown on the target machine,
        // try a DC for the target machine's primary domain.
        //
        // This typically happens for certain Alias SIDs, such
        // as Print Operators and System Operators, for which LSA
        // only returns names if the lookup is done on a DC.
        //
        LPTSTR pszDC = NULL;

        TraceAssert(!bSecondTry);

        // We don't bother trying if standalone, and don't
        // do this if the target machine is already a DC.
        TraceAssert(!bIsStandalone && !bIsDC);

        _GetDcName(pszServer, NULL, &pszDC);

        if (pszDC)
        {
            // Recurse
            if (LookupSidsHelper(hUnknownSids,
                                 pszDC,
                                 hEntryList,
                                 hWndNotify,
                                 uMsgNotify,
                                 TRUE))
            {
                fResult = TRUE;
            }
            LocalFree(pszDC);
        }

        DPA_Destroy(hUnknownSids);
    }

    TraceLeaveValue(fResult);
}




BSTR GetNT4AccountName(LPTSTR pszWinNTPath)
{
    // pszWinNTPath is expected to look like
    //   "WinNT://domain/user"
    // or
    //   "WinNT://domain/machine/user"
    //
    // The "WinNT://" part is optional.
    //
    // In either case, we want the last 2 elements,
    // e.g. "domain/user" and "machine/user".
    //
    // The approach is to find the next to last '/' and add 1.
    // If there are less than 2 slashes, return the original string.

    BSTR strResult = NULL;
    LPTSTR pszResult = pszWinNTPath;
    if (pszWinNTPath)
    {
        LPTSTR pszSlash = StrRChr(pszWinNTPath, pszWinNTPath + lstrlen(pszWinNTPath) - 1, TEXT('/'));
        if (pszSlash)
        {
            pszSlash = StrRChr(pszWinNTPath, pszSlash-1, TEXT('/'));
            if (pszSlash)
                pszResult = pszSlash + 1;
        }
    }

    if (pszResult)
    {
        strResult = SysAllocString(pszResult);
        if (strResult)
        {
            // At this point, there is at most one forward slash
            // in the string.  Convert it to a backslash.
            LPTSTR pszSlash = StrChr(strResult, TEXT('/'));
            if (pszSlash)
                *pszSlash = TEXT('\\');
        }
    }

    return strResult;
}

BOOL
_LookupName(LPCTSTR pszServer,
            LPCTSTR pszAccount,
            PSID *ppSid,
            SID_NAME_USE *pSidType)
{
    BOOL fResult = FALSE;
    BYTE buffer[sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(ULONG)];
    PSID pSid = (PSID)buffer;
    DWORD cbSid = sizeof(buffer);
    TCHAR szDomain[MAX_PATH];
    DWORD cchDomain = ARRAYSIZE(szDomain);
    SID_NAME_USE sidType;

    fResult = LookupAccountName(pszServer,
                                pszAccount,
                                pSid,
                                &cbSid,
                                szDomain,
                                &cchDomain,
                                &sidType);
    if (fResult)
    {
        *ppSid = LocalAllocSid(pSid);
        if (*ppSid)
        {
            if (pSidType)
                *pSidType = sidType;
        }
        else
            fResult = FALSE;
    }

    return fResult;
}

BOOL
CSidCache::InternalLookupNames(PDS_SELECTION_LIST pDsSelList,
                               LPCTSTR pszServer,
                               HDPA hEntryList,
                               BOOL bStandalone)
{
    BOOL fResult = FALSE;
    ULONG cNames;
    HDPA hSids = NULL;
    PSID_CACHE_ENTRY pEntry;
    ULONG i;
    ULONG cNoSID = 0;
    HRESULT hrCom = E_FAIL;
    IADsPathname *pPath = NULL;

    TraceEnter(TRACE_SIDCACHE, "CSidCache::InternalLookupNames");
    TraceAssert(pDsSelList != NULL);
    TraceAssert(hEntryList != NULL);

    if (pDsSelList == NULL || hEntryList == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    cNames = pDsSelList->cItems;
    TraceAssert(cNames != 0);

    if (0 == cNames)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TraceLeaveValue(FALSE);
    }

    hSids = DPA_Create(4);

    for (i = 0; i < cNames; i++)
    {
        PSID pSid = NULL;
        PSID pSidFree = NULL;
        LPVARIANT pvarSid = pDsSelList->aDsSelection[i].pvarFetchedAttributes;
        SID_NAME_USE sidType = SidTypeUnknown;
        BSTR strNT4Name = NULL;

        if (NULL == pvarSid || (VT_ARRAY | VT_UI1) != V_VT(pvarSid)
            || FAILED(SafeArrayAccessData(V_ARRAY(pvarSid), &pSid)))
        {
            // If there's no SID, then we can't use it in an ACL
            Trace((TEXT("No SID returned for %s"), pDsSelList->aDsSelection[i].pwzADsPath));

            // If it's the NT provider, try to lookup the SID by name
            if (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT,
                                            0,
                                            c_szNTProvider,
                                            NTPROV_LEN,
                                            pDsSelList->aDsSelection[i].pwzADsPath,
                                            NTPROV_LEN))
            {
                strNT4Name = GetNT4AccountName(pDsSelList->aDsSelection[i].pwzADsPath + NTPROV_LEN);
                if (strNT4Name)
                {
                    Trace((TEXT("Using LSA to lookup SID for %s"), strNT4Name));
                    if (_LookupName(pszServer, strNT4Name, &pSidFree, &sidType))
                    {
                        pSid = pSidFree;
                    }
                }
            }

            if (NULL == pSid)
            {
                cNoSID++;
                continue;
            }
        }
        TraceAssert(NULL != pSid);

        // Is it already in the cache?
        pEntry = FindSid(pSid);
        if (pEntry)
        {
            DPA_AppendPtr(hEntryList, pEntry);
        }
        else
        {
            // Not cached, try to make an entry using the info returned
            // by the object picker.
            if (SidTypeUnknown == sidType)
                sidType = GetSidType(pSid, pDsSelList->aDsSelection[i].pwzClass);

            if (!lstrcmpi(c_szForeignSecurityPrincipal, pDsSelList->aDsSelection[i].pwzClass))
            {
                // Object picker returns non-localized names for these (the
                // DS Configuration Container is not localized). Look up the
                // localized name from LSA.  175278

                // This happens automatically below (pEntry is NULL).
            }
            else if (SidTypeAlias == sidType || SidTypeWellKnownGroup == sidType)
            {
                // Only need the name
                pEntry = MakeEntry(pSid,
                                   sidType,
                                   pDsSelList->aDsSelection[i].pwzName,
                                   NULL);
            }
            else if (pDsSelList->aDsSelection[i].pwzUPN && *pDsSelList->aDsSelection[i].pwzUPN)
            {
                // We have both name and UPN
                pEntry = MakeEntry(pSid,
                                   sidType,
                                   pDsSelList->aDsSelection[i].pwzName,
                                   pDsSelList->aDsSelection[i].pwzUPN);
            }
            else if (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT,
                                                 0,
                                                 c_szNTProvider,
                                                 NTPROV_LEN,
                                                 pDsSelList->aDsSelection[i].pwzADsPath,
                                                 NTPROV_LEN))
            {
                // It's downlevel ("WinNT://blah")
                if (NULL == strNT4Name)
                    strNT4Name = GetNT4AccountName(pDsSelList->aDsSelection[i].pwzADsPath + NTPROV_LEN);
                if (strNT4Name)
                {
                    // We have the NT4 name, now look for a Friendly Name
                    BSTR strDisplay = GetNT4DisplayName(strNT4Name,
                                                        pDsSelList->aDsSelection[i].pwzName,
                                                        pszServer,
                                                        bStandalone);
                    pEntry = MakeEntry(pSid,
                                       sidType,
                                       strDisplay ? strDisplay : pDsSelList->aDsSelection[i].pwzName,
                                       strNT4Name);
                    SysFreeString(strDisplay);
                }
            }
            else
            {
                // It's not a downlevel, so it must be
                //   1. WellKnown/Universal (no ADsPath)
                // or
                //   2. Uplevel ("GC:" or "LDAP:") but
                //      has no UPN
                //
                // If it has an ADs path, try to get an
                // NT4 name such as "NTDEV\Domain Users".
                //
                // Note that wellknown things such "Authenticated User"
                // can fall under either 1 or 2 above, depending on what
                // scope it was selected from.  That's why we try to pick
                // them off higher up.
                TraceAssert(NULL == strNT4Name);
                if (pDsSelList->aDsSelection[i].pwzADsPath &&
                    *pDsSelList->aDsSelection[i].pwzADsPath)
                {
                    // DsCrackNames doesn't accept full ADs paths, so use
                    // IADsPathname to retrieve the DN (no provider/server).
                    if (FAILED(hrCom))
                        hrCom = CoInitialize(NULL);
                    if (!pPath)
                    {
                        CoCreateInstance(CLSID_Pathname,
                                         NULL,
                                         CLSCTX_INPROC_SERVER,
                                         IID_IADsPathname,
                                         (LPVOID*)&pPath);
                    }
                    if (pPath)
                    {
                        BSTR strT;
                        if (SUCCEEDED(pPath->Set(AutoBstr(pDsSelList->aDsSelection[i].pwzADsPath),
                                                 ADS_SETTYPE_FULL)))
                        {
                            if (SUCCEEDED(pPath->Retrieve(ADS_FORMAT_X500_DN,
                                                          &strT)))
                            {
                                // Try to get an NT4 account name
                                TranslateNameInternal(strT,
                                                      NameFullyQualifiedDN,
                                                      NameSamCompatible,
                                                      &strNT4Name);
                                SysFreeString(strT);
                            }
                            if (!strNT4Name)
                            {
                                // Retrieve or CrackName failed. Try to build
                                // an NT4-style name from the server name.
                                if (SUCCEEDED(pPath->Retrieve(ADS_FORMAT_SERVER,
                                                              &strT)))
                                {
                                    TCHAR szNT4Name[MAX_PATH];
                                    GetDomainName(strT, szNT4Name, ARRAYSIZE(szNT4Name));
                                    PathAppend(szNT4Name, pDsSelList->aDsSelection[i].pwzName);
                                    strNT4Name = SysAllocString(szNT4Name);
                                    SysFreeString(strT);
                                }
                            }
                        }
                    }
                }
                pEntry = MakeEntry(pSid,
                                   sidType,
                                   pDsSelList->aDsSelection[i].pwzName,
                                   strNT4Name);
            }

            //
            // Do we have a cache entry yet?
            //
            if (pEntry)
            {
                if (AddEntry(pEntry))
                {
                    DPA_AppendPtr(hEntryList, pEntry);
                }
                else
                {
                    LocalFree(pEntry);
                    pEntry = NULL;
                }
            }

            if (!pEntry && hSids)
            {
                // Look up the SID the hard way
                Trace((TEXT("Using LSA to lookup %s"), pDsSelList->aDsSelection[i].pwzADsPath));
                PSID pSidCopy = LocalAllocSid(pSid);
                if (pSidCopy)
                {
                    DPA_AppendPtr(hSids, pSidCopy);
                }
            }
        }

        SysFreeString(strNT4Name);

        if (pSidFree)
            LocalFree(pSidFree);
        else
            SafeArrayUnaccessData(V_ARRAY(pvarSid));
    }

    TraceAssert(0 == cNoSID);

    //
    // Call LSA to lookup names for the SIDs that aren't cached yet
    //
    if (hSids && 0 != DPA_GetPtrCount(hSids))
        LookupSidsHelper(hSids, pszServer, hEntryList);

    if (NULL != hSids)
        DestroyDPA(hSids);

    DoRelease(pPath);

    if (SUCCEEDED(hrCom))
        CoUninitialize();

    TraceLeaveValue(TRUE);
}




DWORD WINAPI
CSidCache::InitThread(LPVOID pvThreadData)
{
    PSIDCACHE pThis = (PSIDCACHE)pvThreadData;

    // Our caller already gave us a ref on the dll to prevent the race window where 
    // we are created but we the dll is freed before we can call LoadLibrary()
    // HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);

    TraceEnter(TRACE_SIDCACHE, "CSidCache::InitThread");

    if (pThis)
    {
        // Lookup some well-known SIDs to pre-load the cache
        HDPA hSids;
	//-1 becuase we donot want to create cache for Admininstrators sid
        hSids = DPA_Create(COUNT_SYSTEM_SID_TYPES -1);
        if (hSids)
        {
            for (int i = 0; i < (COUNT_SYSTEM_SID_TYPES -1); i++)
            {
                DPA_AppendPtr(hSids, QuerySystemSid((UI_SystemSid)i));
            }

            pThis->LookupSidsHelper(hSids, NULL, NULL, NULL, 0,FALSE,TRUE);

            DPA_Destroy(hSids);
        }

        pThis->Release();
    }

    TraceLeave();
    FreeLibraryAndExitThread(GetModuleHandle(c_szDllName), 0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       debug.cpp
//
//  Provides printf style debug output
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <stdio.h>
#include <comctrlp.h>
#pragma hdrstop


#ifdef DEBUG

DWORD g_dwTraceMask = 0;
DWORD g_tlsDebug = 0xffffffffL;

#define MAX_CALL_DEPTH  64
#define BUFFER_SIZE     2048


class CDebugStack
{
private:
    DWORD m_dwThreadID;
    LONG m_cDepth;
    struct
    {
        BOOL    fTracedYet;
        LPCTSTR pszFunctionName;
        DWORD   dwMask;
    }
    m_CallStack[MAX_CALL_DEPTH];
    TCHAR m_szStringBuffer[BUFFER_SIZE];

public:
    CDebugStack() : m_dwThreadID(GetCurrentThreadId()), m_cDepth(-1)
    { ZeroMemory(&m_CallStack, SIZEOF(m_CallStack)); }

public:
    void _Indent(LONG iDepth, LPCTSTR pszFormat, ...);
    void _vIndent(LONG iDepth, LPCTSTR pszFormat, va_list va);
    BOOL _TraceProlog(LONG iDepth, BOOL fForce);
    void _TraceEnter(DWORD dwMask, LPCTSTR pName);
    void _TraceLeave(void);
    void _Trace(BOOL bForce, LPCTSTR pszFormat, ...);
    void _vTrace(BOOL bForce, LPCTSTR pszFormat, va_list va);
    void _TraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
    void _TraceAssert(int iLine, LPTSTR pFilename);
};
typedef CDebugStack *PDEBUGSTACK;

class CDebugStackHolder
{
private:
    HDPA m_hDebugStackList;
    CRITICAL_SECTION m_csStackList;

public:
    CDebugStackHolder() : m_hDebugStackList(NULL) { ExceptionPropagatingInitializeCriticalSection(&m_csStackList); }
    ~CDebugStackHolder();

public:
    void Add(PDEBUGSTACK pDebugStack);
    void Remove(PDEBUGSTACK pDebugStack);
};
typedef CDebugStackHolder *PDEBUGSTACKHOLDER;

PDEBUGSTACKHOLDER g_pStackHolder = NULL;


/*-----------------------------------------------------------------------------
/ _Indent
/ -------
/   Output to the debug stream indented by n columns.
/
/ In:
/   i = column to indent to.
/   pszFormat -> string to be indented
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

void CDebugStack::_Indent(LONG iDepth, LPCTSTR pszFormat, ...)
{
    va_list va;

    va_start(va, pszFormat);
    _vIndent(iDepth, pszFormat, va);
    va_end(va);
}


void CDebugStack::_vIndent(LONG iDepth, LPCTSTR pszFormat, va_list va)
{
    m_szStringBuffer[0] = TEXT('\0');

    wsprintf(m_szStringBuffer, TEXT("%08x "), m_dwThreadID);

    iDepth = min(iDepth, MAX_CALL_DEPTH - 1);
    for ( ; iDepth > 0 ; iDepth-- )
	{
        if(FAILED( StringCchCat(m_szStringBuffer, BUFFER_SIZE,TEXT("  "))))
			break;
	}

	DWORD dwLen = lstrlen(m_szStringBuffer);
	if(BUFFER_SIZE > dwLen)
	{
		if(FAILED(StringCchVPrintf(m_szStringBuffer + dwLen,(BUFFER_SIZE-dwLen), pszFormat, va)))
            return;

		if(FAILED(StringCchCat(m_szStringBuffer,BUFFER_SIZE,TEXT("\n"))))
            return;

		OutputDebugString(m_szStringBuffer);
	}
}


/*-----------------------------------------------------------------------------
/ _TraceProlog
/ -------------
/   Handle the prolog to a prefix string, including outputting the
/   function name if we haven't already.
/
/ In:
/   iDepth = depth in the call stack
/   fForce = ignore flags
/
/ Out:
/   BOOL if trace output should be made
/----------------------------------------------------------------------------*/
BOOL CDebugStack::_TraceProlog(LONG iDepth, BOOL fForce)
{
    if ( iDepth < 0 || iDepth >= MAX_CALL_DEPTH )
        return FALSE;

    if  ( (g_dwTraceMask & m_CallStack[iDepth].dwMask) || fForce )
    {
        if ( !m_CallStack[iDepth].fTracedYet )
        {
            if ( iDepth > 0 )
                _TraceProlog(iDepth-1, TRUE);

            _Indent(iDepth, m_CallStack[iDepth].pszFunctionName);
            m_CallStack[iDepth].fTracedYet = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
/ _TraceEnter
/ ------------
/   Set the debugging call stack up to indicate which function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceEnter(DWORD dwMask, LPCTSTR pName)
{
    m_cDepth++;

    if ( m_cDepth < MAX_CALL_DEPTH )
    {
        if ( !pName )    
            pName = TEXT("<no name>");         // no function name given

        m_CallStack[m_cDepth].fTracedYet = FALSE;
        m_CallStack[m_cDepth].pszFunctionName = pName;
        m_CallStack[m_cDepth].dwMask = dwMask;

        //if ( m_cDepth > 0 )
        //    _TraceProlog(m_cDepth-1, FALSE);
    }
}


/*-----------------------------------------------------------------------------
/ _TraceLeave
/ ------------
/   On exit from a function this will adjust the function stack pointer to 
/   point to our previous function.  If no trace output has been made then 
/   we will output the function name on a single line (to indicate we went somewhere).
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceLeave(void)
{
    //_TraceProlog(m_cDepth, FALSE);

    //if ( !m_cDepth && m_CallStack[0].fTracedYet )
    //    OutputDebugString(TEXT("\n"));
    
    m_cDepth = max(m_cDepth-1, -1);         // account for underflow
}


/*-----------------------------------------------------------------------------
/ _Trace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of 
/   call stack depth.
/
/ In:
/   pszFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_Trace(BOOL bForce, LPCTSTR pszFormat, ...)
{
    va_list va;

    va_start(va, pszFormat);
    _vTrace(bForce, pszFormat, va);
    va_end(va);
}


void CDebugStack::_vTrace(BOOL bForce, LPCTSTR pszFormat, va_list va)
{
    if ( _TraceProlog(m_cDepth, bForce) || bForce )
        _vIndent(m_cDepth+1, pszFormat, va);
}


/*-----------------------------------------------------------------------------
/ _TraceGUID
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
#ifdef UNICODE
#define MAP_GUID(x)     &x, TEXT(""L#x)
#else
#define MAP_GUID(x)     &x, TEXT(""#x)
#endif

#define MAP_GUID2(x,y)  MAP_GUID(x), MAP_GUID(y)

const struct 
{
    const GUID* m_pGUID;
    LPCTSTR     m_pName;
}
_guid_map[] = 
{
    MAP_GUID(IID_IUnknown),
    MAP_GUID(IID_IClassFactory),
    MAP_GUID(IID_IDropTarget),
    MAP_GUID(IID_IDataObject),
    MAP_GUID(IID_IPersist),
    MAP_GUID(IID_IOleWindow),

    MAP_GUID2(IID_INewShortcutHookA, IID_INewShortcutHookW),
    MAP_GUID(IID_IShellBrowser),
    MAP_GUID(IID_IShellView),
    MAP_GUID(IID_IContextMenu),
    MAP_GUID(IID_IShellIcon),
    MAP_GUID(IID_IShellFolder),
    MAP_GUID(IID_IShellExtInit),
    MAP_GUID(IID_IShellPropSheetExt),
    MAP_GUID(IID_IPersistFolder),  
    MAP_GUID2(IID_IExtractIconA, IID_IExtractIconW),
    MAP_GUID2(IID_IShellLinkA, IID_IShellLinkW),
    MAP_GUID2(IID_IShellCopyHookA, IID_IShellCopyHookW),
    MAP_GUID2(IID_IFileViewerA, IID_IFileViewerW),
    MAP_GUID(IID_ICommDlgBrowser),
    MAP_GUID(IID_IEnumIDList),
    MAP_GUID(IID_IFileViewerSite),
    MAP_GUID(IID_IContextMenu2),
    MAP_GUID2(IID_IShellExecuteHookA, IID_IShellExecuteHookW),
    MAP_GUID(IID_IPropSheetPage),
    MAP_GUID(IID_IShellView2),
    MAP_GUID(IID_IUniformResourceLocator),
};

void CDebugStack::_TraceGUID(LPCTSTR pPrefix, REFGUID rGUID)
{
    TCHAR szGUID[40];
    LPCTSTR pName = NULL;
    int i;
    
    for ( i = 0 ; i < ARRAYSIZE(_guid_map); i++ )
    {
        if ( IsEqualGUID(rGUID, *_guid_map[i].m_pGUID) )
        {
            pName = _guid_map[i].m_pName;
            break;
        }
    }

    if ( !pName )
    {
// StringFromGUID2 only does UNICODE.  SHStringFromGUID goes both ways,
// but requires shlwapip.h and shlwapi.lib.
#ifndef UNICODE
  #error "_TraceGUID needs fixing"
#endif    
        StringFromGUID2(rGUID, szGUID, ARRAYSIZE(szGUID));
        //SHStringFromGUID(rGUID, szGUID, ARRAYSIZE(szGUID));
        pName = szGUID;
    }

    _Trace(FALSE, TEXT("%s %s"), pPrefix, pName);
}


/*-----------------------------------------------------------------------------
/ _TraceAssert
/ -------------
/   Our assert handler, out faults it the trace mask as enabled assert
/   faulting.
/
/ In:
/   iLine = line 
/   pFilename -> filename of the file we asserted in
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceAssert(int iLine, LPTSTR pFilename)
{
    // nb: TRUE --> asserts always displayed
    _Trace(TRUE, TEXT("Assert failed in %s, line %d"), pFilename, iLine);

    if ( g_dwTraceMask & TRACE_COMMON_ASSERT )
        DebugBreak();
}


/*-----------------------------------------------------------------------------
/ ~CDebugStackHolder
/ ------------------
/   Free any DebugStack objects that exist
/
/ In:
/   -
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
int CALLBACK
_DeleteCB(LPVOID pVoid, LPVOID /*pData*/)
{
    PDEBUGSTACK pDebugStack = (PDEBUGSTACK)pVoid;
    if (pDebugStack)
    {
        //pDebugStack->_Trace(TRUE, TEXT("~CDebugStackHolder destroying DebugStack"));
        delete pDebugStack;
    }
    return 1;
}

CDebugStackHolder::~CDebugStackHolder()
{
    EnterCriticalSection(&m_csStackList);

    if (NULL != m_hDebugStackList)
    {
        DPA_DestroyCallback(m_hDebugStackList, _DeleteCB, NULL);
        m_hDebugStackList = NULL;
    }

    LeaveCriticalSection(&m_csStackList);
    DeleteCriticalSection(&m_csStackList);
}


/*-----------------------------------------------------------------------------
/ CDebugStackHolder::Add
/ ----------------------
/   Saves the DebugStack object in a list
/
/ In:
/   PDEBUGSTACK pointer to the thread's debug stack object
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void
CDebugStackHolder::Add(PDEBUGSTACK pDebugStack)
{
    EnterCriticalSection(&m_csStackList);

    if (NULL == m_hDebugStackList)
        m_hDebugStackList = DPA_Create(4);

    if (NULL != m_hDebugStackList)
        DPA_AppendPtr(m_hDebugStackList, pDebugStack);

    LeaveCriticalSection(&m_csStackList);
}


/*-----------------------------------------------------------------------------
/ CDebugStackHolder::Remove
/ -------------------------
/   Removes the DebugStack object from the list
/
/ In:
/   PDEBUGSTACK pointer to the thread's debug stack object
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void
CDebugStackHolder::Remove(PDEBUGSTACK pDebugStack)
{
    EnterCriticalSection(&m_csStackList);

    if (NULL != m_hDebugStackList)
    {
        int iStack = DPA_GetPtrIndex(m_hDebugStackList, pDebugStack);

        if (-1 != iStack)
            DPA_DeletePtr(m_hDebugStackList, iStack);
    }

    LeaveCriticalSection(&m_csStackList);
}


/*-----------------------------------------------------------------------------
/ GetThreadStack
/ --------------
/   Create (if necessary) and return the per-thread debug stack object.
/
/ In:
/   -
/
/ Out:
/   PDEBUGSTACK pointer to the thread's debug stack object
/----------------------------------------------------------------------------*/
PDEBUGSTACK GetThreadStack()
{
    PDEBUGSTACK pDebugStack;

    if (0xffffffffL == g_tlsDebug)
        return NULL;

    pDebugStack = (PDEBUGSTACK)TlsGetValue(g_tlsDebug);

    if (!pDebugStack)
    {
        pDebugStack = new CDebugStack;
        TlsSetValue(g_tlsDebug, pDebugStack);

        if (!g_pStackHolder)
            g_pStackHolder = new CDebugStackHolder;

        if (g_pStackHolder)
            g_pStackHolder->Add(pDebugStack);
    }

    return pDebugStack;
}
    

/*-----------------------------------------------------------------------------
/ DoTraceSetMask
/ --------------
/   Adjust the trace mask to reflect the state given.
/
/ In:
/   dwMask = mask for enabling / disable trace output
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask)
{
    g_dwTraceMask = dwMask;
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMaskFromRegKey
/ ------------------------
/   Pick up the TraceMask value from the given registry key and
/   set the trace mask using that.
/
/ In:
/   hkRoot = handle of open key
/   pszSubKey = name of subkey to open
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMaskFromRegKey(HKEY hkRoot, LPCTSTR pszSubKey)
{
    HKEY hKey;
	 
	 //NTRAID#NTBUG9-551459-2002/04/01-hiteshr
    if (ERROR_SUCCESS == RegOpenKeyEx(hkRoot, 
												  pszSubKey,
												  0,
												  KEY_QUERY_VALUE,
												  &hKey))
    {
        DWORD dwTraceMask = 0;
        DWORD cbTraceMask = SIZEOF(dwTraceMask);

        RegQueryValueEx(hKey,
                        TEXT("TraceMask"),
                        NULL,
                        NULL,
                        (LPBYTE)&dwTraceMask,
                        &cbTraceMask);
        DoTraceSetMask(dwTraceMask);
        RegCloseKey(hKey);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMaskFromCLSID
/ -----------------------
/   Pick up the TraceMask value from the given CLSID value and
/   set the trace mask using that.
/
/ In:
/   rCLSID = CLSID to query the value from
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMaskFromCLSID(REFCLSID rCLSID)
{
    TCHAR szClsidKey[48] = TEXT("CLSID\\");
    int nLength = lstrlen(szClsidKey);

// StringFromGUID2 only does UNICODE.  SHStringFromGUID goes both ways,
// but requires shlwapip.h and shlwapi.lib.
#ifdef UNICODE
    if (0 == StringFromGUID2(rCLSID, szClsidKey + nLength, ARRAYSIZE(szClsidKey) - nLength))
#else
#error "DoTraceSetMaskFromCLSID needs fixing"
    if (0 == SHStringFromGUID(rCLSID, szClsidKey + nLength, ARRAYSIZE(szClsidKey) - nLength))
#endif    
        return;

    DoTraceSetMaskFromRegKey(HKEY_CLASSES_ROOT, szClsidKey);
}


/*-----------------------------------------------------------------------------
/ DoTraceEnter
/ ------------
/   Set the debugging call stack up to indicate which function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceEnter(DWORD dwMask, LPCTSTR pName)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceEnter(dwMask, pName);
}


/*-----------------------------------------------------------------------------
/ DoTraceLeave
/ ------------
/   On exit from a function this will adjust the function stack pointer to 
/   point to our previous function.  If no trace output has been made then 
/   we will output the function name on a single line (to indicate we went somewhere).
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceLeave(void)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceLeave();
}


/*-----------------------------------------------------------------------------
/ DoTrace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of 
/   call stack depth.
/
/ In:
/   pszFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTrace(LPCTSTR pszFormat, ...)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();
    va_list va;

    if (pDebugStack)
    {
        va_start(va, pszFormat);
        pDebugStack->_vTrace(FALSE, pszFormat, va);
        va_end(va);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceGuid
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceGUID(pPrefix, rGUID);
}


/*-----------------------------------------------------------------------------
/ DoTraceAssert
/ -------------
/   Our assert handler, out faults it the trace mask as enabled assert
/   faulting.
/
/ In:
/   iLine = line 
/   pFilename -> filename of the file we asserted in
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceAssert(int iLine, LPTSTR pFilename)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceAssert(iLine, pFilename);
}


/*-----------------------------------------------------------------------------
/ DebugThreadDetach
/ DebugProcessAttach
/ DebugProcessDetach
/ -------------
/   These must be called from DllMain
/
/ In:
/   -
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DebugThreadDetach(void)
{
    PDEBUGSTACK pDebugStack;

    if (0xffffffffL == g_tlsDebug)
        return;

    pDebugStack = (PDEBUGSTACK)TlsGetValue(g_tlsDebug);

    if (pDebugStack)
    {
        if (g_pStackHolder)
            g_pStackHolder->Remove(pDebugStack);

        delete pDebugStack;
        TlsSetValue(g_tlsDebug, NULL);
    }
}

void DebugProcessAttach(void)
{
    g_tlsDebug = TlsAlloc();
}

void DebugProcessDetach(void)
{
    DebugThreadDetach();

    if (NULL != g_pStackHolder)
    {
        delete g_pStackHolder;
        g_pStackHolder = NULL;
    }

    if (0xffffffffL != g_tlsDebug)
    {
        TlsFree(g_tlsDebug);
        g_tlsDebug = 0xffffffffL;
    }
}


#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       misc.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <advpub.h>     // REGINSTALL


/*-----------------------------------------------------------------------------
/ DPA_DestroyCallback
/ --------------
/   Same as in newer comctl32, but not present in NT4 SP4.
/
/ In:
/   -
/ Out:
/   
/----------------------------------------------------------------------------*/



/*-----------------------------------------------------------------------------
/ CallRegInstall
/ --------------
/   Called by DllRegisterServer and DllUnregisterServer to register/unregister
/   this module.  Uses the ADVPACK APIs and loads our INF data from resources.
/
/ In:
/   -
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT
CallRegInstall(HMODULE hModule, LPCSTR pszSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack;

    TraceEnter(TRACE_COMMON_MISC, "CallRegInstall");

    hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnRegInstall = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if ( pfnRegInstall )
        {
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnRegInstall(hModule, pszSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    TraceLeaveResult(hr);
}

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void
ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec)
{
   __try
   {
      ::InitializeCriticalSection(critsec);
   }

   // propagate the exception to our caller.  This will cause Log::Log
   // to abort prematurely, which will jump to the the handler in
   // Log::GetInstance
   
   __except (EXCEPTION_CONTINUE_SEARCH)
   {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef _pch_h
#define _pch_h

#include <windows.h>
#include <shlobj.h>

#include <common.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common\msgpopup.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgpopup.cpp
//
//  This file contains MessageBox helper functions.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


/*******************************************************************

    NAME:       MsgPopup

    SYNOPSIS:   Displays a message to the user

    ENTRY:      hwnd        - Owner window handle
                pszMsgFmt   - Main message text
                pszTitle    - MessageBox title
                uType       - MessageBox flags
                hInstance   - Module to load strings from.  Only required if
                              pszMsgFmt or pszTitle is a string resource ID.
                Optional format insert parameters.

    EXIT:

    RETURNS:    MessageBox result

    NOTES:      Either of the string parameters may be string resource ID's.

    HISTORY:
        JeffreyS    11-Jun-1997     Created

********************************************************************/

int
WINAPIV
MsgPopup(HWND hwnd,
         LPCTSTR pszMsgFmt,
         LPCTSTR pszTitle,
         UINT uType,
         HINSTANCE hInstance,
         ...)
{
    int nResult;
    LPTSTR szMsg = NULL;
    LPTSTR szTitle = NULL;
    DWORD dwFormatResult;
    va_list args;

    if (pszMsgFmt == NULL)
        return -1;

    //
    // Insert arguments into the format string
    //
    va_start(args, hInstance);
    if (IS_INTRESOURCE(pszMsgFmt))
        dwFormatResult = vFormatStringID(&szMsg, hInstance, (UINT)((ULONG_PTR)pszMsgFmt), &args);
    else
        dwFormatResult = vFormatString(&szMsg, pszMsgFmt, &args);
    va_end(args);

    if (!dwFormatResult)
        return -1;

    //
    // Load the caption if necessary
    //
    if (pszTitle && IS_INTRESOURCE(pszTitle))
    {
        if (LoadStringAlloc(&szTitle, hInstance, (UINT)((ULONG_PTR)pszTitle)))
            pszTitle = szTitle;
        else
            pszTitle = NULL;
    }

    //
    // Display message box
    //
    nResult = MessageBox(hwnd, szMsg, pszTitle, uType);

    LocalFreeString(&szMsg);
    LocalFreeString(&szTitle);

    return nResult;
}


/*******************************************************************

    NAME:       SysMsgPopup

    SYNOPSIS:   Displays a message to the user using a system error
                message as an insert.

    ENTRY:      hwnd        - Owner window handle
                pszMsg      - Main message text
                pszTitle    - MessageBox title
                uType       - MessageBox flags
                hInstance   - Module to load strings from.  Only required if
                              pszMsg or pszTitle is a string resource ID.
                dwErrorID   - System defined error code (Insert 1)
                pszInsert2  - Optional string to be inserted into pszMsg

    EXIT:

    RETURNS:    MessageBox result

    NOTES:      Any of the string parameters may be string resource ID's.

    HISTORY:
        JeffreyS    11-Jun-1997     Created

********************************************************************/

int
WINAPI
SysMsgPopup(HWND hwnd,
            LPCTSTR pszMsg,
            LPCTSTR pszTitle,
            UINT uType,
            HINSTANCE hInstance,
            DWORD dwErrorID,
            LPCTSTR pszInsert2)
{
    int nResult;
    LPTSTR szInsert2 = NULL;
    LPTSTR szErrorText = NULL;

    //
    // Load the 2nd insert string if necessary
    //
    if (pszInsert2 && IS_INTRESOURCE(pszInsert2))
    {
        if (LoadStringAlloc(&szInsert2, hInstance, (UINT)((ULONG_PTR)pszInsert2)))
            pszInsert2 = szInsert2;
        else
            pszInsert2 = NULL;
    }

    //
    // Get the error message string
    //
    if (dwErrorID)
    {
        GetSystemErrorText(&szErrorText, dwErrorID);
    }

    nResult = MsgPopup(hwnd, pszMsg, pszTitle, uType, hInstance, szErrorText, pszInsert2);

    LocalFreeString(&szInsert2);
    LocalFreeString(&szErrorText);

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common\priv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       priv.cpp
//
//  Provides support for enabling/disabling privileges
//
//--------------------------------------------------------------------------

#include "pch.h"


/*******************************************************************

    NAME:       EnablePrivileges

    SYNOPSIS:   Enables the given privileges in the current token

    ENTRY:      pdwPrivileges - list of privileges to enable

    RETURNS:    On success, the previous thread handle (if present) or NULL
                On failure, INVALID_HANDLE_VALUE

    NOTES:      The returned handle should be passed to ReleasePrivileges
                to ensure proper cleanup.  Otherwise, if not NULL or
                INVALID_HANDLE_VALUE it should be closed with CloseHandle.

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
HANDLE EnablePrivileges(PDWORD pdwPrivileges, ULONG cPrivileges)
{
    BOOL                fResult;
    HANDLE              hToken;
    HANDLE              hOriginalThreadToken;
    PTOKEN_PRIVILEGES   ptp;
    ULONG               nBufferSize;

    if (!pdwPrivileges || !cPrivileges)
        return INVALID_HANDLE_VALUE;

    // Note that TOKEN_PRIVILEGES includes a single LUID_AND_ATTRIBUTES
    nBufferSize = sizeof(TOKEN_PRIVILEGES) + (cPrivileges - 1)*sizeof(LUID_AND_ATTRIBUTES);
    ptp = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, nBufferSize);
    if (!ptp)
        return INVALID_HANDLE_VALUE;

    //
    // Initialize the Privileges Structure
    //
    ptp->PrivilegeCount = cPrivileges;
    for (ULONG i = 0; i < cPrivileges; i++)
    {
        //ptp->Privileges[i].Luid = RtlConvertUlongToLuid(*pdwPrivileges++);
        ptp->Privileges[i].Luid.LowPart = *pdwPrivileges++;
        ptp->Privileges[i].Luid.HighPart = 0;
        ptp->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    //
    // Open the Token
    //
    hToken = hOriginalThreadToken = INVALID_HANDLE_VALUE;
    fResult = OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, FALSE, &hToken);
    if (fResult)
        hOriginalThreadToken = hToken;  // Remember the thread token
    else
        fResult = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);

    if (fResult)
    {
        HANDLE hNewToken;

        //
        // Duplicate that Token
        //
        fResult = DuplicateTokenEx(hToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   NULL,                   // PSECURITY_ATTRIBUTES
                                   SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                                   TokenImpersonation,     // TokenType
                                   &hNewToken);            // Duplicate token
        if (fResult)
        {
            //
            // Add new privileges
            //
            fResult = AdjustTokenPrivileges(hNewToken,  // TokenHandle
                                            FALSE,      // DisableAllPrivileges
                                            ptp,        // NewState
                                            0,          // BufferLength
                                            NULL,       // PreviousState
                                            NULL);      // ReturnLength
            if (fResult)
            {
                //
                // Begin impersonating with the new token
                //
                fResult = SetThreadToken(NULL, hNewToken);
            }

            CloseHandle(hNewToken);
        }
    }

    // If something failed, don't return a token
    if (!fResult)
        hOriginalThreadToken = INVALID_HANDLE_VALUE;

    // Close the original token if we aren't returning it
    if (hOriginalThreadToken == INVALID_HANDLE_VALUE && hToken != INVALID_HANDLE_VALUE)
        CloseHandle(hToken);

    // If we succeeded, but there was no original thread token,
    // return NULL to indicate we need to do SetThreadToken(NULL, NULL)
    // to release privs.
    if (fResult && hOriginalThreadToken == INVALID_HANDLE_VALUE)
        hOriginalThreadToken = NULL;

    LocalFree(ptp);

    return hOriginalThreadToken;
}


/*******************************************************************

    NAME:       ReleasePrivileges

    SYNOPSIS:   Resets privileges to the state prior to the corresponding
                EnablePrivileges call.

    ENTRY:      hToken - result of call to EnablePrivileges

    RETURNS:    nothing

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
void ReleasePrivileges(HANDLE hToken)
{
    if (INVALID_HANDLE_VALUE != hToken)
    {
        SetThreadToken(NULL, hToken);
        if (hToken)
            CloseHandle(hToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Created 22-Nov-96 by Jeff Saathoff (jeffreys)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

TARGETNAME= common
TARGETTYPE= LIBRARY
TARGETPATH= obj

# Aclui.dll, rshx32.dll and dssec.dll depend on common.lib
SYNCHRONIZE_BLOCK=1

CONDITIONAL_INCLUDES=$(CONDITIONAL_INCLUDES) \
    shellp.h    \
    shlobjp.h

SOURCES=    ..\debug.cpp     \
            ..\unknown.cpp   \
            ..\strings.cpp   \
            ..\priv.cpp      \
            ..\msgpopup.cpp  \
            ..\misc.cpp      \

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common\unknown.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       unknown.cpp
//
//  Helper functions for handling IUnknown
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ CUnknown
/   Helper functions to aid the implementation of IUnknown within objects,
/   handles not only AddRef and Release, but also QueryInterface.
/----------------------------------------------------------------------------*/

LONG g_cRefCount = 0;          // global reference count

CUnknown::CUnknown()
{
    m_cRefCount = 0;
    InterlockedIncrement(&g_cRefCount);
}

CUnknown::~CUnknown()
{
    TraceAssert( m_cRefCount == 0 );    // ref counting problem
    InterlockedDecrement(&g_cRefCount);
}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleQueryInterface
/ ------------------------------
/   A table driven implementation of QueryInterface that scans through trying
/   to find a suitable match for the object.
/
/ In:
/   riid = interface being requested
/   ppvObject -> receives a pointer to the object
/   aIntefaces = array of interface descriptions
/   cif = number of interfaces in array
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDMETHODIMP CUnknown::HandleQueryInterface(REFIID riid, LPVOID* ppvObject, LPINTERFACES aInterfaces, int cif)
{
    HRESULT hr = S_OK;
    int i;

    TraceAssert(ppvObject);
    TraceAssert(aInterfaces);
    TraceAssert(cif);

    *ppvObject = NULL;          // no interface yet

    for ( i = 0; i != cif; i++ )
    {
        if ( IsEqualIID(riid, *aInterfaces[i].piid) || IsEqualIID(riid, IID_IUnknown) )
        {
            *ppvObject = aInterfaces[i].pvObject;
            goto exit_gracefully;
        }
    }

    hr = E_NOINTERFACE;         // failed.

exit_gracefully:

    if ( SUCCEEDED(hr) )
        ((LPUNKNOWN)*ppvObject)->AddRef();

    return hr;
}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleAddRef
/ ----------------------
/   Increase the objects reference count.  Global reference count increase
/   by the constructor.
/
/ In:
/   -
/ Out:
/   current reference count
/----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CUnknown::HandleAddRef()
{
    return InterlockedIncrement(&m_cRefCount);
}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleRelease
/ -----------------------
/   Decrease the reference counts, when the objects reaches zero then 
/   destroy it (which inturn will decrease the global reference count).
/
/ In:
/   -
/ Out:
/   current reference count == 0 if destroyed
/----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CUnknown::HandleRelease()
{
    TraceAssert( 0 == m_cRefCount );
    ULONG cRef = InterlockedDecrement(&m_cRefCount);
    if ( 0 == cRef )
    {
        delete this;    
    }
    return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\common\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.cpp
//
//  Useful string manipulation functions.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString)
{
    HRESULT hr;

    TraceEnter(TRACE_COMMON_STR, "LocalAllocString");

    TraceAssert(ppResult);
    TraceAssert(pString);

    if ( !ppResult || !pString )
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments");

    *ppResult = (LPTSTR)LocalAlloc(LPTR, StringByteSize(pString) );

    if ( !*ppResult )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate buffer");

    lstrcpy(*ppResult, pString);
    hr = S_OK;                          //  success

exit_gracefully:

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ LocalAllocStringLen
/ ---------------------
/   Given a length return a buffer of that size.
/
/ In:
/   ppResult -> receives the pointer to the string
/   cLen = length in characters to allocate
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen)
{
    HRESULT hr;

    TraceEnter(TRACE_COMMON_STR, "LocalAllocStringLen");

    TraceAssert(ppResult);

    if ( !ppResult || cLen == 0 )
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments (length or buffer)");

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (cLen+1) * SIZEOF(TCHAR));

    hr = *ppResult ? S_OK:E_OUTOFMEMORY; 

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ LocalFreeString
/ -----------------
/   Release the string pointed to be *ppString (which can be null) and
/   then reset the pointer back to NULL.   
/
/ In:
/   ppString -> pointer to string pointer to be free'd
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void LocalFreeString(LPTSTR* ppString)
{
    if ( ppString )
    {
        if ( *ppString )
            LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }
}


//*************************************************************
//
//  SizeofStringResource
//
//  Purpose:    Find the length (in chars) of a string resource
//
//  Parameters: HINSTANCE hInstance - module containing the string
//              UINT idStr - ID of string
//
//
//  Return:     UINT - # of chars in string, not including NULL
//
//  Notes:      Based on code from user32.
//
//*************************************************************
UINT
SizeofStringResource(HINSTANCE hInstance,
                     UINT idStr)
{
    UINT cch = 0;
    HRSRC hRes = FindResource(hInstance, (LPTSTR)((LONG_PTR)(((USHORT)idStr >> 4) + 1)), RT_STRING);
    if (NULL != hRes)
    {
        HGLOBAL hStringSeg = LoadResource(hInstance, hRes);
        if (NULL != hStringSeg)
        {
            LPWSTR psz = (LPWSTR)LockResource(hStringSeg);
            if (NULL != psz)
            {
                idStr &= 0x0F;
                while(true)
                {
                    cch = *psz++;
                    if (idStr-- == 0)
                        break;
                    psz += cch;
                }
            }
        }
    }
    return cch;
}


//*************************************************************
//
//  LoadStringAlloc
//
//  Purpose:    Loads a string resource into an alloc'd buffer
//
//  Parameters: ppszResult - string resource returned here
//              hInstance - module to load string from
//              idStr - string resource ID
//
//  Return:     same as LoadString
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
int
LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr)
{
    int nResult = 0;
    UINT cch = SizeofStringResource(hInstance, idStr);
    if (cch)
    {
        cch++; // for NULL
        *ppszResult = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (*ppszResult)
            nResult = LoadString(hInstance, idStr, *ppszResult, cch);
    }
    return nResult;
}


//*************************************************************
//
//  String formatting functions
//
//*************************************************************

DWORD
FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, idStr);
    dwResult = vFormatStringID(ppszResult, hInstance, idStr, &args);
    va_end(args);
    return dwResult;
}

DWORD
FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, pszFormat);
    dwResult = vFormatString(ppszResult, pszFormat, &args);
    va_end(args);
    return dwResult;
}

DWORD
vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs)
{
    DWORD dwResult = 0;
    LPTSTR pszFormat = NULL;
    if (LoadStringAlloc(&pszFormat, hInstance, idStr))
    {
        dwResult = vFormatString(ppszResult, pszFormat, pargs);
        LocalFree(pszFormat);
    }
    return dwResult;
}

DWORD
vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                         pszFormat,
                         0,
                         0,
                         (LPTSTR)ppszResult,
                         1,
                         pargs);
}


//*************************************************************
//
//  GetSystemErrorText
//
//  Purpose:    Retrieve error text for a win32 error value
//
//  Parameters: ppszResult - string resource returned here
//              dwErr - error ID
//
//  Return:     same as FormatMessage
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
DWORD
GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwErr,
                         0,
                         (LPTSTR)ppszResult,
                         0,
                         NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.h
//
//--------------------------------------------------------------------------

#ifndef __cstrings_h
#define __cstrings_h

extern TCHAR const c_szDllName[];
extern TCHAR const c_szNetApi32[];
extern TCHAR const c_szAclUI[];
extern WCHAR const c_szFilterFile[];
extern WCHAR const c_szClassKey[];
extern WCHAR const c_szGUIDFormat[];
extern WCHAR const c_szClassFilter[];
extern WCHAR const c_szPropertyFilter[];
extern WCHAR const c_szERFilterFormat[];
extern WCHAR const c_szLDAPDisplayName[];
extern WCHAR const c_szDisplayName[];
extern WCHAR const c_szDisplayID[];
extern WCHAR const c_szValidAccesses[];
extern WCHAR const c_szSchemaIDGUID[];
extern WCHAR const c_szRightsGuid[];
extern WCHAR const c_szSDProperty[];
extern WCHAR const c_szSDRightsProp[];
extern WCHAR const c_szSchemaContext[];
extern WCHAR const c_szConfigContext[];
extern WCHAR const c_szERContainer[];
extern WCHAR const c_szRootDsePath[];
extern WCHAR const c_szPathFormat[];
extern WCHAR const c_szCNFormat[];
extern WCHAR const c_szDefaultSchemaSD[];
extern WCHAR const c_szAttributeSecurityGuid[];
extern WCHAR const c_szObjectClass[];
extern WCHAR const c_szStructuralObjectClass[];
extern WCHAR const c_szObjectClassCategory[];

#endif  // __cstrings_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\dll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dll.h
//
//--------------------------------------------------------------------------

#ifndef __dll_h
#define __dll_h

extern HINSTANCE g_hInstance;
#define GLOBAL_HINSTANCE (g_hInstance)

HRESULT ThreadCoInitialize(void);
void ThreadCoUninitialize(void);
DWORD WaitOnThread(HANDLE *phThread);

HRESULT _CreateSecurityPage(LPSECURITYINFO pSI, HPROPSHEETPAGE *phPage);
HRESULT _EditSecurity(HWND hwndOwner, LPSECURITYINFO pSI);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\dssi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dssi.h
//
//--------------------------------------------------------------------------

// Everything here has moved to private\inc\dssec.h
#include <dssec.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\dssi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dssi.cpp
//
//  This file contains the implementation of the CDSSecurityInfo object,
//  which provides the ISecurityInformation interface for invoking
//  the ACL Editor.
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <dssec.h>
#include "exnc.h"
#include "ntsecapi.h"
TCHAR const c_szDomainClass[]       = DOMAIN_CLASS_NAME;    // adsnms.h
#define CLASS_COMPUTER L"computer"

BOOL 
IsRootObject(IDirectoryObject * pDirObject);

GENERIC_MAPPING g_DSMap =
{
    DS_GENERIC_READ,
    DS_GENERIC_WRITE,
    DS_GENERIC_EXECUTE,
    DS_GENERIC_ALL
};

#define DSSI_LOCAL_NO_CREATE_DELETE     0x00000001

//
//Function Declarations
//
HRESULT
GetDomainSid(LPCWSTR pszServer, PSID *ppSid);

HRESULT
GetRootDomainSid(LPCWSTR pszServer, PSID *ppSid);



//
// CDSSecurityInfo (ISecurityInformation) class definition
//
class CDSSecurityInfo : public ISecurityInformation, 
                               IEffectivePermission,
                               ISecurityObjectTypeInfo, 
                               CUnknown
{
protected:
    GUID        m_guidObjectType;
    BSTR        m_strServerName;
    BSTR        m_strObjectPath;
    BSTR        m_strObjectClass;
    BSTR        m_strDisplayName;
    BSTR        m_strSchemaRootPath;
    AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;
    //
    //List of Aux Clasess Attached to the object
    //
    HDPA        m_hAuxClasses;  
    IDirectoryObject *m_pDsObject;
    PSECURITY_DESCRIPTOR m_pSD;
    PSID        m_pDomainSid;
	PSID		m_pRootDomainSid;
    PSECURITY_DESCRIPTOR  m_pDefaultSD;
    DWORD       m_dwSIFlags;
    DWORD       m_dwInitFlags;  // DSSI_*
    DWORD       m_dwLocalFlags; //DSSI_LOCAL_*
    HANDLE      m_hInitThread;
    HANDLE      m_hLoadLibWaitEvent;
    volatile BOOL m_bThreadAbort;
    PFNREADOBJECTSECURITY  m_pfnReadSD;
    PFNWRITEOBJECTSECURITY m_pfnWriteSD;
    LPARAM      m_lpReadContext;
    LPARAM      m_lpWriteContext;

    //
    //Access Information
    //
    PACCESS_INFO m_pAIGeneral;        //For First Page and Object Page on Advanced
    PACCESS_INFO m_pAIProperty;       //For Property Page on Advanced
    PACCESS_INFO m_pAIEffective;      //For Effective Page on Advanced
    //
    //Object Type List Info
    //
    POBJECT_TYPE_LIST m_pOTL;
    ULONG m_cCountOTL;

public:
    virtual ~CDSSecurityInfo();

    STDMETHODIMP Init(LPCWSTR pszObjectPath,
                      LPCWSTR pszObjectClass,
                      LPCWSTR pszServer,
                      LPCWSTR pszUserName,
                      LPCWSTR pszPassword,
                      DWORD   dwFlags,
                      PFNREADOBJECTSECURITY  pfnReadSD,
                      PFNWRITEOBJECTSECURITY pfnWriteSD,
                      LPARAM lpContext);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // ISecurityInformation
    STDMETHODIMP GetObjectInformation(PSI_OBJECT_INFO pObjectInfo);
    STDMETHODIMP GetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR *ppSD,
                             BOOL fDefault);
    STDMETHODIMP SetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD);
    STDMETHODIMP GetAccessRights(const GUID* pguidObjectType,
                                 DWORD dwFlags,
                                 PSI_ACCESS *ppAccess,
                                 ULONG *pcAccesses,
                                 ULONG *piDefaultAccess);
    STDMETHODIMP MapGeneric(const GUID *pguidObjectType,
                            UCHAR *pAceFlags,
                            ACCESS_MASK *pmask);
    STDMETHODIMP GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                 ULONG *pcInheritTypes);
    STDMETHODIMP PropertySheetPageCallback(HWND hwnd,
                                           UINT uMsg,
                                           SI_PAGE_TYPE uPage);

    //IEffectivePermission
    STDMETHODIMP GetEffectivePermission(const GUID* pguidObjectType,
                                        PSID pUserSid,
                                        LPCWSTR pszServerName,
                                        PSECURITY_DESCRIPTOR pSD,
                                        POBJECT_TYPE_LIST *ppObjectTypeList,
                                        ULONG *pcObjectTypeListLength,
                                        PACCESS_MASK *ppGrantedAccessList,
                                        ULONG *pcGrantedAccessListLength);

    //ISecurityObjectTypeInfo
    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray);



private:
    HRESULT Init2(LPCWSTR pszUserName, LPCWSTR pszPassword);
    HRESULT Init3();
    HRESULT GetAuxClassList();

    DWORD CheckObjectAccess();

    void WaitOnInitThread(void)
        { WaitOnThread(&m_hInitThread); }

    static DWORD WINAPI InitThread(LPVOID pvThreadData);

    static HRESULT WINAPI DSReadObjectSecurity(LPCWSTR pszObjectPath,
                                               SECURITY_INFORMATION si,
                                               PSECURITY_DESCRIPTOR *ppSD,
                                               LPARAM lpContext);

    static HRESULT WINAPI DSWriteObjectSecurity(LPCWSTR pszObjectPath,
                                                SECURITY_INFORMATION si,
                                                PSECURITY_DESCRIPTOR pSD,
                                                LPARAM lpContext);
};


//
// CDSSecurityInfo (ISecurityInformation) implementation
//
CDSSecurityInfo::~CDSSecurityInfo()
{
    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::~CDSSecurityInfo");

    m_bThreadAbort = TRUE;

    if (m_hInitThread != NULL)
    {
        WaitForSingleObject(m_hInitThread, INFINITE);
        CloseHandle(m_hInitThread);
    }

    DoRelease(m_pDsObject);

    SysFreeString(m_strServerName);
    SysFreeString(m_strObjectPath);
    SysFreeString(m_strObjectClass);
    SysFreeString(m_strDisplayName);
    SysFreeString(m_strSchemaRootPath);

    if (m_pSD != NULL)
        LocalFree(m_pSD);

    if( m_pDefaultSD != NULL )
        LocalFree(m_pDefaultSD);

    if(m_pDomainSid)
        LocalFree(m_pDomainSid);

	if(m_pRootDomainSid)
		LocalFree(m_pRootDomainSid);
    
    DestroyDPA(m_hAuxClasses);
    if(m_pAIGeneral && m_pAIGeneral->bLocalFree)
    {
        LocalFree(m_pAIGeneral->pAccess);
        LocalFree(m_pAIGeneral);
    }
    if(m_pAIProperty && m_pAIProperty->bLocalFree)
    {
        LocalFree(m_pAIProperty->pAccess);
        LocalFree(m_pAIProperty);
    }
    if(m_pAIEffective && m_pAIEffective->bLocalFree)
    {
        LocalFree(m_pAIEffective->pAccess);
        LocalFree(m_pAIEffective);
    }        
    if(m_pOTL)
        LocalFree(m_pOTL);

    if(m_ResourceManager)
        AuthzFreeResourceManager(m_ResourceManager);	

    TraceLeaveVoid();
}


//+--------------------------------------------------------------------------
//
//  Function:   DeleteParents
//
//  Synopsis:   Delete the parent of pszClassName from the list.
//              And recursively calls the function to delete the
//              parent of parent of pszClassName from the list.
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------
HRESULT DeleteParents(HDPA hListAux, 
                      LPWSTR pszClassName, 
                      LPWSTR pszSchemaRootPath)
{
    TraceEnter(TRACE_DSSI, "DeleteParents");

    if(!hListAux || !pszSchemaRootPath)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    IADsClass *pDsClass = NULL;
    VARIANT varDerivedFrom;
    int cCount = DPA_GetPtrCount(hListAux);
    
    if(cCount > 1)
    {
        hr = Schema_BindToObject(pszSchemaRootPath,
                                 pszClassName,
                                 IID_IADsClass,
                                 (LPVOID*)&pDsClass);
    
        FailGracefully(hr, "Schema_BindToObject failed");
        //
        //Find out the parent 
        //                           
        hr = pDsClass->get_DerivedFrom(&varDerivedFrom);
        if(hr == E_ADS_PROPERTY_NOT_FOUND)
        {
            //
            //This error will come for TOP which doesn't
            //have any parent
            //
            hr = S_OK;
            goto exit_gracefully;
        }
        FailGracefully(hr, "IADsClass get_DerivedFrom failed");

        LPWSTR pszParent= NULL;
        LPWSTR pszTemp = NULL;
        if( V_VT(&varDerivedFrom) == VT_BSTR)
        {
            pszParent = V_BSTR(&varDerivedFrom);
            int i;
            //
            //Remove all the pszParent entry from the 
            //hListAux
            //
            for(i = 0; i < cCount; ++i)
            {   
                pszTemp = (LPWSTR)DPA_FastGetPtr(hListAux,i);
                if(wcscmp(pszTemp, pszParent) == 0)
                {
                    DPA_DeletePtr(hListAux,i);
                    --cCount;
                    --i;
                }
            }
        }

        VariantClear(&varDerivedFrom);
    }                

exit_gracefully:

    if(pDsClass)
        DoRelease(pDsClass);
    return hr;
}


HRESULT 
CDSSecurityInfo::GetAuxClassList()
{
    TraceEnter(TRACE_DSSI, "GetAuxClassList");

    if(!m_pDsObject || !m_strSchemaRootPath)
    {
        return S_FALSE;
    }

    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAtrrInfoObject = NULL;
    DWORD dwAttrCountObject = 0;
    PADS_ATTR_INFO pAttrInfoStruct = NULL;
    DWORD dwAttrCountStruct= 0;

    HDPA hListAux = NULL;
    HDPA hListCopy = NULL;

    //ObjectClass is list of "class hierarchy of StructuralClass" and "class hierarchy of AuxClass" 
    //for the object.
    //So ObjectClass MINUS StructurcalClass is the list of AuxClass. 
    //This list after subtraction may conatin the inheritance hierarchy. 
    //We only want the mostsignificant classes for the purpose of aclui.

    //
    //Get the ObjectClass Attribute
    //
    LPWSTR pszTemp = (LPWSTR)c_szObjectClass;
    hr = m_pDsObject->GetObjectAttributes(&pszTemp,
                                          1,
                                          &pAtrrInfoObject,
                                          &dwAttrCountObject);
    FailGracefully(hr, "Failed to get ObjectClass Attribute");

    if(!pAtrrInfoObject || !dwAttrCountObject)
        ExitGracefully(hr, S_OK, "Couldn't get ObjectClass, Assume no AuxClass");

    //
    //Get the StructuralObjectClass Attribute
    //
    pszTemp = (LPWSTR)c_szStructuralObjectClass;
    hr = m_pDsObject->GetObjectAttributes(&pszTemp,
                                          1,
                                          &pAttrInfoStruct,
                                          &dwAttrCountStruct);
    FailGracefully(hr, "Failed to get StructuralObjectClass Attribute");

    if(!pAttrInfoStruct || !dwAttrCountStruct)
        ExitGracefully(hr, S_OK, "Couldn't get Structural Object Class Attribute, Assume no Aux Class");

    if(pAtrrInfoObject->dwNumValues == pAttrInfoStruct->dwNumValues)
    {
        Trace((L"No Auxillary Class Attached to this object\n"));
        goto exit_gracefully;
    }

    hListAux = DPA_Create(4);

    UINT i,j;
    BOOL bAuxClass;
    for(i = 0; i < pAtrrInfoObject->dwNumValues; ++i)
    {
        bAuxClass = TRUE;            
        for(j = 0; j < pAttrInfoStruct->dwNumValues; ++j)
        {
            if( wcscmp(pAtrrInfoObject->pADsValues[i].CaseIgnoreString,
                       pAttrInfoStruct->pADsValues[j].CaseExactString) == 0 )
            {
                bAuxClass = FALSE;
                break;
            }
        }
        if(bAuxClass)
        {
            DPA_AppendPtr(hListAux,pAtrrInfoObject->pADsValues[i].CaseExactString);
        }
    }

    UINT cCount;
    cCount = DPA_GetPtrCount(hListAux);

    if(cCount)
    {
        if(cCount > 1)        
        {
            //
            //Make a copy of hListAux
            //
            HDPA hListCopy2 = DPA_Create(cCount);
            for(i = 0; i < cCount; ++i)
                DPA_AppendPtr(hListCopy2,DPA_FastGetPtr(hListAux, i));

            //
            //For each item in hListCopy2 remove its parent from
            //hListAux
            //
            for(i = 0; i < cCount; ++i)
            {
                hr = DeleteParents(hListAux,
                                  (LPWSTR)DPA_FastGetPtr(hListCopy2, i), 
                                  m_strSchemaRootPath);
                FailGracefully(hr, "DeleteParents Failed");
                //
                //if only one item is left we are done.
                //
                if( 1 == DPA_GetPtrCount(hListAux))
                    break;
            }
        }
        
      
        //    
        // What we have left is list of mostsignificant AuxClass[es]
        //
        LPWSTR pszItem;
        cCount = DPA_GetPtrCount(hListAux);
        TraceAssert(cCount);
        if(!m_hAuxClasses)
        {
            m_hAuxClasses = DPA_Create(cCount);
        }
        //
        //Copy AuxClasses into class member
        //
        while(cCount)
        {
            pszItem = (LPWSTR)DPA_FastGetPtr(hListAux,--cCount);
            PAUX_INFO pAI = (PAUX_INFO)LocalAlloc(LPTR,sizeof(AUX_INFO) + StringByteSize(pszItem));
            if(!pAI)
                ExitGracefully(hr, E_OUTOFMEMORY, "Out of memory");
            wcscpy(pAI->pszClassName,pszItem);
            pAI->guid = GUID_NULL;                    

            DPA_AppendPtr(m_hAuxClasses, pAI);
        }
    }            

exit_gracefully:

    if(hListAux)
        DPA_Destroy(hListAux);
    if(hListCopy)
        DPA_Destroy(hListCopy);
    if(pAttrInfoStruct)
        FreeADsMem(pAttrInfoStruct);
    if(pAtrrInfoObject)
        FreeADsMem(pAtrrInfoObject);
    return S_OK;
}       









STDMETHODIMP
CDSSecurityInfo::Init(LPCWSTR pszObjectPath,
                      LPCWSTR pszObjectClass,
                      LPCWSTR pszServer,
                      LPCWSTR pszUserName,
                      LPCWSTR pszPassword,
                      DWORD   dwFlags,
                      PFNREADOBJECTSECURITY  pfnReadSD,
                      PFNWRITEOBJECTSECURITY pfnWriteSD,
                      LPARAM lpContext)
{
    HRESULT hr = S_OK;
    DWORD   dwThreadID;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::Init");
    TraceAssert(pszObjectPath != NULL);
    TraceAssert(m_strObjectPath == NULL);    // only initialize once

    m_dwInitFlags = dwFlags;

    m_ResourceManager = NULL;	
    m_pfnReadSD = DSReadObjectSecurity;
    m_pfnWriteSD = DSWriteObjectSecurity;
    m_lpReadContext = (LPARAM)this;
    m_lpWriteContext = (LPARAM)this;
    m_hLoadLibWaitEvent = NULL;

    m_hAuxClasses = NULL;  
    m_pAIGeneral = NULL;        //For First Page and Object Page on Advanced
    m_pAIProperty = NULL;       //For Property Page on Advanced
    m_pAIEffective = NULL;      //For Effective Page on Advanced
    m_pOTL = NULL;
    m_cCountOTL = 0;
    m_pDomainSid = NULL;
	m_pRootDomainSid = NULL;

    if (pfnReadSD)
    {
        m_pfnReadSD = pfnReadSD;
        m_lpReadContext = lpContext;
    }

    if (pfnWriteSD)
    {
        m_pfnWriteSD = pfnWriteSD;
        m_lpWriteContext = lpContext;
    }

    m_pDefaultSD = NULL;
    m_pSD = NULL;
    m_strObjectPath = SysAllocString(pszObjectPath);
    if (m_strObjectPath == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to copy the object path");

    if (pszObjectClass && *pszObjectClass)
        m_strObjectClass = SysAllocString(pszObjectClass);

    if (pszServer)
    {
        // Skip any preceding backslashes
        while (L'\\' == *pszServer)
            pszServer++;

        if (*pszServer)
            m_strServerName = SysAllocString(pszServer);
    }

    // Init2 cracks the path, binds to the object, checks access to
    // the object and gets the schema path.  This used to be done on
    // the other thread below, but is faster now than it used to be.
    //
    // It's preferable to do it here where we can fail and prevent the
    // page from being created if, for example, the user has no access
    // to the object's security descriptor.  This is better than always
    // creating the Security page and having it show a message
    // when initialization fails.
    hr = Init2(pszUserName, pszPassword);
    if (SUCCEEDED(hr))
    {

        //
        //Get the domain sid
        //
        GetDomainSid(m_strServerName, &m_pDomainSid);
		GetRootDomainSid(m_strServerName,&m_pRootDomainSid);

        if( !m_strObjectClass || !m_strSchemaRootPath )
        {
            // We evidently don't have read_property access to the object,
            // so just assume it's not a container, so we don't have to deal
            // with inherit types.
            //
            // We need to struggle on as best as we can. If someone removes
            // all access to an object, this is the only way an admin can
            // restore it.
            //
            m_guidObjectType = GUID_NULL;

            //don't show effective permission tab
            m_dwSIFlags &= (~SI_EDIT_EFFECTIVE);
        }
        else
        {
            //
            //Get the list of Dynamic Auxillary Classes attached to this Object.
            //
            hr = GetAuxClassList();


        }




        //Create event to make sure load library is called by InitThread before
        //function returns
        m_hLoadLibWaitEvent = CreateEvent( NULL,
                                           TRUE,
                                           FALSE,
                                           NULL );
        if( m_hLoadLibWaitEvent != NULL )
        {
            m_hInitThread = CreateThread(NULL,
                                         0,
                                         InitThread,
                                         this,
                                         0,
                                         &dwThreadID);
            
            WaitForSingleObject( m_hLoadLibWaitEvent, INFINITE );
        }
    }




exit_gracefully:
    
    if( m_hLoadLibWaitEvent )
        CloseHandle( m_hLoadLibWaitEvent );
    TraceLeaveResult(hr);
}


char const c_szDsGetDcNameProc[]       = "DsGetDcNameW";
char const c_szNetApiBufferFreeProc[]  = "NetApiBufferFree";
typedef DWORD (WINAPI *PFN_DSGETDCNAME)(LPCWSTR, LPCWSTR, GUID*, LPCWSTR, ULONG, PDOMAIN_CONTROLLER_INFOW*);
typedef DWORD (WINAPI *PFN_NETAPIFREE)(LPVOID);

HRESULT
GetDsDcAddress(BSTR *pbstrDcAddress)
{
    HRESULT hr = E_FAIL;
    HMODULE hNetApi32 = LoadLibrary(c_szNetApi32);
    if (hNetApi32)
    {
        PFN_DSGETDCNAME pfnDsGetDcName = (PFN_DSGETDCNAME)GetProcAddress(hNetApi32, c_szDsGetDcNameProc);
        PFN_NETAPIFREE pfnNetApiFree = (PFN_NETAPIFREE)GetProcAddress(hNetApi32, c_szNetApiBufferFreeProc);

        if (pfnDsGetDcName && pfnNetApiFree)
        {
            PDOMAIN_CONTROLLER_INFOW pDCI;
            DWORD dwErr = (*pfnDsGetDcName)(NULL, NULL, NULL, NULL,
                                            DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED,
                                            &pDCI);
            hr = HRESULT_FROM_WIN32(dwErr);
            if (SUCCEEDED(hr))
            {
                LPCWSTR pszAddress = pDCI->DomainControllerAddress;
                // Skip any preceding backslashes
                while (L'\\' == *pszAddress)
                    pszAddress++;
                *pbstrDcAddress = SysAllocString(pszAddress);
                if (NULL == *pbstrDcAddress)
                    hr = E_OUTOFMEMORY;
                (*pfnNetApiFree)(pDCI);
            }
        }
        FreeLibrary(hNetApi32);
    }
    return hr;
}

HRESULT
CDSSecurityInfo::Init2(LPCWSTR pszUserName, LPCWSTR pszPassword)
{
    HRESULT hr = S_OK;
    DWORD dwAccessGranted;
    PADS_OBJECT_INFO pObjectInfo = NULL;
    IADsPathname *pPath = NULL;
    LPWSTR pszTemp;
    DWORD dwPrivs[] = { SE_SECURITY_PRIVILEGE, SE_TAKE_OWNERSHIP_PRIVILEGE };
    HANDLE hToken = INVALID_HANDLE_VALUE;
    PADS_ATTR_INFO pAttributeInfo = NULL;
    DWORD dwAttributesReturned;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::Init2");
    TraceAssert(m_strObjectPath != NULL);
    TraceAssert(m_pDsObject == NULL);  // only do this one time

    //
    // Create an ADsPathname object to parse the path and get the
    // leaf name (for display) and server name (if necessary)
    //
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pPath);
    if (pPath)
    {
        if (FAILED(pPath->Set(m_strObjectPath, ADS_SETTYPE_FULL)))
            DoRelease(pPath); // sets pPath to NULL
    }

    if (NULL == m_strServerName)
    {
        // The path may or may not specify a server.  If not, call DsGetDcName
        if (pPath)
            hr = pPath->Retrieve(ADS_FORMAT_SERVER, &m_strServerName);
        if (!pPath || FAILED(hr))
            hr = GetDsDcAddress(&m_strServerName);
        FailGracefully(hr, "Unable to get server name");
    }
    Trace((TEXT("Server \"%s\""), m_strServerName));

    // Enable privileges before binding so CheckObjectAccess
    // and DSRead/WriteObjectSecurity work correctly.
    hToken = EnablePrivileges(dwPrivs, ARRAYSIZE(dwPrivs));

    // Bind to the object and get the schema path, etc.
    Trace((TEXT("Calling OpenDSObject(%s)"), m_strObjectPath));
    hr = OpenDSObject(m_strObjectPath,
                       (LPWSTR)pszUserName,
                       (LPWSTR)pszPassword,
                       ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                       IID_IDirectoryObject,
                       (LPVOID*)&m_pDsObject);
    FailGracefully(hr, "Failed to get the DS object");

    // Assume certain access by default
    if (m_dwInitFlags & DSSI_READ_ONLY)
        dwAccessGranted = READ_CONTROL;
    else
        dwAccessGranted = READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY;

    if (!(m_dwInitFlags & DSSI_NO_ACCESS_CHECK))
    {
        // Check whether the user has permission to do anything to
        // the security descriptor on this object.
        dwAccessGranted = CheckObjectAccess();
        Trace((TEXT("AccessGranted = 0x%08x"), dwAccessGranted));

        if (!(dwAccessGranted & (READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | SI_MAY_WRITE)))
            ExitGracefully(hr, E_ACCESSDENIED, "No access");
    }

    // Translate the access into SI_* flags, starting with this:
    m_dwSIFlags = SI_EDIT_ALL | SI_ADVANCED | SI_EDIT_PROPERTIES | SI_SERVER_IS_DC |SI_EDIT_EFFECTIVE;

    if (!(dwAccessGranted & WRITE_DAC))
    {
        if( !(dwAccessGranted & SI_MAY_WRITE) )
            m_dwSIFlags |= SI_READONLY;
        else
            m_dwSIFlags |= SI_MAY_WRITE;
    }

    if (!(dwAccessGranted & WRITE_OWNER))
    {
        if (!(dwAccessGranted & READ_CONTROL))
            m_dwSIFlags &= ~SI_EDIT_OWNER;
        else
            m_dwSIFlags |= SI_OWNER_READONLY;
    }

    if (!(dwAccessGranted & ACCESS_SYSTEM_SECURITY) || (m_dwInitFlags & DSSI_NO_EDIT_SACL))
        m_dwSIFlags &= ~SI_EDIT_AUDITS;

    if (m_dwInitFlags & DSSI_NO_EDIT_OWNER)
        m_dwSIFlags &= ~SI_EDIT_OWNER;

	// If this is a root object (ex. domain), hide the ACL protect checkbox
	if ((m_dwInitFlags & DSSI_IS_ROOT) || IsRootObject(m_pDsObject))
	{
		m_dwSIFlags |= SI_NO_ACL_PROTECT;
    }

    // Get the class name and schema path
    m_pDsObject->GetObjectInformation(&pObjectInfo);
    if (pObjectInfo)
    {
        //
        // Note that m_strObjectClass, if provided, can be different
        // than pObjectInfo->pszClassName.  This is true when editing default
        // ACLs on schema class objects, for example, in which case
        // pObjectInfo->pszClassName will be "attributeSchema" but m_strObjectClass
        // will be something else such as "computer" or "user". Be
        // careful to only use pObjectInfo->pszClassName for getting the path of
        // the schema root, and use m_strObjectClass for everything else.
        //
        // If m_strObjectClass is not provided, use pObjectInfo->pszClassName.
        //
        if (m_strObjectClass == NULL)
            m_strObjectClass = SysAllocString(pObjectInfo->pszClassName);


        // Get the the path of the schema root
        int nClassLen;
        nClassLen = lstrlenW(pObjectInfo->pszClassName);
        pszTemp = pObjectInfo->pszSchemaDN + lstrlenW(pObjectInfo->pszSchemaDN) - nClassLen;
        if (CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,
                                        NORM_IGNORECASE,
                                        pszTemp,
                                        nClassLen,
                                        pObjectInfo->pszClassName,
                                        nClassLen))
        {
            *pszTemp = L'\0';
        }

        // Save the schema root path
        m_strSchemaRootPath = SysAllocString(pObjectInfo->pszSchemaDN);

    }

    //For computer objects only use CN as display name doesn't get updated
    //when name of computer is changed which results in displaying old name.
    //see bug 104186	
    if(!m_strObjectClass || lstrcmpi(m_strObjectClass,CLASS_COMPUTER))
    {
        //
        // Get the displayName property
        //
        pszTemp = (LPWSTR)c_szDisplayName;
        HRESULT hr1 = m_pDsObject->GetObjectAttributes(&pszTemp,
                                                       1,
                                                       &pAttributeInfo,
                                                       &dwAttributesReturned);

        //NTRAID#NTBUG9-68903-2002/08/07-hiteshr
        //Under certain conditions where underlying AD is host, and ADSI fails to 
        //to get any schema information from AD, this can fail or return information
        //in provider specific format. 
        if (SUCCEEDED(hr1) && 
            pAttributeInfo && 
            pAttributeInfo->pADsValues->dwType == ADSTYPE_CASE_EXACT_STRING )
        {
            m_strDisplayName = SysAllocString(pAttributeInfo->pADsValues->CaseExactString);
            FreeADsMem(pAttributeInfo);
            pAttributeInfo = NULL;
        }
    }

    // If that failed, try the leaf name.
    if (!m_strDisplayName && pPath)
    {
        // Retrieve the display name
        pPath->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        pPath->Retrieve(ADS_FORMAT_LEAF, &m_strDisplayName);
        pPath->SetDisplayType(ADS_DISPLAY_FULL);
    }
    
    // If we still don't have a display name, just copy the RDN.
    // Ugly, but better than nothing.    
    if (!m_strDisplayName && pObjectInfo)
        m_strDisplayName = SysAllocString(pObjectInfo->pszRDN);


exit_gracefully:

    if (pObjectInfo)
        FreeADsMem(pObjectInfo);

    DoRelease(pPath);
    ReleasePrivileges(hToken);

    TraceLeaveResult(hr);
}


HRESULT
CDSSecurityInfo::Init3()
{
    HRESULT hr = S_OK;
    IADsClass *pDsClass = NULL;
    VARIANT var = {0};

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::Init3");
    TraceAssert(m_strSchemaRootPath != NULL);
    TraceAssert(m_strObjectClass != NULL);

    if (m_bThreadAbort)
        goto exit_gracefully;

    // Create the schema cache
    // Sandwich this SchemaCache_Create call with refcounting. In the event that
    // the threads created therein take a long time to return, this allows the
    // release on the CDSSecurityInfo object in the invoking application to simply
    // return instead of waiting potentially a very long time for the schema cache
    // creation threads to complete.  This is because the last release on the 
    // CDSSecurityInfo calls its destructor (duh!) and the destructor waits on the
    // threads.
    AddRef ();  
    hr = SchemaCache_Create(m_strServerName);
    Release();
    FailGracefully(hr, "Unable to create schema cache");

    if( m_strSchemaRootPath && m_strObjectClass )
    {

        // Bind to the schema class object
        hr = Schema_BindToObject(m_strSchemaRootPath,
                                 m_strObjectClass,
                                 IID_IADsClass,
                                 (LPVOID*)&pDsClass);
        FailGracefully(hr, "Failed to get the Schema class object");

        // Get the class GUID
        Schema_GetObjectID(pDsClass, &m_guidObjectType);

        if (m_bThreadAbort)
            goto exit_gracefully;

        // See if this object is a container, by getting the list of possible
        // child classes.  If this fails, treat it as a non-container.
        pDsClass->get_Containment(&var);
     
        //set m_dwLocalFlags to DSSI_LOCAL_NO_CREATE_DELETE if object is not 
        // a container. If this flag is set, CREATE_DELETE permission which are
        // inherited from parents but meaning less for leaf object will not be shown.
        // In most cases presence of this flag is same as absence of SI_CONTAINER in m_dwSIFlags,
        // however in some cases its not possible to determine if the object is container or not.
        // there object is treated as non-container but we still must show all the aces.
     
        if (V_VT(&var) == (VT_ARRAY | VT_VARIANT))
        {
            LPSAFEARRAY psa = V_ARRAY(&var);

            TraceAssert(psa && psa->cDims == 1);

            if (psa->rgsabound[0].cElements > 0)
            {
                m_dwSIFlags |= SI_CONTAINER;
            }
            else
                m_dwLocalFlags |= DSSI_LOCAL_NO_CREATE_DELETE;
        }
        else if (V_VT(&var) == VT_BSTR) // single entry
        {
            TraceAssert(V_BSTR(&var));
            m_dwSIFlags |= SI_CONTAINER;
        }
        else
            m_dwLocalFlags |= DSSI_LOCAL_NO_CREATE_DELETE;

        if( !IsEqualGUID( m_guidObjectType, GUID_NULL ) )
        {
            hr = Schema_GetDefaultSD( &m_guidObjectType, m_pDomainSid, m_pRootDomainSid, &m_pDefaultSD );
            FailGracefully(hr, "Failed to get the Schema class object");
            
            m_dwSIFlags |= SI_RESET_DACL;
        }

    }
exit_gracefully:

    VariantClear(&var);
    DoRelease(pDsClass);

    TraceLeaveResult(hr);
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

#undef CLASS_NAME
#define CLASS_NAME CDSSecurityInfo
#include "unknown.inc"

STDMETHODIMP
CDSSecurityInfo::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    INTERFACES iface[] =
    {
        &IID_ISecurityInformation, static_cast<LPSECURITYINFO>(this),
        &IID_IEffectivePermission, static_cast<LPEFFECTIVEPERMISSION>(this),
        &IID_ISecurityObjectTypeInfo, static_cast<LPSecurityObjectTypeInfo>(this),
    };

    return HandleQueryInterface(riid, ppv, iface, ARRAYSIZE(iface));
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CDSSecurityInfo::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetObjectInformation");
    TraceAssert(pObjectInfo != NULL &&
                !IsBadWritePtr(pObjectInfo, SIZEOF(*pObjectInfo)));

    pObjectInfo->hInstance = GLOBAL_HINSTANCE;
    pObjectInfo->dwFlags = m_dwSIFlags ;
    pObjectInfo->pszServerName = m_strServerName;
    pObjectInfo->pszObjectName = m_strDisplayName ? m_strDisplayName : m_strObjectPath;

    if (!IsEqualGUID(m_guidObjectType, GUID_NULL))
    {
        pObjectInfo->dwFlags |= SI_OBJECT_GUID;
        pObjectInfo->guidObjectType = m_guidObjectType;
    }

    TraceLeaveResult(S_OK);
}

//IF object is leaf object which cannot have create/detele object
//permissions, this function removes those aces from SD, so that 
//they are not displayed. It only removes inherited aces, if ace is 
//explicit, it better get displayed so that user can remove it.
//This is done to fix bug 14793

DWORD
RemoveRedundantPermissions( PSECURITY_DESCRIPTOR *ppSD, GUID *pGuidObjectType )

{

    PACL pAcl = NULL;
    PACE_HEADER pAce= NULL;
    UINT cAces = 0;
    BOOL *pBoolArray = NULL;
    TraceEnter(TRACE_DSSI, "RemoveRedundantPermissions");

    if ( NULL == ppSD || NULL == *ppSD )
        TraceLeaveResult(ERROR_SUCCESS);   // Nothing to do

    BOOL bDefaulted;
    BOOL bPresent;
    GetSecurityDescriptorDacl(*ppSD, &bPresent, &pAcl, &bDefaulted);

    if (NULL != pAcl)
    {
        if(pAcl->AceCount)
        {
            //pBoolArray is initialzied to FALSE
            pBoolArray = (PBOOL)LocalAlloc(LPTR,sizeof(BOOL)*pAcl->AceCount);
            if(!pBoolArray)
                return ERROR_NOT_ENOUGH_MEMORY;
        }            

        for (cAces = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
             cAces < pAcl->AceCount;
             ++cAces, pAce = (PACE_HEADER)NextAce(pAce))
        {
            if( pAce->AceFlags & INHERITED_ACE )
            {
            //If Only Create Child/Delete Child don't show it
                if((((ACCESS_ALLOWED_ACE*)pAce)->Mask & (~(ACTRL_DS_CREATE_CHILD |ACTRL_DS_DELETE_CHILD))) == 0 )
                {
                    pBoolArray[cAces] = TRUE;
                    continue;
                }
                //If the ace is inherited and inherit only and inherited object type
                //is not same as this object type bug 22559
                if( (((ACCESS_ALLOWED_ACE*)pAce)->Header.AceFlags & INHERIT_ONLY_ACE )
                    && IsObjectAceType(pAce) )
                {
                    GUID *pGuid = RtlObjectAceInheritedObjectType(pAce);
                    if(pGuid && pGuidObjectType && !IsEqualGUID(*pGuid,*pGuidObjectType))
                    {
                        pBoolArray[cAces] = TRUE;
                        continue;
                    }
                }
            }
        }
        //Now Delete the Aces
        UINT cAceCount = pAcl->AceCount;
        UINT cAdjust = 0;
        for( cAces = 0; cAces < cAceCount; ++cAces)
        {
            if(pBoolArray[cAces])
            {
                DeleteAce(pAcl, cAces - cAdjust);
                cAdjust++;
            }
        }
        LocalFree(pBoolArray);
    }
    TraceLeaveResult(ERROR_SUCCESS);
}


STDMETHODIMP
CDSSecurityInfo::GetSecurity(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR *ppSD,
                             BOOL fDefault)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetSecurity");
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    *ppSD = NULL;

    
    if (fDefault)
    {
        if( m_pDefaultSD )
        {
            ULONG nLength = GetSecurityDescriptorLength(m_pDefaultSD);
            *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, nLength);
            if (*ppSD != NULL)
                CopyMemory(*ppSD, m_pDefaultSD, nLength);
            else
                hr = E_OUTOFMEMORY;   
        }
        else
            hr = E_NOTIMPL;
    }
    else if (!(si & SACL_SECURITY_INFORMATION) && m_pSD != NULL)
    {
        ULONG nLength = GetSecurityDescriptorLength(m_pSD);

        *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, nLength);
        if (*ppSD != NULL)
            CopyMemory(*ppSD, m_pSD, nLength);
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        TraceAssert(m_strObjectPath != NULL);
        TraceAssert(m_pfnReadSD != NULL)
        hr = (*m_pfnReadSD)(m_strObjectPath, si, ppSD, m_lpReadContext);
    }

    if( si & DACL_SECURITY_INFORMATION && (m_dwLocalFlags & DSSI_LOCAL_NO_CREATE_DELETE ) )
        RemoveRedundantPermissions(ppSD, &m_guidObjectType);        

    TraceLeaveResult(hr);
}


STDMETHODIMP
CDSSecurityInfo::SetSecurity(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::SetSecurity");
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);

    TraceAssert(m_strObjectPath != NULL);
    TraceAssert(m_pfnWriteSD != NULL)
    hr = (*m_pfnWriteSD)(m_strObjectPath, si, pSD, m_lpWriteContext);

    if (SUCCEEDED(hr) && m_pSD != NULL && (si != SACL_SECURITY_INFORMATION))
    {
        // The initial security descriptor is no longer valid.
        LocalFree(m_pSD);
        m_pSD = NULL;
    }

    TraceLeaveResult(hr);
}


STDMETHODIMP
CDSSecurityInfo::GetAccessRights(const GUID* pguidObjectType,
                                 DWORD dwFlags,
                                 PSI_ACCESS *ppAccesses,
                                 ULONG *pcAccesses,
                                 ULONG *piDefaultAccess)
{
    HRESULT hr = S_OK;
    LPCTSTR pszClassName = NULL;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetAccessRights");
    TraceAssert(ppAccesses != NULL);
    TraceAssert(pcAccesses != NULL);
    TraceAssert(piDefaultAccess != NULL);

    *ppAccesses = NULL;
    *pcAccesses = 0;
    *piDefaultAccess = 0;

    WaitOnInitThread();

    //
    //If we are getting the access rights for GUID which is selected in the
    //Apply onto combobox of permission page, we don't need to worry about
    //aux class. Only get the permission for the object type
    //
    BOOL bInheritGuid = TRUE;

    if (pguidObjectType == NULL || IsEqualGUID(*pguidObjectType, GUID_NULL))
    {
        bInheritGuid = FALSE;
        pguidObjectType = &m_guidObjectType;
        pszClassName = m_strObjectClass;
    }

    if (m_dwInitFlags & DSSI_NO_FILTER)
        dwFlags |= SCHEMA_NO_FILTER;

    // No schema path means we don't have read_property access to the object.
    // This limits what we can do.
    if (NULL == m_strSchemaRootPath)
        dwFlags |= SCHEMA_COMMON_PERM;

    PACCESS_INFO *ppAI = NULL;
    PACCESS_INFO pAI = NULL;
    if(!bInheritGuid)
    {
        if(dwFlags & SI_EDIT_PROPERTIES)
            ppAI = &m_pAIProperty;
        else if(dwFlags & SI_EDIT_EFFECTIVE)
            ppAI = &m_pAIEffective;    
        else
            ppAI = &m_pAIGeneral;
    }
    else
    {
        ppAI = &pAI;
    }

    if(!*ppAI)
    {
        hr = SchemaCache_GetAccessRights(pguidObjectType,
                                         pszClassName,
                                         !bInheritGuid ? m_hAuxClasses : NULL,
                                         m_strSchemaRootPath,
                                         dwFlags,
                                         ppAI);
        if(FAILED(hr))
        {
            return hr;
        }
    }

    if(*ppAI)
    {
        *ppAccesses = (*ppAI)->pAccess;
        *pcAccesses = (*ppAI)->cAccesses;
        *piDefaultAccess = (*ppAI)->iDefaultAccess;
    }
    
    TraceLeaveResult(hr);
}


STDMETHODIMP
CDSSecurityInfo::MapGeneric(const GUID* /*pguidObjectType*/,
                            UCHAR *pAceFlags,
                            ACCESS_MASK *pmask)
{
    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::MapGeneric");
    TraceAssert(pAceFlags != NULL);
    TraceAssert(pmask != NULL);

    // Only CONTAINER_INHERIT_ACE has meaning for DS
    *pAceFlags &= ~OBJECT_INHERIT_ACE;

    MapGenericMask(pmask, &g_DSMap);

    // We don't expose SYNCHRONIZE, so don't pass it through
    // to the UI.  192389
    *pmask &= ~SYNCHRONIZE;

    TraceLeaveResult(S_OK);
}


STDMETHODIMP
CDSSecurityInfo::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                                 ULONG *pcInheritTypes)
{
    HRESULT hr;
    DWORD dwFlags = 0;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetInheritTypes");

    if (m_dwInitFlags & DSSI_NO_FILTER)
        dwFlags |= SCHEMA_NO_FILTER;

    hr = SchemaCache_GetInheritTypes(&m_guidObjectType, dwFlags, ppInheritTypes, pcInheritTypes);

    TraceLeaveResult(hr);
}


STDMETHODIMP
CDSSecurityInfo::PropertySheetPageCallback(HWND hwnd,
                                           UINT uMsg,
                                           SI_PAGE_TYPE uPage)
{
    if (PSPCB_SI_INITDIALOG == uMsg && uPage == SI_PAGE_PERM)
    {
        WaitOnInitThread();
    

        //
        // HACK ALERT!!!
        //
        // Exchange Platinum is required to hide membership of some groups
        // (distribution lists) for legal reasons. The only way they found
        // to do this is with non-canonical ACLs which look roughly like
        //   Allow Admins access
        //   Deny Everyone access
        //   <normal ACL>
        //
        // Since ACLUI always generates ACLs in NT Canonical Order, we can't
        // allow these funky ACLs to be modified. If we did, the DL's would
        // either become visible or Admins would get locked out.
        //
        if (!(SI_READONLY & m_dwSIFlags))
        {
            DWORD dwAclType = IsSpecificNonCanonicalSD(m_pSD);
            if (ENC_RESULT_NOT_PRESENT != dwAclType)
            {
                // It's a funky ACL so don't allow changes
                m_dwSIFlags |= SI_READONLY;

                // Tell the user what's going on
                MsgPopup(hwnd,
                         MAKEINTRESOURCE(IDS_SPECIAL_ACL_WARNING),
                         MAKEINTRESOURCE(IDS_SPECIAL_SECURITY_TITLE),
                         MB_OK | MB_ICONWARNING | MB_SETFOREGROUND,
                         g_hInstance,
                         m_strDisplayName);

                // S_FALSE suppresses further popups from aclui ("The ACL
                // is not ordered correctly, etc.")
                return S_FALSE;
            }
        }

        if( (SI_READONLY & m_dwSIFlags) && (DSSI_NO_READONLY_MESSAGE & m_dwSIFlags) )
            return S_FALSE;
    }
    return S_OK;
}

DWORD WINAPI
CDSSecurityInfo::InitThread(LPVOID pvThreadData)
{
    CDSSecurityInfo *psi;

    HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);
    psi = (CDSSecurityInfo*)pvThreadData;
    
    SetEvent(psi->m_hLoadLibWaitEvent);
    InterlockedIncrement(&GLOBAL_REFCOUNT);


    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::InitThread");
    TraceAssert(psi != NULL);

#if DBG
    DWORD dwTime = GetTickCount();
#endif

    ThreadCoInitialize();

    psi->Init3();

    ThreadCoUninitialize();

#if DBG
    Trace((TEXT("InitThread complete, elapsed time: %d ms"), GetTickCount() - dwTime));
#endif

    TraceLeave();

    ASSERT( 0 != GLOBAL_REFCOUNT );
    InterlockedDecrement(&GLOBAL_REFCOUNT);
    FreeLibraryAndExitThread(hInstThisDll, 0);

}


HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CDSSecurityInfo::DSReadObjectSecurity
//
//  Synopsis:   Reads the security descriptor from the specied DS object
//
//  Arguments:  [IN  pszObjectPath] --  ADS path of DS object
//              [IN  SeInfo]        --  Security descriptor parts requested
//              [OUT ppSD]          --  Security descriptor returned here
//              [IN  lpContext]     --  CDSSecurityInfo*
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
HRESULT WINAPI
CDSSecurityInfo::DSReadObjectSecurity(LPCWSTR /*pszObjectPath*/,
                                      SECURITY_INFORMATION SeInfo,
                                      PSECURITY_DESCRIPTOR *ppSD,
                                      LPARAM lpContext)
{
    HRESULT hr = S_OK;
    LPWSTR pszSDProperty = (LPWSTR)c_szSDProperty;
    PADS_ATTR_INFO pSDAttributeInfo = NULL;
    DWORD dwAttributesReturned;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::DSReadObjectSecurity");
    TraceAssert(SeInfo != 0);
    TraceAssert(ppSD != NULL);
    TraceAssert(lpContext != 0);

    *ppSD = NULL;

    CDSSecurityInfo *pThis = reinterpret_cast<CDSSecurityInfo*>(lpContext);
    TraceAssert(pThis != NULL);
    TraceAssert(pThis->m_pDsObject != NULL);

    // Set the SECURITY_INFORMATION mask
    hr = SetSecurityInfoMask(pThis->m_pDsObject, SeInfo);
    FailGracefully(hr, "Unable to set ADS_OPTION_SECURITY_MASK");

    // Read the security descriptor
    hr = pThis->m_pDsObject->GetObjectAttributes(&pszSDProperty,
                                                 1,
                                                 &pSDAttributeInfo,
                                                 &dwAttributesReturned);
    if (SUCCEEDED(hr) && !pSDAttributeInfo)
        hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege
    FailGracefully(hr, "Unable to read nTSecurityDescriptor attribute");

    TraceAssert(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType);
    TraceAssert(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType);

    *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);
    if (!*ppSD)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    CopyMemory(*ppSD,
               pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue,
               pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);

exit_gracefully:

    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    TraceLeaveResult(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CDSSecurityInfo::DSWriteObjectSecurity
//
//  Synopsis:   Writes the security descriptor to the specied DS object
//
//  Arguments:  [IN  pszObjectPath] --  ADS path of DS object
//              [IN  SeInfo]        --  Security descriptor parts provided
//              [IN  pSD]           --  The new security descriptor
//              [IN  lpContext]     --  CDSSecurityInfo*
//
//----------------------------------------------------------------------------
HRESULT WINAPI
CDSSecurityInfo::DSWriteObjectSecurity(LPCWSTR /*pszObjectPath*/,
                                       SECURITY_INFORMATION SeInfo,
                                       PSECURITY_DESCRIPTOR pSD,
                                       LPARAM lpContext)
{
    HRESULT hr = S_OK;
    ADSVALUE attributeValue;
    ADS_ATTR_INFO attributeInfo;
    DWORD dwAttributesModified;
    DWORD dwSDLength;
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
    DWORD dwRevision;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::DSWriteObjectSecurity");
    TraceAssert(pSD && IsValidSecurityDescriptor(pSD));
    TraceAssert(SeInfo != 0);
    TraceAssert(lpContext != 0);

    CDSSecurityInfo *pThis = reinterpret_cast<CDSSecurityInfo*>(lpContext);
    TraceAssert(pThis != NULL);
    TraceAssert(pThis->m_pDsObject != NULL);

    // Set the SECURITY_INFORMATION mask
    hr = SetSecurityInfoMask(pThis->m_pDsObject, SeInfo);
    FailGracefully(hr, "Unable to set ADS_OPTION_SECURITY_MASK");

    // Need the total size
    dwSDLength = GetSecurityDescriptorLength(pSD);

    //
    // If necessary, make a self-relative copy of the security descriptor
    //
    GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision);
    if (!(sdControl & SE_SELF_RELATIVE))
    {
        psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

        if (psd == NULL ||
            !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
        {
            DWORD dwErr = GetLastError();
            ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "Unable to make self-relative SD copy");
        }

        // Point to the self-relative copy
        pSD = psd;
    }

    attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attributeValue.SecurityDescriptor.dwLength = dwSDLength;
    attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSD;

    attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
    attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
    attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attributeInfo.pADsValues = &attributeValue;
    attributeInfo.dwNumValues = 1;

    // Write the security descriptor
    hr = pThis->m_pDsObject->SetObjectAttributes(&attributeInfo,
                                                 1,
                                                 &dwAttributesModified);
    if (HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION) == hr
        && OWNER_SECURITY_INFORMATION == SeInfo)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_OWNER);
    }

exit_gracefully:

    if (psd != NULL)
        LocalFree(psd);

    TraceLeaveResult(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckObjectAccess
//
//  Synopsis:   Checks access to the security descriptor of a DS object.
//              In particular, determines whether the user has READ_CONTROL,
//              WRITE_DAC, WRITE_OWNER, and/or ACCESS_SYSTEM_SECURITY access.
//              If it cannot determine for sure about WRITE_DAC permission,
//              it returns SI_MAY_WRITE which helps aclui to put a better warning
//  Arguments:  none
//
//  Return:     DWORD (Access Mask)
//
//  Notes:      The check for READ_CONTROL involves reading the Owner,
//              Group, and DACL.  This security descriptor is saved
//              in m_pSD.
//
//              The checks for WRITE_DAC, WRITE_OWNER, and
//              ACCESS_SYSTEM_SECURITY involve getting sDRightsEffective
//              from the object.
//
//----------------------------------------------------------------------------
DWORD
CDSSecurityInfo::CheckObjectAccess()
{
    DWORD dwAccessGranted = 0;
    HRESULT hr;
    SECURITY_INFORMATION si = 0;
    LPWSTR pProp = (LPWSTR)c_szSDRightsProp;
    PADS_ATTR_INFO pSDRightsInfo = NULL;
    DWORD dwAttributesReturned;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::CheckObjectAccess");

#ifdef DSSEC_PRIVATE_DEBUG
    // FOR DEBUGGING ONLY
    // Turn this on to prevent the dialogs from being read-only. This is
    // useful for testing the object picker against NTDEV (for example).
    TraceMsg("Returning all access for debugging");
    dwAccessGranted = (READ_CONTROL | WRITE_OWNER | WRITE_DAC | ACCESS_SYSTEM_SECURITY);
#endif

    // Test for READ_CONTROL by trying to read the Owner, Group, and DACL
    TraceAssert(NULL == m_pSD); // shouldn't get here twice
    TraceAssert(m_strObjectPath != NULL);
    TraceAssert(m_pfnReadSD != NULL);
    hr = (*m_pfnReadSD)(m_strObjectPath,
                        OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                        &m_pSD,
                        m_lpReadContext);
    if (SUCCEEDED(hr))
    {
        TraceAssert(NULL != m_pSD);
        dwAccessGranted |= READ_CONTROL;
    }

    // If we're in read-only mode, there's no need to check anything else.
    if (m_dwInitFlags & DSSI_READ_ONLY)
        TraceLeaveValue(dwAccessGranted);

    // Read the sDRightsEffective property to determine writability
    m_pDsObject->GetObjectAttributes(&pProp,
                                     1,
                                     &pSDRightsInfo,
                                     &dwAttributesReturned);
    if (pSDRightsInfo)
    {
        TraceAssert(ADSTYPE_INTEGER == pSDRightsInfo->dwADsType);
        si = pSDRightsInfo->pADsValues->Integer;
        FreeADsMem(pSDRightsInfo);
    }
    else
    {
        //
        // Note that GetObjectAttributes commonly returns S_OK even when
        // it fails, so the HRESULT is basically useless here.
        //
        // This can fail if we don't have read_property access, which can
        // happen when an admin is trying to restore access to an object
        // that has had all access removed or denied
        //
        // Assume we can write the Owner and DACL. If not, the worst that
        // happens is the user gets an "Access Denied" message when trying
        // to save changes.
        //
        //Instead of add SI_MAY_WRITE to dwAccessGranted . This helps 
        //ACLUI to putup a better error message. bug 411843

        TraceMsg("GetObjectAttributes failed to read sDRightsEffective");
        dwAccessGranted |= SI_MAY_WRITE;
        si = OWNER_SECURITY_INFORMATION ;
    }

    // The resulting SECURITY_INFORMATION mask indicates the
    // security descriptor parts that may be modified by the user.
    Trace((TEXT("sDRightsEffective = 0x%08x"), si));

    if (OWNER_SECURITY_INFORMATION & si)
        dwAccessGranted |= WRITE_OWNER;

    if (DACL_SECURITY_INFORMATION & si)
        dwAccessGranted |= WRITE_DAC;

    if (SACL_SECURITY_INFORMATION & si)
        dwAccessGranted |= ACCESS_SYSTEM_SECURITY;

    TraceLeaveValue(dwAccessGranted);
}

BOOL SkipLocalGroup(LPCWSTR pszServerName, PSID psid)
{

	SID_NAME_USE use;
	WCHAR szAccountName[MAX_PATH];
	WCHAR szDomainName[MAX_PATH];
	DWORD dwAccountLen = MAX_PATH;
	DWORD dwDomainLen = MAX_PATH;

	if(LookupAccountSid(pszServerName,
						 psid,
						 szAccountName,
						 &dwAccountLen,
						 szDomainName,
						 &dwDomainLen,
						 &use))
	{
		if(use == SidTypeWellKnownGroup)
			return TRUE;
	}

	//
	//Built In sids have first subauthority of 32 ( s-1-5-32 )
	//
	if((*(GetSidSubAuthorityCount(psid)) >= 1 ) && (*(GetSidSubAuthority(psid,0)) == 32))
		return TRUE;
	
	return FALSE;
}

					 



STDMETHODIMP 
CDSSecurityInfo::GetEffectivePermission(const GUID* pguidObjectType,
                                        PSID pUserSid,
                                        LPCWSTR pszServerName,
                                        PSECURITY_DESCRIPTOR pSD,
                                        POBJECT_TYPE_LIST *ppObjectTypeList,
                                        ULONG *pcObjectTypeListLength,
                                        PACCESS_MASK *ppGrantedAccessList,
                                        ULONG *pcGrantedAccessListLength)
{
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    LUID luid = {0xdead,0xbeef};    
    AUTHZ_ACCESS_REQUEST AReq;
    AUTHZ_ACCESS_REPLY AReply;
    HRESULT hr = S_OK;    
    DWORD dwFlags = 0;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetEffectivePermission");
    TraceAssert(pUserSid && IsValidSecurityDescriptor(pSD));
    TraceAssert(ppObjectTypeList != NULL);
    TraceAssert(pcObjectTypeListLength != NULL);
    TraceAssert(ppGrantedAccessList != NULL);
    TraceAssert(pcGrantedAccessListLength != NULL);

    AReply.GrantedAccessMask = NULL;
    AReply.Error = NULL;
    AReq.ObjectTypeList = NULL;
    AReq.ObjectTypeListLength = 0;
 
    if( m_ResourceManager == NULL )
    {	
        //Initilize RM for Access check
    	AuthzInitializeResourceManager(AUTHZ_RM_FLAG_NO_AUDIT,
        							   NULL,
                	                   NULL,
                        	           NULL,
                                       L"Dummy",
                                       &m_ResourceManager );
	
	if( m_ResourceManager == NULL )
            ExitGracefully(hr, E_UNEXPECTED, "Could Not Get Resource Manager");    
    }

    //Initialize the client context

    BOOL bSkipLocalGroup = SkipLocalGroup(pszServerName, pUserSid);
    
    if( !AuthzInitializeContextFromSid(bSkipLocalGroup?AUTHZ_SKIP_TOKEN_GROUPS:0 ,
                                       pUserSid,
                                       m_ResourceManager,
                                       NULL,
                                       luid,
                                       NULL,
                                       &CC) )
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr, 
                       HRESULT_FROM_WIN32(dwErr),
                       "AuthzInitializeContextFromSid Failed");
    }

    if (NULL == m_strSchemaRootPath)
        dwFlags = SCHEMA_COMMON_PERM;

    if(!m_pOTL)
    {
        //Get ObjectTypeList
        hr = Schema_GetObjectTypeList((LPGUID)pguidObjectType,
                                      m_hAuxClasses,
                                      m_strSchemaRootPath,
                                      dwFlags,
                                      &(AReq.ObjectTypeList), 
                                      &(AReq.ObjectTypeListLength));
        FailGracefully( hr, "Schema_GetObjectTypeList Failed");
        m_pOTL = AReq.ObjectTypeList;
        m_cCountOTL = AReq.ObjectTypeListLength;
    }
    else
    {
        AReq.ObjectTypeList = m_pOTL;
        AReq.ObjectTypeListLength = m_cCountOTL;
    }

    //Do the Access Check

    AReq.DesiredAccess = MAXIMUM_ALLOWED;
    AReq.PrincipalSelfSid = NULL;
    AReq.OptionalArguments = NULL;

    AReply.ResultListLength = AReq.ObjectTypeListLength;
    AReply.SaclEvaluationResults = NULL;
    if( (AReply.GrantedAccessMask = (PACCESS_MASK)LocalAlloc(LPTR, sizeof(ACCESS_MASK)*AReply.ResultListLength) ) == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to LocalAlloc");
    if( (AReply.Error = (PDWORD)LocalAlloc(LPTR, sizeof(DWORD)*AReply.ResultListLength)) == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to LocalAlloc");

    if( !AuthzAccessCheck(0,
                          CC,
                          &AReq,
                          NULL,
                          pSD,
                          NULL,
                          0,
                          &AReply,
                          NULL) )
    {
        DWORD dwErr = GetLastError();
        ExitGracefully(hr,                        
                       HRESULT_FROM_WIN32(dwErr),
                       "AuthzAccessCheck Failed");
    }

exit_gracefully:

    if(CC)
        AuthzFreeContext(CC);
    
    if(!SUCCEEDED(hr))
    {
        if(AReply.GrantedAccessMask)
            LocalFree(AReply.GrantedAccessMask);
        if(AReply.Error)
            LocalFree(AReply.Error);
        AReply.Error = NULL;
        AReply.GrantedAccessMask = NULL;
    }
    else
    {
        *ppObjectTypeList = AReq.ObjectTypeList;                                  
        *pcObjectTypeListLength = AReq.ObjectTypeListLength;
        *ppGrantedAccessList = AReply.GrantedAccessMask;
        *pcGrantedAccessListLength = AReq.ObjectTypeListLength;
    }

    TraceLeaveResult(hr);
}

STDMETHODIMP 
CDSSecurityInfo::GetInheritSource(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray)
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    PINHERITED_FROM pTempInherit = NULL;
    PINHERITED_FROM pTempInherit2 = NULL;
    LPWSTR pStrTemp = NULL;
    IADsPathname *pPath = NULL;
    BSTR strObjectPath = NULL;
    BSTR strServerName = NULL;
    BSTR strParentPath = NULL;
    LPGUID *ppGuid = NULL;
	BOOL bFreeInheritFromArray = FALSE;

    TraceEnter(TRACE_DSSI, "CDSSecurityInfo::GetInheritSource");
    TraceAssert(pACL != 0);
    TraceAssert(ppInheritArray != NULL);

    //
    // Create an ADsPathname object to parse the path and get the
    // the objectname in ADS_FORMAT_X500_DN 
    //
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pPath);

    if (pPath)
    {
        if (SUCCEEDED(pPath->Set(m_strObjectPath, ADS_SETTYPE_FULL)))
        {
            hr = pPath->Retrieve(ADS_FORMAT_SERVER, &strServerName);
            if(!strServerName)
            {
                pPath->Set(m_strServerName,ADS_SETTYPE_SERVER );
                hr = pPath->Retrieve(ADS_FORMAT_X500 ,&strObjectPath);
            }
            else
                strObjectPath = m_strObjectPath;
        }
    }

    if(strObjectPath == NULL)
        strObjectPath = m_strObjectPath;


    if( pACL == NULL || ppInheritArray == NULL )
        ExitGracefully(hr, E_POINTER, "CDSSecurityInfo::GetInheritSource Invalid Parameters");

    pTempInherit = (PINHERITED_FROM)LocalAlloc( LPTR, sizeof(INHERITED_FROM)*pACL->AceCount);
    if(pTempInherit == NULL)
            ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");

    UINT cGuidCount;
    cGuidCount = 1;
    if(m_hAuxClasses)
        cGuidCount += DPA_GetPtrCount(m_hAuxClasses);

    ppGuid = (LPGUID*)LocalAlloc(LPTR,sizeof(LPGUID)*cGuidCount);
    if(!ppGuid)
        ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");

    ppGuid[0] = &m_guidObjectType;

    for(UINT i = 1; i < cGuidCount ; ++i)
    {
        PAUX_INFO pAI = (PAUX_INFO)DPA_FastGetPtr(m_hAuxClasses, i-1);     
        if(IsEqualGUID(pAI->guid, GUID_NULL))
        {
            hr = Schema_GetObjectTypeGuid(pAI->pszClassName,&pAI->guid);
			FailGracefully( hr, "Schema_GetObjectTypeGuid Failed");
        }
        ppGuid[i] = &pAI->guid;
    }

    dwErr = GetInheritanceSource(strObjectPath,
                                 SE_DS_OBJECT_ALL,
                                 si,
                                 //m_dwSIFlags & SI_CONTAINER,
                                 TRUE,
                                 ppGuid,
                                 cGuidCount,
                                 pACL,
                                 NULL,
                                 &g_DSMap,
                                 pTempInherit);
    
    hr = HRESULT_FROM_WIN32(dwErr);
    FailGracefully( hr, "GetInheritanceSource Failed");

	bFreeInheritFromArray = TRUE;
    DWORD nSize;
    

    nSize = sizeof(INHERITED_FROM)*pACL->AceCount;
    for(UINT i = 0; i < pACL->AceCount; ++i)
    {
        if(pTempInherit[i].AncestorName)
            nSize += StringByteSize(pTempInherit[i].AncestorName);
    }

    pTempInherit2 = (PINHERITED_FROM)LocalAlloc( LPTR, nSize );
    if(pTempInherit2 == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");
    
    pStrTemp = (LPWSTR)(pTempInherit2 + pACL->AceCount); 

    for(i = 0; i < pACL->AceCount; ++i)
    {
        pTempInherit2[i].GenerationGap = pTempInherit[i].GenerationGap;
        if(pTempInherit[i].AncestorName)
        {
            if (SUCCEEDED(pPath->Set(pTempInherit[i].AncestorName, ADS_SETTYPE_FULL)))
            {
                hr = pPath->Retrieve(ADS_FORMAT_X500_DN, &strParentPath);
            }
            
            pTempInherit2[i].AncestorName = pStrTemp;
            
            if(strParentPath)
            {
                wcscpy(pStrTemp,strParentPath);
                pStrTemp += (wcslen(pStrTemp)+1);
                SysFreeString(strParentPath);
                strParentPath = NULL;
            }
            else
            {
                wcscpy(pStrTemp,pTempInherit[i].AncestorName);
                pStrTemp += (wcslen(pTempInherit[i].AncestorName)+1);
            }
        }
    }
            

exit_gracefully:

	if(bFreeInheritFromArray)
		FreeInheritedFromArray(pTempInherit, pACL->AceCount,NULL);
    
	if(SUCCEEDED(hr))
    {        
        *ppInheritArray = pTempInherit2;
            
    }                        
    if(pTempInherit)
        LocalFree(pTempInherit);

    if(ppGuid)
        LocalFree(ppGuid);
    
    DoRelease(pPath);
    if(strObjectPath != m_strObjectPath)
        SysFreeString(strObjectPath);
    if(strServerName)
		SysFreeString(strServerName);	

    TraceLeaveResult(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   DSCreateISecurityInfoObjectEx
//
//  Synopsis:   Instantiates an ISecurityInfo interface for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  pwszServer]        --  Name/address of DS DC (optional)
//              [IN  pwszUserName]      --  User name for validation (optional)
//              [IN  pwszPassword]      --  Password for validation (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT ppSI]              --  Interface pointer returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  lpContext]         --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateISecurityInfoObjectEx(LPCWSTR pwszObjectPath,
                              LPCWSTR pwszObjectClass,
                              LPCWSTR pwszServer,
                              LPCWSTR pwszUserName,
                              LPCWSTR pwszPassword,
                              DWORD   dwFlags,
                              LPSECURITYINFO *ppSI,
                              PFNREADOBJECTSECURITY  pfnReadSD,
                              PFNWRITEOBJECTSECURITY pfnWriteSD,
                              LPARAM lpContext)
{
    HRESULT hr;
    CDSSecurityInfo* pSI = NULL;

    TraceEnter(TRACE_SECURITY, "DSCreateISecurityInfoObjectEx");

    if (pwszObjectPath == NULL || ppSI == NULL)
        TraceLeaveResult(E_INVALIDARG);

    *ppSI = NULL;

    //
    // Create and initialize the ISecurityInformation object.
    //
    pSI = new CDSSecurityInfo();      // ref == 0
    if (!pSI)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create CDSSecurityInfo object");

    pSI->AddRef();                    // ref == 1

    hr = pSI->Init(pwszObjectPath,
                   pwszObjectClass,
                   pwszServer,
                   pwszUserName,
                   pwszPassword,
                   dwFlags,
                   pfnReadSD,
                   pfnWriteSD,
                   lpContext);
    if (FAILED(hr))
    {
        DoRelease(pSI);
    }

    *ppSI = (LPSECURITYINFO)pSI;

exit_gracefully:

    TraceLeaveResult(hr);
}


STDAPI
DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
                            LPCWSTR pwszObjectClass,
                            DWORD   dwFlags,
                            LPSECURITYINFO *ppSI,
                            PFNREADOBJECTSECURITY  pfnReadSD,
                            PFNWRITEOBJECTSECURITY pfnWriteSD,
                            LPARAM lpContext)
{
    return DSCreateISecurityInfoObjectEx(pwszObjectPath,
                                         pwszObjectClass,
                                         NULL, //pwszServer,
                                         NULL, //pwszUserName,
                                         NULL, //pwszPassword,
                                         dwFlags,
                                         ppSI,
                                         pfnReadSD,
                                         pfnWriteSD,
                                         lpContext);
}


//+---------------------------------------------------------------------------
//
//  Function:   DSCreateSecurityPage
//
//  Synopsis:   Creates a Security property page for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT phPage]            --  HPROPSHEETPAGE returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  lpContext]         --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateSecurityPage(LPCWSTR pwszObjectPath,
                     LPCWSTR pwszObjectClass,
                     DWORD   dwFlags,
                     HPROPSHEETPAGE *phPage,
                     PFNREADOBJECTSECURITY  pfnReadSD,
                     PFNWRITEOBJECTSECURITY pfnWriteSD,
                     LPARAM lpContext)
{
    HRESULT hr;
    LPSECURITYINFO pSI = NULL;

    TraceEnter(TRACE_SECURITY, "DSCreateSecurityPage");

    if (NULL == phPage || NULL == pwszObjectPath || !*pwszObjectPath)
        TraceLeaveResult(E_INVALIDARG);

    *phPage = NULL;

    hr = DSCreateISecurityInfoObject(pwszObjectPath,
                                     pwszObjectClass,
                                     dwFlags,
                                     &pSI,
                                     pfnReadSD,
                                     pfnWriteSD,
                                     lpContext);
    if (SUCCEEDED(hr))
    {
        hr = _CreateSecurityPage(pSI, phPage);
        DoRelease(pSI);
    }

    TraceLeaveResult(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   DSEditSecurity
//
//  Synopsis:   Displays a modal dialog for editing security on a DS object
//
//  Arguments:  [IN  hwndOwner]         --  Dialog owner window
//              [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [IN  pwszCaption        --  Optional dialog caption
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  lpContext]         --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSEditSecurity(HWND hwndOwner,
               LPCWSTR pwszObjectPath,
               LPCWSTR pwszObjectClass,
               DWORD dwFlags,
               LPCWSTR pwszCaption,
               PFNREADOBJECTSECURITY pfnReadSD,
               PFNWRITEOBJECTSECURITY pfnWriteSD,
               LPARAM lpContext)
{
    HRESULT hr;
    LPSECURITYINFO pSI = NULL;

    TraceEnter(TRACE_SECURITY, "DSCreateSecurityPage");

    if (NULL == pwszObjectPath || !*pwszObjectPath)
        TraceLeaveResult(E_INVALIDARG);

    if (pwszCaption && *pwszCaption)
    {
        // Use the provided caption
        HPROPSHEETPAGE hPage = NULL;

        hr = DSCreateSecurityPage(pwszObjectPath,
                                  pwszObjectClass,
                                  dwFlags,
                                  &hPage,
                                  pfnReadSD,
                                  pfnWriteSD,
                                  lpContext);
        if (SUCCEEDED(hr))
        {
            PROPSHEETHEADERW psh;
            psh.dwSize = SIZEOF(psh);
            psh.dwFlags = PSH_DEFAULT;
            psh.hwndParent = hwndOwner;
            psh.hInstance = GLOBAL_HINSTANCE;
            psh.pszCaption = pwszCaption;
            psh.nPages = 1;
            psh.nStartPage = 0;
            psh.phpage = &hPage;

            PropertySheetW(&psh);
        }
    }
    else
    {
        // This method creates a caption like "Permissions for Foo"
        hr = DSCreateISecurityInfoObject(pwszObjectPath,
                                         pwszObjectClass,
                                         dwFlags,
                                         &pSI,
                                         pfnReadSD,
                                         pfnWriteSD,
                                         lpContext);
        if (SUCCEEDED(hr))
        {
            hr = _EditSecurity(hwndOwner, pSI);
            DoRelease(pSI);
        }
    }

    TraceLeaveResult(hr);
}



/*******************************************************************

    NAME:       GetLSAConnection

    SYNOPSIS:   Wrapper for LsaOpenPolicy

    ENTRY:      pszServer - the server on which to make the connection

    EXIT:

    RETURNS:    LSA_HANDLE if successful, NULL otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/

LSA_HANDLE
GetLSAConnection(LPCTSTR pszServer, DWORD dwAccessDesired)
{
    LSA_HANDLE hPolicy = NULL;
    LSA_UNICODE_STRING uszServer = {0};
    LSA_UNICODE_STRING *puszServer = NULL;
    LSA_OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;

    sqos.Length = SIZEOF(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    oa.SecurityQualityOfService = &sqos;

    if (pszServer &&
        *pszServer &&
        RtlCreateUnicodeString(&uszServer, pszServer))
    {
        puszServer = &uszServer;
    }

    LsaOpenPolicy(puszServer, &oa, dwAccessDesired, &hPolicy);

    if (puszServer)
        RtlFreeUnicodeString(puszServer);

    return hPolicy;
}

HRESULT
GetDomainSid(LPCWSTR pszServer, PSID *ppSid)
{
    HRESULT hr = S_OK;
    NTSTATUS nts = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO pDomainInfo = NULL;
    if(!pszServer || !ppSid)
        return E_INVALIDARG;

    *ppSid = NULL;

    LSA_HANDLE hLSA = GetLSAConnection(pszServer, POLICY_VIEW_LOCAL_INFORMATION);

    if (!hLSA)
    {
        hr = E_FAIL;
        goto exit_gracefully;
    }

    
    nts = LsaQueryInformationPolicy(hLSA,
                                    PolicyAccountDomainInformation,
                                    (PVOID*)&pDomainInfo);
    if(nts != STATUS_SUCCESS)
    {
        hr = E_FAIL;
        goto exit_gracefully;
    }

    if (pDomainInfo && pDomainInfo->DomainSid)
    {
        ULONG cbSid = GetLengthSid(pDomainInfo->DomainSid);

        *ppSid = (PSID) LocalAlloc(LPTR, cbSid);

        if (!*ppSid)
        {
            hr = E_OUTOFMEMORY;
            goto exit_gracefully;
        }

        CopyMemory(*ppSid, pDomainInfo->DomainSid, cbSid);
    }

exit_gracefully:
    if(pDomainInfo)
        LsaFreeMemory(pDomainInfo);          
    if(hLSA)
        LsaClose(hLSA);

    return hr;
}

//
// include and defines for ldap calls
//
#include <winldap.h>
#include <ntldap.h>

typedef LDAP * (LDAPAPI *PFN_LDAP_OPEN)( PWCHAR, ULONG );
typedef ULONG (LDAPAPI *PFN_LDAP_UNBIND)( LDAP * );
typedef ULONG (LDAPAPI *PFN_LDAP_SEARCH)(LDAP *, PWCHAR, ULONG, PWCHAR, PWCHAR *, ULONG,PLDAPControlA *, PLDAPControlA *, struct l_timeval *, ULONG, LDAPMessage **);
typedef LDAPMessage * (LDAPAPI *PFN_LDAP_FIRST_ENTRY)( LDAP *, LDAPMessage * );
typedef PWCHAR * (LDAPAPI *PFN_LDAP_GET_VALUE)(LDAP *, LDAPMessage *, PWCHAR );
typedef ULONG (LDAPAPI *PFN_LDAP_MSGFREE)( LDAPMessage * );
typedef ULONG (LDAPAPI *PFN_LDAP_VALUE_FREE)( PWCHAR * );
typedef ULONG (LDAPAPI *PFN_LDAP_MAP_ERROR)( ULONG );

HRESULT
GetRootDomainSid(LPCWSTR pszServer, PSID *ppSid)
{
    //
    // get root domain sid, save it in RootDomSidBuf (global)
    // this function is called within the critical section
    //
    // 1) ldap_open to the DC of interest.
    // 2) you do not need to ldap_connect - the following step works anonymously
    // 3) read the operational attribute rootDomainNamingContext and provide the
    //    operational control LDAP_SERVER_EXTENDED_DN_OID as defined in sdk\inc\ntldap.h.


    DWORD               Win32rc=NO_ERROR;

    HINSTANCE                   hLdapDll=NULL;
    PFN_LDAP_OPEN               pfnLdapOpen=NULL;
    PFN_LDAP_UNBIND             pfnLdapUnbind=NULL;
    PFN_LDAP_SEARCH             pfnLdapSearch=NULL;
    PFN_LDAP_FIRST_ENTRY        pfnLdapFirstEntry=NULL;
    PFN_LDAP_GET_VALUE          pfnLdapGetValue=NULL;
    PFN_LDAP_MSGFREE            pfnLdapMsgFree=NULL;
    PFN_LDAP_VALUE_FREE         pfnLdapValueFree=NULL;
    PFN_LDAP_MAP_ERROR          pfnLdapMapError=NULL;

    PLDAP                       phLdap=NULL;

    LDAPControlW    serverControls = { LDAP_SERVER_EXTENDED_DN_OID_W,
                                       { 0, NULL },
                                       TRUE
                                     };
    LPWSTR           Attribs[] = { LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W, NULL };

    PLDAPControlW   rServerControls[] = { &serverControls, NULL };
    PLDAPMessage    pMessage = NULL;
    LDAPMessage     *pEntry = NULL;
    PWCHAR           *ppszValues=NULL;

    LPWSTR           pSidStart, pSidEnd, pParse;
    BYTE            *pDest = NULL;
    BYTE            OneByte;

	DWORD RootDomSidBuf[sizeof(SID)/sizeof(DWORD)+5];

    hLdapDll = LoadLibraryA("wldap32.dll");

    if ( hLdapDll) 
	{
        pfnLdapOpen = (PFN_LDAP_OPEN)GetProcAddress(hLdapDll,
                                                    "ldap_openW");
        pfnLdapUnbind = (PFN_LDAP_UNBIND)GetProcAddress(hLdapDll,
                                                      "ldap_unbind");
        pfnLdapSearch = (PFN_LDAP_SEARCH)GetProcAddress(hLdapDll,
                                                    "ldap_search_ext_sW");
        pfnLdapFirstEntry = (PFN_LDAP_FIRST_ENTRY)GetProcAddress(hLdapDll,
                                                      "ldap_first_entry");
        pfnLdapGetValue = (PFN_LDAP_GET_VALUE)GetProcAddress(hLdapDll,
                                                    "ldap_get_valuesW");
        pfnLdapMsgFree = (PFN_LDAP_MSGFREE)GetProcAddress(hLdapDll,
                                                      "ldap_msgfree");
        pfnLdapValueFree = (PFN_LDAP_VALUE_FREE)GetProcAddress(hLdapDll,
                                                    "ldap_value_freeW");
        pfnLdapMapError = (PFN_LDAP_MAP_ERROR)GetProcAddress(hLdapDll,
                                                      "LdapMapErrorToWin32");
    }

    if ( pfnLdapOpen == NULL ||
         pfnLdapUnbind == NULL ||
         pfnLdapSearch == NULL ||
         pfnLdapFirstEntry == NULL ||
         pfnLdapGetValue == NULL ||
         pfnLdapMsgFree == NULL ||
         pfnLdapValueFree == NULL ||
         pfnLdapMapError == NULL ) 
	{

        Win32rc = ERROR_PROC_NOT_FOUND;

    } else 
	{

        //
        // bind to ldap
        //
        phLdap = (*pfnLdapOpen)((PWCHAR)pszServer, LDAP_PORT);

        if ( phLdap == NULL ) 
            Win32rc = ERROR_FILE_NOT_FOUND;
    }

    if ( NO_ERROR == Win32rc ) 
	{
        //
        // now get the ldap handle,
        //

        Win32rc = (*pfnLdapSearch)(
                        phLdap,
                        L"",
                        LDAP_SCOPE_BASE,
                        L"(objectClass=*)",
                        Attribs,
                        0,
                        (PLDAPControlA *)&rServerControls,
                        NULL,
                        NULL,
                        10000,
                        &pMessage);

        if( Win32rc == NO_ERROR && pMessage ) 
		{

            Win32rc = ERROR_SUCCESS;

            pEntry = (*pfnLdapFirstEntry)(phLdap, pMessage);

            if(pEntry == NULL) 
			{

                Win32rc = (*pfnLdapMapError)( phLdap->ld_errno );

            } else 
			{
                //
                // Now, we'll have to get the values
                //
                ppszValues = (*pfnLdapGetValue)(phLdap,
                                              pEntry,
                                              Attribs[0]);

                if( ppszValues == NULL) 
				{

                    Win32rc = (*pfnLdapMapError)( phLdap->ld_errno );

                } else if ( ppszValues[0] && ppszValues[0][0] != '\0' ) 
				{

                    //
                    // ppszValues[0] is the value to parse.
                    // The data will be returned as something like:

                    // <GUID=278676f8d753d211a61ad7e2dfa25f11>;<SID=010400000000000515000000828ba6289b0bc11e67c2ef7f>;DC=colinbrdom1,DC=nttest,DC=microsoft,DC=com

                    // Parse through this to find the <SID=xxxxxx> part.  Note that it may be missing, but the GUID= and trailer should not be.
                    // The xxxxx represents the hex nibbles of the SID.  Translate to the binary form and case to a SID.


                    pSidStart = wcsstr(ppszValues[0], L"<SID=");

                    if ( pSidStart ) 
					{
                        //
                        // find the end of this SID
                        //
                        pSidEnd = wcsstr(pSidStart, L">");

                        if ( pSidEnd ) 
						{

                            pParse = pSidStart + 5;
                            pDest = (BYTE *)RootDomSidBuf;

                            while ( pParse < pSidEnd-1 ) 
							{

                                if ( *pParse >= '0' && *pParse <= '9' ) 
								{
                                    OneByte = (BYTE) ((*pParse - '0') * 16);
                                } 
								else 
								{
                                    OneByte = (BYTE) ( (tolower(*pParse) - 'a' + 10) * 16 );
                                }

                                if ( *(pParse+1) >= '0' && *(pParse+1) <= '9' ) 
								{
                                    OneByte = OneByte + (BYTE) ( (*(pParse+1)) - '0' ) ;
                                } 
								else 
								{
                                    OneByte = OneByte + (BYTE) ( tolower(*(pParse+1)) - 'a' + 10 ) ;
                                }

                                *pDest = OneByte;
                                pDest++;
                                pParse += 2;
                            }

							ULONG cbSid = GetLengthSid((PSID)RootDomSidBuf);
							*ppSid = (PSID) LocalAlloc(LPTR, cbSid);

							if (!*ppSid)
							{
								Win32rc = ERROR_NOT_ENOUGH_MEMORY;
							}

							CopyMemory(*ppSid, (PSID)RootDomSidBuf, cbSid);
							ASSERT(IsValidSid(*ppSid));


                        } else 
						{
                            Win32rc = ERROR_OBJECT_NOT_FOUND;
                        }
                    } else 
					{
                        Win32rc = ERROR_OBJECT_NOT_FOUND;
                    }

                    (*pfnLdapValueFree)(ppszValues);

                } else 
				{
                    Win32rc = ERROR_OBJECT_NOT_FOUND;
                }
            }

            (*pfnLdapMsgFree)(pMessage);
        }

    }

    //
    // even though it's not binded, use unbind to close
    //
    if ( phLdap != NULL && pfnLdapUnbind )
        (*pfnLdapUnbind)(phLdap);

    if ( hLdapDll ) 
	{
        FreeLibrary(hLdapDll);
    }

    return HRESULT_FROM_WIN32(Win32rc);
}


BOOL 
IsRootObject(IDirectoryObject * pDirObject)
{
	if(!pDirObject)
	{
		ASSERT(pDirObject);
		return FALSE;
	}

	LPWSTR  pAttrNames[]={L"instanceType"};
	DWORD   dwNumAttr= ARRAYSIZE(pAttrNames);

	ADS_ATTR_INFO   *pAttrInfo=NULL;
	DWORD   dwReturn = 0;

	HRESULT hr = pDirObject->GetObjectAttributes( pAttrNames, 
												  dwNumAttr, 
												  &pAttrInfo, 
												  &dwReturn );

	if(FAILED(hr) || dwReturn != 1 )
		return FALSE;

	ASSERT(ADSTYPE_INTEGER == pAttrInfo->dwADsType);
	int InstanceType = pAttrInfo[0].pADsValues->Integer; 

	FreeADsMem( pAttrInfo );

	if(InstanceType & DS_INSTANCETYPE_IS_NC_HEAD)
		return TRUE;
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\dll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dll.cpp
//
//  Core entry points for the DLL
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define INITGUID
#include <initguid.h>
#include "iids.h"

/*----------------------------------------------------------------------------
/ Globals
/----------------------------------------------------------------------------*/

HINSTANCE g_hInstance = NULL;
HINSTANCE g_hAclEditDll = NULL;
DWORD     g_tls = 0xffffffffL;


/*-----------------------------------------------------------------------------
/ DllMain
/ -------
/   Main entry point.  We are passed reason codes and assored other
/   information when loaded or closed down.
/
/ In:
/   hInstance = our instance handle
/   dwReason = reason code
/   pReserved = depends on the reason code.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDAPI_(BOOL)
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*pReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        g_tls = TlsAlloc();
        DebugProcessAttach();
        TraceSetMaskFromCLSID(CLSID_DsSecurity);
#ifndef DEBUG
        DisableThreadLibraryCalls(hInstance);
#endif
        break;

    case DLL_PROCESS_DETACH:
        SchemaCache_Destroy();
        if (g_hAclEditDll)
            FreeLibrary(g_hAclEditDll);
        TlsFree(g_tls);
        DebugProcessDetach();
        break;

    case DLL_THREAD_DETACH:
        DebugThreadDetach();
        break;
    }

    return TRUE;
}


/*-----------------------------------------------------------------------------
/ DllCanUnloadNow
/ ---------------
/   Called by the outside world to determine if our DLL can be unloaded. If we
/   have any objects in existance then we must not unload.
/
/ In:
/   -
/ Out:
/   BOOL inidicate unload state.
/----------------------------------------------------------------------------*/
STDAPI
DllCanUnloadNow(void)
{
    return GLOBAL_REFCOUNT ? S_FALSE : S_OK;
}


/*-----------------------------------------------------------------------------
/ DllGetClassObject
/ -----------------
/   Given a class ID and an interface ID, return the relevant object.  This used
/   by the outside world to access the objects contained here in.
/
/ In:
/   rCLISD = class ID required
/   riid = interface within that class required
/   ppv -> receives the newly created object.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDAPI
DllGetClassObject(REFCLSID rCLSID, REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    CDsSecurityClassFactory *pClassFactory;

    TraceEnter(TRACE_CORE, "DllGetClassObject");
    TraceGUID("Object requested", rCLSID);
    TraceGUID("Interface requested", riid);

    *ppv = NULL;

    if (!IsEqualIID(rCLSID, CLSID_DsSecurity))
        ExitGracefully(hr, CLASS_E_CLASSNOTAVAILABLE, "CLSID not supported");

    pClassFactory = new CDsSecurityClassFactory;

    if (!pClassFactory)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create class factory");

    hr = pClassFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pClassFactory;           

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ WaitOnThread
/ -----------------
/   If a thread is running (if the handle is non-NULL) wait for it to complete.
/   Then set the handle to NULL.
/
/ In:
/   phThread = address of thread handle
/
/ Out:
/   Result of WaitForSingleObject, or zero.
/----------------------------------------------------------------------------*/
DWORD
WaitOnThread(HANDLE *phThread)
{
    DWORD dwResult = 0;

    if (phThread != NULL && *phThread != NULL)
    {
        HCURSOR hcurPrevious = SetCursor(LoadCursor(NULL, IDC_WAIT));

        SetThreadPriority(*phThread, THREAD_PRIORITY_HIGHEST);

        dwResult = WaitForSingleObject(*phThread, INFINITE);

        CloseHandle(*phThread);
        *phThread = NULL;

        SetCursor(hcurPrevious);
    }

    return dwResult;
}


/*-----------------------------------------------------------------------------
/ Thread Local Storage helpers
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ ThreadCoInitialize
/ ------------------
/   There is some thread local storage that indicates if we have called
/   CoInitialize.  If CoInitialize has not yet been called, call it now.
/   Otherwise, do nothing.
/
/ In:
/   -
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT
ThreadCoInitialize(void)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_CORE, "ThreadCoInitialize");

    if (!TlsGetValue(g_tls))
    {
        TraceMsg("Calling CoInitialize");
        hr = CoInitialize(NULL);
        TlsSetValue(g_tls, (LPVOID)SUCCEEDED(hr));
    }

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ ThreadCoUninitialize
/ ------------------
/   There is some thread local storage that indicates if we have called
/   CoInitialize.  If CoInitialize has been called, call CoUninitialize now.
/   Otherwise, do nothing.
/
/ In:
/   -
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

void
ThreadCoUninitialize(void)
{
    TraceEnter(TRACE_CORE, "ThreadCoUninitialize");

    if (TlsGetValue(g_tls))
    {
        TraceMsg("Calling CoUninitialize");
        CoUninitialize();
        TlsSetValue(g_tls, NULL);
    }

    TraceLeaveVoid();
}


//
// Wrappers for delay-loading aclui.dll
//
char const c_szCreateSecurityPage[] = "CreateSecurityPage";
char const c_szEditSecurity[] = "EditSecurity";
typedef HPROPSHEETPAGE (WINAPI *PFN_CREATESECPAGE)(LPSECURITYINFO);
typedef BOOL (WINAPI *PFN_EDITSECURITY)(HWND, LPSECURITYINFO);

HRESULT
_CreateSecurityPage(LPSECURITYINFO pSI, HPROPSHEETPAGE *phPage)
{
    HRESULT hr = E_FAIL;

    if (NULL == g_hAclEditDll)
        g_hAclEditDll = LoadLibrary(c_szAclUI);

    if (g_hAclEditDll)
    {
        static PFN_CREATESECPAGE s_pfnCreateSecPage = NULL;

        if (NULL == s_pfnCreateSecPage)
            s_pfnCreateSecPage = (PFN_CREATESECPAGE)GetProcAddress(g_hAclEditDll, c_szCreateSecurityPage);

        if (s_pfnCreateSecPage)
        {
            hr = S_OK;

            *phPage = (*s_pfnCreateSecPage)(pSI);

            if (NULL == *phPage)
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT
_EditSecurity(HWND hwndOwner, LPSECURITYINFO pSI)
{
    HRESULT hr = E_FAIL;

    if (NULL == g_hAclEditDll)
        g_hAclEditDll = LoadLibrary(c_szAclUI);

    if (g_hAclEditDll)
    {
        static PFN_EDITSECURITY s_pfnEditSecurity = NULL;

        if (NULL == s_pfnEditSecurity)
            s_pfnEditSecurity = (PFN_EDITSECURITY)GetProcAddress(g_hAclEditDll, c_szEditSecurity);

        if (s_pfnEditSecurity)
        {
            hr = S_OK;
            (*s_pfnEditSecurity)(hwndOwner, pSI);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\exnc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       exnc.h
//
// Specific Non-Canonical Test
//
// Test if a Security Descriptor contains an ACL with non-Canonical ACEs
//
// Created by: Marcelo Calbucci (MCalbu)
//             June 23rd, 1999.
//
//--------------------------------------------------------------------------

#ifndef __EXNC_H__
#define __EXNC_H__

#include <windows.h>
#include <ntdsapi.h>

//
// IsSpecificNonCanonical Results:
//
// ENC_RESULT_NOT_PRESENT: This is not an Specific Non-Canonical SD.
//                         (It still can be a Canonical SD)
// ENC_RESULT_HIDEMEMBER : We have the Non-Canonical part referent to HideMembership
// ENC_RESULT_HIDEOBJECT : We have the Non-Canonical part referent to HideFromAB
// ENC_RESULT_ALL        : We have both Non-Canonical parts, HideMembership and HideFromAB
#define ENC_RESULT_NOT_PRESENT	0x0
#define ENC_RESULT_HIDEMEMBER	0x1
#define ENC_RESULT_HIDEOBJECT	0x2
#define ENC_RESULT_ALL		(ENC_RESULT_HIDEMEMBER | ENC_RESULT_HIDEOBJECT)

#define ENC_MINIMUM_ALLOWED	0x1
//
// IsSpecificNonCanonicalSD
DWORD IsSpecificNonCanonicalSD(PSECURITY_DESCRIPTOR pSD);

#define NT_RIGHT_MEMBER		{0xbf9679c0, 0x0de6, 0x11d0, {0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2}}

PSID GetAccountSid(LPCTSTR szServer, LPCTSTR szUsername);
BOOL ENCCompareSids(PSID pSid, LPVOID lpAce);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.cpp
//
//  Constant strings used by this app
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

TCHAR const c_szDllName[]           = TEXT("dssec.dll");
TCHAR const c_szNetApi32[]          = TEXT("NetApi32.dll");
TCHAR const c_szAclUI[]             = TEXT("aclui.dll");
WCHAR const c_szFilterFile[]        = L"dssec.dat";
WCHAR const c_szClassKey[]          = L"@";
WCHAR const c_szGUIDFormat[]        = L"{%s}";
WCHAR const c_szClassFilter[]       = L"(objectClass=classSchema)";
WCHAR const c_szPropertyFilter[]    = L"(objectClass=attributeSchema)";
WCHAR const c_szERFilterFormat[]    = L"(&(objectClass=controlAccessRight)(appliesTo=%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x))";
WCHAR const c_szLDAPDisplayName[]   = L"lDAPDisplayName";
WCHAR const c_szDisplayName[]       = L"displayName";
WCHAR const c_szDisplayID[]         = L"localizationDisplayId";
WCHAR const c_szValidAccesses[]     = L"validAccesses";
WCHAR const c_szSchemaIDGUID[]      = L"schemaIDGUID";
WCHAR const c_szRightsGuid[]        = L"rightsGuid";
WCHAR const c_szSDProperty[]        = L"nTSecurityDescriptor";
WCHAR const c_szSDRightsProp[]      = L"sDRightsEffective";
WCHAR const c_szSchemaContext[]     = L"schemaNamingContext";
WCHAR const c_szConfigContext[]     = L"configurationNamingContext";
WCHAR const c_szERContainer[]       = L"CN=Extended-Rights";
WCHAR const c_szRootDsePath[]       = L"LDAP://rootdse";
WCHAR const c_szPathFormat[]        = L"LDAP://%s";
WCHAR const c_szCNFormat[]          = L"CN=%s";
WCHAR const c_szDefaultSchemaSD[]   = L"defaultSecurityDescriptor";
WCHAR const c_szAttributeSecurityGuid[] = L"attributeSecurityGUID";
WCHAR const c_szObjectClass[] = L"objectclass";
WCHAR const c_szStructuralObjectClass[] = L"structuralobjectclass";
WCHAR const c_szObjectClassCategory[]    = L"objectClassCategory";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\exnc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       exnc.cpp
//
// Specific Non-Canonical Test
//
// Test if a Security Descriptor contains an ACL with non-Canonical ACEs
//
// Created by: Marcelo Calbucci (MCalbu)
//             June 23rd, 1999.
//
//--------------------------------------------------------------------------

#include "pch.h"
extern "C" {
#include <seopaque.h>   // RtlObjectAceSid, etc.
}
#include "exnc.h"

static const GUID guidMember = NT_RIGHT_MEMBER;


//
// ENCCompareSids
// Compare if pSid is the same SID inside pAce.
//
BOOL ENCCompareSids(PSID pSid, PACE_HEADER pAce)
{
    if (!pAce)
        return FALSE;

    PSID pSid2 = NULL;

    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        pSid2 = RtlObjectAceSid(pAce);
        break;

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
        pSid2 = (PSID)&((PKNOWN_ACE)pAce)->SidStart;
        break;

    default:
        return FALSE;
    }

    return (pSid && pSid2 && EqualSid(pSid, pSid2));
}


//
// IsSpecificNonCanonicalSD
// This function verifies if the Security Descriptor (*pSD) it is or not in the
// specific non-canonical format.
// Parameters:
//    pSD: The Security Descriptor to be analyzed
// Result:
//    ENC_RESULT_NOT_PRESENT: This is not a Specific Non-Canonical SD.
//                            (It still can be a Canonical SD)
//    ENC_RESULT_HIDEMEMBER : We have the Non-Canonical part referent to HideMembership
//    ENC_RESULT_HIDEOBJECT : We have the Non-Canonical part referent to HideFromAB
//    ENC_RESULT_ALL        : We have both Non-Canonical parts, HideMembership and HideFromAB
//
DWORD IsSpecificNonCanonicalSD(PSECURITY_DESCRIPTOR pSD)
{
    // Check the Security Descriptor
    if(pSD==NULL)
        return FALSE;
    if(!IsValidSecurityDescriptor(pSD))
        return FALSE;

    // Get and Check the DACL
    PACL pDacl = NULL;
    BOOL fDaclPresent, fDaclDefaulted;
    if(!GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pDacl, &fDaclDefaulted))
        return FALSE;
    if(!fDaclPresent)
        return FALSE;
    if(!pDacl)
        return FALSE;

    // Do a lazy evaluation:
    //    If we have less than 4 ACEs, this is not a Specific Non-Canonical ACL
    if (pDacl->AceCount < 4)
        return FALSE;

    //
    // Check if the "member" or "list object" are in the Non-Canonical format
    //

    // Info (flags): Count how many alloweds we have
    DWORD dwInfoMember = 0;
    DWORD dwInfoListObject = 0;
    
    // Get the Sids...
    SID sidEveryone;    // SID contains 1 subauthority, which is enough

    // -1 = Unknown
    // 0 = Not Present
    // 1 = Present
    int iMemberResult = -1;
    int iListObjectResult = -1;

    //  # Everyone
    SID_IDENTIFIER_AUTHORITY siaNtAuthority1 = SECURITY_WORLD_SID_AUTHORITY;
    InitializeSid(&sidEveryone, &siaNtAuthority1, 1);
    *(GetSidSubAuthority(&sidEveryone, 0)) = SECURITY_WORLD_RID;

    DWORD dwCurAce;
    PACE_HEADER pAce;

    for (dwCurAce = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
         dwCurAce < pDacl->AceCount;
         dwCurAce++, pAce = (PACE_HEADER)NextAce(pAce))
    {
        // Test the "member"
        if (-1 == iMemberResult && IsObjectAceType(pAce))
        {
            const GUID *pObjectType = RtlObjectAceObjectType(pAce);
            if (pObjectType && (guidMember == *pObjectType))
            {
                switch(pAce->AceType)
                {
                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                    dwInfoMember++;
                    break;

                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                    if (ENCCompareSids(&sidEveryone, pAce))
                    {
                        if (dwInfoMember >= ENC_MINIMUM_ALLOWED)
                            iMemberResult = 1;
                        else
                            iMemberResult = 0;

                        if (-1 != iListObjectResult)
                            dwCurAce = pDacl->AceCount; // Quit the loop
                    }
                    break;
                }
            }
        }

        // Test the "list object"
        if (-1 == iListObjectResult &&
            ACTRL_DS_LIST_OBJECT == ((PKNOWN_ACE)pAce)->Mask)
        {
            switch(pAce->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                dwInfoListObject++;
                break;

            case ACCESS_DENIED_ACE_TYPE:
                if (ENCCompareSids(&sidEveryone, pAce))
                {
                    if (dwInfoListObject >= ENC_MINIMUM_ALLOWED)
                        iListObjectResult = 1;
                    else
                        iListObjectResult = 0;

                    if (-1 != iMemberResult)
                        dwCurAce = pDacl->AceCount; // Quit the loop
                }
                break;
            }
        }
    }

    DWORD dwResult = 0;

    if (iMemberResult == 1)
        dwResult |= ENC_RESULT_HIDEMEMBER;

    if (iListObjectResult == 1)
        dwResult |= ENC_RESULT_HIDEOBJECT;

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef _pch_h
#define _pch_h

// Headers etc

#ifndef UNICODE
#error "No ANSI support yet"
#endif

extern "C"
{
    #include <nt.h>         // SE_TAKE_OWNERSHIP_PRIVILEGE, etc
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <seopaque.h>

}

#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <atlconv.h>        // ANSI/Unicode conversion support
#include <shlobj.h>
#include <shlwapi.h>        // StrStr
#include <comctrlp.h>       // DPA/DSA
#include <lmcons.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <activeds.h>
#include <winldap.h>
#include <aclapi.h>
#include <aclui.h>

#include <common.h>
#include <dsclient.h>

#include "resource.h"
#include "iids.h"
#include "cstrings.h"

#include "dll.h"

extern "C"
{
    #include "authz.h"
}

#include "schema.h"
#include "security.h"

#define MAX_TYPENAME_LENGTH     64

// Magic debug flags
#define TRACE_CORE          0x00000001
#define TRACE_SECURITY      0x00000002
#define TRACE_DSSI          0x00000004
#define TRACE_SCHEMA        0x00000008
#define TRACE_SCHEMACLASS   0x00000010
#define TRACE_SCHEMAPROP    0x00000020
#define TRACE_ALWAYS        0xffffffff          // use with caution

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\schema.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       schema.h
//
//--------------------------------------------------------------------------

#ifndef _SCHEMA_CACHE_H_
#define _SCHEMA_CACHE_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Generic Mapping for DS, adapted from \nt\private\ds\src\inc\permit.h
//
#define DS_GENERIC_READ         ((STANDARD_RIGHTS_READ)     | \
                                 (ACTRL_DS_LIST)            | \
                                 (ACTRL_DS_READ_PROP)       | \
                                 (ACTRL_DS_LIST_OBJECT))

#define DS_GENERIC_EXECUTE      ((STANDARD_RIGHTS_EXECUTE)  | \
                                 (ACTRL_DS_LIST))

// Note, STANDARD_RIGHTS_WRITE is specifically NOT included here
#define DS_GENERIC_WRITE        ((ACTRL_DS_SELF)            | \
                                 (ACTRL_DS_WRITE_PROP))

#define DS_GENERIC_ALL          ((STANDARD_RIGHTS_REQUIRED) | \
                                 (ACTRL_DS_CREATE_CHILD)    | \
                                 (ACTRL_DS_DELETE_CHILD)    | \
                                 (ACTRL_DS_DELETE_TREE)     | \
                                 (ACTRL_DS_READ_PROP)       | \
                                 (ACTRL_DS_WRITE_PROP)      | \
                                 (ACTRL_DS_LIST)            | \
                                 (ACTRL_DS_LIST_OBJECT)     | \
                                 (ACTRL_DS_CONTROL_ACCESS)  | \
                                 (ACTRL_DS_SELF))

//
// Flags for SchemaCache_Get****ID
//
#define IDC_CLASS_NO_CREATE     0x00000001
#define IDC_CLASS_NO_DELETE     0x00000002
#define IDC_CLASS_NO_INHERIT    0x00000004
#define IDC_PROP_NO_READ        IDC_CLASS_NO_CREATE
#define IDC_PROP_NO_WRITE       IDC_CLASS_NO_DELETE
#define OTL_ADDED_TO_LIST       0x00000008

#define IDC_CLASS_NONE          (IDC_CLASS_NO_CREATE | IDC_CLASS_NO_DELETE | IDC_CLASS_NO_INHERIT)
#define IDC_PROP_NONE           (IDC_PROP_NO_READ | IDC_PROP_NO_WRITE)

#define SCHEMA_COMMON_PERM      0x80000000
#define SCHEMA_NO_FILTER        0x40000000
#define SCHEMA_CLASS            0x20000000


//
//Purpose: Used to store information about aux class
//
typedef struct _AUX_INFO{
    GUID    guid;                       //Object Type Guid of class
    WCHAR pszClassName[ANYSIZE_ARRAY];  //class Name
}AUX_INFO, *PAUX_INFO;

//
//Purpose: Used to cache Access information passed to get access right
//
typedef struct _ACCESS_INFO{
    GUID ObjectTypeGuid;
    DWORD dwFlags;
    BOOL bLocalFree;
    PSI_ACCESS pAccess;
    ULONG cAccesses;
    ULONG iDefaultAccess;
}ACCESS_INFO, *PACCESS_INFO;

HRESULT SchemaCache_Create(LPCTSTR pszServer);
void SchemaCache_Destroy(void);

HRESULT SchemaCache_GetInheritTypes(LPCGUID pguidObjectType,
                                    DWORD dwFlags,
                                    PSI_INHERIT_TYPE *ppInheritTypes,
                                    ULONG *pcInheritTypes);
HRESULT SchemaCache_GetAccessRights(LPCGUID pguidObjectType,
                                    LPCTSTR pszClassName,   // optional (faster if provided)
                                    HDPA    hAuxList,
                                    LPCTSTR pszSchemaPath,
                                    DWORD dwFlags,  // 0, SI_ADVANCED, or SI_ADVANCED | SI_EDIT_PROPERTIES
                                    PACCESS_INFO* ppAccesInfo);

HRESULT Schema_BindToObject(LPCTSTR pszSchemaPath,
                            LPCTSTR pszName,
                            REFIID riid,
                            LPVOID *ppv);
HRESULT Schema_GetObjectID(IADs *pObj, LPGUID pGUID);

HRESULT Schema_GetDefaultSD( GUID *pSchemaGuid,
                             PSID pDomainSid,
							 PSID pRootDomainSid,
                             PSECURITY_DESCRIPTOR *ppSD = NULL );

HRESULT Schema_GetObjectTypeList(GUID *pSchamaGuid,
                                 HDPA hAuxList,
                                 LPCWSTR pszSchemaPath,
                                 DWORD dwFlags,
                                 POBJECT_TYPE_LIST *ppObjectTypeList, 
                                 DWORD * pObjectTypeListCount);

HRESULT Schema_GetObjectTypeGuid(LPCWSTR pszClassName, LPGUID pGuid);

AUTHZ_RESOURCE_MANAGER_HANDLE Schema_GetAUTHZ_RM();

bool DoesPathContainServer(LPCWSTR pszPath);
HRESULT OpenDSObject (LPTSTR lpPath, LPTSTR lpUserName, LPTSTR lpPassword, DWORD dwFlags, REFIID riid, void FAR * FAR * ppObject);


void
DestroyDPA(HDPA hList);

#ifdef __cplusplus
}
#endif

#endif  // _SCHEMA_CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_SECURITY                    0
#define IDS_SECURITYHELP                1
#define IDS_NO_ACCESS                   2
#define IDS_DS_CONTAINER_ONLY           3
#define IDS_DS_CONTAINER_SUBITEMS       4
#define IDS_DS_SUBITEMS_ONLY            5
#define IDS_DS_INHERIT_TYPE             6
#define IDS_DS_CREATE_CHILD_TYPE        7
#define IDS_DS_DELETE_CHILD_TYPE        8
#define IDS_DS_READ_PROP_TYPE           9
#define IDS_DS_WRITE_PROP_TYPE          10
#define IDS_DS_READWRITE_TYPE           11
#define IDS_DS_CREATEDELETE_TYPE        12
#define IDS_SPECIAL_SECURITY_TITLE      14
#define IDS_SPECIAL_ACL_WARNING         15
#define IDS_ACTRL_DELETE                16
#define IDS_ACTRL_READ_CONTROL          17
#define IDS_ACTRL_CHANGE_ACCESS         18
#define IDS_ACTRL_CHANGE_OWNER          19
#define IDS_ACTRL_DS_CREATE_CHILD       20
#define IDS_ACTRL_DS_DELETE_CHILD       21
#define IDS_ACTRL_DS_LIST               22
#define IDS_ACTRL_DS_SELF               23
#define IDS_ACTRL_DS_READ_PROP          24
#define IDS_ACTRL_DS_WRITE_PROP         25
#define IDS_ACTRL_DS_DELETE_TREE        26
#define IDS_ACTRL_DS_LIST_OBJECT        27
#define IDS_ACTRL_DS_CONTROL_ACCESS     28
#define IDS_DS_GENERIC_READ             32
#define IDS_DS_GENERIC_WRITE            33
#define IDS_DS_GENERIC_EXECUTE          34
#define IDS_DS_GENERIC_ALL              35
#define IDS_ACTRL_DS_READ_WRITE_PROP    36
#define IDS_ACTRL_DS_CREATE_DELETE_CHILD 37

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        126
#define _APS_NEXT_COMMAND_VALUE         40008
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\schema.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       schema.cpp
//
//  This file contains the implementation of the Schema Cache
//
//--------------------------------------------------------------------------

#include "pch.h"
#include "sddl.h"
#include "sddlp.h"
#include "AdsOpenFlags.h"

//
// CSchemaCache object definition
//
#include "schemap.h"

PSCHEMACACHE g_pSchemaCache = NULL;


//
// Page size used for paging query result sets (better performance)
//
#define PAGE_SIZE       16

//
// The following array defines the permission names for DS objects.
//
SI_ACCESS g_siDSAccesses[] =
{
    { &GUID_NULL, DS_GENERIC_ALL,           MAKEINTRESOURCE(IDS_DS_GENERIC_ALL),        SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DS_GENERIC_READ,          MAKEINTRESOURCE(IDS_DS_GENERIC_READ),       SI_ACCESS_GENERAL },
    { &GUID_NULL, DS_GENERIC_WRITE,         MAKEINTRESOURCE(IDS_DS_GENERIC_WRITE),      SI_ACCESS_GENERAL },
    { &GUID_NULL, ACTRL_DS_LIST,            MAKEINTRESOURCE(IDS_ACTRL_DS_LIST),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_LIST_OBJECT,     MAKEINTRESOURCE(IDS_ACTRL_DS_LIST_OBJECT),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_READ_PROP,       MAKEINTRESOURCE(IDS_ACTRL_DS_READ_PROP),    SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { &GUID_NULL, ACTRL_DS_WRITE_PROP,      MAKEINTRESOURCE(IDS_ACTRL_DS_WRITE_PROP),   SI_ACCESS_SPECIFIC | SI_ACCESS_PROPERTY },
    { &GUID_NULL, ACTRL_DS_WRITE_PROP|ACTRL_DS_READ_PROP, MAKEINTRESOURCE(IDS_ACTRL_DS_READ_WRITE_PROP),   },
    { &GUID_NULL, DELETE,                   MAKEINTRESOURCE(IDS_ACTRL_DELETE),          SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_DELETE_TREE,     MAKEINTRESOURCE(IDS_ACTRL_DS_DELETE_TREE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,             MAKEINTRESOURCE(IDS_ACTRL_READ_CONTROL),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                MAKEINTRESOURCE(IDS_ACTRL_CHANGE_ACCESS),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,              MAKEINTRESOURCE(IDS_ACTRL_CHANGE_OWNER),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                        MAKEINTRESOURCE(IDS_NO_ACCESS),             0 },
    { &GUID_NULL, ACTRL_DS_SELF,            MAKEINTRESOURCE(IDS_ACTRL_DS_SELF),         SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_CONTROL_ACCESS,  MAKEINTRESOURCE(IDS_ACTRL_DS_CONTROL_ACCESS),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_CREATE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_CREATE_CHILD), SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_DELETE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_DELETE_CHILD), SI_ACCESS_CONTAINER | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACTRL_DS_DELETE_CHILD|ACTRL_DS_CREATE_CHILD,    MAKEINTRESOURCE(IDS_ACTRL_DS_CREATE_DELETE_CHILD), 0 },  //This won't show up as checkbox but used to display in advanced page.
};
#define g_iDSRead       1   // DS_GENERIC_READ
#define g_iDSListObject 4   // ACTRL_DS_LIST_OBJECT
#define g_iDSProperties 5   // Read/Write properties
#define g_iDSDefAccess  g_iDSRead
#define g_iDSAllExtRights 15
#define g_iDSAllValRights 14
#define g_iDSDeleteTree	  9


//
// The following array defines the inheritance types common to all DS containers.
//
SI_INHERIT_TYPE g_siDSInheritTypes[] =
{
    { &GUID_NULL, 0,                                        MAKEINTRESOURCE(IDS_DS_CONTAINER_ONLY)     },
    { &GUID_NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_DS_CONTAINER_SUBITEMS) },
    { &GUID_NULL, CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, MAKEINTRESOURCE(IDS_DS_SUBITEMS_ONLY)      },
};

//
//Used to store some temp info
//
typedef struct _temp_info
{
    LPCGUID pguid;
    DWORD   dwFilter;
    LPCWSTR pszLdapName;
    WCHAR   szDisplayName[ANYSIZE_ARRAY];
} TEMP_INFO, *PTEMP_INFO;


//
// Helper functions for cleaning up DPA lists
//
int CALLBACK
_LocalFreeCB(LPVOID pVoid, LPVOID /*pData*/)
{
    LocalFree(pVoid);
    return 1;
}

void
DestroyDPA(HDPA hList)
{
    if (hList != NULL)
        DPA_DestroyCallback(hList, _LocalFreeCB, 0);
}
//
// Callback function for merging. Passed to DPA_Merge
//
LPVOID CALLBACK _Merge(UINT , LPVOID pvDest, LPVOID , LPARAM )
{
    return pvDest;
}

BSTR
GetFilterFilePath(void)
{
	 //NTRAID#NTBUG9-577753-2002/04/01-hiteshr
    WCHAR szFilterFile[MAX_PATH+1];
    UINT cch = GetSystemDirectory(szFilterFile, ARRAYSIZE(szFilterFile));
    if (0 == cch || cch >= ARRAYSIZE(szFilterFile))
        return NULL;
    if (szFilterFile[cch-1] != L'\\')
	 {
		 if(FAILED(StringCchCat(szFilterFile,ARRAYSIZE(szFilterFile),L"\\")))
			 return NULL;
	 }

	 if(SUCCEEDED(StringCchCat(szFilterFile,ARRAYSIZE(szFilterFile), c_szFilterFile)))
		return SysAllocString(szFilterFile);
	 else
		return NULL;
}


//
// Local prototypes
//
HRESULT
Schema_Search(LPWSTR pszSchemaSearchPath,
              LPCWSTR pszFilter,
              HDPA *phCache,
              BOOL bProperty);

//
// C wrappers for the schema cache object
//
HRESULT
SchemaCache_Create(LPCWSTR pszServer)
{
    HRESULT hr = S_OK;

    if (g_pSchemaCache == NULL)
    {
        g_pSchemaCache = new CSchemaCache(pszServer);

        if (g_pSchemaCache  == NULL)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


void
SchemaCache_Destroy(void)
{
    delete g_pSchemaCache;
    g_pSchemaCache = NULL;
}


HRESULT
SchemaCache_GetInheritTypes(LPCGUID pguidObjectType,
                            DWORD dwFlags,
                            PSI_INHERIT_TYPE *ppInheritTypes,
                            ULONG *pcInheritTypes)
{
    HRESULT hr = E_UNEXPECTED;

    if (g_pSchemaCache)
        hr = g_pSchemaCache->GetInheritTypes(pguidObjectType, dwFlags, ppInheritTypes, pcInheritTypes);

    return hr;
}


HRESULT
SchemaCache_GetAccessRights(LPCGUID pguidObjectType,
                            LPCWSTR pszClassName,
                            HDPA     hAuxList,
                            LPCWSTR pszSchemaPath,
                            DWORD dwFlags,
                            PACCESS_INFO* ppAccesInfo)
{
    HRESULT hr = E_UNEXPECTED;

    if (g_pSchemaCache)
        hr = g_pSchemaCache->GetAccessRights(pguidObjectType,
                                             pszClassName,
                                             hAuxList,
                                             pszSchemaPath,
                                             dwFlags,
                                             ppAccesInfo);
    return hr;
}


HRESULT
Schema_GetDefaultSD( GUID *pSchemaIdGuid,
                     PSID pDomainSid,
					 PSID pRootDomainSid,
                     PSECURITY_DESCRIPTOR *ppSD )
{
    HRESULT hr = E_UNEXPECTED;
    if( g_pSchemaCache )
        hr = g_pSchemaCache->GetDefaultSD(pSchemaIdGuid, 
										  pDomainSid, 
										  pRootDomainSid, 
										  ppSD);

    return hr;

}


HRESULT Schema_GetObjectTypeList(GUID *pSchamaGuid,
                                 HDPA hAuxList,
                                 LPCWSTR pszSchemaPath,
                                 DWORD dwFlags,
                                 POBJECT_TYPE_LIST *ppObjectTypeList, 
                                 DWORD * pObjectTypeListCount)
{
    HRESULT hr = E_UNEXPECTED;
    if( g_pSchemaCache )
        hr = g_pSchemaCache->GetObjectTypeList( pSchamaGuid,
                                                hAuxList,
                                                pszSchemaPath,
                                                dwFlags,
                                                ppObjectTypeList, 
                                                pObjectTypeListCount);

    return hr;

}


HRESULT Schema_GetObjectTypeGuid(LPCWSTR pszClassName, LPGUID pGuid)
{
   
    if( g_pSchemaCache )
        return g_pSchemaCache->LookupClassID(pszClassName, pGuid);
    else
        return E_UNEXPECTED;
}

AUTHZ_RESOURCE_MANAGER_HANDLE Schema_GetAUTHZ_RM()
{
    if( g_pSchemaCache )
        return g_pSchemaCache->GetAuthzRM();

    return NULL;
}

//
// DPA comparison functions used for sorting and searching the cache lists
//
int CALLBACK
Schema_CompareLdapName(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    int nResult = 0;
    PID_CACHE_ENTRY pEntry1 = (PID_CACHE_ENTRY)p1;
    PID_CACHE_ENTRY pEntry2 = (PID_CACHE_ENTRY)p2;
    LPCWSTR pszFind = (LPCWSTR)lParam;

    if (pEntry1)
        pszFind = pEntry1->szLdapName;

    if (pszFind && pEntry2)
    {
        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 pszFind,
                                 -1,
                                 pEntry2->szLdapName,
                                 -1) - CSTR_EQUAL;
    }

    return nResult;
}


//
// Callback function used to sort based on display name
//
int CALLBACK
Schema_CompareTempDisplayName(LPVOID p1, LPVOID p2, LPARAM )
{
    int nResult = 0;
    PTEMP_INFO pti1 = (PTEMP_INFO)p1;
    PTEMP_INFO pti2 = (PTEMP_INFO)p2;

    if (pti1 && pti2)
    {
        LPCWSTR psz1 = pti1->szDisplayName;
        LPCWSTR psz2 = pti2->szDisplayName;

        if (!*psz1)
            psz1 = pti1->pszLdapName;
        if (!*psz2)
            psz2 = pti2->pszLdapName;

        // Note that we are sorting backwards
        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 (LPCWSTR)psz2,
                                 -1,
                                 (LPCWSTR)psz1,
                                 -1) - CSTR_EQUAL;
    }

    return nResult;
}

//
// Callback function used to sort based on display name
//
int CALLBACK
Schema_ComparePropDisplayName(LPVOID p1, LPVOID p2, LPARAM )
{
    int nResult = 0;
    PPROP_ENTRY pti1 = (PPROP_ENTRY)p1;
    PPROP_ENTRY pti2 = (PPROP_ENTRY)p2;

    if (pti1 && pti2)
    {
        LPCWSTR psz1 = pti1->szName;
        LPCWSTR psz2 = pti2->szName;

        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 (LPCWSTR)psz1,
                                 -1,
                                 (LPCWSTR)psz2,
                                 -1) - CSTR_EQUAL;
    }

    return nResult;
}

//
// DPA comparison function used for sorting the Extended Rights list
//
int CALLBACK
Schema_CompareER(LPVOID p1, LPVOID p2, LPARAM /*lParam*/)
{
    int nResult = 0;
    PER_ENTRY pEntry1 = (PER_ENTRY)p1;
    PER_ENTRY pEntry2 = (PER_ENTRY)p2;

    if (pEntry1 && pEntry2)
    {
        nResult = CompareStringW(LOCALE_USER_DEFAULT,
                                 0,
                                 pEntry1->szName,
                                 -1,
                                 pEntry2->szName,
                                 -1) - CSTR_EQUAL;

    }

    return nResult;
}



//
// CSchemaCache object implementation
//
CSchemaCache::CSchemaCache(LPCWSTR pszServer)
{
    HRESULT hr;
    IADsPathname *pPath = NULL;
    BSTR strRootDSEPath = NULL;
    IADs *pRootDSE = NULL;
    VARIANT var = {0};
    DWORD dwThreadID;
    HANDLE ahWait[2];
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::CSchemaCache");

    // Initialize everything
    ZeroMemory(this, sizeof(CSchemaCache));
    m_hrClassResult = E_UNEXPECTED;
    m_hrPropertyResult = E_UNEXPECTED;
    m_nDsListObjectEnforced = -1;        
    m_hLoadLibPropWaitEvent = NULL;
    m_hLoadLibClassWaitEvent = NULL;

    m_AICommon.pAccess = g_siDSAccesses;    
    m_AICommon.cAccesses = ARRAYSIZE(g_siDSAccesses);
    m_AICommon.iDefaultAccess = g_iDSDefAccess; 
    m_AICommon.bLocalFree = FALSE;


    m_hClassCache = NULL;
    m_hPropertyCache = NULL;    
    m_pInheritTypeArray = NULL;
    m_hObjectTypeCache = NULL;
    m_hAccessInfoCache = NULL;

    ExceptionPropagatingInitializeCriticalSection(&m_ObjectTypeCacheCritSec);

    
    if (pszServer && !*pszServer)
        pszServer = NULL;

    // Create a path object for manipulating ADS paths
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pPath);
    FailGracefully(hr, "Unable to create ADsPathname object");

    // Build RootDSE path with server
    hr = pPath->Set(AutoBstr(c_szRootDsePath), ADS_SETTYPE_FULL);
    FailGracefully(hr, "Unable to initialize path object");
    if (pszServer)
    {
        hr = pPath->Set(AutoBstr(pszServer), ADS_SETTYPE_SERVER);
        FailGracefully(hr, "Unable to initialize path object");
    }
    hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &strRootDSEPath);
    FailGracefully(hr, "Unable to retrieve RootDSE path from path object");

    // Bind to the RootDSE object
    hr = OpenDSObject(strRootDSEPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION,
                       IID_IADs,
                       (LPVOID*)&pRootDSE);
    if (FAILED(hr) && pszServer)
    {
        // Try again with no server
        SysFreeString(strRootDSEPath);

        hr = pPath->Retrieve(ADS_FORMAT_WINDOWS_NO_SERVER, &strRootDSEPath);
        FailGracefully(hr, "Unable to retrieve RootDSE path from path object");

        hr = OpenDSObject(strRootDSEPath,
                           NULL,
                           NULL,
                           ADS_SECURE_AUTHENTICATION,
                           IID_IADs,
                           (LPVOID*)&pRootDSE);
    }
    FailGracefully(hr, "Failed to bind to root DSE");

    // Build the schema root path
    hr = pRootDSE->Get(AutoBstr(c_szSchemaContext), &var);
    FailGracefully(hr, "Unable to get schema naming context");

    TraceAssert(V_VT(&var) == VT_BSTR);
    hr = pPath->Set(V_BSTR(&var), ADS_SETTYPE_DN);
    FailGracefully(hr, "Unable to initialize path object");

    hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &m_strSchemaSearchPath);
    FailGracefully(hr, "Unable to retrieve schema search path from path object");

    // Build the Extended Rights container path
    VariantClear(&var);
    hr = pRootDSE->Get(AutoBstr(c_szConfigContext), &var);
    FailGracefully(hr, "Unable to get configuration naming context");

    TraceAssert(V_VT(&var) == VT_BSTR);
    hr = pPath->Set(V_BSTR(&var), ADS_SETTYPE_DN);
    FailGracefully(hr, "Unable to initialize path object");

    hr = pPath->AddLeafElement(AutoBstr(c_szERContainer));
    FailGracefully(hr, "Unable to build Extended Rights path");

    hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &m_strERSearchPath);
    FailGracefully(hr, "Unable to retrieve Extended Rights search path from path object");
    
    //Create the Events
    m_hLoadLibPropWaitEvent = CreateEvent(NULL,
                                          TRUE,
                                          FALSE,
                                          NULL );
    m_hLoadLibClassWaitEvent = CreateEvent(NULL,
                                          TRUE,
                                          FALSE,
                                          NULL );


    if( m_hLoadLibPropWaitEvent && m_hLoadLibClassWaitEvent )
    {
        // Start a thread to enumerate the schema classes
        m_hClassThread = CreateThread(NULL,
                                      0,
                                      SchemaClassThread,
                                      this,
                                      0,
                                      &dwThreadID);

        // Start a thread to enumerate the schema properties
        m_hPropertyThread = CreateThread(NULL,
                                         0,
                                         SchemaPropertyThread,
                                         this,
                                         0,
                                         &dwThreadID);



        ahWait[0] = m_hClassThread;
        ahWait[1] = m_hPropertyThread;

        WaitForMultipleObjects(2,
                               ahWait,
                               TRUE,
                               INFINITE);
    }

exit_gracefully:

    VariantClear(&var);
    DoRelease(pRootDSE);
    DoRelease(pPath);
    SysFreeString(strRootDSEPath);
    if( m_hLoadLibPropWaitEvent )
        CloseHandle( m_hLoadLibPropWaitEvent );
    if( m_hLoadLibClassWaitEvent )
        CloseHandle( m_hLoadLibClassWaitEvent );


    TraceLeaveVoid();
}


CSchemaCache::~CSchemaCache()
{

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::~CSchemaCache");

    SysFreeString(m_strSchemaSearchPath);
    SysFreeString(m_strERSearchPath);
    SysFreeString(m_strFilterFile);
    DeleteCriticalSection(&m_ObjectTypeCacheCritSec);

    DestroyDPA(m_hClassCache);
    DestroyDPA(m_hPropertyCache);
    if(m_hObjectTypeCache)
    {
        POBJECT_TYPE_CACHE pOTC = NULL;
        UINT cCount = DPA_GetPtrCount(m_hObjectTypeCache);
        for(UINT i = 0; i < cCount; ++i)
        {
            pOTC = (POBJECT_TYPE_CACHE)DPA_FastGetPtr(m_hObjectTypeCache, i);
            if(pOTC)
            {
                DestroyDPA(pOTC->hListChildObject);
                DestroyDPA(pOTC->hListExtRights);
                DestroyDPA(pOTC->hListProperty);
                DestroyDPA(pOTC->hListPropertySet);    
            }
        }
    }
    DestroyDPA(m_hObjectTypeCache);    

    if (m_hAccessInfoCache != NULL)
    {
        UINT cItems = DPA_GetPtrCount(m_hAccessInfoCache);
        PACCESS_INFO pAI = NULL;
        while (cItems > 0)
        {
            pAI = (PACCESS_INFO)DPA_FastGetPtr(m_hAccessInfoCache, --cItems);
            if(pAI && pAI->pAccess)
                LocalFree(pAI->pAccess);            
        }
    }
    DestroyDPA(m_hAccessInfoCache);        
        
    if (m_pInheritTypeArray != NULL)
        LocalFree(m_pInheritTypeArray);

    TraceMsg("CSchemaCache::~CSchemaCache exiting");
    TraceLeaveVoid();
}


LPCWSTR
CSchemaCache::GetClassName(LPCGUID pguidObjectType)
{
    LPCWSTR pszLdapName = NULL;
    PID_CACHE_ENTRY pCacheEntry;

    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::GetClassName");

    pCacheEntry = LookupClass(pguidObjectType);

    if (pCacheEntry != NULL)
        pszLdapName = pCacheEntry->szLdapName;

    TraceLeaveValue(pszLdapName);
}


HRESULT
CSchemaCache::GetInheritTypes(LPCGUID ,
                              DWORD dwFlags,
                              PSI_INHERIT_TYPE *ppInheritTypes,
                              ULONG *pcInheritTypes)
{
    // We're going to find the inherit type array corresponding to the passed-in
    // object type - pInheritTypeArray will point to it!
    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::GetInheritTypes");
    TraceAssert(ppInheritTypes != NULL);
    TraceAssert(pcInheritTypes != NULL);

    *pcInheritTypes = 0;
    *ppInheritTypes = NULL;

    // If the filter state is changing, free everything
    if (m_pInheritTypeArray &&
        (m_pInheritTypeArray->dwFlags & SCHEMA_NO_FILTER) != (dwFlags & SCHEMA_NO_FILTER))
    {
        LocalFree(m_pInheritTypeArray);
        m_pInheritTypeArray = NULL;
    }

    // Build m_pInheritTypeArray if necessary
    if (m_pInheritTypeArray == NULL)
    {
        BuildInheritTypeArray(dwFlags);
    }

    // Return m_pInheritTypeArray if we have it, otherwise
    // fall back on the static types
    if (m_pInheritTypeArray)
    {
        *pcInheritTypes = m_pInheritTypeArray->cInheritTypes;
        *ppInheritTypes = m_pInheritTypeArray->aInheritType;
    }
    else
    {
        TraceMsg("Returning default inherit information");
        *ppInheritTypes = g_siDSInheritTypes;
        *pcInheritTypes = ARRAYSIZE(g_siDSInheritTypes);
    }

    TraceLeaveResult(S_OK); // always succeed
}


HRESULT
CSchemaCache::GetAccessRights(LPCGUID pguidObjectType,
                              LPCWSTR pszClassName,
                              HDPA hAuxList,
                              LPCWSTR pszSchemaPath,
                              DWORD dwFlags,
                              PACCESS_INFO *ppAccessInfo)
{
    HRESULT hr = S_OK;
    HCURSOR hcur;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetAccessRights");
    TraceAssert(ppAccessInfo);


    BOOL bAddToCache = FALSE;
    PACCESS_INFO pAI = NULL;
    //
    // If the SCHEMA_COMMON_PERM flag is on, just return the permissions
    // that are common to all DS objects (including containers).
    //
    if (dwFlags & SCHEMA_COMMON_PERM)
    {        
        *ppAccessInfo = &m_AICommon;
        TraceLeaveResult(S_OK);
    }

    TraceAssert(pguidObjectType);
        
    EnterCriticalSection(&m_ObjectTypeCacheCritSec);


    //
    //If AuxList is null, we can return the item from cache
    //
    if(hAuxList == NULL)
    {
        //There is no Aux Class. Check the m_hAccessInfoCache if we have access right
        //for the pguidObjectType;
        if (m_hAccessInfoCache != NULL)
        {
            UINT cItems = DPA_GetPtrCount(m_hAccessInfoCache);

            while (cItems > 0)
            {
                pAI = (PACCESS_INFO)DPA_FastGetPtr(m_hAccessInfoCache, --cItems);
                //
                //Found A match.
                //
                if(pAI && 
                   IsEqualGUID(pAI->ObjectTypeGuid, *pguidObjectType) &&
                   ((pAI->dwFlags & (SI_EDIT_PROPERTIES | SI_EDIT_EFFECTIVE)) == 
                    (dwFlags & (SI_EDIT_PROPERTIES | SI_EDIT_EFFECTIVE))))    

                    break;

                pAI = NULL;
            }
            
            if(pAI)
            {
                goto exit_gracefully;    
            }
        }
        bAddToCache = TRUE;
    }
    
    pAI = (PACCESS_INFO)LocalAlloc(LPTR,sizeof(ACCESS_INFO));
    if(!pAI)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");
    
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = BuildAccessArray(pguidObjectType,
                          pszClassName,
                          pszSchemaPath,
                          hAuxList,
                          dwFlags,
                          &pAI->pAccess,
                          &pAI->cAccesses,
                          &pAI->iDefaultAccess);
    FailGracefully(hr, "BuildAccessArray Failed");

    if(bAddToCache)
    {
        if(!m_hAccessInfoCache)
            m_hAccessInfoCache = DPA_Create(4);
    
        if(!m_hAccessInfoCache)
            ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create Failed");

        pAI->dwFlags = dwFlags;
        pAI->ObjectTypeGuid = *pguidObjectType;
        DPA_AppendPtr(m_hAccessInfoCache, pAI);
    }
    
    //
    //If item is added to cache, don't localfree it. It will be free when 
    //DLL is unloaded
    //
    pAI->bLocalFree = !bAddToCache;
    
    SetCursor(hcur);

exit_gracefully:

    if(FAILED(hr))
    {
        if(pAI)
        {
            LocalFree(pAI);
            pAI = NULL;
        }
    }

    *ppAccessInfo = pAI;

    LeaveCriticalSection(&m_ObjectTypeCacheCritSec);

    TraceLeaveResult(hr);
}

 

HRESULT 
CSchemaCache::GetDefaultSD(GUID *pSchemaIDGuid, 
						   PSID pDomainSid, 
						   PSID pRootDomainSid, 
						   PSECURITY_DESCRIPTOR *ppSD)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetDefaultSD");
    TraceAssert( pSchemaIDGuid != NULL);
    TraceAssert( ppSD != NULL );

    HRESULT hr = S_OK;

	if( (pDomainSid && !IsValidSid(pDomainSid)) ||
		 (pRootDomainSid && !IsValidSid(pRootDomainSid)) )
		 return E_INVALIDARG;

    LPWSTR pszDestData = NULL;
    IDirectorySearch * IDs = NULL;
    ADS_SEARCH_HANDLE hSearchHandle=NULL;  
    LPWSTR lpszSchemaGuidFilter = L"(schemaIdGuid=%s)";
    LPWSTR pszAttr[] = {L"defaultSecurityDescriptor"};
    ADS_SEARCH_COLUMN col;
    WCHAR szSearchBuffer[MAX_PATH];

    hr = ADsEncodeBinaryData( (PBYTE)pSchemaIDGuid,
                          sizeof(GUID),
                          &pszDestData  );
    FailGracefully(hr, "ADsEncodeBinaryData Failed");
    
    hr = StringCchPrintf(szSearchBuffer, 
                         ARRAYSIZE(szSearchBuffer),
                         lpszSchemaGuidFilter,
                         pszDestData);
    FailGracefully(hr, "StringCchPrintf Failed");
    
   
   //We have Filter Now

   //Search in Configuration Contianer
    hr = OpenDSObject(  m_strSchemaSearchPath,
                         NULL,
                         NULL,
                         ADS_SECURE_AUTHENTICATION,
                         IID_IDirectorySearch,
                         (void **)&IDs );
    FailGracefully(hr, "OpenDSObject Failed");

    hr = IDs->ExecuteSearch(szSearchBuffer,
                           pszAttr,
                           1,
                           &hSearchHandle );

    FailGracefully(hr, "Search in Schema  Failed");


    hr = IDs->GetFirstRow(hSearchHandle);
    if( hr == S_OK )
    {  
        //Get Guid
        hr = IDs->GetColumn( hSearchHandle, pszAttr[0], &col );
        FailGracefully(hr, "Failed to get column from search result");

        if(pDomainSid && pRootDomainSid)
        {
            if(!ConvertStringSDToSDDomain(pDomainSid,
                                          pRootDomainSid,
                                          (LPCWSTR)(LPWSTR)col.pADsValues->CaseIgnoreString,
                                          SDDL_REVISION_1,
                                          ppSD,
                                          NULL )) 
            {
                hr = GetLastError();
                IDs->FreeColumn( &col );
                ExitGracefully(hr, E_FAIL, "Unable to convert String SD to SD");
            }
        }
        else
        {
            if ( !ConvertStringSecurityDescriptorToSecurityDescriptor( (LPCWSTR)(LPWSTR)col.pADsValues->CaseIgnoreString,
                                                                        SDDL_REVISION_1,
                                                                        ppSD,
                                                                        NULL ) ) 
            {
                hr = GetLastError();
                IDs->FreeColumn( &col );
                ExitGracefully(hr, E_FAIL, "Unable to convert String SD to SD");
            }
        }
        IDs->FreeColumn( &col );         
    }
    else
        ExitGracefully(hr, E_FAIL, "Schema search resulted in zero rows");
    
    

exit_gracefully:

    if( IDs )
    {
      if( hSearchHandle )
         IDs->CloseSearchHandle( hSearchHandle );
      IDs->Release();
    }
    FreeADsMem(pszDestData);
    TraceLeaveResult(hr);
}



VOID AddOTLToList( POBJECT_TYPE_LIST pOTL, WORD Level, LPGUID pGuidObject )
{
    (pOTL)->Level = Level;
    (pOTL)->ObjectType = pGuidObject;
}

//Get the ObjectTypeList for pSchemaGuid class

OBJECT_TYPE_LIST g_DefaultOTL[] = {
                                    {0, 0, (LPGUID)&GUID_NULL},
                                  };
HRESULT
CSchemaCache::GetObjectTypeList( GUID *pguidObjectType,
                                 HDPA hAuxList,
                                 LPCWSTR pszSchemaPath,
                                 DWORD dwFlags,
                                 POBJECT_TYPE_LIST *ppObjectTypeList,                                  
                                 DWORD * pObjectTypeListCount)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetObjectTypeList");
    TraceAssert( pguidObjectType != NULL);
    TraceAssert( ppObjectTypeList != NULL );
    TraceAssert( pObjectTypeListCount != NULL );
    TraceAssert(pszSchemaPath != NULL);


    HRESULT hr = S_OK;
    //
    //Lists
    //
    HDPA hExtRightList = NULL;
    HDPA hPropSetList = NULL;
    HDPA hPropertyList = NULL;
    HDPA hClassList = NULL;
    //
    //List counts
    //
    ULONG cExtendedRights = 0;
    ULONG cPropertySets = 0;
    UINT cProperties = 0;
    UINT cChildClasses = 0;

    POBJECT_TYPE_LIST pOTL = NULL;
    POBJECT_TYPE_LIST pTempOTL = NULL;

    LPCWSTR pszClassName = NULL;
    UINT cGuidIndex = 0;


    if( dwFlags & SCHEMA_COMMON_PERM )
    {
        *ppObjectTypeList = 
            (POBJECT_TYPE_LIST)LocalAlloc(LPTR,sizeof(OBJECT_TYPE_LIST)*ARRAYSIZE(g_DefaultOTL));
        if(!*ppObjectTypeList)
            TraceLeaveResult(E_OUTOFMEMORY);
        //
        //Note that default OTL is entry with all zero,thatz what LPTR does.
        //so there is no need to copy
        //
        *pObjectTypeListCount = ARRAYSIZE(g_DefaultOTL);        
        TraceLeaveResult(S_OK);
    }

    EnterCriticalSection(&m_ObjectTypeCacheCritSec);

    //
    // Lookup the name of this class
    //
    if (pszClassName == NULL)
        pszClassName = GetClassName(pguidObjectType);

    if(!pszClassName)
         ExitGracefully(hr, E_UNEXPECTED, "Unknown child object GUID");
    
    //
    // Get the list of Extended Rights for this page
    //
    if (pguidObjectType &&
        SUCCEEDED(GetExtendedRightsForNClasses(m_strERSearchPath,
                                               pguidObjectType,
                                               hAuxList,
                                               &hExtRightList,
                                               &hPropSetList)))

    {
        if(hPropSetList)
            cPropertySets = DPA_GetPtrCount(hPropSetList);
        if(hExtRightList)
            cExtendedRights = DPA_GetPtrCount(hExtRightList);
    }

    //
    //Get the child classes
    //
    if( pguidObjectType &&
        SUCCEEDED(GetChildClassesForNClasses(pguidObjectType,
                                             pszClassName,
                                             hAuxList,
                                             pszSchemaPath,
                                             &hClassList)))
    {

        if(hClassList)
            cChildClasses = DPA_GetPtrCount(hClassList);        
    }
     
    //
    //Get the properties for the class
    //        
    if (pguidObjectType &&
        SUCCEEDED(GetPropertiesForNClasses(pguidObjectType,
                                           pszClassName,
                                           hAuxList,
                                           pszSchemaPath,
                                           &hPropertyList)))
    {
        if(hPropertyList)
            cProperties = DPA_GetPtrCount(hPropertyList);
        
    }
    
    pOTL = (POBJECT_TYPE_LIST)LocalAlloc(LPTR, 
                                         (cPropertySets + 
                                          cExtendedRights + 
                                          cChildClasses + 
                                          cProperties +
                                          1)* sizeof(OBJECT_TYPE_LIST)); 
                                                   
    if(!pOTL)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create POBJECT_TYPE_LIST");

    pTempOTL = pOTL;

    //
    //First Add the entry corresponding to Object
    //
    AddOTLToList(pTempOTL, 
                 ACCESS_OBJECT_GUID, 
                 pguidObjectType);
    pTempOTL++;
    cGuidIndex++;    
    
    UINT i, j;
    for (i = 0; i < cExtendedRights; i++)
    {
        PER_ENTRY pER = (PER_ENTRY)DPA_FastGetPtr(hExtRightList, i);
        AddOTLToList(pTempOTL, 
                     ACCESS_PROPERTY_SET_GUID, 
                     &(pER->guid));
        pTempOTL++;    
        cGuidIndex++;
    }
    
    //
    //Add Property Set
    //

    for(i = 0; i < cPropertySets; ++i)
    {
        PER_ENTRY pER = (PER_ENTRY)DPA_FastGetPtr(hPropSetList, i);
        
        AddOTLToList(pTempOTL,
                     ACCESS_PROPERTY_SET_GUID, 
                     &pER->guid); 
        cGuidIndex++;
        pTempOTL++;    
        
        //
        //Add all the properties which are member of this property set
        //
        for(j = 0; j < cProperties; ++j)
        {
            PPROP_ENTRY pProp = (PPROP_ENTRY)DPA_FastGetPtr(hPropertyList, j);
            if(IsEqualGUID(pER->guid, *pProp->pasguid))
            {
                AddOTLToList(pTempOTL,
                             ACCESS_PROPERTY_GUID, 
                             pProp->pguid); 
                cGuidIndex++;
                pTempOTL++;    
                pProp->dwFlags|= OTL_ADDED_TO_LIST;
            }
        }                
    }               

    //Add all remaining properties
    for( j =0; j < cProperties; ++j )
    {
        PPROP_ENTRY pProp = (PPROP_ENTRY)DPA_FastGetPtr(hPropertyList, j);
        if( !(pProp->dwFlags & OTL_ADDED_TO_LIST) )
        {
            AddOTLToList(pTempOTL, 
                         ACCESS_PROPERTY_SET_GUID, 
                         pProp->pguid); 
            pTempOTL++;    
            cGuidIndex++;
        }
        pProp->dwFlags &= ~OTL_ADDED_TO_LIST;
    }
    
    //All all child clasess
    for( j = 0; j < cChildClasses; ++j )
    {
        PPROP_ENTRY pClass= (PPROP_ENTRY)DPA_FastGetPtr(hClassList, j);
        AddOTLToList(pTempOTL, 
                     ACCESS_PROPERTY_SET_GUID, 
                     pClass->pguid); 
        pTempOTL++;
        cGuidIndex++;
    }

exit_gracefully:

    DPA_Destroy(hExtRightList);
    DPA_Destroy(hClassList);
    DPA_Destroy(hPropertyList);
    DPA_Destroy(hPropSetList);

    LeaveCriticalSection(&m_ObjectTypeCacheCritSec);

    if (FAILED(hr))
    {
        *ppObjectTypeList = NULL;
        *pObjectTypeListCount = 0;
    }
    else
    {
        *ppObjectTypeList = pOTL;
        *pObjectTypeListCount = cGuidIndex;
    }

    TraceLeaveResult(hr);
}


PID_CACHE_ENTRY
CSchemaCache::LookupID(HDPA hCache, LPCWSTR pszLdapName)
{
    PID_CACHE_ENTRY pCacheEntry = NULL;
    int iEntry;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::LookupID");
    TraceAssert(hCache != NULL);
    TraceAssert(pszLdapName != NULL && *pszLdapName);

    iEntry = DPA_Search(hCache,
                        NULL,
                        0,
                        Schema_CompareLdapName,
                        (LPARAM)pszLdapName,
                        DPAS_SORTED);

    if (iEntry != -1)
        pCacheEntry = (PID_CACHE_ENTRY)DPA_FastGetPtr(hCache, iEntry);

    TraceLeaveValue(pCacheEntry);
}

BOOL
CSchemaCache::IsAuxClass(LPCGUID pguidObjectType)
{
    PID_CACHE_ENTRY pCacheEntry = NULL;
    HRESULT hr = S_OK;
    UINT cItems;

    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::IsAuxClass");
    TraceAssert(pguidObjectType != NULL);
    
    if(IsEqualGUID(*pguidObjectType, GUID_NULL))
        return FALSE;

    hr = WaitOnClassThread();
    FailGracefully(hr, "Class cache unavailable");

    TraceAssert(m_hClassCache != NULL);

    cItems = DPA_GetPtrCount(m_hClassCache);

    while (cItems > 0)
    {
        PID_CACHE_ENTRY pTemp = (PID_CACHE_ENTRY)DPA_FastGetPtr(m_hClassCache, --cItems);

        if (IsEqualGUID(*pguidObjectType, pTemp->guid))
        {
            pCacheEntry = pTemp;
            break;
        }
    }

exit_gracefully:

    if(pCacheEntry)
        return pCacheEntry->bAuxClass;
    else
        return FALSE;       
}

PID_CACHE_ENTRY
CSchemaCache::LookupClass(LPCGUID pguidObjectType)
{
    PID_CACHE_ENTRY pCacheEntry = NULL;
    HRESULT hr = S_OK;
    UINT cItems;

    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::LookupClass");
    TraceAssert(pguidObjectType != NULL);
    TraceAssert(!IsEqualGUID(*pguidObjectType, GUID_NULL));

    hr = WaitOnClassThread();
    FailGracefully(hr, "Class cache unavailable");

    TraceAssert(m_hClassCache != NULL);

    cItems = DPA_GetPtrCount(m_hClassCache);

    while (cItems > 0)
    {
        PID_CACHE_ENTRY pTemp = (PID_CACHE_ENTRY)DPA_FastGetPtr(m_hClassCache, --cItems);

        if (IsEqualGUID(*pguidObjectType, pTemp->guid))
        {
            pCacheEntry = pTemp;
            break;
        }
    }

exit_gracefully:

    TraceLeaveValue(pCacheEntry);
}


HRESULT
CSchemaCache::LookupClassID(LPCWSTR pszClass, LPGUID pGuid)
{
    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::LookupClassID");
    TraceAssert(pszClass != NULL && pGuid != NULL);
	

    HRESULT hr = WaitOnClassThread();
	if(SUCCEEDED(hr))
    {
        TraceAssert(m_hClassCache != NULL);
        PID_CACHE_ENTRY pCacheEntry = LookupID(m_hClassCache, pszClass);
        if (pCacheEntry)
            *pGuid = pCacheEntry->guid;
    }

    return hr;
}


LPCGUID
CSchemaCache::LookupPropertyID(LPCWSTR pszProperty)
{
    LPCGUID pID = NULL;

    TraceEnter(TRACE_SCHEMAPROP, "CSchemaCache::LookupPropertyID");
    TraceAssert(pszProperty != NULL);

    if (SUCCEEDED(WaitOnPropertyThread()))
    {
        TraceAssert(m_hPropertyCache != NULL);
        PID_CACHE_ENTRY pCacheEntry = LookupID(m_hPropertyCache, pszProperty);
        if (pCacheEntry)
            pID = &pCacheEntry->guid;
    }

    TraceLeaveValue(pID);
}


WCHAR const c_szDsHeuristics[] = L"dSHeuristics";

int
CSchemaCache::GetListObjectEnforced(void)
{
    int nListObjectEnforced = 0;    // Assume "not enforced"
    HRESULT hr;
    IADsPathname *pPath = NULL;
    const LPWSTR aszServicePath[] =
    {
        L"CN=Services",
        L"CN=Windows NT",
        L"CN=Directory Service",
    };
    BSTR strServicePath = NULL;
    IDirectoryObject *pDirectoryService = NULL;
    LPWSTR pszDsHeuristics = (LPWSTR)c_szDsHeuristics;
    PADS_ATTR_INFO pAttributeInfo = NULL;
    DWORD dwAttributesReturned;
    LPWSTR pszHeuristicString;
    int i;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetListObjectEnforced");

    // Create a path object for manipulating ADS paths
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pPath);
    FailGracefully(hr, "Unable to create ADsPathname object");

    hr = pPath->Set(m_strERSearchPath, ADS_SETTYPE_FULL);
    FailGracefully(hr, "Unable to initialize ADsPathname object");

    hr = pPath->RemoveLeafElement();
    for (i = 0; i < ARRAYSIZE(aszServicePath); i++)
    {
        hr = pPath->AddLeafElement(AutoBstr(aszServicePath[i]));
        FailGracefully(hr, "Unable to build path to 'Directory Service' object");
    }

    hr = pPath->Retrieve(ADS_FORMAT_WINDOWS, &strServicePath);
    FailGracefully(hr, "Unable to build path to 'Directory Service' object");

    hr = ADsGetObject(strServicePath,
                      IID_IDirectoryObject,
                      (LPVOID*)&pDirectoryService);
    FailGracefully(hr, "Unable to bind to 'Directory Service' object for heuristics");

    hr = pDirectoryService->GetObjectAttributes(&pszDsHeuristics,
                                                1,
                                                &pAttributeInfo,
                                                &dwAttributesReturned);
    if (!pAttributeInfo)
        ExitGracefully(hr, hr, "GetObjectAttributes failed to read dSHeuristics property");

    TraceAssert(ADSTYPE_DN_STRING <= pAttributeInfo->dwADsType);
    TraceAssert(ADSTYPE_NUMERIC_STRING >= pAttributeInfo->dwADsType);
    TraceAssert(1 == pAttributeInfo->dwNumValues);

    pszHeuristicString = pAttributeInfo->pADsValues->NumericString;
    if (pszHeuristicString &&
        lstrlenW(pszHeuristicString) > 2 &&
        L'0' != pszHeuristicString[2])
    {
        nListObjectEnforced = 1;
    }

exit_gracefully:

    if (pAttributeInfo)
        FreeADsMem(pAttributeInfo);

    DoRelease(pDirectoryService);
    DoRelease(pPath);

    SysFreeString(strServicePath);

    TraceLeaveValue(nListObjectEnforced);
}

BOOL
CSchemaCache::HideListObjectAccess(void)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::HideListObjectAccess");

    if (-1 == m_nDsListObjectEnforced)
    {
        m_nDsListObjectEnforced = GetListObjectEnforced();
    }

    TraceLeaveValue(0 == m_nDsListObjectEnforced);
}


#define ACCESS_LENGTH_0 (sizeof(SI_ACCESS) + MAX_TYPENAME_LENGTH * sizeof(WCHAR))
#define ACCESS_LENGTH_1 (sizeof(SI_ACCESS) + MAX_TYPENAME_LENGTH * sizeof(WCHAR))
#define ACCESS_LENGTH_2 (3 * sizeof(SI_ACCESS) + 3 * MAX_TYPENAME_LENGTH * sizeof(WCHAR))

HRESULT
CSchemaCache::BuildAccessArray(LPCGUID pguidObjectType,
                               LPCWSTR pszClassName,
                               LPCWSTR pszSchemaPath,    
                               HDPA hAuxList,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    HRESULT hr = S_OK;
    
    DWORD dwBufferLength = 0;
    UINT cMaxAccesses;
    LPWSTR pszData = NULL;
    //
    //Lists
    //
    HDPA hExtRightList = NULL;
    HDPA hPropSetList = NULL;
    HDPA hPropertyList = NULL;
    HDPA hClassList = NULL;
    //
    //List counts
    //
    ULONG cExtendedRights = 0;
    ULONG cPropertySets = 0;
    UINT cProperties = 0;
    UINT cChildClasses = 0;

    ULONG cBaseRights = 0;
    
    
    PSI_ACCESS pAccesses = NULL;
    PSI_ACCESS pTempAccesses = NULL;
    ULONG cAccesses = 0;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::BuildAccessArray");
    TraceAssert(pguidObjectType != NULL);
    TraceAssert(ppAccesses);
    TraceAssert(pcAccesses);
    TraceAssert(piDefaultAccess);

    *ppAccesses = NULL;
    *pcAccesses = 0;
    *piDefaultAccess = 0;
    //
    //Decide what all we need
    //
    BOOL bBasicRight = FALSE;
    BOOL bExtRight = FALSE;
    BOOL bChildClass = FALSE;
    BOOL bProp = FALSE;


    //
    // Lookup the name of this class
    //
    if (pszClassName == NULL)
        pszClassName = GetClassName(pguidObjectType);
    
    if(pszClassName == NULL)
        ExitGracefully(hr, E_UNEXPECTED, "Unknown child object GUID");

    
    if(dwFlags & SI_EDIT_PROPERTIES)
    {
        bProp = TRUE;
    }
    else if(dwFlags & SI_EDIT_EFFECTIVE)
    {
        bExtRight = TRUE;
        bChildClass = TRUE;
        bProp = TRUE;
    }
    else
    {
        bExtRight = TRUE;
        bChildClass = TRUE;
    }
    //
    //We don't show basicRights for Auxillary Classes.
    //This happens when user selects Aux Class in Applyonto combo
    //
    bBasicRight = !IsAuxClass(pguidObjectType);
    //
    // Get the list of Extended Rights for this page
    //
    if (pguidObjectType &&
        SUCCEEDED(GetExtendedRightsForNClasses(m_strERSearchPath,
                                               pguidObjectType,
                                               hAuxList,
                                               bExtRight ? &hExtRightList : NULL,
                                               &hPropSetList)))

    {
        if(hPropSetList)
            cPropertySets = DPA_GetPtrCount(hPropSetList);
        if(hExtRightList)
            cExtendedRights = DPA_GetPtrCount(hExtRightList);
    }


    if( bChildClass &&
        pguidObjectType &&
        SUCCEEDED(GetChildClassesForNClasses(pguidObjectType,
                                             pszClassName,
                                             hAuxList,
                                             pszSchemaPath,
                                             &hClassList)))
    {

        if(hClassList)
            cChildClasses = DPA_GetPtrCount(hClassList);        
    }
     

    //
    //Get the properties for the class
    //        
    if (bProp &&
        pguidObjectType &&
        SUCCEEDED(GetPropertiesForNClasses(pguidObjectType,
                                           pszClassName,
                                           hAuxList,
                                           pszSchemaPath,
                                           &hPropertyList)))
    {
        if(hPropertyList)
            cProperties = DPA_GetPtrCount(hPropertyList);
        
    }
    
    if(bBasicRight)
    {
        //
        //Only Read Property and write Property
        //
        if(dwFlags & SI_EDIT_PROPERTIES)
        {
            cBaseRights = 2;
        }
        else
        {
            cBaseRights = ARRAYSIZE(g_siDSAccesses);
                if (!cChildClasses)
                    cBaseRights -= 3; // skip DS_CREATE_CHILD and DS_DELETE_CHILD and both

        }
    }

    //
    //Three Entries per Child Class 1)Create 2)Delete 3) Create/Delete 
    //Three Entries per Prop Class 1) Read 2)Write 3)Read/Write
    //
    cMaxAccesses =  cBaseRights +
                    cExtendedRights +  
                    3 * cChildClasses +  
                    3 * cPropertySets +
                    3 * cProperties;
    //
    //This can happen for Aux Class Object Right page
    //As we don't show general rights for it.
    //
    if(cMaxAccesses == 0)
        goto exit_gracefully;
    
    //
    // Allocate a buffer for the access array
    //
    dwBufferLength =  cBaseRights * sizeof(SI_ACCESS)
                      + cExtendedRights * ACCESS_LENGTH_1
                      + cChildClasses * ACCESS_LENGTH_2
                      + cPropertySets * ACCESS_LENGTH_2
                      + cProperties * ACCESS_LENGTH_2;
    
    pAccesses = (PSI_ACCESS)LocalAlloc(LPTR, dwBufferLength);
    if (pAccesses == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    pTempAccesses = pAccesses;
    pszData = (LPWSTR)(pTempAccesses + cMaxAccesses);

    //
    //Copy the basic right
    //
    if(bBasicRight)
    {
        if(dwFlags & SI_EDIT_PROPERTIES)
        {    
            //
            // Add "Read All Properties" and "Write All Properties"
            //
            CopyMemory(pTempAccesses, &g_siDSAccesses[g_iDSProperties], 2 * sizeof(SI_ACCESS));
            pTempAccesses += 2;
            cAccesses += 2;
        }
        else
        {
            //
            // Add normal entries 
            //
            CopyMemory(pTempAccesses, g_siDSAccesses, cBaseRights * sizeof(SI_ACCESS));
            pTempAccesses += cBaseRights;
            cAccesses += cBaseRights;

            if (HideListObjectAccess())
            {
                pAccesses[g_iDSRead].mask &= ~ACTRL_DS_LIST_OBJECT;
                pAccesses[g_iDSListObject].dwFlags = 0;
            }
			
			//
			//If there are no child objects, don't show create/delete child objects
			//
			if(cChildClasses == 0)
				pAccesses[g_iDSDeleteTree].dwFlags = 0;

        }
    }

    //
    // Add entries for creating & deleting child objects
    //
    if (bChildClass && cChildClasses)
    {
        TraceAssert(NULL != hClassList);

        cAccesses += AddTempListToAccessList(hClassList,
                                             &pTempAccesses,
                                             &pszData,
                                             SI_ACCESS_SPECIFIC,
                                             SCHEMA_CLASS | (dwFlags & SCHEMA_NO_FILTER),
                                             FALSE);
    }



    if(bExtRight)
    {
        //
        //Decide if to show "All Extended Rights" entry 
        //and "All Validated Right Entry
        //
        BOOL bAllExtRights = FALSE;
        if(cExtendedRights)
        {
            //
            // Add entries for Extended Rights
            //
            UINT i;
            for (i = 0; i < cExtendedRights; i++)
            {
                PER_ENTRY pER = (PER_ENTRY)DPA_FastGetPtr(hExtRightList, i);

                //
                //Show All Validated Right entry only if atleast one 
                //individual Validated Right is present
                //
                //if(pER->mask & ACTRL_DS_SELF)
                //    bAllValRights = TRUE;
				//New Comments: Always show Validated Rights since they
				//Form Write permission on first page and hiding them
				//on advanced page cause confusion(lots of). See
				//bug 495391

                //
                //Show All Validated Right entry only if atleast one 
                //individual Validated Right is present
                //
                if(pER->mask & ACTRL_DS_CONTROL_ACCESS)
                    bAllExtRights = TRUE;

                pTempAccesses->mask = pER->mask;
                //
                //Extended Rights Are shown on both first page and advanced page
                //
                pTempAccesses->dwFlags = SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC;
                pTempAccesses->pguid = &pER->guid;
                pTempAccesses->pszName = pszData;
                lstrcpynW(pszData, pER->szName, MAX_TYPENAME_LENGTH);
                pszData += (lstrlen(pTempAccesses->pszName) + 1);
                pTempAccesses++;
                cAccesses++;
            }
        }
        if(!bAllExtRights && bBasicRight)
            pAccesses[g_iDSAllExtRights].dwFlags = 0;

    }

    //
    //Add PropertySet Entries
    //
    if (cPropertySets > 0)
    {
        cAccesses += AddTempListToAccessList(hPropSetList,
                                             &pTempAccesses,
                                             &pszData,
                                             SI_ACCESS_GENERAL|SI_ACCESS_PROPERTY,
                                             (dwFlags & SCHEMA_NO_FILTER),
                                             TRUE);
    }

    //
    // Add property entries
    //
    if (bProp && cProperties > 0)
    {
        cAccesses += AddTempListToAccessList(hPropertyList,
                                             &pTempAccesses,
                                             &pszData,
                                             SI_ACCESS_PROPERTY,
                                             (dwFlags & SCHEMA_NO_FILTER),
                                             FALSE);
    }


    *ppAccesses = pAccesses;
    *pcAccesses = cAccesses;
    *piDefaultAccess = bBasicRight ? g_iDSDefAccess : 0;


exit_gracefully:

    if(hExtRightList)
        DPA_Destroy(hExtRightList);
    if(hClassList)
        DPA_Destroy(hClassList);
    if(hPropertyList)
        DPA_Destroy(hPropertyList);
    if(hPropSetList)
        DPA_Destroy(hPropSetList);

    TraceLeaveResult(hr);
}




HRESULT
CSchemaCache::EnumVariantList(LPVARIANT pvarList,
                              HDPA hTempList,
                              DWORD dwFlags,
                              IDsDisplaySpecifier *pDisplaySpec,
                              LPCWSTR pszPropertyClass,
                              BOOL )
{
    HRESULT hr = S_OK;
    LPVARIANT pvarItem = NULL;
    int cItems;
    BOOL bSafeArrayLocked = FALSE;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::EnumVariantList");
    TraceAssert(pvarList != NULL);
    TraceAssert(hTempList != NULL);

	if (dwFlags & SCHEMA_CLASS)
        hr = WaitOnClassThread();
    else
		hr = WaitOnPropertyThread();

	FailGracefully(hr, "Required Cache Not Available");


    if (V_VT(pvarList) == (VT_ARRAY | VT_VARIANT))
    {
        hr = SafeArrayAccessData(V_ARRAY(pvarList), (LPVOID*)&pvarItem);
        FailGracefully(hr, "Unable to access SafeArray");
        bSafeArrayLocked = TRUE;
        cItems = V_ARRAY(pvarList)->rgsabound[0].cElements;
    }
    else if (V_VT(pvarList) == VT_BSTR) // Single entry in list
    {
        pvarItem = pvarList;
        cItems = 1;
    }
    else
    {
        // Unknown format
        ExitGracefully(hr, E_INVALIDARG, "Unexpected VARIANT type");
    }

    if (NULL == m_strFilterFile)
        m_strFilterFile = GetFilterFilePath();

    //
    // Enumerate the variant list and get information about each
    // (filter, guid, display name)
    //
    for ( ; cItems > 0; pvarItem++, cItems--)
    {
        LPWSTR pszItem;
        DWORD dwFilter = 0;
        WCHAR wszDisplayName[MAX_PATH];
        PPROP_ENTRY pti;
        PID_CACHE_ENTRY pid ;


        //
        //Get the ldapDisplayName
        //            
        TraceAssert(V_VT(pvarItem) == VT_BSTR);
        pszItem = V_BSTR(pvarItem);

        //
        // Check for nonexistent or empty strings
        //
        if (!pszItem || !*pszItem)
            continue;

        //
        //Check if the string is filtered by dssec.dat file
        //
        if(m_strFilterFile)
        {
            if (dwFlags & SCHEMA_CLASS)
            {
                dwFilter = GetPrivateProfileIntW(pszItem,
                                                 c_szClassKey,
                                                 0,
                                                 m_strFilterFile);
                if(pszPropertyClass)
                    dwFilter |= GetPrivateProfileIntW(pszPropertyClass,
                                                      pszItem,
                                                      0,
                                                      m_strFilterFile);


            }
            else if (pszPropertyClass)
            {
                dwFilter = GetPrivateProfileIntW(pszPropertyClass,
                                                 pszItem,
                                                 0,
                                                 m_strFilterFile);
            }
        }
        
        //
        // Note that IDC_CLASS_NO_CREATE == IDC_PROP_NO_READ
        // and IDC_CLASS_NO_DELETE == IDC_PROP_NO_WRITE
        //
        dwFilter &= (IDC_CLASS_NO_CREATE | IDC_CLASS_NO_DELETE);

        //
        //Get the schema or property cache entry
        //
        if (dwFlags & SCHEMA_CLASS)
            pid = LookupID(m_hClassCache, pszItem);
        else
            pid = LookupID(m_hPropertyCache, pszItem);
            
        if(pid == NULL)
            continue;

        
        //
        //Get the Display Name
        //
        wszDisplayName[0] = L'\0';

        if (pDisplaySpec)
        {
            if (dwFlags & SCHEMA_CLASS)
            {
                pDisplaySpec->GetFriendlyClassName(pszItem,
                                                   wszDisplayName,
                                                   ARRAYSIZE(wszDisplayName));
            }
            else if (pszPropertyClass)
            {
                pDisplaySpec->GetFriendlyAttributeName(pszPropertyClass,
                                                       pszItem,
                                                       wszDisplayName,
                                                       ARRAYSIZE(wszDisplayName));
            }
        }

        LPWSTR pszDisplay;
        pszDisplay = (wszDisplayName[0] != L'\0') ? wszDisplayName : pszItem;
        //
        // Remember what we've got so far
        //
        pti = (PPROP_ENTRY)LocalAlloc(LPTR, sizeof(PROP_ENTRY) + StringByteSize(pszDisplay));
        if (pti)
        {
            pti->pguid = &pid->guid;
            pti->pasguid = &pid->asGuid;   
            pti->dwFlags |= dwFilter;
            lstrcpyW(pti->szName, pszDisplay);
            DPA_AppendPtr(hTempList, pti);
        }            
    }


exit_gracefully:

    if (bSafeArrayLocked)
        SafeArrayUnaccessData(V_ARRAY(pvarList));

    TraceLeaveResult(hr);
}


UINT
CSchemaCache::AddTempListToAccessList(HDPA hTempList,
                                      PSI_ACCESS *ppAccess,
                                      LPWSTR *ppszData,
                                      DWORD dwAccessFlags,
                                      DWORD dwFlags,
                                      BOOL bPropSet)
{
    UINT cTotalEntries = 0;
    int cItems;
    DWORD dwAccess1;
    DWORD dwAccess2;
    WCHAR szFmt1[MAX_TYPENAME_LENGTH];
    WCHAR szFmt2[MAX_TYPENAME_LENGTH];
    WCHAR szFmt3[MAX_TYPENAME_LENGTH];

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::AddTempListToAccessList");
    TraceAssert(ppAccess != NULL);
    TraceAssert(ppszData != NULL);

    cItems = DPA_GetPtrCount(hTempList);
    if (0 == cItems)
        ExitGracefully(cTotalEntries, 0, "empty list");

    if (dwFlags & SCHEMA_CLASS)
    {
        dwAccess1 = ACTRL_DS_CREATE_CHILD;
        dwAccess2 = ACTRL_DS_DELETE_CHILD;
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_CREATE_CHILD_TYPE, szFmt1, ARRAYSIZE(szFmt1));
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_DELETE_CHILD_TYPE, szFmt2, ARRAYSIZE(szFmt2));
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_CREATEDELETE_TYPE, szFmt3, ARRAYSIZE(szFmt3));
    }
    else
    {
        dwAccess1 = ACTRL_DS_READ_PROP;
        dwAccess2 = ACTRL_DS_WRITE_PROP;
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_READ_PROP_TYPE,  szFmt1, ARRAYSIZE(szFmt1));
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_WRITE_PROP_TYPE, szFmt2, ARRAYSIZE(szFmt2));
        LoadStringW(GLOBAL_HINSTANCE, IDS_DS_READWRITE_TYPE,  szFmt3, ARRAYSIZE(szFmt3));
    }

    // Enumerate the list and make up to 2 entries for each
    for(int i = 0; i < cItems; ++i)
    {
        PER_ENTRY pER = NULL;
        PPROP_ENTRY pProp = NULL;
        LPWSTR pszData;
        LPGUID pGuid = NULL;
        PSI_ACCESS pNewAccess;
        LPCWSTR pszName;
        int cch;
        DWORD dwAccess3;
        DWORD dwFilter = 0;
        
        if(bPropSet)
        {
            pER = (PER_ENTRY)DPA_FastGetPtr(hTempList, i);
            if (!pER)
                continue;
            pGuid = &pER->guid;
            pszName = pER->szName;
            dwFilter = 0;
        }
        else
        {
            pProp = (PPROP_ENTRY)DPA_FastGetPtr(hTempList, i);
            if (!pProp)
                continue;
            pGuid = pProp->pguid;
            pszName = pProp->szName;
            dwFilter = pProp->dwFlags;
        }
    
        pszData = *ppszData;
        pNewAccess = *ppAccess;

        dwAccess3 = 0;
        if ((dwFlags & SCHEMA_NO_FILTER) ||
            !(dwFilter & IDC_CLASS_NO_CREATE))
        {
            pNewAccess->mask = dwAccess1;
            pNewAccess->dwFlags = dwAccessFlags;
            pNewAccess->pguid = pGuid;

            pNewAccess->pszName = (LPCWSTR)pszData;
            cch = wsprintfW((LPWSTR)pszData, szFmt1, pszName);
            pszData += (cch + 1);

            cTotalEntries++;
            pNewAccess++;

            dwAccess3 |= dwAccess1;
        }

        if ((dwFlags & SCHEMA_NO_FILTER) ||
            !(dwFilter & IDC_CLASS_NO_DELETE))
        {
            pNewAccess->mask = dwAccess2;
            pNewAccess->dwFlags = dwAccessFlags;
            pNewAccess->pguid = pGuid;

            pNewAccess->pszName = (LPCWSTR)pszData;
            cch = wsprintfW((LPWSTR)pszData, szFmt2, pszName);
            pszData += (cch + 1);

            cTotalEntries++;
            pNewAccess++;

            dwAccess3 |= dwAccess2;
        }

        if (dwAccess3 == (dwAccess1 | dwAccess2))
        {
            // Add a hidden entry for
            //     "Read/write <prop>"
            // or
            //     "Create/delete <child>"
            pNewAccess->mask = dwAccess3;
            // dwFlags = 0 means it will never show as a checkbox, but it
            // may be used for the name displayed on the Advanced page.
            pNewAccess->dwFlags = 0;
            pNewAccess->pguid = pGuid;

            pNewAccess->pszName = (LPCWSTR)pszData;
            cch = wsprintfW((LPWSTR)pszData, szFmt3, pszName);
            pszData += (cch + 1);

            cTotalEntries++;
            pNewAccess++;
        }

        if (*ppAccess != pNewAccess)
        {
            *ppAccess = pNewAccess; // move past new entries
            *ppszData = pszData;
        }
    }

exit_gracefully:

    TraceLeaveValue(cTotalEntries);
}


DWORD WINAPI
CSchemaCache::SchemaClassThread(LPVOID pvThreadData)
{
    PSCHEMACACHE pCache;

    HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);
    InterlockedIncrement(&GLOBAL_REFCOUNT);

    pCache = (PSCHEMACACHE)pvThreadData;
    SetEvent(pCache->m_hLoadLibClassWaitEvent);
    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::SchemaClassThread");
    TraceAssert(pCache != NULL);
    TraceAssert(pCache->m_strSchemaSearchPath != NULL);

#if DBG
    DWORD dwTime = GetTickCount();
#endif

    ThreadCoInitialize();

    pCache->m_hrClassResult = Schema_Search(pCache->m_strSchemaSearchPath,
                                            c_szClassFilter,
                                            &pCache->m_hClassCache,
                                            FALSE);

    ThreadCoUninitialize();

#if DBG
    Trace((TEXT("SchemaClassThread complete, elapsed time: %d ms"), GetTickCount() - dwTime));
#endif

    TraceLeave();

    ASSERT( 0 != GLOBAL_REFCOUNT );
    InterlockedDecrement(&GLOBAL_REFCOUNT);
    FreeLibraryAndExitThread(hInstThisDll, 0);
}


DWORD WINAPI
CSchemaCache::SchemaPropertyThread(LPVOID pvThreadData)
{
    PSCHEMACACHE pCache = NULL;

    HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);
    InterlockedIncrement(&GLOBAL_REFCOUNT);

    pCache = (PSCHEMACACHE)pvThreadData;
    SetEvent(pCache->m_hLoadLibPropWaitEvent);
    TraceEnter(TRACE_SCHEMAPROP, "CSchemaCache::SchemaPropertyThread");
    TraceAssert(pCache != NULL);
    TraceAssert(pCache->m_strSchemaSearchPath != NULL);

#if DBG
    DWORD dwTime = GetTickCount();
#endif

    ThreadCoInitialize();

    pCache->m_hrPropertyResult = Schema_Search(pCache->m_strSchemaSearchPath,
                                               c_szPropertyFilter,
                                               &pCache->m_hPropertyCache,
                                               TRUE);

    ThreadCoUninitialize();

#if DBG
    Trace((TEXT("SchemaPropertyThread complete, elapsed time: %d ms"), GetTickCount() - dwTime));
#endif

    TraceLeave();

    ASSERT( 0 != GLOBAL_REFCOUNT );
    InterlockedDecrement(&GLOBAL_REFCOUNT);
    FreeLibraryAndExitThread(hInstThisDll, 0);

}


HRESULT
CSchemaCache::BuildInheritTypeArray(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    int cItems = 0;
    DWORD cbNames = 0;
    DWORD dwBufferLength;
    PINHERIT_TYPE_ARRAY pInheritTypeArray = NULL;
    PSI_INHERIT_TYPE pNewInheritType;
    LPGUID pGuidData = NULL;
    LPWSTR pszData = NULL;
    WCHAR szFormat[MAX_TYPENAME_LENGTH];
    HDPA hTempList = NULL;
    PTEMP_INFO pti;
    IDsDisplaySpecifier *pDisplaySpec = NULL;

    TraceEnter(TRACE_SCHEMACLASS, "CSchemaCache::BuildInheritTypeArray");
    TraceAssert(m_pInheritTypeArray == NULL);   // Don't want to build this twice

    if (NULL == m_strFilterFile)
        m_strFilterFile = GetFilterFilePath();

    hr = WaitOnClassThread();
    FailGracefully(hr, "Class cache unavailable");

    cItems = DPA_GetPtrCount(m_hClassCache);
    if (cItems == 0)
        ExitGracefully(hr, E_FAIL, "No schema classes available");

    hTempList = DPA_Create(cItems);
    if (!hTempList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create DPA");

    // Get the display specifier object
    CoCreateInstance(CLSID_DsDisplaySpecifier,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IDsDisplaySpecifier,
                     (void**)&pDisplaySpec);

    // Enumerate child types, apply filtering, and get display names
    while (cItems > 0)
    {
        PID_CACHE_ENTRY pCacheEntry;
        WCHAR wszDisplayName[MAX_PATH];

        pCacheEntry = (PID_CACHE_ENTRY)DPA_FastGetPtr(m_hClassCache, --cItems);

        if (!pCacheEntry)
            continue;
        
        if (m_strFilterFile && !(dwFlags & SCHEMA_NO_FILTER))
        {
            DWORD dwFilter = GetPrivateProfileIntW(pCacheEntry->szLdapName,
                                                   c_szClassKey,
                                                   0,
                                                   m_strFilterFile);
            if (dwFilter & IDC_CLASS_NO_INHERIT)
                continue;
        }

        wszDisplayName[0] = L'\0';

        if (pDisplaySpec)
        {
            pDisplaySpec->GetFriendlyClassName(pCacheEntry->szLdapName,
                                               wszDisplayName,
                                               ARRAYSIZE(wszDisplayName));
        }

        if (L'\0' != wszDisplayName[0])
            cbNames += StringByteSize(wszDisplayName);
        else
            cbNames += StringByteSize(pCacheEntry->szLdapName);

        pti = (PTEMP_INFO)LocalAlloc(LPTR, sizeof(TEMP_INFO) + sizeof(WCHAR)*lstrlenW(wszDisplayName));
        if (pti)
        {
            pti->pguid = &pCacheEntry->guid;
            pti->pszLdapName = pCacheEntry->szLdapName;
            lstrcpyW(pti->szDisplayName, wszDisplayName);
            DPA_AppendPtr(hTempList, pti);
        }
    }

    // Sort by display name
    DPA_Sort(hTempList, Schema_CompareTempDisplayName, 0);

    // Get an accurate count
    cItems = DPA_GetPtrCount(hTempList);

    //
    // Allocate a buffer for the inherit type array
    //
    dwBufferLength = sizeof(INHERIT_TYPE_ARRAY) - sizeof(SI_INHERIT_TYPE)
        + sizeof(g_siDSInheritTypes)
        + cItems * (sizeof(SI_INHERIT_TYPE) + sizeof(GUID) + MAX_TYPENAME_LENGTH*sizeof(WCHAR))
        + cbNames;

    pInheritTypeArray = (PINHERIT_TYPE_ARRAY)LocalAlloc(LPTR, dwBufferLength);
    if (pInheritTypeArray == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    pInheritTypeArray->cInheritTypes = ARRAYSIZE(g_siDSInheritTypes);

    pNewInheritType = pInheritTypeArray->aInheritType;
    pGuidData = (LPGUID)(pNewInheritType + pInheritTypeArray->cInheritTypes + cItems);
    pszData = (LPWSTR)(pGuidData + cItems);


    // Copy static entries
    CopyMemory(pNewInheritType, g_siDSInheritTypes, sizeof(g_siDSInheritTypes));
    pNewInheritType += ARRAYSIZE(g_siDSInheritTypes);

    // Load format string
    LoadString(GLOBAL_HINSTANCE,
               IDS_DS_INHERIT_TYPE,
               szFormat,
               ARRAYSIZE(szFormat));

    // Enumerate child types and make an entry for each
    while (cItems > 0)
    {
        int cch;
        LPCWSTR pszDisplayName;

        pti = (PTEMP_INFO)DPA_FastGetPtr(hTempList, --cItems);
        if (!pti)
            continue;

        if (pti->szDisplayName[0])
            pszDisplayName = pti->szDisplayName;
        else
            pszDisplayName = pti->pszLdapName;

        pNewInheritType->dwFlags = CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE;

        // The class entry name is the child class name, e.g. "Domain" or "User"
        pNewInheritType->pszName = pszData;
        cch = wsprintfW(pszData, szFormat, pszDisplayName);
        pszData += (cch + 1);

        pNewInheritType->pguid = pGuidData;
        *pGuidData = *pti->pguid;
        pGuidData++;

        pNewInheritType++;
        pInheritTypeArray->cInheritTypes++;
    }

exit_gracefully:

    DoRelease(pDisplaySpec);

    if (SUCCEEDED(hr))
    {
        m_pInheritTypeArray = pInheritTypeArray;
        // Set this master inherit type array's GUID to null
        m_pInheritTypeArray->guidObjectType = GUID_NULL;
        m_pInheritTypeArray->dwFlags = (dwFlags & SCHEMA_NO_FILTER);
    }
    else if (pInheritTypeArray != NULL)
    {
        LocalFree(pInheritTypeArray);
    }

    DestroyDPA(hTempList);

    TraceLeaveResult(hr);
}


HRESULT
Schema_BindToObject(LPCWSTR pszSchemaPath,
                    LPCWSTR pszName,
                    REFIID riid,
                    LPVOID *ppv)
{   
    TraceEnter(TRACE_SCHEMA, "Schema_BindToObject");
    TraceAssert(pszSchemaPath != NULL);
    TraceAssert(pszName == NULL || *pszName);
    TraceAssert(ppv != NULL);

	 HRESULT hr = S_OK;
    if (pszSchemaPath == NULL)
    {
        ExitGracefully(hr, E_INVALIDARG, "No schema path provided");
    }


	 WCHAR szPath[MAX_PATH];    
    //
    // Build the schema path to this object
    //
    hr = StringCchCopy(szPath, ARRAYSIZE(szPath),pszSchemaPath);
	 FailGracefully(hr, "StringCchCopy Failed");
    
	 //Get the last character 
	 UINT nSchemaRootLen = lstrlenW(pszSchemaPath);
	 WCHAR chTemp = szPath[nSchemaRootLen-1];

    if (pszName != NULL)
    {
        // If there is no trailing slash, add it
        if (chTemp != TEXT('/'))
        {
            hr = StringCchCat(szPath,ARRAYSIZE(szPath),L"/");            
				FailGracefully(hr, "StringCchCat Failed to add /");
        }

		  // Add the class or property name onto the end
		  hr = StringCchCat(szPath,ARRAYSIZE(szPath),pszName);            
		  FailGracefully(hr, "StringCchCat Failed to pszName");

    }
    else if (nSchemaRootLen > 0)
    {
        // If there is a trailing slash, remove it
        if (chTemp == TEXT('/'))
            szPath[nSchemaRootLen-1] = TEXT('\0');
    }
    else
    {
        ExitGracefully(hr, E_INVALIDARG, "Empty schema path");
    }

    //
    // Instantiate the schema object
    //
    ThreadCoInitialize();
    hr = OpenDSObject(szPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION,
                       riid,
                       ppv);

exit_gracefully:

    TraceLeaveResult(hr);
}


HRESULT
Schema_GetObjectID(IADs *pObj, LPGUID pGUID)
{
    HRESULT hr;
    VARIANT varID = {0};

    TraceEnter(TRACE_SCHEMA, "Schema_GetObjectID(IADs*)");
    TraceAssert(pObj != NULL);
    TraceAssert(pGUID != NULL && !IsBadWritePtr(pGUID, sizeof(GUID)));

    // Get the "schemaIDGUID" property
    hr = pObj->Get(AutoBstr(c_szSchemaIDGUID), &varID);

    if (SUCCEEDED(hr))
    {
        LPGUID pID = NULL;

        TraceAssert(V_VT(&varID) == (VT_ARRAY | VT_UI1));
        TraceAssert(V_ARRAY(&varID) && varID.parray->cDims == 1);
        TraceAssert(V_ARRAY(&varID)->rgsabound[0].cElements >= sizeof(GUID));

        hr = SafeArrayAccessData(V_ARRAY(&varID), (LPVOID*)&pID);
        if (SUCCEEDED(hr))
        {
            *pGUID = *pID;
            SafeArrayUnaccessData(V_ARRAY(&varID));
        }
        VariantClear(&varID);
    }

    TraceLeaveResult(hr);
}


HRESULT
Schema_Search(LPWSTR pszSchemaSearchPath,
              LPCWSTR pszFilter,
              HDPA *phCache,
              BOOL bProperty)
{
    HRESULT hr = S_OK;
    HDPA hCache = NULL;
    IDirectorySearch *pSchemaSearch = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCHPREF_INFO prefInfo[3];
    const LPCWSTR pProperties1[] =
    {
        c_szLDAPDisplayName,            // "lDAPDisplayName"
        c_szSchemaIDGUID,               // "schemaIDGUID"
        c_szObjectClassCategory,
    };
    const LPCWSTR pProperties2[] =
    {
        c_szLDAPDisplayName,
        c_szSchemaIDGUID,
        c_szAttributeSecurityGuid,
    };

    TraceEnter(lstrcmp(pszFilter, c_szPropertyFilter) ? TRACE_SCHEMACLASS : TRACE_SCHEMAPROP, "Schema_Search");
    TraceAssert(pszSchemaSearchPath != NULL);
    TraceAssert(phCache != NULL);

    LPCWSTR * pProperties = (LPCWSTR *)( bProperty ? pProperties2 : pProperties1 );
    DWORD dwSize = (DWORD)(bProperty ? ARRAYSIZE(pProperties2) : ARRAYSIZE(pProperties1));
    //
    // Create DPA if necessary
    //
    if (*phCache == NULL)
        *phCache = DPA_Create(100);

    if (*phCache == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create failed");

    hCache = *phCache;

    // Get the schema search object
    hr = OpenDSObject(pszSchemaSearchPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION,
                       IID_IDirectorySearch,
                       (LPVOID*)&pSchemaSearch);
    FailGracefully(hr, "Failed to get schema search object");

    // Set preferences to Asynchronous, Deep search, Paged results
    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = PAGE_SIZE;

    hr = pSchemaSearch->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));

    // Do the search
    hr = pSchemaSearch->ExecuteSearch((LPWSTR)pszFilter,
                                      (LPWSTR*)pProperties,
                                      dwSize,
                                      &hSearch);
    FailGracefully(hr, "IDirectorySearch::ExecuteSearch failed");

    // Loop through the rows, getting the name and ID of each property or class
    for (;;)
    {
        ADS_SEARCH_COLUMN colLdapName;
        ADS_SEARCH_COLUMN colGuid;
        ADS_SEARCH_COLUMN colASGuid;
        LPWSTR pszLdapName;
        LPGUID pID;
        LPGUID pASID;
        INT iObjectClassCategory = 0;
        PID_CACHE_ENTRY pCacheEntry;

        hr = pSchemaSearch->GetNextRow(hSearch);

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS)
            break;

        // Get class/property internal name
        hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szLDAPDisplayName, &colLdapName);
        if (FAILED(hr))
        {
            TraceMsg("lDAPDisplayName not found for class/property");
            continue;
        }

        TraceAssert(colLdapName.dwADsType >= ADSTYPE_DN_STRING
                    && colLdapName.dwADsType <= ADSTYPE_NUMERIC_STRING);
        TraceAssert(colLdapName.dwNumValues == 1);

        pszLdapName = colLdapName.pADsValues->CaseIgnoreString;

        // Get the GUID column
        hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szSchemaIDGUID, &colGuid);
        if (FAILED(hr))
        {
            Trace((TEXT("GUID not found for \"%s\""), pszLdapName));
            pSchemaSearch->FreeColumn(&colLdapName);
            continue;
        }

        // Get GUID from column
        TraceAssert(colGuid.dwADsType == ADSTYPE_OCTET_STRING);
        TraceAssert(colGuid.dwNumValues == 1);
        TraceAssert(colGuid.pADsValues->OctetString.dwLength == sizeof(GUID));

        pID = (LPGUID)(colGuid.pADsValues->OctetString.lpValue);


        pASID = (LPGUID)&GUID_NULL;
        if( bProperty )
        {
            // Get the AttrbiuteSecurityGUID column
            hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szAttributeSecurityGuid, &colASGuid);
            
            if (hr != E_ADS_COLUMN_NOT_SET && FAILED(hr))
            {
                Trace((TEXT("AttributeSecurityGUID not found for \"%s\""), pszLdapName));
                pSchemaSearch->FreeColumn(&colLdapName);
                pSchemaSearch->FreeColumn(&colGuid);
                continue;
            }

            if( hr != E_ADS_COLUMN_NOT_SET )
            {
                // Get GUID from column
                TraceAssert(colASGuid.dwADsType == ADSTYPE_OCTET_STRING);
                TraceAssert(colASGuid.dwNumValues == 1);
                TraceAssert(colASGuid.pADsValues->OctetString.dwLength == sizeof(GUID));

                pASID = (LPGUID)(colASGuid.pADsValues->OctetString.lpValue);
            }
        }
        else
        {
            // Get the c_szObjectClassCategory column
            hr = pSchemaSearch->GetColumn(hSearch, (LPWSTR)c_szObjectClassCategory, &colASGuid);
            
            if (FAILED(hr))
            {
                Trace((TEXT("ObjectClassCategory not found for \"%s\""), pszLdapName));
                pSchemaSearch->FreeColumn(&colLdapName);
                pSchemaSearch->FreeColumn(&colGuid);
                continue;
            }

            // Get GUID from column
            TraceAssert(colASGuid.dwADsType == ADSTYPE_INTEGER);
            TraceAssert(colASGuid.dwNumValues == 1);
            
            iObjectClassCategory = colASGuid.pADsValues->Integer;
        }

        pCacheEntry = (PID_CACHE_ENTRY)LocalAlloc(LPTR,
                                  sizeof(ID_CACHE_ENTRY)
                                  + sizeof(WCHAR)*lstrlenW(pszLdapName));
        if (pCacheEntry != NULL)
        {
            // Copy the item name and ID
            pCacheEntry->guid = *pID;
            pCacheEntry->asGuid = *pASID;
            pCacheEntry->bAuxClass = (iObjectClassCategory == 3);
            lstrcpyW(pCacheEntry->szLdapName, pszLdapName);

            // Insert into cache
            DPA_AppendPtr(hCache, pCacheEntry);
        }
    
        pSchemaSearch->FreeColumn(&colLdapName);
        pSchemaSearch->FreeColumn(&colGuid);
        if(!bProperty || hr != E_ADS_COLUMN_NOT_SET)
        pSchemaSearch->FreeColumn(&colASGuid);
    }

    DPA_Sort(hCache, Schema_CompareLdapName, 0);

exit_gracefully:

    if (hSearch != NULL)
        pSchemaSearch->CloseSearchHandle(hSearch);

    DoRelease(pSchemaSearch);

    if (FAILED(hr))
    {
        DestroyDPA(hCache);
        *phCache = NULL;
    }

    TraceLeaveResult(hr);
}



//+--------------------------------------------------------------------------
//
//  Function:   Schema_GetExtendedRightsForOneClass
//
//  Synopsis:   This Function Gets the Extended Rights for One Class.
//              It Adds all the control rights, validated rights to 
//              phERList. It Adds all the PropertySets to phPropSetList.
//
//  Arguments:  [pszSchemaSearchPath - IN] : Path to schema
//              [pguidClass - In] : Guid Of the class
//              [phERList - OUT] : Get the output Extended Right List
//              [phPropSetList - OUT]: Gets the output PropertySet List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::GetExtendedRightsForOneClass(IN LPWSTR pszSchemaSearchPath,
                                    IN LPCGUID pguidClass,
                                    OUT HDPA *phERList,
                                    OUT HDPA *phPropSetList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetExtendedRightsForOneClass");
    
    if(!pszSchemaSearchPath 
       || !pguidClass 
       || IsEqualGUID(*pguidClass, GUID_NULL)
       || !phERList
       || !phPropSetList)
    {
        Trace((L"Invalid Arguments Passed to Schema_GetExtendedRightsForOneClass"));          
        return E_INVALIDARG; 
    }

    HRESULT hr = S_OK;
    IDirectorySearch *pSearch = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCHPREF_INFO prefInfo[3];
    WCHAR szFilter[100];
    HDPA hExtRightList = NULL;
    HDPA hPropSetList = NULL;
    POBJECT_TYPE_CACHE pOTC = NULL;

    //
    //Search in the cache
    //
    if (m_hObjectTypeCache != NULL)
    {
        UINT cItems = DPA_GetPtrCount(m_hObjectTypeCache);

        while (cItems > 0)
        {
            pOTC = (POBJECT_TYPE_CACHE)DPA_FastGetPtr(m_hObjectTypeCache, --cItems);
            //
            //Found A match.
            //
            if(IsEqualGUID(pOTC->guidObject, *pguidClass))    
                break;
            
            pOTC = NULL;                
        }
        //
        //Have we already got the properties
        //
        if(pOTC && pOTC->flags & OTC_EXTR)
        {
            *phERList = pOTC->hListExtRights;
            *phPropSetList = pOTC->hListPropertySet;
            return S_OK;
        }
    }


    //
    //Attributes to fetch
    //
    const LPCWSTR pProperties[] =
    {
        c_szDisplayName,                // "displayName"
        c_szDisplayID,                  // "localizationDisplayId"
        c_szRightsGuid,                 // "rightsGuid"
        c_szValidAccesses,              // "validAccesses"
    };


    //
    // Build the filter string
    //
    hr = StringCchPrintf(szFilter, ARRAYSIZE(szFilter),c_szERFilterFormat,
              pguidClass->Data1, pguidClass->Data2, pguidClass->Data3,
              pguidClass->Data4[0], pguidClass->Data4[1],
              pguidClass->Data4[2], pguidClass->Data4[3],
              pguidClass->Data4[4], pguidClass->Data4[5],
              pguidClass->Data4[6], pguidClass->Data4[7]);
    FailGracefully(hr, "StringCchPrintf Failed");

    Trace((TEXT("Filter \"%s\""), szFilter));

    //
    // Create DPA to hold results
    //
    hExtRightList = DPA_Create(8);
    

    if (hExtRightList == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create failed");

    hPropSetList = DPA_Create(8);

    if( hPropSetList == NULL )
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create failed");

    //
    // Get the schema search object
    //
    hr = OpenDSObject(pszSchemaSearchPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION,
                       IID_IDirectorySearch,
                       (LPVOID*)&pSearch);
    FailGracefully(hr, "Failed to get schema search object");
    
    //
    // Set preferences to Asynchronous, OneLevel search, Paged results
    //
    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = PAGE_SIZE;

    hr = pSearch->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
    FailGracefully(hr, "IDirectorySearch::SetSearchPreference failed");
    
    //
    // Do the search
    //
    hr = pSearch->ExecuteSearch(szFilter,
                                (LPWSTR*)pProperties,
                                ARRAYSIZE(pProperties),
                                &hSearch);
    FailGracefully(hr, "IDirectorySearch::ExecuteSearch failed");
    
    //
    // Loop through the rows, getting the name and ID of each property or class
    //
    for (;;)
    {
        ADS_SEARCH_COLUMN col;
        GUID guid;
        DWORD dwValidAccesses;
        LPWSTR pszName = NULL;
        WCHAR szDisplayName[MAX_PATH];

        hr = pSearch->GetNextRow(hSearch);

        if (FAILED(hr) || hr == S_ADS_NOMORE_ROWS)
            break;
        
        //
        // Get the GUID
        //
        if (FAILED(pSearch->GetColumn(hSearch, (LPWSTR)c_szRightsGuid, &col)))
        {
            TraceMsg("GUID not found for extended right");
            continue;
        }
        TraceAssert(col.dwADsType >= ADSTYPE_DN_STRING
                    && col.dwADsType <= ADSTYPE_NUMERIC_STRING);
        hr = StringCchPrintf(szFilter, 
                             ARRAYSIZE(szFilter),
                             c_szGUIDFormat, 
                             col.pADsValues->CaseIgnoreString);
        pSearch->FreeColumn(&col);
        if(FAILED(hr))
        {
            continue;
        }
        CLSIDFromString(szFilter, &guid);
        

        //
        // Get the valid accesses mask
        //
        if (FAILED(pSearch->GetColumn(hSearch, (LPWSTR)c_szValidAccesses, &col)))
        {
            TraceMsg("validAccesses not found for Extended Right");
            continue;
        }
        TraceAssert(col.dwADsType == ADSTYPE_INTEGER);
        TraceAssert(col.dwNumValues == 1);
        dwValidAccesses = (DWORD)(DS_GENERIC_ALL & col.pADsValues->Integer);
        pSearch->FreeColumn(&col);
        
        //
        // Get the display name
        //
        szDisplayName[0] = L'\0';
        if (SUCCEEDED(pSearch->GetColumn(hSearch, (LPWSTR)c_szDisplayID, &col)))
        {
            TraceAssert(col.dwADsType == ADSTYPE_INTEGER);
            TraceAssert(col.dwNumValues == 1);
            if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                              g_hInstance,
                              col.pADsValues->Integer,
                              0,
                              szDisplayName,
                              ARRAYSIZE(szDisplayName),
                              NULL))
            {
                pszName = szDisplayName;
            }
            pSearch->FreeColumn(&col);
        }

        if (NULL == pszName &&
            SUCCEEDED(pSearch->GetColumn(hSearch, (LPWSTR)c_szDisplayName, &col)))
        {
            TraceAssert(col.dwADsType >= ADSTYPE_DN_STRING
                        && col.dwADsType <= ADSTYPE_NUMERIC_STRING);
            lstrcpynW(szDisplayName, col.pADsValues->CaseIgnoreString, ARRAYSIZE(szDisplayName));
            pszName = szDisplayName;
            pSearch->FreeColumn(&col);
        }

        if (NULL == pszName)
        {
            TraceMsg("displayName not found for Extended Right");
            continue;
        }

        //
        //Create A new Cache Entry
        //
        PER_ENTRY pER = (PER_ENTRY)LocalAlloc(LPTR, sizeof(ER_ENTRY) + StringByteSize(pszName));
        if( pER == NULL )
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

        pER->guid = guid;
        pER->mask = dwValidAccesses;
        pER->dwFlags = 0;
        lstrcpyW(pER->szName, pszName);
        
        //
        // Is it a Property Set?
        //
        if (dwValidAccesses & (ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP))
        {   
            //         
            // Insert into list
            //
            Trace((TEXT("Adding PropertySet\"%s\""), pszName));
            DPA_AppendPtr(hPropSetList, pER);
            dwValidAccesses &= ~(ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP);            
        }    
        else if (dwValidAccesses)
        {
            //
            // Must be a Control Right, Validated Write, etc.
            //
            Trace((TEXT("Adding Extended Right \"%s\""), pszName));
            DPA_AppendPtr(hExtRightList, pER);
        }
    }

    UINT cCount;
    //
    //Get the count of Extended Rights
    //
    cCount = DPA_GetPtrCount(hExtRightList);    
    if(!cCount)
    {
        DPA_Destroy(hExtRightList);
        hExtRightList = NULL;
    }
    else
    {
        DPA_Sort(hExtRightList, Schema_CompareER, 0);
    }
    //
    //Get the Count of PropertySets
    //
    cCount = DPA_GetPtrCount(hPropSetList);    
    if(!cCount)
    {
        DPA_Destroy(hPropSetList);
        hPropSetList = NULL;
    }
    else
    {
        DPA_Sort(hPropSetList,Schema_CompareER, 0 );
    }

    //
    //Add entry to the cache
    //
    if(!m_hObjectTypeCache)
        m_hObjectTypeCache = DPA_Create(4);
    
    if(!m_hObjectTypeCache)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create Failed");

    if(!pOTC)
    {
        pOTC = (POBJECT_TYPE_CACHE)LocalAlloc(LPTR,sizeof(OBJECT_TYPE_CACHE));
        if(!pOTC)
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc Failed");
        pOTC->guidObject = *pguidClass;
        DPA_AppendPtr(m_hObjectTypeCache, pOTC);
    }

    pOTC->hListExtRights = hExtRightList;
    pOTC->hListPropertySet = hPropSetList;
    pOTC->flags |= OTC_EXTR;


exit_gracefully:

    if (hSearch != NULL)
        pSearch->CloseSearchHandle(hSearch);

    DoRelease(pSearch);

    if (FAILED(hr))
    {
        if(hExtRightList)
        {
            DestroyDPA(hExtRightList);
            hExtRightList = NULL;
        }
        if(hPropSetList)
        {
            DestroyDPA(hPropSetList);
            hPropSetList = NULL;
        }                        
    }

    //
    //Set The Output
    //
    *phERList = hExtRightList;
    *phPropSetList = hPropSetList;

    TraceLeaveResult(hr);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetChildClassesForOneClass
//
//  Synopsis:   This Function Gets the List of child classes for a class.
//
//  Arguments:  [pguidObjectType - IN] : ObjectGuidType of the class
//              [pszClassName - IN] : Class Name
//              [pszSchemaPath - IN] : Schema Search Path
//              [phChildList - OUT]: Output childclass List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------

HRESULT
CSchemaCache::GetChildClassesForOneClass(IN LPCGUID pguidObjectType,
                                         IN LPCWSTR pszClassName,
                                         IN LPCWSTR pszSchemaPath,
                                         OUT HDPA *phChildList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetChildClassesForOneClass");

    HRESULT hr = S_OK;
    BOOL bContainer = FALSE;
    VARIANT varContainment = {0};
    HDPA hClassList = NULL;
    UINT cChildClass = 0;
    POBJECT_TYPE_CACHE pOTC = NULL;

    if(!pguidObjectType || 
       !pszSchemaPath ||
       !phChildList)
    {
        Trace((L"Invalid Input Arguments Passed to Schema_GetExtendedRightsForOneClass"));
        return E_INVALIDARG;
    }

    //
    //Search in the cache
    //
    if (m_hObjectTypeCache != NULL)
    {
        UINT cItems = DPA_GetPtrCount(m_hObjectTypeCache);

        while (cItems > 0)
        {
            pOTC = (POBJECT_TYPE_CACHE)DPA_FastGetPtr(m_hObjectTypeCache, --cItems);
            //
            //Found A match.
            //
            if(IsEqualGUID(pOTC->guidObject, *pguidObjectType))    
                break;

            pOTC = NULL;
        }
        //
        //Have we already got the child classes
        //
        if(pOTC && pOTC->flags & OTC_COBJ)
        {
            *phChildList = pOTC->hListChildObject;
            return S_OK;
        }
    }

    //
    // Lookup the name of this class
    //
    if (pszClassName == NULL)
        pszClassName = GetClassName(pguidObjectType);

    if (pszClassName == NULL)
        ExitGracefully(hr, E_UNEXPECTED, "Unknown child object GUID");

    //
    // Figure out if the object is a container by getting the list of child
    // classes. 
    //
    IADsClass *pDsClass;

    //
    // Get the schema object for this class
    //
    hr = Schema_BindToObject(pszSchemaPath,
                             pszClassName,
                             IID_IADsClass,
                             (LPVOID*)&pDsClass);
    FailGracefully(hr, "Schema_BindToObjectFailed");

    //
    // Get the list of possible child classes
    //
    if (SUCCEEDED(pDsClass->get_Containment(&varContainment)))
    {
        if (V_VT(&varContainment) == (VT_ARRAY | VT_VARIANT))
        {
            LPSAFEARRAY psa = V_ARRAY(&varContainment);
            TraceAssert(psa && psa->cDims == 1);
            if (psa->rgsabound[0].cElements > 0)
            bContainer = TRUE;
        }
        else if (V_VT(&varContainment) == VT_BSTR) // single entry
        {
            TraceAssert(V_BSTR(&varContainment));
            bContainer = TRUE;
        }
                
        //
        // (Requires the schema class enumeration thread to complete first,
        // and it's usually not done yet the first time we get here.)
        //
        if(bContainer)
        {
            hClassList = DPA_Create(8);
            if (hClassList)
            {
                IDsDisplaySpecifier *pDisplaySpec = NULL;
                //
                // Get the display specifier object
                //
                CoCreateInstance(CLSID_DsDisplaySpecifier,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IDsDisplaySpecifier,
                                 (void**)&pDisplaySpec);
                //
                // Filter the list & get display names
                //
                EnumVariantList(&varContainment,
                                hClassList,
                                SCHEMA_CLASS,
                                pDisplaySpec,
                                pszClassName,
                                FALSE);

                DoRelease(pDisplaySpec);

                //
                //Get the count of properties
                //
                cChildClass = DPA_GetPtrCount(hClassList);    
                if(!cChildClass)
                {
                    DPA_Destroy(hClassList);
                    hClassList = NULL;
                }
                else
                {   
                    //
                    //Sort The list
                    //
                    DPA_Sort(hClassList,Schema_ComparePropDisplayName, 0 );
                }
            }
        }
    }
    DoRelease(pDsClass);

    //
    //Add entry to the cache
    //
    if(!m_hObjectTypeCache)
        m_hObjectTypeCache = DPA_Create(4);
    
    if(!m_hObjectTypeCache)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create Failed");

    if(!pOTC)
    {
        pOTC = (POBJECT_TYPE_CACHE)LocalAlloc(LPTR,sizeof(OBJECT_TYPE_CACHE));
        if(!pOTC)
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc Failed");
        pOTC->guidObject = *pguidObjectType;
        DPA_AppendPtr(m_hObjectTypeCache, pOTC);
    }

    pOTC->hListChildObject = hClassList;
    pOTC->flags |= OTC_COBJ;

    


exit_gracefully:

    VariantClear(&varContainment);

    if(FAILED(hr))
    {
        DestroyDPA(hClassList);
        hClassList = NULL;
    }

    //
    //Set the Output
    //
    *phChildList = hClassList;

    TraceLeaveResult(hr);
}


//+--------------------------------------------------------------------------
//
//  Function:   GetPropertiesForOneClass
//
//  Synopsis:   This Function Gets the List of properties for a class.
//
//  Arguments:  [pguidObjectType - IN] : ObjectGuidType of the class
//              [pszClassName - IN] : Class Name
//              [pszSchemaPath - IN] : Schema Search Path
//              [phPropertyList - OUT]: Output Property List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::GetPropertiesForOneClass(IN LPCGUID pguidObjectType,
                                       IN LPCWSTR pszClassName,
                                       IN LPCWSTR pszSchemaPath,
                                       OUT HDPA *phPropertyList)
{
    HRESULT hr;
    IADsClass *pDsClass = NULL;
    VARIANT varMandatoryProperties = {0};
    VARIANT varOptionalProperties = {0};
    UINT cProperties = 0;
    IDsDisplaySpecifier *pDisplaySpec = NULL;
    HDPA hPropertyList = NULL;
    POBJECT_TYPE_CACHE pOTC = NULL;

    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetPropertiesForOneClass");

    if(!pguidObjectType || 
       !pszSchemaPath ||
       !phPropertyList)
    {
        Trace((L"Invalid Input Arguments Passed to CSchemaCache::GetPropertiesForOneClass"));
        return E_INVALIDARG;
    }

    //
    //Search in the cache
    //
    if (m_hObjectTypeCache != NULL)
    {
        UINT cItems = DPA_GetPtrCount(m_hObjectTypeCache);

        while (cItems > 0)
        {
            pOTC = (POBJECT_TYPE_CACHE)DPA_FastGetPtr(m_hObjectTypeCache, --cItems);
            //
            //Found A match.
            //
            if(IsEqualGUID(pOTC->guidObject, *pguidObjectType))    
                break;
            
            pOTC = NULL;
        }
        //
        //Have we already got the properties
        //
        if(pOTC && pOTC->flags & OTC_PROP)
        {
            *phPropertyList = pOTC->hListProperty;
            return S_OK;
        }
    }


    //
    // Get the schema object for this class
    //
    if (pszClassName == NULL)
        pszClassName = GetClassName(pguidObjectType);

    if (pszClassName == NULL)
        ExitGracefully(hr, E_UNEXPECTED, "Unknown child object GUID");

    hr = Schema_BindToObject(pszSchemaPath,
                             pszClassName,
                             IID_IADsClass,
                             (LPVOID*)&pDsClass);
    FailGracefully(hr, "Unable to create schema object");

    //
    // Get the display specifier object
    //
    CoCreateInstance(CLSID_DsDisplaySpecifier,
                     NULL,
                     CLSCTX_INPROC_SERVER,
                     IID_IDsDisplaySpecifier,
                     (void**)&pDisplaySpec);

    hPropertyList = DPA_Create(8);
    if (!hPropertyList)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create DPA");

    //
    // Get mandatory and optional property lists
    //
    if (SUCCEEDED(pDsClass->get_MandatoryProperties(&varMandatoryProperties)))
    {
        EnumVariantList(&varMandatoryProperties,
                        hPropertyList,
                        0,
                        pDisplaySpec,
                        pszClassName,
                        FALSE);
    }
    if (SUCCEEDED(pDsClass->get_OptionalProperties(&varOptionalProperties)))
    {
        EnumVariantList(&varOptionalProperties,
                        hPropertyList,
                        0,
                        pDisplaySpec,
                        pszClassName,
                        FALSE);
    }

    //
    //Get the Number of properties
    //
    cProperties = DPA_GetPtrCount(hPropertyList);    
    if(!cProperties)
    {
        DPA_Destroy(hPropertyList);
        hPropertyList = NULL;
    }
    else
    {
        //
        //Sort The list
        //
        DPA_Sort(hPropertyList,Schema_ComparePropDisplayName, 0 );
    }

    //
    //Add entry to the cache
    //
    if(!m_hObjectTypeCache)
        m_hObjectTypeCache = DPA_Create(4);
    
    if(!m_hObjectTypeCache)
        ExitGracefully(hr, E_OUTOFMEMORY, "DPA_Create Failed");

    if(!pOTC)
    {
        pOTC = (POBJECT_TYPE_CACHE)LocalAlloc(LPTR,sizeof(OBJECT_TYPE_CACHE));
        if(!pOTC)
            ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc Failed");
        pOTC->guidObject = *pguidObjectType;
        DPA_AppendPtr(m_hObjectTypeCache, pOTC);
    }

    pOTC->hListProperty = hPropertyList;
    pOTC->flags |= OTC_PROP;

exit_gracefully:

    VariantClear(&varMandatoryProperties);
    VariantClear(&varOptionalProperties);
    
    DoRelease(pDsClass);
    DoRelease(pDisplaySpec);

    if(FAILED(hr) && hPropertyList)
    {
        DestroyDPA(hPropertyList);
        hPropertyList = NULL;
    }
    //
    //Set the Output
    //
    *phPropertyList = hPropertyList;

    TraceLeaveResult(hr);
}
//+--------------------------------------------------------------------------
//
//  Function:   GetExtendedRightsForNClasses
//
//  Synopsis:   
//              This function gets the ExtendedRigts(control rights,
//              validated rights) and PropertySets for pszClassName and
//              all the classes in AuxTypeList. 
//              Function Merges Extended Rights of all the classes in to a 
//              signle list form which duplicates are removed and list 
//              is sorted.
//              Function Merges PropertySets of all the classes in to a 
//              signle list form which duplicates are removed and list 
//              is sorted.
//
//  Arguments:  [pguidClass - IN] : ObjectGuidType of the class
//              [hAuxList - IN]:List of Auxillary Classes
//              [pszSchemaSearchPath - IN] : Schema Search Path
//              [phERList - OUT]: Output Extended Rights list
//              [phPropSetList - OUT]: Output Propset List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//  Note:       Calling function must call DPA_Destroy on *phERList and *phPropSetList
//              to Free the memory
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::GetExtendedRightsForNClasses(IN LPWSTR pszSchemaSearchPath,
                                           IN LPCGUID pguidClass,
                                           IN HDPA    hAuxList,
                                           OUT HDPA *phERList,
                                           OUT HDPA *phPropSetList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetExtendedRightsForNClasses");

    if(!pguidClass || 
       !pszSchemaSearchPath)
    {
        Trace((L"Invalid Input Arguments Passed to CSchemaCache::GetPropertiesForNClasses"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    HDPA hERList = NULL;
    HDPA hPropSetList = NULL;
    HDPA hFinalErList = NULL;
    HDPA hFinalPropSetList = NULL;

    //
    //Get the extended rights for pguidClass
    //
    hr = GetExtendedRightsForOneClass(pszSchemaSearchPath,
                                      pguidClass,
                                      &hERList,
                                      &hPropSetList);
    FailGracefully(hr,"GetExtendedRightsForOneClasses failed");

    if(hERList && phERList)
    {
        UINT cCount = DPA_GetPtrCount(hERList);
        hFinalErList = DPA_Create(cCount);
        if(!hFinalErList)
            ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
        //
        //Copy hERList to hFinalErList
        //
        DPA_Merge(hFinalErList,             //Destination
                  hERList,                  //Source
                  DPAM_SORTED|DPAM_UNION,   //Already Sorted And give me union
                  Schema_CompareER,
                  _Merge,
                  0);        
    }                    

    if(hPropSetList && phPropSetList)
    {
        UINT cCount = DPA_GetPtrCount(hPropSetList);
        hFinalPropSetList = DPA_Create(cCount);
        if(!hFinalPropSetList)
            ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");

        //
        //Copy hPropSetList to hFinalPropSetList
        //
        DPA_Merge(hFinalPropSetList,             //Destination
                  hPropSetList,                  //Source
                  DPAM_SORTED|DPAM_UNION,   //Already Sorted And give me union
                  Schema_CompareER,
                  _Merge,
                  0);        
    }                    
    //
    //For each auxclass get the extended rights
    //and property sets
    //
    if (hAuxList != NULL)
    {

        UINT cItems = DPA_GetPtrCount(hAuxList);

        while (cItems > 0)
        {
            PAUX_INFO pAI;
            pAI = (PAUX_INFO)DPA_FastGetPtr(hAuxList, --cItems);
            if(IsEqualGUID(pAI->guid, GUID_NULL))
            {
                hr = LookupClassID(pAI->pszClassName, &pAI->guid);
				FailGracefully(hr,"Cache Not available");
            }
            
            hERList = NULL;
            hPropSetList = NULL;
            //
            //Get the ER and PropSet for AuxClass
            //
            hr = GetExtendedRightsForOneClass(pszSchemaSearchPath,
                                              &pAI->guid,
                                              &hERList,
                                              &hPropSetList);
            FailGracefully(hr,"GetExtendedRightsForOneClasses failed");
                        
            if(hERList && phERList)
            {
                if(!hFinalErList)
                {
                    UINT cCount = DPA_GetPtrCount(hERList);
                    hFinalErList = DPA_Create(cCount);

                    if(!hFinalErList)
                        ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
                }
        
                //
                //Merge hERList into hFinalErList
                //
                DPA_Merge(hFinalErList,             //Destination
                          hERList,                  //Source
                          DPAM_SORTED|DPAM_UNION,   //Already Sorted And give me union
                          Schema_CompareER,
                          _Merge,
                          0);        
            }                    
            
            if(hPropSetList && phPropSetList)
            {
                if(!hFinalPropSetList)
                {
                    UINT cCount = DPA_GetPtrCount(hPropSetList);
                    hFinalPropSetList = DPA_Create(cCount);

                    if(!hFinalPropSetList)
                        ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
                }

                //
                //Merge hPropSetList into hFinalPropSetList
                //        
                DPA_Merge(hFinalPropSetList,             //Destination
                          hPropSetList,                  //Source
                          DPAM_SORTED|DPAM_UNION,   //Already Sorted And give me union
                          Schema_CompareER,
                          _Merge,
                          0);        
            }                    

        }
    }

exit_gracefully:
    if(FAILED(hr))
    {
        if(hFinalPropSetList)
            DPA_Destroy(hFinalPropSetList);    

        if(hFinalErList)
            DPA_Destroy(hFinalErList);    

        hFinalErList = NULL;
        hFinalPropSetList = NULL;
    }
    
    if(phERList)
        *phERList = hFinalErList;
    if(phPropSetList)
        *phPropSetList = hFinalPropSetList;                     
    
    TraceLeaveResult(hr);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetChildClassesForNClasses
//
//  Synopsis:   
//              This function gets the childclasses for pszClassName and
//              all the classes in AuxTypeList. Function Merges child clasess
//              of all the classes in to a signle list form which duplicates 
//              are removed and list is sorted
//
//  Arguments:  [pguidObjectType - IN] : ObjectGuidType of the class
//              [pszClassName - IN] : Class Name
//              [hAuxList - IN]:List of Auxillary Classes
//              [pszSchemaPath - IN] : Schema Search Path
//              [phChildList - OUT]: Output Child Classes List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//  Note:       Calling function must call DPA_Destroy on *phPropertyList to
//              Free the memory
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::GetChildClassesForNClasses(IN LPCGUID pguidObjectType,
                                             IN LPCWSTR pszClassName,
                                             IN HDPA hAuxList,
                                             IN LPCWSTR pszSchemaPath,
                                             OUT HDPA *phChildList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetChildClassesForNClasses");

    if(!pguidObjectType || 
       !pszSchemaPath ||
       !phChildList)
    {
        Trace((L"Invalid Input Arguments Passed to CSchemaCache::GetPropertiesForNClasses"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    HDPA hChildList = NULL;
    HDPA hFinalChildList = NULL;

    //
    //Get the Child Classes for pszClassName
    //
    hr = GetChildClassesForOneClass(pguidObjectType,
                                    pszClassName,
                                    pszSchemaPath,
                                    &hChildList);
    FailGracefully(hr,"GetExtendedRightsForOneClasses failed");

    if(hChildList)
    {
        if(!hFinalChildList)
        {
            UINT cCount = DPA_GetPtrCount(hChildList);
            hFinalChildList = DPA_Create(cCount);
            if(!hFinalChildList)
                ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
        }
        //
        //Copy hChildList to hFinalChildList
        //
        DPA_Merge(hFinalChildList,             //Destination
                  hChildList,                  //Source
                  DPAM_SORTED|DPAM_UNION,      //Already Sorted And give me union
                  Schema_ComparePropDisplayName,
                  _Merge,
                  0);        
    }                    

    //
    //For each class in hAuxList get the child classes
    //
    if (hAuxList != NULL)
    {

        UINT cItems = DPA_GetPtrCount(hAuxList);

        while (cItems > 0)
        {
            PAUX_INFO pAI;
            pAI = (PAUX_INFO)DPA_FastGetPtr(hAuxList, --cItems);
            if(IsEqualGUID(pAI->guid, GUID_NULL))
            {
                hr = LookupClassID(pAI->pszClassName, &pAI->guid);
				FailGracefully(hr,"Cache Not available");
            }
            
            //
            //GetPropertiesForOneClass returns the list of handles
            //from cache so don't delete them. Simply set them to NULL
            //
            hChildList = NULL;
            
            hr = GetChildClassesForOneClass(&pAI->guid,
                                            pAI->pszClassName,
                                            pszSchemaPath,
                                            &hChildList);
            FailGracefully(hr,"GetExtendedRightsForOneClasses failed");
                        
            if(hChildList)
            {
                if(!hFinalChildList)
                {
                    UINT cCount = DPA_GetPtrCount(hChildList);
                    hFinalChildList = DPA_Create(cCount);
                    if(!hFinalChildList)
                        ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
                }
        
                //
                //Merge hChildList into hFinalChildList
                //
                DPA_Merge(hFinalChildList,             //Destination
                          hChildList,                  //Source
                          DPAM_SORTED|DPAM_UNION,      //Already Sorted And give me union
                          Schema_ComparePropDisplayName,
                          _Merge,
                          0);        
            }                    

        }
    }

exit_gracefully:
    if(FAILED(hr))
    {
        if(hFinalChildList)
            DPA_Destroy(hFinalChildList);    

        hFinalChildList = NULL;
    }
    
    //
    //Set the output
    //
    *phChildList = hFinalChildList;                     

    TraceLeaveResult(hr);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetPropertiesForNClasses
//
//  Synopsis:   
//              This function gets the properties for pszClassName and
//              all the classes in AuxTypeList. Function Merges properties
//              of all the classes in to a signle list form which duplicates 
//
//  Arguments:  [pguidObjectType - IN] : ObjectGuidType of the class
//              [pszClassName - IN] : Class Name
//              [hAuxList - IN]:List of Auxillary Classes
//              [pszSchemaPath - IN] : Schema Search Path
//              [phPropertyList - OUT]: Output Property List
//
//  Returns:    HRESULT : S_OK if everything succeeded
//                        E_INVALIDARG if the object entry wasn't found
//  Note:       Calling function must call DPA_Destroy on *phPropertyList to
//              Free the memory
//
//  History:    3-Nov 2000  hiteshr   Created
//
//---------------------------------------------------------------------------
HRESULT
CSchemaCache::
GetPropertiesForNClasses(IN LPCGUID pguidObjectType,
                         IN LPCWSTR pszClassName,
                         IN HDPA hAuxList,
                         IN LPCWSTR pszSchemaPath,
                         OUT HDPA *phPropertyList)
{
    TraceEnter(TRACE_SCHEMA, "CSchemaCache::GetPropertiesForNClasses");

    if(!pguidObjectType || 
       !pszSchemaPath ||
       !phPropertyList)
    {
        Trace((L"Invalid Input Arguments Passed to CSchemaCache::GetPropertiesForNClasses"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    HDPA hPropertyList = NULL;
    HDPA hFinalPropertyList = NULL;

    //
    //Get The properties for pszClassName
    //
    hr = GetPropertiesForOneClass(pguidObjectType,
                                  pszClassName,
                                  pszSchemaPath,
                                  &hPropertyList);
    FailGracefully(hr,"GetPropertiesForOneClass failed");

    if(hPropertyList)
    {
        UINT cCount = DPA_GetPtrCount(hPropertyList);
        hFinalPropertyList = DPA_Create(cCount);
        if(!hFinalPropertyList)
            ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");

        //
        //Copy hPropertyList to hFinalPropertyList. 
        //
        DPA_Merge(hFinalPropertyList,             //Destination
                  hPropertyList,                  //Source
                  DPAM_SORTED|DPAM_UNION,         //Already Sorted And give me union
                  Schema_ComparePropDisplayName,
                  _Merge,
                  0);        
    }                    

    //
    //Get the properties for each class in hAuxList 
    //and add them to hFinalPropertyList
    //
    if (hAuxList != NULL)
    {

        UINT cItems = DPA_GetPtrCount(hAuxList);

        while (cItems > 0)
        {
            PAUX_INFO pAI;
            pAI = (PAUX_INFO)DPA_FastGetPtr(hAuxList, --cItems);
            if(IsEqualGUID(pAI->guid, GUID_NULL))
            {
                hr = LookupClassID(pAI->pszClassName, &pAI->guid);
				FailGracefully(hr,"Cache Not available");
            }
           
            //
            //GetPropertiesForOneClass returns the list of handles
            //from cache so don't delete them. Simply set them to NULL
            //
            hPropertyList = NULL;
            
            //
            //Get properties for Aux Class
            //
            hr = GetPropertiesForOneClass(&pAI->guid,
                                          pAI->pszClassName,
                                          pszSchemaPath,
                                          &hPropertyList);
            FailGracefully(hr,"GetExtendedRightsForOneClasses failed");
                        
            if(hPropertyList)
            {
                if(!hFinalPropertyList)
                {
                    UINT cCount = DPA_GetPtrCount(hPropertyList);
                    hFinalPropertyList = DPA_Create(cCount);
                    if(!hFinalPropertyList)
                        ExitGracefully(hr, ERROR_NOT_ENOUGH_MEMORY,"DPA_Create Failed");
                }
                //
                //Merge hPropertyList with hFinalPropertyList
                //
                DPA_Merge(hFinalPropertyList,             //Destination
                          hPropertyList,                  //Source
                          DPAM_SORTED|DPAM_UNION,         //Already Sorted And give me union
                          Schema_ComparePropDisplayName,
                          _Merge,
                          0);        
            }                    

        }
    }

exit_gracefully:
    if(FAILED(hr))
    {
        if(hFinalPropertyList)
            DPA_Destroy(hFinalPropertyList);    

        hFinalPropertyList = NULL;
    }
    //
    //Set the Output
    //
    *phPropertyList = hFinalPropertyList;                     

    TraceLeaveResult(hr);
}


//+--------------------------------------------------------------------------
//
//  Function:   DoesPathContainServer
//
//  Synopsis:   
//              Checks if the path contain server name in begining
//  Arguments:  [pszPath - IN] : Path to DS object
//
//  Returns:    BOOL: true if path contain server name
//                    false if not or error occurs    
//
//  History:    27 March 2000  hiteshr   Created
//
//---------------------------------------------------------------------------

bool DoesPathContainServer(LPCWSTR pszPath)
{

	IADsPathname *pPath = NULL;
	BSTR strServerName = NULL;
	bool bReturn = false;
    
	BSTR strObjectPath = SysAllocString(pszPath);
	if(!strObjectPath)
		return false;


	//
	// Create an ADsPathname object to parse the path and get the
	// server name 
	//
	HRESULT hr = CoCreateInstance(CLSID_Pathname,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IADsPathname,
								  (LPVOID*)&pPath);
	if (pPath)
	{
		//
		//Set Full Path
		//
		if (SUCCEEDED(pPath->Set(strObjectPath, ADS_SETTYPE_FULL)))
		{
			//
			//Retrieve servername
			//
			hr = pPath->Retrieve(ADS_FORMAT_SERVER, &strServerName);
			if(SUCCEEDED(hr) && strServerName)
			{
				bReturn = true;
			}
		}
	}
	
	DoRelease(pPath);
	if(strServerName)
		SysFreeString(strServerName);
	SysFreeString(strObjectPath);

	return bReturn;
}

//*************************************************************
//
//  OpenDSObject()
//
//  Purpose:    Calls AdsOpenObject with ADS_SERVER_BIND
//  Return:		Same as AdsOpenObject
//
//*************************************************************

HRESULT OpenDSObject (LPTSTR lpPath, LPTSTR lpUserName, LPTSTR lpPassword, DWORD dwFlags, REFIID riid, void FAR * FAR * ppObject)
{
    static DWORD additionalFlags = GetADsOpenObjectFlags();
    dwFlags |= additionalFlags;

    if (DoesPathContainServer(lpPath))
    {
        dwFlags |= ADS_SERVER_BIND;
    }

    return (ADsOpenObject(lpPath, lpUserName, lpPassword, dwFlags,
                          riid, ppObject));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\iids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       iids.h
//
//--------------------------------------------------------------------------

// CLSID_DsSecurity {4E40F770-369C-11d0-8922-00A024AB2DBB}
DEFINE_GUID(CLSID_DsSecurity, 0x4e40f770, 0x369c, 0x11d0, 0x89, 0x22, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\security.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       security.h
//
//--------------------------------------------------------------------------

#ifndef __security_h
#define __security_h


/*-----------------------------------------------------------------------------
/ CDsSecurityClassFactory
/----------------------------------------------------------------------------*/

class CDsSecurityClassFactory : public IClassFactory, CUnknown
{
public:
    // IUnkown
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP         QueryInterface(REFIID riid, LPVOID* ppvObject);

    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown* pOuter, REFIID riid, LPVOID* ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);
};


/*-----------------------------------------------------------------------------
/ CDsSecurity
/----------------------------------------------------------------------------*/

class CDsSecurity : public IShellExtInit, IShellPropSheetExt, IContextMenu, CUnknown
{
private:
    LPSECURITYINFO m_pSI;

public:
    virtual ~CDsSecurity();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID);

    // IShellPropSheetExt methods
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHODIMP ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hShellMenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi);
    STDMETHODIMP GetCommandString( UINT_PTR idCmd, UINT uFlags, UINT FAR* reserved, LPSTR pszName, UINT ccMax);
};


#endif  // __security_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\schemap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       schemap.h
//
//--------------------------------------------------------------------------

#ifndef _SCHEMAP_H_
#define _SCHEMAP_H_


//
//Purpose contains all the attributes of an objecttype
//
typedef struct _OBJECT_TYPE_CACHE
{
    GUID guidObject;
    DWORD flags;
    HDPA hListProperty;     //List of Property of the objecttype
    HDPA hListExtRights;    //List of Extended Rights of the objecttype   
    HDPA hListPropertySet;  //List of PropertySet of the objecttype
    HDPA hListChildObject;  //List of Child Classes of the objecttype
}OBJECT_TYPE_CACHE,*POBJECT_TYPE_CACHE;

#define OTC_PROP    0x00000001  //hListProperty is present.
#define OTC_EXTR    0x00000002  //hListExtRights,hListPropertySet is present
#define OTC_COBJ    0x00000004  //hListChildObject is present

typedef struct _ER_ENTRY
{
    GUID  guid;
    DWORD mask;
    DWORD dwFlags;
    WCHAR szName[ANYSIZE_ARRAY];
} ER_ENTRY, *PER_ENTRY;

typedef struct _PROP_ENTRY
{
    GUID *pguid;
    GUID *pasguid;
    DWORD dwFlags;
    WCHAR szName[ANYSIZE_ARRAY];
}PROP_ENTRY,*PPROP_ENTRY;
    

//
// Structures used by the cache
//
typedef struct _IdCacheEntry
{
    GUID    guid;
    GUID    asGuid;     //attributeSecurityGuid, Present only for properties.
    BOOL    bAuxClass;
    WCHAR   szLdapName[ANYSIZE_ARRAY];
} ID_CACHE_ENTRY, *PID_CACHE_ENTRY;


typedef struct _InheritTypeArray
{
    GUID            guidObjectType;
    DWORD           dwFlags;
    ULONG           cInheritTypes;
    SI_INHERIT_TYPE aInheritType[ANYSIZE_ARRAY];
} INHERIT_TYPE_ARRAY, *PINHERIT_TYPE_ARRAY;

typedef struct _AccessArray
{
    GUID        guidObjectType;
    DWORD       dwFlags;
    ULONG       cAccesses;
    ULONG       iDefaultAccess;
    SI_ACCESS   aAccess[ANYSIZE_ARRAY];
} ACCESS_ARRAY, *PACCESS_ARRAY;



//
// CSchemaCache object definition
//
class CSchemaCache
{
protected:
    BSTR        m_strSchemaSearchPath;
    BSTR        m_strERSearchPath;
    BSTR        m_strFilterFile;
    
    //
    //Cache of all classes in schema
    //
    HDPA        m_hClassCache;
    //
    //Cache of all attributes in schema
    //
    HDPA        m_hPropertyCache;
    HANDLE      m_hClassThread;
    HANDLE      m_hPropertyThread;
    HRESULT     m_hrClassResult;
    HRESULT     m_hrPropertyResult;
    
    PINHERIT_TYPE_ARRAY m_pInheritTypeArray;
    //
    //Cache for each objecttype. Contains lists of 
    //childclasses, propsets, extRigts, & properties
    //
    //
    HDPA        m_hObjectTypeCache;
    //
    //Cache of ACCESS_RIGHT for each object type
    //
    HDPA        m_hAccessInfoCache;
    //
    //This ACCESS_RIGHT is used if SCHEMA_COMMON_PERM flag is present
    //
    ACCESS_INFO m_AICommon;

    CRITICAL_SECTION m_ObjectTypeCacheCritSec;
    int         m_nDsListObjectEnforced;    
    HANDLE      m_hLoadLibPropWaitEvent;
    HANDLE      m_hLoadLibClassWaitEvent;
    AUTHZ_RESOURCE_MANAGER_HANDLE m_ResourceManager;    //Used for access check

public:
    CSchemaCache(LPCWSTR pszServer);
    ~CSchemaCache();

    LPCWSTR GetClassName(LPCGUID pguidObjectType);
    HRESULT GetInheritTypes(LPCGUID pguidObjectType,
                            DWORD dwFlags,
                            PSI_INHERIT_TYPE *ppInheritTypes,
                            ULONG *pcInheritTypes);
    HRESULT GetAccessRights(LPCGUID pguidObjectType,
                            LPCWSTR pszClassName,
                            HDPA pAuxList,
                            LPCWSTR pszSchemaPath,
                            DWORD dwFlags,
                            PACCESS_INFO* ppAccesInfo);
    HRESULT GetDefaultSD( GUID *pSchemaIDGuid,
                          PSID pDomainSid,
						  PSID pRootDomainSid,
                          PSECURITY_DESCRIPTOR * ppSD = NULL );

    HRESULT GetObjectTypeList(GUID *pSchamaGuid,
                              HDPA hAuxList,  
                              LPCWSTR pszSchemaPath,
                              DWORD dwFlags,
                              POBJECT_TYPE_LIST *ppObjectTypeList ,
                              DWORD * pObjectTypeListCount );
    AUTHZ_RESOURCE_MANAGER_HANDLE GetAuthzRM(){ return m_ResourceManager; }

    HRESULT LookupClassID(LPCWSTR pszClass, LPGUID pGuid);
protected:
    HRESULT WaitOnClassThread()
        { WaitOnThread(&m_hClassThread); return m_hrClassResult; }
    HRESULT WaitOnPropertyThread()
        { WaitOnThread(&m_hPropertyThread); return m_hrPropertyResult; }

private:
    PID_CACHE_ENTRY LookupID(HDPA hCache, LPCWSTR pszLdapName);
    PID_CACHE_ENTRY LookupClass(LPCGUID pguidObjectType);    
    LPCGUID LookupPropertyID(LPCWSTR pszProperty);
    BOOL IsAuxClass(LPCGUID pguidObjectType);

    int GetListObjectEnforced(void);
    BOOL HideListObjectAccess(void);

    HRESULT BuildAccessArray(LPCGUID pguidObjectType,
                             LPCWSTR pszClassName,
                             LPCWSTR pszSchemaPath,
                             HDPA hAuxList,
                             DWORD dwFlags,
                             PSI_ACCESS *ppAccesses,
                             ULONG *pcAccesses,
                             ULONG *piDefaultAccess);
    HRESULT EnumVariantList(LPVARIANT pvarList,
                            HDPA hTempList,
                            DWORD dwFlags,
                            IDsDisplaySpecifier *pDisplaySpec,
                            LPCWSTR pszPropertyClass,
                            BOOL bObjectTypeList);
    
    UINT AddTempListToAccessList(HDPA hTempList,
                                      PSI_ACCESS *ppAccess,
                                      LPWSTR *ppszData,
                                      DWORD dwAccessFlags,
                                      DWORD dwFlags,
                                      BOOL bPropSet);


    static DWORD WINAPI SchemaClassThread(LPVOID pvThreadData);
    static DWORD WINAPI SchemaPropertyThread(LPVOID pvThreadData);

    HRESULT BuildInheritTypeArray(DWORD dwFlags);

    HRESULT
    GetExtendedRightsForNClasses(IN LPWSTR pszSchemaSearchPath,
                                 IN LPCGUID pguidClass,
                                 IN HDPA    hAuxList,
                                 OUT HDPA *phERList,
                                 OUT HDPA *phPropSetList);


    HRESULT
    GetChildClassesForNClasses(IN LPCGUID pguidObjectType,
                               IN LPCWSTR pszClassName,
                               IN HDPA hAuxList,
                               IN LPCWSTR pszSchemaPath,
                               OUT HDPA *phChildList);

    HRESULT
    GetPropertiesForNClasses(IN LPCGUID pguidObjectType,
                             IN LPCWSTR pszClassName,
                             IN HDPA hAuxList,
                             IN LPCWSTR pszSchemaPath,
                             OUT HDPA *phPropertyList);


    HRESULT
    GetExtendedRightsForOneClass(IN LPWSTR pszSchemaSearchPath,
                                 IN LPCGUID pguidClass,
                                 OUT HDPA *phERList,
                                 OUT HDPA *phPropSetList);


    HRESULT
    GetChildClassesForOneClass(IN LPCGUID pguidObjectType,
                               IN LPCWSTR pszClassName,
                               IN LPCWSTR pszSchemaPath,
                               OUT HDPA *phChildList);

    HRESULT
    GetPropertiesForOneClass(IN LPCGUID pguidObjectType,
                             IN LPCWSTR pszClassName,
                             IN LPCWSTR pszSchemaPath,
                             OUT HDPA *phPropertyList);


};
typedef CSchemaCache *PSCHEMACACHE;

extern PSCHEMACACHE g_pSchemaCache;

#endif  // _SCHEMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\security.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       security.cpp
//
//  Invoke the security UI for DS objects
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <dssec.h>


/*-----------------------------------------------------------------------------
/ CDsSecurityClassFactory
/   Class factory for the Security property page and context menu
/----------------------------------------------------------------------------*/

#undef CLASS_NAME
#define CLASS_NAME CDsSecurityClassFactory
#include <unknown.inc>

STDMETHODIMP
CDsSecurityClassFactory::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IClassFactory, (LPCLASSFACTORY)this,
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*-----------------------------------------------------------------------------
/ IClassFactory methods
/----------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurityClassFactory::CreateInstance(LPUNKNOWN punkOuter,
                                        REFIID riid,
                                        LPVOID* ppvObject)
{
    HRESULT hr;
    CDsSecurity* pDsSecurity;

    TraceEnter(TRACE_SECURITY, "CDsSecurityClassFactory::CreateInstance");
    TraceGUID("Interface requested", riid);

    TraceAssert(ppvObject);

    if (punkOuter)
        ExitGracefully(hr, CLASS_E_NOAGGREGATION, "Aggregation is not supported");

    pDsSecurity = new CDsSecurity;

    if (!pDsSecurity)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate CDsSecurity");

    hr = pDsSecurity->QueryInterface(riid, ppvObject);

    if (FAILED(hr))
        delete pDsSecurity;

exit_gracefully:

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurityClassFactory::LockServer(BOOL /*fLock*/)
{
    return E_NOTIMPL;               // not supported
}


/*-----------------------------------------------------------------------------
/ CDsSecurity
/   Security property page and context menu shell extension
/----------------------------------------------------------------------------*/

// Destructor

CDsSecurity::~CDsSecurity()
{
    DoRelease(m_pSI);
}

// IUnknown bits

#undef CLASS_NAME
#define CLASS_NAME CDsSecurity
#include "unknown.inc"

STDMETHODIMP
CDsSecurity::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IShellExtInit, (LPSHELLEXTINIT)this,
        &IID_IShellPropSheetExt, (LPSHELLPROPSHEETEXT)this,
        &IID_IContextMenu, (LPCONTEXTMENU)this,
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*----------------------------------------------------------------------------
/ IShellExtInit
/----------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::Initialize(LPCITEMIDLIST /*pIDFolder*/,
                        LPDATAOBJECT pDataObj,
                        HKEY /*hKeyID*/)
{
    HRESULT hr;
    FORMATETC fe = {0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medObjectNames = {0};
    STGMEDIUM medDisplayOptions = {0};
    LPDSOBJECTNAMES pDsObjects;
    LPWSTR pObjectPath;
    LPWSTR pClass = NULL;
    DWORD dwFlags = 0;
    LPWSTR pszServer = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    static CLIPFORMAT cfDsObjectNames = 0;
    static CLIPFORMAT cfDsDisplayOptions = 0;

    TraceEnter(TRACE_SECURITY, "CDsSecurity::Initialize");

    DoRelease(m_pSI);

    // Call the data object to get the array of DS names and classes.  This
    // is stored using a private clipboard format - so we must first
    // try and register it.

    if (!cfDsObjectNames)
        cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);

    if (!cfDsObjectNames)
        ExitGracefully(hr, E_FAIL, "Clipboard format failed to register");

    fe.cfFormat = cfDsObjectNames;            // set the clipboard format

    if (!pDataObj)
        ExitGracefully(hr, E_INVALIDARG, "No data object given");

    hr = pDataObj->GetData(&fe, &medObjectNames);
    FailGracefully(hr, "Failed to get selected objects");

    pDsObjects = (LPDSOBJECTNAMES)medObjectNames.hGlobal;
    TraceAssert(pDsObjects);

    if (!(pDsObjects->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED))
        ExitGracefully(hr, E_FAIL, "Security page only shown in advanced mode");

    if (1 != pDsObjects->cItems)
        ExitGracefully(hr, E_FAIL, "Multiple selection not supported");

    // Get the object path
    pObjectPath = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetName);
    Trace((TEXT("Name \"%s\""), pObjectPath));

    // Get the class name
    if (pDsObjects->aObjects[0].offsetClass)
    {
        pClass = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetClass);
        Trace((TEXT("Class \"%s\""), pClass));
    }

// DSOBJECT_READONLYPAGES is no longer used
#ifdef DSOBJECT_READONLYPAGES
    if (pDsObjects->aObjects[0].dwFlags & DSOBJECT_READONLYPAGES)
        dwFlags = DSSI_READ_ONLY;
#endif

    //
    // Get server name and user credentials from the data object
    //
    if (!cfDsDisplayOptions)
        cfDsDisplayOptions = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_DISPLAY_SPEC_OPTIONS);
    if (cfDsDisplayOptions)
    {
        fe.cfFormat = cfDsDisplayOptions;
        hr = pDataObj->GetData(&fe, &medDisplayOptions);
        if (SUCCEEDED(hr))
        {
            LPDSDISPLAYSPECOPTIONS pDisplayOptions = (LPDSDISPLAYSPECOPTIONS)medDisplayOptions.hGlobal;

            if (pDisplayOptions->dwFlags & DSDSOF_HASUSERANDSERVERINFO)
            {
                if (pDisplayOptions->offsetServer)
                    pszServer = (LPWSTR)ByteOffset(pDisplayOptions, pDisplayOptions->offsetServer);
                if (pDisplayOptions->offsetUserName)
                    pszUserName = (LPWSTR)ByteOffset(pDisplayOptions, pDisplayOptions->offsetUserName);
                if (pDisplayOptions->offsetPassword)
                    pszPassword = (LPWSTR)ByteOffset(pDisplayOptions, pDisplayOptions->offsetPassword);

                Trace((TEXT("Display Options: server = %s; user = %s; pw = %s"),
                      pszServer?pszServer:TEXT("none"),
                      pszUserName?pszUserName:TEXT("none"),
                      pszPassword?pszPassword:TEXT("none")));
            }
        }
    }

    //
    // Create and initialize the ISecurityInformation object.
    //
    hr = DSCreateISecurityInfoObjectEx(pObjectPath,
                                       pClass,
                                       pszServer,
                                       pszUserName,
                                       pszPassword,
                                       dwFlags,
                                       &m_pSI,
                                       NULL,
                                       NULL,
                                       0);

exit_gracefully:

    ReleaseStgMedium(&medDisplayOptions);
    ReleaseStgMedium(&medObjectNames);

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ IShellPropSheetExt
/----------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                      LPARAM               lParam)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SECURITY, "CDsSecurity::AddPages");

    if (m_pSI != NULL)
    {
        HPROPSHEETPAGE hPermPage = NULL;

        hr = _CreateSecurityPage(m_pSI, &hPermPage);

        if (NULL != hPermPage && !lpfnAddPage(hPermPage, lParam))
            DestroyPropertySheetPage(hPermPage);
    }

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::ReplacePage(UINT                 /* uPageID */,
                         LPFNADDPROPSHEETPAGE /* lpfnReplaceWith */,
                         LPARAM               /* lParam */)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------------------------
/ IContextMenu
/----------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::QueryContextMenu(HMENU hMenu,
                              UINT indexMenu,
                              UINT idCmdFirst,
                              UINT /*idCmdLast*/,
                              UINT /*uFlags*/)
{
    TCHAR szBuffer[MAX_PATH];
    MENUITEMINFO mii;
    int idMax = idCmdFirst;

    TraceEnter(TRACE_SECURITY, "CDsSecurity::QueryContextMenu");

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    mii.fType = MFT_STRING;

	 //NTRAID#NTBUG9-578983-2002/04/02-hiteshr
    // Merge our verbs into the menu we were given
    LoadString(GLOBAL_HINSTANCE, IDS_SECURITY, szBuffer, ARRAYSIZE(szBuffer));

	 mii.dwTypeData = szBuffer;
    mii.cch = lstrlen(szBuffer);


    mii.wID = idMax++;

    InsertMenuItem(hMenu,
                   indexMenu++,
                   TRUE /*fByPosition*/,
                   &mii);

    TraceLeaveValue(ResultFromShort(idMax - idCmdFirst));
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_SECURITY, "CDsSecurity::InvokeCommand");

    if (HIWORD(lpcmi->lpVerb) != 0)
        TraceLeaveResult(E_NOTIMPL);

    TraceAssert(LOWORD(lpcmi->lpVerb) == 0);

    // REVIEW If they ever get around to making property pages work
    // for DS objects, we can replace this with
    // ShellExecuteEx(verb=Properties, parameters=Security) [see ..\rshx32\rshx32.cpp]
    if (m_pSI != NULL)
        hr = _EditSecurity(lpcmi->hwnd, m_pSI);

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP
CDsSecurity::GetCommandString(UINT_PTR /*idCmd*/,
                              UINT uFlags,
                              LPUINT /*reserved*/,
                              LPSTR pszName,
                              UINT ccMax)
{
    if (uFlags == GCS_HELPTEXT)
    {
        LoadString(GLOBAL_HINSTANCE, IDS_SECURITYHELP, (LPTSTR)pszName, ccMax);
        return S_OK;
    }

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\sources.inc ===
TARGETNAME= dssec
TARGETTYPE= DYNLINK
TARGETPATH= obj

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}

MSC_WARNING_LEVEL= /W4
DLLDEF=$(O)\$(TARGETNAME).def

DLLENTRY=   DllMain

INCLUDES=..;$(O);..\..\inc;$(BASE_INC_PATH);$(DS_INC_PATH);$(ADMIN_INC_PATH);   

LINKLIBS=\
    ..\..\common\winnt\$(O)\common.lib \

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SHELL_LIB_PATH)\comctlp.lib     \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\oleaut32.lib    \
    $(SDK_LIB_PATH)\adsiid.lib      \
    $(SDK_LIB_PATH)\activeds.lib    \
    $(SDK_LIB_PATH)\authz.lib    \

SOURCES=\
    ..\extrts.mc    \
    ..\resource.rc  \
    ..\dll.cpp      \
    ..\cstrings.cpp \
    ..\security.cpp \
    ..\dssi.cpp     \
    ..\schema.cpp   \
    ..\exnc.cpp     \

MISCFILES=\
    ..\dssec.dat

PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\inc\msgpopup.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgpopup.h
//
//  Definitions and prototypes for MessageBox helper functions.
//
//--------------------------------------------------------------------------

#ifndef _MSGPOPUP_H_
#define _MSGPOPUP_H_

#ifdef __cplusplus
extern "C" {
#endif

int
WINAPIV
MsgPopup(HWND hwnd,                 // Owner window
         LPCTSTR pszMsg,            // May be resource ID
         LPCTSTR pszTitle,          // May be resource ID or NULL
         UINT uType,                // MessageBox flags
         HINSTANCE hInstance,       // Resource strings loaded from here
         ...);                      // Arguments to insert into pszMsg
int
WINAPI
SysMsgPopup(HWND hwnd,
            LPCTSTR pszMsg,
            LPCTSTR pszTitle,
            UINT uType,
            HINSTANCE hInstance,
            DWORD dwErrorID,
            LPCTSTR pszInsert2 = NULL);

#ifdef __cplusplus
}
#endif

#endif  // _MSGPOPUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\inc\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       common.h
//
//--------------------------------------------------------------------------

#ifndef __common_h
#define __common_h

//
// ARRAYSIZE, SIZEOF, and ResultFromShort are defined in private shell
// headers, but those headers tend to move around, change, and break.
// Define the macros here so we don't have to include the headers only for
// this purpose.
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)       sizeof(a)
#endif

#ifndef ResultFromShort
#define ResultFromShort(i)      MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(i))
#endif


//
// Avoid bringing in C runtime code for NO reason
//
#if defined(__cplusplus)
inline void * __cdecl operator new(size_t size) { return (void *)LocalAlloc(LPTR, size); }
inline void __cdecl operator delete(void *ptr) { LocalFree(ptr); }
extern "C" inline __cdecl _purecall(void) { return 0; }
#endif  // __cplusplus

#include "debug.h"
#include "unknown.h"
#include "strings.h"
#include "priv.h"
#include "msgpopup.h"

//
//strsafe apis
//
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 

/*-----------------------------------------------------------------------------
/ Flags to control the trace output from parts of the common library
/----------------------------------------------------------------------------*/
#define TRACE_COMMON_STR       0x80000000
#define TRACE_COMMON_ASSERT    0x40000000
#define TRACE_COMMON_MISC      0x20000000

/*-----------------------------------------------------------------------------
/ Misc functions (misc.cpp)
/----------------------------------------------------------------------------*/
HRESULT CallRegInstall(HMODULE hModule, LPCSTR pszSection);



/*-----------------------------------------------------------------------------
/ Exit macros for macro
/   - these assume that a label "exit_gracefully:" prefixes the prolog
/     to your function
/----------------------------------------------------------------------------*/
#define ExitGracefully(hr, result, text)            \
            { TraceMsg(text); hr = result; goto exit_gracefully; }

#define FailGracefully(hr, text)                    \
	    { if ( FAILED(hr) ) { TraceMsg(text); goto exit_gracefully; } }


/*-----------------------------------------------------------------------------
/ Interface helper macros
/----------------------------------------------------------------------------*/
#define DoRelease(pInterface)                       \
        { if ( pInterface ) { pInterface->Release(); pInterface = NULL; } }


/*-----------------------------------------------------------------------------
/ String helper macros
/----------------------------------------------------------------------------*/
#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*SIZEOF(TCHAR))


/*-----------------------------------------------------------------------------
/ Other helpful macros
/----------------------------------------------------------------------------*/
#define ByteOffset(base, offset)                    \
        (((LPBYTE)base)+offset)


// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\inc\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#ifndef __debug_h
#define __debug_h

#if DBG
#define DEBUG
#else
#undef  DEBUG
#endif


/*-----------------------------------------------------------------------------
/ Debugging APIs (use the Macros, they make it easier and cope with correctly
/ removing debugging when it is disabled at build time).
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask);
void DoTraceSetMaskFromRegKey(HKEY hkRoot, LPCTSTR pszSubKey);
void DoTraceSetMaskFromCLSID(REFCLSID rCLSID);
void DoTraceEnter(DWORD dwMask, LPCTSTR pName);
void DoTraceLeave(void);
void DoTrace(LPCTSTR pFormat, ...);
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
void DoTraceAssert(int iLine, LPTSTR pFilename);


/*-----------------------------------------------------------------------------
/ Macros to ease the use of the debugging APIS.
/----------------------------------------------------------------------------*/

#ifdef DEBUG

void DebugThreadDetach(void);           // optional
void DebugProcessAttach(void);          // required
void DebugProcessDetach(void);          // required

#define TraceSetMask(dwMask)            DoTraceSetMask(dwMask)
#define TraceSetMaskFromRegKey(hk, psz) DoTraceSetMaskFromRegKey(hk, psz)
#define TraceSetMaskFromCLSID(rCLSID)   DoTraceSetMaskFromCLSID(rCLSID)
#define TraceEnter(dwMask, fn)          DoTraceEnter(dwMask, TEXT(fn))
#define TraceLeave()                    DoTraceLeave()

#define Trace(x)                        DoTrace x
#define TraceMsg(s)                     DoTrace(TEXT(s))
#define TraceGUID(s, rGUID)             DoTraceGUID(TEXT(s), rGUID)

#define TraceAssert(x) \
                { if ( !(x) ) DoTraceAssert(__LINE__, TEXT(__FILE__)); }

#define TraceLeaveResult(hr) \
                { HRESULT __hr = (hr); if (FAILED(__hr)) Trace((TEXT("Failed (%08x)"), __hr)); TraceLeave(); return __hr; }

#define TraceLeaveVoid() \
                { TraceLeave(); return; }

#define TraceLeaveValue(value) \
                { TraceLeave(); return (value); }

#else   // !DEBUG

#define DebugThreadDetach()
#define DebugProcessAttach()
#define DebugProcessDetach()

#define TraceSetMask(dwMask)
#define TraceSetMaskFromRegKey(hk, psz)
#define TraceSetMaskFromCLSID(rCLSID)
#define TraceEnter(dwMask, fn)
#define TraceLeave()

#define Trace(x)
#define TraceMsg(s)
#define TraceGUID(s, rGUID)

#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return (hr); }
#define TraceLeaveVoid()        { return; }
#define TraceLeaveValue(value)  { return (value); }

#endif  // DEBUG


#endif  // __debug_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\dssec\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       version.h
//
//--------------------------------------------------------------------------

// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Directory Service Security UI"
#define VER_INTERNALNAME_STR            "dssec"
#define VER_LEGALCOPYRIGHT_YEARS        "1996"
#define VER_ORIGINALFILENAME_STR        "dssec.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\inc\unknown.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       unknown.h
//
//--------------------------------------------------------------------------

#ifndef _unknown_h
#define _unknown_h


// Global count of number of active objects

extern LONG g_cRefCount;
#define GLOBAL_REFCOUNT     (g_cRefCount)


// CUnknown

typedef struct
{
    const IID* piid;            // interface ID
    LPVOID  pvObject;           // pointer to the object
} INTERFACES, * LPINTERFACES;

class CUnknown 
{
    protected:
        LONG m_cRefCount;

    public:
        CUnknown();
        virtual ~CUnknown();
        
        STDMETHODIMP         HandleQueryInterface(REFIID riid, LPVOID* ppvObject, LPINTERFACES aInterfaces, int cif);
        STDMETHODIMP_(ULONG) HandleAddRef();
        STDMETHODIMP_(ULONG) HandleRelease();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\inc\priv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       priv.h
//
//--------------------------------------------------------------------------

#ifndef _PRIV_H_
#define _PRIV_H_

#ifdef __cplusplus
extern "C" {
#endif

HANDLE  EnablePrivileges(PDWORD pdwPrivileges, ULONG cPrivileges);
void    ReleasePrivileges(HANDLE hToken);

#ifdef __cplusplus
}
#endif

#endif  // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\inc\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef __strings_h
#define __strings_h

HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString);
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen);
void    LocalFreeString(LPTSTR* ppString);

UINT SizeofStringResource(HINSTANCE hInstance, UINT idStr);
int LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr);

// String formatting functions - *ppszResult must be LocalFree'd
DWORD FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...);
DWORD FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...);
DWORD vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs);
DWORD vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs);

DWORD GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr);

// A BSTR wrapper that frees itself upon destruction.
// Taken from sburns burnslib
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:
        
   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      TraceAssert(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\cstrings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.cpp
//
//  Constant strings used by this module
//
//--------------------------------------------------------------------------

#include "rshx32.h"

TCHAR const c_szProperties[]    = TEXT("Properties");
TCHAR const c_szAclUI[]         = TEXT("aclui.dll");
TCHAR const c_szWinSpool[]      = TEXT("winspool.drv");
TCHAR const c_szDot[]           = TEXT(".");
TCHAR const c_szDotDot[]        = TEXT("..");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\cstrings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cstrings.h
//
//--------------------------------------------------------------------------

#ifndef __cstrings_h
#define __cstrings_h

extern TCHAR const c_szProperties[];
extern TCHAR const c_szAclUI[];
extern TCHAR const c_szWinSpool[];
extern TCHAR const c_szDot[];
extern TCHAR const c_szDotDot[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\inc\unknown.inc ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       unknown.inc
//
//  Magic include file to help with implementing IUnknown
//
//--------------------------------------------------------------------------


/*----------------------------------------------------------------------------
/ Macros to handle AddRef & Release (by calling CUnknown methods)
/----------------------------------------------------------------------------*/

STDMETHODIMP_(ULONG) CLASS_NAME::AddRef()
{
    return CUnknown::HandleAddRef();
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP_(ULONG) CLASS_NAME::Release()
{
    return CUnknown::HandleRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\ntfssi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ntfssi.cpp
//
//  This file contains the implementation of the CNTFSSecurity object.
//
//--------------------------------------------------------------------------

#include "rshx32.h"
#include <windowsx.h>   // GET_WM_COMMAND_ID, etc.
#include <atlconv.h>

#define MY_FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED                    \
                            | SYNCHRONIZE                               \
                            | FILE_READ_DATA    | FILE_LIST_DIRECTORY   \
                            | FILE_WRITE_DATA   | FILE_ADD_FILE         \
                            | FILE_APPEND_DATA  | FILE_ADD_SUBDIRECTORY \
                            | FILE_CREATE_PIPE_INSTANCE                 \
                            | FILE_READ_EA                              \
                            | FILE_WRITE_EA                             \
                            | FILE_EXECUTE      | FILE_TRAVERSE         \
                            | FILE_DELETE_CHILD                         \
                            | FILE_READ_ATTRIBUTES                      \
                            | FILE_WRITE_ATTRIBUTES)

#if(FILE_ALL_ACCESS != MY_FILE_ALL_ACCESS)
#error ACL editor needs to sync with file permissions changes in ntioapi.h (or ntioapi.h is broken)
#endif

#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

//
// Treat SYNCHRONIZE specially. In particular, always allow SYNCHRONIZE and
// never Deny SYNCHRONIZE. Do this by removing it from the Generic Mapping,
// turning it off in all ACEs and SI_ACCESS entries, and then adding it to
// all Allow ACEs before saving a new ACL.
//
#define FILE_GENERIC_READ_      (FILE_GENERIC_READ    & ~SYNCHRONIZE)
#define FILE_GENERIC_WRITE_     (FILE_GENERIC_WRITE   & ~(SYNCHRONIZE | READ_CONTROL))
#define FILE_GENERIC_EXECUTE_   (FILE_GENERIC_EXECUTE & ~SYNCHRONIZE)
#define FILE_GENERIC_ALL_       (FILE_ALL_ACCESS      & ~SYNCHRONIZE)

#define FILE_GENERAL_MODIFY     (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_ | DELETE)
#define FILE_GENERAL_PUBLISH    (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_DEPOSIT    (FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_READ_EX    (FILE_GENERIC_READ_  | FILE_GENERIC_EXECUTE_)

// The following array defines the permission names for NTFS objects.
SI_ACCESS siNTFSAccesses[] =
{
    { &GUID_NULL, FILE_GENERIC_ALL_,    MAKEINTRESOURCE(IDS_NTFS_GENERIC_ALL),      SI_ACCESS_GENERAL | INHERIT_FULL|SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_GENERAL_MODIFY,  MAKEINTRESOURCE(IDS_NTFS_GENERAL_MODIFY),   SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX, MAKEINTRESOURCE(IDS_NTFS_GENERAL_READ),     SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX, MAKEINTRESOURCE(IDS_NTFS_GENERAL_LIST),     SI_ACCESS_CONTAINER | CONTAINER_INHERIT_ACE },
    { &GUID_NULL, FILE_GENERIC_READ_,   MAKEINTRESOURCE(IDS_NTFS_GENERIC_READ),     SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERIC_WRITE_,  MAKEINTRESOURCE(IDS_NTFS_GENERIC_WRITE),    SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_EXECUTE,         MAKEINTRESOURCE(IDS_NTFS_FILE_EXECUTE),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_DATA,       MAKEINTRESOURCE(IDS_NTFS_FILE_READ_DATA),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_ATTRIBUTES, MAKEINTRESOURCE(IDS_NTFS_FILE_READ_ATTR),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_EA,         MAKEINTRESOURCE(IDS_NTFS_FILE_READ_EA),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_DATA,      MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_DATA),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_APPEND_DATA,     MAKEINTRESOURCE(IDS_NTFS_FILE_APPEND_DATA), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_ATTRIBUTES,MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_ATTR),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_EA,        MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_EA),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_DELETE_CHILD,    MAKEINTRESOURCE(IDS_NTFS_FILE_DELETE_CHILD),SI_ACCESS_SPECIFIC },
#if(FILE_CREATE_PIPE_INSTANCE != FILE_APPEND_DATA)
    { &GUID_NULL, FILE_CREATE_PIPE_INSTANCE, MAKEINTRESOURCE(IDS_NTFS_FILE_CREATE_PIPE), SI_ACCESS_SPECIFIC },
#endif
    { &GUID_NULL, DELETE,               MAKEINTRESOURCE(IDS_NTFS_STD_DELETE),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,         MAKEINTRESOURCE(IDS_NTFS_STD_READ_CONTROL), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,            MAKEINTRESOURCE(IDS_NTFS_STD_WRITE_DAC),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,          MAKEINTRESOURCE(IDS_NTFS_STD_WRITE_OWNER),  SI_ACCESS_SPECIFIC },
//    { &GUID_NULL, SYNCHRONIZE,          MAKEINTRESOURCE(IDS_NTFS_STD_SYNCHRONIZE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                    MAKEINTRESOURCE(IDS_NONE),                  0 },
    { &GUID_NULL, FILE_GENERIC_EXECUTE_,MAKEINTRESOURCE(IDS_NTFS_GENERIC_EXECUTE),  0 },
    { &GUID_NULL, FILE_GENERAL_DEPOSIT, MAKEINTRESOURCE(IDS_NTFS_GENERAL_DEPOSIT),  0 },
    { &GUID_NULL, FILE_GENERAL_PUBLISH, MAKEINTRESOURCE(IDS_NTFS_GENERAL_PUBLISH),  0 },
};
#define iNTFSDefAccess      2   // FILE_GENERAL_READ_EX
#define iNTFSDelChildAccess 14  // FILE_DELETE_CHILD
    
// The following array defines the inheritance types for NTFS directories.
SI_INHERIT_TYPE siNTFSInheritTypes[] =
{
    &GUID_NULL, 0,                                                             MAKEINTRESOURCE(IDS_NTFS_FOLDER),
    &GUID_NULL, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_NTFS_FOLDER_SUBITEMS),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                                         MAKEINTRESOURCE(IDS_NTFS_FOLDER_SUBFOLDER),
    &GUID_NULL, OBJECT_INHERIT_ACE,                                            MAKEINTRESOURCE(IDS_NTFS_FOLDER_FILE),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_NTFS_SUBITEMS_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,                      MAKEINTRESOURCE(IDS_NTFS_SUBFOLDER_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,                         MAKEINTRESOURCE(IDS_NTFS_FILE_ONLY),
};

VOID ProgressFunction(IN LPWSTR                   pObjectName,    
                      IN DWORD                    Status,         
                      IN OUT PPROG_INVOKE_SETTING pInvokeSetting ,
                      IN PVOID                    Args,
                      IN BOOL                     SecuritySet);

BOOL SetFileSecurityUsingNTName(IN LPCWSTR pszFileName,
                                IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                OUT PBOOL pbIsFile);




STDMETHODIMP
CheckFileAccess(LPCTSTR pszObjectName, LPDWORD pdwAccessGranted)
{
    HRESULT hr = S_OK;
    UINT i;
    UNICODE_STRING usNtFileName = {0};
    DWORD dwAccessDesired[] = { ALL_SECURITY_ACCESS,
                                READ_CONTROL,
                                WRITE_DAC,
                                WRITE_OWNER,
                                ACCESS_SYSTEM_SECURITY };

    TraceEnter(TRACE_NTFSSI, "CheckFileAccess");
    TraceAssert(pdwAccessGranted != NULL);

    *pdwAccessGranted = 0;

    if (!RtlDosPathNameToNtPathName_U(pszObjectName,
                                      &usNtFileName,
                                      NULL,
                                      NULL))
    {
        ExitGracefully(hr, E_OUTOFMEMORY, "RtlDosPathNameToNtPathName_U failed");
    }

    for (i = 0; i < ARRAYSIZE(dwAccessDesired); i++)
    {
        OBJECT_ATTRIBUTES oa;
        IO_STATUS_BLOCK StatusBlock;
        DWORD dwErr;
        HANDLE hFile;

        if ((dwAccessDesired[i] & *pdwAccessGranted) == dwAccessDesired[i])
            continue;   // already have this access

        InitializeObjectAttributes(&oa,
                                   &usNtFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   0,
                                   0);

        dwErr = RtlNtStatusToDosError(NtOpenFile(&hFile,
                                                 dwAccessDesired[i],
                                                 &oa,
                                                 &StatusBlock,
                                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                 0));
        if (dwErr == 0)
        {
            *pdwAccessGranted |= dwAccessDesired[i];
            NtClose(hFile);
        }
    }

exit_gracefully:

    RtlFreeUnicodeString(&usNtFileName);

    Trace((TEXT("Access = 0x%08x"), *pdwAccessGranted));
    TraceLeaveResult(hr);
}





///////////////////////////////////////////////////////////
//
// Constructor/destructor
//
///////////////////////////////////////////////////////////

NTFS_COMPARE_DATA::~NTFS_COMPARE_DATA()
{
    LocalFreeString(&pszSaclConflict);
    LocalFreeString(&pszDaclConflict);
	LocalFreeString(&pszFailureMsg);
}

CNTFSSecurity::CNTFSSecurity(SE_OBJECT_TYPE seType, BOOL bShowLossInheritedAclWarning)
: CSecurityInformation(seType),
m_pszSystemDrive(NULL),
m_pszSystemRoot(NULL),
m_bShowLossInheritedAclWarning(bShowLossInheritedAclWarning)
{
}

CNTFSSecurity::~CNTFSSecurity()
{
    if (m_pCompareData != NULL)
        m_pCompareData->bAbortThread = TRUE;

    if(m_pszSystemDrive)
        LocalFree(m_pszSystemDrive);
    if(m_pszSystemRoot)
        LocalFree(m_pszSystemRoot);

    WaitForComparison();
    delete m_pCompareData;
}

STDMETHODIMP
CNTFSSecurity::Initialize(HDPA      hItemList,
                          DWORD     dwFlags,
                          LPTSTR    pszServer,
                          LPTSTR    pszObject)
{
    HRESULT hr;

    //
    // If we're editing the owner on a folder, turn on the Recurse button.
    //
    if (dwFlags & SI_CONTAINER)
    {
        if ((dwFlags & (SI_EDIT_OWNER | SI_OWNER_READONLY)) == SI_EDIT_OWNER)
            dwFlags |= SI_OWNER_RECURSE;

        if (!(dwFlags & SI_READONLY))
            dwFlags |= SI_RESET_DACL_TREE;

        if (dwFlags & SI_EDIT_AUDITS)
            dwFlags |= SI_RESET_SACL_TREE;
    }

    //
    // Let the base class do its thing
    //
    hr = CSecurityInformation::Initialize(hItemList,
                                          dwFlags,
                                          pszServer,
                                          pszObject);

    //
    // If multiple selection, create thread to compare security descriptors
    //
    if (m_hItemList && DPA_GetPtrCount(m_hItemList) > 1)
    {
        m_pCompareData = new NTFS_COMPARE_DATA(m_hItemList, m_dwSIFlags);

        if (m_pCompareData != NULL)
        {
            DWORD dwID;

            m_hCompareThread = CreateThread(NULL,
                                            0,
                                            NTFSCompareThreadProc,
                                            m_pCompareData,
                                            CREATE_SUSPENDED,
                                            &dwID);
            if (m_hCompareThread != NULL)
            {
                SetThreadPriority(m_hCompareThread, THREAD_PRIORITY_BELOW_NORMAL);
                ResumeThread(m_hCompareThread);
            }
            else
            {
                delete m_pCompareData;
                m_pCompareData = NULL;
            }
        }
    }

    //Get System Paths
    GetSystemPaths(&m_pszSystemDrive,&m_pszSystemRoot);

    return hr;
}

///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CNTFSSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::GetAccessRights");
    TraceAssert(ppAccesses != NULL);
    TraceAssert(pcAccesses != NULL);
    TraceAssert(piDefaultAccess != NULL);
    
    //
    //Don't Show delete subfolder and files for files or
    //when applyonto is files only
    //
    if(IsFile())
        siNTFSAccesses[iNTFSDelChildAccess].dwFlags = 0;
    else
        siNTFSAccesses[iNTFSDelChildAccess].dwFlags = SI_ACCESS_SPECIFIC;


    *ppAccesses = siNTFSAccesses;
    *pcAccesses = ARRAYSIZE(siNTFSAccesses);
    *piDefaultAccess = iNTFSDefAccess;

    TraceLeaveResult(S_OK);
}

GENERIC_MAPPING NTFSMap =
{
    FILE_GENERIC_READ_,
    FILE_GENERIC_WRITE_,
    FILE_GENERIC_EXECUTE_,
    FILE_GENERIC_ALL_
};

STDMETHODIMP
CNTFSSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::MapGeneric");
    TraceAssert(pmask != NULL);

    MapGenericMask(pmask, &NTFSMap);
    *pmask &= ~SYNCHRONIZE;

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CNTFSSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::GetInheritTypes");
    TraceAssert(ppInheritTypes != NULL);
    TraceAssert(pcInheritTypes != NULL);

    if (m_dwSIFlags & SI_CONTAINER)
    {
        *ppInheritTypes = siNTFSInheritTypes;
        *pcInheritTypes = ARRAYSIZE(siNTFSInheritTypes);
        TraceLeaveResult(S_OK);
    }

    TraceLeaveResult(E_NOTIMPL);
}

STDMETHODIMP
CNTFSSecurity::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    HRESULT hr = S_OK;
    SECURITY_INFORMATION siConflict = 0;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::GetSecurity");
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    *ppSD = NULL;

    if (fDefault)
    {
        ExitGracefully(hr, E_NOTIMPL, "Default security descriptor not supported");
    }

    WaitForComparison();

    if (m_pCompareData != NULL)
    {
		//If comparison failed we cannot do anything.
		//Display the error message. Error message is
		//be set by DPA_CompareSecurityIntersection as 
		//this function knows the exact casue and context
		//of failure.
		if(FAILED(m_pCompareData->hrResult))
		{
			if(m_pCompareData->pszFailureMsg)
			{
				MsgPopup(GetLastActivePopup(m_hwndOwner),
                         m_pCompareData->pszFailureMsg,
                         MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
                         MB_OK | MB_ICONWARNING | MB_SETFOREGROUND,
                         g_hInstance);
				return S_FALSE;					
			}
			return m_pCompareData->hrResult;
		}


		siConflict = si & m_pCompareData->siConflict;
    }

    // Read it from the first item.
    hr = CSecurityInformation::GetSecurity(si, ppSD, fDefault);

    if (SUCCEEDED(hr) && siConflict != 0)
    {
        //
        // Clear out any of the parts that conflict
        //
        PISECURITY_DESCRIPTOR psd = (PISECURITY_DESCRIPTOR)*ppSD;
        TraceAssert(psd != NULL);

        if (siConflict & OWNER_SECURITY_INFORMATION)
        {
            psd->Owner = NULL;
        }

        if (siConflict & GROUP_SECURITY_INFORMATION)
        {
            psd->Group = NULL;
        }

        // The following can happen if there was an error resetting ACLs above

        if (siConflict & SACL_SECURITY_INFORMATION)
        {
            psd->Control &= ~SE_SACL_PRESENT;
            psd->Sacl = NULL;
        }

        if (siConflict & DACL_SECURITY_INFORMATION)
        {
            psd->Control &= ~SE_DACL_PRESENT;
            psd->Dacl = NULL;
        }
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


//
// See comments about SYNCHRONIZE at the top of this file
//
void
FixSynchronizeAccess(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    if (NULL != pSD && 0 != (si & DACL_SECURITY_INFORMATION))
    {
        BOOL bPresent;
        BOOL bDefault;
        PACL pDacl = NULL;

        GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault);

        if (pDacl)
        {
            PACE_HEADER pAce;
            int i;

            for (i = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
                 i < pDacl->AceCount;
                 i++, pAce = (PACE_HEADER)NextAce(pAce))
            {
                if (ACCESS_ALLOWED_ACE_TYPE == pAce->AceType)
                    ((PKNOWN_ACE)pAce)->Mask |= SYNCHRONIZE;
				//
				//If full control is denied, there is no reason not
				//to deny Synchronize permission.
				//
				else if((ACCESS_DENIED_ACE_TYPE == pAce->AceType) &&
						(((PKNOWN_ACE)pAce)->Mask == FILE_GENERIC_ALL_))	
					((PKNOWN_ACE)pAce)->Mask = FILE_ALL_ACCESS;					
            }
        }
    }
}


STDMETHODIMP
CNTFSSecurity::SetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;

    if (si & DACL_SECURITY_INFORMATION)
        FixSynchronizeAccess(si, pSD);

    if(m_bShowLossInheritedAclWarning)
    {
	    if(!SetAclOnRemoteNetworkDrive(m_hItemList,
									    si,
									    pSD,
									    GetLastActivePopup(m_hwndOwner)))
	    {
		    return S_FALSE;
	    }
    }



    if(!SetAclOnSystemPaths(m_hItemList,
                           m_pszSystemDrive,
                           m_pszSystemRoot,
                           si,
                           GetLastActivePopup(m_hwndOwner)))
    {
        return S_FALSE;
    }

    //
    // If we need to recursively set the Owner, get the Owner &
    // Group from pSD.
    //
    if (si & ( SI_OWNER_RECURSE | SI_RESET_DACL_TREE | SI_RESET_SACL_TREE ) )
    {
        si = si & (~( SI_OWNER_RECURSE | SI_RESET_DACL_TREE | SI_RESET_SACL_TREE ));
        hr = SetSecurityLocal(si, pSD, NULL);

        // Remember whether the user cancelled, since hr gets
        // reset when we call the base class below.
    }
    else 
    {
        // See comments about SYNCHRONIZE at the top of this file

        // Call the base class to do the rest
        hr = CSecurityInformation::SetSecurity(si, pSD);
    }

    if (S_OK == hr && m_pCompareData)
    {
        // If we successfully wrote it, then it doesn't conflict anymore
        m_pCompareData->siConflict &= ~(si);

        if (0 == m_pCompareData->siConflict)
        {
            delete m_pCompareData;
            m_pCompareData = NULL;
        }
    }

    return hr;
}


STDMETHODIMP
CNTFSSecurity::PropertySheetPageCallback(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage)
{
    HRESULT hr;
    LPUINT pidsPrompt = NULL;
    LPCTSTR pszFile2 = NULL;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::PropertySheetPageCallback");

    hr = CSecurityInformation::PropertySheetPageCallback(hwnd, uMsg, uPage);

    if (uMsg == PSPCB_SI_INITDIALOG)
    {
        WaitForComparison();


		SECURITY_INFORMATION si = 0;
        if (m_pCompareData != NULL)
        {
            if (SUCCEEDED(m_pCompareData->hrResult))
            {
                switch (uPage)
                {
                case SI_PAGE_PERM:
                case SI_PAGE_ADVPERM:
                    pidsPrompt = &m_pCompareData->idsDaclPrompt;
                    pszFile2 = m_pCompareData->pszDaclConflict;
					si = DACL_SECURITY_INFORMATION;
                    break;

                case SI_PAGE_AUDIT:
                    pidsPrompt = &m_pCompareData->idsSaclPrompt;
                    pszFile2 = m_pCompareData->pszSaclConflict;
					si = SACL_SECURITY_INFORMATION;
                    break;
                }
            }
    
			if (pidsPrompt != NULL && *pidsPrompt != 0)
			{
				if (IDYES != MsgPopup(hwnd,
									  MAKEINTRESOURCE(*pidsPrompt),
									  MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
									  MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND,
									  g_hInstance,
									  m_pszObjectName,
									  pszFile2))
				{
					// Don't want to prompt again for the same thing, so set
					// this to zero.
					*pidsPrompt = 0;
					hr = E_FAIL;    // abort
					TraceLeaveResult(hr);
				}

				// Don't want to prompt again for the same thing, so set
				// this to zero.
				*pidsPrompt = 0;


				//Reset the ACL
				// Build security descriptor with empty DACL and SACL
				SECURITY_DESCRIPTOR sdEmpty = {0};
				ACL aclEmpty = {0};
				if(!InitializeSecurityDescriptor(&sdEmpty, SECURITY_DESCRIPTOR_REVISION))
				{
					TraceLeaveResult(E_FAIL);
				}

				if(!InitializeAcl(&aclEmpty, sizeof(ACL), ACL_REVISION))
				{
					TraceLeaveResult(E_FAIL);
				}

				if(!SetSecurityDescriptorSacl(&sdEmpty, TRUE, &aclEmpty, FALSE))
				{
					TraceLeaveResult(E_FAIL);
				}

				if(!SetSecurityDescriptorDacl(&sdEmpty, TRUE, &aclEmpty, FALSE))
				{
					TraceLeaveResult(E_FAIL);
				}

				// Reset the DACL and/or SACL
				HANDLE hToken = INVALID_HANDLE_VALUE;
				DWORD dwPriv = SE_SECURITY_PRIVILEGE;
				if(SACL_SECURITY_INFORMATION == si)
				{
					hToken = EnablePrivileges(&dwPriv, 1);
				}
				hr = SetSecurity(si, (PSECURITY_DESCRIPTOR)&sdEmpty);
				if(SACL_SECURITY_INFORMATION == si)
				{
					// Release the privilege we enabled
				    ReleasePrivileges(hToken);
				}
				

				if(FAILED(hr))
				{
					MsgPopup(hwnd,
							 MAKEINTRESOURCE((si == DACL_SECURITY_INFORMATION) ? IDS_RESET_PERM_FAILED : IDS_RESET_AUDITING_FAILED),
							 MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
							 MB_OK | MB_ICONWARNING | MB_SETFOREGROUND,
							 g_hInstance);
					return E_FAIL;
				}
			}
			else if(si & m_pCompareData->siConflict)
			{
				//This situation arises when advanced page is brought up first time.
				//We show the message prompting for reset, and either user selects no 
				//or resets fails. In both the cases conflict is still there and we 
				//disable the page. Now we close the advanced page and bring it up again.
				//This time we won't show any prompt as we have already cleared the prompt
				//So we should check if there is still conflict and if yes we should disable
				//page.
				TraceLeaveResult(E_FAIL);
			}
		}
    }

    TraceLeaveResult(hr);
}



STDMETHODIMP
CNTFSSecurity::WriteObjectSecurity(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD)
{
    DWORD dwErr;
    HRESULT hr = S_OK;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::WriteObjectSecurity");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(pSD != NULL);


    hr = CSecurityInformation::WriteObjectSecurity(pszObject, si, pSD);


    // This is a workaround.  SetNamedSecurityInfo[Ex] fails with Access Denied
    // in some cases where the owner is trying to set the DACL
    // (typically because the propagation code can't enumerate the children
    // because owner doesn't have read access).

    if (E_ACCESSDENIED == hr)
    {
        SECURITY_DESCRIPTOR_CONTROL wControl = 0;
        DWORD dwRevision;

        // If we're setting a protected DACL (i.e. no inheritance from parent)
        // try SetFileSecurity.  If that works, try the full write again.
        //
        // Don't do this if the DACL isn't protected since it may fool the
        // system into thinking that this is a downlevel DACL that should
        // be protected.  That would be very confusing to the user.

        GetSecurityDescriptorControl(pSD, &wControl, &dwRevision);

        if ((si & DACL_SECURITY_INFORMATION)
            && ((wControl & SE_DACL_PROTECTED) || (m_dwSIFlags & SI_NO_ACL_PROTECT))
            && SetFileSecurity(pszObject, si, pSD))
        {
            hr = CSecurityInformation::WriteObjectSecurity(pszObject, si, pSD);
        }
    }

    //
    // Notify the shell if we change permissions on a folder (48220)
    //
    if (SUCCEEDED(hr) &&
        (si & DACL_SECURITY_INFORMATION) &&
        (m_dwSIFlags & SI_CONTAINER))
    {
        SHChangeNotify(SHCNE_UPDATEDIR,
                       SHCNF_PATH | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT,
                       pszObject,
                       NULL);
    }

    TraceLeaveResult(hr);
}

void
CNTFSSecurity::WaitForComparison()
{
    if (m_hCompareThread != NULL)
    {
        DWORD dwResult;
        HCURSOR hcurPrevious = SetCursor(LoadCursor(NULL, IDC_WAIT));

        SetThreadPriority(m_hCompareThread, THREAD_PRIORITY_HIGHEST);

        dwResult = WaitForSingleObject(m_hCompareThread, INFINITE);

        if (m_pCompareData != NULL)
        {
            if (GetExitCodeThread(m_hCompareThread, &dwResult))
            {
                m_pCompareData->hrResult = dwResult;
            }
            else
            {
                dwResult = GetLastError();
                m_pCompareData->hrResult = HRESULT_FROM_WIN32(dwResult);
            }
        }

        CloseHandle(m_hCompareThread);
        m_hCompareThread = NULL;
        SetCursor(hcurPrevious);
    }
}

DWORD WINAPI
CNTFSSecurity::NTFSReadSD(LPCTSTR pszObject,
                          SECURITY_INFORMATION si,
                          PSECURITY_DESCRIPTOR* ppSD)
{
    DWORD dwLength = 0;
    DWORD dwErr = 0;

    TraceEnter(TRACE_NTFSSI | TRACE_NTFSCOMPARE, "CNTFSSecurity::NTFSReadSD");
    TraceAssert(pszObject != NULL);
    TraceAssert(si != 0);
    TraceAssert(ppSD != NULL);

    //
    // Assume that required privileges have already been
    // enabled, if appropriate.
    //
    GetFileSecurity(pszObject, si, NULL, 0, &dwLength);
    if (dwLength)
    {
        *ppSD = LocalAlloc(LPTR, dwLength);
        if (*ppSD &&
            !GetFileSecurity(pszObject, si, *ppSD, dwLength, &dwLength))
        {
            dwErr = GetLastError();
            LocalFree(*ppSD);
            *ppSD = NULL;
        }
    }
    else
        dwErr = GetLastError();

    TraceLeaveValue(dwErr);
}

DWORD WINAPI
CNTFSSecurity::NTFSCompareThreadProc(LPVOID pvData)
{
    PNTFS_COMPARE_DATA pCompareData = (PNTFS_COMPARE_DATA)pvData;
    HRESULT hr;
    DWORD dwSIFlags;
    BOOL bOwnerConflict = FALSE;
    BOOL bSaclConflict = FALSE;
    BOOL bDaclConflict = FALSE;

    TraceEnter(TRACE_NTFSCOMPARE, "CNTFSSecurity::NTFSCompareThreadProc");
    TraceAssert(pCompareData != NULL);

    dwSIFlags = pCompareData->dwSIFlags;

    hr = DPA_CompareSecurityIntersection(pCompareData->hItemList,
                                         NTFSReadSD,
                                         (dwSIFlags & SI_EDIT_OWNER) ? &bOwnerConflict : NULL,
                                         NULL,
                                         (dwSIFlags & SI_EDIT_AUDITS) ? &bSaclConflict : NULL,
                                         &bDaclConflict,
                                         NULL,
                                         NULL,
                                         &pCompareData->pszSaclConflict,
                                         &pCompareData->pszDaclConflict,
										 &pCompareData->pszFailureMsg,
                                         &pCompareData->bAbortThread);
    if (SUCCEEDED(hr))
    {
        if (bOwnerConflict)
            pCompareData->siConflict |= OWNER_SECURITY_INFORMATION;

        if (bSaclConflict)
            pCompareData->siConflict |= SACL_SECURITY_INFORMATION;

        if (bDaclConflict)
            pCompareData->siConflict |= DACL_SECURITY_INFORMATION;

        if (pCompareData->pszSaclConflict)
            pCompareData->idsSaclPrompt = IDS_BAD_SACL_INTERSECTION;

        if (pCompareData->pszDaclConflict)
            pCompareData->idsDaclPrompt = IDS_BAD_DACL_INTERSECTION;
    }

    TraceLeaveResult(hr);
}


HRESULT
CNTFSSecurity::SetSecurityLocal(SECURITY_INFORMATION si,
                                PSECURITY_DESCRIPTOR pSD,
                                LPBOOL pbNotAllApplied)
{

    HRESULT hr = S_OK;
    HCURSOR hcur = NULL;
    int i;

    TraceEnter(TRACE_NTFSSI, "CNTFSSecurity::SetSecurityLocal");
    TraceAssert(pSD != NULL);
    TraceAssert(SI_CONTAINER & m_dwSIFlags);

    SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
    DWORD dwRevision;
    PSID psidOwner = NULL;
    PSID psidGroup = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    BOOL bDefaulted;
    BOOL bPresent;

    DWORD dwErr = ERROR_SUCCESS;

    NTFS_PF_DATA dataPF;

    if( !si )
        TraceLeaveResult(hr);

    dataPF.si = si;
    dataPF.pNTFSSec = this;
    dataPF.pSD = pSD;
    dataPF.bCancel = FALSE;


    //
    // Get pointers to various security descriptor parts for
    // calling SetNamedSecurityInfo
    //
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted);
    GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted);
    GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
    GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted);
   
    if (si & DACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_DACL_PROTECTED)
            si |= PROTECTED_DACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
    }
    if (si & SACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_SACL_PROTECTED)
            si |= PROTECTED_SACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
    }


    if (pbNotAllApplied)
        *pbNotAllApplied = FALSE;

    if (NULL == m_hItemList)
        ExitGracefully(hr, E_UNEXPECTED, "CSecurityInformation not initialized");

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    CreateProgressDialog(si);

    for (i = 0; i < DPA_GetPtrCount(m_hItemList); i++)
    {
        LPTSTR pszItem = (LPTSTR)DPA_FastGetPtr(m_hItemList, i);
        if (NULL != pszItem)
        {

            dwErr = TreeResetNamedSecurityInfo( pszItem,
                                                SE_FILE_OBJECT,
                                                si,
                                                si & OWNER_SECURITY_INFORMATION ? psidOwner : NULL,
                                                NULL,
                                                si & DACL_SECURITY_INFORMATION ? pDacl : NULL,
                                                si & SACL_SECURITY_INFORMATION ? pSacl : NULL,
                                                FALSE,
                                                ProgressFunction,
                                                ProgressInvokeEveryObject,
                                                (PVOID)&dataPF);

            hr = HRESULT_FROM_WIN32(dwErr);
            FailGracefully(hr, "Unable to recursively apply security");
        }
        else
        {
            hr = E_UNEXPECTED;
            break;
        }
    }

exit_gracefully:


	if(dataPF.bCancel)
    {
		//User Pressed Cancel Button. Show a warning message showing implication of 
		//canceling the operation.
		UINT idMsg = IDS_PERMISSION_PROPOGATION_CANCEL;
		if(si & SACL_SECURITY_INFORMATION)
			idMsg = IDS_AUDITING_PROPOGATION_CANCEL;
		else if(si & OWNER_SECURITY_INFORMATION)
			idMsg = IDS_OWNER_PROPOGATION_CANCEL;
		
		MsgPopup(m_hwndPopupOwner,
				 MAKEINTRESOURCE(idMsg),
				 MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
				 MB_ICONWARNING | MB_SETFOREGROUND,
				 g_hInstance);
        
		if(pbNotAllApplied)
			*pbNotAllApplied = TRUE;
	
		//We should read the success in this case since
		//we don't know the state of acl. If we return S_OK
		//security page will reread the acl and display the
		//correct acl
		hr = S_OK;
    }               

    CloseProgressDialog();

    if (m_psdOwnerFullControl)
    {
        LocalFree(m_psdOwnerFullControl);
        m_psdOwnerFullControl = NULL;
    }

    if (hcur)
    {
        SetCursor(hcur);
    }

    TraceLeaveResult(hr);
}

BOOL PathIsDotOrDotDot(LPCTSTR pszPath)
{
    if (TEXT('.') == *pszPath++)
    {
        if (TEXT('\0') == *pszPath || (TEXT('.') == *pszPath && TEXT('\0') == *(pszPath + 1)))
            return TRUE;
    }
    return FALSE;
}

typedef struct _APPLY_SECURITY_ERROR
{
    HWND    hwndParent;
    DWORD   dwError;
    LPCTSTR pszPath;
    UINT    idMsg[1];   // Optional, string resource IDs (only 1 used so far)
} APPLY_SECURITY_ERROR;


INT_PTR CALLBACK
FailedApplySecurityProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            APPLY_SECURITY_ERROR* pae = (APPLY_SECURITY_ERROR*)lParam;
            LPTSTR pszT = NULL;

            // Set the message string(s)
            for (int i = 0; i < ARRAYSIZE(pae->idMsg); i++)
            {
                if (pae->idMsg[i])
                {
                    LoadStringAlloc(&pszT, g_hInstance, pae->idMsg[i]);
                    if (pszT)
                        SetDlgItemText(hDlg, (IDC_MSG1 + i), pszT);
                    LocalFreeString(&pszT);
                }
            }

            // Compact the path so it fits on the dialog
            PathSetDlgItemPath(hDlg, IDC_FILENAME, pae->pszPath);

            // Set the error text
            if (NOERROR != pae->dwError)
            {
                if (!GetSystemErrorText(&pszT, pae->dwError))
                    FormatStringID(&pszT, g_hInstance, IDS_FMT_UNKNOWN_ERROR, pae->dwError);
                if (pszT)
                    SetDlgItemText(hDlg, IDC_ERROR_TXT, pszT);
                LocalFreeString(&pszT);
            }
            break;
        }

        case WM_COMMAND:
        {
            WORD wControlID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (wControlID)
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, wControlID);
                    return TRUE;
            }
            break;
        }
    }
    return FALSE;
}

//
// This function displays the "An error has occured [Continue] [Cancel]" message
//
// Returns IDOK or IDCANCEL
//
int
FailedApplySecurityErrorDlg(HWND hWndParent, APPLY_SECURITY_ERROR* pae)
{
                //The progress dialog must be visible when this error message is shown
    if( !IsWindowVisible( pae->hwndParent ) )
    {
        ShowWindow( pae->hwndParent, SW_SHOW);
        SetForegroundWindow( pae->hwndParent );
    }


    return (int)DialogBoxParam(g_hInstance,
                               MAKEINTRESOURCE(IDD_SET_SECURITY_ERROR),
                               hWndParent,
                               FailedApplySecurityProc,
                               (LPARAM)pae);
}

#ifndef IDA_APPLYATTRIBS
// this is the resource ID of an AVI in shell32.dll. If shell32's
// resource ID's change, we'll get the wrong animation (or none).
// We could steal the AVI and build it into rshx32's resources, except
// it almost doubles the size of rshx32.dll (~35k to ~57k).
#define IDA_APPLYATTRIBS        165     // animation for applying file attributes
#endif

void
CNTFSSecurity::CreateProgressDialog(SECURITY_INFORMATION si)
{
    HRESULT hr = S_OK;
    // Shouldn't be necessary, but just in case
    CloseProgressDialog();

    // m_hwndOwner is the toplevel parent of the Security page
    m_hwndPopupOwner = GetLastActivePopup(m_hwndOwner);

    __try
    {
    hr = CoCreateInstance(CLSID_ProgressDialog,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IProgressDialog,
                          (void**)&m_pProgressDlg);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_OUTOFMEMORY;

    }

    if (SUCCEEDED(hr) && m_pProgressDlg)
    {
        WCHAR szT[256];
        UINT ids = IDS_RESET_SEC_TREE;
        IOleWindow *pWindow;

        LoadStringW(g_hInstance, IDS_PROPPAGE_TITLE, szT, ARRAYSIZE(szT));
        m_pProgressDlg->SetTitle(szT);

        switch (si)
        {
        case OWNER_SECURITY_INFORMATION:
            ids = IDS_RESET_OWNER_TREE;
            break;

        case SACL_SECURITY_INFORMATION:
            ids = IDS_RESET_SACL_TREE;
            break;

        case DACL_SECURITY_INFORMATION:
            ids = IDS_RESET_DACL_TREE;
            break;
        }
        LoadStringW(g_hInstance, ids, szT, ARRAYSIZE(szT));
        m_pProgressDlg->SetLine(1, szT, FALSE, NULL);

        m_pProgressDlg->SetAnimation(GetModuleHandle(TEXT("shell32.dll")), IDA_APPLYATTRIBS);
        m_pProgressDlg->StartProgressDialog(m_hwndPopupOwner,
                                            NULL,
                                            PROGDLG_MODAL | PROGDLG_NOTIME
                                             | PROGDLG_NOMINIMIZE | PROGDLG_NOPROGRESSBAR,
                                            NULL);

        if (SUCCEEDED(m_pProgressDlg->QueryInterface(IID_IOleWindow, (void**)&pWindow)))
        {
            pWindow->GetWindow(&m_hwndPopupOwner);
            pWindow->Release();
        }
    }
}

void
CNTFSSecurity::CloseProgressDialog(void)
{
    m_hwndPopupOwner = NULL;

    if (m_pProgressDlg)
    {
        m_pProgressDlg->StopProgressDialog();
        m_pProgressDlg->Release();
        m_pProgressDlg = NULL;
    }
}

HRESULT
CNTFSSecurity::SetProgress(LPTSTR pszFile)
{
    USES_CONVERSION;

    if (m_pProgressDlg)
    {
        m_pProgressDlg->SetLine(2, T2W(pszFile), TRUE, NULL);
        if (m_pProgressDlg->HasUserCancelled())
            return S_FALSE;
    }
    return S_OK;
}

HRESULT
CNTFSSecurity::BuildOwnerFullControlSD(PSECURITY_DESCRIPTOR pSD)
{
    PSID psidOwner;
    BOOL bDefaulted;
    DWORD dwAclLen;
    PACL pAcl;
    PACE_HEADER pAce;

    if (!GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted))
        return E_INVALIDARG;

    dwAclLen = sizeof(ACL)
        + sizeof(KNOWN_ACE) - sizeof(DWORD)
        + GetLengthSid(psidOwner);

    m_psdOwnerFullControl = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + dwAclLen);
    if (NULL == m_psdOwnerFullControl)
        return E_OUTOFMEMORY;

	HRESULT hr = S_OK;

    if(!InitializeSecurityDescriptor(m_psdOwnerFullControl, SECURITY_DESCRIPTOR_REVISION))
	{
		DWORD dwErr = GetLastError();
		ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"InitializeSecurityDescriptor failed");
	}
    
	pAcl = (PACL)ByteOffset(m_psdOwnerFullControl, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if(!InitializeAcl(pAcl, dwAclLen, ACL_REVISION))
	{
		DWORD dwErr = GetLastError();
		ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"InitializeAcl failed");
	}
    
	if(!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidOwner))
	{
		DWORD dwErr = GetLastError();
		ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"AddAccessAllowedAce failed");
	}
    pAce = (PACE_HEADER)FirstAce(pAcl);
    pAce->AceFlags = INHERIT_FULL;
    
	if(!SetSecurityDescriptorDacl(m_psdOwnerFullControl, TRUE, pAcl, TRUE))
	{
		DWORD dwErr = GetLastError();
		ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"SetSecurityDescriptorDacl failed");
	}

exit_gracefully:

	if(FAILED(hr))
	{
		if (m_psdOwnerFullControl)
			LocalFree(m_psdOwnerFullControl);

		m_psdOwnerFullControl = NULL;
	}

    TraceLeaveResult(hr);
}

VOID ProgressFunction(IN LPWSTR                   pObjectName,    
                      IN DWORD                    Status,         
                      IN OUT PPROG_INVOKE_SETTING pInvokeSetting ,
                      IN PVOID                    Args,
                      BOOL                        bSecuritySet)
{
    TraceEnter(TRACE_NTFSCOMPARE, "ProgressFunction");
    TraceAssert(pObjectName != NULL);
    TraceAssert(Args);
    
    PNTFS_PF_DATA pfData = (PNTFS_PF_DATA)(Args);
    CNTFSSecurity * pNTFSSec = pfData->pNTFSSec;
    HRESULT hr = S_OK;

    if( Status == ERROR_SUCCESS )
    {
        //
        // Notify the shell if we change permissions on a folder (48220)
        //
        if ( pfData->si & DACL_SECURITY_INFORMATION)
        {
            SHChangeNotify(SHCNE_UPDATEDIR,
                           SHCNF_PATH | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT,
                           pObjectName,
                           NULL);
        }
    }
    else
    {   
        //
        //This means it was able to set security on this folder and some error 
        //occured while enumerating child. 
        //
        if(bSecuritySet && pfData->si & OWNER_SECURITY_INFORMATION)
        {
            BOOL bIsFile = FALSE;
            hr = pNTFSSec->GiveOwnerFullControl(pObjectName, pfData->pSD, &bIsFile);
            if(hr == S_OK)
            {
                //
                //Look for comment in SetFileSecurityUsingNTName
                //
                *pInvokeSetting = bIsFile ?ProgressInvokeEveryObject:ProgressRetryOperation;
                TraceLeaveVoid();
            }
        }
        
        APPLY_SECURITY_ERROR ae = { ((PNTFS_PF_DATA)(Args))->pNTFSSec->GetHwndPopOwner(),HRESULT_FROM_WIN32(Status), pObjectName, { 0 } };
        if (IDOK != FailedApplySecurityErrorDlg( ((PNTFS_PF_DATA)(Args))->pNTFSSec->GetHwndPopOwner(), &ae))
        {
            *pInvokeSetting = ProgressCancelOperation;   // abort
            pfData->bCancel = TRUE;
        }
        else
        {
            *pInvokeSetting = ProgressInvokeEveryObject;      // continue
        }
    }
    
    if (S_FALSE == ((PNTFS_PF_DATA)(Args))->pNTFSSec->SetProgress(pObjectName))
	{
        *pInvokeSetting = ProgressCancelOperation;
		pfData->bCancel = TRUE;
	}
    
    TraceLeaveVoid();

}

HRESULT CNTFSSecurity::GiveOwnerFullControl( LPCWSTR lpszFileName, 
                                             PSECURITY_DESCRIPTOR pSD,  
                                             BOOL *pbIsFile)
{

    HRESULT hr = S_OK;


    // Ask the user if they want to grant themselves access
    if (!m_psdOwnerFullControl)
    {
        if (IDYES == MsgPopup(m_hwndPopupOwner,
            MAKEINTRESOURCE(IDS_FMT_WRITE_OWNER_ERR),
            MAKEINTRESOURCE(IDS_PROPPAGE_TITLE),
            MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND,
            g_hInstance,
            lpszFileName))
        {
            BuildOwnerFullControlSD(pSD);
        }
        else
        {
            // Continue without enumerating this folder
            TraceLeaveResult(S_FALSE);
        }
    }
    if (m_psdOwnerFullControl)
    {
        // Give the owner Full Control
        // Use SetFileSecurity         
        if(!SetFileSecurityUsingNTName(lpszFileName,
                                      m_psdOwnerFullControl,
                                      pbIsFile))
        {

            hr = E_FAIL;
        }

        if(SUCCEEDED(hr))
            TraceLeaveResult(S_OK);
    }
    TraceLeaveResult(S_FALSE);
}

GENERIC_MAPPING STANDARD_FILE_MAP=
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

STDMETHODIMP 
CNTFSSecurity::GetInheritSource( SECURITY_INFORMATION si,
                                 PACL pACL, 
                                 PINHERITED_FROM *ppInheritArray)
{
    HRESULT hr = S_OK;
    LPTSTR pszItem;
    DWORD dwErr = ERROR_SUCCESS;
    PINHERITED_FROM pTempInherit = NULL;
    PINHERITED_FROM pTempInherit2 = NULL;
    LPWSTR pStrTemp = NULL;
	BOOL bFreeInheritedFromArray = FALSE;
    TraceEnter(TRACE_SI, "CNTFSSecurity::GetInheritSource");
    TraceAssert(pACL != 0);
    TraceAssert(ppInheritArray != NULL);

    if( pACL == NULL || ppInheritArray == NULL )
        ExitGracefully(hr, E_POINTER, "Invalid Parameters, CNTFSSecurity::GetInheritSource");

    // Get the name of the first item
    pszItem = (LPTSTR)DPA_GetPtr(m_hItemList, 0);
    if (NULL == pszItem)
        ExitGracefully(hr, E_UNEXPECTED, "CSecurityInformation not initialized");


    pTempInherit = (PINHERITED_FROM)LocalAlloc( LPTR, sizeof(INHERITED_FROM)*pACL->AceCount);
    if(pTempInherit == NULL)
            ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");


    dwErr = GetInheritanceSource(pszItem,
                                 SE_FILE_OBJECT,
                                 si,
                                 m_dwSIFlags & SI_CONTAINER,
                                 NULL,
                                 0,
                                 pACL,
                                 NULL,
                                 &STANDARD_FILE_MAP,
                                 pTempInherit);
    
    hr = HRESULT_FROM_WIN32(dwErr);
    FailGracefully( hr, "GetInheritanceSource Failed");

	bFreeInheritedFromArray = TRUE;

    DWORD nSize;
    UINT i;

    nSize = sizeof(INHERITED_FROM)*pACL->AceCount;
    for(i = 0; i < pACL->AceCount; ++i)
    {
        if(pTempInherit[i].AncestorName)
            nSize += StringByteSize(pTempInherit[i].AncestorName);
    }

    pTempInherit2 = (PINHERITED_FROM)LocalAlloc( LPTR, nSize );
    if(pTempInherit2 == NULL)
        ExitGracefully(hr, E_OUTOFMEMORY,"OUT of Memory");
    
    pStrTemp = (LPWSTR)(pTempInherit2 + pACL->AceCount); 

    for(i = 0; i < pACL->AceCount; ++i)
    {
        pTempInherit2[i].GenerationGap = pTempInherit[i].GenerationGap;
        if(pTempInherit[i].AncestorName)
        {
            pTempInherit2[i].AncestorName = pStrTemp;
            wcscpy(pStrTemp,pTempInherit[i].AncestorName);
            pStrTemp += (wcslen(pTempInherit[i].AncestorName)+1);
        }
    }
            

exit_gracefully:

	if(bFreeInheritedFromArray)
		FreeInheritedFromArray(pTempInherit, pACL->AceCount,NULL);
    if(SUCCEEDED(hr))
    {        
        *ppInheritArray = pTempInherit2;
            
    }                        
    if(pTempInherit)
        LocalFree(pTempInherit);

    TraceLeaveResult(hr);
}



BOOL SetFileSecurityUsingNTName(IN LPCWSTR pszFileName,
                                IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                IN PBOOL pbIsFile)
{
	//
	//Set File Security
    //


    if (!SetFileSecurity(pszFileName,
						 DACL_SECURITY_INFORMATION,
						 pSecurityDescriptor))
		return FALSE;

    //When resetting the owner, if user is not owner and he doesn't have any permissions
    //TreeResetNamedSecurityInfo cannot determine if its a file or directory. So after 
    //setting the ownership TreeResetNamedSecurityInfo tries to enumerate the file, which fails
    //as there is nothing to enumerate and TreeResetNamedSecurityInfo calls ProgressFunction 
    //which stamps a FullControl on the file and ask TreeResetNamedSecurityInfo to retry
    //which again fails and we are infinte loop. The way to break this is ask TreeResetNamedSecurityInfo
    //not to retry if its a file. which is what we are doing below. Ugly, yup.


    //
    //default we assume its a file
    //if its a file and we assume its a dir, we are infinite loop
    //if its a dir and we assume its a file, we skip that dir which 
    //is lesser evil
    //
    *pbIsFile = TRUE;
        
    //
    //Open the file for Generic_read
    //
	WIN32_FILE_ATTRIBUTE_DATA fileAttrData;
	if (GetFileAttributesEx(pszFileName,
						    GetFileExInfoStandard,
						    &fileAttrData))
	{
		if(fileAttrData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			*pbIsFile = FALSE;

	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\ntfssi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ntfssi.h
//
//  This file contains the definition of the CNTFSSecurity object.
//
//--------------------------------------------------------------------------

#ifndef _NTFSSI_H_
#define _NTFSSI_H_

#include "si.h"

STDMETHODIMP
CheckFileAccess(LPCTSTR pszObjectName, LPDWORD pdwAccessGranted);

struct NTFS_COMPARE_DATA
{
    HDPA hItemList;
    DWORD dwSIFlags;
    SECURITY_INFORMATION siConflict;
    UINT idsSaclPrompt;
    UINT idsDaclPrompt;
    LPTSTR pszSaclConflict;
    LPTSTR pszDaclConflict;
    LPTSTR pszFailureMsg;           //If Comparison failed for some reason, this 
                                    //contain error message to display
    HRESULT hrResult;
    BOOL bAbortThread;

    NTFS_COMPARE_DATA(HDPA h, DWORD dw) : hItemList(h), 
                                          dwSIFlags(dw),    
                                          siConflict(0),
                                          idsSaclPrompt(0),
                                          idsDaclPrompt(0),
                                          pszSaclConflict(NULL),
                                          pszDaclConflict(NULL),
                                          pszFailureMsg(NULL) {}
    ~NTFS_COMPARE_DATA();
};
typedef NTFS_COMPARE_DATA *PNTFS_COMPARE_DATA;

class CNTFSSecurity;
struct NTFS_PF_DATA
{
    SECURITY_INFORMATION si;
    CNTFSSecurity * pNTFSSec;
    PSECURITY_DESCRIPTOR pSD;
    BOOL bCancel;
};
typedef NTFS_PF_DATA * PNTFS_PF_DATA;


class CNTFSSecurity : public CSecurityInformation
{
private:
    HANDLE              m_hCompareThread;
    PNTFS_COMPARE_DATA  m_pCompareData;
    IProgressDialog    *m_pProgressDlg;
    HWND                m_hwndPopupOwner;
    PSECURITY_DESCRIPTOR m_psdOwnerFullControl;
    LPWSTR              m_pszSystemDrive;
    LPWSTR              m_pszSystemRoot;
    BOOL m_bShowLossInheritedAclWarning;

public:
    CNTFSSecurity(SE_OBJECT_TYPE seType,BOOL bShowLossInheritedAclWarning);
    virtual ~CNTFSSecurity();

    STDMETHOD(Initialize)(HDPA   hItemList,
                          DWORD  dwFlags,
                          LPTSTR pszServer,
                          LPTSTR pszObject);

    // ISecurityInformation methods not handled by CSecurityInformation
    // or overridden here.
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
    STDMETHOD(GetInheritSource)(SECURITY_INFORMATION si,
                                PACL pACL, 
                                PINHERITED_FROM *ppInheritArray);

    HWND GetHwndPopOwner() { return m_hwndPopupOwner; }
    HRESULT SetProgress(LPTSTR pszFile);
    HRESULT GiveOwnerFullControl(LPCWSTR lpszFileName, PSECURITY_DESCRIPTOR pSD, PBOOL pbIsFile );

protected:

    HRESULT SetSecurityLocal(SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD,
                             LPBOOL pbNotAllApplied = NULL);
    void CreateProgressDialog(SECURITY_INFORMATION si);
    void CloseProgressDialog(void);

    HRESULT BuildOwnerFullControlSD(PSECURITY_DESCRIPTOR pSD);


    STDMETHOD(WriteObjectSecurity)(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD);

    void WaitForComparison();
    static DWORD WINAPI NTFSReadSD(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR* ppSD);
    static DWORD WINAPI NTFSCompareThreadProc(LPVOID pvData);
};

#endif  /* _NTFSSI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\security\rshx32\printsi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       printsi.cpp
//
//  This file contains the implementation of the CPrintSecurity object.
//
//--------------------------------------------------------------------------

#include "rshx32.h"


// The following array defines the permission names for NT printers.
SI_ACCESS siPrintAccesses[] =
{
    { &GUID_NULL, PRINTER_EXECUTE,           MAKEINTRESOURCE(IDS_PRINT_PRINT),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, PRINTER_ALL_ACCESS,        MAKEINTRESOURCE(IDS_PRINT_ADMINISTER),      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, JOB_ALL_ACCESS,            MAKEINTRESOURCE(IDS_PRINT_ADMINISTER_JOBS), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC | OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE },
//    { &GUID_NULL, DELETE,                    MAKEINTRESOURCE(IDS_PRINT_DELETE),          SI_ACCESS_SPECIFIC },
    { &GUID_NULL, STANDARD_RIGHTS_READ,      MAKEINTRESOURCE(IDS_PRINT_READ),            SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                 MAKEINTRESOURCE(IDS_PRINT_CHANGE_PERM),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,               MAKEINTRESOURCE(IDS_PRINT_CHANGE_OWNER),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, PRINTER_ALL_ACCESS|JOB_ALL_ACCESS, MAKEINTRESOURCE(IDS_PRINT_JOB_ALL), 0 },
    { &GUID_NULL, 0,                         MAKEINTRESOURCE(IDS_NONE),                  0 },
};
#define iPrintDefAccess     0   // PRINTER_EXECUTE (i.e. "Print" access)

#define PRINTER_ALL_AUDIT           (PRINTER_ALL_ACCESS | ACCESS_SYSTEM_SECURITY)
#define JOB_ALL_AUDIT               (JOB_ALL_ACCESS | ACCESS_SYSTEM_SECURITY)
#define PRINTER_JOB_ALL_AUDIT       (PRINTER_ALL_ACCESS | JOB_ALL_ACCESS | ACCESS_SYSTEM_SECURITY)

// The following array defines the auditting names for NT printers.
SI_ACCESS siPrintAudits[] =
{
    { &GUID_NULL, PRINTER_EXECUTE,           MAKEINTRESOURCE(IDS_PRINT_PRINT),           SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, PRINTER_ALL_AUDIT,         MAKEINTRESOURCE(IDS_PRINT_ADMINISTER),      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, JOB_ALL_AUDIT,             MAKEINTRESOURCE(IDS_PRINT_ADMINISTER_JOBS), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC | OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE },
//    { &GUID_NULL, DELETE,                    MAKEINTRESOURCE(IDS_PRINT_DELETE),          SI_ACCESS_SPECIFIC },
    { &GUID_NULL, STANDARD_RIGHTS_READ,      MAKEINTRESOURCE(IDS_PRINT_READ),            SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,                 MAKEINTRESOURCE(IDS_PRINT_CHANGE_PERM),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,               MAKEINTRESOURCE(IDS_PRINT_CHANGE_OWNER),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, PRINTER_ALL_AUDIT|JOB_ALL_AUDIT, MAKEINTRESOURCE(IDS_PRINT_JOB_ALL),   0 },
    { &GUID_NULL, 0,                         MAKEINTRESOURCE(IDS_NONE),                  0 },
};
#define iPrintDefAudit      0   // PRINTER_EXECUTE (i.e. "Print" access)

// The following array defines the inheritance types for NT printers.
SI_INHERIT_TYPE siPrintInheritTypes[] =
{
    &GUID_NULL, 0,                                     MAKEINTRESOURCE(IDS_PRINT_PRINTER),
    &GUID_NULL, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_PRINT_DOCUMENT_ONLY),
    &GUID_NULL, OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_PRINT_PRINTER_DOCUMENT),
};


BOOL
GetPrinterAlloc(HANDLE hPrinter, DWORD dwLevel, LPBYTE *ppBuffer)
{
    BOOL bResult;
    DWORD dwLength = 0;
    LPBYTE pBuffer = NULL;

    bResult = GetPrinter(hPrinter, dwLevel, NULL, 0, &dwLength);
    if (dwLength)
    {
        bResult = FALSE;
        pBuffer = (LPBYTE)LocalAlloc(LPTR, dwLength);
        if (pBuffer)
        {
            bResult = GetPrinter(hPrinter, dwLevel, pBuffer, dwLength, &dwLength);
            if (!bResult)
            {
                LocalFree(pBuffer);
                pBuffer = NULL;
            }
        }
    }
    *ppBuffer = pBuffer;
    return bResult;
}


STDMETHODIMP
CheckPrinterAccess(LPCTSTR pszObjectName,
                   LPDWORD pdwAccessGranted,
                   LPTSTR  pszServer,
                   ULONG   cchServer)
{
    HRESULT hr = S_OK;
    UINT i;
    PRINTER_DEFAULTS PrinterDefaults;
    DWORD dwAccessDesired[] = { ALL_SECURITY_ACCESS,
                                READ_CONTROL,
                                WRITE_DAC,
                                WRITE_OWNER,
                                ACCESS_SYSTEM_SECURITY };
    HANDLE hPrinter = NULL;

    PrinterDefaults.pDatatype = NULL;
    PrinterDefaults.pDevMode  = NULL;

    TraceEnter(TRACE_PRINTSI, "CheckPrinterAccess");
    TraceAssert(pdwAccessGranted != NULL);

    __try
    {
        *pdwAccessGranted = 0;

        for (i = 0; i < ARRAYSIZE(dwAccessDesired); i++)
        {
            if ((dwAccessDesired[i] & *pdwAccessGranted) == dwAccessDesired[i])
                continue;   // already have this access

            PrinterDefaults.DesiredAccess = dwAccessDesired[i];

            if (OpenPrinter((LPTSTR)pszObjectName, &hPrinter, &PrinterDefaults))
            {
                *pdwAccessGranted |= dwAccessDesired[i];
                ClosePrinter(hPrinter);
            }
            else
            {
                DWORD dwErr = GetLastError();

                if (dwErr != ERROR_ACCESS_DENIED &&
                    dwErr != ERROR_PRIVILEGE_NOT_HELD)
                {
                    ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "OpenPrinter failed");
                }
            }
        }

        if (pszServer)
        {
            PrinterDefaults.DesiredAccess = PRINTER_READ;
            if (OpenPrinter((LPTSTR)pszObjectName, &hPrinter, &PrinterDefaults))
            {
                PPRINTER_INFO_2 ppi = NULL;
                if (GetPrinterAlloc(hPrinter, 2, (LPBYTE*)&ppi))
                {
                    if (ppi && ppi->pServerName)
                        lstrcpyn(pszServer, ppi->pServerName, cchServer);
                    else
                        *pszServer = TEXT('\0');
                    LocalFree(ppi);
                }
                ClosePrinter(hPrinter);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
    }

exit_gracefully:

    Trace((TEXT("Access = 0x%08x"), *pdwAccessGranted));
    TraceLeaveResult(hr);
}


STDMETHODIMP
CPrintSecurity::Initialize(HDPA     hItemList,
                           DWORD    dwFlags,
                           LPTSTR   pszServer,
                           LPTSTR   pszObject)
{
    return CSecurityInformation::Initialize(hItemList,
                                            dwFlags | SI_NO_TREE_APPLY | SI_NO_ACL_PROTECT,
                                            pszServer,
                                            pszObject);
}


//
// NT6 REVIEW
//
// GetAceSid, FindManagePrinterACE, MungeAclForPrinter and
// CPrintSecurity::SetSecurity only exist here because
// 1) The spooler removes JOB_ACCESS_ADMINISTER from an ACE unless the
//    ACE has INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE.
// 2) The NT4 ACL editor (ACLEDIT) needs extra bogus ACEs to recognize
//    "Manage Documents" access. (Must support downlevel clients.)
//
// The first case should be rare, since you have to perform certain
// steps in the NT5 ACL editor (ACLUI) to cause this situation. The
// second situation is common, since CREATER_OWNER and Administrators
// usually have "Manage Documents" access.
//
// If the spooler guys decide to not support NT4 clients for NT6, and they
// stop stripping JOB_ACCESS_ADMINISTER from ACEs, then MungeAclForPrinter
// and CPrintSecurity::SetSecurity can be removed entirely. ENCOURAGE THEM
// TO MAKE THAT CHANGE. (They can also remove similar hacks from their own
// code that add bogus ACEs for the old ACL editor.)
//

PSID
GetAceSid(PACE_HEADER pAce)
{
    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        return (PSID)&((PKNOWN_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        return (PSID)&((PCOMPOUND_ACCESS_ALLOWED_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        return RtlObjectAceSid(pAce);
    }

    return NULL;
}

PACE_HEADER
FindManagePrinterACE(PACL pAcl, PSID pSid)
{
    UINT i;
    PACE_HEADER pAce;

    if (!pAcl || !pSid)
        return NULL;

    for (i = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
         i < pAcl->AceCount;
         i++, pAce = (PACE_HEADER)NextAce(pAce))
    {
        if (pAce->AceType == ACCESS_ALLOWED_ACE_TYPE
            && (((PKNOWN_ACE)pAce)->Mask & PRINTER_ALL_ACCESS) == PRINTER_ALL_ACCESS
            && !(pAce->AceFlags & INHERIT_ONLY_ACE)
            && EqualSid(pSid, GetAceSid(pAce)))
        {
            return pAce;
        }
    }

    return NULL;
}

BOOL
MungeAclForPrinter(PACL pAcl, PACL *ppAclOut)
{
    USHORT i;
    PACE_HEADER pAce;
    PACE_HEADER pAceCopy = NULL;

    if (ppAclOut == NULL)
        return FALSE;

    *ppAclOut = NULL;

    if (pAcl == NULL)
        return TRUE;

    TraceEnter(TRACE_PRINTSI, "MungeAclForPrinter");

    for (i = 0, pAce = (PACE_HEADER)FirstAce(pAcl);
         i < pAcl->AceCount;
         i++, pAce = (PACE_HEADER)NextAce(pAce))
    {
        //
        // If this ACE has the JOB_ACCESS_ADMINISTER bit and the inherit
        // flags indicate that it applies to both printers and documents,
        // then we need to treat it specially, since the spooler won't save
        // JOB_ACCESS_ADMINISTER on a printer ACE (INHERIT_ONLY_ACE not set).
        //
        if ((((PKNOWN_ACE)pAce)->Mask & JOB_ACCESS_ADMINISTER) &&
            (pAce->AceFlags & (INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE)) == OBJECT_INHERIT_ACE)
        {
            //
            // Split into 2 aces: one with no inheritance, and one with
            // INHERIT_ONLY_ACE turned on. Let the spooler do whatever
            // it wants with the mask.
            //
            // This requires allocating a larger ACL and copying all
            // previous aces over.
            //

            TraceMsg("Splitting JOB_ACCESS_ADMINISTER ACE into 2");

            if (*ppAclOut == NULL)
            {
                //
                // Allocate new ACL and copy previous aces.  The length is enough
                // for 1 copy of all previous aces, and 3 copies (max) of all
                // remaining aces.
                //
                ULONG nPrevLength = (ULONG)((ULONG_PTR)pAce - (ULONG_PTR)pAcl);
                *ppAclOut = (PACL)LocalAlloc(LPTR, nPrevLength + (pAcl->AclSize - nPrevLength) * 3);
                if (!*ppAclOut)
                    TraceLeaveValue(FALSE);

                CopyMemory(*ppAclOut, pAcl, nPrevLength);
                (*ppAclOut)->AclSize = (USHORT)LocalSize(*ppAclOut);
                (*ppAclOut)->AceCount = i;
                pAceCopy = (PACE_HEADER)ByteOffset(*ppAclOut, nPrevLength);
            }

            // Turn off inheritance and copy this ace
            pAce->AceFlags &= ~OBJECT_INHERIT_ACE;
            CopyMemory(pAceCopy, pAce, pAce->AceSize);
            pAceCopy = (PACE_HEADER)NextAce(pAceCopy);
            (*ppAclOut)->AceCount++;

            // Now turn on inheritance (with INHERIT_ONLY_ACE) and copy it
            // again (it gets copied way down below).  Note that this may
            // causes the next IF clause to add a bogus ACE also.
            pAce->AceFlags |= OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE;
        }

        //
        // If this ACE has JOB_ALL_ACCESS and INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,
        // and there isn't also a "Manage Printers" ACE for the same SID, add a
        // bogus ACE with READ_CONTROL and CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE.
        // The old ACL editor on downlevel clients needs this to recognize
        // "Manage Documents" access.
        //
        if (pAce->AceType == ACCESS_ALLOWED_ACE_TYPE
            && (((PKNOWN_ACE)pAce)->Mask & JOB_ALL_ACCESS) == JOB_ALL_ACCESS
            && (pAce->AceFlags & (INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE)) == (INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE)
            && !FindManagePrinterACE(pAcl, GetAceSid(pAce)))
        {
            TraceMsg("Adding bogus ACE for downlevel support");

            if (*ppAclOut == NULL)
            {
                //
                // Allocate new ACL and copy previous aces.  The length is enough
                // for 1 copy of all previous aces, and 3 copies (max) of all
                // remaining aces.
                //
                ULONG nPrevLength = (ULONG)((ULONG_PTR)pAce - (ULONG_PTR)pAcl);
                *ppAclOut = (PACL)LocalAlloc(LPTR, nPrevLength + (pAcl->AclSize - nPrevLength) * 3);
                if (!*ppAclOut)
                    TraceLeaveValue(FALSE);

                CopyMemory(*ppAclOut, pAcl, nPrevLength);
                (*ppAclOut)->AclSize = (USHORT)LocalSize(*ppAclOut);
                (*ppAclOut)->AceCount = i;
                pAceCopy = (PACE_HEADER)ByteOffset(*ppAclOut, nPrevLength);
            }

            // Copy this ace, turn on CONTAINER_INHERIT_ACE, and set
            // the mask to STANDARD_RIGHTS_READ.
            CopyMemory(pAceCopy, pAce, pAce->AceSize);
            pAceCopy->AceFlags &= ~OBJECT_INHERIT_ACE;
            pAceCopy->AceFlags |= INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE;
            ((PKNOWN_ACE)pAceCopy)->Mask = STANDARD_RIGHTS_READ;
            pAceCopy = (PACE_HEADER)NextAce(pAceCopy);
            (*ppAclOut)->AceCount++;
        }

        if (*ppAclOut != NULL)
        {
            // Copy current ace
            CopyMemory(pAceCopy, pAce, pAce->AceSize);
            pAceCopy = (PACE_HEADER)NextAce(pAceCopy);
            (*ppAclOut)->AceCount++;
        }
    }

    if (*ppAclOut != NULL)
    {
        TraceAssert((ULONG_PTR)pAceCopy > (ULONG_PTR)*ppAclOut &&
                    (ULONG_PTR)pAceCopy <= (ULONG_PTR)*ppAclOut + (*ppAclOut)->AclSize);

        // Set the ACL size to the correct value
        (*ppAclOut)->AclSize = (WORD)((ULONG_PTR)pAceCopy - (ULONG_PTR)*ppAclOut);
    }

    TraceLeaveValue(TRUE);
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CPrintSecurity::SetSecurity(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    PACL pDaclCopy = NULL;
    PACL pSaclCopy = NULL;
    BOOL bPresent;
    BOOL bDefaulted;
    SECURITY_DESCRIPTOR sd;

    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::SetSecurity");

	HRESULT hr = S_OK;

    if ((si & DACL_SECURITY_INFORMATION)
        && GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted)
        && bPresent)
    {
        if (MungeAclForPrinter(pDacl, &pDaclCopy) && pDaclCopy)
            pDacl = pDaclCopy;
    }

    if ((si & SACL_SECURITY_INFORMATION)
        && GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted)
        && bPresent)
    {
        if (MungeAclForPrinter(pSacl, &pSaclCopy) && pSaclCopy)
            pSacl = pSaclCopy;
    }

    if (pDaclCopy || pSaclCopy)
    {
        // Build a new SECURITY_DESCRIPTOR
        PSID psid;
        DWORD dwRevision;
        SECURITY_DESCRIPTOR_CONTROL sdControl = 0;

        if(!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision))
		{
			DWORD dwErr = GetLastError();
			ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"GetSecurityDescriptorControl failed");
		}

        if(!InitializeSecurityDescriptor(&sd, dwRevision))
		{
			DWORD dwErr = GetLastError();
			ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"InitializeSecurityDescriptor failed");
		}

        sd.Control = (SECURITY_DESCRIPTOR_CONTROL)(sdControl & ~SE_SELF_RELATIVE);

        if ((si & OWNER_SECURITY_INFORMATION)
            && GetSecurityDescriptorOwner(pSD, &psid, &bDefaulted))
        {
            if(!SetSecurityDescriptorOwner(&sd, psid, bDefaulted))
			{
				DWORD dwErr = GetLastError();
				ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"SetSecurityDescriptorOwner failed");
			}

        }

        if ((si & GROUP_SECURITY_INFORMATION)
            && GetSecurityDescriptorGroup(pSD, &psid, &bDefaulted))
        {
            if(!SetSecurityDescriptorGroup(&sd, psid, bDefaulted))
			{
				DWORD dwErr = GetLastError();
				ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"SetSecurityDescriptorGroup failed");
			}

        }

        if (si & SACL_SECURITY_INFORMATION)
        {
            if(!SetSecurityDescriptorSacl(&sd,
                                      sdControl & SE_SACL_PRESENT,
                                      pSacl,
                                      sdControl & SE_SACL_DEFAULTED))
			{
				DWORD dwErr = GetLastError();
				ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"SetSecurityDescriptorSacl failed");
			}

        }

        if (si & DACL_SECURITY_INFORMATION)
        {
            if(!SetSecurityDescriptorDacl(&sd,
                                      sdControl & SE_DACL_PRESENT,
                                      pDacl,
                                      sdControl & SE_DACL_DEFAULTED))
			{
				DWORD dwErr = GetLastError();
				ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr),"SetSecurityDescriptorDacl failed");
			}

        }

        // Switch to the new security descriptor
        pSD = &sd;
    }

    // The base class does the rest of the work
    hr = CSecurityInformation::SetSecurity(si, pSD);

exit_gracefully:

    if (pDaclCopy)
        LocalFree(pDaclCopy);

    if (pSaclCopy)
        LocalFree(pSaclCopy);

    TraceLeaveResult(hr);
}

STDMETHODIMP
CPrintSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::GetAccessRights");
    TraceAssert(ppAccesses != NULL);
    TraceAssert(pcAccesses != NULL);
    TraceAssert(piDefaultAccess != NULL);

    if (dwFlags & SI_EDIT_AUDITS)
    {
        *ppAccesses = siPrintAudits;
        *pcAccesses = ARRAYSIZE(siPrintAudits);
        *piDefaultAccess = iPrintDefAudit;
    }
    else
    {
        *ppAccesses = siPrintAccesses;
        *pcAccesses = ARRAYSIZE(siPrintAccesses);
        *piDefaultAccess = iPrintDefAccess;
    }

    TraceLeaveResult(S_OK);
}


GENERIC_MAPPING JobMap =
{
    JOB_READ,
    JOB_WRITE,
    JOB_EXECUTE,
    JOB_ALL_ACCESS
};

GENERIC_MAPPING PrinterMap =
{
    PRINTER_READ,
    PRINTER_WRITE,
    PRINTER_EXECUTE,
    PRINTER_ALL_ACCESS
};

GENERIC_MAPPING FullPrinterMap =
{
    PRINTER_READ | JOB_READ,
    PRINTER_WRITE | JOB_WRITE,
    PRINTER_EXECUTE | JOB_EXECUTE,
    PRINTER_ALL_ACCESS | JOB_ALL_ACCESS
};

STDMETHODIMP
CPrintSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pmask)
{
    PGENERIC_MAPPING pMap;

    TraceEnter(TRACE_PRINTSI, "CPrintSecurity::MapGeneric");
    TraceAssert(pAceFlags != NULL);
    TraceAssert(pmask != NULL);

    // This flag has no meaning for printers, but it's often turned on
    // in legacy ACLs.  Turn it off here
    *pAceFlags &= ~CONTAINER_INHERIT_ACE;

    // Choose the correct generic mapping according to the inherit
    // scope of this ACE.
    if (*pAceFlags & OBJECT_INHERIT_ACE)
    {
        if (*pAceFlags & INHERIT_ONLY_ACE)
            pMap = &JobMap;                 // documents only
        else
            pMap = &FullPrinterMap;         // printers & documents
    }
    else
        pMap = &PrinterMap;                 // printers only

    // Note that the case where INHERIT_ONLY_ACE is ON but OBJECT_INHERIT_ACE
    // is OFF falls under the "printers only" case above. However, this
    // case makes no sense (inherit-only, but not onto documents) and it
    // doesn't matter how we do the mapping.

    // Map any generic bits to standard & specific bits.
    // When using the NT5 ACL APIs, ntmarta.dll maps generic bits, so this
    // isn't always necessary, but we'll do it anyway to be sure.
    MapGenericMask(pmask, pMap);

    // Turn off any extra bits that ntmarta.dll may have turned on
    // (ntmarta uses a different mapping).  But leave ACCESS_SYSTEM_SECURITY
    // alone in case we're editing a SACL.
