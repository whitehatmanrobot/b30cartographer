GetPixelPitch(pDest),
                   DDSurf_GetChipPixelSize(pDest),
                   rSrc,
                   rDest);
                     
} // _DD_P3DownloadDD

//-----------------------------------------------------------------------------
//
// _DD_P3DownloadDstCh
//
// Function to do an image download to the rectangular region.
// Uses the packed bit on Permedia to do the packing for us.  
//
//-----------------------------------------------------------------------------
void 
_DD_P3DownloadDstCh(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt,
    RECTL* rSrc,
    RECTL* rDest)
{
    // Work out pixel offset into the framestore of the rendered surface
    ULONG ulSCRoundedUpDWords;
    ULONG ulSCWholeDWords, ulSCDWordsCnt, ulSCExtraBytes;
    ULONG ulTotalImageDWORDs;
    DWORD SrcOffset; 
    ULONG ulImageLines;
    ULONG count;
    ULONG renderData;
    DWORD dwDownloadTag;
    int rDestleft, rDesttop, rSrcleft, rSrctop;
    RECTL rNewDest;
    BOOL bDstKey = FALSE;
    P3_DMA_DEFS();
                
    // Because of a bug in RL we sometimes have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("_DD_P3DownloadDstCh", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }    
    
       
    SrcOffset = (DWORD)(rSrc->left << DDSurf_GetChipPixelSize(pDest)) + (rSrc->top * pSource->lpGbl->lPitch);

    ulSCRoundedUpDWords = rDest->right - rDest->left;
    ulImageLines = rDest->bottom - rDest->top;

    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(FBWriteBufferAddr0, DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
    SEND_P3_DATA(FBWriteBufferWidth0, DDSurf_GetPixelPitch(pDest));
    SEND_P3_DATA(FBWriteBufferOffset0, (rDest->top << 16) | (rDest->left & 0xFFFF));

    SEND_P3_DATA(LogicalOpMode, 7);

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    if (lpBlt->dwFlags & DDBLT_KEYDESTOVERRIDE)
    {
        bDstKey = TRUE;

        // Dest keying.
        // The conventional chroma test is set up to key off the dest - the framebuffer.
        SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_FBDATA) |
                                        P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_PASS) |
                                        P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_REJECT)
                                        );

        SEND_P3_DATA(ChromaLower, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceLowValue);
        SEND_P3_DATA(ChromaUpper, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceHighValue);

        // The source buffer is the source for the destination color key
        SEND_P3_DATA(FBSourceReadBufferAddr, DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
        SEND_P3_DATA(FBSourceReadBufferWidth, DDSurf_GetPixelPitch(pDest));
        SEND_P3_DATA(FBSourceReadBufferOffset, (rDest->top << 16) | (rDest->left & 0xFFFF));
    
        // Enable source reads to get the colorkey color
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_FBSOURCEREAD_LAYOUT(P3RX_LAYOUT_LINEAR));
    }
    else
    {
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_DISABLE));
    }

    SEND_P3_DATA(FBWriteMode, P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                                P3RX_FBWRITEMODE_LAYOUT0(P3RX_LAYOUT_LINEAR));
    SEND_P3_DATA(FBDestReadMode, P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE) |
                                    P3RX_FBDESTREAD_LAYOUT0(P3RX_LAYOUT_LINEAR));


    // This dest-colorkey download always needs to send unpacked color data
    // because it can't use spans.
    SEND_P3_DATA(DownloadTarget, Color_Tag);
    switch (DDSurf_GetChipPixelSize(pDest))
    {
        case __GLINT_8BITPIXEL:
            dwDownloadTag = Packed8Pixels_Tag;
            break;
        case __GLINT_16BITPIXEL:
            dwDownloadTag = Packed16Pixels_Tag;
            break;
        default:
            dwDownloadTag = Color_Tag;
            break;
    }
    
    rNewDest = *rDest;

    DISPDBG((DBGLVL, "Image download %dx%d", ulSCRoundedUpDWords, ulImageLines));

    if (DDSurf_GetChipPixelSize(pDest) != __GLINT_32BITPIXEL) 
    {
        if (DDSurf_GetChipPixelSize(pDest) == __GLINT_8BITPIXEL) 
        {
            ulSCExtraBytes  = ulSCRoundedUpDWords & 3;
            ulSCWholeDWords = ulSCRoundedUpDWords >> 2;
            ulSCRoundedUpDWords = (ulSCRoundedUpDWords + 3) >> 2;
            
            if (dwDownloadTag != Color_Tag)
            {
                rNewDest.right = rNewDest.left + (ulSCRoundedUpDWords << 2);
            }
        }
        else 
        {
            ulSCExtraBytes  = (ulSCRoundedUpDWords & 1) << 1;
            ulSCWholeDWords = ulSCRoundedUpDWords >> 1;
            ulSCRoundedUpDWords = (ulSCRoundedUpDWords + 1) >> 1;

            if (dwDownloadTag != Color_Tag)
            {
                rNewDest.right = rNewDest.left + (ulSCRoundedUpDWords << 1);
            }
        }
    }

    // Calc the total number of image DWORDs to send to GPU
    ulTotalImageDWORDs = ulImageLines * ulSCWholeDWords;

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(RectanglePosition, 0);


    // Don't use spans for the unpacking scheme, but use the 2D Setup
    // unit to do the work of setting up the destination
    SEND_P3_DATA(ScissorMinXY, 0 )
    SEND_P3_DATA(ScissorMaxXY,P3RX_SCISSOR_X_Y(rDest->right - rDest->left ,
                                               rDest->bottom - rDest->top ));
    SEND_P3_DATA(ScissorMode, P3RX_SCISSORMODE_USER(__PERMEDIA_ENABLE));
    
    renderData =  P3RX_RENDER2D_WIDTH( (rNewDest.right - rNewDest.left) & 0xfff )
                | P3RX_RENDER2D_HEIGHT( 0 )
                | P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_SYNC_ON_HOST_DATA )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_FBREADSOURCEENABLE((bDstKey ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE));
    SEND_P3_DATA(Render2D, renderData);
    SEND_P3_DATA(Count, rNewDest.bottom - rNewDest.top );
    SEND_P3_DATA(Render, P3RX_RENDER_PRIMITIVETYPE(P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID) |
                         P3RX_RENDER_SYNCONHOSTDATA(__PERMEDIA_ENABLE) |
                         P3RX_RENDER_FBSOURCEREADENABLE((bDstKey ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE)));
    
    _try
    {
        BYTE *pSurfaceData = (BYTE *)pSource->lpGbl->fpVidMem + SrcOffset;
        DWORD *pCurrentLine = (DWORD *)pSurfaceData;
        
        while (ulImageLines-- > 0)
        {
            DISPDBG((DBGLVL, "Image download lines %d", ulImageLines));

            // Initialize the number of DWORDs counter
            ulSCDWordsCnt = ulSCWholeDWords;

            // Send the texels in DWORDS
            while (ulSCDWordsCnt >= BLOCK_SIZE)
            {
                P3_ENSURE_DX_SPACE(BLOCK_SIZE + 1);
                WAIT_FIFO(BLOCK_SIZE + 1);
                ADD_FUNNY_DWORD(TAGGED_SIZE | dwDownloadTag);

                for (count = BLOCK_SIZE / UNROLL_COUNT; count; count--)
                {
                    DISPDBG((DBGLVL, "Image download count %d", count));
                    UNROLLED();
                }
                ulSCDWordsCnt -= BLOCK_SIZE;
            }

            // Finish off the rest of the whole DWORDs on the scanline
            if (ulSCDWordsCnt) 
            {
                P3_ENSURE_DX_SPACE(ulSCDWordsCnt + 1);
                WAIT_FIFO(ulSCDWordsCnt + 1);
                ADD_FUNNY_DWORD(((ulSCDWordsCnt - 1) << 16) | dwDownloadTag);
                for (count = 0; count < ulSCDWordsCnt; count++, pCurrentLine++) 
                {
                    ADD_FUNNY_DWORD(*pCurrentLine);
                    ulTotalImageDWORDs--;
                }
            }

            // Finish off the extra bytes at the end of the scanline
            if (ulSCExtraBytes)
            {
                DWORD dwTemp;

                P3_ENSURE_DX_SPACE(1 + 1);   // 1 tag + 1 data DWORD
                WAIT_FIFO(1 + 1);
                ADD_FUNNY_DWORD(dwDownloadTag);

                memcpy(&dwTemp, pCurrentLine, ulSCExtraBytes);
                ADD_FUNNY_DWORD(dwTemp);
                ulTotalImageDWORDs--;
            }

            pSurfaceData += pSource->lpGbl->lPitch;
            pCurrentLine = (DWORD*)pSurfaceData;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DISPDBG((ERRLVL, "Perm3 caused exception at line %u of file %s",
                         __LINE__,__FILE__));
        // Send enough DWORDs to the GPU to avoid deadlock
        for (count = 0; count < ulTotalImageDWORDs; count++)
        {
            ADD_FUNNY_DWORD(dwDownloadTag);
            ADD_FUNNY_DWORD(0);                 // Dummy pixel data
        }
    }

    P3_ENSURE_DX_SPACE(6);
    WAIT_FIFO(6);

    SEND_P3_DATA(WaitForCompletion, 0);
    SEND_P3_DATA(ScissorMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBSourceReadMode, __PERMEDIA_DISABLE);

    // Put back the values if we changed them.
    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();

}  //_DD_P3DownloadDstCh
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddbltfx.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddbltfx.c
*
* Content: DirectDraw Blt implementation for stretching blts
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "glintdef.h"
#include "dma.h"
#include "tag.h"
#include "chroma.h"

// A magic number to make it all work.
// This must be 11 or less, according to the P3 spec.
#define MAGIC_NUMBER_2D 11

//-----------------------------------------------------------------------------
//
// _DD_P3BltSourceChroma
//
// Do a blt with no stretching, but with source chroma keying
//
//-----------------------------------------------------------------------------
void 
_DD_P3BltSourceChroma(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt, 
    RECTL *rSrc,
    RECTL *rDest)
{
    LONG    rSrctop, rSrcleft, rDesttop, rDestleft;
    BOOL    b8to8blit;
    BOOL    bBlocking;
    DWORD   dwRenderDirection;
    DWORD   dwSourceOffset;
    DWORD   dwLowerSrcBound, dwUpperSrcBound;
    
    P3_DMA_DEFS();

    // Beacuse of a bug in RL we sometimes 
    // have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("_DD_P3BltSourceChroma", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }

    if ( ( pFormatDest->DeviceFormat == SURF_CI8 ) && 
         ( pFormatSource->DeviceFormat == SURF_CI8 ) )
    {
        // An 8bit->8bit blit. This is treated specially, since no LUT translation is involved.
        b8to8blit = TRUE;
    }
    else
    {
        b8to8blit = FALSE;
    } 
    
    DISPDBG((DBGLVL, "P3 Chroma (before): Upper = 0x%08x, Lower = 0x%08x", 
                     lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue,
                     lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue));

    // Prepare data to be used as color keying limits
    if ( b8to8blit )
    {
        // No conversion, just use the index value in the R channel.
        dwLowerSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue & 0x000000ff;
        dwUpperSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue | 0xffffff00;
    }     
    else
    {
        dwLowerSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
        dwUpperSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue;
        if ( pFormatSource->DeviceFormat == SURF_8888 )       
        {
            //
            // Mask off alpha channel when a single source color key is used
//@@BEGIN_DDKSPLIT        
            // IZ : This can be a problem when a color key range is used.
//@@END_DDKSPLIT
            //

            dwUpperSrcBound |= 0xFF000000;
            dwLowerSrcBound &= 0x00FFFFFF;
        }
    }
    
    DISPDBG((DBGLVL, "P3 Chroma (after): Upper = 0x%08x, Lower = 0x%08x",
                     dwUpperSrcBound, dwLowerSrcBound));


    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(pSource->lpGbl->fpVidMem, 
                                                 pDest->lpGbl->fpVidMem,
                                                 rSrc,
                                                 rDest,
                                                 &bBlocking);
   
    P3_DMA_GET_BUFFER_ENTRIES(32);

    // Even though the AlphaBlend is disabled, the chromakeying uses
    // the ColorFormat, ColorOrder and ColorConversion fields.

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    SEND_P3_DATA(AlphaBlendColorMode,   
              P3RX_ALPHABLENDCOLORMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDCOLORMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_ALPHABLENDCOLORMODE_COLORORDER ( COLOR_MODE )
            | P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
            
    SEND_P3_DATA(AlphaBlendAlphaMode,   
              P3RX_ALPHABLENDALPHAMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_ALPHATYPE ( P3RX_ALPHABLENDMODE_ALPHATYPE_OGL )
            | P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );

    // Setup the hw chromakeying registers
    SEND_P3_DATA(ChromaTestMode, 
              P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) 
            | P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_FBDATA) 
            | P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_REJECT) 
            | P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_PASS)
            );

    SEND_P3_DATA(ChromaLower, dwLowerSrcBound);
    SEND_P3_DATA(ChromaUpper, dwUpperSrcBound);  

    SEND_P3_DATA(LogicalOpMode, GLINT_ENABLED_LOGICALOP( __GLINT_LOGICOP_NOOP ));

    SEND_P3_DATA(FBWriteBufferAddr0, 
                 DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
                 
    SEND_P3_DATA(FBWriteBufferWidth0, DDSurf_GetPixelPitch(pDest));
    SEND_P3_DATA(FBWriteBufferOffset0, 0);

    SEND_P3_DATA(FBSourceReadBufferAddr, 
                 DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSource));
                 
    SEND_P3_DATA(FBSourceReadBufferWidth, DDSurf_GetPixelPitch(pSource));

    dwSourceOffset = (( rSrc->top - rDest->top   ) << 16 ) | 
                     (( rSrc->left - rDest->left ) & 0xffff );
                     
    SEND_P3_DATA(FBSourceReadBufferOffset, dwSourceOffset);

    SEND_P3_DATA(FBDestReadMode, 
              P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE) 
            | P3RX_FBDESTREAD_LAYOUT0(P3RX_LAYOUT_LINEAR));
            
    SEND_P3_DATA(FBWriteMode, 
              P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) 
            | P3RX_FBWRITEMODE_LAYOUT0(P3RX_LAYOUT_LINEAR));

    SEND_P3_DATA(FBSourceReadMode, 
              P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) 
            | P3RX_FBSOURCEREAD_LAYOUT(P3RX_LAYOUT_LINEAR) 
            | P3RX_FBSOURCEREAD_BLOCKING(bBlocking));
            
    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(30);

    // Can't use 2D setup because we aren't rendering with spans.
    if (dwRenderDirection == 0)
    {
        // right to left, bottom to top
        SEND_P3_DATA(StartXDom, (rDest->right << 16));
        SEND_P3_DATA(StartXSub, (rDest->left << 16));
        SEND_P3_DATA(StartY,    ((rDest->bottom - 1) << 16));
        SEND_P3_DATA(dY,        (DWORD)((-1) << 16));
    }
    else
    {
        // left to right, top to bottom
        SEND_P3_DATA(StartXDom, (rDest->left << 16));
        SEND_P3_DATA(StartXSub, (rDest->right << 16));
        SEND_P3_DATA(StartY,    (rDest->top << 16));
        SEND_P3_DATA(dY,        (1 << 16));
    }
    SEND_P3_DATA(Count, rDest->bottom - rDest->top );

    // Do the blt
    SEND_P3_DATA(Render, 
              P3RX_RENDER_PRIMITIVETYPE(P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID) 
            | P3RX_RENDER_FBSOURCEREADENABLE(__PERMEDIA_ENABLE));

    // Disable all the units that were switched on.
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE );

    // Put back the values if we changed them.

    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();
    
} // _DD_P3BltSourceChroma

//-----------------------------------------------------------------------------
//
// _DD_P3BltStretchSrcChDstCh
//
//
// Does a blit through the texture unit to allow stretching.  Also
// handle mirroring if the stretched image requires it and doth dest and
// source chromakeying.  Can also YUV->RGB convert
//
// This is the generic rout - others will be optimisations of this
// (if necessary).
//
//
//-----------------------------------------------------------------------------
VOID 
_DD_P3BltStretchSrcChDstCh(
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR fpSrcVidMem,
    P3_SURF_FORMAT* pFormatSource,    
    DWORD dwSrcPixelSize,
    DWORD dwSrcWidth,
    DWORD dwSrcHeight,
    DWORD dwSrcPixelPitch,
    DWORD dwSrcPatchMode,    
    ULONG ulSrcOffsetFromMemBase,    
    DWORD dwSrcFlags,
    DDPIXELFORMAT*  pSrcDDPF,
    BOOL bIsSourceAGP,
    FLATPTR fpDestVidMem,   
    P3_SURF_FORMAT* pFormatDest,    
    DWORD dwDestPixelSize,
    DWORD dwDestWidth,
    DWORD dwDestHeight,
    DWORD dwDestPixelPitch,
    DWORD dwDestPatchMode,
    ULONG ulDestOffsetFromMemBase,
    DWORD dwBltFlags,
    DWORD dwBltDDFX,
    DDCOLORKEY BltSrcColorKey,
    DDCOLORKEY BltDestColorKey,
    RECTL *rSrc,
    RECTL *rDest)
{
    ULONG   renderData;
    RECTL   rMySrc, rMyDest;
    int     iXScale, iYScale;
    int     iSrcWidth, iSrcHeight;
    int     iDstWidth, iDstHeight;
    DWORD   texSStart, texTStart;
    DWORD   dwRenderDirection;
    BOOL    bXMirror, bYMirror;
    BOOL    bFiltering;
    BOOL    bSrcKey, bDstKey;
    BOOL    bDisableLUT;
    int     iTemp;
    BOOL    b8to8blit;
    BOOL    bYUVMode;
    BOOL    bBlocking;
    DWORD   TR0;
    int     iTextureType;
    int     iPixelSize;
    int     iTextureFilterModeColorOrder;
    SurfFilterDeviceFormat  sfdfTextureFilterModeFormat;

    P3_DMA_DEFS();

    // Make local copies that we can mangle.
    rMySrc = *rSrc;
    rMyDest = *rDest;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("_DD_P3BltStretchSrcChDstCh", 
                               &rMySrc, &rMyDest))
    {
        // Nothing to be blitted
        return;
    }    
    
    iSrcWidth  = rMySrc.right - rMySrc.left;
    iSrcHeight = rMySrc.bottom - rMySrc.top;
    iDstWidth  = rMyDest.right - rMyDest.left;
    iDstHeight = rMyDest.bottom - rMyDest.top;

    bDisableLUT = FALSE;

    if (pFormatSource->DeviceFormat == SURF_YUV422)
    {
        bYUVMode = TRUE;
        // Always use ABGR for YUV;
        iTextureFilterModeColorOrder = 0;
    }
    else
    {
        bYUVMode = FALSE;
        iTextureFilterModeColorOrder = COLOR_MODE;
    }

    sfdfTextureFilterModeFormat = pFormatSource->FilterFormat;

    if ( ( pFormatDest->DeviceFormat == SURF_CI8 ) && 
         ( pFormatSource->DeviceFormat == SURF_CI8 ) )
    {
        // An 8bit->8bit blit. This is treated specially, 
        // since no LUT translation is involved.
        // Fake this up in a wacky way to stop the LUT
        // getting it's hands on it.
        sfdfTextureFilterModeFormat = SURF_FILTER_L8;
        bDisableLUT = TRUE;
        b8to8blit = TRUE;
    }
    else
    {
        b8to8blit = FALSE;
    }

    // Let's see if anyone uses this flag - might be good to get it working
    // now that we know what it means (use bilinear filtering instead of point).
    ASSERTDD ( ( dwBltFlags & DDBLTFX_ARITHSTRETCHY ) == 0,
                 "** _DD_P3BltStretchSrcChDstCh: DDBLTFX_ARITHSTRETCHY used");

    // Is this a stretch blit?
    if (((iSrcWidth != iDstWidth) || 
        (iSrcHeight != iDstHeight)) &&
        ((pFormatSource->DeviceFormat == SURF_YUV422)) )
    {
        bFiltering = TRUE;
    }
    else
    {
        bFiltering = FALSE;
    }

    if ( ( dwBltFlags & DDBLT_KEYSRCOVERRIDE ) != 0 )
    {
        bSrcKey = TRUE;
    }
    else
    {
        bSrcKey = FALSE;
    }

    if ( ( dwBltFlags & DDBLT_KEYDESTOVERRIDE ) != 0 )
    {
        bDstKey = TRUE;
    }
    else
    {
        bDstKey = FALSE;
    }


    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(fpSrcVidMem, 
                                                 fpDestVidMem,
                                                 &rMySrc,
                                                 &rMyDest,
                                                 &bBlocking);

    // If we are doing special effects, and we are mirroring, 
    // we need to fix up the rectangles and change the sense of
    // the render operation - we need to be carefull with overlapping
    // rectangles
    if (dwRenderDirection)
    {
        if(dwBltFlags & DDBLT_DDFX)
        {
            if(dwBltDDFX & DDBLTFX_MIRRORUPDOWN)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.bottom;
                    rMySrc.bottom = dwSrcHeight - rMySrc.top;
                    rMySrc.top = dwSrcHeight - iTemp;
                }
                bYMirror = TRUE;
            }
            else
            { 
                bYMirror = FALSE;
            }
        
            if(dwBltDDFX & DDBLTFX_MIRRORLEFTRIGHT)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.right;
                    rMySrc.right = dwSrcWidth - rMySrc.left;
                    rMySrc.left = dwSrcWidth - iTemp;
                }
                bXMirror = TRUE;
            }
            else
            {
                bXMirror = FALSE;
            }
        }
        else
        {
            bXMirror = FALSE;
            bYMirror = FALSE;
        }
    }
    else
    {
        if(dwBltFlags & DDBLT_DDFX)
        {
            if(dwBltDDFX & DDBLTFX_MIRRORUPDOWN)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Fix up the rectangles
                    iTemp = rMySrc.bottom;
                    rMySrc.bottom = dwSrcHeight - rMySrc.top;
                    rMySrc.top = dwSrcHeight - iTemp;
                }
                bYMirror = FALSE;
            }
            else
            {
                bYMirror = TRUE;
            }
        
            if(dwBltDDFX & DDBLTFX_MIRRORLEFTRIGHT)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.right;
                    rMySrc.right = dwSrcWidth - rMySrc.left;
                    rMySrc.left = dwSrcWidth - iTemp;
                }
                bXMirror = FALSE;
            }
            else
            {
                bXMirror = TRUE;
            }
        }
        else
        {
            // Not mirroring, but need to render from the other side.
            bXMirror = TRUE;
            bYMirror = TRUE;
        }
    }

    // MAGIC_NUMBER_2D can be anything, but it needs to be at least as
    // big as the widest texture, but not too big or you'll lose fractional
    // precision. Valid range for a P3 is 0->11
    ASSERTDD ( iSrcWidth  <= ( 1 << MAGIC_NUMBER_2D ), 
               "_DD_P3BltStretchSrcChDstCh: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( iSrcHeight <= ( 1 << MAGIC_NUMBER_2D ), 
               "_DD_P3BltStretchSrcChDstCh: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( ( iSrcWidth > 0 ) && ( iSrcHeight > 0 ) && 
               ( iDstWidth > 0 ) && ( iDstHeight > 0 ),
               "_DD_P3BltStretchSrcChDstCh: width or height negative" );
    if ( bFiltering )
    {
        // This must be an unsigned divide, because we need the top bit.
        iXScale = ( ( ( (unsigned)iSrcWidth  ) << (32-MAGIC_NUMBER_2D) ) / 
                                                    (unsigned)( iDstWidth  ) );
        iYScale = ( ( ( (unsigned)iSrcHeight ) << (32-MAGIC_NUMBER_2D) ) / 
                                                    (unsigned)( iDstHeight ) );
    }
    else
    {
        // This must be an unsigned divide, because we need the top bit.
        iXScale = ( ( (unsigned)iSrcWidth  << (32-MAGIC_NUMBER_2D)) / 
                                                    (unsigned)( iDstWidth ) );
        iYScale = ( ( (unsigned)iSrcHeight << (32-MAGIC_NUMBER_2D)) / 
                                                    (unsigned)( iDstHeight) );
    }


    if (bXMirror)       
    {
        texSStart = ( rMySrc.right - 1 ) << (32-MAGIC_NUMBER_2D);
        iXScale = -iXScale;
    }
    else
    {
        texSStart = rMySrc.left << (32-MAGIC_NUMBER_2D);
    }

    if (bYMirror)       
    {
        texTStart = ( rMySrc.bottom - 1 ) << (32-MAGIC_NUMBER_2D);
        iYScale = -iYScale;
    }
    else
    {
        texTStart = rMySrc.top << (32-MAGIC_NUMBER_2D);
    }

    // Move pixel centres to 0.5, 0.5.
    if ( bFiltering )
    {
        texSStart -= 1 << (31-MAGIC_NUMBER_2D);
        texTStart -= 1 << (31-MAGIC_NUMBER_2D);
    }

    DISPDBG((DBGLVL, "Blt from (%d, %d) to (%d,%d) (%d, %d)", 
                     rMySrc.left, rMySrc.top,
                     rMyDest.left, rMyDest.top, 
                     rMyDest.right, rMyDest.bottom));

    P3_DMA_GET_BUFFER_ENTRIES(24);

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize ));

    // Vape the cache.
    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_ENABLE);

    // The write buffer is the destination for the pixels
    SEND_P3_DATA(FBWriteBufferAddr0, ulDestOffsetFromMemBase);
    SEND_P3_DATA(FBWriteBufferWidth0, dwDestPixelPitch);
    SEND_P3_DATA(FBWriteBufferOffset0, 0);

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize));

    SEND_P3_DATA(RectanglePosition, P3RX_RECTANGLEPOSITION_X( rMyDest.left )
                                    | P3RX_RECTANGLEPOSITION_Y( rMyDest.top ));

    renderData =  P3RX_RENDER2D_WIDTH(( rMyDest.right - rMyDest.left ) & 0xfff )
                | P3RX_RENDER2D_FBREADSOURCEENABLE( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_HEIGHT ( 0 )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_TEXTUREENABLE( __PERMEDIA_ENABLE );

    SEND_P3_DATA(Render2D, renderData);

    // This is the alpha blending unit.
    // AlphaBlendxxxMode are set up by the context code.
    ASSERTDD ( pFormatDest->DitherFormat >= 0, 
               "_DD_P3BltStretchSrcChDstCh: Destination format illegal" );

    // The colour format, order and conversion fields are used by the 
    // chroma keying, even though this register is disabled.
    SEND_P3_DATA(AlphaBlendColorMode,   
              P3RX_ALPHABLENDCOLORMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDCOLORMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_ALPHABLENDCOLORMODE_COLORORDER ( COLOR_MODE )
            | P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
    SEND_P3_DATA(AlphaBlendAlphaMode,   
              P3RX_ALPHABLENDALPHAMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_ALPHATYPE ( P3RX_ALPHABLENDMODE_ALPHATYPE_OGL )
            | P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(26);

    // If there is only one chromakey needed, use the proper chromakey
    // This is mainly because the alphamap version doesn't work yet.
    if ( bDstKey )
    {
        // Dest keying.
        // The conventional chroma test is set up to key off the dest - the framebuffer.
        SEND_P3_DATA(ChromaTestMode, 
                        P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                        P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_FBDATA) |
                        P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_PASS) |
                        P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_REJECT)
                        );

        SEND_P3_DATA(ChromaLower, BltDestColorKey.dwColorSpaceLowValue);
        SEND_P3_DATA(ChromaUpper, BltDestColorKey.dwColorSpaceHighValue);

        // The source buffer is the source for the destination color key
        SEND_P3_DATA(FBSourceReadBufferAddr, ulDestOffsetFromMemBase);
        SEND_P3_DATA(FBSourceReadBufferWidth, dwDestPixelPitch);
        SEND_P3_DATA(FBSourceReadBufferOffset, 0);
    
        // Enable source reads to get the colorkey color
        SEND_P3_DATA(FBSourceReadMode, 
                        P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                        P3RX_FBSOURCEREAD_LAYOUT(dwDestPatchMode)
                        );
    }
    else
    {
        // Don't need source reads - the source data comes from the texturemap
        SEND_P3_DATA(FBSourceReadMode, 
                        P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_DISABLE));

        if ( bSrcKey )
        {
            DWORD   dwLowerSrcBound;
            DWORD   dwUpperSrcBound;

            // Source keying, no dest keying.
            // The conventional chroma test is set up to key off the source.
            // Note we are keying off the input from the texture here, so we use the INPUTCOLOR as the chroma test
            // source
            SEND_P3_DATA(ChromaTestMode, 
                          P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                          P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_INPUTCOLOR) |
                          P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_REJECT) |
                          P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_PASS)
                          );

            if ( b8to8blit )
            {
                // No conversion, just use the index value in the R channel.
                dwLowerSrcBound = BltSrcColorKey.dwColorSpaceLowValue & 0x000000ff;
                dwUpperSrcBound = BltSrcColorKey.dwColorSpaceHighValue | 0xffffff00;
            }
            else
            {
                // Don't scale, do a shift instead.
                Get8888ScaledChroma(pThisDisplay,
                            dwSrcFlags,
                            pSrcDDPF,
                            BltSrcColorKey.dwColorSpaceLowValue,
                            BltSrcColorKey.dwColorSpaceHighValue,
                            &dwLowerSrcBound,
                            &dwUpperSrcBound,
                            NULL,                   // NULL palette
                            FALSE, 
                            TRUE);
            }

            DISPDBG((DBGLVL,"P3 Src Chroma: Upper = 0x%08x, Lower = 0x%08x", 
                            BltSrcColorKey.dwColorSpaceLowValue,
                            BltSrcColorKey.dwColorSpaceHighValue));

            DISPDBG((DBGLVL,"P3 Src Chroma(after): "
                            "Upper = 0x%08x, Lower = 0x%08x",
                            dwUpperSrcBound,
                            dwLowerSrcBound));

            SEND_P3_DATA(ChromaLower, dwLowerSrcBound);
            SEND_P3_DATA(ChromaUpper, dwUpperSrcBound);
        }
        else if ( !bSrcKey && !bDstKey )
        {
            // No chroma keying at all.
            SEND_P3_DATA(ChromaTestMode,
                            P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_DISABLE ) );
        }
    }

    if ( bDstKey && bSrcKey )
    {
        DWORD   dwLowerSrcBound;
        DWORD   dwUpperSrcBound;

        if ( b8to8blit )
        {
            DISPDBG((ERRLVL,"Er... don't know what to do in this situation."));
        }

        // Enable source reads to get the colorkey color during dest colorkeys
        SEND_P3_DATA(FBSourceReadMode, 
                        P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                        P3RX_FBSOURCEREAD_LAYOUT(dwDestPatchMode)
                     );

        // Don't scale, do a shift instead.
        Get8888ZeroExtendedChroma(pThisDisplay,
                        dwSrcFlags,
                        pSrcDDPF,
                        BltSrcColorKey.dwColorSpaceLowValue,
                        BltSrcColorKey.dwColorSpaceHighValue,
                        &dwLowerSrcBound,
                        &dwUpperSrcBound);

        // If both colourkeys are needed, the source keying is done by counting
        // chroma test fails in the texture filter unit.
        SEND_P3_DATA(TextureChromaLower0, dwLowerSrcBound);
        SEND_P3_DATA(TextureChromaUpper0, dwUpperSrcBound);

        SEND_P3_DATA(TextureChromaLower1, dwLowerSrcBound);
        SEND_P3_DATA(TextureChromaUpper1, dwUpperSrcBound);

        SEND_P3_DATA(TextureFilterMode, 
                  P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_FORMATBOTH ( sfdfTextureFilterModeFormat )
                | P3RX_TEXFILTERMODE_COLORORDERBOTH ( COLOR_MODE )
                | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPSENSEBOTH ( P3RX_ALPHAMAPSENSE_INRANGE )
                | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT0 ( bFiltering ? 3 : 0 )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT1 ( 4 )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT01 ( 8 )
                );
    }
    else
    {
        SEND_P3_DATA(TextureFilterMode, 
                  P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_FORMATBOTH ( sfdfTextureFilterModeFormat )
                | P3RX_TEXFILTERMODE_COLORORDERBOTH ( iTextureFilterModeColorOrder )
                | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_FORCEALPHATOONEBOTH ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_ENABLE )
                );
        // And now the alpha test (alpha test unit)
        SEND_P3_DATA ( AlphaTestMode, P3RX_ALPHATESTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(18);

    SEND_P3_DATA ( AntialiasMode, P3RX_ANTIALIASMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    // Texture coordinate unit.
    SEND_P3_DATA(TextureCoordMode, 
              P3RX_TEXCOORDMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXCOORDMODE_WRAPS ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_WRAPT ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_OPERATION ( P3RX_TEXCOORDMODE_OPERATION_2D )
            | P3RX_TEXCOORDMODE_INHIBITDDAINIT ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLELOD ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLEDY ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_WIDTH ( log2 ( dwDestWidth ) )
            | P3RX_TEXCOORDMODE_HEIGHT ( log2 ( dwDestHeight ) )
            | P3RX_TEXCOORDMODE_TEXTUREMAPTYPE ( P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_2D )
            | P3RX_TEXCOORDMODE_WRAPS1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            | P3RX_TEXCOORDMODE_WRAPT1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            );

    SEND_P3_DATA(SStart,        texSStart);
    SEND_P3_DATA(TStart,        texTStart);
    SEND_P3_DATA(dSdx,          iXScale);
    SEND_P3_DATA(dSdyDom,       0);
    SEND_P3_DATA(dTdx,          0);
    SEND_P3_DATA(dTdyDom,       iYScale);

    SEND_P3_DATA(TextureBaseAddr0, ulSrcOffsetFromMemBase);

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(32);

    if ( bYUVMode )
    {
        // Set up the YUV unit.
        SEND_P3_DATA ( YUVMode, P3RX_YUVMODE_ENABLE ( __PERMEDIA_ENABLE ) );
        iTextureType = P3RX_TEXREADMODE_TEXTURETYPE_VYUY422;
        iPixelSize = P3RX_TEXREADMODE_TEXELSIZE_16;

        // The idea here is to do ((colorcomp - 16) * 1.14), but in YUV space
        // because the YUV unit comes after the texture composite unit.  

        SEND_P3_DATA(TextureCompositeMode, 
                        P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_ENABLE ));
            
        SEND_P3_DATA(TextureCompositeColorMode0, 
                  P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_T0C)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FC)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_SUBTRACT_AB)        
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_ONE));

        SEND_P3_DATA(TextureCompositeAlphaMode0, 
                  P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_T0A)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FA)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_SUBTRACT_AB)
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_ONE));

        // This subtracts 16 from Y
        SEND_P3_DATA(TextureCompositeFactor0, ((0 << 24)  | 
                                               (0x0 << 16)| 
                                               (0x0 << 8) | 
                                               (0x10)       ));

        // This multiplies the channels by 0.57.
        SEND_P3_DATA(TextureCompositeFactor1, ((0x80 << 24) | 
                                               (0x80 << 16) | 
                                               (0x80 << 8)  | 
                                               (0x91)       ));

        SEND_P3_DATA(TextureCompositeColorMode1, 
                  P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_OC)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FC)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_MODULATE_AB)        
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_TWO));

        SEND_P3_DATA(TextureCompositeAlphaMode1, 
                  P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_OC)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FA)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_MODULATE_AB)
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_TWO));    
    }
    else
    {
        iTextureType = P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
        iPixelSize = dwSrcPixelSize;

        // Disable the composite units.
        SEND_P3_DATA(TextureCompositeMode, 
                        P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    // Pass through the texel.
    SEND_P3_DATA(TextureApplicationMode, 
          P3RX_TEXAPPMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXAPPMODE_BOTHA ( P3RX_TEXAPP_A_CC )
        | P3RX_TEXAPPMODE_BOTHB ( P3RX_TEXAPP_B_TC )
        | P3RX_TEXAPPMODE_BOTHI ( P3RX_TEXAPP_I_CA )
        | P3RX_TEXAPPMODE_BOTHINVI ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_BOTHOP ( P3RX_TEXAPP_OPERATION_PASS_B )
        | P3RX_TEXAPPMODE_KDENABLE ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_KSENABLE ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_MOTIONCOMPENABLE ( __PERMEDIA_DISABLE )
        );


    TR0 = P3RX_TEXREADMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_WIDTH ( 0 )
        | P3RX_TEXREADMODE_HEIGHT ( 0 )
        | P3RX_TEXREADMODE_TEXELSIZE ( iPixelSize )
        | P3RX_TEXREADMODE_TEXTURE3D ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_MAPBASELEVEL ( 0 )
        | P3RX_TEXREADMODE_MAPMAXLEVEL ( 0 )
        | P3RX_TEXREADMODE_LOGICALTEXTURE ( 0 )
        | P3RX_TEXREADMODE_ORIGIN ( P3RX_TEXREADMODE_ORIGIN_TOPLEFT )
        | P3RX_TEXREADMODE_TEXTURETYPE ( iTextureType )
        | P3RX_TEXREADMODE_BYTESWAP ( P3RX_TEXREADMODE_BYTESWAP_NONE )
        | P3RX_TEXREADMODE_MIRROR ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_INVERT ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_OPAQUESPAN ( __PERMEDIA_DISABLE )
        ;
    SEND_P3_DATA(TextureReadMode0, TR0);
    SEND_P3_DATA(TextureReadMode1, TR0);

    SEND_P3_DATA(TextureMapWidth0, 
                    P3RX_TEXMAPWIDTH_WIDTH(dwSrcPixelPitch) |
                    P3RX_TEXMAPWIDTH_LAYOUT(dwSrcPatchMode) |
                    P3RX_TEXMAPWIDTH_HOSTTEXTURE(bIsSourceAGP));

    SEND_P3_DATA(TextureCacheReplacementMode,
              P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST0 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST1 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_SHOWCACHEINFO ( __PERMEDIA_DISABLE )
            );

    SEND_P3_DATA(TextureMapSize, 0 );

    if ( bDisableLUT )
    {
        SEND_P3_DATA(LUTMode, P3RX_LUTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    if ( bFiltering )
    {
        // Texture index unit
        SEND_P3_DATA(TextureIndexMode0, 
                  P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
                | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
                | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
                | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
                );
    }
    else
    {
        // Texture index unit
        SEND_P3_DATA(TextureIndexMode0, 
                  P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
                | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_NEAREST )
                | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_NEAREST )
                | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
                );
    }

    ASSERTDD ( pFormatDest->DitherFormat >= 0, 
               "_DD_P3BltStretchSrcChDstCh: Destination format illegal" );

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(10);
               
    if ( bFiltering )
    {
        // Filtering, so dither.
        SEND_P3_DATA(DitherMode, 
                  P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
                | P3RX_DITHERMODE_XOFFSET ( 0 )
                | P3RX_DITHERMODE_YOFFSET ( 0 )
                | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
                | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
                | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
                );
    }
    else
    {
        // No filter, no dither (though it doesn't actually matter).
        SEND_P3_DATA(DitherMode, 
                  P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_DISABLE )
                | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
                | P3RX_DITHERMODE_XOFFSET ( 0 )
                | P3RX_DITHERMODE_YOFFSET ( 0 )
                | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
                | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
                | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
                );
    }

    SEND_P3_DATA(LogicalOpMode, 
                    P3RX_LOGICALOPMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize));

    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(dwDestPatchMode)
                 );

    WAIT_FIFO(22);
    P3_ENSURE_DX_SPACE(22);
    SEND_P3_DATA(Count, rMyDest.bottom - rMyDest.top );
    SEND_P3_DATA(Render,
              P3RX_RENDER_PRIMITIVETYPE ( P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID )
            | P3RX_RENDER_TEXTUREENABLE ( __PERMEDIA_ENABLE )
            | P3RX_RENDER_FOGENABLE ( __PERMEDIA_DISABLE )
            | P3RX_RENDER_FBSOURCEREADENABLE( (bDstKey ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE))
            );

    // Disable all the things I switched on.
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureFilterMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AntialiasMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCoordMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureReadMode0, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureIndexMode0, __PERMEDIA_DISABLE );

    P3_ENSURE_DX_SPACE(20);
    WAIT_FIFO(20);
    
    SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCompositeColorMode0, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeAlphaMode0, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeColorMode1, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeAlphaMode1, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureApplicationMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(FBSourceReadMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE );

    P3_DMA_COMMIT_BUFFER();
} // _DD_P3BltStretchSrcChDstCh

//-----------------------------------------------------------------------------
//
// _DD_P3BltStretchSrcChDstCh_DD
//
// Stretch blit with source and destination chroma keying
// This version takes as parameters DDraw objects
//
//-----------------------------------------------------------------------------
VOID 
_DD_P3BltStretchSrcChDstCh_DD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource,
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt,
    RECTL *rSrc,
    RECTL *rDest)
{
    _DD_P3BltStretchSrcChDstCh(pThisDisplay,
                               // pSource data elements
                               pSource->lpGbl->fpVidMem,
                               pFormatSource,                               
                               DDSurf_GetChipPixelSize(pSource),
                               (int)pSource->lpGbl->wWidth,
                               (int)pSource->lpGbl->wHeight,
                               DDSurf_GetPixelPitch(pSource),
                               P3RX_LAYOUT_LINEAR,
                               DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSource),                                                              
                               pSource->dwFlags,
                               &pSource->lpGbl->ddpfSurface,    
                               DDSurf_IsAGP(pSource),
                               // pDest data elements
                               pDest->lpGbl->fpVidMem,
                               pFormatDest,                               
                               DDSurf_GetChipPixelSize(pDest),
                               (int)pDest->lpGbl->wWidth,
                               (int)pDest->lpGbl->wHeight,
                               DDSurf_GetPixelPitch(pDest),
                               P3RX_LAYOUT_LINEAR,
                               DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest),
                               // Others
                               lpBlt->dwFlags,
                               lpBlt->bltFX.dwDDFX,
                               lpBlt->bltFX.ddckSrcColorkey,
                               lpBlt->bltFX.ddckDestColorkey,
                               rSrc,
                               rDest);    
} // _DD_P3BltStretchSrcChDstCh_DD

//-----------------------------------------------------------------------------
//
// __P3BltDestOveride
//
//-----------------------------------------------------------------------------
VOID 
__P3BltDestOveride(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    RECTL *rSrc,
    RECTL *rDest,
    DWORD logicop, 
    DWORD dwDestPointer)
{
    DWORD   renderData;
    LONG    rSrctop, rSrcleft, rDesttop, rDestleft;
    DWORD   dwSourceOffset;
    BOOL    bBlocking;
    DWORD   dwRenderDirection;
    DWORD   dwDestPatchMode, dwSourcePatchMode;

    P3_DMA_DEFS();

    // Beacuse of a bug in RL we sometimes have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("__P3BltDestOveride", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }    
    
    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(pSource->lpGbl->fpVidMem, 
                                                 pDest->lpGbl->fpVidMem,
                                                 rSrc,
                                                 rDest,
                                                 &bBlocking);

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(30);
    WAIT_FIFO(30); 

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    SEND_P3_DATA(FBWriteBufferAddr0, dwDestPointer);
    SEND_P3_DATA(FBWriteBufferWidth0, DDSurf_GetPixelPitch(pDest));
    SEND_P3_DATA(FBWriteBufferOffset0, 0);
    
    SEND_P3_DATA(FBSourceReadBufferAddr, 
                DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSource));
    SEND_P3_DATA(FBSourceReadBufferWidth, DDSurf_GetPixelPitch(pSource));
    
    dwSourceOffset = (( rSrc->top - rDest->top ) << 16 ) | 
                     (( rSrc->left - rDest->left ) & 0xffff );
                     
    SEND_P3_DATA(FBSourceReadBufferOffset, dwSourceOffset);

    dwDestPatchMode = P3RX_LAYOUT_LINEAR;
    dwSourcePatchMode = P3RX_LAYOUT_LINEAR;
    
    SEND_P3_DATA(FBDestReadMode, 
                    P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE));

    SEND_P3_DATA(FBSourceReadMode, 
                    P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBSOURCEREAD_LAYOUT(dwSourcePatchMode) |
                    P3RX_FBSOURCEREAD_BLOCKING( bBlocking ));

    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(dwDestPatchMode));


    P3_ENSURE_DX_SPACE(16);
    WAIT_FIFO(16); 
    
    SEND_P3_DATA(RectanglePosition, 
                    P3RX_RECTANGLEPOSITION_Y(rDest->top) |
                    P3RX_RECTANGLEPOSITION_X(rDest->left));

    renderData =  
        P3RX_RENDER2D_WIDTH(( rDest->right - rDest->left ) & 0xfff )  |
        P3RX_RENDER2D_HEIGHT(( rDest->bottom - rDest->top ) & 0xfff ) |
        P3RX_RENDER2D_FBREADSOURCEENABLE(__PERMEDIA_ENABLE)           |
        P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_VARIABLE )    |
        P3RX_RENDER2D_INCREASINGX( dwRenderDirection )                |
        P3RX_RENDER2D_INCREASINGY( dwRenderDirection );
                
    SEND_P3_DATA(Render2D, renderData);

    // Put back the values if we changed them.
    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();
    
} // __P3BltDestOveride

//-----------------------------------------------------------------------------
//
// __P3BltStretchSrcChDstChSourceOveride
//
//-----------------------------------------------------------------------------
VOID
__P3BltStretchSrcChDstChSourceOveride(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource,
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt,
    RECTL *rSrc,
    RECTL *rDest,
    DWORD dwNewSource
    )
{
    ULONG   renderData;
    RECTL   rMySrc, rMyDest;
    int     iXScale, iYScale;
    int     iSrcWidth, iSrcHeight;
    int     iDstWidth, iDstHeight;
    DWORD   texSStart, texTStart;
    DWORD   dwRenderDirection;
    BOOL    bXMirror, bYMirror;
    BOOL    bFiltering;
    BOOL    bSrcKey, bDstKey;
    BOOL    bDisableLUT;
    BOOL    bBlocking;
    int     iTemp;
    BOOL    b8to8blit;
    BOOL    bYUVMode;
    DWORD   TR0;
    int     iTextureType;
    int     iPixelSize;
    int     iTextureFilterModeColorOrder;
        
    SurfFilterDeviceFormat  sfdfTextureFilterModeFormat;
    P3_DMA_DEFS();

    bDisableLUT = FALSE;

    // Make local copies that we can mangle.
    rMySrc = *rSrc;
    rMyDest = *rDest;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("__P3BltStretchSrcChDstChSourceOveride", 
                               &rMySrc, &rMyDest))
    {
        // Nothing to be blitted
        return;
    }    

    iSrcWidth  = rMySrc.right - rMySrc.left;
    iSrcHeight = rMySrc.bottom - rMySrc.top;
    iDstWidth  = rMyDest.right - rMyDest.left;
    iDstHeight = rMyDest.bottom - rMyDest.top;

    if (pFormatSource->DeviceFormat == SURF_YUV422)
    {
        bYUVMode = TRUE;
        // Always use ABGR for YUV;
        iTextureFilterModeColorOrder = 0;
    }
    else
    {
        bYUVMode = FALSE;
        iTextureFilterModeColorOrder = COLOR_MODE;
    }

    sfdfTextureFilterModeFormat = pFormatSource->FilterFormat;

    if ( ( pFormatDest->DeviceFormat == SURF_CI8 ) && ( pFormatSource->DeviceFormat == SURF_CI8 ) )
    {
        // An 8bit->8bit blit. This is treated specially, since no LUT translation is involved.
        // Fake this up in a wacky way to stop the LUT
        // getting it's hands on it.
        sfdfTextureFilterModeFormat = SURF_FILTER_L8;
        bDisableLUT = TRUE;
        b8to8blit = TRUE;
    }
    else
    {
        b8to8blit = FALSE;
    }

    // Let's see if anyone uses this flag - might be good to get it working
    // now that we know what it means (use bilinear filtering instead of point).
    ASSERTDD ( ( lpBlt->dwFlags & DDBLTFX_ARITHSTRETCHY ) == 0, "** _DD_P3BltStretchSrcChDstCh: DDBLTFX_ARITHSTRETCHY used - please tell TomF" );

    // Is this a stretch blit?
    if (((iSrcWidth != iDstWidth) || 
        (iSrcHeight != iDstHeight)) &&
        ((pFormatSource->DeviceFormat == SURF_YUV422)))
    {
        bFiltering = TRUE;
    }
    else
    {
        bFiltering = FALSE;
    }

    if ( ( lpBlt->dwFlags & DDBLT_KEYSRCOVERRIDE ) != 0 )
    {
        bSrcKey = TRUE;
    }
    else
    {
        bSrcKey = FALSE;
    }

    if ( ( lpBlt->dwFlags & DDBLT_KEYDESTOVERRIDE ) != 0 )
    {
        bDstKey = TRUE;
    }
    else
    {
        bDstKey = FALSE;
    }


    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(pSource->lpGbl->fpVidMem, 
                                                 pDest->lpGbl->fpVidMem,
                                                 &rMySrc,
                                                 &rMyDest,
                                                 &bBlocking);

    // If we are doing special effects, and we are mirroring, 
    // we need to fix up the rectangles and change the sense of
    // the render operation - we need to be carefull with overlapping
    // rectangles
    if (dwRenderDirection)
    {
        if(lpBlt->dwFlags & DDBLT_DDFX)
        {
            if(lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.bottom;
                    rMySrc.bottom = pSource->lpGbl->wHeight - rMySrc.top;
                    rMySrc.top = pSource->lpGbl->wHeight - iTemp;
                }
                bYMirror = TRUE;
            }
            else
            { 
                bYMirror = FALSE;
            }
        
            if(lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.right;
                    rMySrc.right = pSource->lpGbl->wWidth - rMySrc.left;
                    rMySrc.left = pSource->lpGbl->wWidth - iTemp;
                }
                bXMirror = TRUE;
            }
            else
            {
                bXMirror = FALSE;
            }
        }
        else
        {
            bXMirror = FALSE;
            bYMirror = FALSE;
        }
    }
    else
    {
        if(lpBlt->dwFlags & DDBLT_DDFX)
        {
            if(lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Fix up the rectangles
                    iTemp = rMySrc.bottom;
                    rMySrc.bottom = pSource->lpGbl->wHeight - rMySrc.top;
                    rMySrc.top = pSource->lpGbl->wHeight - iTemp;
                }
                bYMirror = FALSE;
            }
            else
            {
                bYMirror = TRUE;
            }
        
            if(lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
            {
                if (pThisDisplay->dwDXVersion < DX6_RUNTIME)
                {
                    // Need to fix up the rectangles
                    iTemp = rMySrc.right;
                    rMySrc.right = pSource->lpGbl->wWidth - rMySrc.left;
                    rMySrc.left = pSource->lpGbl->wWidth - iTemp;
                }
                bXMirror = FALSE;
            }
            else
            {
                bXMirror = TRUE;
            }
        }
        else
        {
            // Not mirroring, but need to render from the other side.
            bXMirror = TRUE;
            bYMirror = TRUE;
        }
    }

    // MAGIC_NUMBER_2D can be anything, but it needs to be at least as
    // big as the widest texture, but not too big or you'll lose fractional
    // precision. Valid range for a P3 is 0->11
    ASSERTDD ( iSrcWidth  <= ( 1 << MAGIC_NUMBER_2D ), "** _DD_P3BltStretchSrcChDstCh: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( iSrcHeight <= ( 1 << MAGIC_NUMBER_2D ), "** _DD_P3BltStretchSrcChDstCh: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( ( iSrcWidth > 0 ) && ( iSrcHeight > 0 ) && ( iDstWidth > 0 ) && ( iDstHeight > 0 ), "** _DD_P3BltStretchSrcChDstCh: width or height negative" );
    if ( bFiltering )
    {
        // This must be an unsigned divide, because we need the top bit.
        iXScale = ( ( ( (unsigned)iSrcWidth  ) << (32-MAGIC_NUMBER_2D) ) / (unsigned)( iDstWidth  ) );
        iYScale = ( ( ( (unsigned)iSrcHeight ) << (32-MAGIC_NUMBER_2D) ) / (unsigned)( iDstHeight ) );
    }
    else
    {
        // This must be an unsigned divide, because we need the top bit.
        iXScale = ( ( (unsigned)iSrcWidth  << (32-MAGIC_NUMBER_2D)) / (unsigned)( iDstWidth ) );
        iYScale = ( ( (unsigned)iSrcHeight << (32-MAGIC_NUMBER_2D)) / (unsigned)( iDstHeight) );
    }


    if (bXMirror)       
    {
        texSStart = ( rMySrc.right - 1 ) << (32-MAGIC_NUMBER_2D);
        iXScale = -iXScale;
    }
    else
    {
        texSStart = rMySrc.left << (32-MAGIC_NUMBER_2D);
    }

    if (bYMirror)       
    {
        texTStart = ( rMySrc.bottom - 1 ) << (32-MAGIC_NUMBER_2D);
        iYScale = -iYScale;
    }
    else
    {
        texTStart = rMySrc.top << (32-MAGIC_NUMBER_2D);
    }

    // Move pixel centres to 0.5, 0.5.
    if ( bFiltering )
    {
        texSStart -= 1 << (31-MAGIC_NUMBER_2D);
        texTStart -= 1 << (31-MAGIC_NUMBER_2D);
    }

    DISPDBG((DBGLVL, "Blt from (%d, %d) to (%d,%d) (%d, %d)", 
                     rMySrc.left, rMySrc.top,
                     rMyDest.left, rMyDest.top, 
                     rMyDest.right, rMyDest.bottom));

    P3_DMA_GET_BUFFER_ENTRIES(24);

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    // Vape the cache.
    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_ENABLE);

    // The write buffer is the destination for the pixels
    SEND_P3_DATA(FBWriteBufferAddr0, DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
    SEND_P3_DATA(FBWriteBufferWidth0, DDSurf_GetPixelPitch(pDest));
    SEND_P3_DATA(FBWriteBufferOffset0, 0);

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    SEND_P3_DATA(RectanglePosition, P3RX_RECTANGLEPOSITION_X( rMyDest.left )
                                    | P3RX_RECTANGLEPOSITION_Y( rMyDest.top ));

    renderData =  P3RX_RENDER2D_WIDTH(( rMyDest.right - rMyDest.left ) & 0xfff )
                | P3RX_RENDER2D_FBREADSOURCEENABLE( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_HEIGHT ( 0 )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_TEXTUREENABLE( __PERMEDIA_ENABLE );

    SEND_P3_DATA(Render2D, renderData);

    // This is the alpha blending unit.
    // AlphaBlendxxxMode are set up by the context code.
    ASSERTDD ( pFormatDest->DitherFormat >= 0, "** _DD_P3BltStretchSrcChDstCh: Destination format illegal" );

    // The colour format, order and conversion fields are used by the chroma keying,
    // even though this register is disabled.
    SEND_P3_DATA(AlphaBlendColorMode,   P3RX_ALPHABLENDCOLORMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDCOLORMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_ALPHABLENDCOLORMODE_COLORORDER ( COLOR_MODE )
            | P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
    SEND_P3_DATA(AlphaBlendAlphaMode,   P3RX_ALPHABLENDALPHAMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_ALPHATYPE ( P3RX_ALPHABLENDMODE_ALPHATYPE_OGL )
            | P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
            
    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(30);

    // If there is only one chromakey needed, use the proper chromakey
    // This is mainly because the alphamap version doesn't work yet.
    if ( bDstKey )
    {
        // Dest keying.
        // The conventional chroma test is set up to key off the dest - the framebuffer.
        SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_FBDATA) |
                                        P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_PASS) |
                                        P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_REJECT)
                                        );

        SEND_P3_DATA(ChromaLower, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceLowValue);
        SEND_P3_DATA(ChromaUpper, lpBlt->bltFX.ddckDestColorkey.dwColorSpaceHighValue);

        // The source buffer is the source for the destination color key
        SEND_P3_DATA(FBSourceReadBufferAddr, DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest));
        SEND_P3_DATA(FBSourceReadBufferWidth, DDSurf_GetPixelPitch(pDest));
        SEND_P3_DATA(FBSourceReadBufferOffset, 0);
    
        // Enable source reads to get the colorkey color
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_FBSOURCEREAD_LAYOUT(P3RX_LAYOUT_LINEAR));
    }
    else
    {
        // Don't need source reads - the source data comes from the texturemap
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_DISABLE));

        if ( bSrcKey )
        {
            DWORD   dwLowerSrcBound = 0;
            DWORD   dwUpperSrcBound = 0;

            // Source keying, no dest keying.
            // The conventional chroma test is set up to key off the source.
            // Note we are keying off the input from the texture here, so we use the INPUTCOLOR as the chroma test
            // source
            SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_ENABLE) |
                                            P3RX_CHROMATESTMODE_SOURCE(P3RX_CHROMATESTMODE_SOURCE_INPUTCOLOR) |
                                            P3RX_CHROMATESTMODE_PASSACTION(P3RX_CHROMATESTMODE_ACTION_REJECT) |
                                            P3RX_CHROMATESTMODE_FAILACTION(P3RX_CHROMATESTMODE_ACTION_PASS)
                                            );

            if ( b8to8blit )
            {
                // No conversion, just use the index value in the R channel.
                dwLowerSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue & 0x000000ff;
                dwUpperSrcBound = lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue | 0xffffff00;
            }
            else
            {
                // Don't scale, do a shift instead.
                Get8888ScaledChroma(pThisDisplay,
                            pSource->dwFlags,
                            &pSource->lpGbl->ddpfSurface,
                            lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue,
                            lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue,
                            &dwLowerSrcBound,
                            &dwUpperSrcBound,
                            NULL,                   // NULL palette
                            FALSE, 
                            TRUE);
            }

            DISPDBG((DBGLVL,"P3 Src Chroma: Upper = 0x%08x, Lower = 0x%08x", 
                            lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue,
                            lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue));

            DISPDBG((DBGLVL,"P3 Src Chroma(after): "
                            "Upper = 0x%08x, Lower = 0x%08x",
                            dwUpperSrcBound,
                            dwLowerSrcBound));

            SEND_P3_DATA(ChromaLower, dwLowerSrcBound);
            SEND_P3_DATA(ChromaUpper, dwUpperSrcBound);
        }
        else if ( !bSrcKey && !bDstKey )
        {
            // No chroma keying at all.
            SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_DISABLE ) );
        }
    }

    if ( bDstKey && bSrcKey )
    {
        DWORD   dwLowerSrcBound;
        DWORD   dwUpperSrcBound;

        if ( b8to8blit )
        {
            DISPDBG((ERRLVL,"Er... don't know what to do in this situation."));
        }

        // Enable source reads to get the colorkey color during dest colorkeys
        SEND_P3_DATA(FBSourceReadMode, P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                                        P3RX_FBSOURCEREAD_LAYOUT(P3RX_LAYOUT_LINEAR));

        // Don't scale, do a shift instead.
        Get8888ZeroExtendedChroma(pThisDisplay,
                        pSource->dwFlags,
                        &pSource->lpGbl->ddpfSurface,
                        lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue,
                        lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceHighValue,
                        &dwLowerSrcBound,
                        &dwUpperSrcBound);

        // If both colourkeys are needed, the source keying is done by counting
        // chroma test fails in the texture filter unit.
        SEND_P3_DATA(TextureChromaLower0, dwLowerSrcBound);
        SEND_P3_DATA(TextureChromaUpper0, dwUpperSrcBound);

        SEND_P3_DATA(TextureChromaLower1, dwLowerSrcBound);
        SEND_P3_DATA(TextureChromaUpper1, dwUpperSrcBound);

        SEND_P3_DATA(TextureFilterMode, P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_FORMATBOTH ( sfdfTextureFilterModeFormat )
                | P3RX_TEXFILTERMODE_COLORORDERBOTH ( COLOR_MODE )
                | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPSENSEBOTH ( P3RX_ALPHAMAPSENSE_INRANGE )
                | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT0 ( bFiltering ? 3 : 0 )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT1 ( 4 )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT01 ( 8 )
                );
    }
    else
    {
        SEND_P3_DATA(TextureFilterMode, P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_FORMATBOTH ( sfdfTextureFilterModeFormat )
                | P3RX_TEXFILTERMODE_COLORORDERBOTH ( iTextureFilterModeColorOrder )
                | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
                | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_FORCEALPHATOONEBOTH ( __PERMEDIA_DISABLE )
                | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_ENABLE )
                );
        // And now the alpha test (alpha test unit)
        SEND_P3_DATA ( AlphaTestMode, P3RX_ALPHATESTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    SEND_P3_DATA ( AntialiasMode, P3RX_ANTIALIASMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    // Texture coordinate unit.
    SEND_P3_DATA(TextureCoordMode, P3RX_TEXCOORDMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXCOORDMODE_WRAPS ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_WRAPT ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_OPERATION ( P3RX_TEXCOORDMODE_OPERATION_2D )
            | P3RX_TEXCOORDMODE_INHIBITDDAINIT ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLELOD ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLEDY ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_WIDTH ( log2 ( (int)pDest->lpGbl->wWidth ) )
            | P3RX_TEXCOORDMODE_HEIGHT ( log2 ( (int)pDest->lpGbl->wHeight ) )
            | P3RX_TEXCOORDMODE_TEXTUREMAPTYPE ( P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_2D )
            | P3RX_TEXCOORDMODE_WRAPS1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            | P3RX_TEXCOORDMODE_WRAPT1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            );

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(30);

    SEND_P3_DATA(SStart,        texSStart);
    SEND_P3_DATA(TStart,        texTStart);
    SEND_P3_DATA(dSdx,          iXScale);
    SEND_P3_DATA(dSdyDom,       0);
    SEND_P3_DATA(dTdx,          0);
    SEND_P3_DATA(dTdyDom,       iYScale);

    SEND_P3_DATA(TextureBaseAddr0, dwNewSource);
    if ( bYUVMode )
    {
        // Set up the YUV unit.
        SEND_P3_DATA ( YUVMode, P3RX_YUVMODE_ENABLE ( __PERMEDIA_ENABLE ) );
        iTextureType = P3RX_TEXREADMODE_TEXTURETYPE_VYUY422;
        iPixelSize = P3RX_TEXREADMODE_TEXELSIZE_16;

        // The idea here is to do ((colorcomp - 16) * 1.14), but in YUV space because the
        // YUV unit comes after the texture composite unit.  The reason for this change is
        // to make our YUV conversion more like the ATI conversion.  It isn't more correct this way, 
        // just different, but the WHQL tests were probably written on the ATI card and our colors
        // aren't close enough to match what they do so we fail the test
        SEND_P3_DATA(TextureCompositeMode, P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_ENABLE ));
            
        SEND_P3_DATA(TextureCompositeColorMode0, P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_T0C)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FC)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_SUBTRACT_AB)        
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_ONE));

        SEND_P3_DATA(TextureCompositeAlphaMode0, P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_T0A)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FA)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_SUBTRACT_AB)
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_ONE));

        // This subtracts 16 from Y
        SEND_P3_DATA(TextureCompositeFactor0, ((0 << 24) | (0x0 << 16) | (0x0 << 8) | 0x10));

        // This multiplies the channels by 0.57.
        SEND_P3_DATA(TextureCompositeFactor1, ((0x80 << 24) | (0x80 << 16) | (0x80 << 8) | 0x91));

        SEND_P3_DATA(TextureCompositeColorMode1, P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_OC)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FC)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_MODULATE_AB)        
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_TWO));

        SEND_P3_DATA(TextureCompositeAlphaMode1, P3RX_TEXCOMPCAMODE01_ENABLE(__PERMEDIA_ENABLE)
                | P3RX_TEXCOMPCAMODE01_ARG1(P3RX_TEXCOMP_OC)
                | P3RX_TEXCOMPCAMODE01_INVARG1(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_ARG2(P3RX_TEXCOMP_FA)            
                | P3RX_TEXCOMPCAMODE01_INVARG2(__PERMEDIA_DISABLE)     
                | P3RX_TEXCOMPCAMODE01_A(P3RX_TEXCOMP_ARG1)
                | P3RX_TEXCOMPCAMODE01_B(P3RX_TEXCOMP_ARG2)             
                | P3RX_TEXCOMPCAMODE01_OPERATION(P3RX_TEXCOMP_OPERATION_MODULATE_AB)
                | P3RX_TEXCOMPCAMODE01_SCALE(P3RX_TEXCOMP_OPERATION_SCALE_TWO));

    
    }
    else
    {
        iTextureType = P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
        iPixelSize = DDSurf_GetChipPixelSize(pSource);

        // Disable the composite units.
        SEND_P3_DATA(TextureCompositeMode, P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(24);

    // Pass through the texel.
    SEND_P3_DATA(TextureApplicationMode, P3RX_TEXAPPMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXAPPMODE_BOTHA ( P3RX_TEXAPP_A_CC )
        | P3RX_TEXAPPMODE_BOTHB ( P3RX_TEXAPP_B_TC )
        | P3RX_TEXAPPMODE_BOTHI ( P3RX_TEXAPP_I_CA )
        | P3RX_TEXAPPMODE_BOTHINVI ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_BOTHOP ( P3RX_TEXAPP_OPERATION_PASS_B )
        | P3RX_TEXAPPMODE_KDENABLE ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_KSENABLE ( __PERMEDIA_DISABLE )
        | P3RX_TEXAPPMODE_MOTIONCOMPENABLE ( __PERMEDIA_DISABLE )
        );


    TR0 = P3RX_TEXREADMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_WIDTH ( 0 )
        | P3RX_TEXREADMODE_HEIGHT ( 0 )
        | P3RX_TEXREADMODE_TEXELSIZE ( iPixelSize )
        | P3RX_TEXREADMODE_TEXTURE3D ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_MAPBASELEVEL ( 0 )
        | P3RX_TEXREADMODE_MAPMAXLEVEL ( 0 )
        | P3RX_TEXREADMODE_LOGICALTEXTURE ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_ORIGIN ( P3RX_TEXREADMODE_ORIGIN_TOPLEFT )
        | P3RX_TEXREADMODE_TEXTURETYPE ( iTextureType )
        | P3RX_TEXREADMODE_BYTESWAP ( P3RX_TEXREADMODE_BYTESWAP_NONE )
        | P3RX_TEXREADMODE_MIRROR ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_INVERT ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_OPAQUESPAN ( __PERMEDIA_DISABLE )
        ;
    SEND_P3_DATA(TextureReadMode0, TR0);
    SEND_P3_DATA(TextureReadMode1, TR0);

    SEND_P3_DATA(TextureMapWidth0, P3RX_TEXMAPWIDTH_WIDTH(DDSurf_GetPixelPitch(pSource)) |
                                    P3RX_TEXMAPWIDTH_LAYOUT(P3RX_LAYOUT_LINEAR) |
                                    P3RX_TEXMAPWIDTH_HOSTTEXTURE(DDSurf_IsAGP(pSource)));

    SEND_P3_DATA(TextureCacheReplacementMode,
            P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST0 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST1 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_SHOWCACHEINFO ( __PERMEDIA_DISABLE )
            );

    SEND_P3_DATA(TextureMapSize, 0 );

    if ( bDisableLUT )
    {
        SEND_P3_DATA(LUTMode, P3RX_LUTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    }

    if ( bFiltering )
    {
        // Texture index unit
        SEND_P3_DATA(TextureIndexMode0, 
                  P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
                | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
                | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
                | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
                );
    }
    else
    {
        // Texture index unit
        SEND_P3_DATA(TextureIndexMode0, 
                  P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
                | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
                | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
                | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_NEAREST )
                | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_NEAREST )
                | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
                | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
                | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
                );
    }

    ASSERTDD ( pFormatDest->DitherFormat >= 0, "** _DD_P3BltStretchSrcChDstCh: Destination format illegal" );
    if ( bFiltering )
    {
        // Filtering, so dither.
        SEND_P3_DATA(DitherMode, 
                  P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
                | P3RX_DITHERMODE_XOFFSET ( 0 )
                | P3RX_DITHERMODE_YOFFSET ( 0 )
                | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
                | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
                | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
                );
    }
    else
    {
        // No filter, no dither (though it doesn't actually matter).
        SEND_P3_DATA(DitherMode, 
                  P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
                | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_DISABLE )
                | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
                | P3RX_DITHERMODE_XOFFSET ( 0 )
                | P3RX_DITHERMODE_YOFFSET ( 0 )
                | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
                | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
                | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
                );
    }

    SEND_P3_DATA(LogicalOpMode, 
                    P3RX_LOGICALOPMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    SEND_P3_DATA(PixelSize, (2 - DDSurf_GetChipPixelSize(pDest)));

    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(P3RX_LAYOUT_LINEAR));

    WAIT_FIFO(32);
    P3_ENSURE_DX_SPACE(32);
    
    SEND_P3_DATA(Count, rMyDest.bottom - rMyDest.top );
    SEND_P3_DATA(Render,
              P3RX_RENDER_PRIMITIVETYPE ( P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID )
            | P3RX_RENDER_TEXTUREENABLE ( __PERMEDIA_ENABLE )
            | P3RX_RENDER_FOGENABLE ( __PERMEDIA_DISABLE )
            | P3RX_RENDER_FBSOURCEREADENABLE( (bDstKey ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE))
            );

    // Disable all the things I switched on.
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureFilterMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AntialiasMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCoordMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureReadMode0, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureIndexMode0, __PERMEDIA_DISABLE );

    WAIT_FIFO(20);
    P3_ENSURE_DX_SPACE(20);
    
    SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCompositeColorMode0, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeAlphaMode0, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeColorMode1, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeAlphaMode1, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureApplicationMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(FBSourceReadMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE );

    P3_DMA_COMMIT_BUFFER();
} // __P3BltStretchSrcChDstChSourceOveride


//-----------------------------------------------------------------------------
//
// _DD_P3BltStretchSrcChDstChOverlap
//
//-----------------------------------------------------------------------------
void 
_DD_P3BltStretchSrcChDstChOverlap(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource,
    P3_SURF_FORMAT* pFormatDest,
    LPDDHAL_BLTDATA lpBlt,
    RECTL *rSrc,
    RECTL *rDest)
{
    P3_MEMREQUEST mmrq;
    DWORD dwResult;
    
    ZeroMemory(&mmrq, sizeof(P3_MEMREQUEST));
    mmrq.dwSize = sizeof(P3_MEMREQUEST);
    mmrq.dwBytes = DDSurf_Pitch(pSource) * DDSurf_Height(pSource);
    mmrq.dwAlign = 16;
    mmrq.dwFlags = MEM3DL_FIRST_FIT | MEM3DL_FRONT;

    dwResult = _DX_LIN_AllocateLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                                            &mmrq);
    if (dwResult != GLDD_SUCCESS)
    {
        // Couldn't get the memory, so try anyway.  It probably won't look 
        // right but it is our best shot...
        DISPDBG((WRNLVL,"Overlapped stretch blit unlikely to look correct!"));
        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                      pSource, 
                                      pDest, 
                                      pFormatSource, 
                                      pFormatDest, 
                                      lpBlt, 
                                      rSrc, 
                                      rDest);
        return;
    }

    // Copy the source buffer to a temporary place.
    __P3BltDestOveride(pThisDisplay, 
                       pSource, 
                       pSource, 
                       pFormatSource, 
                       pFormatSource, 
                       rSrc, 
                       rSrc, 
                       __GLINT_LOGICOP_COPY, 
                       (long)mmrq.pMem - (long)pThisDisplay->dwScreenFlatAddr);

    // Do the blit, stretching to our temporary buffer
    __P3BltStretchSrcChDstChSourceOveride(pThisDisplay, 
                                          pSource, 
                                          pDest, 
                                          pFormatSource, 
                                          pFormatDest, 
                                          lpBlt, 
                                          rSrc, 
                                          rDest, 
                                          (long)mmrq.pMem - 
                                                (long)pThisDisplay->dwScreenFlatAddr);

    // Free the allocated source buffer.
    _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                             mmrq.pMem);
                             
} // _DD_P3BltStretchSrcChDstChOverlap

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
//-----------------------------------------------------------------------------
//
// Function: P3RX_AA_Shrink
//
// Does a 2x2 to 1x1 blit through the texture unit to shrink an AA buffer
//
//-----------------------------------------------------------------------------
VOID P3RX_AA_Shrink(P3_D3DCONTEXT* pContext)
{
    ULONG   renderData;
    RECTL   rMySrc, rMyDest;
    int     iSrcWidth, iSrcHeight;
    int     iDstWidth, iDstHeight;
    DWORD   TR0;
    int     iSourcePixelSize;
        
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    P3_SURF_INTERNAL* pSurf = pContext->pSurfRenderInt;

    P3_SURF_FORMAT* pFormatSource;
    P3_SURF_FORMAT* pFormatDest = pSurf->pFormatSurface;

    P3_DMA_DEFS();

    rMySrc.top = 0;
    rMySrc.bottom = pSurf->wHeight * 2;
    rMySrc.left = 0;
    rMySrc.right = pSurf->wWidth * 2;

    rMyDest.top = 0;
    rMyDest.left = 0;
    rMyDest.right = pSurf->wWidth;
    rMyDest.bottom = pSurf->wHeight;

    iSrcWidth  = rMySrc.right - rMySrc.left;
    iSrcHeight = rMySrc.bottom - rMySrc.top;
    iDstWidth  = rMyDest.right - rMyDest.left;
    iDstHeight = rMyDest.bottom - rMyDest.top;

    // MAGIC_NUMBER_2D can be anything, but it needs to be at least as
    // big as the widest texture, but not too big or you'll lose fractional
    // precision. Valid range for a P3 is 0->11
    ASSERTDD ( iSrcWidth  <= ( 1 << MAGIC_NUMBER_2D ), 
               "P3RX_AA_Shrink: MAGIC_NUMBER_2D is too small" );
    ASSERTDD ( iSrcHeight <= ( 1 << MAGIC_NUMBER_2D ), 
               "P3RX_AA_Shrink: MAGIC_NUMBER_2D is too small" );
    
    DISPDBG((DBGLVL, "Glint Blt from (%d, %d) to (%d,%d) (%d, %d)", 
                     rMySrc.left, rMySrc.top,
                     rMyDest.left, rMyDest.top, 
                     rMyDest.right, rMyDest.bottom));

    iSourcePixelSize = pSurf->dwPixelSize;
    pFormatSource = pFormatDest;

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    // Vape the cache.
    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_ENABLE);

    // Source read is same as write.
    SEND_P3_DATA(FBSourceReadBufferAddr, pSurf->lOffsetFromMemoryBase );
    SEND_P3_DATA(FBSourceReadBufferWidth, pSurf->dwPixelPitch);
    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(pSurf->dwPatchMode));

    // No offset - we read the dest pixels so that we can chroma-key off them.
    SEND_P3_DATA(FBSourceReadBufferOffset, 0);
    SEND_P3_DATA(FBWriteBufferOffset0, 0);

    SEND_P3_DATA(PixelSize, pSurf->dwPixelSize);
    SEND_P3_DATA(RectanglePosition, 
                        P3RX_RECTANGLEPOSITION_X( rMyDest.left ) |
                        P3RX_RECTANGLEPOSITION_Y( rMyDest.top ));

    renderData =  P3RX_RENDER2D_WIDTH(( rMyDest.right - rMyDest.left ) & 0xfff )
                | P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_NORMAL )
                | P3RX_RENDER2D_FBREADSOURCEENABLE( __PERMEDIA_DISABLE )
                | P3RX_RENDER2D_HEIGHT ( 0 )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_AREASTIPPLEENABLE( __PERMEDIA_DISABLE )
                | P3RX_RENDER2D_TEXTUREENABLE( __PERMEDIA_ENABLE );

    SEND_P3_DATA(Render2D, renderData);

    // This is the alpha blending unit.
    // AlphaBlendxxxMode are set up by the context code.

    // The colour format, order and conversion fields are used by the 
    // chroma keying, even though this register is disabled.
    SEND_P3_DATA(AlphaBlendColorMode,   
              P3RX_ALPHABLENDCOLORMODE_ENABLE ( __PERMEDIA_DISABLE ) 
            | P3RX_ALPHABLENDCOLORMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_ALPHABLENDCOLORMODE_COLORORDER ( COLOR_MODE )
            | P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );
            
    SEND_P3_DATA(AlphaBlendAlphaMode,   
              P3RX_ALPHABLENDALPHAMODE_ENABLE ( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER( __PERMEDIA_DISABLE )
            | P3RX_ALPHABLENDALPHAMODE_ALPHATYPE ( P3RX_ALPHABLENDMODE_ALPHATYPE_OGL )
            | P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION ( P3RX_ALPHABLENDMODE_CONVERT_SHIFT )
            );

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    // No chroma keying at all.
    SEND_P3_DATA(ChromaTestMode, P3RX_CHROMATESTMODE_ENABLE(__PERMEDIA_DISABLE ) );
    
    SEND_P3_DATA(TextureFilterMode, P3RX_TEXFILTERMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXFILTERMODE_FORMATBOTH ( pFormatSource->FilterFormat )
            | P3RX_TEXFILTERMODE_COLORORDERBOTH ( COLOR_MODE )
            | P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH ( __PERMEDIA_DISABLE )
            | P3RX_TEXFILTERMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
            | P3RX_TEXFILTERMODE_ALPHAMAPFILTERING ( __PERMEDIA_DISABLE )
            | P3RX_TEXFILTERMODE_FORCEALPHATOONEBOTH ( __PERMEDIA_DISABLE )
            | P3RX_TEXFILTERMODE_SHIFTBOTH ( __PERMEDIA_DISABLE )
            );

    // And now the alpha test (alpha test unit)
    SEND_P3_DATA ( AlphaTestMode, P3RX_ALPHATESTMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    SEND_P3_DATA ( AntialiasMode, P3RX_ANTIALIASMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    // Texture coordinate unit.
    SEND_P3_DATA(TextureCoordMode, 
              P3RX_TEXCOORDMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXCOORDMODE_WRAPS ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_WRAPT ( P3RX_TEXCOORDMODE_WRAP_REPEAT )
            | P3RX_TEXCOORDMODE_OPERATION ( P3RX_TEXCOORDMODE_OPERATION_2D )
            | P3RX_TEXCOORDMODE_INHIBITDDAINIT ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLELOD ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_ENABLEDY ( __PERMEDIA_DISABLE )
            | P3RX_TEXCOORDMODE_WIDTH (0)       // Only used for mipmapping 
            | P3RX_TEXCOORDMODE_HEIGHT (0)
            | P3RX_TEXCOORDMODE_TEXTUREMAPTYPE ( P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_2D )
            | P3RX_TEXCOORDMODE_WRAPS1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            | P3RX_TEXCOORDMODE_WRAPT1 ( P3RX_TEXCOORDMODE_WRAP_CLAMP )
            );

    SEND_P3_DATA(SStart,        (1 << (31-MAGIC_NUMBER_2D)));
    SEND_P3_DATA(TStart,        (1 << (31-MAGIC_NUMBER_2D)));
    SEND_P3_DATA(dSdx,          (2 << (32-MAGIC_NUMBER_2D)));
    SEND_P3_DATA(dSdyDom,       0);
    SEND_P3_DATA(dTdx,          0);
    SEND_P3_DATA(dTdyDom,       (2 << (32-MAGIC_NUMBER_2D)));

    SEND_P3_DATA(LBWriteMode, 0);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(TextureBaseAddr0, 
                    pContext->dwAliasBackBuffer - 
                            pThisDisplay->dwScreenFlatAddr );

    TR0 = P3RX_TEXREADMODE_ENABLE ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_WIDTH ( 0 )
        | P3RX_TEXREADMODE_HEIGHT ( 0 )
        | P3RX_TEXREADMODE_TEXELSIZE (iSourcePixelSize)
        | P3RX_TEXREADMODE_TEXTURE3D ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_COMBINECACHES ( __PERMEDIA_ENABLE )
        | P3RX_TEXREADMODE_MAPBASELEVEL ( 0 )
        | P3RX_TEXREADMODE_MAPMAXLEVEL ( 0 )
        | P3RX_TEXREADMODE_LOGICALTEXTURE ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_ORIGIN ( P3RX_TEXREADMODE_ORIGIN_TOPLEFT )
        | P3RX_TEXREADMODE_TEXTURETYPE ( P3RX_TEXREADMODE_TEXTURETYPE_NORMAL)
        | P3RX_TEXREADMODE_BYTESWAP ( P3RX_TEXREADMODE_BYTESWAP_NONE )
        | P3RX_TEXREADMODE_MIRROR ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_INVERT ( __PERMEDIA_DISABLE )
        | P3RX_TEXREADMODE_OPAQUESPAN ( __PERMEDIA_DISABLE )
        ;

    SEND_P3_DATA(TextureReadMode0, TR0);
    SEND_P3_DATA(TextureReadMode1, TR0);

    SEND_P3_DATA(TextureMapWidth0, 
                        P3RX_TEXMAPWIDTH_WIDTH(pSurf->dwPixelPitch * 2) |
                        P3RX_TEXMAPWIDTH_LAYOUT(pSurf->dwPatchMode));

    SEND_P3_DATA(TextureCacheReplacementMode,
              P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST0 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST1 ( __PERMEDIA_DISABLE )
            | P3RX_TEXCACHEREPLACEMODE_SHOWCACHEINFO ( __PERMEDIA_DISABLE )
            );

    SEND_P3_DATA(TextureMapSize, 0 );

    SEND_P3_DATA(LUTMode, P3RX_LUTMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    // Texture index unit
    SEND_P3_DATA(TextureIndexMode0, 
              P3RX_TEXINDEXMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXINDEXMODE_WIDTH ( MAGIC_NUMBER_2D )
            | P3RX_TEXINDEXMODE_HEIGHT ( MAGIC_NUMBER_2D )
            | P3RX_TEXINDEXMODE_BORDER ( __PERMEDIA_DISABLE )
            | P3RX_TEXINDEXMODE_WRAPU ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
            | P3RX_TEXINDEXMODE_WRAPV ( P3RX_TEXINDEXMODE_WRAP_REPEAT )
            | P3RX_TEXINDEXMODE_MAPTYPE ( P3RX_TEXINDEXMODE_MAPTYPE_2D )
            | P3RX_TEXINDEXMODE_MAGFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
            | P3RX_TEXINDEXMODE_MINFILTER ( P3RX_TEXINDEXMODE_FILTER_LINEAR )
            | P3RX_TEXINDEXMODE_TEX3DENABLE ( __PERMEDIA_DISABLE )
            | P3RX_TEXINDEXMODE_MIPMAPENABLE ( __PERMEDIA_DISABLE )
            | P3RX_TEXINDEXMODE_NEARESTBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
            | P3RX_TEXINDEXMODE_LINEARBIAS ( P3RX_TEXINDEXMODE_BIAS_ZERO )
            | P3RX_TEXINDEXMODE_SOURCETEXELENABLE ( __PERMEDIA_DISABLE )
            );

    // Disable the composite units.
    SEND_P3_DATA(TextureCompositeMode, 
                    P3RX_TEXCOMPMODE_ENABLE ( __PERMEDIA_DISABLE ) );
    
    // Pass through the texel.
    SEND_P3_DATA(TextureApplicationMode, 
              P3RX_TEXAPPMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_TEXAPPMODE_BOTHA ( P3RX_TEXAPP_A_CC )
            | P3RX_TEXAPPMODE_BOTHB ( P3RX_TEXAPP_B_TC )
            | P3RX_TEXAPPMODE_BOTHI ( P3RX_TEXAPP_I_CA )
            | P3RX_TEXAPPMODE_BOTHINVI ( __PERMEDIA_DISABLE )
            | P3RX_TEXAPPMODE_BOTHOP ( P3RX_TEXAPP_OPERATION_PASS_B )
            | P3RX_TEXAPPMODE_KDENABLE ( __PERMEDIA_DISABLE )
            | P3RX_TEXAPPMODE_KSENABLE ( __PERMEDIA_DISABLE )
            | P3RX_TEXAPPMODE_MOTIONCOMPENABLE ( __PERMEDIA_DISABLE )
            );

    // Filtering, so dither.
    SEND_P3_DATA(DitherMode, 
              P3RX_DITHERMODE_ENABLE ( __PERMEDIA_ENABLE )
            | P3RX_DITHERMODE_DITHERENABLE ( __PERMEDIA_DISABLE )
            | P3RX_DITHERMODE_COLORFORMAT ( pFormatDest->DitherFormat )
            | P3RX_DITHERMODE_XOFFSET ( 0 )
            | P3RX_DITHERMODE_YOFFSET ( 0 )
            | P3RX_DITHERMODE_COLORORDER ( COLOR_MODE )
            | P3RX_DITHERMODE_ALPHADITHER ( P3RX_DITHERMODE_ALPHADITHER_DITHER )
            | P3RX_DITHERMODE_ROUNDINGMODE ( P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE )
            );

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(LogicalOpMode, 
                    P3RX_LOGICALOPMODE_ENABLE ( __PERMEDIA_DISABLE ) );

    SEND_P3_DATA(FBWriteBufferAddr0, pSurf->lOffsetFromMemoryBase );
    SEND_P3_DATA(FBWriteBufferWidth0, pSurf->dwPixelPitch);

    SEND_P3_DATA(Count, rMyDest.bottom - rMyDest.top );
    SEND_P3_DATA(Render,
              P3RX_RENDER_PRIMITIVETYPE ( P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID )
            | P3RX_RENDER_TEXTUREENABLE ( __PERMEDIA_ENABLE )
            | P3RX_RENDER_FOGENABLE ( __PERMEDIA_DISABLE )
            | P3RX_RENDER_FBSOURCEREADENABLE( __PERMEDIA_DISABLE)
            );

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);
    
    // Disable all the units that were switched on.
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureFilterMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AlphaTestMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(AntialiasMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCoordMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureReadMode0, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureIndexMode0, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(TextureApplicationMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE );
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE );

    P3_DMA_COMMIT_BUFFER();
} // P3RX_AA_Shrink
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddover.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddover.c
*
* Content: DirectDraw Overlays implementation
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "ddover.h"

#define P3R3DX_VIDEO 1
#include "ramdac.h"


#if WNT_DDRAW

    #define ENABLE_OVERLAY(pThisDisplay, flag) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->bOverlayEnabled, flag )

    #define SET_OVERLAY_HEIGHT(pThisDisplay, height) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->VBLANKUpdateOverlayHeight, height )
    #define SET_OVERLAY_WIDTH(pThisDisplay, width) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->VBLANKUpdateOverlayWidth, width )
#else
    
    #define ENABLE_OVERLAY(pThisDisplay, flag) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->pGLInfo->bOverlayEnabled, flag )

    #define SET_OVERLAY_HEIGHT(pThisDisplay, height) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->pGLInfo->VBLANKUpdateOverlayHeight, height )
    #define SET_OVERLAY_WIDTH(pThisDisplay, width) \
            FORCED_IN_ORDER_WRITE ( pThisDisplay->pGLInfo->VBLANKUpdateOverlayWidth, width )
#endif // WNT_DDRAW

// Flags used in the dwOverlayFiltering entry.
#define OVERLAY_FILTERING_X 0x1
#define OVERLAY_FILTERING_Y 0x2



// The table that says whether the overlay will actually work at
// This res, dot clock, etc.
typedef struct OverlayWorksEntry_tag
{
    int     iMemBandwidth;          // Actually just memory clock in kHz (well, 1024Hz units actually).
    int     iDotBandwidth;          // In kbytes/sec, i.e. dotclock * pixel depth / 2^10
    int     iSourceWidth;           // In bytes, i.e. pixels*depth.
    int     iWidthCoverage;         // Fraction of screen covered by overlay horizontally * 0x10000
} OverlayWorksEntry;

// This table lists areas that the overlay works in. If there is more memory
// bandwidth, and less of the other factors than given on any single line,
// then the overlay will work. If no single line covers the current mode,
// then the overlay will fail.
// Having more memory bandwidth is fine, and having less for all the others
// is fine - the overlay will still work.

#define SIZE_OF_OVERLAY_WORKS_TABLE 18

// DVD size is 1440 wide (720 YUYV pixels).
static OverlayWorksEntry OverlayWorksTable[SIZE_OF_OVERLAY_WORKS_TABLE] =
{
    {  68359, 210937,  928, 0x10000 },  // Max source width at 70MHz, 1152x864x16,75Hz
    {  68359, 210937, 1024, 0x06000 },  // Max coverage of 1024 width at 70MHz, 1152x864x16,75Hz
    {  68359, 210937, 2048, 0x04000 },  // Max coverage of 2048 width at 70MHz, 1152x864x16,75Hz
    {  68359, 421875,  864, 0x10000 },  // Max source width at 70MHz, 1152x864x32,75Hz
    {  68359, 421875, 1024, 0x04400 },  // Max coverage of 1024 width at 70MHz, 1152x864x32,75Hz
    {  68359, 421875, 2048, 0x03800 },  // Max coverage of 2048 width at 70MHz, 1152x864x32,75Hz

    {  87890, 210937, 1440, 0x10000 },  // Max source width at 90MHz, 1152x864x16,75Hz
    {  87890, 210937, 2048, 0x07000 },  // Max coverage of 2048 width at 90MHz, 1152x864x16,75Hz
    {  87890, 421875, 1152, 0x10000 },  // Max source width at 90MHz, 1152x864x32,75Hz
    {  87890, 421875, 1440, 0x09000 },  // Max DVD size at 90MHz, 1152x864x32,75Hz
    {  87890, 421875, 2048, 0x05500 },  // Max coverage of 2048 width at 90MHz, 1152x864x32,75Hz

    {  87890, 685546,  834, 0x10000 },  // Max source width at 90MHz, 1600x1200x32,64Hz
    {  87890, 685546, 2048, 0x03000 },  // Max coverage of 2048 width at 90MHz, 1600x1200x32,64Hz

// Shipping clock is 110, so measure at 105 just to be on the safe side.
    { 102559, 210937, 2048, 0x07155 },  // Max coverage of 2048 width at 105MHz, 1152x864x16,75Hz
    { 102559, 306640, 1440, 0x10000 },  // Max resoloution for fulscreen DVD at 105MHz: 1024x768x32,75Hz
    { 102559, 421875, 1440, 0x09e38 },  // Max DVD size at 105MHz, 1152x864x32,75Hz
    { 102559, 421875, 2048, 0x0551c },  // Max coverage of 2048 width at 105MHz, 1152x864x32,75Hz

// ...and one that only just works at 109MHz!
    { 106445, 421875, 1440, 0x10000 }   // Max DVD size at 109MHz, 1152x864x32,75Hz

};

//-----------------------------------------------------------------------------
//
// __OV_Compute_Best_Fit_Delta
//
// Function to calculate a 12.12 delta value to provide scaling from
// a src_dimension to the target dest_dimension.
// The dest_dimension is not adjustable, but the src_dimension may be adjusted
// slightly, so that the delta yields a more accurate value for dest.
// filter_adj should be set to 1 if linear filtering is going to be anabled
// during scaling, and 0 otherwise.
// int_bits indicates the number of bits in the scaled delta format
//
//-----------------------------------------------------------------------------
int 
__OV_Compute_Best_Fit_Delta(
    unsigned long *src_dimension,
    unsigned long  dest_dimension,
    unsigned long filter_adj,
    unsigned long int_bits,
    unsigned long *best_delta) 
{
  int result = 0;
  float fp_delta;
  float delta;
  unsigned long delta_mid;
  unsigned long delta_down;
  unsigned long delta_up;
  float mid_src_dim;
  float down_src_dim;
  float up_src_dim;
  float mid_err;
  float mid_frac;
  int   mid_ok;
  float down_err;
  float down_frac;
  int   down_ok;
  float up_err;
  float up_frac;
  int   up_ok;
  int   itemp;

  // The value at which a scaled delta value is deemed too large
  const unsigned int max_scaled_int = (1 << (12+int_bits));

  // Calculate an exact floating point delta
  fp_delta = (float)(*src_dimension - filter_adj) / dest_dimension;

  // Calculate the scaled representation of the delta
  delta = (fp_delta * (1<<12));

  // Truncate to max_int
  if (delta >= max_scaled_int) 
  {
    delta = (float)(max_scaled_int - 1); // Just below the overflow value
  }

  // Calculate the scaled approximation to the delta
  myFtoi(&delta_mid, delta);

  // Calculate the scaled approximation to the delta, less a 'bit'
  // But don't let it go out of range
  myFtoi(&delta_down, delta);
  if (delta_down != 0) 
  {
    delta_down --;
  }

  // Calculate the scaled approximation to the delta, plus a 'bit'
  // But don't let it go out of range
  myFtoi(&delta_up, delta);
  if ((delta_up + 1) < max_scaled_int) 
  {
    delta_up ++;
  }

  // Recompute the source dimensions, based on the dest and deltas
  mid_src_dim =
    (((float)(dest_dimension - 1) * delta_mid) / (1<<12)) + filter_adj;

  down_src_dim =
    (((float)(dest_dimension - 1) * delta_down) / (1<<12)) + filter_adj;

  up_src_dim =
    (((float)(dest_dimension - 1) * delta_up)   / (1<<12)) + filter_adj;

  // Choose the delta which gives final source coordinate closest the target,
  // while giving a fraction 'f' such that (1.0 - f) <= delta

  mid_err  = (float)myFabs(mid_src_dim - *src_dimension);
  myFtoi(&itemp, mid_src_dim);
  mid_frac = mid_src_dim - itemp;
  mid_ok = ((1.0 - mid_frac) <= ((float)(delta_mid) / (1<<12)));

  down_err  = (float)myFabs(down_src_dim - *src_dimension);
  myFtoi(&itemp, down_src_dim);
  down_frac = down_src_dim - itemp;
  down_ok = ((1.0 - down_frac) <= ((float)(delta_down) / (1<<12)));

  up_err  = (float)myFabs(up_src_dim - *src_dimension);
  myFtoi(&itemp, up_src_dim);
  up_frac = (up_src_dim - itemp);
  up_ok = ((1.0 - up_frac) <= ((float)(delta_up) / (1<<12)));

  if (mid_ok && (!down_ok || (mid_err <= down_err)) &&
        (!up_ok   || (mid_err <= up_err))) 
  {
    *best_delta = delta_mid;
    myFtoi(&itemp, (mid_src_dim + ((float)(delta_mid) / (1<<12))));
    *src_dimension = (unsigned long)(itemp - filter_adj);

    result = 1;
  }
  else if (down_ok                            && 
           (!mid_ok || (down_err <= mid_err)) &&
           (!up_ok  || (down_err <= up_err ))  ) 
  {
    *best_delta = delta_down;
    myFtoi(&itemp, (down_src_dim + ((float)(delta_down) / (1<<12))));
    *src_dimension = (unsigned long)(itemp - filter_adj);

    result = 1;
  }
  else if (up_ok                              && 
           (!mid_ok  || (up_err <= mid_err )) && 
           (!down_ok || (up_err <= down_err)) ) 
  {
    *best_delta = delta_up;
    myFtoi(&itemp, (up_src_dim + ((float)(delta_up) / (1<<12))));
    *src_dimension = (unsigned long)(itemp - filter_adj);
    result = 1;
  }
  else 
  {
    result = 0;
    *best_delta = delta_mid;
    myFtoi(&itemp, (mid_src_dim + ((float)(delta_mid) / (1<<12))));
    myFtoi(&itemp, (itemp - filter_adj) + 0.9999f);
    *src_dimension = (unsigned long)itemp;
  }


  return result;
} // __OV_Compute_Best_Fit_Delta


//-----------------------------------------------------------------------------
//
// __OV_Find_Zoom
//
//-----------------------------------------------------------------------------
#define VALID_WIDTH(w)      ((w & 3) == 0)
#define MAKE_VALID_WIDTH(w) ((w) & ~0x3)
#define WIDTH_STEP          4

int 
__OV_Find_Zoom(
    unsigned long  src_width,
    unsigned long* shrink_width,
    unsigned long  dest_width,
    unsigned long* zoom_delta,
    BOOL bFilter) 
{
  int zoom_ok;
  int zx_adj = 0;

  // Find a suitable zoom delta for the given source
  // the source image may be adjusted in width by as much as 8 pixels to
  // acheive a match

  // Find zoom for requested width
  unsigned long trunc_width = MAKE_VALID_WIDTH(*shrink_width);
  zoom_ok = __OV_Compute_Best_Fit_Delta(&trunc_width, 
                                        dest_width, 
                                        zx_adj, 
                                        (bFilter ? 1 : 0),
                                        zoom_delta);

  // If no zoom was matched for the requested width, start searching up and down
  if (!zoom_ok || (!VALID_WIDTH(trunc_width))) 
  {
    unsigned long up_width   = MAKE_VALID_WIDTH(trunc_width) + WIDTH_STEP;
    unsigned long down_width = MAKE_VALID_WIDTH(trunc_width) - WIDTH_STEP;

    int done_up = 0;
    int done_down = 0;
    do 
    {
      // Check upwards
      zoom_ok = 0;
      if (up_width < dest_width) 
      {
        unsigned long new_width = up_width;
        zoom_ok = __OV_Compute_Best_Fit_Delta(&new_width, 
                                              dest_width, 
                                              zx_adj, 
                                              (bFilter ? 1 : 0),
                                              zoom_delta);

        // If the above call somehow adjusts width to invalid,
        // mark the delta invalid
        if (!VALID_WIDTH(new_width)) 
        {
          zoom_ok = 0;
        }

        if (zoom_ok) 
        {
          *shrink_width = new_width;
        }
        else 
        {
          up_width += WIDTH_STEP;
        }
      }
      else
        done_up = 1;

      // Check downwards
      if (!zoom_ok && (down_width >= 4) && (down_width < src_width)) 
      {
        unsigned long new_width = down_width;
        zoom_ok =
          __OV_Compute_Best_Fit_Delta(&new_width, dest_width, zx_adj, (bFilter ? 1 : 0),
                                 zoom_delta);

        // If the above call somehow adjusts width to invalid,
        // mark the delta invalid
        if (!VALID_WIDTH(new_width)) 
        {
          zoom_ok = 0;
        }

        if (zoom_ok) 
        {
          *shrink_width = new_width;
        }
        else 
        {
          down_width -= WIDTH_STEP;
        }
      }
      else
      {
        done_down = 1;
      }
      
    } while (!zoom_ok && (!done_up || !done_down));
  }
  
  return zoom_ok;
} // __OV_Find_Zoom

//-----------------------------------------------------------------------------
//
// __OV_Compute_Params
//
//-----------------------------------------------------------------------------
unsigned long 
__OV_Compute_Params(
    unsigned long  src_width,    
    unsigned long  dest_width,
    unsigned long *ovr_shrinkxd, 
    unsigned long *ovr_zoomxd,
    unsigned long *ovr_w,
    BOOL bFilter)
{
  unsigned long iterations = 0;

  unsigned long sx_adj = 0;

  const unsigned long fixed_one = 0x00001000;

  //
  // Use the source and destination rectangle dimensions to compute
  // delta values
  //

  int zoom_ok;

  unsigned long adj_src_width = src_width + 1; // +1 to account for -- below
  unsigned long exact_shrink_xd;
  unsigned long exact_zoom_xd;

  do 
  {
      unsigned long shrink_width;

    // Step to next source width
    adj_src_width--;

    // Make a stab at the deltas for the current source width

    // Initially, the deltas are assumed to be 1, and the width due to
    // shrinking is therefore equal to src width
    shrink_width = adj_src_width;
    exact_shrink_xd = fixed_one;
    exact_zoom_xd   = fixed_one;

    // Compute the shrink width and delta required
    if (dest_width < adj_src_width) 
    {
      // Shrink
      myFtoi(&exact_shrink_xd, (((float)(adj_src_width - sx_adj) /
                        (float)(dest_width)) * (1<<12)) + 0.999f);

      myFtoi(&shrink_width,(adj_src_width - sx_adj) /
                     ((float)(exact_shrink_xd) / (1<<12)));

    }

    // Truncate shrink to valid width
    if (!VALID_WIDTH(shrink_width) && (shrink_width > 4)) 
    {
      shrink_width = MAKE_VALID_WIDTH(shrink_width);
      
      myFtoi(&exact_shrink_xd,(((float)(adj_src_width - sx_adj) / 
                                (float)(shrink_width)) * (1<<12)) + 0.999f);
    }

    // Compute any zoom delta required
    zoom_ok = 1;
    if (shrink_width < dest_width) 
    {
      // Make an attempt at a zoom delta, and shrink-width for this src width
      zoom_ok = __OV_Find_Zoom(adj_src_width, &shrink_width, dest_width,
                          &exact_zoom_xd, bFilter);

      // Compute shrink delta
      myFtoi(&exact_shrink_xd,(((float)(adj_src_width - sx_adj) /
              (float)(shrink_width)) * (1<<12)) + 0.999f);
    }
  } while (0);

  *ovr_zoomxd       = exact_zoom_xd;
  *ovr_shrinkxd     = exact_shrink_xd;
  *ovr_w            = adj_src_width;

  return iterations;
} // __OV_Compute_Params

//-----------------------------------------------------------------------------
//
// __OV_ClipRectangles
//
// Clip the dest rectangle against the screen and change the source 
// rect appropriately
//
//-----------------------------------------------------------------------------
void 
__OV_ClipRectangles(
    P3_THUNKEDDATA* pThisDisplay, 
    DRVRECT* rcNewSrc, 
    DRVRECT* rcNewDest)
{
    float ScaleX;
    float ScaleY;
    float OffsetX;
    float OffsetY;
    float fTemp;
    DRVRECT rcSrc;
    DRVRECT rcDest;

    // Find the scale and offset from screen rects to overlay rects.
    // This is like a transform to take the dest rect to the source.
    ScaleX = (float)( pThisDisplay->P3Overlay.rcSrc.right - 
                      pThisDisplay->P3Overlay.rcSrc.left    ) / 
             (float)( pThisDisplay->P3Overlay.rcDest.right - 
                      pThisDisplay->P3Overlay.rcDest.left   );
                      
    ScaleY = (float)(pThisDisplay->P3Overlay.rcSrc.bottom   - 
                     pThisDisplay->P3Overlay.rcSrc.top       ) / 
             (float)( pThisDisplay->P3Overlay.rcDest.bottom - 
                      pThisDisplay->P3Overlay.rcDest.top     );
                      
    OffsetX = ((float)pThisDisplay->P3Overlay.rcSrc.left / ScaleX) - 
               (float)pThisDisplay->P3Overlay.rcDest.left;
               
    OffsetY = ((float)pThisDisplay->P3Overlay.rcSrc.top / ScaleY) - 
               (float)pThisDisplay->P3Overlay.rcDest.top;

    // Clip the dest against the screen
    if (pThisDisplay->P3Overlay.rcDest.right > 
        (LONG)pThisDisplay->dwScreenWidth)
    {
        rcDest.right =  (LONG)pThisDisplay->dwScreenWidth;
    }
    else
    {
        rcDest.right = pThisDisplay->P3Overlay.rcDest.right;
    }

    if (pThisDisplay->P3Overlay.rcDest.left < 0)
    {
        rcDest.left =  0;
    }
    else
    {
        rcDest.left = pThisDisplay->P3Overlay.rcDest.left;
    }

    if (pThisDisplay->P3Overlay.rcDest.top < 0)
    {
        rcDest.top =  0;
    }
    else
    {
        rcDest.top = pThisDisplay->P3Overlay.rcDest.top;
    }

    if (pThisDisplay->P3Overlay.rcDest.bottom > 
        (LONG)pThisDisplay->dwScreenHeight)
    {
        rcDest.bottom =  (LONG)pThisDisplay->dwScreenHeight;
    }
    else
    {
        rcDest.bottom = pThisDisplay->P3Overlay.rcDest.bottom;
    }

    // Transform the new dest rect to the new source rect
    fTemp = ( ( (float)rcDest.left + OffsetX ) * ScaleX + 0.499f);
    myFtoi ( (int*)&(rcSrc.left), fTemp );

    fTemp = ( ( (float)rcDest.right + OffsetX ) * ScaleX + 0.499f);
    myFtoi ( (int*)&(rcSrc.right), fTemp );

    fTemp = ( ( (float)rcDest.top + OffsetY ) * ScaleY + 0.499f);
    myFtoi ( (int*)&(rcSrc.top), fTemp );

    fTemp = ( ( (float)rcDest.bottom + OffsetY ) * ScaleY + 0.499f);
    myFtoi ( (int*)&(rcSrc.bottom), fTemp );

    *rcNewSrc = rcSrc;
    *rcNewDest = rcDest;

    DISPDBG((DBGLVL,"rcSrc.left: %d, rcSrc.right: %d", 
                    rcSrc.left, rcSrc.right));
    DISPDBG((DBGLVL,"rcDest.left: %d, rcDest.right: %d", 
                    rcDest.left, rcDest.right));
    return;
} // __OV_ClipRectangles

//-----------------------------------------------------------------------------
//
// _DD_OV_UpdateSource
//
// Update the source DDRAW surface that we are displaying from
// This routine is also used when using the overlay to stretch up for a 
// DFP display, so the DDraw overlay mechnism may be disabled and inactive 
// when this is called. It must allow for this.
//
//-----------------------------------------------------------------------------
void 
_DD_OV_UpdateSource(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    DWORD dwOverlaySourceOffset;

    DISPDBG ((DBGLVL,"** In _DD_OV_UpdateSource"));

    // Update current overlay surface
    pThisDisplay->P3Overlay.pCurrentOverlay = pSurf->lpGbl->fpVidMem;

    // Increase the buffer index
    pThisDisplay->P3Overlay.dwCurrentVideoBuffer++;
    if (pThisDisplay->P3Overlay.dwCurrentVideoBuffer > 2)
    {
        pThisDisplay->P3Overlay.dwCurrentVideoBuffer = 0;
    }

    dwOverlaySourceOffset = (DWORD)(pSurf->lpGbl->fpVidMem - 
                                      pThisDisplay->dwScreenFlatAddr);
                                
    switch (DDSurf_BitDepth(pSurf))
    {
        case 8:
            break;
        case 16:
            dwOverlaySourceOffset >>= 1;
            break;
        case 32:
            dwOverlaySourceOffset >>= 2;
            break;
        default:
            DISPDBG((ERRLVL,"Oops Overlay depth makes no sense"));
            break;
    }

    switch(pThisDisplay->P3Overlay.dwCurrentVideoBuffer)
    {
        case 0:
            LOAD_GLINT_CTRL_REG(VideoOverlayBase0, dwOverlaySourceOffset);
            LOAD_GLINT_CTRL_REG(VideoOverlayIndex, 0);
            break;
        case 1:
            LOAD_GLINT_CTRL_REG(VideoOverlayBase1, dwOverlaySourceOffset);
            LOAD_GLINT_CTRL_REG(VideoOverlayIndex, 1);
            break;
        case 2:
            LOAD_GLINT_CTRL_REG(VideoOverlayBase2, dwOverlaySourceOffset);
            LOAD_GLINT_CTRL_REG(VideoOverlayIndex, 2);
            break;
    }

} // _DD_OV_UpdateSource


//-----------------------------------------------------------------------------
//
// __OV_UpdatePosition
//
// Given the correct starting rectangle, this function clips it against the 
// screen and updates the overlay position registers.
// If *pdwShrinkFactor is NULL, then the overlay is updated, otherwise the
// desired shrink factor is put in *pdwShrinkFactor and the registers are
// NOT updated. This is so the shrink factor can be checked to see if the
// overlay would actually work in this case.
//
//-----------------------------------------------------------------------------
void 
__OV_UpdatePosition(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD *pdwShrinkFactor)
{
    DWORD dwSrcWidth;
    DWORD dwSrcHeight;
    DWORD dwDestHeight;
    DWORD dwDestWidth;
    DWORD dwXDeltaZoom;
    DWORD dwXDeltaShrink;
    DWORD dwYDelta;
    DWORD dwSrcAdjust;
    DRVRECT rcNewSrc;
    DRVRECT rcNewDest;
    P3RDRAMDAC *pP3RDRegs;
    DWORD dwLastShrink;
    DWORD dwLastZoom;
    
    DISPDBG ((DBGLVL,"**In __OV_UpdatePosition"));

    // Get a pointer to the ramdac
    pP3RDRegs = (P3RDRAMDAC *)&(pThisDisplay->pGlint->ExtVCReg);

    // Get the clipped destination rectangles
    __OV_ClipRectangles(pThisDisplay, &rcNewSrc, &rcNewDest);

    // Get the widths
    dwDestWidth = (DWORD)(rcNewDest.right - rcNewDest.left);
    dwDestHeight = (DWORD)(rcNewDest.bottom - rcNewDest.top);
    dwSrcWidth = (DWORD)(rcNewSrc.right - rcNewSrc.left);
    dwSrcHeight = (DWORD)(rcNewSrc.bottom - rcNewSrc.top);

    if ( pThisDisplay->bOverlayPixelDouble )
    {
        // We need to double the destination width first.
        dwDestWidth <<= 1;
    }

    // Compute the overlay parameters
    __OV_Compute_Params(dwSrcWidth, 
                        dwDestWidth, 
                        &dwXDeltaShrink, 
                        &dwXDeltaZoom, 
                        &dwSrcAdjust, 
                        ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_X ) != 0 ) );
                        
    DISPDBG((DBGLVL,"OVERLAY: XShrink 0x%x", dwXDeltaShrink));
    DISPDBG((DBGLVL,"OVERLAY: XZoom 0x%x", dwXDeltaZoom));

    if ( pdwShrinkFactor != NULL )
    {
        // We just wanted to know the shrink factor.
        *pdwShrinkFactor = dwXDeltaShrink;
        return;
    }

    dwLastZoom = READ_GLINT_CTRL_REG(VideoOverlayZoomXDelta);
    dwLastShrink = READ_GLINT_CTRL_REG(VideoOverlayShrinkXDelta);

    if ( ((dwLastZoom >> 4) != dwXDeltaZoom) || 
         ((dwLastShrink >> 4) != dwXDeltaShrink)  )
    {
        //dwCurrentMode = READ_GLINT_CTRL_REG(VideoOverlayMode);
        //LOAD_GLINT_CTRL_REG(VideoOverlayMode, 0);

        LOAD_GLINT_CTRL_REG(VideoOverlayZoomXDelta, (dwXDeltaZoom << 4));
        LOAD_GLINT_CTRL_REG(VideoOverlayShrinkXDelta, (dwXDeltaShrink << 4));
        
        DISPDBG((DBGLVL,"OVERLAY: VideoOverlayZoomXDelta 0x%x", dwXDeltaZoom << 4));
        DISPDBG((DBGLVL,"OVERLAY: VideoOverlayShrinkXDelta 0x%x", dwXDeltaShrink << 4));

        //LOAD_GLINT_CTRL_REG(VideoOverlayMode, dwCurrentMode);
    }   

    // Load up the Y scaling
    if ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_Y ) != 0 )
    {
        // Apply filtering.
        dwYDelta = ( ( ( dwSrcHeight - 1 ) << 12 ) + dwDestHeight - 1 ) / dwDestHeight;
        // Make sure this will cause proper termination
        ASSERTDD ( ( dwYDelta * dwDestHeight ) >= ( ( dwSrcHeight - 1 ) << 12 ), "** __OV_UpdatePosition: dwYDelta is not big enough" );
        ASSERTDD ( ( dwYDelta * ( dwDestHeight - 1 ) ) < ( ( dwSrcHeight - 1 ) << 12 ), "** __OV_UpdatePosition: dwYDelta is too big" );
        dwYDelta <<= 4;
    }
    else
    {
        dwYDelta = ( ( dwSrcHeight << 12 ) + dwDestHeight - 1 ) / dwDestHeight;
        // Make sure this will cause proper termination
        ASSERTDD ( ( dwYDelta * dwDestHeight ) >= ( dwSrcHeight << 12 ), "** __OV_UpdatePosition: dwYDelta is not big enough" );
        ASSERTDD ( ( dwYDelta * ( dwDestHeight - 1 ) ) < ( dwSrcHeight << 12 ), "** __OV_UpdatePosition: dwYDelta is too big" );
        dwYDelta <<= 4;
    }
    LOAD_GLINT_CTRL_REG(VideoOverlayYDelta, dwYDelta);

    // Width & Height
    if ( RENDERCHIP_PERMEDIAP3 )
    {
        // These registers are _not_ synched to VBLANK like all the others,
        // so we need to do it manually.

        if ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_Y ) != 0 )
        {
            SET_OVERLAY_HEIGHT ( pThisDisplay, ( rcNewSrc.bottom - rcNewSrc.top - 1 ) );
        }
        else
        {
            SET_OVERLAY_HEIGHT ( pThisDisplay, rcNewSrc.bottom - rcNewSrc.top );
        }
        SET_OVERLAY_WIDTH ( pThisDisplay, rcNewSrc.right - rcNewSrc.left );
    }
    else
    {
        // These auto-sync on everything else.
        LOAD_GLINT_CTRL_REG(VideoOverlayWidth, rcNewSrc.right - rcNewSrc.left);
        LOAD_GLINT_CTRL_REG(VideoOverlayHeight, rcNewSrc.bottom - rcNewSrc.top);
    }

    // Origin of source
    LOAD_GLINT_CTRL_REG(VideoOverlayOrigin, (rcNewSrc.top << 16) | (rcNewSrc.left & 0xFFFF));

    DISPDBG((DBGLVL,"OVERLAY: VideoOverlayWidth 0x%x", rcNewSrc.right - rcNewSrc.left));
    DISPDBG((DBGLVL,"OVERLAY: VideoOverlayHeight 0x%x", rcNewSrc.bottom - rcNewSrc.top));
    DISPDBG((DBGLVL,"OVERLAY: VideoOverlayOrigin 0x%x",  (rcNewSrc.top << 16) | (rcNewSrc.left & 0xFFFF) ));
    DISPDBG((DBGLVL,"OVERLAY: VideoOverlayYDelta 0x%x",  dwYDelta ));


    // Setup Overlay Dest in RAMDAC Unit.
    // RAMDAC registers are only 8bits wide.
    if ( pThisDisplay->bOverlayPixelDouble )
    {
        // Need to double all these numbers.
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XSTARTLOW, ((rcNewDest.left << 1) & 0xFF));
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XSTARTHIGH, (rcNewDest.left >> 7));

        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XENDLOW, ((rcNewDest.right << 1 ) & 0xFF));
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XENDHIGH, (rcNewDest.right >> 7));
    }
    else
    {
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XSTARTLOW, (rcNewDest.left & 0xFF));
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XSTARTHIGH, (rcNewDest.left >> 8));

        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XENDLOW, (rcNewDest.right & 0xFF));
        P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_XENDHIGH, (rcNewDest.right >> 8));
    }

    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_YSTARTLOW, (rcNewDest.top & 0xFF));
    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_YSTARTHIGH, (rcNewDest.top >> 8));
    
    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_YENDLOW, (rcNewDest.bottom & 0xFF));
    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_YENDHIGH, (rcNewDest.bottom >> 8));

    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_XSTARTLOW   0x%x", (rcNewDest.left & 0xFF) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_XSTARTHIGH  0x%x", (rcNewDest.left >> 8) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_YSTARTLOW   0x%x", (rcNewDest.top & 0xFF) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_YSTARTHIGH  0x%x", (rcNewDest.top >> 8) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_XENDLOW     0x%x", (rcNewDest.right & 0xFF) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_XENDHIGH    0x%x", (rcNewDest.right >> 8) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_YENDLOW     0x%x", (rcNewDest.bottom & 0xFF) ));
    DISPDBG((DBGLVL,"OVERLAY: P3RD_VIDEO_OVERLAY_YENDHIGH    0x%x", (rcNewDest.bottom >> 8) ));
} // __OV_UpdatePosition

//-----------------------------------------------------------------------------
//
// DdUpdateOverlay
//
// Repositions or modifies the visual attributes of an overlay surface.
//
// DdUpdateOverlay shows, hides, or repositions an overlay surface on the 
// screen. It also sets attributes of the overlay surface, such as the stretch 
// factor or type of color key to be used.
//
// The driver should determine whether it has the bandwidth to support the 
// overlay update request. The driver should use dwFlags to determine the type 
// of request and how to process it.
//
// The driver/hardware must stretch or shrink the overlay accordingly when the 
// rectangles specified by rDest and rSrc are different sizes.
//
// Note that DdFlip is used for flipping between overlay surfaces, so 
// performance for DdUpdateOverlay is not critical.
//
//
// Parameters
//
//      puod 
//          Points to a DD_UPDATEOVERLAYDATA structure that contains the 
//          information required to update the overlay. 
//
//          .lpDD 
//              Points to a DD_DIRECTDRAW_GLOBAL structure that represents 
//              the DirectDraw object. 
//          .lpDDDestSurface 
//              Points to a DD_SURFACE_LOCAL structure that represents the 
//              DirectDraw surface to be overlaid. This value can be NULL 
//              if DDOVER_HIDE is specified in dwFlags. 
//          .rDest 
//              Specifies a RECTL structure that contains the x, y, width, 
//              and height of the region on the destination surface to be 
//              overlaid. 
//          .lpDDSrcSurface 
//              Points to a DD_SURFACE_LOCAL structure that describes the 
//              overlay surface. 
//          .rSrc 
//              Specifies a RECTL structure that contains the x, y, width, 
//              and height of the region on the source surface to be used 
//              for the overlay. 
//          .dwFlags 
//              Specifies how the driver should handle the overlay. This 
//              member can be a combination of any of the following flags: 
//
//              DDOVER_HIDE 
//                  The driver should hide the overlay; that is, the driver 
//                  should turn this overlay off. 
//              DDOVER_SHOW 
//                  The driver should show the overlay; that is, the driver 
//                  should turn this overlay on. 
//              DDOVER_KEYDEST 
//                  The driver should use the color key associated with the 
//                  destination surface. 
//              DDOVER_KEYDESTOVERRIDE 
//                  The driver should use the dckDestColorKey member of the 
//                  DDOVERLAYFX structure as the destination color key 
//                  instead of the color key associated with the destination 
//                  surface. 
//              DDOVER_KEYSRC 
//                  The driver should use the color key associated with the 
//                  destination surface. 
//              DDOVER_KEYSRCOVERRIDE 
//                  The driver should use the dckSrcColorKey member of the 
//                  DDOVERLAYFX structure as the source color key instead of 
//                  the color key associated with the destination surface. 
//              DDOVER_DDFX 
//                  The driver should show the overlay surface using the 
//                  attributes specified by overlayFX. 
//              DDOVER_ADDDIRTYRECT 
//                  Should be ignored by the driver. 
//              DDOVER_REFRESHDIRTYRECTS 
//                  Should be ignored by the driver. 
//              DDOVER_REFRESHALL 
//                  Should be ignored by the driver. 
//              DDOVER_INTERLEAVED 
//                  The overlay surface is composed of interleaved fields. 
//                  Drivers that support VPE need only check this flag. 
//              DDOVER_AUTOFLIP 
//                  The driver should autoflip the overlay whenever the 
//                  hardware video port autoflips. Drivers that support VPE 
//                  need only check this flag. 
//              DDOVER_BOB 
//                  The driver should display each field of VPE object data 
//                  individually without causing any jittery artifacts. This 
//                  flag pertains to both VPE and decoders that want to do 
//                  their own flipping in kernel mode using the kernel-mode 
//                  video transport functionality. 
//              DDOVER_OVERRIDEBOBWEAVE 
//                  Bob/weave decisions should not be overridden by other 
//                  interfaces. If the overlay mixer sets this flag, DirectDraw 
//                  will not allow a kernel-mode driver to use the kernel-mode 
//                  video transport functionality to switch the hardware 
//                  between bob and weave mode. 
//              DDOVER_BOBHARDWARE 
//                  Indicates that bob will be performed by hardware rather 
//                  than by software or emulation. Drivers that support VPE 
//                  need only check this flag. 
//
//          .overlayFX 
//              Specifies a DDOVERLAYFX structure describing additional effects 
//              that the driver should use to update the overlay. The driver 
//              should use this structure only if one of DDOVER_DDFX, 
//              DDOVER_KEYDESTOVERRIDE, or DDOVER_KEYSRCOVERRIDE are set in 
//              dwFlags. 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdUpdateOverlay callback. A return code of DD_OK 
//              indicates success. 
//          .UpdateOverlay 
//              This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdUpdateOverlay(
    LPDDHAL_UPDATEOVERLAYDATA puod)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwDestColourKey;
    DWORD dwSrcColourKey;

    BOOL bSrcColorKey = FALSE;
    BOOL bDestColorKey = FALSE;
    P3_SURF_FORMAT* pFormatOverlaySrc;
    P3_SURF_FORMAT* pFormatOverlayDest;
    DWORD dwOverlayControl = 0;
    P3RDRAMDAC *pP3RDRegs;
    VideoOverlayModeReg OverlayMode;
    RDVideoOverlayControlReg RDOverlayControl;
    DWORD dwVideoOverlayUpdate;
    int iCurEntry, iCurDotBandwidth, iCurMemBandwidth, 
        iCurSourceWidth, iCurWidthCoverage;
    BOOL bNoFilterInY;

    GET_THUNKEDDATA(pThisDisplay, puod->lpDD);

    // Get a pointer to the ramdac
    pP3RDRegs = (P3RDRAMDAC *)&(pThisDisplay->pGlint->ExtVCReg);
   
    DISPDBG ((DBGLVL,"**In DdUpdateOverlay dwFlags = %x",puod->dwFlags));

    ZeroMemory(&OverlayMode, sizeof(VideoOverlayModeReg));
    ZeroMemory(&RDOverlayControl, sizeof(RDOverlayControl));

    do
    {
        dwVideoOverlayUpdate = READ_GLINT_CTRL_REG(VideoOverlayUpdate);
    } while ((dwVideoOverlayUpdate & 0x1) != 0);

    // Are we hiding the overlay?
    if (puod->dwFlags & DDOVER_HIDE)
    {
        DISPDBG((DBGLVL,"** DdUpdateOverlay - hiding."));

        // Hide the overlay.
        if (pThisDisplay->P3Overlay.dwVisibleOverlays == 0)
        {
            // No overlay being shown.
            DISPDBG((WRNLVL,"** DdUpdateOverlay - DDOVER_HIDE - already hidden."));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }
        // Hide an overlay which is not shown
        if (pThisDisplay->P3Overlay.pCurrentOverlay !=
            puod->lpDDSrcSurface->lpGbl->fpVidMem)
        {
            // No overlay being shown.
            DISPDBG((WRNLVL,"** DdUpdateOverlay - overlay not visible."));
            puod->ddRVal = DD_OK;
            return DDHAL_DRIVER_HANDLED;
        }

        OverlayMode.Enable = __PERMEDIA_DISABLE;
        RDOverlayControl.Enable = __PERMEDIA_DISABLE;
        
        ENABLE_OVERLAY(pThisDisplay, FALSE);
        pThisDisplay->P3Overlay.pCurrentOverlay = (FLATPTR)NULL;
        pThisDisplay->P3Overlay.dwVisibleOverlays = 0;
    }
    // Are we showing the overlay?
    else if ((puod->dwFlags & DDOVER_SHOW) || 
             (pThisDisplay->P3Overlay.dwVisibleOverlays != 0))
    {   
        if (pThisDisplay->P3Overlay.dwVisibleOverlays > 0) 
        {
            // Compare the video memory pointer to decide whether this is the
            // the current overlay surface
            if (pThisDisplay->P3Overlay.pCurrentOverlay != 
                puod->lpDDSrcSurface->lpGbl->fpVidMem)
            {
                // Overlay is already being displayed. Can't have a new one.
                DISPDBG((WRNLVL,"** DdUpdateOverlay - DDOVER_SHOW - already being shown, and it's a new surface."));
                puod->ddRVal = DDERR_OUTOFCAPS;
                return DDHAL_DRIVER_HANDLED;
            }
        }

        if (((pThisDisplay->pGLInfo->dwFlags & GMVF_DFP_DISPLAY) != 0) &&
            ((pThisDisplay->pGLInfo->dwScreenWidth != pThisDisplay->pGLInfo->dwVideoWidth) ||
             (pThisDisplay->pGLInfo->dwScreenHeight != pThisDisplay->pGLInfo->dwVideoHeight)))
        {
            // Display driver is using the overlay on a DFP, so we can't use it.
            DISPDBG((WRNLVL,"** DdUpdateOverlay - DDOVER_SHOW - overlay being used for desktop stretching on DFP."));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }


        // See if the screen is currently byte-doubled.
        if ( ( ( READ_GLINT_CTRL_REG(MiscControl) ) & 0x80 ) == 0 )
        {
            pThisDisplay->bOverlayPixelDouble = FALSE;
        }
        else
        {
            pThisDisplay->bOverlayPixelDouble = TRUE;
        }

        // Set up Video Overlay Color Format.
        pFormatOverlaySrc = _DD_SUR_GetSurfaceFormat( puod->lpDDSrcSurface);
        pFormatOverlayDest = _DD_SUR_GetSurfaceFormat( puod->lpDDDestSurface);

        pThisDisplay->P3Overlay.dwCurrentVideoBuffer = 0;

        OverlayMode.Enable = __PERMEDIA_ENABLE;
        RDOverlayControl.Enable = __PERMEDIA_ENABLE;

        ENABLE_OVERLAY(pThisDisplay, TRUE);
        pThisDisplay->P3Overlay.dwVisibleOverlays = 1;

        if (pFormatOverlaySrc->DeviceFormat == SURF_YUV422)
        {
            OverlayMode.YUV = VO_YUV_422;
            OverlayMode.ColorOrder = VO_COLOR_ORDER_BGR;
        }
        else if (pFormatOverlaySrc->DeviceFormat == SURF_YUV444)
        {
            OverlayMode.YUV = VO_YUV_444;
            OverlayMode.ColorOrder = VO_COLOR_ORDER_BGR;
        }
        else
        {
            OverlayMode.YUV = VO_YUV_RGB;
            OverlayMode.ColorOrder = VO_COLOR_ORDER_RGB;
            switch (pFormatOverlaySrc->DitherFormat)
            {
                case P3RX_DITHERMODE_COLORFORMAT_8888:
                    OverlayMode.ColorFormat = VO_CF_RGB8888;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_4444:
                    OverlayMode.ColorFormat = VO_CF_RGB4444;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_5551:
                    OverlayMode.ColorFormat = VO_CF_RGB5551;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_565:
                    OverlayMode.ColorFormat = VO_CF_RGB565;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_332:
                    OverlayMode.ColorFormat = VO_CF_RGB332;
                    break;

                case P3RX_DITHERMODE_COLORFORMAT_CI:
                    OverlayMode.ColorFormat = VO_CF_RGBCI8;
                    break;

                default:
                    DISPDBG((ERRLVL,"** DdUpdateOverlay: Unknown overlay pixel type"));
                    puod->ddRVal = DDERR_INVALIDSURFACETYPE;
                    return DDHAL_DRIVER_HANDLED;
                    break;
            }
        }

        // Set up Video Overlay Pixel Size
        switch (pFormatOverlaySrc->dwBitsPerPixel) 
        {
            case 8:
                OverlayMode.PixelSize = VO_PIXEL_SIZE8;
                RDOverlayControl.DirectColor = __PERMEDIA_DISABLE;
                break;

            case 16:
                OverlayMode.PixelSize = VO_PIXEL_SIZE16;
                RDOverlayControl.DirectColor = __PERMEDIA_ENABLE;
                break;

            case 32:
                OverlayMode.PixelSize = VO_PIXEL_SIZE32;
                RDOverlayControl.DirectColor = __PERMEDIA_ENABLE;
                break;

            default:
                break;
        }

        // Keep the rectangles
        pThisDisplay->P3Overlay.rcDest = *(DRVRECT*)&puod->rDest;

        if ( pThisDisplay->P3Overlay.rcDest.left == 1 )
        {
            // Don't use 2 - it will "reveal" the (purple) colourkey colour.
            pThisDisplay->P3Overlay.rcDest.left = 0;
        }
        if ( pThisDisplay->P3Overlay.rcDest.right == 1 )
        {
            // Don't use 0 - it will "reveal" the (purple) colourkey colour.
            pThisDisplay->P3Overlay.rcDest.right = 2;
        }
        pThisDisplay->P3Overlay.rcSrc = *(DRVRECT*)&puod->rSrc;

        pThisDisplay->dwOverlayFiltering = OVERLAY_FILTERING_X | 
                                           OVERLAY_FILTERING_Y;

        // See if this overlay size works by looking it up in the table.
        iCurDotBandwidth = ( pThisDisplay->pGLInfo->PixelClockFrequency << pThisDisplay->pGLInfo->bPixelToBytesShift ) >> 10;
        iCurMemBandwidth = pThisDisplay->pGLInfo->MClkFrequency >> 10;
        iCurSourceWidth = ( puod->rSrc.right - puod->rSrc.left ) * ( pFormatOverlaySrc->dwBitsPerPixel >> 3 );
        iCurWidthCoverage = ( ( puod->rDest.right - puod->rDest.left ) << 16 ) / ( pThisDisplay->pGLInfo->dwScreenWidth );
        DISPDBG (( DBGLVL, "DdUpdateOverlay: Looking up mem=%d, pixel=%d, width=%d, coverage=0x%x", iCurMemBandwidth, iCurDotBandwidth, iCurSourceWidth, iCurWidthCoverage ));

        iCurEntry = 0;
        // Search for a line with lower memory bandwidth and higher everything else.
        while ( iCurEntry < SIZE_OF_OVERLAY_WORKS_TABLE )
        {
            if (( OverlayWorksTable[iCurEntry].iMemBandwidth  <= iCurMemBandwidth  ) &&
                ( OverlayWorksTable[iCurEntry].iDotBandwidth  >= iCurDotBandwidth  ) &&
                ( OverlayWorksTable[iCurEntry].iSourceWidth   >= iCurSourceWidth   ) &&
                ( OverlayWorksTable[iCurEntry].iWidthCoverage >= iCurWidthCoverage ) )
            {
                // Yep - this should be alright then.
                break;
            }
            iCurEntry++;
        }
        if ( iCurEntry == SIZE_OF_OVERLAY_WORKS_TABLE )
        {
            // Oops - this will fall over when filtered.
            DISPDBG((DBGLVL,"** P3RXOU32: overlay wanted mem=%d, pixel=%d, width=%d, coverage=0x%x", iCurMemBandwidth, iCurDotBandwidth, iCurSourceWidth, iCurWidthCoverage ));

            // Normal behaviour.
            bNoFilterInY = TRUE;
        }
        else
        {
            DISPDBG((DBGLVL,"** P3RXOU32: found  mem=%d, pixel=%d, width=%d, coverage=0x%x", OverlayWorksTable[iCurEntry].iMemBandwidth, OverlayWorksTable[iCurEntry].iDotBandwidth, OverlayWorksTable[iCurEntry].iSourceWidth, OverlayWorksTable[iCurEntry].iWidthCoverage ));
            bNoFilterInY = FALSE;
        }

        if ( bNoFilterInY )
        {
            // Turn off Y filtering.
            pThisDisplay->dwOverlayFiltering &= ~OVERLAY_FILTERING_Y;
        }

        // Overlay is fine to show.
        __OV_UpdatePosition(pThisDisplay, NULL);

        _DD_OV_UpdateSource(pThisDisplay, puod->lpDDSrcSurface);

        // Stride of source
        LOAD_GLINT_CTRL_REG(VideoOverlayStride, DDSurf_GetPixelPitch(puod->lpDDSrcSurface));
        LOAD_GLINT_CTRL_REG(VideoOverlayFieldOffset, 0x0);
    
        if ( puod->dwFlags & DDOVER_KEYDEST )
        {
            // Use destination surface's destination colourkey for dst key.
            dwDestColourKey = puod->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
            bDestColorKey = TRUE;
        }

        if ( puod->dwFlags & DDOVER_KEYDESTOVERRIDE )
        {
            // Use DDOVERLAYFX dest colour for dst key.
            dwDestColourKey = puod->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
            bDestColorKey = TRUE;
        }
        
        if ( puod->dwFlags & DDOVER_KEYSRC )
        {
            // Use source surface's source colourkey for src key.
            dwSrcColourKey = puod->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
            bSrcColorKey = TRUE;
        }

        if ( puod->dwFlags & DDOVER_KEYSRCOVERRIDE )
        {
            // Use DDOVERLAYFX src colour for src key.
            dwSrcColourKey = puod->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
            bSrcColorKey = TRUE;
        }

        if (bSrcColorKey && bDestColorKey)
        {
            // We can't do both - return an error.
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }

        RDOverlayControl.Mode = VO_MODE_ALWAYS;

        if (bSrcColorKey)
        {
            if (pFormatOverlaySrc->DeviceFormat == SURF_YUV422)
            {
                // Er... this is a very odd pixel format - how do I get a useful number out of it?
                DISPDBG((ERRLVL,"** DdUpdateOverlay: no idea how to get a YUV422 source colour"));
            }
            else if (pFormatOverlaySrc->DeviceFormat == SURF_YUV444)
            {
                // No idea how to get a useful number out of this.
                DISPDBG((ERRLVL,"** DdUpdateOverlay: no idea how to get a YUV444 source colour"));
            }
            else
            {
                switch (pFormatOverlaySrc->DitherFormat)
                {
                    case P3RX_DITHERMODE_COLORFORMAT_CI:
                        // Formatting already done.
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_332:
                        dwSrcColourKey = FORMAT_332_32BIT_BGR(dwSrcColourKey);
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_5551:
                        dwSrcColourKey = FORMAT_5551_32BIT_BGR(dwSrcColourKey);
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_4444:
                        dwSrcColourKey = FORMAT_4444_32BIT_BGR(dwSrcColourKey);
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_565:
                        dwSrcColourKey = FORMAT_565_32BIT_BGR(dwSrcColourKey);
                        break;

                    case P3RX_DITHERMODE_COLORFORMAT_8888:
                        dwSrcColourKey = FORMAT_8888_32BIT_BGR(dwSrcColourKey);
                        break;

                    default:
                        DISPDBG((ERRLVL,"** DdUpdateOverlay: Unknown overlay pixel type"));
                        break;
                }
            }

            P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYR, (dwSrcColourKey & 0xFF));
            P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYG, ((dwSrcColourKey >> 8) & 0xFF));
            P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYB, ((dwSrcColourKey >> 16) & 0xFF));

            RDOverlayControl.Mode = VO_MODE_OVERLAYKEY;
        }

        if (bDestColorKey)
        {

            switch (pFormatOverlayDest->dwBitsPerPixel) 
            {
                case 8:
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYR, (dwDestColourKey & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYG, (dwDestColourKey & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYB, (dwDestColourKey & 0xFF));
                    break;

                case 16:
                    if (pFormatOverlayDest->DitherFormat == P3RX_DITHERMODE_COLORFORMAT_5551) 
                    {
                        dwDestColourKey = FORMAT_5551_32BIT_BGR(dwDestColourKey);
                    }
                    else 
                    {
                        dwDestColourKey = FORMAT_565_32BIT_BGR(dwDestColourKey);
                    }
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYR, (dwDestColourKey & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYG, ((dwDestColourKey >> 8) & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYB, ((dwDestColourKey >> 16) & 0xFF));
                    break;

                case 32:
                    dwDestColourKey = FORMAT_8888_32BIT_BGR(dwDestColourKey);
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYR, (dwDestColourKey & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYG, ((dwDestColourKey >> 8) & 0xFF));
                    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_KEYB, ((dwDestColourKey >> 16) & 0xFF));
                    break;

                default:
                    break;
            }

            RDOverlayControl.Mode = VO_MODE_MAINKEY;
        }

        // Filtering
        if ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_X ) != 0 )
        {
            if ( ( pThisDisplay->dwOverlayFiltering & OVERLAY_FILTERING_Y ) != 0 )
            {
                // Full filtering.
                OverlayMode.Filter = 1;
            }
            else
            {
                // In X only - no extra bandwidth problems.
                // BUT THIS DOESN'T SEEM TO WORK IN SOME CASES - WE JUST GET NO FILTERING AT ALL!
                OverlayMode.Filter = 2;
            }
        }
        else
        {
            // No filtering at all.
            // (can't do Y filtering with no X filtering, but it never happens anyway).
            OverlayMode.Filter = 0;
        }

        if (puod->dwFlags & DDOVER_ALPHADESTCONSTOVERRIDE)
        {
            P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_BLEND, puod->overlayFX.dwAlphaDestConst);
            RDOverlayControl.Mode = VO_MODE_BLEND;
        }
    }

    // Load up the overlay mode
    LOAD_GLINT_CTRL_REG(VideoOverlayMode, *(DWORD*)&OverlayMode);

    // Setup the overlay control bits in the RAMDAC
    P3RD_LOAD_INDEX_REG(P3RD_VIDEO_OVERLAY_CONTROL, *(BYTE*)&RDOverlayControl);

    // Update the settings
    UPDATE_OVERLAY(pThisDisplay, TRUE, TRUE);

    puod->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // DdUpdateOverlay

//-----------------------------------------------------------------------------
//
// DdSetOverlayPosition
//
// Sets the position for an overlay
//
//  When the overlay is visible, the driver should cause the overlay to be 
//  displayed on the primary surface. The upper left corner of the overlay 
//  should be anchored at (lXPos,lYPos). For example, values of (0,0) indicates 
//  that the upper left corner of the overlay should appear in the upper left 
//  corner of the surface identified by lpDDDestSurface.
//
//  When the overlay is invisible, the driver should set DDHAL_DRIVER_HANDLED in 
//  ddRVal and return.
//
// Parameters
//
//      psopd 
//          Points to a DD_SETOVERLAYPOSITIONDATA structure that contains the 
//          information required to set the overlay position. 
//
//          .lpDD 
//              Points to a DD_DIRECTDRAW_GLOBAL structure that describes the 
//              driver. 
//          .lpDDSrcSurface 
//              Points to a DD_SURFACE_LOCAL structure that represents the 
//              DirectDraw overlay surface. 
//          .lpDDDestSurface 
//              Points to a DD_SURFACE_LOCAL structure representing the surface 
//              that is being overlaid. 
//          .lXPos 
//              Specifies the x coordinate of the upper left corner of the 
//              overlay, in pixels. 
//          .lYPos 
//              Specifies the y coordinate of the upper left corner of the 
//              overlay, in pixels. 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdSetOverlayPosition callback. A return code of 
//              DD_OK indicates success. 
//          .SetOverlayPosition 
//              This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSetOverlayPosition(
    LPDDHAL_SETOVERLAYPOSITIONDATA psopd)
{
    P3_THUNKEDDATA*       pThisDisplay;
    LONG lDestWidth;
    LONG lDestHeight;
    DWORD dwVideoOverlayUpdate;
    GET_THUNKEDDATA(pThisDisplay, psopd->lpDD);

    DISPDBG ((DBGLVL,"**In DdSetOverlayPosition"));

    if (pThisDisplay->P3Overlay.dwVisibleOverlays == 0)
    {
        psopd->ddRVal = DDERR_OVERLAYNOTVISIBLE;
        return DDHAL_DRIVER_HANDLED;
    }
    
    do
    {
        dwVideoOverlayUpdate = READ_GLINT_CTRL_REG(VideoOverlayUpdate);
    } while ((dwVideoOverlayUpdate & 0x1) != 0);

    lDestWidth = pThisDisplay->P3Overlay.rcDest.right - pThisDisplay->P3Overlay.rcDest.left;
    lDestHeight = pThisDisplay->P3Overlay.rcDest.bottom - pThisDisplay->P3Overlay.rcDest.top;

    // Keep the new position
    pThisDisplay->P3Overlay.rcDest.left = psopd->lXPos;
    pThisDisplay->P3Overlay.rcDest.right = psopd->lXPos + (LONG)lDestWidth;

    pThisDisplay->P3Overlay.rcDest.top = psopd->lYPos;
    pThisDisplay->P3Overlay.rcDest.bottom = psopd->lYPos + (LONG)lDestHeight;
    
    // Update the overlay position  
    __OV_UpdatePosition(pThisDisplay, NULL);

    // Update the settings
    LOAD_GLINT_CTRL_REG(VideoOverlayUpdate, VO_ENABLE);

    psopd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} // DdSetOverlayPosition
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddover.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: ddover.h
*
* Content: DirectDraw Overlays implementation macros and definitions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation
\**************************************************************************/

#ifndef __DDOVER_H
#define __DDOVER_H

// For setting up the VideoPort HAL
#define VIDEOPORT_NUM_CONNECT_INFO       8
#define VIDEOPORT_MAX_FIELD_HEIGHT   0x800
#define VIDEOPORT_MAX_FIELD_WIDTH    0x800
#define VIDEOPORT_MAX_VBI_WIDTH      0x800

#define VIDEOPORT_HREF_ACTIVE_HIGH          1
#define VIDEOPORT_VREF_ACTIVE_HIGH          2


// Defines for VideoOverlay values.
#define VO_ENABLE           1
#define VO_DISABLE          0

#define VO_MIRROR_X         1
#define VO_MIRROR_Y         1

#define VO_COLOR_ORDER_RGB  1
#define VO_COLOR_ORDER_BGR  0

#define VO_YUV_RGB          0
#define VO_YUV_422          1
#define VO_YUV_444          2

#define VO_CF_RGB8888       0
#define VO_CF_RGB4444       1
#define VO_CF_RGB5551       2
#define VO_CF_RGB565        3
#define VO_CF_RGB332        4
#define VO_CF_RGBCI8        5

#define VO_PIXEL_SIZE8      0
#define VO_PIXEL_SIZE16     1
#define VO_PIXEL_SIZE32     2

#define VO_MODE_MAINKEY     0
#define VO_MODE_OVERLAYKEY  1
#define VO_MODE_ALWAYS      2
#define VO_MODE_BLEND       3

#define VO_BLENDSRC_MAIN        0
#define VO_BLENDSRC_REGISTER    1

#define VO_KEY_COLOR            0
#define VO_KEY_ALPHA            1
 
#define VO_MEMTYPE_FRAMEBUFFER  (0 << 30)
#define VO_MEMTYPE_LOCALBUFFER  (1 << 30)

typedef struct tagVideoOverlayModeReg
{
    DWORD Enable                : 1;    // lsb
    DWORD BufferSync            : 3;
    DWORD FieldPolarity         : 1;
    DWORD PixelSize             : 2;
    DWORD ColorFormat           : 3;
    DWORD YUV                   : 2;
    DWORD ColorOrder            : 1;
    DWORD LinearColorExtension  : 1;
    DWORD Filter                : 2;
    DWORD DeInterlace           : 2;
    DWORD PatchMode             : 2;
    DWORD Flip                  : 3;
    DWORD MirrorX               : 1;
    DWORD MirrorY               : 1;
    DWORD Reserved1             : 7;
} VideoOverlayModeReg;

typedef struct tagRDVideoOverlayControlReg
{
    BYTE Enable                 : 1;
    BYTE Mode                   : 2;
    BYTE DirectColor            : 1;
    BYTE BlendSrc               : 1;
    BYTE Key                    : 1;
    BYTE Reserved               : 2;
} RDVideoOverlayControlReg;

#define __GP_VIDEO_ENABLE 0x0001

#if WNT_DDRAW

    #define FORCED_IN_ORDER_WRITE(target,value) *((volatile ULONG *)(target)) = (value)
    
    #define UPDATE_OVERLAY(pThisDisplay, bWaitForVSync, bUpdateOverlaySize)                     \
        do                                                                                      \
        {                                                                                       \
            if (pThisDisplay->pGLInfo->dwFlags & GMVF_VBLANK_ENABLED)                           \
            {                                                                                   \
                FORCED_IN_ORDER_WRITE ( pThisDisplay->bVBLANKUpdateOverlay, TRUE );             \
            }                                                                                   \
            else                                                                                \
            {                                                                                   \
                if (bWaitForVSync)                                                              \
                {                                                                               \
                    if (READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE)                  \
                                                                                                \
                    {                                                                           \
                        /* only wait for vblank if the monitor is on */                         \
                        LOAD_GLINT_CTRL_REG(IntFlags, INTR_VBLANK_SET);                         \
                        while (((READ_GLINT_CTRL_REG(IntFlags)) & INTR_VBLANK_SET) == 0);       \
                    }                                                                           \
                }                                                                               \
                                                                                                \
                if (bUpdateOverlaySize)                                                                 \
                {                                                                                       \
                    DWORD dwVideoOverlayMode = READ_GLINT_CTRL_REG(VideoOverlayMode);                   \
                    LOAD_GLINT_CTRL_REG(VideoOverlayMode, (dwVideoOverlayMode & 0xfffffffe));           \
                    LOAD_GLINT_CTRL_REG(VideoOverlayWidth,  *pThisDisplay->VBLANKUpdateOverlayWidth);   \
                    LOAD_GLINT_CTRL_REG(VideoOverlayHeight, *pThisDisplay->VBLANKUpdateOverlayHeight);  \
                    LOAD_GLINT_CTRL_REG(VideoOverlayMode, dwVideoOverlayMode);                          \
                }                                                                                       \
                                                                                                \
                LOAD_GLINT_CTRL_REG(VideoOverlayUpdate, VO_ENABLE);                             \
            }                                                                                   \
        }                                                                                       \
        while(0)

#else

    static ULONG volatile *vpdwTemp;

    // A macro to help me - I always get the volatile syntax wrong.
    #define FORCED_IN_ORDER_WRITE(target,value) vpdwTemp = &(target); *vpdwTemp = (value)

    #define UPDATE_OVERLAY(pThisDisplay, bWaitForVSync, bUpdateOverlaySize)                     \
        do                                                                                      \
        {                                                                                       \
            if (pThisDisplay->pGLInfo->dwFlags & GMVF_VBLANK_ENABLED)                           \
            {                                                                                   \
                FORCED_IN_ORDER_WRITE ( pThisDisplay->pGLInfo->bVBLANKUpdateOverlay, TRUE );    \
            }                                                                                   \
            else                                                                                \
            {                                                                                   \
                if ((READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE) && (bWaitForVSync)) \
                {                                                                               \
                    /* only wait for vblank if the monitor is on */                             \
                    LOAD_GLINT_CTRL_REG(IntFlags, INTR_VBLANK_SET);                             \
                    while (((READ_GLINT_CTRL_REG(IntFlags)) & INTR_VBLANK_SET) == 0);           \
                }                                                                               \
                                                                                                \
                if (bUpdateOverlaySize)                                                                         \
                {                                                                                               \
                    DWORD dwVideoOverlayMode = READ_GLINT_CTRL_REG(VideoOverlayMode);                           \
                    LOAD_GLINT_CTRL_REG(VideoOverlayMode, (dwVideoOverlayMode & 0xfffffffe));                   \
                    LOAD_GLINT_CTRL_REG(VideoOverlayWidth, pThisDisplay->pGLInfo->VBLANKUpdateOverlayWidth);    \
                    LOAD_GLINT_CTRL_REG(VideoOverlayHeight, pThisDisplay->pGLInfo->VBLANKUpdateOverlayHeight);  \
                    LOAD_GLINT_CTRL_REG(VideoOverlayMode, dwVideoOverlayMode);                                  \
                }                                                                                               \
                                                                                                \
                LOAD_GLINT_CTRL_REG(VideoOverlayUpdate, VO_ENABLE);                             \
            }                                                                                   \
        }                                                                                       \
        while(0)

#endif

#endif // __DDOVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddenable.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddenable.c
*
* Content: Windows 2000 only DirectDraw/D3D enabling functions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "glint.h"

#if WNT_DDRAW

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// __DDE_BuildPixelFormat
//
// generate a pixel format structure based on the mode
// This example works only with RGB surfaces
//
//-----------------------------------------------------------------------------
void 
__DDE_BuildPixelFormat(
    P3_THUNKEDDATA* pThisDisplay,
    LPGLINTINFO pGLInfo,
    LPDDPIXELFORMAT pdpf )
{
    PPDEV ppdev;

    ppdev = pThisDisplay->ppdev;

    pdpf->dwSize = sizeof( DDPIXELFORMAT );
    pdpf->dwFourCC = 0;

    pdpf->dwFlags = DDPF_RGB;

    if( pGLInfo->dwBpp == 8 )
    {
        pdpf->dwFlags |= DDPF_PALETTEINDEXED8;
    }
    pdpf->dwRGBBitCount = pGLInfo->dwBpp;

    pdpf->dwRBitMask = ppdev->flRed;
    pdpf->dwGBitMask = ppdev->flGreen;
    pdpf->dwBBitMask = ppdev->flBlue;

    // Calculate the alpha channel as it isn't in the ppdev
    switch (pGLInfo->dwBpp)
    {
        case 8:
            DISPDBG((DBGLVL, "Format is 8 bits"));
            pdpf->dwRGBAlphaBitMask = 0;
            break;
            
        case 16:
            DISPDBG((DBGLVL, "Format is 16 bits"));
            switch(ppdev->flRed)
            {
                case 0x7C00:
                    pdpf->dwRGBAlphaBitMask = 0x8000L;
                    pdpf->dwFlags |= DDPF_ALPHAPIXELS;
                    break;
                default:
                    pdpf->dwRGBAlphaBitMask = 0x0L;
            }
            break;
        case 24:
            DISPDBG((DBGLVL, "Format is 24 bits"));
            pdpf->dwRGBAlphaBitMask = 0x00000000L;
            break;
        case 32:
            DISPDBG((DBGLVL, "Desktop is 32 bits"));
            pdpf->dwRGBAlphaBitMask = 0xff000000L;
            pdpf->dwFlags |= DDPF_ALPHAPIXELS;
            break;
            
    }
} // __DDE_BuildPixelFormat 

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// __DDE_bSetupDDStructs
//
// This fills in the data that would have been setup on Win9X in the
// 16 bit side
// 
//-----------------------------------------------------------------------------
BOOL 
__DDE_bSetupDDStructs( 
    P3_THUNKEDDATA* pThisDisplay, 
    BOOL reset )
{
    DWORD dwRegistryValue;
    BOOL bSuccess;
    LPGLINTINFO pGLInfo;
    PPDEV ppdev;
    void *fbPtr;            // Framebuffer pointer
    void *lbPtr;            // Localbuffer pointer
    DWORD fbSizeInBytes;    // Size of framebuffer
    DWORD lbSizeInBytes;    // Size of localbuffer
    DWORD fbOffsetInBytes;  // Offset to 1st 'free' byte in framebuffer
    DWORD dwMemStart, dwMemEnd;

    // reset == TRUE if there has been a mode change.
    pThisDisplay->bResetMode = reset;

#if DBG
    if (pThisDisplay->bResetMode)
    {
        DISPDBG((DBGLVL,"Resetting due to mode change"));
    }
    else
    {
        DISPDBG((DBGLVL, "Creating for the first time"));
    }
#endif

    // Setup pThisDisplay->pGLInfo from PPDEV
    pGLInfo = pThisDisplay->pGLInfo;
    ppdev = pThisDisplay->ppdev;

    GetFBLBInfoForDDraw (ppdev, 
                          &fbPtr,               // Framebuffer pointer
                          &lbPtr,               // Localbuffer pointer,
                                                //     (*** This is NULL***)
                          &fbSizeInBytes,       // Size of framebuffer
                          &lbSizeInBytes,       // Size of localbuffer
                          &fbOffsetInBytes,     // Offset to 1st 'free' byte 
                                                //     in framebuffer
                          &pGLInfo->bDRAMBoard);// TRUE if SDRAM vidmem, 
                                                //   FALSE if SGRAM 
                                                //   (i.e. hw writemask) vidmem


    DISPDBG((DBGLVL, "__DDE_bSetupDDStructs: fbPtr 0x%lx, fbOff 0x%x", 
                     fbPtr, fbOffsetInBytes));

    // If VBlankStatusPtr is non-NULL then we know that the NT miniport 
    // will set the VBlankStatusPtr for us.
    if (pThisDisplay->VBlankStatusPtr)
        pGLInfo->dwFlags = GMVF_VBLANK_ENABLED;// Say that we are using VBLANKs
    else
        pGLInfo->dwFlags = 0;

    pGLInfo->bPixelToBytesShift = (unsigned char)ppdev->cPelSize;
    pGLInfo->ddFBSize = fbSizeInBytes;
    pGLInfo->dwScreenBase = 0;
    pGLInfo->dwOffscreenBase = fbOffsetInBytes;

    pGLInfo->dwScreenWidth = ppdev->cxScreen;   // Driver info
    pGLInfo->dwScreenHeight = ppdev->cyScreen;
    pGLInfo->dwVideoWidth = ppdev->cxMemory;
    pGLInfo->dwVideoHeight = ppdev->cyMemory;

    bSuccess = GET_REGISTRY_ULONG_FROM_STRING(
                        "HardwareInformation.CurrentPixelClockSpeed",
                        &dwRegistryValue);
    if(!bSuccess)
    {
        DISPDBG((ERRLVL,"Error - can't determine pixel clock"));
        dwRegistryValue = 0;
    }
    DISPDBG((DBGLVL,"Pixel clock frequency is %dHz", dwRegistryValue));
    pGLInfo->PixelClockFrequency = dwRegistryValue;

    bSuccess = GET_REGISTRY_ULONG_FROM_STRING(
                        "HardwareInformation.CurrentMemClockSpeed", 
                        &dwRegistryValue);
    if(!bSuccess)
    {
        DISPDBG((ERRLVL,"Error - can't determine memory clock"));
        dwRegistryValue = 0;
    }
    
    DISPDBG((DBGLVL,"Memory clock frequency is %dHz", dwRegistryValue));
    pGLInfo->MClkFrequency = dwRegistryValue;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        DISPDBG((DBGLVL, "Desktop is 8 bits"));
        pGLInfo->dwBpp = 8;
    }
    else if (ppdev->iBitmapFormat == BMF_16BPP)
    {
        DISPDBG((DBGLVL, "Desktop is 16 bits"));
        pGLInfo->dwBpp = 16;
    }
    else if (ppdev->iBitmapFormat == BMF_24BPP)
    {
        DISPDBG((DBGLVL, "Desktop is 24 bits"));
        pGLInfo->dwBpp = 24;
    }
    else
    {
        DISPDBG((DBGLVL, "Desktop is 32 bits"));
        pGLInfo->dwBpp = 32;
    }

    pGLInfo->dwScreenWidthBytes = ppdev->lDelta;

    if (pGLInfo->pRegs == 0)
    {
        DISPDBG ((WRNLVL, "__DDE_bSetupDDStructs: NULL register set"));
        return (FALSE);
    }

    // Setup the information that is shared with the 32 bit side
    // Control points to the RAMDAC
    // pGLInfo is a pointer to the DisplayDriver state.
    pThisDisplay->pGLInfo = pGLInfo;
    pThisDisplay->control = (FLATPTR) pGLInfo->pRegs;

    // NT uses offsets for its memory addresses
    pThisDisplay->dwScreenFlatAddr = 0;
    pThisDisplay->dwLocalBuffer = 0;

    __DDE_BuildPixelFormat( pThisDisplay, 
                        (LPGLINTINFO) pThisDisplay->pGLInfo, 
                        &pThisDisplay->ddpfDisplay );

    // Setup the display size information
    // dwScreenWidth, dwScreenHeight = current resolution
    // cxMemory = Pixels across for one scanline 
    //              (not necessarily the same as the screen width)
    // cyMemory = Scanline height of the memory
    // dwScreenStart = First visible line of display
    pThisDisplay->dwScreenWidth = pGLInfo->dwScreenWidth;
    pThisDisplay->dwScreenHeight = pGLInfo->dwScreenHeight;
    pThisDisplay->cxMemory = pGLInfo->dwScreenWidth;

    pThisDisplay->dwScreenStart = pThisDisplay->dwScreenFlatAddr + 
                                                        pGLInfo->dwScreenBase;
    
    // Usefull constants used during blits.
    if (pThisDisplay->ddpfDisplay.dwRGBBitCount == 24)
    {
        // The driver will detect these strange values and handle appropriately
        pThisDisplay->bPixShift = 4;
        pThisDisplay->bBppShift = 4;
        pThisDisplay->dwBppMask = 4;
        
        pThisDisplay->cyMemory = pGLInfo->ddFBSize / 
                                    (pThisDisplay->dwScreenWidth * 3);
    }
    else
    {
        // = 2,1,0 for 32,16,8 depth.  Shifts needed to calculate bytes/pixel
        pThisDisplay->bPixShift = 
                            (BYTE)pThisDisplay->ddpfDisplay.dwRGBBitCount >> 4;
        // = 0,1,2 for 32/16/8.
        pThisDisplay->bBppShift = 2 - pThisDisplay->bPixShift;
        // = 3,1,0 for 8,16,32 bpp
        pThisDisplay->dwBppMask = 3 >> pThisDisplay->bPixShift;

        pThisDisplay->cyMemory = 
                        pGLInfo->ddFBSize / 
                            (pThisDisplay->dwScreenWidth <<  
                                (pThisDisplay->ddpfDisplay.dwRGBBitCount >> 4));
    }

    // On Windows NT, we manage a region of memory starting from 0 
    //(all pointers are offsets from the start of the mapped memory)
    dwMemStart = pGLInfo->dwOffscreenBase;
    dwMemEnd = pGLInfo->ddFBSize - 1;

    // Round up the start pointer and round down the end pointer
    dwMemStart = (dwMemStart + 3) & ~3;
    dwMemEnd = dwMemEnd & ~3;
    
    // Now make the end pointer inclusive
    dwMemEnd -= 1;

    DISPDBG((DBGLVL,"Heap Attributes:"));
    DISPDBG((DBGLVL,"  Start of Heap Memory: 0x%lx", 
                pThisDisplay->LocalVideoHeap0Info.dwMemStart));
    DISPDBG((DBGLVL,"  End of Heap Memory: 0x%lx", 
                pThisDisplay->LocalVideoHeap0Info.dwMemEnd));

    // If we already have a heap setup and the mode has changed
    // we free the Heap manager
    if (pThisDisplay->bDDHeapManager)
    {
        if (pThisDisplay->bResetMode)
        {
            // The mode has been changed.  
            // We need to free the allocator and re-create it
            _DX_LIN_UnInitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info);

            // Start the allocator off again.
            _DX_LIN_InitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info,
                                          dwMemStart,
                                          dwMemEnd);
        }
    }
    else
    {
        // This must be the first instance of a created driver,
        // so create the Heap and remember that it is created.
        _DX_LIN_InitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info,
                                      dwMemStart,
                                      dwMemEnd);
        pThisDisplay->bDDHeapManager = TRUE;
    }

    if(ppdev->flStatus & ENABLE_LINEAR_HEAP)
    {
        // save away the heap info we really need, we won't actually 
        // enable the DX managed heap until we get a 
        // DrvNotify(DN_DRAWING_BEGIN)
        ppdev->heap.pvmLinearHeap = &pThisDisplay->LocalVideoHeap0Info;
        ppdev->heap.cLinearHeaps = 1;
    }

    return TRUE;
} // __DDE_bSetupDDStructs

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// __DDE_bDestroyDDStructs
//
// Disable the linear allocator.  
//
//-----------------------------------------------------------------------------
BOOL 
__DDE_bDestroyDDStructs ( 
    P3_THUNKEDDATA* pThisDisplay )
{
    // Release the linear allocator
    if (pThisDisplay->bDDHeapManager)
    {
        _DX_LIN_UnInitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info);
    }

    // 3D Heap manager not available.
    pThisDisplay->bDDHeapManager = FALSE;

    // Reset the driver version to 0 so it will be filled in again.
    pThisDisplay->dwDXVersion = 0;

    return TRUE;

} // __DDE_bDestroyDDStructs

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_CreatePPDEV
//
// These functions are called in sync with the creation/destruction of the pDev
//
//-----------------------------------------------------------------------------
BOOL 
_DD_DDE_CreatePPDEV(
    PDEV* ppdev)
{
    P3_THUNKEDDATA* pThisDisplay;

    DISPDBG((DBGLVL,"*** In _DD_DDE_CreatePPDEV"));

    ASSERTDD(ppdev->thunkData == NULL,
             "ERROR: thunkData already created for this pDev??");

    // initialize the DX context which will be used by the display driver 
    // context switcher. We need a reference count because there is a case 
    // when a second, temporary, context would otherwise be created (when 
    // enabling the second adapter in a m-monitor system), first scrubbing 
    // out the old context ID, then invalidating the new one when it is
    // deleted!
    ppdev->DDContextID = -1;
    ppdev->DDContextRefCount = 0;

    // Allocate our ppdev
    ppdev->thunkData = (PVOID)HEAP_ALLOC(HEAP_ZERO_MEMORY, 
                                         sizeof(P3_THUNKEDDATA),
                                         ALLOC_TAG_DX(D));                                          
    if (ppdev->thunkData == NULL)
    {
        DISPDBG((ERRLVL, "_DD_DDE_CreatePPDEV: thunkdata alloc failed"));
        return (FALSE);
    }

    // Our ppdev is called pThisDisplay
    pThisDisplay = (P3_THUNKEDDATA*) ppdev->thunkData;
    pThisDisplay->ppdev = ppdev;

    pThisDisplay->pGLInfo = (PVOID)HEAP_ALLOC(HEAP_ZERO_MEMORY, 
                                              sizeof(GlintInfo),
                                              ALLOC_TAG_DX(E));
    if (pThisDisplay->pGLInfo == NULL)
    {
        DISPDBG((ERRLVL, "_DD_DDE_CreatePPDEV: pGLInfo alloc failed"));

        EngFreeMem (pThisDisplay);
        ppdev->thunkData = NULL;

        return (FALSE);
    }

//@@BEGIN_DDKSPLIT
    // W9X DX version is setup in the display driver.
//@@END_DDKSPLIT    

    // On Windows W2000 DX is always at least DX7
    pThisDisplay->dwDXVersion = DX7_RUNTIME;

    GetChipInfoForDDraw(ppdev, 
                        &pThisDisplay->pGLInfo->dwRenderChipID, 
                        &pThisDisplay->pGLInfo->dwRenderChipRev, 
                        &pThisDisplay->pGLInfo->dwRenderFamily,
                        &pThisDisplay->pGLInfo->dwGammaRev);

    DISPDBG((DBGLVL,"RenderChip: 0x%x, RenderFamily: 0x%x", 
                    pThisDisplay->pGLInfo->dwRenderChipID, 
                    pThisDisplay->pGLInfo->dwRenderFamily));

    return TRUE;
} // _DD_DDE_CreatePPDEV

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_ResetPPDEV
//
//-----------------------------------------------------------------------------
void _DD_DDE_ResetPPDEV(PDEV* ppdevOld, PDEV* ppdevNew)
{
    P3_THUNKEDDATA* pThisDisplayOld = (P3_THUNKEDDATA*)ppdevOld->thunkData;
    P3_THUNKEDDATA* pThisDisplayNew = (P3_THUNKEDDATA*)ppdevNew->thunkData;
    
    DISPDBG((DBGLVL,"_DD_DDE_ResetPPDEV: "
                    "pThisDispayOld: 0x%x, pThisDisplayNew: 0x%x", 
                    pThisDisplayOld, pThisDisplayNew));
               
} // _DD_DDE_ResetPPDEV

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_DestroyPPDEV
//
//-----------------------------------------------------------------------------
void _DD_DDE_DestroyPPDEV(PDEV* ppdev)
{
    P3_THUNKEDDATA* pThisDisplay = (P3_THUNKEDDATA*)ppdev->thunkData;

#if DBG
    g_pThisTemp = NULL;
#endif

    if (pThisDisplay)
    {
        // The 32 bit side will have allocated memory for use as global 
        // D3D/DD Driver data. Free it if it is there
        if (pThisDisplay->pD3DHALCallbacks16)
        {
            SHARED_HEAP_FREE(&pThisDisplay->pD3DHALCallbacks16, 
                             &pThisDisplay->pD3DHALCallbacks32,
                             TRUE);
                                
            DISPDBG((DBGLVL,"Freed pThisDisplay->pD3DHALCallbacks32"));
        }

        if (pThisDisplay->pD3DDriverData16)
        {
            SHARED_HEAP_FREE(&pThisDisplay->pD3DDriverData16, 
                             &pThisDisplay->pD3DDriverData32,
                             TRUE);
                    
            DISPDBG((DBGLVL,"Freed pThisDisplay->pD3DDriverData32"));
        }

        pThisDisplay->lpD3DGlobalDriverData = 0;
        pThisDisplay->lpD3DHALCallbacks = 0;

        if (pThisDisplay->pGLInfo)
        {
            EngFreeMem (pThisDisplay->pGLInfo);
            pThisDisplay->pGLInfo = NULL;
            DISPDBG((DBGLVL,"Freed pThisDisplay->pGLInfo"));
        }

        EngFreeMem (pThisDisplay);
        pThisDisplay = NULL;
        DISPDBG((DBGLVL,"Freed pThisDisplay"));
    }

    // Clear the pointer
    ppdev->thunkData = NULL;
    
} // _DD_DDE_DestroyPPDEV

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_vAssertModeDirectDraw
//
// This function is called by enable.c when entering or leaving the
// DOS full-screen character mode.
//
//-----------------------------------------------------------------------------
VOID 
_DD_DDE_vAssertModeDirectDraw(
    PDEV*   ppdev,
    BOOL    bEnabled)
{
    P3_THUNKEDDATA* pThisDisplay = (P3_THUNKEDDATA*)ppdev->thunkData;
    
    DISPDBG((DBGLVL, "_DD_DDE_vAssertModeDirectDraw: enter"));

#if DX7_TEXMANAGEMENT
    // Mark all managed surfaces as dirty as we've lost 
    // everything living in the videomemory

   _DD_TM_EvictAllManagedTextures(pThisDisplay);
    
#endif    
    
} // _DD_DDE_vAssertModeDirectDraw

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_bEnableDirectDraw
//
// This function is called by enable.c when the mode is first initialized,
// right after the miniport does the mode-set.
//
//-----------------------------------------------------------------------------
BOOL _DD_DDE_bEnableDirectDraw(
PDEV*   ppdev)
{
    DISPDBG((DBGLVL, "_DD_DDE_bEnableDirectDraw: enter"));

    // DirectDraw is all set to be used on this card:
    ppdev->flStatus |= STAT_DIRECTDRAW;

    return(TRUE);
} // _DD_DDE_bEnableDirectDraw

//-----------------------------------------------------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// _DD_DDE_vDisableDirectDraw
//
// This function is called by enable.c when the driver is shutting down.
//
//-----------------------------------------------------------------------------
VOID _DD_DDE_vDisableDirectDraw(
PDEV*   ppdev)
{
     DISPDBG((DBGLVL, "_DD_DDE_vDisableDirectDraw: enter"));
} // _DD_DDE_vDisableDirectDraw

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// DrvEnableDirectDraw
//
// Enables hardware for DirectDraw use.
//
// GDI calls DrvEnableDirectDraw to obtain pointers to the DirectDraw callbacks
// that the driver supports. The driver should set the function pointer members 
// of DD_CALLBACKS, DD_SURFACECALLBACKS, and DD_PALETTECALLBACKS to point to 
// those functions that it implements. A driver should also set the 
// corresponding bit fields in the dwFlags members of these structures for all 
// supported callbacks.
//
// A driver's DrvEnableDirectDraw implementation can also dedicate hardware 
// resources such as display memory for use by DirectDraw only.
//
// DrvEnableDirectDraw returns TRUE if it succeeds; otherwise, it returns FALSE
//
//  Parameters
//
//      dhpdev 
//          Handle to the PDEV returned by the driver's DrvEnablePDEV routine.
//      pCallBacks 
//          Points to the DD_CALLBACKS structure to be initialized by the 
//          driver. 
//      pSurfaceCallBacks 
//          Points to the DD_SURFACECALLBACKS structure to be initialized by 
//          the driver. 
//      pPaletteCallBacks 
//          Points to the DD_PALETTECALLBACKS structure to be initialized by 
//          the driver. 
//
//-----------------------------------------------------------------------------

BOOL DrvEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PDEV* ppdev;
    BOOL bRet;
    DWORD dwResult;
    P3_THUNKEDDATA* pThisDisplay;
    DWORD *theVBlankThing, *bOverlayEnabled;
    DWORD *VBLANKUpdateOverlay;
    DWORD *VBLANKUpdateOverlayWidth;
    DWORD *VBLANKUpdateOverlayHeight;
    DWORD Buffers;
    
    ppdev = (PDEV*) dhpdev;
    pThisDisplay = (P3_THUNKEDDATA*) ppdev->thunkData;

    if (!bSetupOffscreenForDDraw (FALSE, 
                                  ppdev, 
                                  &theVBlankThing, 
                                  &bOverlayEnabled, 
                                  &VBLANKUpdateOverlay, 
                                  &VBLANKUpdateOverlayWidth, 
                                  &VBLANKUpdateOverlayHeight))
    {
        DISPDBG((ERRLVL, "DrvEnableDirectDraw: "
                         "bSetupOffscreenForDDraw failed, but continuing"));
        //return (FALSE);
    }

    pThisDisplay->VBlankStatusPtr = theVBlankThing;
    pThisDisplay->bOverlayEnabled = bOverlayEnabled;
    pThisDisplay->bVBLANKUpdateOverlay = VBLANKUpdateOverlay;
    pThisDisplay->VBLANKUpdateOverlayWidth = VBLANKUpdateOverlayWidth;
    pThisDisplay->VBLANKUpdateOverlayHeight = VBLANKUpdateOverlayHeight;

#if DBG
    // Read in the registry variable for the debug level
    {
        // Get the Debuglevel for DirectX
        bRet = GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.Debug", &dwResult);
        if (bRet == TRUE)
        {
            P3R3DX_DebugLevel = (LONG)dwResult;
        }
        else
        {
            P3R3DX_DebugLevel = 0;
        }

        DISPDBG((WRNLVL,"Setting DebugLevel to 0x%x", P3R3DX_DebugLevel));
    }
#endif

    // Create context with >2 sub-buffers for Interupt driven DMA.
    bRet =GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.SubBuffers", &dwResult);
    if ((dwResult == 0) || (bRet == FALSE))
    {
        // Default
        Buffers = DEFAULT_SUBBUFFERS;
    }
    else 
    {
        if (dwResult > MAX_SUBBUFFERS) 
        {
            Buffers = MAX_SUBBUFFERS;
        }
        else
        {
            Buffers = dwResult;
        }
        
        if (Buffers < 2)
        {
            Buffers = 2;
        }
    }

    pThisDisplay->pGLInfo->dw3DDMABufferSize = 0;
    pThisDisplay->pGLInfo->dw3DDMABufferPhys = 0;
    pThisDisplay->pGLInfo->dw3DDMABufferVirt = 0;

    // Allocate a DMA Buffer on Win2K
    DDGetFreeDMABuffer(&pThisDisplay->pGLInfo->dw3DDMABufferPhys,
                       &pThisDisplay->pGLInfo->dw3DDMABufferVirt,
                       &pThisDisplay->pGLInfo->dw3DDMABufferSize);

    if (pThisDisplay->pGLInfo->dw3DDMABufferSize != 0)
    {
        DISPDBG((DBGLVL,"Allocated DMA Buffer:- "
                        "Phys:0x%x, Virt:0x%x, Size:0x%x",
                        pThisDisplay->pGLInfo->dw3DDMABufferPhys,
                        pThisDisplay->pGLInfo->dw3DDMABufferVirt,
                        pThisDisplay->pGLInfo->dw3DDMABufferSize));
    }
    else
    {
        DISPDBG((WRNLVL,"Failed to allocate DMA Buffer!"));
    }

    if(ppdev->DDContextID == -1)
    {
        // we don't have a DDraw context: create one now
        ppdev->DDContextID = GlintAllocateNewContext(ppdev, 
                                                     NULL, 
                                                     0, 
                                                     Buffers, 
                                                     NULL, 
                                                     ContextType_None);
        if(ppdev->DDContextID != -1)
        {
            ++ppdev->DDContextRefCount;
            
            DISPDBG((DBGLVL, "<%13s, %4d>: DrvEnableDirectDraw: "
                             "Created DDraw context, current DX context "
                             "count = %d for ppdev %p", 
                             __FILE__, __LINE__, 
                             ppdev->DDContextRefCount, ppdev));
        }
    }
    
    if (ppdev->DDContextID < 0) 
    {
        DISPDBG((ERRLVL, "ERROR: failed to allocate DDRAW context"));
        return(FALSE);
    }
    
    DISPDBG((DBGLVL,"  Created DD Register context: 0x%x", 
                    ppdev->DDContextID));

    if (!__DDE_bSetupDDStructs (pThisDisplay, TRUE))
    {
        vGlintFreeContext (ppdev, ppdev->DDContextID);
        DISPDBG((ERRLVL, "ERROR: DrvEnableDirectDraw: "
                         "__DDE_bSetupDDStructs failed"));
        return (FALSE);
    }
    
    if (!_DD_InitDDHAL32Bit (pThisDisplay))
    {
        vGlintFreeContext (ppdev, ppdev->DDContextID);
        DISPDBG((ERRLVL, "ERROR: DrvEnableDirectDraw: "
                         "_DD_InitDDHAL32Bit failed"));
        return (FALSE);
    }
    
    // Set the flag that says we have to handle a mode change.
    // This will cause the chip to be initialised properly at the 
    // right time.
    pThisDisplay->bResetMode = TRUE;
    pThisDisplay->bStartOfDay = TRUE;
    pThisDisplay->pGLInfo->dwDirectXState = DIRECTX_LASTOP_UNKNOWN;

    // Fill in the function pointers at start of day.  We copy these from 
    // the Initialisation done in _DD_InitDDHAL32Bit.  It's OK to do this 
    // because on a Windows NT compile the structures should match
    memcpy(pCallBacks, 
           &pThisDisplay->DDHALCallbacks, 
           sizeof(DD_CALLBACKS));
           
    memcpy(pSurfaceCallBacks, 
           &pThisDisplay->DDSurfCallbacks, 
           sizeof(DD_SURFACECALLBACKS));

    // Note that we don't call 'vGetDisplayDuration' here, for a couple of
    // reasons:
    //
    //  o Because the system is already running, it would be disconcerting
    //    to pause the graphics for a good portion of a second just to read
    //    the refresh rate;
    //  o More importantly, we may not be in graphics mode right now.
    //
    // For both reasons, we always measure the refresh rate when we switch
    // to a new mode.

    return(TRUE);
    
} // DrvEnableDirectDraw

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// DrvDisableDirectDraw
//
// Disables hardware for DirectDraw use.
//
// GDI calls DrvDisableDirectDraw when the last DirectDraw application has 
// finished running. A driver's DrvDisableDirectDraw implementation should 
// clean up any software resources and reclaim any hardware resources that 
// the driver dedicated to DirectDraw in DrvEnableDirectDraw.
//
// Parameters
//      dhpdev 
//          Handle to the PDEV that was returned by the driver's 
//          DrvEnablePDEV routine. 
//
//-----------------------------------------------------------------------------
VOID 
DrvDisableDirectDraw(
    DHPDEV      dhpdev)
{
    PDEV* ppdev;
    P3_THUNKEDDATA* pThisDisplay;

    ppdev = (PDEV*) dhpdev;
    pThisDisplay = (P3_THUNKEDDATA*) ppdev->thunkData;

    // Only do all this stuff if we have not already been disabled.
    // Note that when running NT4 without SP3, this function can be called
    // more times than DrvEnableDirectDraw.
    if (pThisDisplay != NULL)
    {
        // Re-enable GDI off-screen bitmaps
        (void) bSetupOffscreenForDDraw (TRUE, 
                                        ppdev, 
                                        NULL, 
                                        NULL, 
                                        NULL, 
                                        NULL, 
                                        NULL);

        // Free all memory
        (void) __DDE_bDestroyDDStructs (pThisDisplay);

        if(ppdev->DDContextRefCount > 0)
        {
            if(--ppdev->DDContextRefCount == 0)
            {
                vGlintFreeContext (ppdev, ppdev->DDContextID);
                DISPDBG((DBGLVL,"Freed DDraw context: 0x%x", 
                                ppdev->DDContextID));
                                
                ppdev->DDContextID = -1;

                DISPDBG((DBGLVL, "<%13s, %4d>: DrvDisableDirectDraw:"
                                 " Deleted DDraw context, current DX context"
                                 " count = %d for ppdev %p", 
                                 __FILE__, __LINE__, 
                                 ppdev->DDContextRefCount, ppdev));
            }
        }

        DDFreeDMABuffer((void*)(ULONG_PTR)pThisDisplay->pGLInfo->dw3DDMABufferPhys);

    }
} // DrvDisableDirectDraw

#endif  //  WNT_DDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddsurf.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddsurf.c
*
* Content: DirectDraw surfaces creation/destructions callbacks
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
// This file needs the surface format table
#include "glint.h"
#include "dma.h"

// This enum is used to lookup the correct entry in the table
// for all the surface types the HAL cares about
typedef enum tagDeviceFormatNum
{
    HAL_8888_ALPHA = 0,
    HAL_8888_NOALPHA = 1,
    HAL_5551_ALPHA = 2,
    HAL_5551_NOALPHA = 3,
    HAL_4444 = 4,
    HAL_332 = 10,
    HAL_2321 = 18,
    HAL_CI8 = 28,
    HAL_CI4 = 29,
    HAL_565 = 30,
    HAL_YUV444 = 34,
    HAL_YUV422 = 35,
    HAL_L8 = 36,
    HAL_A8L8 = 37,
    HAL_A4L4 = 38,
    HAL_A8 = 39,
    HAL_MVCA = 40,
    HAL_MVSU = 41,
    HAL_MVSB = 42,
    HAL_UNKNOWN = 255,
} DeviceFormatNum;

static P3_SURF_FORMAT SurfaceFormats[MAX_SURFACE_FORMATS] =
{
    // If there are multiple formats, the one with the alpha is listed first.
    // Format 0 (32 bit 8888)            // Always 3 components for 888(8) textures.            Red     Green   Blue   Alpha       bAlpha, P3RX Filter format
    /* 0 */ {SURF_8888, 32, __GLINT_32BITPIXEL, RGBA_COMPONENTS, LOG_2_32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_8888, "R8G8B8A8" },
    /* 1 */ {SURF_8888, 32, __GLINT_32BITPIXEL, RGBA_COMPONENTS, LOG_2_32, 0xFF0000, 0xFF00, 0xFF, 0x00000000, FALSE, SURF_FILTER_888, SURF_DITHER_8888, "R8G8B8x8" },

    // Format 1 (16 bit 5551)
    /* 2 */ {SURF_5551_FRONT, 16, __GLINT_16BITPIXEL, RGBA_COMPONENTS, LOG_2_16, 0x7C00, 0x03E0, 0x001F, 0x8000, TRUE, SURF_FILTER_5551, SURF_DITHER_5551, "R5G5B5A1" },
    /* 3 */ {SURF_5551_FRONT, 16, __GLINT_16BITPIXEL, RGB_COMPONENTS, LOG_2_16, 0x7C00, 0x03E0, 0x001F, 0x0, FALSE, SURF_FILTER_5551, SURF_DITHER_5551, "R5G5B5x1" },

    // Format 2 (16 bit 4444)
    /* 4 */ {SURF_4444, 16, __GLINT_16BITPIXEL, RGBA_COMPONENTS, LOG_2_16, 0xF00, 0xF0, 0xF, 0xF000, TRUE, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4A4" },
    /* 5 */ {SURF_4444, 16, __GLINT_16BITPIXEL, RGBA_COMPONENTS, LOG_2_16, 0xF00, 0xF0, 0xF, 0xF000, TRUE, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4x4" },

    // Format 3 (16 bit 4444 Front)
    /* 6 */ {SURF_4444_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4A4" },
    /* 7 */ {SURF_4444_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4x4" },

    // Format 4 (16 bit 4444 Back)
    /* 8 */ {SURF_4444_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4A4" },
    /* 9 */ {SURF_4444_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_4444, SURF_DITHER_4444, "R4G4B4x4" },

    // Format 5 (8 bit 332 Front)
    /* 10 */ {SURF_332_FRONT, 8, __GLINT_8BITPIXEL, RGB_COMPONENTS, LOG_2_8, 0xE0, 0x1C, 0x3, 0, FALSE, SURF_FILTER_332, SURF_DITHER_332, "R3G3B2" },
    /* 11 */ {SURF_332_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_332, SURF_DITHER_332, "R3G3B2" },

    // Format 6 (8 bit 332 back)
    /* 12 */ {SURF_332_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_332, SURF_DITHER_332, "R3G3B2" },
    /* 13 */ {SURF_332_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_332, SURF_DITHER_332, "R3G3B2" },
    
    // Format 7 (4 bit 121 front)
    /* 14 */ {SURF_121_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R1G2B1" },
    /* 15 */ {SURF_121_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R1G2B1" },

    // Format 8 (4 bit 121 back)
    /* 16 */ {SURF_121_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R1G2B1" },
    /* 17 */ {SURF_121_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R1G2B1" },

    // Format 9 (8 bit 2321 front)
    /* 18 */ {SURF_2321_FRONT, 8, __GLINT_8BITPIXEL, RGBA_COMPONENTS, LOG_2_8, 0xC0, 0x38, 0x6, 0x1, TRUE, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2A1" },
    /* 19 */ {SURF_2321_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },

    // Format 10 (8 bit 2321 back)
    /* 20 */ {SURF_2321_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2A1" },
    /* 21 */ {SURF_2321_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },

    // Format 11 (8 bit 232 front off)
    /* 22 */ {SURF_232_FRONTOFF, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },
    /* 23 */ {SURF_232_FRONTOFF, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },

    // Format 12 (8 bit 232 back off)
    /* 24 */ {SURF_232_BACKOFF, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },
    /* 25 */ {SURF_232_BACKOFF, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_INVALID, SURF_DITHER_INVALID, "R2G3B2x1" },

    // Format 13 (5551 back)
    /* 26 */ {SURF_5551_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_5551, SURF_DITHER_5551, "R5G5B5A1" },
    /* 27 */ {SURF_5551_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_5551, SURF_DITHER_5551, "R5G5B5x1" },

    // Format 14 (CI8)
    /* 28 */ {SURF_CI8, 8, __GLINT_8BITPIXEL, RGBA_COMPONENTS, LOG_2_8, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_I8, "I8" },
    
    // Format 15 (CI4)
    /* 29 */ {SURF_CI4, 4, __GLINT_4BITPIXEL, RGBA_COMPONENTS, LOG_2_4, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "I4" },
    
    // Format 16 (565 front)
    /* 30 */ {SURF_565_FRONT, 16, __GLINT_16BITPIXEL, RGB_COMPONENTS, LOG_2_16, 0xF800, 0x07E0, 0x001F, 0, FALSE, SURF_FILTER_565, SURF_DITHER_565, "R5G6B5" },
    /* 31 */ {SURF_565_FRONT, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_565, SURF_DITHER_565, "R5G6B5" },

    // Format 17 (565 back)
    /* 32 */ {SURF_565_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_565, SURF_DITHER_565, "R5G6B5" },
    /* 33 */ {SURF_565_BACK, 0, 0, COMPONENTS_DONT_CARE, 0, 0, 0, 0, 0, 0, SURF_FILTER_565, SURF_DITHER_565, "R5G6B5" },

    // Format 18 (YUV 444)
    /* 34 */ {SURF_YUV444, 32, __GLINT_16BITPIXEL, RGBA_COMPONENTS, LOG_2_16, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "YUV444" },
    
    // Format 19 (YUV 422)
    /* 35 */ {SURF_YUV422, 16, __GLINT_16BITPIXEL, RGB_COMPONENTS, LOG_2_32, 0, 0, 0, 0, FALSE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "YUV422" },

    // Format 100 (L8)
    /* 36 */ {SURF_L8, 8, __GLINT_8BITPIXEL, RGB_COMPONENTS, LOG_2_8, 0, 0, 0, 0, FALSE, SURF_FILTER_L8, SURF_DITHER_INVALID, "L8" },

    // Format 101 (A8L8)
    /* 37 */ {SURF_A8L8, 16, __GLINT_16BITPIXEL, RGB_COMPONENTS, LOG_2_16, 0, 0, 0, 0, TRUE, SURF_FILTER_A8L8, SURF_DITHER_INVALID, "A8L8" },

    // Format 102 (A4L4)
    /* 38 */ {SURF_A4L4, 16, __GLINT_8BITPIXEL, RGB_COMPONENTS, LOG_2_8, 0, 0, 0, 0, TRUE, SURF_FILTER_A4L4, SURF_DITHER_INVALID, "A4L4" },

    // Format 103 (A8)
    /* 39 */ {SURF_A8, 8, __GLINT_8BITPIXEL, RGB_COMPONENTS, LOG_2_8, 0, 0, 0, 0, TRUE, SURF_FILTER_A8, SURF_DITHER_INVALID, "A8" },

    // Format 104 (A8) MVCA
    /* 40 */ {SURF_MVCA, 32, __GLINT_32BITPIXEL, RGB_COMPONENTS, LOG_2_32, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "MVCA" },

    // Format 105 (A8) MVSU
    /* 41 */ {SURF_MVSU, 32, __GLINT_32BITPIXEL, RGB_COMPONENTS, LOG_2_32, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "MVSU" },

    // Format 106 (A8) MVSB
    /* 42 */ {SURF_MVSB, 32, __GLINT_32BITPIXEL, RGB_COMPONENTS, LOG_2_32, 0, 0, 0, 0, TRUE, SURF_FILTER_8888_OR_YUV, SURF_DITHER_INVALID, "MVSB" }

};

#define MAKE_DWORD_ALIGNED(n)   ( ((n) % 4) ? ((n) + 4 - ((n) % 4)) : (n) )
#define MAKE_QWORD_ALIGNED(n)   ( ((n) % 8) ? ((n) + 8 - ((n) % 8)) : (n) )

//-----------------------------------------------------------------------------
//
// _DD_SUR_GetSurfaceFormat
//
//-----------------------------------------------------------------------------
P3_SURF_FORMAT* 
_DD_SUR_GetSurfaceFormat(
    LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    DeviceFormatNum HALDeviceFormat = HAL_UNKNOWN; // The default

    if (pLcl)
    {
        DDPIXELFORMAT* pPixFormat = DDSurf_GetPixelFormat(pLcl);
        if (pPixFormat->dwFlags & DDPF_FOURCC)
        {
            switch( pPixFormat->dwFourCC)
            {
            case FOURCC_MVCA:
                HALDeviceFormat = HAL_MVCA;
                break;
                
            case FOURCC_MVSU:
                HALDeviceFormat = HAL_MVSU;
                break;
                
            case FOURCC_MVSB:
                HALDeviceFormat = HAL_MVSB;
                break;
                
            case FOURCC_YUV422:
                HALDeviceFormat = HAL_YUV422;
                break;
                
            case FOURCC_YUV411:
                HALDeviceFormat = HAL_YUV444;
                break;
            } //switch
        }
        else if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED4)
        {
            HALDeviceFormat = HAL_CI4;  
        }
        else if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED8)
        {
            HALDeviceFormat = HAL_CI8;  
        }
        else if (pPixFormat->dwFlags & DDPF_LUMINANCE)
        {
            switch(pPixFormat->dwRGBBitCount)
            {
            case 8:
                if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
                {
                    HALDeviceFormat = HAL_A4L4;
                }
                else
                {
                    HALDeviceFormat = HAL_L8;
                }
                break;
                
            case 16:
                HALDeviceFormat = HAL_A8L8;
                break;
                
            default:
                HALDeviceFormat = HAL_UNKNOWN;
                break;
            } // switch
        }
        else if (pPixFormat->dwFlags & DDPF_ALPHA)
        {
            // Alpha only format
            switch(pPixFormat->dwAlphaBitDepth)
            {
            case 8:
                HALDeviceFormat = HAL_A8;
                break;
                
            default:
                HALDeviceFormat = HAL_UNKNOWN;
                break;
            }
        }
        else
        {
            switch(pPixFormat->dwRGBBitCount)
            {
            case 32:
            case 24:
                if (pPixFormat->dwRGBAlphaBitMask != 0)
                {
                    HALDeviceFormat = HAL_8888_ALPHA;   
                }
                else
                {
                    HALDeviceFormat = HAL_8888_NOALPHA; 
                }
                break;
                
            case 16:
                switch (pPixFormat->dwRBitMask)
                {
                case 0xf00:
                    HALDeviceFormat = HAL_4444;
                    break;
                    
                case 0x7c00:
                    if (pPixFormat->dwRGBAlphaBitMask != 0)
                    {
                        HALDeviceFormat = HAL_5551_ALPHA;
                    }
                    else
                    {
                        HALDeviceFormat = HAL_5551_NOALPHA;
                    }
                    break;
                    
                default:
                    HALDeviceFormat = HAL_565;
                    break;
                    
                }
                break;
                
            case 8:
                if (pPixFormat->dwRBitMask != 0xE0)
                {
                    HALDeviceFormat = HAL_2321;
                }
                else
                {
                    HALDeviceFormat = HAL_332;
                }
                break;
                
            case 0:
                HALDeviceFormat = HAL_CI8;
                break;
            default:
                DISPDBG((ERRLVL,"_DD_SUR_GetSurfaceFormat: "
                            "Invalid Surface Format"));
                break;
            } // switch
        } // if
    }

#if DBG
    if (HALDeviceFormat == HAL_UNKNOWN)
    {
        DISPDBG((ERRLVL,"ERROR: Failed to pick a valid surface format!"));
    }

    if(SurfaceFormats[HALDeviceFormat].dwBitsPerPixel == 0)
    {
        DISPDBG((ERRLVL,"ERROR: Chosen surface format that isn't defined "
                    "in the table!"));
    }
#endif // DBG

    if (HALDeviceFormat == HAL_UNKNOWN)
    {
        // Don't know what it is - return a valid type.
        return &SurfaceFormats[0];
    }
    else
    {
        // Return a pointer to the correct line in the table
        return &SurfaceFormats[HALDeviceFormat];
    }
} // _DD_SUR_GetSurfaceFormat

//---------------------------------------------------------------------------
// BOOL __SUR_bComparePixelFormat
//
// Function used to compare 2 pixels formats for equality. This is a 
// helper function to __SUR_bCheckTextureFormat. A return value of TRUE 
// indicates equality
//
//---------------------------------------------------------------------------
BOOL 
__SUR_bComparePixelFormat(
    LPDDPIXELFORMAT lpddpf1, 
    LPDDPIXELFORMAT lpddpf2)
{
    if (lpddpf1->dwFlags != lpddpf2->dwFlags)
    {
        return FALSE;
    }

    // same bitcount for non-YUV surfaces?
    if (!(lpddpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)))
    {
        if (lpddpf1->dwRGBBitCount != lpddpf2->dwRGBBitCount )
        {
            return FALSE;
        }
    }

    // same RGB properties?
    if (lpddpf1->dwFlags & DDPF_RGB)
    {
        if ((lpddpf1->dwRBitMask != lpddpf2->dwRBitMask) ||
            (lpddpf1->dwGBitMask != lpddpf2->dwGBitMask) ||
            (lpddpf1->dwBBitMask != lpddpf2->dwBBitMask) ||
            (lpddpf1->dwRGBAlphaBitMask != lpddpf2->dwRGBAlphaBitMask))
        { 
             return FALSE;
        }
    }
    
    // same YUV properties?
    if (lpddpf1->dwFlags & DDPF_YUV)	
    {
        if ((lpddpf1->dwFourCC != lpddpf2->dwFourCC) ||
            (lpddpf1->dwYUVBitCount != lpddpf2->dwYUVBitCount) ||
            (lpddpf1->dwYBitMask != lpddpf2->dwYBitMask) ||
            (lpddpf1->dwUBitMask != lpddpf2->dwUBitMask) ||
            (lpddpf1->dwVBitMask != lpddpf2->dwVBitMask) ||
            (lpddpf1->dwYUVAlphaBitMask != lpddpf2->dwYUVAlphaBitMask))
        {
             return FALSE;
        }
    }
    else if (lpddpf1->dwFlags & DDPF_FOURCC)
    {
        if (lpddpf1->dwFourCC != lpddpf2->dwFourCC)
        {
            return FALSE;
        }
    }

    // If Interleaved Z then check Z bit masks are the same
    if (lpddpf1->dwFlags & DDPF_ZPIXELS)
    {
        if (lpddpf1->dwRGBZBitMask != lpddpf2->dwRGBZBitMask)
        {
            return FALSE;
        }
    }

    return TRUE;
} // __SUR_bComparePixelFormat

//---------------------------------------------------------------------------
//
// BOOL __SUR_bCheckTextureFormat
//
// Function used to determine if a texture format is supported. It traverses 
// the deviceTextureFormats list. We use this in DdCanCreateSurface. A
// return value of TRUE indicates that we do support the requested texture 
// format.
//
//---------------------------------------------------------------------------

BOOL 
__SUR_bCheckTextureFormat(
    P3_THUNKEDDATA *pThisDisplay, 
    LPDDPIXELFORMAT lpddpf)
{
    DWORD i;

    // Run the list for a matching format , we already built the list (when
    // the driver was loaded) and stored it in pThisDisplay with 
    // __D3D_BuildTextureFormatsP3 in  _D3DHALCreateDriver (d3d.c)

    // Notice the special handling for paletted textures as described in
    // __D3D_BuildTextureFormatsP3 (thats why we loop until <= , not just
    // until < ).
    
    for (i=0; i <= pThisDisplay->dwNumTextureFormats; i++)
    {
        if (__SUR_bComparePixelFormat(
                    lpddpf, 
                    &pThisDisplay->TextureFormats[i].ddpfPixelFormat))
        {
            return TRUE;
        }   
    }

    return FALSE;
} // __SUR_bCheckTextureFormat

//---------------------------------------------------------------------------
//
// DWORD __SUR_bSurfPlacement
//
// Function used to determine if a surface should be placed at the front or
// at the back of our video memory heap. 
// Returns the MEM3DL_FRONT and MEM3DL_BACK values.
//
//---------------------------------------------------------------------------
DWORD
__SUR_bSurfPlacement(
    LPDDRAWI_DDRAWSURFACE_LCL psurf,
    DDSURFACEDESC *lpDDSurfaceDesc)
{
    static BOOL  bBufferToggle = TRUE;
    DWORD dwResult;
    
    if (psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        DWORD dwTexturePlacement;

        // They might have passed a DDSD2 in a DDSD1 structure.
        if (lpDDSurfaceDesc && (lpDDSurfaceDesc->dwSize == 
            sizeof(DDSURFACEDESC2)))
        {
            DDSURFACEDESC2* pDesc2 = 
                                (DDSURFACEDESC2*)lpDDSurfaceDesc;
            
            // Check for the application hint on texture stage placement
            if (!(pDesc2->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
            {
                if (pDesc2->dwFlags & DDSD_TEXTURESTAGE)
                {
                    dwTexturePlacement = pDesc2->dwTextureStage;

                    // Put it somewhere sensible if it 
                    // is in a large stage number
                    if (dwTexturePlacement > 1)
                    {
                        // Toggle all entries above 1 so that they 
                        // jump between banks.
                        dwTexturePlacement = 
                                        (dwTexturePlacement ^ 1) & 0x1;
                    }
                }
                else
                {
                    // No stage hint.  PingPong
                    dwTexturePlacement = bBufferToggle;
                    bBufferToggle = !bBufferToggle;
                }
            }
            else
            {
                // No stage hint.  PingPong
                dwTexturePlacement = bBufferToggle;
                bBufferToggle = !bBufferToggle;
            }
        }
        else
        {
            // No DDSD2, PingPong
            dwTexturePlacement = bBufferToggle;
            bBufferToggle = !bBufferToggle;
        }

        // Jump up and down in the one heap
        if (dwTexturePlacement == 0)
        {
            dwResult = MEM3DL_FRONT;
        }
        else
        {
            dwResult = MEM3DL_BACK;
        }
    }
    // Not a texture
    else
    {
        dwResult = MEM3DL_FRONT;
    }

    return dwResult;
    
} // __SUR_bSurfPlacement
//-----------------------------Public Routine----------------------------------
//
// DdCanCreateSurface
//
// Indicates whether the driver can create a surface of the specified 
// surface description
//
// DdCanCreateSurface should check the surface description to which 
// lpDDSurfaceDesc points to determine if the driver can support the format and
// capabilities of the requested surface for the mode that the driver is 
// currently in. The driver should return DD_OK in ddRVal if it supports the 
// surface; otherwise, it should return the DDERR_Xxx error code that best 
// describes why it does not support the surface.
//
// The bIsDifferentPixelFormat member is unreliable for z-buffers. Drivers 
// should use bIsDifferentPixelFormat only when they have first checked that 
// the specified surface is not a z-buffer. Drivers can perform this check by
// determining whether the DDSCAPS_ZBUFFER flag is set in lpDDSurfaceDesc
// ddsCaps.dwCaps.
//
// Parameters
//
//      pccsd
//          Points to the DD_CANCREATESURFACEDATA structure containing the 
//          information required for the driver to determine whether a surface 
//          can be created. 
//  
//          .lpDD 
//               Points to the DD_DIRECTDRAW_GLOBAL structure representing the
//               DirectDraw object. 
//          .lpDDSurfaceDesc 
//               Points to a DDSURFACEDESC structure that contains a 
//               description of the surface to be created. 
//          .bIsDifferentPixelFormat 
//               Indicates whether the pixel format of the surface to be 
//               created differs from the primary surface. 
//          .ddRVal 
//               Specifies the location in which the driver writes the return 
//               value of the DdCanCreateSurface callback. A return code of 
//               DD_OK indicates success. 
//          .CanCreateSurface 
//               This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdCanCreateSurface( 
    LPDDHAL_CANCREATESURFACEDATA pccsd )
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(DdCanCreateSurface);
    
    GET_THUNKEDDATA(pThisDisplay, pccsd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    // ************************* Z BUFFERS *******************************
    // We support 15,16,24 and 32 bits Z-buffers 
    // (wo accounting for stencil bits) on PERMEDIA3
    if ((pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_ZBUFFER) &&
        (pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {  
        DWORD dwZBitDepth;

        // Check out the case of a z buffer with a pixel format

        // Complex surfaces aren't allowed to have stencil bits.  In 
        // this case we take the pixel z depth from the old place - the 
        // surface desc.
        if ((pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_COMPLEX) ||
            (pccsd->lpDDSurfaceDesc->dwFlags & DDSD_ZBUFFERBITDEPTH) )
        {
            dwZBitDepth = pccsd->lpDDSurfaceDesc->dwZBufferBitDepth;
        }
        else
        {
            // On DX 6 the Z Bit depth is stored in the Pixel Format.
            dwZBitDepth = 
                pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwZBufferBitDepth;
        }

        // Notice we have to check for a dwZBitDepth of 16 or 32 even if a 
        // stencil buffer is present. dwZBufferBitDepth in this case will be 
        // the sum of the z buffer and the stencil buffer bit depth.
        if ((dwZBitDepth == 16) || (dwZBitDepth == 32))
        {
            pccsd->ddRVal = DD_OK;
        }
        else
        {
            DISPDBG((WRNLVL,"DdCanCreateSurface ERROR: "
                            "Depth buffer not 16 or 32 Bits! (%d)", 
                            dwZBitDepth));

            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        }
        
        DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
        return DDHAL_DRIVER_HANDLED;    
    }

    // *********************** 3D RENDER TARGETS ***************************
    if (pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_3DDEVICE)
    {
        // We are going to use this surface as a rendering target

        // Notice that this will also cover the case when we're
        // trying to create a vidmem texture that will also be used
        // as a rendertarget (as we go thorugh this path before 
        // DDSCAPS_TEXTURE-cap surfaces are processed)
        if (!pccsd->bIsDifferentPixelFormat)        
        {
            // we have the same format as the primary . If this is true,
            // on DX7 we won't have the ddpfPixelFormat fielded at all.
            // But we do support rendertargets and textures of the same
            // format as our possible primaries so we return DD_OK
            DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                             "Same as primary format for "
                             "rendertarget surface" ));
            pccsd->ddRVal = DD_OK;            
        }
        else if( pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB )
        {
            DDPIXELFORMAT *pPixFmt = 
                        &pccsd->lpDDSurfaceDesc->ddpfPixelFormat;
        
             // Only 32 and 16 (565) RGB modes allowed.
            switch (pPixFmt->dwRGBBitCount)
            {
            case 32:
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "32-bit RGB format for "
                                 "rendertarget surface" ));
                pccsd->ddRVal = DD_OK;
                break;
                
            case 16:
                if ((pPixFmt->dwRBitMask == 0xF800) &&
                    (pPixFmt->dwGBitMask == 0x07E0) &&        
                    (pPixFmt->dwBBitMask == 0x001F))
                {                                
                    DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                     "16-bit 565 RGB format for "
                                     "rendertarget surface" ));
                    pccsd->ddRVal = DD_OK;
                }
                else
                {
                    DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                     "NOT 16-bit 565 RGB format for "
                                     "16BPP rendertarget surface" ));             
                    pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                }
                break;                            
                
            default:
                DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                 "RGB rendertarget not 16 (565) "
                                 "or 32 bit - wrong pixel format" ));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;           
                break;
            }            
        }
        else
        {
            DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                             "Rendertarget not an RGB Surface"
                             " - wrong pixel format" ));
            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        }
        
        DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
        return DDHAL_DRIVER_HANDLED;                            
    }

    // *************************** TEXTURES **************************
    if(pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        // Notice that the case when we're trying to create a vidmem 
        // texture that will also be used as a rendertarget has already
        // been taken care of when processing the 3D rendertargets case
        // as their valid formats are a subset of the valid texture formats

        if (!pccsd->bIsDifferentPixelFormat)        
        {
            // we have the same format as the primary . If this is true,
            // on DX7 we won't have the ddpfPixelFormat fielded at all.
            // but all primary formats are valid for this driver as
            // texture formats as well, so succeed this call
            DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                             "Same as primary format for "
                             "texture surface" ));
            pccsd->ddRVal = DD_OK;            
        }    
        // if the surface is going to be a texture verify it matches one
        // of the supported texture formats (already stored in pThisDisplay)
        else if (__SUR_bCheckTextureFormat(
                                pThisDisplay,
                                &pccsd->lpDDSurfaceDesc->ddpfPixelFormat))
        {
            // texture surface is in one or our supported texture formats           
            DISPDBG((DBGLVL, "  Texture Surface - OK" ));
            pccsd->ddRVal = DD_OK;
        }
        else
        {
            // we don't support this kind of texture format
            DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                             "Texture Surface format not supported" ));
            pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        }
        
        DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
        return DDHAL_DRIVER_HANDLED;
        
    }        

    // ***********************************************************************
    // * OTHER OFFSCREEN SURFACES THAT ARE DIFFERENT FROM THE PRIMARY FORMAT *
    // ***********************************************************************
    if (pccsd->bIsDifferentPixelFormat)
    {
        DISPDBG((DBGLVL,"Pixel Format is different to primary"));
        if(pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
        {
            DISPDBG((DBGLVL, "    FourCC requested (%4.4hs, 0x%08lx)", 
                     (LPSTR) &pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC,
                        pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ));

            switch (pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC)
            {
            case FOURCC_YUV422:
                DISPDBG((WRNLVL,"DdCanCreateSurface OK: "
                                "Surface requested is YUV422"));
                pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                pccsd->ddRVal = DD_OK;
                break;
                
                // Disabled for now.
            case FOURCC_YUV411:
                DISPDBG((WRNLVL,"DdCanCreateSurface ERROR: "
                                "Surface requested is YUV411 - Disabled"));
                pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 32;
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                break;
                
            default:
                DISPDBG((WRNLVL,"DdCanCreateSurface ERROR: "
                                "Invalid FOURCC requested, refusing"));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                break;
            }

            DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);            
            return DDHAL_DRIVER_HANDLED;
        }
//@@BEGIN_DDKSPLIT        
        // azn check if the following variations are now still needed
//@@END_DDKSPLIT        
        // Luminance texture support
        else if( (pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags 
                                                        & DDPF_LUMINANCE) &&
                 !(pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY) )
        {
            DDPIXELFORMAT *pddpfCur;
            // Only 16 and 8-bit modes allowed.
            pddpfCur = &(pccsd->lpDDSurfaceDesc->ddpfPixelFormat);

            if (pddpfCur->dwLuminanceBitCount == 8) 
            {
                // Check for L8
                if (!(pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & 
                                                            DDPF_ALPHAPIXELS))
                {
                    DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                     " 8 Bit Luminance surface"));
                    pccsd->ddRVal = DD_OK;
                }
                // Must be A4:L4
                else
                {
                    DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                     "4 Bit Luma + 4 Bit Alpha surface"));
                    pccsd->ddRVal = DD_OK;
                }
            }
            // Check for A8L8
            else if (pddpfCur->dwLuminanceBitCount == 16) 
            {
                if (pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & 
                                                            DDPF_ALPHAPIXELS)
                {
                    DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                     " 16 Bit Luminance + Alpha Surface"));
                    pccsd->ddRVal = DD_OK;
                }
                else
                {
                    DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                     "Bad A8L8 format" ));                 
                    pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
                }
                
            }
            else
            {
                DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                 "Unknown luminance texture" ));              
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
            }

            DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
            return DDHAL_DRIVER_HANDLED;
        }
        else if( (pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & 
                                                                DDPF_ALPHA) &&
                 !(pccsd->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
            DDPIXELFORMAT *pddpfCur;
            pddpfCur = &(pccsd->lpDDSurfaceDesc->ddpfPixelFormat);

            if (pddpfCur->dwAlphaBitDepth == 8)
            {
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "8 Bit Alpha surface"));
                pccsd->ddRVal = DD_OK;
            }
            else
            {
                DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                 "pddpfCur->dwAlphaBitDepth != 8" ));             
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
            }

            DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
            return DDHAL_DRIVER_HANDLED;
        }
        else if( pccsd->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB )
        {
            DDPIXELFORMAT *pddpfCur;
            // Only 32, 16 and 8-bit modes allowed.
            pddpfCur = &(pccsd->lpDDSurfaceDesc->ddpfPixelFormat);
            switch ( pddpfCur->dwRGBBitCount )
            {
            case 32:
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "RGB 32-bit surface" ));
                pccsd->ddRVal = DD_OK;
                break;
                
            case 16:
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "RGB 16-bit surface" ));
                pccsd->ddRVal = DD_OK;
                break;
                
            case 8:
                DISPDBG((DBGLVL, "DdCanCreateSurface OK: "
                                 "RGB 8-bit Surface" ));
                pccsd->ddRVal = DD_OK;
                break;
                               
            default:
                DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                                 "RGB Surface - wrong pixel format" ));
                pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;           
                break;
            }
            
            DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
            return DDHAL_DRIVER_HANDLED;
        }

        // Since its a different from the primary surface and doesn't fall
        // into any of the previous cases, we fail it
        DISPDBG((WRNLVL, "DdCanCreateSurface ERROR: "
                         "Different from the primary surface but unknown" ));        
        pccsd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
        return DDHAL_DRIVER_HANDLED;
    }

    // Same format as the primary, we succeed it anyway
    DISPDBG((DBGLVL, "DdCanCreateSurface OK: (Def) Same format as primary" ));
    pccsd->ddRVal = DD_OK;
    DBG_CB_EXIT(DdCanCreateSurface, pccsd->ddRVal);
    return DDHAL_DRIVER_HANDLED;

} // DdCanCreateSurface 

//-----------------------------Public Routine----------------------------------
//
// DdCreateSurface
//
// Creates a DirectDraw surface.
//
// The driver can allocate the surface memory itself or can request that 
// DirectDraw perform the memory management. If the driver performs the 
//allocation, it must do the following: 
//
// Perform the allocation and write a valid pointer to the memory in the 
// fpVidMem member of the DD_SURFACE_GLOBAL structure. 
// If the surface has a FourCC format, write the pitch in the lPitch member of 
// the DD_SURFACE_GLOBAL and DDSURFACEDESC structures, and update the flags 
// accordingly. 
//
// Otherwise, the driver can have DirectDraw allocate the surface by returning 
// one of the following values in fpVidMem: 
//
//      DDHAL_PLEASEALLOC_BLOCKSIZE requests that DirectDraw allocate the 
//                                  surface memory from offscreen memory. 
//      DDHAL_PLEASEALLOC_USERMEM   requests that DirectDraw allocate the 
//                                  surface memory from user memory. The 
//                                  driver must also return the size in 
//                                  bytes of the memory region in dwUserMemSize.
//
// For DirectDraw to perform the allocation of a surface with a FourCC format,
// the driver must also return the pitch and x- and y-block sizes in lPitch, 
// dwBlockSizeX, and dwBlockSizeY, respectively. The pitch must be returned in 
// the lPitch member of both the DD_SURFACE_GLOBAL and DDSURFACEDESC structures. 
// For linear memory, the driver should set dwBlockSizeX to be the size in bytes
// of the memory region and set dwBlockSizeY to 1. 
//
// By default, the driver is not notified when a primary surface is created on 
// Windows 2000. However, if the driver supports GUID_NTPrivateDriverCaps and 
// the DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION flag is set, then the driver will 
// be notified.
//
// Parameters
//
//      pcsd 
//          Points to a DD_CREATESURFACEDATA structure that contains the 
//          information required to create a surface. 
//
//          .lpDD 
//              Points to the DD_DIRECTDRAW_GLOBAL structure representing the 
//              driver. 
//          .lpDDSurfaceDesc 
//              Points to the DDSURFACEDESC structure describing the surface 
//              that the driver should create. 
//          .lplpSList 
//              Points to a list of DD_SURFACE_LOCAL structures describing 
//              the surface objects created by the driver. On Windows 2000, 
//              there is usually only one entry in this array. However, if 
//              the driver supports the Windows 95/98-style surface creation 
//              techniques using DdGetDriverInfo with GUID_NTPrivateDriverCaps,
//              and the driver sets the DDHAL_PRIVATECAP_ATOMICSURFACECREATION 
//              flag, the member will contain a list of surfaces (usually more 
//              than one). 
//          .dwSCnt 
//              Specifies the number of surfaces in the list to which lplpSList
//              points. This value is usually 1 on Windows 2000. However, if 
//              you support the Windows 95/Windows98-style surface creation 
//              techniques using DdGetDriverInfo with GUID_NTPrivateDriverCaps, 
//              the member will contain the actual number of surfaces in the 
//              list (usually more than one). 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdCreateSurface callback. A return code of DD_OK 
//              indicates success. 
//          .CreateSurface 
//              This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdCreateSurface( 
    LPDDHAL_CREATESURFACEDATA pcsd )
{
    int                         i;
    DWORD                       BitDepth;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;
    LPDDRAWI_DDRAWSURFACE_MORE  psurf_more;
    BOOL                        bHandled = TRUE;
    BOOL                        bResize = FALSE;
    P3_THUNKEDDATA*             pThisDisplay;
    DWORD                       dwExtraBytes;

    DBG_CB_ENTRY(DdCreateSurface);
    
    GET_THUNKEDDATA(pThisDisplay, pcsd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);
    STOP_SOFTWARE_CURSOR(pThisDisplay);
    DDRAW_OPERATION(pContext, pThisDisplay); 

    for( i=0; i<(int)pcsd->dwSCnt; i++ )
    {
        DDPIXELFORMAT* pPixFormat = NULL;
        psurf = pcsd->lplpSList[i];
        psurf_gbl = psurf->lpGbl;
        psurf_more = psurf->lpSurfMore;

        // Dump debug info about the surface to be created
        DISPDBG((DBGLVL, "\nLooking at Surface %d of %d", i + 1, pcsd->dwSCnt));
        DISPDBG((DBGLVL,"Surf dimensions: %d x %d", psurf_gbl->wWidth, 
                        psurf_gbl->wHeight ));          
        DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, psurf);     

        DISPDBG((DBGLVL, "DdCreateSurface setting NULL"));
        psurf_gbl->fpVidMem = 0;
                    
        // Get the bitdepth of the surface
        BitDepth = DDSurf_BitDepth(psurf);

        // All Z buffers need adjusting, and setting the correct bit depth
        if (DDSurf_HasPixelFormat(psurf->dwFlags))
        { 
            if (psurf_gbl->ddpfSurface.dwFlags & DDPF_ZBUFFER)
            {
                DISPDBG((DBGLVL,"Surface is Z Buffer"));
                BitDepth = psurf_gbl->ddpfSurface.dwZBufferBitDepth;

                // Force the pitch to the correct value - the DX runtime
                // sometimes sends us a duff value.

                psurf_gbl->lPitch = psurf_gbl->wWidth << ( BitDepth >> 4 );

                // Ddraw surfaces in IA64 have to be DWORD aligned in their
                // pitch in order for emulation code to work correctly
                // And on X86 we declared surfaces will be DWORD aligned in 
                // DrvGetDirectDrawInfo (vmiData.dwXXXXXAlign = 4)
                psurf_gbl->lPitch = MAKE_DWORD_ALIGNED(psurf_gbl->lPitch);
            }
        }

        // Determine if we need to resize the surface to make it fit.
        bResize = FALSE;

        // The surface is a YUV format surface
        if (DDSurf_HasPixelFormat(psurf->dwFlags))
        {
            if (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC)
            {
                bResize = TRUE;
                switch( psurf_gbl->ddpfSurface.dwFourCC )
                {
                    case FOURCC_YUV422:
                        DISPDBG((DBGLVL,"Surface is YUV422"));
                        psurf_gbl->ddpfSurface.dwYUVBitCount = 16;
                        BitDepth = 16;
                        break;
                        
                    case FOURCC_YUV411:
                        DISPDBG((DBGLVL,"Surface is YUV411"));
                        psurf_gbl->ddpfSurface.dwYUVBitCount = 32;
                        BitDepth = 32;
                        break;
                        
                    default:
                        // We should never get here, as CanCreateSurface will
                        // validate the YUV format for us.
                        DISPDBG((ERRLVL,"Trying to create an invalid YUV surface!"));
                        break;
                }
            }
        }

        DISPDBG((DBGLVL,"Surface Pitch is: 0x%x",  psurf_gbl->lPitch));

        // This flag is set if the surface needs resizing.  
        if (bResize)
        {
            DWORD dwNewWidth = psurf_gbl->wWidth;
            DWORD dwNewHeight = psurf_gbl->wHeight;
            DWORD dwHeightAlignment = 1;
            DWORD dwWidthAlignment = 1;

            DISPDBG((DBGLVL, "Resizing surface"));

            while ((dwNewWidth % dwWidthAlignment) != 0) dwNewWidth++;
            while ((dwNewHeight % dwHeightAlignment) != 0) dwNewHeight++;

            DISPDBG((DBGLVL,"Surface original = %d x %d, Surface new = %d x %d",
                            psurf_gbl->wWidth, psurf_gbl->wHeight, 
                            dwNewWidth, dwNewHeight));

            psurf_gbl->fpVidMem = (FLATPTR) DDHAL_PLEASEALLOC_BLOCKSIZE;
            psurf_gbl->lPitch = (DWORD)(dwNewWidth * (BitDepth / 8));

            // Ddraw surfaces in IA64 have to be DWORD aligned in their
            // pitch in order for emulation code to work correctly
            // And on X86 we declared surfaces will be DWORD aligned in 
            // DrvGetDirectDrawInfo (vmiData.dwXXXXXAlign = 4)
            psurf_gbl->lPitch = MAKE_DWORD_ALIGNED(psurf_gbl->lPitch);          
            
            psurf_gbl->dwBlockSizeX = (DWORD)((DWORD)dwNewHeight * 
                                                    (DWORD)psurf_gbl->lPitch );
            psurf_gbl->dwBlockSizeY = 1;
        }
        else
        {
            psurf_gbl->lPitch = (DWORD)(psurf_gbl->wWidth * (BitDepth / 8));
            
            // Ddraw surfaces in IA64 have to be DWORD aligned in their
            // pitch in order for emulation code to work correctly
            // And on X86 we declared surfaces will be DWORD aligned in 
            // DrvGetDirectDrawInfo (vmiData.dwXXXXXAlign = 4)
            psurf_gbl->lPitch = MAKE_DWORD_ALIGNED(psurf_gbl->lPitch);          
            
#if DX8_3DTEXTURES
            if (psurf_more->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                // Put slice pitch into dwBlockSizeY.
                psurf_gbl->dwBlockSizeY = psurf_gbl->lPitch * 
                                                            psurf_gbl->wHeight;
            }
#endif // DX8_3DTEXTURES
        }

#if DX7_TEXMANAGEMENT

        // If this is going to be a driver managed texture we'll request DX to 
        // allocate it in a private area in system user memory for us.
        if (psurf_more->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {    
            pcsd->lpDDSurfaceDesc->lPitch   = psurf_gbl->lPitch;
            pcsd->lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
        
            if (pcsd->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
            {
                pcsd->lpDDSurfaceDesc->lPitch = 
                psurf_gbl->lPitch             =
                           ((pcsd->lpDDSurfaceDesc->ddpfPixelFormat.dwRGBBitCount*
                             psurf_gbl->wWidth+31)/32)*4;  //make it DWORD aligned

                // Ddraw surfaces in IA64 have to be DWORD aligned in their
                // pitch in order for emulation code to work correctly
                // And on X86 we declared surfaces will be DWORD aligned in 
                // DrvGetDirectDrawInfo (vmiData.dwXXXXXAlign = 4)
                pcsd->lpDDSurfaceDesc->lPitch = 
                psurf_gbl->lPitch = MAKE_DWORD_ALIGNED(psurf_gbl->lPitch);
            }
    
#if WNT_DDRAW
            psurf_gbl->dwUserMemSize = psurf_gbl->lPitch *
                                            (DWORD)(psurf_gbl->wHeight);
                                            
            psurf_gbl->fpVidMem = DDHAL_PLEASEALLOC_USERMEM;
            
            pcsd->ddRVal = DD_OK;
            DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);          
            return DDHAL_DRIVER_NOTHANDLED;        
#else
            // Assume all the memory allocation will succeed
            if (i == 0) 
            {
                bHandled = TRUE;
            }
            
            psurf_gbl->fpVidMem = (FLATPTR)HEAP_ALLOC(FL_ZERO_MEMORY,
                                                      psurf_gbl->lPitch*psurf_gbl->wHeight,
                                                      ALLOC_TAG_DX(M));
            if (psurf_gbl->fpVidMem)
            {
                // Move on to the next MIP level, skip calling VRAM allocator
                continue; 
            }
            else
            {
                pcsd->ddRVal = DDERR_OUTOFMEMORY;
    
                DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);
                return DDHAL_DRIVER_HANDLED;
            }
#endif
        }

#endif // DX7_TEXMANAGEMENT
    

        // If its not to be created in AGP memory and its not the primary
        // then we allocate the memory using our videomemory allocator
        if ((!(psurf->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)) &&
            (!(psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)))
        {
            P3_MEMREQUEST mmrq;
            DWORD dwResult;
            memset(&mmrq, 0, sizeof(P3_MEMREQUEST));
            mmrq.dwSize = sizeof(P3_MEMREQUEST);

            // Compute what size should be requested for the surface allocation
#if DX8_3DTEXTURES
            if (psurf_more->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                if (bResize)
                {
                    DISPDBG((ERRLVL,"No volume with block size alloc"));
                }
                else
                {
                    // the depth of volume texture is given in
                    // ddsCapsEx.dwCaps4.
                    mmrq.dwBytes = (DWORD)psurf_gbl->lPitch *
                                   (DWORD)psurf_gbl->wHeight *
                                   (DWORD)psurf_more->ddsCapsEx.dwCaps4;
                }
            }
            else
#endif // DX8_3DTEXTURES            
            {
                if (bResize)
                {
                    mmrq.dwBytes = psurf_gbl->dwBlockSizeX * 
                                                    psurf_gbl->dwBlockSizeY;
                }
                else
                {
                    mmrq.dwBytes = (DWORD)psurf_gbl->lPitch * 
                                                    (DWORD)psurf_gbl->wHeight;
                }
            }

            // 16 Byte alignment will work for everything
            mmrq.dwAlign = 16;  

            // Figure out where in the video mem to place it
            mmrq.dwFlags = MEM3DL_FIRST_FIT;
           
            if(__SUR_bSurfPlacement(psurf, 
                                    pcsd->lpDDSurfaceDesc) == MEM3DL_FRONT)
            {
                mmrq.dwFlags |= MEM3DL_FRONT;
            }
            else
            {
                mmrq.dwFlags |= MEM3DL_BACK;            
            }

            DISPDBG((DBGLVL,"DdCreateSurface allocating vidmem for handle #%d",
                            psurf->lpSurfMore->dwSurfaceHandle));     
                        
            // Try allocating it in our video memory
            dwResult = _DX_LIN_AllocateLinearMemory(
                                    &pThisDisplay->LocalVideoHeap0Info, 
                                    &mmrq);

            // Did we got the memory we asked for?
            if (dwResult != GLDD_SUCCESS)
            {
                // If we have an AGP heap and it is a texture request,
                // don't give up - ask DDRAW to allocate it for us.
                if ((pThisDisplay->bCanAGP) &&
                    ((psurf->ddsCaps.dwCaps & DDSCAPS_TEXTURE       ) ||
                     (psurf->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)   ))
                {
                    DISPDBG((WRNLVL,"No texture VideoMemory left, "
                                    "going for AGP"));
                                    
                    psurf->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
                    psurf->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
                    
                }
                else
                {
                    psurf_gbl->fpVidMem = 0;
                    DISPDBG((ERRLVL, "DdCreateSurface: failed, "
                                     "returning NULL"));
                    pcsd->ddRVal = DDERR_OUTOFVIDEOMEMORY;

                    START_SOFTWARE_CURSOR(pThisDisplay);

                    DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);
                    return DDHAL_DRIVER_HANDLED;
                }
            }
            else
            {
                // We succeeded. Now update the fpVidMem of the surface
                
                psurf_gbl->fpVidMem = mmrq.pMem;
            }
        }

#if WNT_DDRAW
        // NT requires us to set some things up differently
        pcsd->lpDDSurfaceDesc->lPitch = psurf_gbl->lPitch;
        pcsd->lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
#endif

        // Mark the surface with the correct video memory type
        if (psurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) 
        {
            DISPDBG((DBGLVL,"Surface is in AGP memory"));
            
            ASSERTDD(pThisDisplay->bCanAGP, 
                     "** DdCreateSurface: Somehow managed to create an AGP "
                     "texture when AGP disabled" );
                     
            psurf->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
            psurf->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
            
            // let DDraw manage AGP memory (return DDHAL_DRIVER_NOTHANDLED)
            // THIS IS ABSOLUTELY NECESSARY IF WE WANT DDRAW TO ALLOCTE THIS!
            bHandled = FALSE;         
        }
        else
        {
            DISPDBG((DBGLVL,"Surface in Local Video Memory"));
            psurf->ddsCaps.dwCaps &= ~DDSCAPS_NONLOCALVIDMEM;
            psurf->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
        }

        DISPDBG((DBGLVL, "DdCreateSurface: Surface=0x%08x, vidMem=0x%08x", 
                         psurf, psurf_gbl->fpVidMem));
    } // for i

    START_SOFTWARE_CURSOR(pThisDisplay);

    //
    // If we allocated the memory successfully then we return OK and 
    // say that we handled it. Otherwise we should return DDHAL_DRIVER_NOTHANDLED
    //
    if(bHandled)
    {
        pcsd->ddRVal = DD_OK;
        DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);        
        return DDHAL_DRIVER_HANDLED;
    }
    else
    {
        // if we return handled, then it is assumed that we did SOMETHING
        // with the surface structures to indicate either what size of block
        // or a new pitch or some modification; or we are returning an error.
        DBG_CB_EXIT(DdCreateSurface, pcsd->ddRVal);   
        return DDHAL_DRIVER_NOTHANDLED;
    }

} // DdCreateSurface 

//-----------------------------Public Routine----------------------------------
//
// DdDestroySurface
//
// Destroys a DirectDraw surface.
//
// If DirectDraw did the memory allocation at surface creation time, 
// DdDestroySurface should return DDHAL_DRIVER_NOTHANDLED.
//
// If the driver is performing the surface memory management itself, 
// DdDestroySurface should free the surface memory and perform any other 
// cleanup, such as freeing private data stored in the dwReserved1 members 
// of the DD_SURFACE_GLOBAL and DD_SURFACE_LOCAL structures.
//
// Parameters
//
//      psdd 
//          Points to a DD_DESTROYSURFACEDATA structure that contains the 
//          information needed to destroy a surface. 
//
//          .lpDD 
//              Points to the DD_DIRECTDRAW_GLOBAL structure that describes 
//              the driver. 
//          .lpDDSurface 
//              Points to the DD_SURFACE_LOCAL structure representing the 
//              surface object to be destroyed. 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdDestroySurface callback. A return code of 
//              DD_OK indicates success. 
//          .DestroySurface 
//              This is unused on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdDestroySurface( 
    LPDDHAL_DESTROYSURFACEDATA psdd )
{
    P3_THUNKEDDATA* pThisDisplay; 

    DBG_CB_ENTRY(DdDestroySurface);

    GET_THUNKEDDATA(pThisDisplay, psdd->lpDD);

    // make sure the DMA buffer is flushed and 
    // complete before we destroy any surface
    STOP_SOFTWARE_CURSOR(pThisDisplay);

    {
    P3_DMA_DEFS();   
    DDRAW_OPERATION(pContext, pThisDisplay);
    P3_DMA_GET_BUFFER();
    P3_DMA_FLUSH_BUFFER();
    WAIT_DMA_COMPLETE;
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    DISPDBG((DBGLVL,"DdDestroySurface handle # %d",
                    psdd->lpDDSurface->lpSurfMore->dwSurfaceHandle));
    
    // If we are destroying a videomemory surface which isn't the primary,
    // we'll need to free ourselves the memory as the driver is managing
    // its own local video memory (though non-local/AGP memory is being
    // managed by DirectDraw)
    if ((!(psdd->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)) &&
        (!(psdd->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)))
    {
#if DX7_TEXMANAGEMENT
        // If this is a driver managed texture surface, we need to make sure 
        // it is deallocated from video memory before proceeding.
        if (psdd->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                            DDSCAPS2_TEXTUREMANAGE)
        {
            if (psdd->lpDDSurface->dwFlags & DDRAWISURF_INVALID)
            {
                // This is not a surface destruction, 
                // but a managed surface eviction
#if W95_DDRAW
                // On Win2k, managed textures are evicted from video memory by
                // _DD_TM_EvictAllManagedTextures() when mode change happens.
                _D3D_TM_RemoveDDSurface(pThisDisplay, psdd->lpDDSurface);
#endif
                psdd->ddRVal=  DD_OK;
                DBG_CB_EXIT(DdDestroySurface, psdd->ddRVal);
                return DDHAL_DRIVER_HANDLED;
            }
            else
            {
                // Normal destruction of managed surface               
                _D3D_TM_RemoveDDSurface(pThisDisplay, psdd->lpDDSurface); 
#if W95_DDRAW
                // On Win2k, runtime will free the system memory for drivers.
                if (psdd->lpDDSurface->lpGbl->fpVidMem)
                {
                    HEAP_FREE((LPVOID)psdd->lpDDSurface->lpGbl->fpVidMem);
                }
#endif
            }
        }
        else
#endif
        {
            // Have no memory to free in error recovery case
            if (psdd->lpDDSurface->lpGbl->fpVidMem)
            {
                _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                                         (DWORD)(psdd->lpDDSurface->lpGbl->fpVidMem));
            }
        }
        
        // Must reset the surface pointer to NULL
        DISPDBG((DBGLVL, "DdDestroySurface: setting ptr to NULL"));
        psdd->lpDDSurface->lpGbl->fpVidMem = 0;

        psdd->lpDDSurface->lpGbl->dwReserved1 = 0;

        psdd->ddRVal = DD_OK;
        DBG_CB_EXIT(DdDestroySurface, psdd->ddRVal);
        return DDHAL_DRIVER_HANDLED;

    }
    else
    {
        DISPDBG((WRNLVL, "DdDestroySurface: **NOT** setting ptr to NULL"));

        psdd->lpDDSurface->lpGbl->dwReserved1 = 0;

        psdd->ddRVal = DD_OK;
        DBG_CB_EXIT(DdDestroySurface, psdd->ddRVal);        
        return DDHAL_DRIVER_NOTHANDLED;
    }
} // DdDestroySurface 

//-----------------------------Public Routine----------------------------------
//
// DdSetColorKey
//
// Sets the color key value for the specified surface. 
//
// DdSetColorKey sets the source or destination color key for the specified 
// surface. Typically, this callback is implemented only for drivers that 
// support overlays with color key capabilities.
//
// Parameters
//
//      psckd
//          Points to a DD_SETCOLORKEYDATA structure that contains the 
//          information required to set the color key for the specified surface.
//
//          .lpDD 
//              Points to the DD_DIRECTDRAW_GLOBAL structure that describes 
//              the driver. 
//          .lpDDSurface 
//              Points to the DD_SURFACE_LOCAL structure that describes the 
//              surface with which the color key is to be associated. 
//          .dwFlags 
//              Specifies which color key is being requested. This member is 
//              a bit-wise OR of any of the following values: 
//
//              DDCKEY_COLORSPACE 
//                      The DDCOLORKEY structure contains a color space. If 
//                      this bit is not set, the structure contains a single 
//                      color key. 
//              DDCKEY_DESTBLT 
//                      The DDCOLORKEY structure specifies a color key or color
//                      space to be used as a destination color key for blit 
//                      operations. 
//              DDCKEY_DESTOVERLAY 
//                      The DDCOLORKEY structure specifies a color key or color
//                      space to be used as a destination color key for overlay 
//                      operations. 
//              DDCKEY_SRCBLT 
//                      The DDCOLORKEY structure specifies a color key or color 
//                      space to be used as a source color key for blit 
//                      operations. 
//              DDCKEY_SRCOVERLAY 
//                      The DDCOLORKEY structure specifies a color key or color 
//                      space to be used as a source color key for overlay 
//                      operations. 
//          .ckNew 
//              Specifies a DDCOLORKEY structure that specifies the new color 
//              key values for the DirectDrawSurface object. 
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdSetColorKey callback. A return code of DD_OK 
//              indicates success. 
//          .SetColorKey 
//              This is not used on Windows 2000. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSetColorKey(
    LPDDHAL_SETCOLORKEYDATA psckd)
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(DdSetColorKey);
    
    GET_THUNKEDDATA(pThisDisplay, psckd->lpDD);
    
//@@BEGIN_DDKSPLIT
#if 0
    // Also, see if this colour key is the one used by the overlay.
    // Yes, we should check that various surfaces agree and so on,
    // but can we assume apps are not going to set these flags if there is
    // no overlay active/appropriate?
    if ( psckd->dwFlags & DDCKEY_DESTOVERLAY )
    {
        pThisDisplay->OverlayDstColourKey = psckd->ckNew.dwColorSpaceLowValue;
    }
#endif
//@@END_DDKSPLIT


    // We have to keep track of colorkey changes for D3D videomemory textures
    // associated with (some) D3D context. We don't know however from this call
    // which D3D context this is so we have to do a search through them (if
    // there are any at all)
    if ((DDSCAPS_TEXTURE & psckd->lpDDSurface->ddsCaps.dwCaps) &&
        (DDSCAPS_VIDEOMEMORY & psckd->lpDDSurface->ddsCaps.dwCaps) &&
        (pThisDisplay->pDirectDrawLocalsHashTable != NULL))
    {
        DWORD dwSurfaceHandle = psckd->lpDDSurface->lpSurfMore->dwSurfaceHandle;
        PointerArray* pSurfaceArray;

        // For now we'll assume failure unless proven otherwise
        psckd->ddRVal = DDERR_INVALIDPARAMS;
        
        // Get a pointer to an array of surface pointers associated to this lpDD
        // The PDD_DIRECTDRAW_LOCAL was stored at D3DCreateSurfaceEx call time
        // in PDD_SURFACE_LOCAL->dwReserved1 
        pSurfaceArray = (PointerArray*)
                            HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                                        psckd->lpDDSurface->dwReserved1);

        if (pSurfaceArray)
        {
            // Found a surface array associated to this lpDD !
            P3_SURF_INTERNAL* pSurfInternal;

            // Check the surface in this array associated to this surface handle
            pSurfInternal = PA_GetEntry(pSurfaceArray, dwSurfaceHandle);

            if (pSurfInternal)
            {
                // Got it! Now update the color key setting(s)
                pSurfInternal->dwFlagsInt |= DDRAWISURF_HASCKEYSRCBLT;
                pSurfInternal->dwCKLow = psckd->ckNew.dwColorSpaceLowValue;
                pSurfInternal->dwCKHigh = psckd->ckNew.dwColorSpaceHighValue;     

                // Report success!
                psckd->ddRVal = DD_OK;
            }
        }                                        
    } 
    else    
    {   
        // No D3D colorkey tracking necessary
        psckd->ddRVal = DD_OK;
    }

    DBG_CB_EXIT(DdSetColorKey, psckd->ddRVal);    
    return DDHAL_DRIVER_HANDLED;
} // DdSetColorKey

//-----------------------------Public Routine----------------------------------
//
// DdGetAvailDriverMemory
//
// DdGetAvailDriverMemory queries the amount of free memory in the driver
// managed memory heap. This function does not need to be implemented if the 
// memory will be managed by DirectDraw.
//
// DdGetAvailDriverMemory determines how much free memory is in the driver's 
// private heaps for the specified surface type. The driver should check the 
// surface capabilities specified in DDSCaps against the heaps that it is 
// maintaining internally to determine which heap size to query. For example, 
// if DDSCAPS_NONLOCALVIDMEM is set, the driver should return only 
// contributions from the AGP heaps.
//
// The driver indicates its support of DdGetAvailDriverMemory by implementing a
// response to GUID_MiscellaneousCallbacks in DdGetDriverInfo.
//
// Parameters
//
//      pgadmd 
//          Points to a DD_GETAVAILDRIVERMEMORYDATA structure that contains the
//          information required to perform the query. 
//
//          lpDD 
//                  Points to the DD_DIRECTDRAW_GLOBAL structure that describes
//                  the driver. 
//          DDSCaps 
//                  Points to a DDSCAPS structure that describes the type of 
//                  surface for which memory availability is being queried. 
//                  The DDSCAPS structure is defined in ddraw.h. 
//          dwTotal 
//                  Specifies the location in which the driver returns the
//                  number of bytes of driver-managed memory that can be used
//                  for surfaces of the type described by DDSCaps. 
//          dwFree 
//                  Specifies the location in which the driver returns the
//                  amount of free memory, in bytes, for the surface type
//                  described by DDSCaps. 
//          ddRVal 
//                  Specifies the location in which the driver writes the
//                  return value of the DdGetAvailDriverMemory callback. A
//                  return code of DD_OK indicates success. 
//          GetAvailDriverMemory
//                  This is unused on Windows 2000. 
//
// Return Value
//      DdGetAvailDriverMemory returns one of the following callback codes:
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//
//      DdGetAvailDriverMemory determines how much free memory is in the 
//      driver's private heaps for the specified surface type. The driver 
//      should check the surface capabilities specified in DDSCaps against 
//      the heaps that it is maintaining internally to determine which heap 
//      size to query. For example, if DDSCAPS_NONLOCALVIDMEM is set, the 
//      driver should return only contributions from the AGP heaps.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetAvailDriverMemory(
    LPDDHAL_GETAVAILDRIVERMEMORYDATA pgadmd)
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(DdGetAvailDriverMemory);
    
    GET_THUNKEDDATA(pThisDisplay, pgadmd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    DISPDBG((DBGLVL, "Heap0:  dwMemStart:0x%x, dwMemEnd:0x%x",
                    pThisDisplay->LocalVideoHeap0Info.dwMemStart, 
                    pThisDisplay->LocalVideoHeap0Info.dwMemEnd));

    pgadmd->ddRVal = DD_OK;
    if (pgadmd->DDSCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        DISPDBG((DBGLVL,"  Not returning AGP heap free memory "
                        "(we don't manage it)"));
        DBG_CB_EXIT(DdGetAvailDriverMemory, pgadmd->ddRVal);                        
        return DDHAL_DRIVER_NOTHANDLED;
    }
    else
    {
        pgadmd->dwTotal = pThisDisplay->LocalVideoHeap0Info.dwMaxChunks *
                             pThisDisplay->LocalVideoHeap0Info.dwMemPerChunk;

        pgadmd->dwFree = 
               _DX_LIN_GetFreeMemInHeap(&pThisDisplay->LocalVideoHeap0Info);
    }

    DISPDBG((DBGLVL,"  Returning %d TotalMem, of which %d free", 
                pgadmd->dwTotal, pgadmd->dwFree));

    DBG_CB_EXIT(DdGetAvailDriverMemory, pgadmd->ddRVal); 
    return DDHAL_DRIVER_HANDLED;
} // DdGetAvailDriverMemory


#if W95_DDRAW
//-----------------------------------------------------------------------------
//
// __FindAGPHeap
//
//-----------------------------------------------------------------------------
static void
__FindAGPHeap( 
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DIRECTDRAW_GBL lpDD )
{
    VIDMEMINFO MemInfo = lpDD->vmiData;
    LPVIDMEM pStartHeap;
    LPVIDMEM pCurrentHeap = NULL;
    BOOL bFoundAGPHeap = FALSE;

    if ((pThisDisplay->bCanAGP) && 
        (pThisDisplay->dwGARTDev != 0) &&
        (MemInfo.dwNumHeaps) &&
        (MemInfo.pvmList))
    {
        int i;

        // Look around for a good AGP heap
        pStartHeap = MemInfo.pvmList;
        for (i = 0; i < (int)MemInfo.dwNumHeaps; i++)
        {
            pCurrentHeap = pStartHeap + i;
            if (pCurrentHeap->dwFlags & VIDMEM_ISNONLOCAL)
            {
                bFoundAGPHeap = TRUE;
                break;
            }               
        }
    } else {
        DISPDBG((ERRLVL,"Unable to allocate AGP memory (AllocatePrivAGPMem)"));
    }

    if(!bFoundAGPHeap)
    {
        DISPDBG((ERRLVL,"Unable to locate AGP heap (AllocatePrivAGPMem)"));
    }

    pThisDisplay->pAGPHeap = pCurrentHeap;
    
} // __FindAGPHeap

//-----------------------------Public Routine----------------------------------
// DdUpdateNonLocalHeap
//
// Received the address of the AGP Heap and updates the chip.
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdUpdateNonLocalHeap(
    LPDDHAL_UPDATENONLOCALHEAPDATA plhd)
{
    P3_THUNKEDDATA* pThisDisplay;
    GET_THUNKEDDATA(pThisDisplay, plhd->lpDD);

    DISPDBG((DBGLVL,"** In DdUpdateNonLocalHeap - for Heap 0x%x", 
                    plhd->dwHeap));

    // Fill in the base pointers
    pThisDisplay->dwGARTDevBase = (DWORD)plhd->fpGARTDev;
    pThisDisplay->dwGARTLinBase = (DWORD)plhd->fpGARTLin;
    
    // Fill in the changeable base pointers.
    pThisDisplay->dwGARTDev = pThisDisplay->dwGARTDevBase;
    pThisDisplay->dwGARTLin = pThisDisplay->dwGARTLinBase;

    __FindAGPHeap( pThisDisplay, plhd->lpDD );

    DISPDBG((DBGLVL,"GartLin: 0x%x, GartDev: 0x%x", 
               plhd->fpGARTLin, plhd->fpGARTDev));

    plhd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdUpdateNonLocalHeap()

//-----------------------------Public Routine----------------------------------
//
// DdGetHeapAlignment
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetHeapAlignment(
    LPDDHAL_GETHEAPALIGNMENTDATA lpGhaData)
{
    P3_THUNKEDDATA* pThisDisplay;

    DISPDBG(( DBGLVL,"DdGetHeapAlignment: Heap %d", lpGhaData->dwHeap ));
    
    if (lpGhaData->dwInstance)
        pThisDisplay = (P3_THUNKEDDATA*)lpGhaData->dwInstance;
    else
        pThisDisplay = (P3_THUNKEDDATA*)g_pDriverData;

    if( lpGhaData->dwHeap <= 2 )
    {
        lpGhaData->Alignment.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        lpGhaData->Alignment.Texture.Linear.dwStartAlignment = 16;

        lpGhaData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }
    else
    {
        lpGhaData->ddRVal = DDERR_INVALIDPARAMS;
        return DDHAL_DRIVER_NOTHANDLED;
    }   
} // DdGetHeapAlignment

#endif  //  W95_DDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddvideo.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddvideo.c
*
* Content: DirectDraw Videoports implementation
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "tag.h"
//#include <mmsystem.h>
#include "dma.h"

//@@BEGIN_DDKSPLIT
#ifdef W95_DDRAW_VIDEO

// Define P3R3DX_VIDEO to allow use of 32bit Macros in ramdac.h
#define P3R3DX_VIDEO 1
#include "ramdac.h"

#include <dvp.h>

extern DWORD CALLBACK __VD_AutoflipOverlay ( void );
extern DWORD CALLBACK __VD_AutoupdateOverlay ( void );

#if 0
#define P2_VIDPORT_WIDTH 768
#define P2_VIDPORT_HEIGHT 288
#endif

// how many DrawOverlay calls to wait after an UpdateOverlay()
// generally 1
#define OVERLAY_UPDATE_WAIT 1
// how many DrawOverlay calls to wait after a SetPosition()
// generally 1
#define OVERLAY_SETPOS_WAIT 1
// how many DrawOverlay calls  between repaints (0=no repaints)
// generally 5-15
#define OVERLAY_CYCLE_WAIT 15
// How many "DrawOverlay calls" a speedy DrawOverlay is worth.
// Generally 1
#define OVERLAY_DRAWOVERLAY_SPEED 1
// How many "DrawOverlay calls" a pretty DrawOverlay is worth.
// Generally the same as OVERLAY_CYCLE_WAIT, or 1 if it is 0.
#define OVERLAY_DRAWOVERLAY_PRETTY 15

// How long in milliseconds to wait for the videoport before timing out.
#define OVERLAY_VIDEO_PORT_TIMEOUT 100


static BOOL g_bFlipVideoPortDoingAutoflip = FALSE;


//-----------------------------------------------------------------------------
//
// __VD_PixelOffsetFromMemoryBase
//
// Calculates the offset from the memory base as the chip sees it.  This is 
// relative to the base address in the chip and is in pixels
//
//-----------------------------------------------------------------------------
long __inline 
__VD_PixelOffsetFromMemoryBase(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    DWORD lOffset;

    lOffset = DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pLcl);

    // Work out pixel offset into the framestore
    if (DDSurf_BitDepth(pLcl) == 24)
    {
        lOffset = lOffset / 3;
    }
    else
    {
        lOffset = lOffset >> DDSurf_GetPixelShift(pLcl);
    }
    return lOffset;
} // __VD_PixelOffsetFromMemoryBase

// Debug function to dump a video port description
#if DBG
//-----------------------------------------------------------------------------
//
// __VD_FillYUVSurface
//
//-----------------------------------------------------------------------------
static void 
__VD_FillYUVSurface(
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl, 
    DWORD Value)
{
    BYTE* pCurrentLine = (BYTE*)lpLcl->lpGbl->fpVidMem;
    WORD x, y;
    WORD* pSurface;
    WORD CurrentColor = (WORD)(Value & 0xFFFF);
    
    for (y = 0; y < lpLcl->lpGbl->wHeight; y++)
    {
        pSurface = (WORD*)pCurrentLine;
        for (x = 0; x < lpLcl->lpGbl->wWidth; x++)
        {
            // YUV Surface is 16Bits
            *pSurface++ = CurrentColor;
        }
        pCurrentLine += lpLcl->lpGbl->lPitch;
        if ((pCurrentLine - (31 << 1)) <= (BYTE*)pSurface)
        {
            while (pSurface++ < (WORD*)pCurrentLine)
            {
                *pSurface = 0xFFFF;
            }
        }
    }
} // __VD_FillYUVSurface

//-----------------------------------------------------------------------------
//
// __VD_DumpVPDesc
//
//-----------------------------------------------------------------------------
static void 
__VD_DumpVPDesc(
    int Level, 
    DDVIDEOPORTDESC vp)
{
    
#define CONNECT_REPORT(param)                               \
        if (vp.VideoPortType.dwFlags & DDVPCONNECT_##param) \
        {                                                   \
            DISPDBG((Level, "   " #param));                 \
        }


    DISPDBG((Level,"Port Size:  %d x %d", vp.dwFieldWidth, vp.dwFieldHeight));
    DISPDBG((Level,"VBI Width:  %d", vp.dwVBIWidth));
    DISPDBG((Level,"uS/Field:   %d", vp.dwMicrosecondsPerField));
    DISPDBG((Level,"Pixels/Sec: %d", vp.dwMaxPixelsPerSecond));
    DISPDBG((Level,"Port ID:    %d", vp.dwVideoPortID));
    DISPDBG((Level,"Flags: "));

    CONNECT_REPORT(INTERLACED);
    CONNECT_REPORT(VACT);
    CONNECT_REPORT(INVERTPOLARITY);
    CONNECT_REPORT(DOUBLECLOCK);
    CONNECT_REPORT(DISCARDSVREFDATA);
    CONNECT_REPORT(HALFLINE);
    CONNECT_REPORT(SHAREEVEN);
    CONNECT_REPORT(SHAREODD);

    DISPDBG((Level,"Connection GUID:"));
    if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_E_HREFH_VREFH))
    {
        DISPDBG((Level, "  DDVPTYPE_E_HREFH_VREFH"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_E_HREFH_VREFL))
    {
        DISPDBG((Level, "  DDVPTYPE_E_HREFH_VREFL"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_E_HREFL_VREFH))
    {
        DISPDBG((Level, "  DDVPTYPE_E_HREFL_VREFH"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_E_HREFL_VREFL))
    {
        DISPDBG((Level, "  DDVPTYPE_E_HREFL_VREFL"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_CCIR656))
    {
        DISPDBG((Level, "  CCIR656"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_BROOKTREE))
    {
        DISPDBG((Level, "  BROOKTREE"));
    }
    else if (MATCH_GUID((vp.VideoPortType.guidTypeID), DDVPTYPE_PHILIPS))
    {
        DISPDBG((Level, "  PHILIPS"));
    }
    else
    {
        DISPDBG((ERRLVL,"  ERROR: Unknown connection type!"));
    }

} // __VD_DumpVPDesc

#define DUMPVPORT(a, b) __VD_DumpVPDesc(a, b);
#define FILLYUV(a, c) __VD_FillYUVSurface(a, c);

#else

#define DUMPVPORT(a, b)
#define FILLYUV(a, c)

#endif

//-----------------------------------------------------------------------------
//
// __VD_CheckVideoPortStatus
//
// Checks to see if the videoport seems to be OK.  If it is, 
// we return TRUE.  if bWait is set then we hang around and
// try to decide if the Video is OK.
//
//-----------------------------------------------------------------------------
#define ERROR_TIMOUT_VP 470000
#define ERROR_TIMOUT_COUNT 50

BOOL 
__VD_CheckVideoPortStatus(
    P3_THUNKEDDATA* pThisDisplay, 
    BOOL bWait)
{
    DWORD dwMClock;
    DWORD dwCurrentLine;
    DWORD dwCurrentIndex;
    DWORD dwNewLine;
    DWORD dwNewMClock;

    // Is the videoport on?
    if (!pThisDisplay->VidPort.bActive) return FALSE;

    // Read the current MClock
    dwMClock = READ_GLINT_CTRL_REG(MClkCount);

    if (bWait) pThisDisplay->VidPort.bResetStatus = TRUE;

    if (pThisDisplay->VidPort.bResetStatus)
    {
        dwCurrentLine = READ_GLINT_CTRL_REG(VSACurrentLine);
        dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);

        // At start of day, record the MClock time for the start of the line
        pThisDisplay->VidPort.dwStartLineTime = dwMClock;
        
        // Also record the starting line
        pThisDisplay->VidPort.dwStartLine = dwCurrentLine;
        pThisDisplay->VidPort.dwStartIndex = dwCurrentIndex;

        pThisDisplay->VidPort.bResetStatus = FALSE;
        return TRUE;
    }

    if (bWait)
    {
        do
        {
            // Read the current line
            dwCurrentLine = READ_GLINT_CTRL_REG(VSACurrentLine);

            // OK, a line of video should take approx:
            // 1 Second / 50-60 fields/second / 300 lines = 
            // 0.000066 = 66uS.
            // If the MClock is running at, say 70Mhz that is 0.000000014 seconds/clock
            // So a line should take 0.000066 / 0.000000014 MClocks = ~4700 MClocks
            
            // Wait for 100 times longer than it should take to draw a line....
            do
            {
                dwNewMClock = READ_GLINT_CTRL_REG(MClkCount);
            } while (dwNewMClock < (dwMClock + ERROR_TIMOUT_VP));

            dwNewLine = READ_GLINT_CTRL_REG(VSACurrentLine);

            // Has the line count advanced?
            if (dwNewLine == dwCurrentLine)
            {
                dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
                if (dwCurrentIndex == pThisDisplay->VidPort.dwStartIndex)
                {
                    // Disable the videoport if the error count goes to high
                    pThisDisplay->VidPort.dwErrorCount++;

                    // Reset the status as we need to make sure the timer restarts.
                    pThisDisplay->VidPort.bResetStatus = TRUE;

                    if (pThisDisplay->VidPort.dwErrorCount > ERROR_TIMOUT_COUNT)
                    {
                        DISPDBG((WRNLVL,"StartLine: %d, CurrentLine: %d, StartIndex: %d, CurrentIndex: %d", pThisDisplay->VidPort.dwStartLine,
                                                            dwCurrentLine, pThisDisplay->VidPort.dwStartIndex, dwCurrentIndex));
                        DISPDBG((ERRLVL,"ERROR: VideoStream not working!"));
                        pThisDisplay->VidPort.bActive = FALSE;
                        return FALSE;
                    }
                }
                else
                {
                    pThisDisplay->VidPort.dwErrorCount = 0;
                    pThisDisplay->VidPort.bResetStatus = TRUE;
                }
            }
            // If it has flag a reset and break
            else
            {
                pThisDisplay->VidPort.dwErrorCount = 0;
                pThisDisplay->VidPort.bResetStatus = TRUE;
            }

        } while (pThisDisplay->VidPort.dwErrorCount);
    }
    else
    {
        // Has the line count advanced?
        if (dwMClock > (pThisDisplay->VidPort.dwStartLineTime + ERROR_TIMOUT_VP))
        {
            dwCurrentLine = READ_GLINT_CTRL_REG(VSACurrentLine);
            if (pThisDisplay->VidPort.dwStartLine == dwCurrentLine)
            {
                dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
                if (dwCurrentIndex == pThisDisplay->VidPort.dwStartIndex)
                {
                    // Disable the videoport if the error count goes to high
                    pThisDisplay->VidPort.dwErrorCount++;

                    DISPDBG((WRNLVL,"ERROR: Timeout at %d", dwMClock));

                    // Reset the status as we need to make sure the timer restarts.
                    pThisDisplay->VidPort.bResetStatus = TRUE;

                    // Disable the videoport
                    if (pThisDisplay->VidPort.dwErrorCount > ERROR_TIMOUT_COUNT)
                    {
                        DISPDBG((WRNLVL,"StartLine: %d, CurrentLine: %d, StartIndex: %d, CurrentIndex: %d", pThisDisplay->VidPort.dwStartLine,
                                                            dwCurrentLine, pThisDisplay->VidPort.dwStartIndex, dwCurrentIndex));
                        DISPDBG((ERRLVL,"ERROR: VideoStream not working!"));
                        pThisDisplay->VidPort.bActive = FALSE;
                    }
                }
                else
                {
                    pThisDisplay->VidPort.dwErrorCount = 0;
                    pThisDisplay->VidPort.bResetStatus = TRUE;
                }
            }
            else
            {
                // Reset the error status
                pThisDisplay->VidPort.dwErrorCount = 0;
                pThisDisplay->VidPort.bResetStatus = TRUE;
            }
        }
    }

    return pThisDisplay->VidPort.bActive;
    
} // __VD_CheckVideoPortStatus

//-----------------------------------------------------------------------------
//
// DdUpdateVideoPort
//
// This required function sets up the video port
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdUpdateVideoPort (
    LPDDHAL_UPDATEVPORTDATA pInput)
{
    DWORD i;
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwCurrentDisplay;
    DWORD dwLineScale;
    DWORD dwEnable;
    DWORD dwDiscard;
    DWORD XScale = 0;
    DWORD YScale = 0;
    VMIREQUEST In;
    VMIREQUEST Out;
    DWORD dwSrcPixelWidth;
    DWORD dwSrcHeight;
    DWORD dwDstPixelWidth;
    DWORD dwDstHeight;

    StreamsRegister_Settings PortSettings;
    StreamsRegister_VSPartialConfigA VSPartialA;


    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdUpdateVideoPort, dwFlags = %d", pInput->dwFlags));

    DUMPVPORT(DBGLVL ,pInput->lpVideoPort->ddvpDesc);

    pThisDisplay->pGLInfo->dwVSACaughtFrames = 0;
    pThisDisplay->pGLInfo->dwVSADroppedFrames = 0;
    pThisDisplay->pGLInfo->dwVSALastDropped = 0;

    if (pInput->dwFlags == DDRAWI_VPORTSTOP)
    {
        DISPDBG((DBGLVL,"  Stopping VideoPort"));

        // Stop any autoflipping.
        if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
        {
            if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
            {
                DISPDBG((DBGLVL,"** DdUpdateVideoPort - VPORTSTOP - was autoflipping on bogus event handle."));
            }
            pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
            pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
            DISPDBG((DBGLVL,"** DdUpdateVideoPort - VPORTSTOP - autoflipping now disabled."));
        }

        WAIT_GLINT_FIFO(2);

        pThisDisplay->VidPort.bActive = FALSE;
        pThisDisplay->VidPort.bResetStatus = TRUE;
        pThisDisplay->VidPort.dwErrorCount = 0;

        pThisDisplay->VidPort.lpSurf[0] = NULL;
        pThisDisplay->VidPort.lpSurf[1] = NULL;
        pThisDisplay->VidPort.lpSurf[2] = NULL;

        // Disable the interrupt.
        dwEnable = READ_GLINT_CTRL_REG(IntEnable);
        dwEnable &= ~INTR_ENABLE_VIDSTREAM_A;
        LOAD_GLINT_REG(IntEnable, dwEnable);

        // Disable the videoport
        LOAD_GLINT_REG(VSAControl, __PERMEDIA_DISABLE);
    }
    else if ((pInput->dwFlags == DDRAWI_VPORTSTART) ||
            (pInput->dwFlags == DDRAWI_VPORTUPDATE))
    {

        DISPDBG((DBGLVL,"  Starting/Updating VideoPort"));

        pThisDisplay->VidPort.lpSurf[0] = NULL;
        pThisDisplay->VidPort.lpSurf[1] = NULL;
        pThisDisplay->VidPort.lpSurf[2] = NULL;

        // Videoport only on P2's, therefore much more fifo room
        WAIT_GLINT_FIFO(100);

        // Disable the videoport so we can setup a new configuration
        LOAD_GLINT_REG(VSAControl, __PERMEDIA_DISABLE);
        
        // How many surfaces do we have?
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP)
        {
            if (pInput->dwNumAutoflip == 0) pThisDisplay->VidPort.dwNumSurfaces = 1;
            else pThisDisplay->VidPort.dwNumSurfaces = pInput->dwNumAutoflip;

            DISPDBG((DBGLVL,"Surfaces passed in (AUTOFLIP) = %d", pThisDisplay->VidPort.dwNumSurfaces));

            for(i = 0; i < pThisDisplay->VidPort.dwNumSurfaces; i++)
            {
                LPDDRAWI_DDRAWSURFACE_LCL pLcl = (pInput->lplpDDSurface[i])->lpLcl;

                if (pLcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER)
                {
                    DISPDBG((DBGLVL,"Surface %d is the FRONTBUFFER", i));
                    dwCurrentDisplay = i;
                }

                FILLYUV(pLcl, i * 0x4444);

                // Store away the offset to this surface
                pThisDisplay->VidPort.dwSurfacePointer[i] = pLcl->lpGbl->fpVidMem;
                pThisDisplay->VidPort.lpSurf[i] = pLcl;
            }

            // Start or continue any autoflipping.
#if DBG
            if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
            {
                DISPDBG((DBGLVL,"** DdUpdateVideoPort - trying to autoflipping using bogus event handle."));
            }
#endif
            if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL == 0 )
            {
                pThisDisplay->pGLInfo->dwPeriodVideoVBL = OVERLAY_AUTOFLIP_PERIOD;
                pThisDisplay->pGLInfo->dwCountdownVideoVBL = OVERLAY_AUTOFLIP_PERIOD;
                DISPDBG((DBGLVL,"** DdUpdateVideoPort - autoflipping now enabled."));
            }

        }
        else
        {
            LPDDRAWI_DDRAWSURFACE_LCL lpNextSurf = (pInput->lplpDDSurface[0])->lpLcl;
            i = 0;

            // Stop any autoflipping.
            if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
            {
#if DBG
                if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
                {
                    DISPDBG((DBGLVL,"** DdUpdateVideoPort - was trying to autoflip using bogus event handle."));
                }
#endif
                pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
                pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
                DISPDBG((DBGLVL,"** DdUpdateVideoPort - autoflipping now disabled."));
            }
        
            while (lpNextSurf != NULL)
            {
                if (lpNextSurf->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER)
                {
                    DISPDBG((DBGLVL,"Surface %d is the FRONTBUFFER", i));
                    dwCurrentDisplay = i;
                }

                // Store away the offset to this surface
                pThisDisplay->VidPort.dwSurfacePointer[i] = lpNextSurf->lpGbl->fpVidMem;
                pThisDisplay->VidPort.lpSurf[i] = lpNextSurf;

                FILLYUV(lpNextSurf, i * 0x4444);

                // Is there another surface in the chain?
                if (lpNextSurf->lpAttachList)
                {
                    lpNextSurf = lpNextSurf->lpAttachList->lpAttached;
                    if (lpNextSurf == NULL) break;
                }
                else break;

                // Have we spun around the loop?
                if (lpNextSurf == (pInput->lplpDDSurface[0])->lpLcl) break;

                i++;
            }

            pThisDisplay->VidPort.dwNumSurfaces = i + 1;
            DISPDBG((DBGLVL,"Surfaces passed in (Not AutoFlip) = %d", (i + 1)));
        }

        DISPDBG((DBGLVL,"  Addresses: 0x%x, 0x%x, 0x%x", 
                        pThisDisplay->VidPort.dwSurfacePointer[0], 
                        pThisDisplay->VidPort.dwSurfacePointer[1],
                        pThisDisplay->VidPort.dwSurfacePointer[2]));

                
        // Remember the size of the vertical blanking interval and the size of the frame.
        pThisDisplay->VidPort.dwFieldWidth = pInput->lpVideoPort->ddvpDesc.dwFieldWidth;
        pThisDisplay->VidPort.dwFieldHeight = pInput->lpVideoPort->ddvpDesc.dwFieldHeight;

        // Setup the Host register so that it points to the same surface we will display.
        pThisDisplay->VidPort.dwCurrentHostFrame = dwCurrentDisplay;

        dwSrcPixelWidth = (pInput->lpVideoInfo->dwVPFlags & DDVP_CROP) ?
                          (pInput->lpVideoInfo->rCrop.right - pInput->lpVideoInfo->rCrop.left) : 
                          pInput->lpVideoPort->ddvpDesc.dwFieldWidth; 

        dwSrcHeight = (pInput->lpVideoInfo->dwVPFlags & DDVP_CROP) ?
                      (pInput->lpVideoInfo->rCrop.bottom - pInput->lpVideoInfo->rCrop.top) :
                      pInput->lpVideoPort->ddvpDesc.dwFieldHeight;

        DISPDBG((DBGLVL,"Source Width: %d", dwSrcPixelWidth));
        DISPDBG((DBGLVL,"Source Height: %d", dwSrcHeight));

        // Do we need to prescale the surface?
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE)
        {
            DISPDBG((DBGLVL,"Prescale Width:%d, Height:%d", 
                            pInput->lpVideoInfo->dwPrescaleWidth,
                            pInput->lpVideoInfo->dwPrescaleHeight));

            if ((pInput->lpVideoInfo->dwPrescaleWidth != 0) &&
                (pInput->lpVideoInfo->dwPrescaleWidth != pInput->lpVideoPort->ddvpDesc.dwFieldWidth))
            {
                XScale =  pInput->lpVideoPort->ddvpDesc.dwFieldWidth / pInput->lpVideoInfo->dwPrescaleWidth;
                switch(XScale)
                {
                    case 2:
                        XScale = 1;
                        break;
                    case 4:
                        XScale = 2;
                        break;
                    case 8:
                        XScale = 3;
                        break;
                    default:
                        XScale = 0;
                        break;
                }
            }

            if ((pInput->lpVideoInfo->dwPrescaleHeight != 0) &&
                (pInput->lpVideoInfo->dwPrescaleHeight != pInput->lpVideoPort->ddvpDesc.dwFieldHeight))
            {   
                YScale = pInput->lpVideoPort->ddvpDesc.dwFieldHeight / pInput->lpVideoInfo->dwPrescaleHeight;
                switch(YScale)
                {
                    case 2:
                        YScale = 1;
                        break;
                    case 4:
                        YScale = 2;
                        break;
                    case 8:
                        YScale = 3;
                        break;
                    default:
                        YScale = 0;
                        break;
                }
            }

            // HACK! HACK!
            dwDstPixelWidth = pInput->lpVideoInfo->dwPrescaleWidth;
            dwDstHeight = pInput->lpVideoInfo->dwPrescaleHeight;
        }
        else
        {
            dwDstPixelWidth = dwSrcPixelWidth;
            dwDstHeight = dwSrcHeight;
        }

        DISPDBG((DBGLVL,"Dest Width: %d", dwDstPixelWidth));
        DISPDBG((DBGLVL,"Dest Height: %d", dwDstHeight));

        // Need to setup the registers differently if we are mirroring top to bottom
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN)
        {
            // Make sure we aren't prescaling...
            if (YScale == 0)
            {
                pThisDisplay->VidPort.dwSurfacePointer[0] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoPort->ddvpDesc.dwFieldHeight);
                pThisDisplay->VidPort.dwSurfacePointer[1] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoPort->ddvpDesc.dwFieldHeight);
                pThisDisplay->VidPort.dwSurfacePointer[2] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoPort->ddvpDesc.dwFieldHeight);
            }
            else
            {
                pThisDisplay->VidPort.dwSurfacePointer[0] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoInfo->dwPrescaleHeight);
                pThisDisplay->VidPort.dwSurfacePointer[1] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoInfo->dwPrescaleHeight);
                pThisDisplay->VidPort.dwSurfacePointer[2] += (pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch * (pInput->lpVideoInfo->dwPrescaleHeight);
            }
        }

        if (pInput->lpVideoPort->ddvpDesc.VideoPortType.dwPortWidth == 8) dwLineScale = 0;
        else dwLineScale = 1;

        // Setup the configuration of the VideoPort
        // This is done by a call to the VXD as the registers that are touched have bits
        // that are shared with the TV Out and the ROM.
        // ***********************
        // UnitMode:    Typically setup for 8 or 16 bit YUV input port.
        // GPMode:      Not used.
        // HREF_POL_A:  Polarity active of HREF
        // VREF_POL_A:  Polarity active of VREF
        // VActive:     Wether the VACT signal is active high or low (if there is one).
        //              Can be set to the inverse of the HREF as a good guess(?)
        // UseField:    Stream A on or off
        // FieldPolA:   How to treat the field polarity of stream A
        // FieldEdgeA:
        // VActiveVBIA:
        // InterlaceA:  Interlaced data on A?
        // ReverseA:    Should we reverse the YUV data on A
        // ***********************
        
        PortSettings.UnitMode = ((pInput->lpVideoPort->ddvpDesc.VideoPortType.dwPortWidth == 8) ? STREAMS_MODE_STREAMA_STREAMB : STREAMS_MODE_STREAMA_WIDE16);
        In.dwSize = sizeof(VMIREQUEST);
        In.dwRegister = P2_VSSettings;
        In.dwCommand = *((DWORD*)(&PortSettings));
        In.dwDevNode = pThisDisplay->dwDevNode;
        In.dwOperation = GLINT_VMI_WRITE;
        VXDCommand(GLINT_VMI_COMMAND, &In, sizeof(VMIREQUEST), &Out, sizeof(VMIREQUEST));

        VSPartialA.HRefPolarityA = ((pThisDisplay->VidPort.dwStreamAFlags & VIDEOPORT_HREF_ACTIVE_HIGH) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE);
        VSPartialA.VRefPolarityA = ((pThisDisplay->VidPort.dwStreamAFlags & VIDEOPORT_VREF_ACTIVE_HIGH) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE);
        // There is no setting in DirectX for the polarity of the active signal.  Therefore we must assume one value.  This
        // has been chosen based on the setting that gives the correct effect for a Bt827/829
        VSPartialA.VActivePolarityA = __PERMEDIA_ENABLE;
        VSPartialA.UseFieldA = __PERMEDIA_DISABLE;
        VSPartialA.FieldPolarityA = ((pInput->lpVideoPort->ddvpDesc.VideoPortType.dwFlags & DDVPCONNECT_INVERTPOLARITY) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE);
        VSPartialA.FieldEdgeA = __PERMEDIA_DISABLE;
        VSPartialA.VActiveVBIA = __PERMEDIA_DISABLE;
        VSPartialA.InterlaceA = __PERMEDIA_ENABLE;
        VSPartialA.ReverseDataA = __PERMEDIA_ENABLE;
        In.dwSize = sizeof(VMIREQUEST);
        In.dwRegister = P2_VSAPartialConfig;
        In.dwCommand = *((DWORD*)(&VSPartialA));
        In.dwDevNode = pThisDisplay->dwDevNode;
        In.dwOperation = GLINT_VMI_WRITE;
        VXDCommand( GLINT_VMI_COMMAND, &In, sizeof(VMIREQUEST), &Out, sizeof(VMIREQUEST));

        // Setup Stream A
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS)
        {
            dwDiscard = PM_VSACONTROL_DISCARD_1;
            DISPDBG((DBGLVL,"Skipping Even Fields"));
        }
        else if(pInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS)
        {
            dwDiscard = PM_VSACONTROL_DISCARD_2;
            DISPDBG((DBGLVL,"Skipping Odd Fields"));
        }
        else dwDiscard = __PERMEDIA_DISABLE;
        
        LOAD_GLINT_REG(VSAControl, PM_VSACONTROL_VIDEO(__PERMEDIA_ENABLE) |
                                    PM_VSACONTROL_VBI(__PERMEDIA_DISABLE) |
                                    PM_VSACONTROL_BUFFER((pThisDisplay->VidPort.dwNumSurfaces == 3) ? 1 : 0) |
                                    PM_VSACONTROL_SCALEX(XScale) | 
                                    PM_VSACONTROL_SCALEY(YScale) |
                                    PM_VSACONTROL_MIRRORY((pInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE) |
                                    PM_VSACONTROL_MIRRORX((pInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE) |
                                    PM_VSACONTROL_DISCARD(dwDiscard) |
                                    PM_VSACONTROL_COMBINE((pInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE) ? __PERMEDIA_ENABLE : __PERMEDIA_DISABLE) |
                                    PM_VSACONTROL_LOCKTOB(__PERMEDIA_DISABLE));

        // Point the register at the surface being used
        LOAD_GLINT_REG(VSAVideoAddressHost, pThisDisplay->VidPort.dwCurrentHostFrame);

        // Check on the video stride
        LOAD_GLINT_REG(VSAVideoStride, (((pInput->lplpDDSurface[0])->lpLcl->lpGbl->lPitch) >> 3));
        
        // Vertical data
        if (pInput->lpVideoInfo->dwVPFlags & DDVP_CROP) 
        {
            LOAD_GLINT_REG(VSAVideoStartLine, pInput->lpVideoInfo->rCrop.top);
            LOAD_GLINT_REG(VSAVideoEndLine, pInput->lpVideoInfo->rCrop.top + dwDstHeight);
        }
        else
        {
            LOAD_GLINT_REG(VSAVideoStartLine, 0);
            LOAD_GLINT_REG(VSAVideoEndLine, dwDstHeight);
        }

        // Not using VBI, must disable (P2ST may not start up in a fixed state)
        LOAD_GLINT_REG(VSAVBIAddressHost, 0);
        LOAD_GLINT_REG(VSAVBIAddressIndex, 0);
        LOAD_GLINT_REG(VSAVBIAddress0, 0);
        LOAD_GLINT_REG(VSAVBIAddress1, 0);
        LOAD_GLINT_REG(VSAVBIAddress2, 0);
        LOAD_GLINT_REG(VSAVBIStride, 0);
        LOAD_GLINT_REG(VSAVBIStartLine, 0);
        LOAD_GLINT_REG(VSAVBIEndLine, 0);
        LOAD_GLINT_REG(VSAVBIStartData, 0);
        LOAD_GLINT_REG(VSAVBIEndData, 0);

#define CLOCKS_PER_PIXEL 2

        // Horizontal data
        // If the 
        if (pInput->lpVideoPort->ddvpDesc.VideoPortType.dwFlags & DDVPCONNECT_VACT)
        {
            // Set StartData and EndData to their limits and
            // let VACT tell us when we are getting active data.
            LOAD_GLINT_REG(VSAVideoStartData, 0);
            LOAD_GLINT_REG(VSAVideoEndData, (VIDEOPORT_MAX_FIELD_WIDTH) - 1);
        }
        else
        {
            if (pInput->lpVideoInfo->dwVPFlags & DDVP_CROP) 
            {
                LOAD_GLINT_REG(VSAVideoStartData, (pInput->lpVideoInfo->rCrop.left * CLOCKS_PER_PIXEL));
                LOAD_GLINT_REG(VSAVideoEndData, (pInput->lpVideoInfo->rCrop.left * CLOCKS_PER_PIXEL) + 
                                                ((dwDstPixelWidth / 2) * CLOCKS_PER_PIXEL));
            }
            else
            {
                LOAD_GLINT_REG(VSAVideoStartData, 0);
                LOAD_GLINT_REG(VSAVideoEndData, (dwDstPixelWidth * CLOCKS_PER_PIXEL));
            }
        }

        // Point at the surfaces
        LOAD_GLINT_REG(VSAVideoAddress0, ((pThisDisplay->VidPort.dwSurfacePointer[0] - pThisDisplay->dwScreenFlatAddr) >> 3));
        LOAD_GLINT_REG(VSAVideoAddress1, ((pThisDisplay->VidPort.dwSurfacePointer[1] - pThisDisplay->dwScreenFlatAddr) >> 3));
        LOAD_GLINT_REG(VSAVideoAddress2, ((pThisDisplay->VidPort.dwSurfacePointer[2] - pThisDisplay->dwScreenFlatAddr) >> 3));

        // Hook the VSYNC interrupt
        dwEnable = READ_GLINT_CTRL_REG(IntEnable);
        dwEnable |= INTR_ENABLE_VIDSTREAM_A;
        LOAD_GLINT_REG(IntEnable, dwEnable);

        LOAD_GLINT_REG(VSAInterruptLine, 0);
        pThisDisplay->VidPort.bActive = TRUE;
        pThisDisplay->VidPort.bResetStatus = TRUE;
        pThisDisplay->VidPort.dwErrorCount = 0;
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdUpdateVideoPort

//-----------------------------------------------------------------------------
//
// DDGetVideoPortConnectInfo
//
// Passes back the connect info to a client.  Can be an array of
// available VideoPort Type
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DDGetVideoPortConnectInfo(
    LPDDHAL_GETVPORTCONNECTDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DDGetVideoPortConnectInfo"));

    // P2 has 1 input and 1 output port, but DirectDraw 
    // VPE only understands input ports (for now).
    if (pInput->dwPortId != 0)
    {
        DISPDBG((WRNLVL, "  Invalid port ID: 0x%x", pInput->dwPortId));
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Fill in an array of connect info's.
    if (pInput->lpConnect == NULL)
    {
        DISPDBG((DBGLVL,"  Request for connect number, Port: 0x%x", pInput->dwPortId));
        pInput->dwNumEntries = VIDEOPORT_NUM_CONNECT_INFO;
        pInput->ddRVal = DD_OK;
    }
    else
    {
        DWORD dwNum;
        DDVIDEOPORTCONNECT ConnectInfo;

        DISPDBG((DBGLVL,"  Request for connect info, Port: 0x%x", pInput->dwPortId));

        ZeroMemory(&ConnectInfo, sizeof(DDVIDEOPORTCONNECT));
        ConnectInfo.dwSize = sizeof(DDVIDEOPORTCONNECT);
        ConnectInfo.dwFlags = DDVPCONNECT_VACT | DDVPCONNECT_DISCARDSVREFDATA
                                | DDVPCONNECT_HALFLINE | DDVPCONNECT_INVERTPOLARITY;

        // 4 GUIDs, 2 Port widths (8 and 16 bits)
        for (dwNum = 0; dwNum < VIDEOPORT_NUM_CONNECT_INFO; dwNum++)
        {
            switch(dwNum)
            {
                case 0: 
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFH_VREFH;
                    ConnectInfo.dwPortWidth = 8;
                    break;
                case 1: 
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFH_VREFH;
                    ConnectInfo.dwPortWidth = 16;
                    break;
                case 2: 
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFH_VREFL;
                    ConnectInfo.dwPortWidth = 8;
                    break;
                case 3: 
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFH_VREFL;
                    ConnectInfo.dwPortWidth = 16;
                    break;
                case 4:
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFL_VREFH;
                    ConnectInfo.dwPortWidth = 8;
                    break;
                case 5:
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFL_VREFH;
                    ConnectInfo.dwPortWidth = 16;
                    break;
                case 6:
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFL_VREFL;
                    ConnectInfo.dwPortWidth = 8;
                    break;
                case 7:
                    ConnectInfo.guidTypeID = DDVPTYPE_E_HREFL_VREFL;
                    ConnectInfo.dwPortWidth = 16;
                    break;
            }
            memcpy((pInput->lpConnect + dwNum), &ConnectInfo, sizeof(DDVIDEOPORTCONNECT));
        }

        pInput->dwNumEntries = VIDEOPORT_NUM_CONNECT_INFO;
        pInput->ddRVal = DD_OK;
    }

    return DDHAL_DRIVER_HANDLED;
    
} // DDGetVideoPortConnectInfo

//-----------------------------------------------------------------------------
//
// DdCanCreateVideoPort
//
// Can the VideoPort be created?
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdCanCreateVideoPort (
    LPDDHAL_CANCREATEVPORTDATA pInput)
{
    DWORD dwFlags = 0;
    LPDDVIDEOPORTDESC    lpVPDesc;
    LPDDVIDEOPORTCONNECT lpVPConn;
    P3_THUNKEDDATA* pThisDisplay;

    lpVPDesc = pInput->lpDDVideoPortDesc;
    lpVPConn = &(pInput->lpDDVideoPortDesc->VideoPortType);
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdCanCreateVideoPort"));

    DUMPVPORT(DBGLVL,*pInput->lpDDVideoPortDesc);

    // Start with DD_OK.  If we are asked for parameters that we don't
    // support, then set the flag to DDERR_INVALIDPARAMS.
    pInput->ddRVal = DD_OK;

    // Check the video port ID
    if (lpVPDesc->dwVideoPortID != 0)
    {
        DISPDBG((DBGLVL, "  Invalid port ID: %d", lpVPDesc->dwVideoPortID));
        pInput->ddRVal = DDERR_INVALIDPARAMS;
    }

    // Check the video field width
    if (lpVPDesc->dwFieldWidth > VIDEOPORT_MAX_FIELD_WIDTH)
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid video field width: %d", lpVPDesc->dwFieldWidth));
    }

    // Check the VBI field width
    if (lpVPDesc->dwVBIWidth > VIDEOPORT_MAX_VBI_WIDTH)
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid VBI field width: %d", lpVPDesc->dwVBIWidth));
    }

    // Check the field height
    if (lpVPDesc->dwFieldHeight > VIDEOPORT_MAX_FIELD_HEIGHT)
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid video field height: %d", lpVPDesc->dwFieldHeight));
    }

    // Check the connection GUID
    if ( MATCH_GUID((lpVPConn->guidTypeID), DDVPTYPE_CCIR656)   ||
         MATCH_GUID((lpVPConn->guidTypeID), DDVPTYPE_BROOKTREE) ||
         MATCH_GUID((lpVPConn->guidTypeID), DDVPTYPE_PHILIPS) )
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid connection GUID"));
    }

    // Check the port width
    if ( !((lpVPConn->dwPortWidth == 8) || (lpVPConn->dwPortWidth == 16)) )
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid port width: %d", lpVPConn->dwPortWidth));
    }

    // All the flags we don't support
    dwFlags = DDVPCONNECT_DOUBLECLOCK | DDVPCONNECT_SHAREEVEN | DDVPCONNECT_SHAREODD;

    // Check the flags
    if (lpVPConn->dwFlags & dwFlags)
    {
        pInput->ddRVal = DDERR_INVALIDPARAMS;
        DISPDBG((DBGLVL, "  Invalid flags: 0x%x", lpVPConn->dwFlags));
    }

    return DDHAL_DRIVER_HANDLED;
    
} // DdCanCreateVideoPort

//-----------------------------------------------------------------------------
//
// DdCreateVideoPort
//
// This function is optional
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdCreateVideoPort (
    LPDDHAL_CREATEVPORTDATA pInput)
{
    VMIREQUEST vmi_inreq;
    VMIREQUEST vmi_outreq;
    BOOL bRet;

    int SurfaceNum = 0;
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdCreateVideoPort"));

    // Reset the structure for the videoport info
    memset(&pThisDisplay->VidPort, 0, sizeof(pThisDisplay->VidPort));

    ZeroMemory(&vmi_inreq, sizeof(VMIREQUEST));
    ZeroMemory(&vmi_outreq, sizeof(VMIREQUEST));
    vmi_inreq.dwSize = sizeof(VMIREQUEST);
    vmi_inreq.dwDevNode = pThisDisplay->dwDevNode;
    vmi_inreq.dwOperation = GLINT_VMI_GETMUTEX_A;
    vmi_inreq.dwMutex = 0;
    bRet = VXDCommand(GLINT_VMI_COMMAND, &vmi_inreq, sizeof(VMIREQUEST), &vmi_outreq, sizeof(VMIREQUEST));
    if (!bRet || (vmi_outreq.dwMutex == 0))
    {
        DISPDBG((WRNLVL,"WARNING: Couldn't get Mutex for stream A - VFW running?"));
        pInput->ddRVal = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }
    pThisDisplay->VidPort.dwMutexA = vmi_outreq.dwMutex;


    // Ensure the port is marked as not created and not on
    pThisDisplay->VidPort.bCreated = FALSE;
    pThisDisplay->VidPort.bActive = FALSE;

    WAIT_GLINT_FIFO(2);

    // Make sure the port is disabled.
    LOAD_GLINT_REG(VSAControl, __PERMEDIA_DISABLE);

    // Keep a copy of the videoport description
    DUMPVPORT(0,*pInput->lpDDVideoPortDesc);

    // Succesfully created the VideoPort.
    pThisDisplay->VidPort.bCreated = TRUE;

    // Depending on the GUID, decide on the Status of the HREF and VREF lines
    if (MATCH_GUID((pInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_E_HREFH_VREFH))
    {
        DISPDBG((DBGLVL,"  GUID: DDVPTYPE_E_HREFH_VREFH"));
        pThisDisplay->VidPort.dwStreamAFlags = VIDEOPORT_HREF_ACTIVE_HIGH | VIDEOPORT_VREF_ACTIVE_HIGH;
    }
    else if (MATCH_GUID((pInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_E_HREFH_VREFL))
    {
        DISPDBG((DBGLVL,"  GUID: DDVPTYPE_E_HREFH_VREFH"));
        pThisDisplay->VidPort.dwStreamAFlags = VIDEOPORT_HREF_ACTIVE_HIGH;
    }
    else if (MATCH_GUID((pInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_E_HREFL_VREFH))
    {
        DISPDBG((DBGLVL,"  GUID: DDVPTYPE_E_HREFH_VREFH"));
        pThisDisplay->VidPort.dwStreamAFlags = VIDEOPORT_VREF_ACTIVE_HIGH;
    }
    else if (MATCH_GUID((pInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_E_HREFL_VREFL))
    {
        DISPDBG((DBGLVL,"  GUID: DDVPTYPE_E_HREFH_VREFH"));
        pThisDisplay->VidPort.dwStreamAFlags = 0;
    }
    else
    {
        DISPDBG((ERRLVL,"ERROR: Unsupported VideoType GUID!"));
        pThisDisplay->VidPort.dwStreamAFlags = 0;
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_NOTHANDLED;
} // DdCreateVideoPort


//-----------------------------------------------------------------------------
//
// DdFlipVideoPort
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdFlipVideoPort (
    LPDDHAL_FLIPVPORTDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwChipIndex;
    DWORD OutCount = 0;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);
    
    DISPDBG((DBGLVL,"** In DdFlipVideoPort"));

    if (pThisDisplay->VidPort.bActive)
    {

#if DBG
        if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
        {
            if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
            {
                DISPDBG((WRNLVL,"** DdFlipVideoPort: was autoflipping on bogus event handle."));
            }
            if ( !g_bFlipVideoPortDoingAutoflip )
            {
                DISPDBG((DBGLVL,"** DdFlipVideoPort: already autoflipping!"));
            }
        }
#endif

        // Don't allow us to catch up with the video
        do
        {
            dwChipIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
        } while (dwChipIndex == pThisDisplay->VidPort.dwCurrentHostFrame);

        pThisDisplay->VidPort.dwCurrentHostFrame++;
        if (pThisDisplay->VidPort.dwCurrentHostFrame >= pThisDisplay->VidPort.dwNumSurfaces)
        {
            pThisDisplay->VidPort.dwCurrentHostFrame = 0;
        }

        // Need to sync to ensure that a blit from the source surface has finished..
        SYNC_WITH_GLINT;
        
        // Advance the count
        LOAD_GLINT_REG(VSAVideoAddressHost, pThisDisplay->VidPort.dwCurrentHostFrame);
    }
    
    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // DdFlipVideoPort


//-----------------------------------------------------------------------------
//
// DdGetVideoPortBandwidth
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortBandwidth (
    LPDDHAL_GETVPORTBANDWIDTHDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DDVIDEOPORTBANDWIDTH *lpOutput = pInput->lpBandwidth;
    DDVIDEOPORTINFO *pInfo = &(pInput->lpVideoPort->ddvpInfo);
    DDVIDEOPORTDESC *pDesc = &(pInput->lpVideoPort->ddvpDesc);

    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortBandwidth"));

    lpOutput->dwSize = sizeof(DDVIDEOPORTBANDWIDTH);    
    lpOutput->dwCaps = DDVPBCAPS_DESTINATION;

    if (!(pInput->dwFlags & DDVPB_TYPE))
    {
        lpOutput->dwOverlay = 20;
        lpOutput->dwColorkey = 20;
        lpOutput->dwYInterpolate = 20;
        lpOutput->dwYInterpAndColorkey = 20;
    }
       
    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // DdGetVideoPortBandwidth


//-----------------------------------------------------------------------------
//
// GetVideoPortInputFormat32
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortInputFormats (
    LPDDHAL_GETVPORTINPUTFORMATDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DDPIXELFORMAT pf[] =
    {
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC, FOURCC_YUV422 ,16,(DWORD)-1,(DWORD)-1,(DWORD)-1},
    };

    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);


    DISPDBG((DBGLVL,"** In DdGetVideoPortInputFormats"));

    //
    // The HAL is gaurenteed that the buffer in pInput->lpddpfFormat
    // is large enough to hold the information
    //
    pInput->dwNumFormats = 1;
    if (pInput->lpddpfFormat != NULL)
    {
        memcpy (pInput->lpddpfFormat, pf, sizeof (DDPIXELFORMAT));
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // GetVideoPortInputFormat32


//-----------------------------------------------------------------------------
//
// DdGetVideoPortOutputFormats
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortOutputFormats (
    LPDDHAL_GETVPORTOUTPUTFORMATDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    DDPIXELFORMAT pf[] =
    {
        {sizeof(DDPIXELFORMAT),DDPF_FOURCC, FOURCC_YUV422 ,16,(DWORD)-1,(DWORD)-1,(DWORD)-1},
    };

    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortOutputFormats"));

    // This says that if the input format of the videoport is YUV then the output will also be
    // YUV to the surface
    if (pInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC )
    {
        if (pInput->lpddpfInputFormat->dwFourCC == FOURCC_YUV422)
        {
            pInput->dwNumFormats = 1;
            if (pInput->lpddpfOutputFormats != NULL)
            {
                memcpy (pInput->lpddpfOutputFormats, pf, sizeof (DDPIXELFORMAT));
            }
        }
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
} // DdGetVideoPortOutputFormats

//-----------------------------------------------------------------------------
//
// DdGetVideoPortField
//
// This function is only required if readback of the current
// field is supported.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortField (
    LPDDHAL_GETVPORTFIELDDATA pInput)
{
    DWORD i = 0;
    DWORD dwIndex  = 0;
    DWORD dwMask   = 0;
    DWORD dwStatus = 0;

    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortField"));

    //
    // Make sure the video port is ON.  If not, set
    // pInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
    //
    if (pThisDisplay->VidPort.bActive == FALSE)
    {
        pInput->ddRVal = DDERR_VIDEONOTACTIVE;
    }
    else
    {
        DWORD dwCurrentIndex;

        // Read the current index and compare with us.  If the same then
        // we haven't finished drawing.
        do
        {
            dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
        } while (pThisDisplay->VidPort.dwCurrentHostFrame == dwCurrentIndex);

        pInput->bField = (BOOL)((pThisDisplay->pGLInfo->dwVSAPolarity >> pThisDisplay->VidPort.dwCurrentHostFrame) & 0x1);
        //pInput->bField = !pInput->bField;

        DISPDBG((DBGLVL,"Returning Field %d's Polarity "
                        "- %d (dwVSAPolarity = 0x%x)", 
                        pThisDisplay->VidPort.dwCurrentHostFrame, 
                        pInput->bField,
                        pThisDisplay->pGLInfo->dwVSAPolarity));

        pInput->ddRVal = DD_OK;
    }

    return DDHAL_DRIVER_HANDLED;
} // DdGetVideoPortField


//-----------------------------------------------------------------------------
//
// DdGetVideoPortLine
//
// This function is only required if readback of the current
// video line number (0 relative) is supported.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortLine (
    LPDDHAL_GETVPORTLINEDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwCurrentLine;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortLine"));

    if (pThisDisplay->VidPort.bActive == FALSE)
    {
        pInput->ddRVal = DDERR_VIDEONOTACTIVE;
    }
    else
    {
        dwCurrentLine = READ_GLINT_CTRL_REG(VSACurrentLine);
        pInput->dwLine = dwCurrentLine;
        pInput->ddRVal = DD_OK;
    }

    return DDHAL_DRIVER_HANDLED;
    
} // DdGetVideoPortLine

//-----------------------------------------------------------------------------
//
// DdDestroyVideoPort
//
// This optional function notifies the HAL when the video port
// has been destroyed.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdDestroyVideoPort (
    LPDDHAL_DESTROYVPORTDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    VMIREQUEST vmi_inreq;
    VMIREQUEST vmi_outreq;
    BOOL bRet;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdDestroyVideoPort"));

    // Ensure the port is off.
    WAIT_GLINT_FIFO(2);

    // Disablet the videoport
    LOAD_GLINT_REG(VSAControl, __PERMEDIA_DISABLE);

    // Ensure the port is marked as not created and not on
    pThisDisplay->VidPort.bCreated = FALSE;
    pThisDisplay->VidPort.bActive = FALSE;

    // Release the mutex on Stream A
    if (pThisDisplay->VidPort.dwMutexA != 0)
    {
        DISPDBG((DBGLVL,"  Releasing StreamA Mutex"));
        ZeroMemory(&vmi_inreq, sizeof(VMIREQUEST));
        ZeroMemory(&vmi_outreq, sizeof(VMIREQUEST));
        vmi_inreq.dwSize = sizeof(VMIREQUEST);
        vmi_inreq.dwDevNode = pThisDisplay->dwDevNode;
        vmi_inreq.dwOperation = GLINT_VMI_RELEASEMUTEX_A;
        vmi_inreq.dwMutex = pThisDisplay->VidPort.dwMutexA;
        bRet = VXDCommand(GLINT_VMI_COMMAND, &vmi_inreq, sizeof(VMIREQUEST), &vmi_outreq, sizeof(VMIREQUEST));
        ASSERTDD(bRet,"ERROR: Couldn't release Mutex on Stream A");
    }

    // Reset the structure
    memset(&pThisDisplay->VidPort, 0, sizeof(pThisDisplay->VidPort));

    // Stop any autoflipping.
    if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
    {
#if DBG
        if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
        {
            DISPDBG((WRNLVL,"** DdDestroyVideoPort: "
                       "was autoflipping on bogus event handle."));
        }
#endif
        pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
        pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
        DISPDBG((DBGLVL,"** DdDestroyVideoPort: autoflipping now disabled."));
    }

    // Make sure the videoport is turned off

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_NOTHANDLED;
    
} // DdDestroyVideoPort

//-----------------------------------------------------------------------------
//
// DdGetVideoSignalStatus
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoSignalStatus(
    LPDDHAL_GETVPORTSIGNALDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwCurrentIndex;
    BOOL bOK = FALSE;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);

    // If the host count matches the index count then the video may be stuck
    if (pThisDisplay->VidPort.dwCurrentHostFrame == dwCurrentIndex)
    {
        bOK = __VD_CheckVideoPortStatus(pThisDisplay, TRUE);
    }
    else
    {
        bOK = TRUE;
    }
    
    if (!bOK)
    {
        pInput->dwStatus = DDVPSQ_NOSIGNAL;
    }
    else
    {
        pInput->dwStatus = DDVPSQ_SIGNALOK;
    }

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdGetVideoSignalStatus

//-----------------------------------------------------------------------------
//
// DdGetVideoPortFlipStatus
//
// This required function allows DDRAW to restrict access to a surface
// until the physical flip has occurred, allowing doubled buffered capture.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetVideoPortFlipStatus (
    LPDDHAL_GETVPORTFLIPSTATUSDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwCurrentIndex;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdGetVideoPortFlipStatus"));

    pInput->ddRVal = DD_OK;

    if (pThisDisplay->VidPort.bActive == TRUE)
    {

        // If we are flipping, check the currently rendered frame
        // Read the current index and compare with us.  If the same then
        // we haven't finished drawing.
        dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
        if (pThisDisplay->VidPort.dwCurrentHostFrame == dwCurrentIndex)
        {
            // If the videoport is not stuck return that we are still drawing
            if (__VD_CheckVideoPortStatus(pThisDisplay, FALSE))
            {
                pInput->ddRVal = DDERR_WASSTILLDRAWING;
            }
            else
            {
                pInput->ddRVal = DD_OK;
            }

        }
    }

    return DDHAL_DRIVER_HANDLED;
    
} // DdGetVideoPortFlipStatus

//-----------------------------------------------------------------------------
//
// DdWaitForVideoPortSync
//
// This function is required
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdWaitForVideoPortSync (
    LPDDHAL_WAITFORVPORTSYNCDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdWaitForVideoPortSync"));

//@@BEGIN_DDKSPLIT
    /*
     * Make sure the video port is ON.  If not, set
     * pInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */
/*
    if (pInput->dwFlags == DDVPEVENT_BEGIN)
    {
        pInput->ddRVal = DD_OK;
    }

    else if (pInput->dwFlags == DDVPEVENT_END)
    {
        pInput->ddRVal = DD_OK;
    }
    */
//@@END_DDKSPLIT

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdWaitForVideoPortSync

//-----------------------------------------------------------------------------
//
// DdSyncSurfaceData
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSyncSurfaceData(
    LPDDHAL_SYNCSURFACEDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdSyncSurfaceData"));

    DBGDUMP_DDRAWSURFACE_LCL(3, pInput->lpDDSurface);
    if (!(pInput->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
    {
        DISPDBG((DBGLVL, "Surface is not an overlay - not handling"));
        pInput->ddRVal = DD_OK;
        return DDHAL_DRIVER_NOTHANDLED;
    }

    if (pInput->lpDDSurface->lpGbl->dwGlobalFlags & 
                                    DDRAWISURFGBL_SOFTWAREAUTOFLIP)
    {
        DISPDBG((DBGLVL, "Autoflipping in software"));
    }
    pInput->dwSurfaceOffset = pInput->lpDDSurface->lpGbl->fpVidMem - 
                                        pThisDisplay->dwScreenFlatAddr;
    pInput->dwOverlayOffset = pInput->dwSurfaceOffset;

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdSyncSurfaceData

//-----------------------------------------------------------------------------
//
// DdSyncVideoPortData
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSyncVideoPortData(
    LPDDHAL_SYNCVIDEOPORTDATA pInput)
{
    P3_THUNKEDDATA* pThisDisplay;
    
    GET_THUNKEDDATA(pThisDisplay, pInput->lpDD->lpGbl);

    DISPDBG((DBGLVL,"** In DdSyncVideoPortData"));

    pInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdSyncVideoPortData

//-----------------------------------------------------------------------------
//
// UpdateOverlay32
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
UpdateOverlay32(
    LPDDHAL_UPDATEOVERLAYDATA puod)
{

    P3_THUNKEDDATA*               pThisDisplay;
    LPDDRAWI_DDRAWSURFACE_LCL   lpSrcSurf;
    HDC                         hDC;
    DWORD                       dwDstColourKey;
    DWORD                       dwSrcColourKey;

    GET_THUNKEDDATA(pThisDisplay, puod->lpDD);


    /*
     * A puod looks like this:
     * 
     * LPDDRAWI_DIRECTDRAW_GBL      lpDD;               // driver struct
     * LPDDRAWI_DDRAWSURFACE_LCL    lpDDDestSurface;    // dest surface
     * RECTL                        rDest;              // dest rect
     * LPDDRAWI_DDRAWSURFACE_LCL    lpDDSrcSurface;     // src surface
     * RECTL                        rSrc;               // src rect
     * DWORD                        dwFlags;            // flags
     * DDOVERLAYFX                  overlayFX;          // overlay FX
     * HRESULT                      ddRVal;             // return value
     * LPDDHALSURFCB_UPDATEOVERLAY  UpdateOverlay;      // PRIVATE: ptr to callback
     */

    DISPDBG ((DBGLVL,"**In UpdateOverlay32"));

    lpSrcSurf = puod->lpDDSrcSurface;

    /*
     * In the LPDDRAWI_DDRAWSURFACE_LCL, we have the following cool data,
     * making life much easier:
     * 
     * HOWEVER! It appears that UpdateOverlay32 is called before any of these
     * values are changed, so use the values passed in instead.
     * 
     * DDCOLORKEY                       ddckCKSrcOverlay;       // color key for source overlay use
     * DDCOLORKEY                       ddckCKDestOverlay;      // color key for destination overlay use
     * LPDDRAWI_DDRAWSURFACE_INT        lpSurfaceOverlaying;    // surface we are overlaying
     * DBLNODE                          dbnOverlayNode;
     * 
     * //
     * //overlay rectangle, used by DDHEL
     * //
     * RECT                             rcOverlaySrc;
     * RECT                             rcOverlayDest;
     * //
     * //the below values are kept here for ddhel. they're set by UpdateOverlay,
     * //they're used whenever the overlays are redrawn.
     * //
     * DWORD                            dwClrXparent;           // the *actual* color key (override, colorkey, or CLR_INVALID)
     * DWORD                            dwAlpha;                // the per surface alpha
     * //
     * //overlay position
     * //
     * LONG                             lOverlayX;              // current x position
     * LONG                             lOverlayY;              // current y position
     */


#if DBG
    // Standard integrity test.
    if ( pThisDisplay->bOverlayVisible == 0 )
    {
        if ( (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl != NULL )
        {
            // If overlay is not visible, the current surface should be NULL.
            DISPDBG((DBGLVL,"** UpdateOverlay32 - vis==0,srcsurf!=NULL"));
        }
    }
    else
    {
        if ( (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl == NULL )
        {
            // If overlay is visible, the current surface should not be NULL.
            DISPDBG((DBGLVL,"** UpdateOverlay32 - vis!=0,srcsurf==NULL"));
        }
    }

#endif //DBG

    if ( ( puod->dwFlags & DDOVER_HIDE ) != 0 )
    {

        DISPDBG((DBGLVL,"** UpdateOverlay32 - hiding."));

        // Hide the overlay.
        if ( pThisDisplay->bOverlayVisible == 0 )
        {
            // No overlay being shown.
            DISPDBG((WRNLVL,"** UpdateOverlay32 - DDOVER_HIDE - already hidden."));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }
        if ( pThisDisplay->OverlaySrcSurfLcl != (ULONG_PTR)lpSrcSurf )
        {
            // This overlay isn't being shown.
            DISPDBG((WRNLVL,"** UpdateOverlay32 - DDOVER_HIDE - not current overlay surface."));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }


        // Stop any autoflipping.
        if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
        {
#if DBG
            if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
            {
                DISPDBG((WRNLVL,"** UpdateOverlay32 - DDOVER_HIDE - was autoflipping on bogus event handle."));
            }
#endif
            pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
            pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
            DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - autoflipping now disabled."));
        }

        if ( pThisDisplay->pGLInfo->dwPeriodMonitorVBL != 0 )
        {
            if ( pThisDisplay->pGLInfo->dwMonitorEventHandle == (DWORD)NULL )
            {
                DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - was autoupdating on bogus event handle."));
            }
            pThisDisplay->pGLInfo->dwPeriodMonitorVBL = 0;
            pThisDisplay->pGLInfo->dwCountdownMonitorVBL = 0;
            DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - autoupdate now disabled."));
        }


//      DISPDBG((DBGLVL,"** UpdateOverlay32 (hiding) destroying rect memory."));
        // Free the rect memory
        if ( (void *)pThisDisplay->OverlayClipRgnMem != NULL )
        {
            HEAP_FREE ((void *)pThisDisplay->OverlayClipRgnMem);
        }
        pThisDisplay->OverlayClipRgnMem     = (ULONG_PTR)NULL;
        pThisDisplay->OverlayClipRgnMemSize = (DWORD)0;
//      DISPDBG((DBGLVL,"** UpdateOverlay32 (hiding) destroyed rect memory."));


        pThisDisplay->bOverlayVisible           = FALSE;
        pThisDisplay->OverlayDstRectL           = (DWORD)0;
        pThisDisplay->OverlayDstRectR           = (DWORD)0;
        pThisDisplay->OverlayDstRectT           = (DWORD)0;
        pThisDisplay->OverlayDstRectB           = (DWORD)0;
        pThisDisplay->OverlaySrcRectL           = (DWORD)0;
        pThisDisplay->OverlaySrcRectR           = (DWORD)0;
        pThisDisplay->OverlaySrcRectT           = (DWORD)0;
        pThisDisplay->OverlaySrcRectB           = (DWORD)0;
        pThisDisplay->OverlayDstSurfLcl         = (ULONG_PTR)NULL;
        pThisDisplay->OverlaySrcSurfLcl         = (ULONG_PTR)NULL;
        pThisDisplay->OverlayDstColourKey       = (DWORD)CLR_INVALID;
        pThisDisplay->OverlaySrcColourKey       = (DWORD)CLR_INVALID;
        pThisDisplay->OverlayUpdateCountdown    = 0;
        pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)FALSE;
        pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)FALSE;

        pThisDisplay->pGLInfo->bOverlayEnabled              = (DWORD)FALSE;
        pThisDisplay->pGLInfo->dwOverlayRectL               = (DWORD)0;
        pThisDisplay->pGLInfo->dwOverlayRectR               = (DWORD)0;
        pThisDisplay->pGLInfo->dwOverlayRectT               = (DWORD)0;
        pThisDisplay->pGLInfo->dwOverlayRectB               = (DWORD)0;
        pThisDisplay->pGLInfo->bOverlayColourKeyEnabled     = (DWORD)FALSE;
        pThisDisplay->pGLInfo->dwOverlayDstColourKeyChip    = (DWORD)-1;
        pThisDisplay->pGLInfo->dwOverlayDstColourKeyFB      = (DWORD)-1;
        pThisDisplay->pGLInfo->dwOverlayAlphaSetFB          = (DWORD)-1;

        // Clean up the temporary buffer, if any.
        if ( pThisDisplay->OverlayTempSurf.VidMem != (ULONG_PTR)NULL )
        {
            FreeStretchBuffer ( pThisDisplay, pThisDisplay->OverlayTempSurf.VidMem );
            pThisDisplay->OverlayTempSurf.VidMem = (ULONG_PTR)NULL;
            pThisDisplay->OverlayTempSurf.Pitch  = (DWORD)0;
        }

        // Restart the 2D renderer with non-overlay functions.
        hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
        if ( hDC != NULL )
        {
            ExtEscape ( hDC, GLINT_OVERLAY_ESCAPE, 0, NULL, 0, NULL );
            DELETE_DRIVER_DC ( hDC );
        }
        else
        {
            DISPDBG((ERRLVL,"** UpdateOverlay32 - CREATE_DRIVER_DC failed"));
        }

        puod->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

    }
    else if ( ( ( puod->dwFlags & DDOVER_SHOW ) != 0 ) || ( pThisDisplay->bOverlayVisible != 0 ) )
    {

        {
            // Catch the dodgy call made by the Demon helper.
            // This is very bad, but it's the only way I can see to
            // get Demon to call these two functions.
            // Remember that the various surfaces and so on are just
            // to get DD to relax and accept life.
            // The first three numbers are just that - magic numbers,
            // and the last one shows which of a range of calls need to be made,
            // as well as being a magic number itself.
            if (
                ( ( puod->dwFlags & DDOVER_SHOW ) != 0 ) &&
                ( ( puod->dwFlags & DDOVER_KEYDESTOVERRIDE ) != 0 ) &&
                ( ( puod->dwFlags & DDOVER_DDFX ) != 0 ) )
            {
                // OK, looks like a valid call from Demon.
                if (
                    ( puod->overlayFX.dckDestColorkey.dwColorSpaceLowValue  == GLDD_MAGIC_AUTOFLIPOVERLAY_DL ) &&
                    ( puod->overlayFX.dckDestColorkey.dwColorSpaceHighValue == GLDD_MAGIC_AUTOFLIPOVERLAY_DH ) )
                {
                    puod->ddRVal = __VD_AutoflipOverlay();
                    // the return value is actually a benign DD error
                    // value, but GLDD_AUTO_RET_* are also aliased to the
                    // right one for useabiliy.
                    return DDHAL_DRIVER_HANDLED;
                }
                else if (
                    ( puod->overlayFX.dckDestColorkey.dwColorSpaceLowValue  == GLDD_MAGIC_AUTOUPDATEOVERLAY_DL ) &&
                    ( puod->overlayFX.dckDestColorkey.dwColorSpaceHighValue == GLDD_MAGIC_AUTOUPDATEOVERLAY_DH ) )
                {
                    puod->ddRVal = __VD_AutoupdateOverlay();
                    // the return value is actually a benign DD error
                    // value, but GLDD_AUTO_RET_* are also aliased to the
                    // right one for useabiliy.
                    return DDHAL_DRIVER_HANDLED;
                }
            }
        }


        DISPDBG((DBGLVL,"** UpdateOverlay32 - showing or reshowing."));


        // Either we need to show this, or it is already being shown.

        if ( ( pThisDisplay->bOverlayVisible != 0 ) && ( pThisDisplay->OverlaySrcSurfLcl != (ULONG_PTR)lpSrcSurf ) )
        {
            // Overlay being shown and source surfaces don't match.
            // i.e. someone else wants an overlay, but it's already in use.
            DISPDBG((DBGLVL,"** UpdateOverlay32 - overlay already being shown, returning DDERR_OUTOFCAPS"));
            puod->ddRVal = DDERR_OUTOFCAPS;
            return DDHAL_DRIVER_HANDLED;
        }



        // Clean up the temporary buffer, if any.
        if ( pThisDisplay->OverlayTempSurf.VidMem != (ULONG_PTR)NULL )
        {
            FreeStretchBuffer ( pThisDisplay, pThisDisplay->OverlayTempSurf.VidMem );
            pThisDisplay->OverlayTempSurf.VidMem = (ULONG_PTR)NULL;
            pThisDisplay->OverlayTempSurf.Pitch  = (DWORD)0;
        }

        // Store all the data in the display's data block.
        pThisDisplay->bOverlayVisible           = TRUE;
        pThisDisplay->OverlayDstRectL           = (DWORD)puod->rDest.left;
        pThisDisplay->OverlayDstRectR           = (DWORD)puod->rDest.right;
        pThisDisplay->OverlayDstRectT           = (DWORD)puod->rDest.top;
        pThisDisplay->OverlayDstRectB           = (DWORD)puod->rDest.bottom;
        pThisDisplay->OverlaySrcRectL           = (DWORD)puod->rSrc.left;
        pThisDisplay->OverlaySrcRectR           = (DWORD)puod->rSrc.right;
        pThisDisplay->OverlaySrcRectT           = (DWORD)puod->rSrc.top;
        pThisDisplay->OverlaySrcRectB           = (DWORD)puod->rSrc.bottom;
        pThisDisplay->OverlayDstSurfLcl         = (ULONG_PTR)puod->lpDDDestSurface;
        pThisDisplay->OverlaySrcSurfLcl         = (ULONG_PTR)lpSrcSurf;
        pThisDisplay->OverlayUpdateCountdown    = 0;
        pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)FALSE;
        pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)FALSE;
        pThisDisplay->OverlayDstColourKey       = (DWORD)CLR_INVALID;
        pThisDisplay->OverlaySrcColourKey       = (DWORD)CLR_INVALID;
        pThisDisplay->pGLInfo->bOverlayEnabled  = (DWORD)TRUE;


        // Make sure someone hasn't changed video mode behind our backs.
        // If an overlay is started in a 16-bit mode and then you change to
        // an 8-bit mode, the caps bits are rarely checked again,
        // and certainly not by DirectShow.
        if ( ( pThisDisplay->bPixShift != GLINTDEPTH16 ) &&
             ( pThisDisplay->bPixShift != GLINTDEPTH32 ) )
        {
            DISPDBG((WRNLVL,"** UpdateOverlay32 - overlay asked for in non-16 or non-32 bit mode. Returning DDERR_OUTOFCAPS"));
            goto update_overlay_outofcaps_cleanup;
        }


        #if 1
        // See if there is a clipper or not. If not, this is trying to fly over the
        // desktop instead of being bound in a window, so object nicely.
        if (    ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl) != NULL ) &&
                ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl)->lpSurfMore != NULL ) &&
                ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl)->lpSurfMore->lpDDIClipper != NULL ) )
        {
            // Yep, there's a clipper
        }
        else
        {
            // No clipper. Someone's doing a WHQL test! :-)
            DISPDBG((WRNLVL,"** UpdateOverlay32 - no clipper on dest surface, returning DDERR_OUTOFCAPS"));
            goto update_overlay_outofcaps_cleanup;
        }
        #endif

        
        #if 1
        {
            // Get the cliprect list, and see if it is larger than the
            // target rectangle. That is a pretty good indication of
            // Overfly (and indeed anything else that tries anything similar)
            LPRGNDATA lpRgn;
            int NumRects;
            LPRECT lpCurRect;

            lpRgn = GetOverlayVisibleRects ( pThisDisplay );
            if ( lpRgn != NULL )
            {
                // Got a clip region.
                NumRects = lpRgn->rdh.nCount;
                if ( NumRects > 0 )
                {
                    lpCurRect = (LPRECT)lpRgn->Buffer;
                    while ( NumRects > 0 )
                    {
                        // The +-5 is a fudge factor to cope with Xing's slight insanities.
                        if (    ( lpCurRect->left   < puod->rDest.left - 5 ) ||
                                ( lpCurRect->right  > puod->rDest.right + 5 ) ||
                                ( lpCurRect->top    < puod->rDest.top - 5 ) ||
                                ( lpCurRect->bottom > puod->rDest.bottom + 5 ) )
                        {
                            DISPDBG((WRNLVL,"** UpdateOverlay32 - out of range cliprect(s). Returning DDERR_OUTOFCAPS"));
                            goto update_overlay_outofcaps_cleanup;
                        }
                        // Next rect
                        NumRects--;
                        lpCurRect++;
                    }
                }
            }
        }
        #endif


        dwDstColourKey = CLR_INVALID;
        if ( puod->dwFlags & DDOVER_KEYDEST )
        {
            // Use destination surface's destination colourkey for dst key.
            dwDstColourKey = puod->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
        }
        if ( puod->dwFlags & DDOVER_KEYDESTOVERRIDE )
        {
            // Use DDOVERLAYFX dest colour for dst key.
            dwDstColourKey = puod->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
        }


        dwSrcColourKey = CLR_INVALID;
        if ( puod->dwFlags & DDOVER_KEYSRC )
        {
            // Use source surface's source colourkey for src key.
            dwSrcColourKey = puod->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
            DISPDBG((WRNLVL,"UpdateOverlay32:ERROR! Cannot do source colour key on overlays."));
        }
        if ( puod->dwFlags & DDOVER_KEYSRCOVERRIDE )
        {
            // Use DDOVERLAYFX src colour for src key.
            dwSrcColourKey = puod->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
            DISPDBG((WRNLVL,"UpdateOverlay32:ERROR! Cannot do source colour key overrides on overlays."));
        }


        if ( dwDstColourKey != CLR_INVALID )
        {
            DWORD dwChipColourKey;
            DWORD dwFBColourKey;
            DWORD dwFBAlphaSet;

            // Find the chip's colour key for this display mode.
            dwChipColourKey = (DWORD)-1;
            switch ( pThisDisplay->bPixShift )
            {
                case GLINTDEPTH16:
                    if ( pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00 )
                    {
                        // 5551 format, as it should be.
                        dwFBColourKey = ( puod->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue ) & 0xffff;
                        dwChipColourKey = CHROMA_LOWER_ALPHA(FORMAT_5551_32BIT_BGR(dwFBColourKey));
                        // Replicate in both words.
                        dwFBColourKey |= dwFBColourKey << 16;
                        dwFBAlphaSet = 0x80008000;
                    }
                    else
                    {
                        // 565 format. Oops.
                        DISPDBG((WRNLVL, "** UpdateOverlay32 error: called for a colourkeyed 565 surface."));
                    }
                    break;
                case GLINTDEPTH32:
                    dwFBColourKey = puod->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
                    dwChipColourKey = CHROMA_LOWER_ALPHA(FORMAT_8888_32BIT_BGR(dwFBColourKey));
                    dwFBAlphaSet = 0xff000000;
                    break;
                case GLINTDEPTH8:
                case GLINTDEPTH24:
                default:
                    DISPDBG((WRNLVL, "** UpdateOverlay32 error: called for an 8, 24 or unknown surface bPixShift=%d", pThisDisplay->bPixShift));
                    DISPDBG((ERRLVL,"** UpdateOverlay32 error: see above."));
                    goto update_overlay_outofcaps_cleanup;
                    break;
            }


            if ( dwChipColourKey == (DWORD)-1 )
            {
                DISPDBG((WRNLVL,"UpdateOverlay32:ERROR:Cannot do overlay dest colour keying..."));
                DISPDBG((WRNLVL,"...in anything but 5551 or 8888 mode - returning DDERR_OUTOFCAPS"));
                goto update_overlay_outofcaps_cleanup;
            }

            pThisDisplay->pGLInfo->bOverlayEnabled              = (DWORD)TRUE;
            pThisDisplay->pGLInfo->dwOverlayDstColourKeyFB      = dwFBColourKey;
            pThisDisplay->pGLInfo->dwOverlayDstColourKeyChip    = dwChipColourKey;
            pThisDisplay->pGLInfo->bOverlayColourKeyEnabled     = (DWORD)TRUE;
            pThisDisplay->pGLInfo->dwOverlayAlphaSetFB          = dwFBAlphaSet;

            // Try to allocate the temporary buffer needed for colourkey stuff.
            pThisDisplay->OverlayTempSurf.VidMem = AllocStretchBuffer (pThisDisplay,
                                                            (pThisDisplay->OverlayDstRectR - pThisDisplay->OverlayDstRectL),    // width
                                                            (pThisDisplay->OverlayDstRectB - pThisDisplay->OverlayDstRectT),    // height
                                                            DDSurf_GetChipPixelSize((LPDDRAWI_DDRAWSURFACE_LCL)(pThisDisplay->OverlayDstSurfLcl)),          // PixelSize
                                                            (ULONG_PTR)((LPDDRAWI_DDRAWSURFACE_LCL)(pThisDisplay->OverlayDstSurfLcl))->ddsCaps.dwCaps,
                                                            (int*)&(pThisDisplay->OverlayTempSurf.Pitch));
            if ( pThisDisplay->OverlayTempSurf.VidMem == (ULONG_PTR)NULL )
            {
                // Not enough space - have to fail the overlay
                DISPDBG((WRNLVL,"UpdateOverlay32:ERROR: not enough memory for buffer - returning DDERR_OUTOFCAPS"));
                pThisDisplay->OverlayTempSurf.Pitch = (DWORD)0;
                goto update_overlay_outofcaps_cleanup;
            }

            // Restart the 2D renderer with overlay functions.
            hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
            if ( hDC != NULL )
            {
                ExtEscape ( hDC, GLINT_OVERLAY_ESCAPE, 0, NULL, 0, NULL );
                DELETE_DRIVER_DC ( hDC );
            }
            else
            {
                DISPDBG((ERRLVL,"** UpdateOverlay32 - CREATE_DRIVER_DC failed"));
            }

            // update the alpha channel
            UpdateAlphaOverlay ( pThisDisplay );
            pThisDisplay->OverlayUpdateCountdown = OVERLAY_UPDATE_WAIT;
        }
        else
        {
            // No colour key, just an overlay.
            pThisDisplay->pGLInfo->bOverlayEnabled              = (DWORD)TRUE;
            pThisDisplay->pGLInfo->bOverlayColourKeyEnabled     = (DWORD)FALSE;
            pThisDisplay->pGLInfo->dwOverlayDstColourKeyChip    = (DWORD)-1;
            pThisDisplay->pGLInfo->dwOverlayDstColourKeyFB      = (DWORD)-1;
            pThisDisplay->pGLInfo->dwOverlayAlphaSetFB          = (DWORD)-1;

            // Restart the 2D renderer with non-overlay functions.
            hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
            if ( hDC != NULL )
            {
                ExtEscape ( hDC, GLINT_OVERLAY_ESCAPE, 0, NULL, 0, NULL );
                DELETE_DRIVER_DC ( hDC );
            }
            else
            {
                DISPDBG((ERRLVL,"** UpdateOverlay32 - CREATE_DRIVER_DC failed"));
            }
        }

        // Safely got any memory required, so we can set these up now.
        pThisDisplay->OverlayDstColourKey = dwDstColourKey;
        pThisDisplay->OverlaySrcColourKey = dwSrcColourKey;

        pThisDisplay->pGLInfo->dwOverlayRectL = pThisDisplay->OverlayDstRectL;
        pThisDisplay->pGLInfo->dwOverlayRectR = pThisDisplay->OverlayDstRectR;
        pThisDisplay->pGLInfo->dwOverlayRectT = pThisDisplay->OverlayDstRectT;
        pThisDisplay->pGLInfo->dwOverlayRectB = pThisDisplay->OverlayDstRectB;


        // Do the update itself.
        P3TestDrawOverlay ( pThisDisplay, lpSrcSurf, FALSE );

        pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)TRUE;

        if ( ( puod->dwFlags & DDOVER_AUTOFLIP ) == 0 )
        {
            // Start or continue any autoupdates - this is not autoflipping.
    #if DBG
            if ( pThisDisplay->pGLInfo->dwMonitorEventHandle == (DWORD)NULL )
            {
                DISPDBG((WRNLVL,"** UpdateOverlay32 - trying to autoupdate using bogus event handle."));
            }
    #endif
            if ( pThisDisplay->pGLInfo->dwPeriodMonitorVBL == 0 )
            {
                pThisDisplay->pGLInfo->dwPeriodMonitorVBL = OVERLAY_AUTOUPDATE_CYCLE_PERIOD;
                pThisDisplay->pGLInfo->dwCountdownMonitorVBL = OVERLAY_AUTOUPDATE_RESET_PERIOD;
                DISPDBG((DBGLVL,"** UpdateOverlay32 - autoupdate now enabled."));
            }
        }
        else
        {
            // This autoflips - stop any autoupdates.
            if ( pThisDisplay->pGLInfo->dwPeriodMonitorVBL != 0 )
            {
                pThisDisplay->pGLInfo->dwPeriodMonitorVBL = 0;
                pThisDisplay->pGLInfo->dwCountdownMonitorVBL = 0;
                DISPDBG((DBGLVL,"** UpdateOverlay32 - autoupdate now disabled because of autoflipping."));
            }
        }


        // And tell the world about it
        DISPDBG((DBGLVL,"** In UpdateOverlay32"));
        DISPDBG((DBGLVL,"** ...Src rect %d,%d -> %d,%d", pThisDisplay->OverlaySrcRectL, pThisDisplay->OverlaySrcRectT, pThisDisplay->OverlaySrcRectR, pThisDisplay->OverlaySrcRectB ));
        DISPDBG((DBGLVL,"** ...Dst rect %d,%d -> %d,%d", pThisDisplay->OverlayDstRectL, pThisDisplay->OverlayDstRectT, pThisDisplay->OverlayDstRectR, pThisDisplay->OverlayDstRectB ));
        DISPDBG((DBGLVL,"** ...Src colour key 0x%08x, dst colour key 0x%08x", pThisDisplay->OverlaySrcColourKey, pThisDisplay->OverlayDstColourKey ));

    }


    puod->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;



update_overlay_outofcaps_cleanup:
    // This cleans up after any partial setup, and returns DDERR_OUTOFCAPS.
    // It's a clean and easy way of failing at any stage.

    DISPDBG((DBGLVL,"** UpdateOverlay32 - cleaning up and returning DDERR_OUTOFCAPS."));

    // Stop any autoflipping.
    if ( pThisDisplay->pGLInfo->dwPeriodVideoVBL != 0 )
    {
#if DBG
        if ( pThisDisplay->pGLInfo->dwVideoEventHandle == (DWORD)NULL )
        {
            DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - was autoflipping on bogus event handle."));
        }
#endif
        pThisDisplay->pGLInfo->dwPeriodVideoVBL = 0;
        pThisDisplay->pGLInfo->dwCountdownVideoVBL = 0;
        DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - autoflipping now disabled."));
    }

    if ( pThisDisplay->pGLInfo->dwPeriodMonitorVBL != 0 )
    {
#if DBG
        if ( pThisDisplay->pGLInfo->dwMonitorEventHandle == (DWORD)NULL )
        {
            DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - was autoupdating on bogus event handle."));
        }
#endif
        pThisDisplay->pGLInfo->dwPeriodMonitorVBL = 0;
        pThisDisplay->pGLInfo->dwCountdownMonitorVBL = 0;
        DISPDBG((DBGLVL,"** UpdateOverlay32 - DDOVER_HIDE - autoupdate now disabled."));
    }


    // Free the rect memory
    if ( (void *)pThisDisplay->OverlayClipRgnMem != NULL )
    {
        HEAP_FREE ((void *)pThisDisplay->OverlayClipRgnMem);
    }
    pThisDisplay->OverlayClipRgnMem     = (ULONG_PTR)NULL;
    pThisDisplay->OverlayClipRgnMemSize = (DWORD)0;


    pThisDisplay->bOverlayVisible           = FALSE;
    pThisDisplay->OverlayDstRectL           = (DWORD)0;
    pThisDisplay->OverlayDstRectR           = (DWORD)0;
    pThisDisplay->OverlayDstRectT           = (DWORD)0;
    pThisDisplay->OverlayDstRectB           = (DWORD)0;
    pThisDisplay->OverlaySrcRectL           = (DWORD)0;
    pThisDisplay->OverlaySrcRectR           = (DWORD)0;
    pThisDisplay->OverlaySrcRectT           = (DWORD)0;
    pThisDisplay->OverlaySrcRectB           = (DWORD)0;
    pThisDisplay->OverlayDstSurfLcl         = (ULONG_PTR)NULL;
    pThisDisplay->OverlaySrcSurfLcl         = (ULONG_PTR)NULL;
    pThisDisplay->OverlayDstColourKey       = (DWORD)CLR_INVALID;
    pThisDisplay->OverlaySrcColourKey       = (DWORD)CLR_INVALID;
    pThisDisplay->OverlayUpdateCountdown    = 0;
    pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)FALSE;
    pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)FALSE;

    pThisDisplay->pGLInfo->bOverlayEnabled              = (DWORD)FALSE;
    pThisDisplay->pGLInfo->dwOverlayRectL               = (DWORD)0;
    pThisDisplay->pGLInfo->dwOverlayRectR               = (DWORD)0;
    pThisDisplay->pGLInfo->dwOverlayRectT               = (DWORD)0;
    pThisDisplay->pGLInfo->dwOverlayRectB               = (DWORD)0;
    pThisDisplay->pGLInfo->bOverlayColourKeyEnabled     = (DWORD)FALSE;
    pThisDisplay->pGLInfo->dwOverlayDstColourKeyChip    = (DWORD)-1;
    pThisDisplay->pGLInfo->dwOverlayDstColourKeyFB      = (DWORD)-1;
    pThisDisplay->pGLInfo->dwOverlayAlphaSetFB          = (DWORD)-1;

    // Clean up the temporary buffer, if any.
    if ( pThisDisplay->OverlayTempSurf.VidMem != (ULONG_PTR)NULL )
    {
        FreeStretchBuffer ( pThisDisplay, pThisDisplay->OverlayTempSurf.VidMem );
        pThisDisplay->OverlayTempSurf.VidMem = (ULONG_PTR)NULL;
        pThisDisplay->OverlayTempSurf.Pitch  = (DWORD)0;
    }

    // Restart the 2D renderer with non-overlay functions.
    hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
    if ( hDC != NULL )
    {
        ExtEscape ( hDC, GLINT_OVERLAY_ESCAPE, 0, NULL, 0, NULL );
        DELETE_DRIVER_DC ( hDC );
    }
    else
    {
        DISPDBG((ERRLVL,"** UpdateOverlay32 - CREATE_DRIVER_DC failed"));
    }

    puod->ddRVal = DDERR_OUTOFCAPS;
    return DDHAL_DRIVER_HANDLED;

}

DWORD CALLBACK SetOverlayPosition32(LPDDHAL_SETOVERLAYPOSITIONDATA psopd)
{

    P3_THUNKEDDATA*       pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, psopd->lpDD);

//  /*
//   * A psopd looks like this:
//   * 
//   * LPDDRAWI_DIRECTDRAW_GBL      lpDD;               // driver struct
//   * LPDDRAWI_DDRAWSURFACE_LCL    lpDDSrcSurface;     // src surface
//   * LPDDRAWI_DDRAWSURFACE_LCL    lpDDDestSurface;    // dest surface
//   * LONG                         lXPos;              // x position
//   * LONG                         lYPos;              // y position
//   * HRESULT                      ddRVal;             // return value
//   * LPDDHALSURFCB_SETOVERLAYPOSITION SetOverlayPosition; // PRIVATE: ptr to callback
//   */

#if DBG
    // Standard integrity test.
    if ( pThisDisplay->bOverlayVisible == 0 )
    {
        if ( (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl != NULL )
        {
            // If overlay is not visible, the current surface should be NULL.
            DISPDBG((DBGLVL,"** SetOverlayPosition32 - vis==0,srcsurf!=NULL"));
        }
    }
    else
    {
        if ( (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl == NULL )
        {
            // If overlay is visible, the current surface should not be NULL.
            DISPDBG((DBGLVL,"** SetOverlayPosition32 - vis!=0,srcsurf==NULL"));
        }
    }
#endif //DBG


    if ( pThisDisplay->bOverlayVisible == 0 )
    {
        // No overlay is visible.
        psopd->ddRVal = DDERR_OVERLAYNOTVISIBLE;
        return DDHAL_DRIVER_HANDLED;
    }
    if ( pThisDisplay->OverlaySrcSurfLcl != (ULONG_PTR)psopd->lpDDSrcSurface )
    {
        // This overlay isn't visible.
        psopd->ddRVal = DDERR_OVERLAYNOTVISIBLE;
        return DDHAL_DRIVER_HANDLED;
    }

#if DBG
    if ( pThisDisplay->OverlayDstSurfLcl != (ULONG_PTR)psopd->lpDDDestSurface )
    {
        // Oh dear. The destination surfaces don't agree.
        DISPDBG((DBGLVL,"** SetOverlayPosition32 - dest surfaces don't agree"));
    }
#endif //DBG

    // Move the rect
    pThisDisplay->OverlayDstRectR       += (DWORD)( psopd->lXPos - (LONG)pThisDisplay->OverlayDstRectL );
    pThisDisplay->OverlayDstRectB       += (DWORD)( psopd->lYPos - (LONG)pThisDisplay->OverlayDstRectT );
    pThisDisplay->OverlayDstRectL       = (DWORD)psopd->lXPos;
    pThisDisplay->OverlayDstRectT       = (DWORD)psopd->lYPos;

    pThisDisplay->pGLInfo->dwOverlayRectL = pThisDisplay->OverlayDstRectL;
    pThisDisplay->pGLInfo->dwOverlayRectR = pThisDisplay->OverlayDstRectR;
    pThisDisplay->pGLInfo->dwOverlayRectT = pThisDisplay->OverlayDstRectT;
    pThisDisplay->pGLInfo->dwOverlayRectB = pThisDisplay->OverlayDstRectB;


    if ( pThisDisplay->OverlayDstColourKey != CLR_INVALID )
    {
        // update the alpha channel
        UpdateAlphaOverlay ( pThisDisplay );
        pThisDisplay->OverlayUpdateCountdown = OVERLAY_UPDATE_WAIT;
    }

    // Do the update itself.
    P3TestDrawOverlay ( pThisDisplay, psopd->lpDDSrcSurface, FALSE );

    pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)TRUE;


    // And tell the world about it
    DISPDBG((DBGLVL,"** In SetOverlayPosition32"));
    DISPDBG((DBGLVL,"** ...Dst rect %d,%d -> %d,%d", pThisDisplay->OverlayDstRectL, pThisDisplay->OverlayDstRectT, pThisDisplay->OverlayDstRectR, pThisDisplay->OverlayDstRectB ));

    psopd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

}




/****************************************************************************
 *
 * LPRGNDATA GetOverlayVisibleRects ( P3_THUNKEDDATA* pThisDisplay );
 * 
 * In:
 *      P3_THUNKEDDATA* pThisDisplay;     This display's pointer
 * 
 * Out:
 *      LPRGNDATA;                      A pointer to the list of rects.
 * 
 * Notes:
 *      Returns a pointer to a list of rects that shows the visible
 * sections of the currently overlaid surface. This list is clipped by
 * the overlay's intended rectange, so no other bounds checking needs to
 * be done.
 *      Note that the memory returned is private and may only be read by
 * other functions. The actual memory is owned by
 * pThisDisplay->OverlayClipRgnMem, and should only be changed by this
 * function (or freed in selected other places). The memory may change
 * every time this function is called, or when various other overlay
 * functions are called.
 * 
 ***************************************************************************/

LPRGNDATA GetOverlayVisibleRects ( P3_THUNKEDDATA* pThisDisplay )
{

    // Use any clipper available.
    LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper;
    HRESULT                     hRes;
    int                         ClipSize;
    RECT                        rBound;

    rBound.left     = pThisDisplay->OverlayDstRectL;
    rBound.right    = pThisDisplay->OverlayDstRectR;
    rBound.top      = pThisDisplay->OverlayDstRectT;
    rBound.bottom   = pThisDisplay->OverlayDstRectB;

    // No WinWatch. Try doing an immediate call.
    lpDDIClipper = NULL;
    if ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl) != NULL )
    {
        if ( ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl)->lpSurfMore != NULL )
        {
            lpDDIClipper = ((LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl)->lpSurfMore->lpDDIClipper;
        }
    }
    if ( lpDDIClipper != NULL )
    {
#ifdef __cplusplus
        hRes = ((IDirectDrawClipper*)(lpDDIClipper->lpVtbl))->GetClipList (&rBound, NULL, (unsigned long*)&ClipSize );
#else
        hRes = ((IDirectDrawClipperVtbl *)(lpDDIClipper->lpVtbl))->GetClipList ( (IDirectDrawClipper *)lpDDIClipper, &rBound, NULL, &ClipSize );
#endif
        if ( hRes == DD_OK )
        {
            // Reallocate if need be.
            if ( ClipSize > (int)pThisDisplay->OverlayClipRgnMemSize )
            {
                if (pThisDisplay->OverlayClipRgnMem != 0 )
                {
                    HEAP_FREE ((void *)pThisDisplay->OverlayClipRgnMem);
                    pThisDisplay->OverlayClipRgnMem = 0;
                }
                pThisDisplay->OverlayClipRgnMem = (ULONG_PTR)HEAP_ALLOC (0, 
                                                                         ClipSize, 
                                                                         ALLOC_TAG_DX(F));
                if ( (void *)pThisDisplay->OverlayClipRgnMem == NULL )
                {
                    DISPDBG((ERRLVL,"ERROR: Flip32: Could not allocate heap memory for clip region"));
                    pThisDisplay->OverlayClipRgnMemSize = 0;
                    return ( NULL );
                }
                else
                {
                    pThisDisplay->OverlayClipRgnMemSize = ClipSize;
                }
            }

            if ( (void *)pThisDisplay->OverlayClipRgnMem != NULL )
            {
                // OK, got some good memory.
#ifdef __cplusplus
                hRes = ((IDirectDrawClipper*)(lpDDIClipper->lpVtbl))->GetClipList (&rBound, (LPRGNDATA)pThisDisplay->OverlayClipRgnMem, (unsigned long*)&ClipSize );
#else
                hRes = ((IDirectDrawClipperVtbl *)(lpDDIClipper->lpVtbl))->GetClipList ( (IDirectDrawClipper *)lpDDIClipper, &rBound, (LPRGNDATA)pThisDisplay->OverlayClipRgnMem, &ClipSize );
#endif
                if ( hRes != DD_OK )
                {
                    DISPDBG((ERRLVL,"ERROR: Flip32: GetClipList failed."));
                    return ( NULL );
                }
                else
                {
                    LPRECT      lpCurRect;
                    RECT        rBound;
                    int         NumRects;
                    LPRGNDATA   lpRgn;
                    // Adjust their bounding rect so it actually does bound all the
                    // rects.

                    lpRgn = (LPRGNDATA)pThisDisplay->OverlayClipRgnMem;
                    lpCurRect = (LPRECT)lpRgn->Buffer;
                    NumRects = lpRgn->rdh.nCount;
                    if ( NumRects > 0 )
                    {
                        rBound = *lpCurRect;

                        NumRects--;
                        lpCurRect++;

                        while ( NumRects > 0 )
                        {
                            if ( rBound.left > lpCurRect->left )
                            {
                                rBound.left = lpCurRect->left;
                            }
                            if ( rBound.top > lpCurRect->top )
                            {
                                rBound.top = lpCurRect->top;
                            }
                            if ( rBound.right < lpCurRect->right )
                            {
                                rBound.right = lpCurRect->right;
                            }
                            if ( rBound.bottom < lpCurRect->bottom )
                            {
                                rBound.bottom = lpCurRect->bottom;
                            }

                            NumRects--;
                            lpCurRect++;
                        }

                        #if DBG
                        // Were the two bounding rectangles the same?
                        if ( ( rBound.left != lpRgn->rdh.rcBound.left ) ||
                             ( rBound.right != lpRgn->rdh.rcBound.right ) ||
                             ( rBound.top != lpRgn->rdh.rcBound.top ) ||
                             ( rBound.bottom != lpRgn->rdh.rcBound.bottom ) )
                        {
                            DISPDBG((DBGLVL,"GetOverlayVisibleRects: area bounding box does not actually bound!"));
                            DISPDBG((DBGLVL,"My bounding rect %d,%d->%d,%d", rBound.left, rBound.top, rBound.right, rBound.bottom ));
                            DISPDBG((DBGLVL,"Their bounding rect %d,%d->%d,%d", lpRgn->rdh.rcBound.left, lpRgn->rdh.rcBound.top, lpRgn->rdh.rcBound.right, lpRgn->rdh.rcBound.bottom ));
                        }
                        #endif
                        lpRgn->rdh.rcBound = rBound;


                        // Phew - we finally got a clip region.
                        return ( (LPRGNDATA)pThisDisplay->OverlayClipRgnMem );
                    }
                    else
                    {
                        // No cliplist.
                        return ( NULL );
                    }
                }
            }
            else
            {
                return ( NULL );
            }
        }
        else
        {
            return ( NULL );
        }
    }

    return ( NULL );
}




/****************************************************************************
 *
 * DWORD GLDD__Autoflip_Overlay ( void );
 * 
 * In:
 *      None.
 * 
 * Out:
 *      Error code:
 *          GLDD_AUTO_RET_DID_UPDATE        = no error - did update.
 *          GLDD_AUTO_RET_ERR_GENERAL       = general error.
 *          GLDD_AUTO_RET_ERR_NO_OVERLAY    = no autoflipping overlay(s).
 * 
 * Notes:
 *      This is called by the Demon helper program that sits waiting for
 * video-in VBLANKS, then calls this.
 *      This flips the current overlay if it is marked as autoflipping. If
 * there is such an overlay, it returns 0, otherwise it returns 1.
 * 
 ***************************************************************************/

DWORD CALLBACK __VD_AutoflipOverlay ( void )
{

    P3_THUNKEDDATA*               pThisDisplay;
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;
    LPDDRAWI_DDRAWSURFACE_LCL   pCurSurf;
    DDHAL_FLIPVPORTDATA         ddhFVPD;

    // This is hard-coded and doesn't on work multi-monitors.
    // But then nothing does, so...
    pThisDisplay = g_pDriverData;

    DISPDBG((DBGLVL,"**In __VD_AutoflipOverlay"));

    if ( pThisDisplay->VidPort.bActive )
    {
        // Video port is active.


        // Find the buffer to show.
        pCurSurf = pThisDisplay->VidPort.lpSurf [ pThisDisplay->VidPort.dwCurrentHostFrame ];
        if ( pCurSurf == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoflipOverlay: pCurSurf is NULL."));
            return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
        }
        if ( pCurSurf->lpGbl == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoflipOverlay: lpGbl is NULL."));
            return ( GLDD_AUTO_RET_ERR_GENERAL );
        }
        lpDD = pCurSurf->lpGbl->lpDD;
        if ( lpDD == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoflipOverlay: lpDD is NULL."));
            return ( GLDD_AUTO_RET_ERR_GENERAL );
        }


        DISPDBG((DBGLVL,"__VD_AutoflipOverlay: GetDriverLock succeeded."));


        // Find the current front surface.
        pCurSurf = pThisDisplay->VidPort.lpSurf [ pThisDisplay->VidPort.dwCurrentHostFrame ];

        P3TestDrawOverlay ( pThisDisplay, pCurSurf, TRUE );

        pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)TRUE;

        // And then flip.
        // Fake up an LPDDHAL_FLIPVPORTDATA.
        // Only item ever used is lpDD.
        g_bFlipVideoPortDoingAutoflip = TRUE;
        ddhFVPD.lpDD = pCurSurf->lpSurfMore->lpDD_lcl;
        DdFlipVideoPort ( &ddhFVPD );
        g_bFlipVideoPortDoingAutoflip = FALSE;

        return ( GLDD_AUTO_RET_DID_UPDATE );
    }
    else
    {
        DISPDBG((DBGLVL,"ERROR:__VD_AutoflipOverlay: video port not active."));
        return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
    }
}





/****************************************************************************
 *
 * DWORD __VD_AutoupdateOverlay ( void );
 * 
 * In:
 *      None.
 * 
 * Out:
 *      Error code:
 *          GLDD_AUTO_RET_NO_UPDATE         = no need to do update.
 *          GLDD_AUTO_RET_DID_UPDATE        = did update.
 *          GLDD_AUTO_RET_ERR_GENERAL       = general error.
 *          GLDD_AUTO_RET_ERR_NO_OVERLAY    = no standard overlay(s).
 * 
 * Notes:
 *      This is called by the Demon helper program that sits waiting for
 * monitor VBLANKS, then calls this.
 *      This checks any non-autoflipping overlay(s), and if they have not
 * been flipped or updated this VBL, it redraws them. Then it resets the
 * VBL flags.
 * 
 ***************************************************************************/

DWORD CALLBACK __VD_AutoupdateOverlay ( void )
{

    P3_THUNKEDDATA*               pThisDisplay;
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;
    LPDDRAWI_DDRAWSURFACE_LCL   pCurSurf;
    DWORD                       iRet;



    // This is hard-coded and doesn't on work multi-monitors.
    // But then nothing does, so...
    pThisDisplay = g_pDriverData;

    if ( pThisDisplay->VidPort.bActive )
    {
        // Video port is active.
        DISPDBG((WRNLVL,"ERROR:__VD_AutoupdateOverlay: video port is active."));
        return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
    }
    else
    {
        // Find the buffer to show.
        pCurSurf = (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlaySrcSurfLcl;
        if ( pCurSurf == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoupdateOverlay: pCurSurf is NULL."));
            return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
        }
        if ( pCurSurf->lpGbl == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoupdateOverlay: lpGbl is NULL."));
            return ( GLDD_AUTO_RET_ERR_NO_OVERLAY );
        }
        lpDD = pCurSurf->lpGbl->lpDD;
        if ( lpDD == NULL )
        {
            DISPDBG((WRNLVL,"ERROR:__VD_AutoupdateOverlay: lpDD is NULL."));
            return ( GLDD_AUTO_RET_ERR_GENERAL );
        }

        // See if the overlay needs showing.
        if ( pThisDisplay->bOverlayFlippedThisVbl || pThisDisplay->bOverlayUpdatedThisVbl )
        {
            // Already done.
            pThisDisplay->bOverlayFlippedThisVbl = FALSE;
            pThisDisplay->bOverlayUpdatedThisVbl = FALSE;
            iRet = GLDD_AUTO_RET_NO_UPDATE;
        }
        else
        {

            // OK, draw this.
            P3TestDrawOverlay ( pThisDisplay, pCurSurf, TRUE );

            // And clear the flags.
            pThisDisplay->bOverlayFlippedThisVbl = FALSE;
            pThisDisplay->bOverlayUpdatedThisVbl = FALSE;
            iRet = GLDD_AUTO_RET_DID_UPDATE;

        }


        return ( iRet );
    }
}






/****************************************************************************
 *
 * void DrawOverlay (   P3_THUNKEDDATA* pThisDisplay,
 *                      LPDDRAWI_DDRAWSURFACE_LCL lpSurfOverlay,
 *                      BOOL bSpeed );
 * 
 * In:
 *      P3_THUNKEDDATA* pThisDisplay;                 This display's pointer
 *      LPDDRAWI_DDRAWSURFACE_LCL lpSurfOverlay;    The overlay surface to draw.
 *      BOOL bSpeed;                                TRUE if this is a speedy call.
 * 
 * Out:
 *      None.
 * 
 * Notes:
 *      Takes the data in pThisDisplay and draws lpSurfOverlay onto
 * its overlayed surface. All the other data comes from lpSurfOverlay.
 * This allows you to call this from Flip32() without kludging the source
 * surface pointer.
 *      This will find the cliprect list of the clipper attached to the
 * overlaid surface, clipped by the overlay rectangle.. If there is no
 * clipper, it just uses the rectangle of the overlay.
 *      The next operation depends on which colour keys are set:
 *      If no colour keys are set, the rects are just blitted on.
 *      If the destination colour key is set, three blits are done.
 * The first stretches the YUV buffer to its final size. The second converts
 * any of the given colour key to set its alpha bits. The third puts
 * the overlay surface onto the screen where the alpha bits have been set,
 * settign the alpha bits as it does so.
 *      If you cross your fingers and wish very very hard, this might
 * actually work. It depends on nothing writing anything but 0 to the
 * alpha bits, and on having alpha bits in the first place.
 *      bSpeed will be TRUE if we are aiming for out-and-out speed,
 * otherwise the aim is to look pretty with as few artefacts as possible.
 * Generally, speed tests are done single-buffered, so a call from
 * Unlock32() will pass TRUE. Pretty tests are done with single-buffering,
 * so Flip32() will pass FALSE. This is only a general guide, and some
 * apps don't know about double-buffering at all. Such is life.
 * 
 ***************************************************************************/

void DrawOverlay ( P3_THUNKEDDATA* pThisDisplay, LPDDRAWI_DDRAWSURFACE_LCL lpSurfOverlay, BOOL bSpeed )
{

    RECTL                       rOverlay;
    RECTL                       rTemp;
    RECTL                       rFB;
    LPDDRAWI_DDRAWSURFACE_LCL   pOverlayLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pOverlayGbl;
    DDRAWI_DDRAWSURFACE_LCL     TempLcl;
    DDRAWI_DDRAWSURFACE_GBL     TempGbl;
    LPDDRAWI_DDRAWSURFACE_LCL   pFBLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pFBGbl;
    P3_SURF_FORMAT*               pFormatOverlay;
    P3_SURF_FORMAT*               pFormatTemp;
    P3_SURF_FORMAT*               pFormatFB;
    DWORD                       localfpVidMem;
    LONG                        localPitch;
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;
    DWORD                       dwColourKeyValue;
    DWORD                       dwAlphaMask;
    DWORD                       windowBaseOverlay;
    DWORD                       windowBaseFB;
    DWORD                       windowBaseTemp;
    float                       OffsetX, OffsetY;
    float                       ScaleX, ScaleY;
    float                       fTemp;
    int                         NumRects;
    LPRECT                      lpCurRect;
    LPRGNDATA                   lpRgn;
    DWORD                       dwCurrentIndex, dwStartTime;
    DWORD                       xScale;
    DWORD                       yScale;
    DWORD                       DestWidth;
    DWORD                       DestHeight;
    DWORD                       SourceWidth;
    DWORD                       SourceHeight;
    DWORD                       LowerBound;
    DWORD                       UpperBound;
    RECT                        TempRect;



    P3_DMA_DEFS();

    // Find the clipping rectangles for the overlay.
    lpRgn = GetOverlayVisibleRects ( pThisDisplay );
    if ( lpRgn != NULL )
    {

        pOverlayLcl             = lpSurfOverlay;
        pFBLcl                  = (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl;

        lpDD = lpSurfOverlay->lpGbl->lpDD;

        // Find the scale and offset from screen rects to overlay rects.
        ScaleX = (float)( pThisDisplay->OverlaySrcRectR - pThisDisplay->OverlaySrcRectL ) / (float)( pThisDisplay->OverlayDstRectR - pThisDisplay->OverlayDstRectL );
        ScaleY = (float)( pThisDisplay->OverlaySrcRectB - pThisDisplay->OverlaySrcRectT ) / (float)( pThisDisplay->OverlayDstRectB - pThisDisplay->OverlayDstRectT );
        OffsetX = ( (float)pThisDisplay->OverlaySrcRectL / ScaleX ) - (float)pThisDisplay->OverlayDstRectL;
        OffsetY = ( (float)pThisDisplay->OverlaySrcRectT / ScaleY ) - (float)pThisDisplay->OverlayDstRectT;

        rFB.left    = lpRgn->rdh.rcBound.left;
        rFB.right   = lpRgn->rdh.rcBound.right;
        rFB.top     = lpRgn->rdh.rcBound.top;
        rFB.bottom  = lpRgn->rdh.rcBound.bottom;

        // Find the size of the screen bounding box.
        if ( lpRgn->rdh.rcBound.left != (int)pThisDisplay->OverlayDstRectL )
        {
            fTemp = ( ( (float)lpRgn->rdh.rcBound.left  + OffsetX ) * ScaleX + 0.499f );
            myFtoi ( (int*)&(rOverlay.left), fTemp );
        }
        else
        {
            rOverlay.left = (int)pThisDisplay->OverlaySrcRectL;
        }

        if ( lpRgn->rdh.rcBound.right != (int)pThisDisplay->OverlayDstRectR )
        {
            fTemp = ( ( (float)lpRgn->rdh.rcBound.right + OffsetX ) * ScaleX + 0.499f );
            myFtoi ( (int*)&(rOverlay.right), fTemp );
        }
        else
        {
            rOverlay.right = (int)pThisDisplay->OverlaySrcRectR;
        }

        if ( lpRgn->rdh.rcBound.top != (int)pThisDisplay->OverlayDstRectT )
        {
            fTemp = ( ( (float)lpRgn->rdh.rcBound.top   + OffsetY ) * ScaleY + 0.499f );
            myFtoi ( (int*)&(rOverlay.top), fTemp );
        }
        else
        {
            rOverlay.top = (int)pThisDisplay->OverlaySrcRectT;
        }

        if ( lpRgn->rdh.rcBound.bottom = (int)pThisDisplay->OverlayDstRectB )
        {
            fTemp = ( ( (float)lpRgn->rdh.rcBound.bottom    + OffsetY ) * ScaleY + 0.499f );
            myFtoi ( (int*)&(rOverlay.bottom), fTemp );
        }
        else
        {
            rOverlay.bottom = pThisDisplay->OverlaySrcRectB;
        }


        // Sync with the specific source surface.

        // Videoport playing?
        if ( ( pThisDisplay->VidPort.bActive == TRUE ) &&
             ( ( pOverlayLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) != 0 ) )
        {

            dwStartTime = timeGetTime();
            while ( TRUE )
            {
                dwCurrentIndex = READ_GLINT_CTRL_REG(VSAVideoAddressIndex);
                if (pThisDisplay->VidPort.dwCurrentHostFrame == dwCurrentIndex)
                {
                    // If the videoport is not stuck we are still drawing
                    if (!__VD_CheckVideoPortStatus(pThisDisplay, FALSE))
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }

                // Have we timed out?
                if ( ( timeGetTime() - dwStartTime ) > OVERLAY_VIDEO_PORT_TIMEOUT )
                {
                    return;
                }
            }
        }
        else
        {
            // Not a videoport blit, so wait for the framebuffer flip
            // status to be good.
//@@BEGIN_DDKSPLIT            
            // Not actually sure if we want this in or not.
//@@END_DDKSPLIT            
            {
                HRESULT ddrval;

                do
                {
                    ddrval = _DX_QueryFlipStatus(pThisDisplay, pFBLcl->lpGbl->fpVidMem, TRUE );
                }
                while ( ddrval != DD_OK );
            }
        }




        if ( pThisDisplay->OverlayDstColourKey != CLR_INVALID )
        {
            // This is destination colourkeyed.
            rTemp.left              = 0;
            rTemp.right             = rFB.right - rFB.left;
            rTemp.top               = 0;
            rTemp.bottom            = rFB.bottom - rFB.top;




            if ( pThisDisplay->OverlayUpdateCountdown != 0 )
            {
                pThisDisplay->OverlayUpdateCountdown -= OVERLAY_DRAWOVERLAY_SPEED;
                if ( !bSpeed )
                {
                    // This is a pretty call, not a fast one.
                    pThisDisplay->OverlayUpdateCountdown -= ( OVERLAY_DRAWOVERLAY_PRETTY - OVERLAY_DRAWOVERLAY_SPEED );
                }

                if ( ( (signed int)pThisDisplay->OverlayUpdateCountdown ) <= 0 )
                {
                    // Update the overlay.
                    UpdateAlphaOverlay ( pThisDisplay );

                    // If you set this to 0, the overlay will never update again
                    // until a SetOverlayPosition() or UpdateOverlay32()
                    // Otherwise, set it to a positive value to update every now
                    // and then.
                    pThisDisplay->OverlayUpdateCountdown = OVERLAY_CYCLE_WAIT;
                }
            }


            VALIDATE_MODE_AND_STATE(pThisDisplay);

            // First stop dual cursor accesses
            // Must be done before switching to DD context.
            STOP_SOFTWARE_CURSOR(pThisDisplay);
            // Switch to DirectDraw context
            DDRAW_OPERATION(pContext, pThisDisplay);


            DISPDBG((DBGLVL,"** In DrawOverlay"));

            pOverlayGbl     = pOverlayLcl->lpGbl;
            pFBGbl          = pFBLcl->lpGbl;

            pFormatOverlay  = _DD_SUR_GetSurfaceFormat(pOverlayLcl);
            pFormatFB       = _DD_SUR_GetSurfaceFormat(pFBLcl);
            // Temp buffer will be same format as framebuffer.
            pFormatTemp     = pFormatFB;


            DISPDBG((DBGLVL, "Overlay Surface:"));
            DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pOverlayLcl);
            DISPDBG((DBGLVL, "FB Surface:"));
            DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pFBLcl);


            dwColourKeyValue = pThisDisplay->OverlayDstColourKey;
            switch ( pThisDisplay->bPixShift )
            {
                case GLINTDEPTH16:
                    if ( pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00 )
                    {
                        // 5551 format, as it should be.
                        dwAlphaMask = 0x8000;
                    }
                    else
                    {
                        // 565 format. Oops.
                        DISPDBG((WRNLVL, "** DrawOverlay error: called for a 565 surface"));
                        return;
                    }
                    break;
                case GLINTDEPTH32:
                    dwAlphaMask = 0xff000000;
                    break;
                case GLINTDEPTH8:
                case GLINTDEPTH24:
                default:
                    DISPDBG((WRNLVL, "** DrawOverlay error: called for an 8, 24 or unknown surface bPixShift=%d", pThisDisplay->bPixShift));
                    return;
                    break;
            }
        //  dwColourKeyValue &= ~dwAlphaMask;

            localfpVidMem = pThisDisplay->OverlayTempSurf.VidMem;
            localPitch = pThisDisplay->OverlayTempSurf.Pitch;
            if ( (void *)localfpVidMem == NULL )
            {
                // Nothing has been reserved for us! Panic stations!
                DISPDBG((ERRLVL,"ERROR: DrawOverlay has no temporary surface allocated."));
                return;
            }
            if ( localPitch < ( ( rTemp.right - rTemp.left ) << ( DDSurf_GetChipPixelSize(pFBLcl) ) ) )
            {
                // Reserved pitch is too small! Panic stations!
                DISPDBG((WRNLVL,"DrawOverlay has left,right %d,%d, and overlay has left,right %d,%d", rFB.left, rFB.right, pThisDisplay->OverlayDstRectL, pThisDisplay->OverlayDstRectR ));
                DISPDBG((WRNLVL,"ERROR: DrawOverlay has pitch %d and should be at least %d", localPitch, ( ( rTemp.right - rTemp.left ) << ( DDSurf_GetChipPixelSize(pFBLcl) ) ) ));
                DISPDBG((ERRLVL,"ERROR: DrawOverlay has pitch too small to be right."));
                return;
            }

            // Set the surface up.
            TempLcl = *pFBLcl;
            TempGbl = *(pFBLcl->lpGbl);
            TempLcl.lpGbl = &TempGbl;
            TempGbl.fpVidMem = localfpVidMem;
            
            DDSurf_Pitch(&TempLcl) = localPitch;

            // get bpp and pitches for surfaces.
            windowBaseOverlay   = __VD_PixelOffsetFromMemoryBase(pThisDisplay, pOverlayLcl);
            windowBaseFB        = __VD_PixelOffsetFromMemoryBase(pThisDisplay, pFBLcl);
            windowBaseTemp      = __VD_PixelOffsetFromMemoryBase(pThisDisplay, &TempLcl);

            // Do the colourspace conversion and stretch/shrink of the overlay
            {
                DestWidth = rTemp.right - rTemp.left;
                DestHeight = rTemp.bottom - rTemp.top;
                SourceWidth = rOverlay.right - rOverlay.left;
                SourceHeight = rOverlay.bottom - rOverlay.top;

                xScale = (SourceWidth << 20) / DestWidth;
                yScale = (SourceHeight << 20) / DestHeight;
                
                P3_DMA_GET_BUFFER();
                P3_ENSURE_DX_SPACE(80);

                WAIT_FIFO(40);

                SEND_P3_DATA(DitherMode, (COLOR_MODE << PM_DITHERMODE_COLORORDER) |
                                    (SURFFORMAT_FORMAT_BITS(pFormatTemp) << PM_DITHERMODE_COLORFORMAT) |
                                    (SURFFORMAT_FORMATEXTENSION_BITS(pFormatTemp) << PM_DITHERMODE_COLORFORMATEXTENSION) |
                                    (1 << PM_DITHERMODE_ENABLE) |
                                    (2 << PM_DITHERMODE_FORCEALPHA) |
                                    (1 << PM_DITHERMODE_DITHERENABLE));

                SEND_P3_DATA(FBReadPixel, DDSurf_GetChipPixelSize((&TempLcl)) );

                SEND_P3_DATA(FBWindowBase, windowBaseTemp);

                // set no read of source.
                SEND_P3_DATA(FBReadMode, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch((&TempLcl))));
                SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

                // set base of source
                SEND_P3_DATA(TextureBaseAddress, windowBaseOverlay);
                SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
                
                SEND_P3_DATA(TextureColorMode, PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                     PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

                SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                    PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                                    PM_TEXREADMODE_WIDTH(11) |
                                                    PM_TEXREADMODE_HEIGHT(11) );


                SEND_P3_DATA(TextureMapFormat, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pOverlayLcl)) | 
                                                (DDSurf_GetChipPixelSize(pOverlayLcl) << PM_TEXMAPFORMAT_TEXELSIZE) );

                if ( pFormatOverlay->DeviceFormat == SURF_YUV422 )
                {
                    // Turn on the YUV unit
                    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatOverlay))  |
                                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_COLORORDER(INV_COLOR_MODE));
                    SEND_P3_DATA(YUVMode, 0x1);
                }
                else
                {
                    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatOverlay))  |
                                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_COLORORDER(COLOR_MODE));
                    // Shouldn't actually need this - it's the default setting.
                    SEND_P3_DATA(YUVMode, 0x0);
                }

                SEND_P3_DATA(LogicalOpMode, 0);

                // set offset of source
                SEND_P3_DATA(SStart,      rOverlay.left << 20);
                SEND_P3_DATA(TStart,      rOverlay.top<< 20);
                SEND_P3_DATA(dSdx,        xScale);
                SEND_P3_DATA(dSdyDom,     0);

                WAIT_FIFO(24);
                SEND_P3_DATA(dTdx,        0);
                SEND_P3_DATA(dTdyDom,     yScale);

                /*
                 * Render the rectangle
                 */
                SEND_P3_DATA(StartXDom, rTemp.left << 16);
                SEND_P3_DATA(StartXSub, rTemp.right << 16);
                SEND_P3_DATA(StartY,    rTemp.top << 16);
                SEND_P3_DATA(dY,        1 << 16);
                SEND_P3_DATA(Count,     rTemp.bottom - rTemp.top);
                SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);

                SEND_P3_DATA(DitherMode, 0);

                // Turn off the YUV unit
                SEND_P3_DATA(YUVMode, 0x0);

                SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_DISABLE));
                SEND_P3_DATA(TextureColorMode, PM_TEXCOLORMODE_ENABLE(__PERMEDIA_DISABLE));

                P3_DMA_COMMIT_BUFFER();
            }




            // Blit the expanded overlay to the framebuffer, colourkeying off the alpha.

            {

                // Select anything with full alpha.
                LowerBound = 0xff000000;
                UpperBound = 0xffffffff;

                P3_DMA_GET_BUFFER();

                P3_ENSURE_DX_SPACE(40);
                WAIT_FIFO(20);

                // don't need to twiddle the source (which is actually the framebuffer).
                SEND_P3_DATA(DitherMode,0);

                // Accept range, disable updates
                SEND_P3_DATA(YUVMode, (0x1 << 1)|0x20);



                // set a read of source.
                // Note - as we are enabling reads, we might have to do a WaitForCompleteion
                // (see the P2 Programmer's Reference Manual about the FBReamMode for more details.
                // but I think we should be OK - we are unlikely to have just written this data.
                SEND_P3_DATA(FBReadMode,(PACKED_PP_LOOKUP(DDSurf_GetPixelPitch((&TempLcl)))) |
                                    PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE) );
                SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

                // set FB write point
                SEND_P3_DATA(FBWindowBase, windowBaseFB);

                // set up FBWrite mode. This _must_ be done after setting up FBReadMode.
                SEND_P3_DATA(FBWriteConfig,(PACKED_PP_LOOKUP(DDSurf_GetPixelPitch((pFBLcl)))));

                // offset the source point (point it at the temp thingie)
                SEND_P3_DATA(FBSourceOffset, windowBaseTemp - windowBaseFB - rFB.left - ( ( rFB.top * DDSurf_GetPixelPitch((&TempLcl)) ) ) );

                // set base of source
                SEND_P3_DATA(TextureBaseAddress, windowBaseFB);
                SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
                
                SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                        PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

                SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                    PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                                    PM_TEXREADMODE_WIDTH(11) |
                                                    PM_TEXREADMODE_HEIGHT(11) );

                SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatFB))  |
                                                PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatFB)) |
                                                PM_TEXDATAFORMAT_COLORORDER(COLOR_MODE));

                SEND_P3_DATA(TextureMapFormat,    ((PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pFBLcl)))) | 
                                                (DDSurf_GetChipPixelSize(pFBLcl) << PM_TEXMAPFORMAT_TEXELSIZE) );

                SEND_P3_DATA(ChromaLowerBound, LowerBound);
                SEND_P3_DATA(ChromaUpperBound, UpperBound);


                SEND_P3_DATA(dSdx,      1 << 20);
                SEND_P3_DATA(dSdyDom,   0);
                SEND_P3_DATA(dTdx,      0);
                SEND_P3_DATA(dTdyDom,   1 << 20);
                SEND_P3_DATA(dY,        1 << 16);

                lpCurRect = (LPRECT)lpRgn->Buffer;
                NumRects = lpRgn->rdh.nCount;
                while ( NumRects > 0 )
                {
                    P3_ENSURE_DX_SPACE(14);
                    WAIT_FIFO(7);

                    SEND_P3_DATA(SStart,    lpCurRect->left << 20);
                    SEND_P3_DATA(TStart,    lpCurRect->top << 20);
//                  SEND_P3_DATA(dSdx,      1 << 20);
//                  SEND_P3_DATA(dSdyDom,   0);
//                  SEND_P3_DATA(dTdx,      0);
//                  SEND_P3_DATA(dTdyDom,   1 << 20);

                    SEND_P3_DATA(StartXDom, lpCurRect->left << 16);
                    SEND_P3_DATA(StartXSub, lpCurRect->right << 16);
                    SEND_P3_DATA(StartY,    lpCurRect->top << 16);
//                  SEND_P3_DATA(dY,        1 << 16);
                    SEND_P3_DATA(Count,     lpCurRect->bottom - lpCurRect->top);
                    SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);

                    // Next rect
                    NumRects--;
                    lpCurRect++;
                }

                P3_ENSURE_DX_SPACE(10);
                WAIT_FIFO(5);

                SEND_P3_DATA(DitherMode, 0);
                SEND_P3_DATA(YUVMode, 0x0);

                SEND_P3_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
                SEND_P3_DATA(TextureColorMode, __PERMEDIA_DISABLE);

                SEND_P3_DATA(TextureReadMode, __PERMEDIA_DISABLE);

                P3_DMA_COMMIT_BUFFER();
            }




        #ifdef WANT_DMA
            if (pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA)
            {
                // If we have queued up a DMA, we must send it now.
                P3_DMA_DEFS();
                P3_DMA_GET_BUFFER();
            
                // Flush DMA buffer
                P3_DMA_FLUSH_BUFFER();
            }
        #endif


            START_SOFTWARE_CURSOR(pThisDisplay);


        }
        else
        {
            // Not colourkeyed, so just blit directly to the screen.

            DISPDBG((DBGLVL,"** In DrawOverlay"));

            VALIDATE_MODE_AND_STATE(pThisDisplay);

            pOverlayGbl     = pOverlayLcl->lpGbl;
            pFBGbl          = pFBLcl->lpGbl;
            pFormatOverlay  = _DD_SUR_GetSurfaceFormat(pOverlayLcl);
            pFormatFB       = _DD_SUR_GetSurfaceFormat(pFBLcl);
            // Temp buffer will be same format as framebuffer.


            DISPDBG((DBGLVL, "Overlay Surface:"));
            DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pOverlayLcl);
            DISPDBG((DBGLVL, "FB Surface:"));
            DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pFBLcl);

            // First stop dual cursor accesses
            STOP_SOFTWARE_CURSOR(pThisDisplay);
            // Switch to DirectDraw context
            DDRAW_OPERATION(pContext, pThisDisplay);

            windowBaseOverlay   = __VD_PixelOffsetFromMemoryBase(pThisDisplay, pOverlayLcl);
            windowBaseFB        = __VD_PixelOffsetFromMemoryBase(pThisDisplay, pFBLcl);

            {
                P3_DMA_GET_BUFFER();
                P3_ENSURE_DX_SPACE(70);

                WAIT_FIFO(16);

                SEND_P3_DATA(DitherMode, (COLOR_MODE << PM_DITHERMODE_COLORORDER) |
                                    (SURFFORMAT_FORMAT_BITS(pFormatFB) << PM_DITHERMODE_COLORFORMAT) |
                                    (SURFFORMAT_FORMATEXTENSION_BITS(pFormatFB) << PM_DITHERMODE_COLORFORMATEXTENSION) |
                                    (1 << PM_DITHERMODE_ENABLE) |
                                    (1 << PM_DITHERMODE_DITHERENABLE));

                SEND_P3_DATA(FBReadPixel, DDSurf_GetChipPixelSize((pFBLcl)) );

                SEND_P3_DATA(FBWindowBase, windowBaseFB);

                // set no read of source.
                SEND_P3_DATA(FBReadMode, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch((pFBLcl))));
                SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

                // set base of source
                SEND_P3_DATA(TextureBaseAddress, windowBaseOverlay);
                SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
                
                SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                        PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

                SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                                    PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                                    PM_TEXREADMODE_WIDTH(11) |
                                                    PM_TEXREADMODE_HEIGHT(11) );

                SEND_P3_DATA(TextureMapFormat, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pOverlayLcl)) | 
                                                (DDSurf_GetChipPixelSize(pOverlayLcl) << PM_TEXMAPFORMAT_TEXELSIZE) );

                if ( pFormatOverlay->DeviceFormat == SURF_YUV422 )
                {
                    // Turn on the YUV unit
                    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatOverlay))  |
                                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_COLORORDER(INV_COLOR_MODE));
                    SEND_P3_DATA(YUVMode, 0x1);
                }
                else
                {
                    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatOverlay)) |
                                                    PM_TEXDATAFORMAT_COLORORDER(COLOR_MODE));
                    // Shouldn't actually need this - it's the default setting.
                    SEND_P3_DATA(YUVMode, 0x0);
                }

                SEND_P3_DATA(LogicalOpMode, 0);


                // Constant values in the rectangle loop.
                SEND_P3_DATA(dSdyDom,   0);
                SEND_P3_DATA(dTdx,      0);
                SEND_P3_DATA(dY,        1 << 16);

                lpCurRect = (LPRECT)lpRgn->Buffer;
                NumRects = lpRgn->rdh.nCount;
                while ( NumRects > 0 )
                {
                    // Transform the source rect.
                    fTemp = ( ( (float)lpCurRect->left      + OffsetX ) * ScaleX + 0.499f );
                    myFtoi ( (int*)&(TempRect.left), fTemp );
                    fTemp = ( ( (float)lpCurRect->right + OffsetX ) * ScaleX + 0.499f );
                    myFtoi ( (int*)&(TempRect.right), fTemp );
                    fTemp = ( ( (float)lpCurRect->top       + OffsetY ) * ScaleY + 0.499f );
                    myFtoi ( (int*)&(TempRect.top), fTemp );
                    fTemp = ( ( (float)lpCurRect->bottom    + OffsetY ) * ScaleY + 0.499f );
                    myFtoi ( (int*)&(TempRect.bottom), fTemp );

                    xScale = ( ( TempRect.right - TempRect.left ) << 20) / ( lpCurRect->right - lpCurRect->left );
                    yScale = ( ( TempRect.bottom - TempRect.top ) << 20) / ( lpCurRect->bottom - lpCurRect->top );
                
                    P3_ENSURE_DX_SPACE(18);
                    WAIT_FIFO(9);

                    // set offset of source
                    SEND_P3_DATA(SStart,    TempRect.left << 20);
                    SEND_P3_DATA(TStart,    TempRect.top << 20);
                    SEND_P3_DATA(dSdx,      xScale);
//                  SEND_P3_DATA(dSdyDom,   0);
//                  SEND_P3_DATA(dTdx,      0);
                    SEND_P3_DATA(dTdyDom,   yScale);

                    SEND_P3_DATA(StartXDom, lpCurRect->left << 16);
                    SEND_P3_DATA(StartXSub, lpCurRect->right << 16);
                    SEND_P3_DATA(StartY,    lpCurRect->top << 16);
//                  SEND_P3_DATA(dY,        1 << 16);
                    SEND_P3_DATA(Count,     lpCurRect->bottom - lpCurRect->top);
                    SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);


                    // Next rect
                    NumRects--;
                    lpCurRect++;
                }


                P3_ENSURE_DX_SPACE(10);
                WAIT_FIFO(5);

                SEND_P3_DATA(DitherMode, 0);

                // Turn off YUV conversion.
                if ( pFormatOverlay->DeviceFormat == SURF_YUV422 )
                {
                    SEND_P3_DATA(YUVMode, 0x0);
                }

                SEND_P3_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
                SEND_P3_DATA(TextureColorMode, __PERMEDIA_DISABLE);

                SEND_P3_DATA(TextureReadMode, __PERMEDIA_DISABLE);

                P3_DMA_COMMIT_BUFFER();
            }


            #ifdef WANT_DMA
            if (pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA)
            {
                // If we have queued up a DMA, we must send it now.
                P3_DMA_DEFS();
                P3_DMA_GET_BUFFER();
            
                if( (DWORD)dmaPtr != pThisDisplay->pGLInfo->DMAPartition[pThisDisplay->pGLInfo->CurrentPartition].VirtAddr ) 
                {
                    // Flush DMA buffer
                    P3_DMA_FLUSH_BUFFER();
                }
            }
            #endif


            START_SOFTWARE_CURSOR(pThisDisplay);

        }


        // And that's all.
    }




    return;
}





/****************************************************************************
 *
 * void UpdateAlphaOverlay ( P3_THUNKEDDATA* pThisDisplay );
 * 
 * In:
 *      P3_THUNKEDDATA* pThisDisplay;                 This display's pointer
 * 
 * Out:
 *      None.
 * 
 * Notes:
 *      Takes the data in pThisDisplay and changes everything of the right
 * colourkey to black with a full alpha, ready for calls to DrawOverlay()
 * 
 ***************************************************************************/

void UpdateAlphaOverlay ( P3_THUNKEDDATA* pThisDisplay )
{

    RECTL                       rFB;
    LPDDRAWI_DDRAWSURFACE_LCL   pFBLcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pFBGbl;
    P3_SURF_FORMAT*               pFormatFB;
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;
    DWORD                       dwColourKeyValue;
    DWORD                       dwAlphaMask;
    DWORD                       windowBaseFB;
    LONG                        lPixPitchFB;
    DWORD                       LowerBound;
    DWORD                       UpperBound;


    P3_DMA_DEFS();

    REPORTSTAT(pThisDisplay, ST_Blit, 1);

    rFB.left                = (LONG)pThisDisplay->OverlayDstRectL;
    rFB.right               = (LONG)pThisDisplay->OverlayDstRectR;
    rFB.top                 = (LONG)pThisDisplay->OverlayDstRectT;
    rFB.bottom              = (LONG)pThisDisplay->OverlayDstRectB;
    pFBLcl                  = (LPDDRAWI_DDRAWSURFACE_LCL)pThisDisplay->OverlayDstSurfLcl;



    DISPDBG((DBGLVL,"** In UpdateAlphaOverlay"));

    VALIDATE_MODE_AND_STATE(pThisDisplay);


    pFBGbl          = pFBLcl->lpGbl;
    pFormatFB       = _DD_SUR_GetSurfaceFormat(pFBLcl);


    DISPDBG((DBGLVL, "FB Surface:"));
    DBGDUMP_DDRAWSURFACE_LCL(10, pFBLcl);


    dwColourKeyValue = pThisDisplay->OverlayDstColourKey;
    switch ( pThisDisplay->bPixShift )
    {
        case GLINTDEPTH16:
            if ( pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00 )
            {
                // 5551 format, as it should be.
                dwAlphaMask = 0x8000;
            }
            else
            {
                // 565 format. Oops.
                DISPDBG((WRNLVL, "** DrawOverlay error: called for a 565 surface"));
                return;
            }
            break;
        case GLINTDEPTH32:
            dwAlphaMask = 0xff000000;
            break;
        case GLINTDEPTH8:
        case GLINTDEPTH24:
        default:
            DISPDBG((WRNLVL, "** DrawOverlay error: called for an 8, 24 or unknown surface bPixShift=%d", pThisDisplay->bPixShift));
            return;
            break;
    }
    dwColourKeyValue &= ~dwAlphaMask;


    lpDD = pFBLcl->lpGbl->lpDD;


    // First stop dual cursor accesses
    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Switch to DirectDraw context
    DDRAW_OPERATION(pContext, pThisDisplay);

    // get bpp and pitches for surfaces.
    lPixPitchFB = pFBGbl->lPitch;

    windowBaseFB = (pFBGbl->fpVidMem - pThisDisplay->dwScreenFlatAddr) >> DDSurf_GetPixelShift(pFBLcl);
    lPixPitchFB = lPixPitchFB >> DDSurf_GetPixelShift(pFBLcl);

    // Do the colourkey(no alpha) to colourkey+alpha blit.
    DISPDBG((DBGLVL, "Source Surface:"));
    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pFBLcl);

    LowerBound = dwColourKeyValue;
    UpperBound = dwColourKeyValue;

    switch (pFormatFB->DeviceFormat)
    {
        case SURF_5551_FRONT:
            LowerBound = FORMAT_5551_32BIT_BGR(LowerBound);
            UpperBound = FORMAT_5551_32BIT_BGR(UpperBound);
            LowerBound = LowerBound & 0x00F8F8F8;   // Account for 'missing bits'
            UpperBound = UpperBound & 0x00FFFFFF;   // and vape any alpha
            UpperBound = UpperBound | 0x00070707;
            break;
        case SURF_8888:
            LowerBound = FORMAT_8888_32BIT_BGR(LowerBound);
            UpperBound = FORMAT_8888_32BIT_BGR(UpperBound);
            LowerBound = LowerBound & 0x00FFFFFF;   // Bin any alpha.
            UpperBound = UpperBound & 0x00FFFFFF;
            break;
        default:
            DISPDBG((WRNLVL,"** DrawOverlay: invalid source pixel format passed (DeviceFormat=%d)",pFormatFB->DeviceFormat));
            break;
    }

    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(70);

    WAIT_FIFO(36);

//  if (DDSurf_GetChipPixelSize(pSrcLcl) != __GLINT_8BITPIXEL)
//  {
        SEND_P3_DATA(DitherMode, (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                                 (SURFFORMAT_FORMAT_BITS(pFormatFB) << PM_DITHERMODE_COLORFORMAT) |
                                 (SURFFORMAT_FORMATEXTENSION_BITS(pFormatFB) << PM_DITHERMODE_COLORFORMATEXTENSION) |
                                 (1 << PM_DITHERMODE_ENABLE));
//  }

    SEND_P3_DATA(FBReadPixel, pThisDisplay->bPixShift);

    // Accept range, disable updates
    SEND_P3_DATA(YUVMode, (0x1 << 1)|0x20);

    SEND_P3_DATA(FBWindowBase, windowBaseFB);

    // set the colour to be written (rather than the texture colour)
    // use the colour key with alpha set.
    SEND_P3_DATA(ConstantColor, ( LowerBound | 0xff000000 ) );
    // Enable colour, disable DDAs.
    SEND_P3_DATA(ColorDDAMode, 0x1);

    // Disable reads of FBsource or FBdest - all data comes from the texture unit.
    SEND_P3_DATA(FBReadMode,(PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pFBLcl))));
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_P3_DATA(TextureBaseAddress, windowBaseFB);
    SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
    
    SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                            PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

    SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                        PM_TEXREADMODE_WIDTH(11) |
                                        PM_TEXREADMODE_HEIGHT(11) );

    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatFB)) |
                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatFB)) |
                                    PM_TEXDATAFORMAT_COLORORDER(COLOR_MODE));

    SEND_P3_DATA(TextureMapFormat,    ((PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pFBLcl)))) | 
                                    (DDSurf_GetChipPixelSize(pFBLcl) << PM_TEXMAPFORMAT_TEXELSIZE) );


    SEND_P3_DATA(ChromaLowerBound, LowerBound);
    SEND_P3_DATA(ChromaUpperBound, UpperBound);

    /*
     * Render the rectangle
     */
    // set offset of source
    SEND_P3_DATA(SStart,    rFB.left << 20);
    SEND_P3_DATA(TStart,    rFB.top << 20);
    SEND_P3_DATA(dSdx,      1 << 20);
    SEND_P3_DATA(dSdyDom,   0);
    SEND_P3_DATA(dTdx,      0);
    SEND_P3_DATA(dTdyDom,   1 << 20);

    // set destination
    SEND_P3_DATA(StartXDom, rFB.left << 16);
    SEND_P3_DATA(StartXSub, rFB.right << 16);
    SEND_P3_DATA(StartY,    rFB.top << 16);
    SEND_P3_DATA(dY,        1 << 16);
    SEND_P3_DATA(Count,     rFB.bottom - rFB.top);
    SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);

//  if (DDSurf_GetChipPixelSize(pSrcLcl) != __GLINT_8BITPIXEL)
//  {
        SEND_P3_DATA(DitherMode, 0);
//  }

    // Turn off chroma key and all the other unusual features
    SEND_P3_DATA(YUVMode, 0x0);
    SEND_P3_DATA(ColorDDAMode, 0x0);

    SEND_P3_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureColorMode, __PERMEDIA_DISABLE);

    SEND_P3_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    P3_DMA_COMMIT_BUFFER();


#ifdef WANT_DMA
    if (pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA)
    {
        // If we have queued up a DMA, we must send it now.
        P3_DMA_DEFS();
        P3_DMA_GET_BUFFER();
    
        if( (DWORD)dmaPtr != pThisDisplay->pGLInfo->DMAPartition[pThisDisplay->pGLInfo->CurrentPartition].VirtAddr ) 
        {
            // Flush DMA buffer
            P3_DMA_FLUSH_BUFFER();
        }
    }
#endif


    START_SOFTWARE_CURSOR(pThisDisplay);


    return;
}


#endif  // W95_DDRAW_VIDEO
//@@END_DDKSPLIT

//@@BEGIN_DDKSPLIT

void PermediaBltYUVRGB(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest, 
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    DDBLTFX* lpBltFX, 
    RECTL *rSrc,
    RECTL *rDest, 
    DWORD windowBase,
    DWORD SourceOffset)
{
    DWORD xScale;
    DWORD yScale;
    DWORD DestWidth = rDest->right - rDest->left;
    DWORD DestHeight = rDest->bottom - rDest->top;
    DWORD SourceWidth = rSrc->right - rSrc->left;
    DWORD SourceHeight = rSrc->bottom - rSrc->top;

    P3_DMA_DEFS();

    ASSERTDD(pDest, "Not valid surface in destination");
    ASSERTDD(pSource, "Not valid surface in source");

    xScale = (SourceWidth << 20) / DestWidth;
    yScale = (SourceHeight << 20) / DestHeight;
    
    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(50);

    WAIT_FIFO(17);

    SEND_P3_DATA(FBReadPixel, DDSurf_GetChipPixelSize(pDest));

    if (DDSurf_GetChipPixelSize(pSource) != __GLINT_8BITPIXEL)
    {
        SEND_P3_DATA(DitherMode, (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                                 (SURFFORMAT_FORMAT_BITS(pFormatDest) << PM_DITHERMODE_COLORFORMAT) |
                                 (SURFFORMAT_FORMATEXTENSION_BITS(pFormatDest) << PM_DITHERMODE_COLORFORMATEXTENSION) |
                                 (1 << PM_DITHERMODE_ENABLE) |
                                 (1 << PM_DITHERMODE_DITHERENABLE));
    }

    SEND_P3_DATA(FBWindowBase, windowBase);

    // set no read of source.
    SEND_P3_DATA(FBReadMode, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pDest)));
    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_P3_DATA(TextureBaseAddress, SourceOffset);
    SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_ENABLE));
    
    SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_ENABLE) |
                                            PM_TEXCOLORMODE_APPLICATIONMODE(__GLINT_TEXCOLORMODE_APPLICATION_COPY));

    SEND_P3_DATA(TextureReadMode, PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                                        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                                        PM_TEXREADMODE_WIDTH(11) |
                                        PM_TEXREADMODE_HEIGHT(11) );

    SEND_P3_DATA(TextureDataFormat, PM_TEXDATAFORMAT_FORMAT(SURFFORMAT_FORMAT_BITS(pFormatSource)) |
                                    PM_TEXDATAFORMAT_FORMATEXTENSION(SURFFORMAT_FORMATEXTENSION_BITS(pFormatSource)) |
                                    PM_TEXDATAFORMAT_COLORORDER(INV_COLOR_MODE));

    SEND_P3_DATA(TextureMapFormat, PACKED_PP_LOOKUP(DDSurf_GetPixelPitch(pSource)) | 
                                    (DDSurf_GetChipPixelSize(pSource) << PM_TEXMAPFORMAT_TEXELSIZE) );

    // Turn on the YUV unit
    SEND_P3_DATA(YUVMode, 0x1);

    SEND_P3_DATA(LogicalOpMode, 0);


    // set offset of source
    SEND_P3_DATA(SStart,    rSrc->left << 20);
    SEND_P3_DATA(TStart, (rSrc->top<< 20));
    SEND_P3_DATA(dSdx,      xScale);
    SEND_P3_DATA(dSdyDom, 0);

    WAIT_FIFO(14);
    SEND_P3_DATA(dTdx,        0);
    SEND_P3_DATA(dTdyDom, yScale);

    /*
     * Render the rectangle
     */
    SEND_P3_DATA(StartXDom, rDest->left << 16);
    SEND_P3_DATA(StartXSub, rDest->right << 16);
    SEND_P3_DATA(StartY,    rDest->top << 16);
    SEND_P3_DATA(dY,        1 << 16);
    SEND_P3_DATA(Count,     rDest->bottom - rDest->top);
    SEND_P3_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_TEXTURED_PRIMITIVE);

    if (DDSurf_GetChipPixelSize(pSource) != __GLINT_8BITPIXEL)
    {
        SEND_P3_DATA(DitherMode, 0);
    }

    // Turn off the YUV unit
    SEND_P3_DATA(YUVMode, 0x0);

    SEND_P3_DATA(TextureAddressMode, PM_TEXADDRESSMODE_ENABLE(__PERMEDIA_DISABLE));
    SEND_P3_DATA(TextureColorMode,    PM_TEXCOLORMODE_ENABLE(__PERMEDIA_DISABLE));
    SEND_P3_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    P3_DMA_COMMIT_BUFFER();
}

//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\debug.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           *     SAMPLE CODE        *
*                           **************************
*
* Module Name: debug.c
*
* Content: Debugging aids
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// Debug routines

#include "glint.h"
#include "dma.h"
#include <windef.h>          
#include <limits.h>
#include <stdio.h>
#include <stdarg.h>

#if DBG

#if DBG_TRACK_CODE
// we don't want to ever do code coverage of the debugging tools 
// (otherwise we might loop forever)
#undef if
#undef while
#endif // DBG_TRACK_CODE


#if DBG_TRACK_FUNCS || DBG_TRACK_CODE
// Common helper functions
//-----------------------------------------------------------------------------
// __ShortFileName
//
// Leave just an 8.3 filename to store rather than a full path name
//
//----------------------------------------------------------------------------- 
char *
__ShortFileName(char *pInStr)
{
    char *pShortFN;

    pShortFN = pInStr;

    if (pInStr != NULL)
    {
        while (*pInStr != '\0')
        {
            if (*pInStr++ == '\\')
            {
                pShortFN = pInStr;
            }
        }
    }

    return (pShortFN);
    
} // __ShortFileName

#endif // DBG_TRACK_FUNCS || DBG_TRACK_CODE

#if DBG_TRACK_FUNCS
//-----------------------------------------------------------------------------
//
// ****************** FUNCTION COVERAGE DEBUGGING SUPPORT ********************
//
//-----------------------------------------------------------------------------
//
// This mechanism enables us to track which functions are called (entered),
// how many times they are called, what values do they return (and if they exit 
// through all expected return points). Support to track maximum, minimum and
// average time per call can also be implemented.
//
// To use it, add the DBG_ENTRY macro at the start of important functions you 
// want to track and before taking any return statement, add a DBG_EXIT macro
// giving a DWORD value representative of the return value of the function.
// Different return values will be tracked independently.
//
//
//  ********** This support should only be enabled for test runs. **********
//  ** IT SHOULD NOT BE SET BY DEFAULT ON NEITHER ON FREE OR CHECKED BUILDS **
//
//-----------------------------------------------------------------------------

// Maximum of functions to be tracked. Code will take care of not exceeding
// this, but it should be adjusted upward if necessary.
#define DEBUG_MAX_FUNC_COUNT 200

// Maximum of different return values to keep track of. Can be independent
// of DEBUG_MAX_FUNC_COUNT, just using a heuristic here instead of a wild guess.
#define DEBUG_MAX_RETVALS    (DEBUG_MAX_FUNC_COUNT * 30)

// global structures that will hold our data
struct { 
    VOID *pFuncAddr;  //
    DWORD dwRetVal;   //
    DWORD dwLine;     //
    DWORD dwCount;    //
} g_DbgFuncRetVal[DEBUG_MAX_RETVALS];

struct {
    VOID    *pFuncAddr;        //
    char    *pszFuncName;      //
    char    *pszFileName;      //
    DWORD    dwLine;           //
    DWORD    dwEntryCount;     //
    DWORD    dwExitCount;      //
    DWORD    dwIndxLastRetVal; //
    // profiling support - not yet implemented //azn
    LONGLONG LastStartTime;    //
    DWORD    MinTime;          //
    DWORD    MaxTime;          //
    DWORD    AvgTime;          //
} g_DbgFuncCoverage[DEBUG_MAX_FUNC_COUNT];

DWORD g_dwRetVal_Cnt = 0;
DWORD g_dwFuncCov_Cnt = 0;
DWORD g_dwFuncCov_Extra = 0;
    
//-----------------------------------------------------------------------------
// __Find
//
// Does a binary search on the g_DbgFuncCoverage array
//
// Since 0 is a valid array element, we return DEBUG_MAX_FUNC_COUNT if we
// fail to find a suitable match.
//
//-----------------------------------------------------------------------------
DWORD 
__Find(
    VOID *pFuncAddr, DWORD *pdwNearFail)
{
    DWORD dwLower ,dwUpper ,dwNewProbe ;

    *pdwNearFail = 0; // default failure value

    if (g_dwFuncCov_Cnt > 0)
    {       
        dwLower = 0;
        dwUpper = g_dwFuncCov_Cnt - 1; // dwUpper points to a valid element
               
        do 
        {       
            dwNewProbe = (dwUpper + dwLower) / 2;
            
            //DISPDBG((0,"%x %d %d %d",pFuncAddr,dwLower,dwUpper,dwNewProbe));
            
            if (g_DbgFuncCoverage[dwNewProbe].pFuncAddr == pFuncAddr)
            {
                // Found!!!    
                return dwNewProbe;
            }

            *pdwNearFail = dwNewProbe; // nearest element where we failed.

            // The new values for dwNewProbe make sure that we don't retest
            // the same value again unless dwUpper == dwLower in which case
            // we're done.
            if (g_DbgFuncCoverage[dwNewProbe].pFuncAddr > pFuncAddr)
            {
                if (dwNewProbe > 0)
                {
                    dwUpper = dwNewProbe - 1;
                }
                else
                {   // all elements in the array are larger than pFuncAdrr
                    // so this is just a way to exit from the loop since
                    // our vars are unsigned
                    dwUpper = 0; 
                    dwLower = 1;
                }
            }
            else
            {
                dwLower = dwNewProbe + 1;
            }
        } while(dwUpper >= dwLower);
    }

    return DEBUG_MAX_FUNC_COUNT;  // return error - element not found
    
} // __Find

//-----------------------------------------------------------------------------
// __FindOrAdd
//
// Does a binary search on the g_DbgFuncCoverage array, but if the element 
// isn't there, it is added.
//
// If we fail to add the element, we return the DEBUG_MAX_FUNC_COUNT value
//
//-----------------------------------------------------------------------------
DWORD 
__FindOrAdd(
    VOID *pFuncAddr,
    char *pszFuncName, 
    DWORD dwLine , 
    char *pszFileName)
{
    DWORD dwNearFail;
    DWORD iEntry;
    DWORD dwNewElem;
    BOOL bNeedToMoveElems;

    // Do the normal search of the element first

    iEntry = __Find(pFuncAddr, &dwNearFail);

    if (iEntry != DEBUG_MAX_FUNC_COUNT)
    {
        return iEntry; //we're done!
    }

    // Now we have to add the new element. Do we have enough space?
    if (g_dwFuncCov_Cnt == DEBUG_MAX_FUNC_COUNT)
    {
        g_dwFuncCov_Extra++;         // Keep count of how many extra 
                                     // entries we really need
        return DEBUG_MAX_FUNC_COUNT; // return error - not enough space left
    }

    // Do we need to move elements to insert the new one ?  
    if ( g_dwFuncCov_Cnt == 0)
    {
        bNeedToMoveElems = FALSE;
        dwNewElem = 0;
    }
    else if ( (dwNearFail == g_dwFuncCov_Cnt - 1) &&
              (g_DbgFuncCoverage[dwNearFail].pFuncAddr < pFuncAddr) )
    {
        bNeedToMoveElems = FALSE;
        dwNewElem = g_dwFuncCov_Cnt;    
    }
    else if (g_DbgFuncCoverage[dwNearFail].pFuncAddr < pFuncAddr)
    {
        bNeedToMoveElems = TRUE;   
        dwNewElem = dwNearFail + 1;
    } 
    else
    {
        bNeedToMoveElems = TRUE;  
        dwNewElem = dwNearFail;        
    }

    // Do the move inside the array if necessary
    if (bNeedToMoveElems)
    {
        // we need to move (g_dwFuncCov_Cnt - dwNewElem) elements
        // we use memmove as memcpy doesn't handle overlaps!
        // (remember: first param of memcpy is dst, 2nd is src!)
        memmove(&g_DbgFuncCoverage[dwNewElem+1],
                &g_DbgFuncCoverage[dwNewElem],
                sizeof(g_DbgFuncCoverage[0])*(g_dwFuncCov_Cnt - dwNewElem)); 

        // now cleanup the fields
        memset(&g_DbgFuncCoverage[dwNewElem], 
               0, 
               sizeof(g_DbgFuncCoverage[dwNewElem]));
    }

    // Now init the main fields
    g_DbgFuncCoverage[dwNewElem].pFuncAddr = pFuncAddr;
    g_DbgFuncCoverage[dwNewElem].pszFuncName = pszFuncName;
    g_DbgFuncCoverage[dwNewElem].pszFileName = __ShortFileName(pszFileName);
    g_DbgFuncCoverage[dwNewElem].dwLine = dwLine;

    // Mark the fact that the array has grown by one element
    g_dwFuncCov_Cnt++;
    
    DISPDBG((DBGLVL,"*** DEBUG FUNC COVERAGE New Elem (total now:%d) %x @ %d",
                    g_dwFuncCov_Cnt, pFuncAddr, dwNewElem));
    
    return dwNewElem;
    
} // __FindOrAdd

//-----------------------------------------------------------------------------
// __GetTime
//-----------------------------------------------------------------------------
VOID
__GetTime( LONGLONG *pllTime)
{
    *pllTime = 0; //azn - temporary
} // __GetTime

//-----------------------------------------------------------------------------
// Debug_Func_Entry
//-----------------------------------------------------------------------------
VOID 
Debug_Func_Entry(
    VOID *pFuncAddr,
    char *pszFuncName, 
    DWORD dwLine , 
    char *pszFileName)
{
    DWORD iEntry;
    LONGLONG llTimer;
    
    // Look for a log element for entry to this function. If not found it
    // is added to the current list of covered functions.
    iEntry = __FindOrAdd(pFuncAddr, pszFuncName, dwLine, pszFileName);
    
    // Didn't found one and no more space left in the internal data
    // structures ? Report error and return!
    if (iEntry == DEBUG_MAX_FUNC_COUNT)
    {
        DISPDBG((ERRLVL,"*** DEBUG FUNC COVERAGE ERROR in Debug_Func_Entry"));
        return;
    }
    
    // Update/Add information for this entry
    if (g_DbgFuncCoverage[iEntry].dwEntryCount != 0)
    {
        // This is an update
        g_DbgFuncCoverage[iEntry].dwEntryCount++;
        __GetTime(&llTimer);
        g_DbgFuncCoverage[iEntry].LastStartTime = llTimer;
    }
    else
    {
        // This is an addition
        g_DbgFuncCoverage[iEntry].dwEntryCount = 1; 
        g_DbgFuncCoverage[iEntry].dwExitCount = 0;
        g_DbgFuncCoverage[iEntry].dwIndxLastRetVal = 0;
        
        __GetTime(&llTimer);
        g_DbgFuncCoverage[iEntry].LastStartTime = llTimer;
        g_DbgFuncCoverage[iEntry].MinTime = 0;        
        g_DbgFuncCoverage[iEntry].MaxTime = 0;
        g_DbgFuncCoverage[iEntry].AvgTime = 0;            
    }

} // Debug_Func_Entry

//-----------------------------------------------------------------------------
// Debug_Func_Exit
//-----------------------------------------------------------------------------                      
VOID 
Debug_Func_Exit(
    VOID *pFuncAddr,
    DWORD dwRetVal,                       
    DWORD dwLine)
{    
    DWORD iEntry; 
    LONGLONG llTimer;
    DWORD dwElapsedTime;
    DWORD dwDummy;
    DWORD iRVEntry;

    __GetTime(&llTimer);

    // Look for a log element for entry to this function
    iEntry = __Find(pFuncAddr, &dwDummy);
    
    // Record and update relevant info in g_DbgFuncCoverage
    if (iEntry != DEBUG_MAX_FUNC_COUNT)
    {
        // keep track of times we've exited this function
        g_DbgFuncCoverage[iEntry].dwExitCount++;   
        
        // Keep track of elapsed times for this function
//@@BEGIN_DDKSPLIT        
        // possibly an evil data conversion - azn
//@@END_DDKSPLIT
        dwElapsedTime = (DWORD)(llTimer - 
                                g_DbgFuncCoverage[iEntry].LastStartTime);

        if (dwElapsedTime > g_DbgFuncCoverage[iEntry].MaxTime)
        {
            g_DbgFuncCoverage[iEntry].MaxTime = dwElapsedTime;
        }

        if (dwElapsedTime < g_DbgFuncCoverage[iEntry].MinTime)
        {
            g_DbgFuncCoverage[iEntry].MinTime = dwElapsedTime;
        }            

        g_DbgFuncCoverage[iEntry].AvgTime =
                        ( (g_DbgFuncCoverage[iEntry].dwExitCount - 1)*
                          g_DbgFuncCoverage[iEntry].AvgTime +
                          dwElapsedTime 
                        ) / g_DbgFuncCoverage[iEntry].dwExitCount;
        
        g_DbgFuncCoverage[iEntry].LastStartTime = 0;    
    } 
    else
    {
        DISPDBG((ERRLVL,"*** DEBUG FUNC COVERAGE ERROR not found %x",pFuncAddr));
        return; // don't even try adding this to the return value table
    }

    iRVEntry = g_DbgFuncCoverage[iEntry].dwIndxLastRetVal;

    if (iRVEntry != 0)
    {
        // Check if the last time we recorded a return value for this function
        // it was the exact same one. This way will save space recording some
        // duplicate info. The method is not perfect, but it's fast.

        if (( g_DbgFuncRetVal[iRVEntry].pFuncAddr == pFuncAddr) &&
            ( g_DbgFuncRetVal[iRVEntry].dwRetVal  == dwRetVal ) &&
            ( g_DbgFuncRetVal[iRVEntry].dwLine    == dwLine   ) )
        {
            //increment count for this event
            g_DbgFuncRetVal[iRVEntry].dwCount += 1;
            
            return; // we won't store a new record for this event
        }
    }

    // We couldn't save space, so we add info about the return value
    if (g_dwRetVal_Cnt < DEBUG_MAX_RETVALS)
    {
        g_DbgFuncCoverage[iEntry].dwIndxLastRetVal = g_dwRetVal_Cnt;
        
        g_DbgFuncRetVal[g_dwRetVal_Cnt].pFuncAddr = pFuncAddr;
        g_DbgFuncRetVal[g_dwRetVal_Cnt].dwRetVal  = dwRetVal;
        g_DbgFuncRetVal[g_dwRetVal_Cnt].dwLine    = dwLine;    
        g_DbgFuncRetVal[g_dwRetVal_Cnt].dwCount   = 1;                  
        
        g_dwRetVal_Cnt++;        
    }
  
} // Debug_Func_Exit

//-----------------------------------------------------------------------------
//
// Debug_Func_Report_And_Reset
//
// Report the accumulated stats and then reset them.
//
// This should be called through the DrvEscape mechanism(Win2K) or through some
// easily controllable code path which we can use to trigger it.
//
//-----------------------------------------------------------------------------  
VOID
Debug_Func_Report_And_Reset(void)
{
    DWORD i,j,k; // counters
    DWORD dwCount;

    DISPDBG((ERRLVL,"********* DEBUG FUNC COVERAGE (Debug_Func_Report) *********"));
    
    // Report if we have overflowed in any of our internal structures 
    // which would invalidate much of our results.
    if (g_dwFuncCov_Cnt >= DEBUG_MAX_FUNC_COUNT)
    {
       DISPDBG((ERRLVL,"*** DEBUG FUNC COVERAGE: g_DbgFuncCoverage exceeded "
                      "%d entries by %d ***",
                      DEBUG_MAX_FUNC_COUNT, 
                      g_dwFuncCov_Extra));
    }

    if (g_dwRetVal_Cnt >= DEBUG_MAX_RETVALS)
    {
       DISPDBG((ERRLVL,"*** DEBUG FUNC COVERAGE: g_DbgFuncRetVal exceeded "
                      "%d entries ***",DEBUG_MAX_RETVALS));
    }
    
    // Headers of function coverage report
    DISPDBG((ERRLVL,"%25s %12s %4s %6s %6s %8s",
                   "Function","File","Line","#Entry","#Exit","ExitValue"));

    // Go through each function called and report on its results
    for (i = 0; i < g_dwFuncCov_Cnt; i++)
    {
        DISPDBG((ERRLVL,"%25s %12s %4d %6d %6d",
                        g_DbgFuncCoverage[i].pszFuncName,
                        g_DbgFuncCoverage[i].pszFileName,                    
                        g_DbgFuncCoverage[i].dwLine,
                        g_DbgFuncCoverage[i].dwEntryCount,
                        g_DbgFuncCoverage[i].dwExitCount));                            

        // Get result values
        for(j = 0; j < g_dwRetVal_Cnt; j++)
        {
            if(g_DbgFuncRetVal[j].pFuncAddr == 
               g_DbgFuncCoverage[i].pFuncAddr)
            {
                // This entry is a valid exit value report for 
                // our g_DbgFuncCoverage entry, count instances
                dwCount = g_DbgFuncRetVal[j].dwCount;
                          
                // Now get rid of any duplicate records of this 
                // same exit event while counting
                for (k = j + 1; k < g_dwRetVal_Cnt; k++)
                {
                    if ( (g_DbgFuncRetVal[j].pFuncAddr == 
                                    g_DbgFuncRetVal[k].pFuncAddr) &&
                         (g_DbgFuncRetVal[j].dwLine ==  
                                    g_DbgFuncRetVal[k].dwLine) &&       
                         (g_DbgFuncRetVal[j].dwRetVal ==  
                                    g_DbgFuncRetVal[k].dwRetVal))
                    {
                        dwCount += g_DbgFuncRetVal[k].dwCount;
                        
                        g_DbgFuncRetVal[k].pFuncAddr = NULL;
                        g_DbgFuncRetVal[k].dwRetVal   = 0;
                        g_DbgFuncRetVal[k].dwLine     = 0;
                        g_DbgFuncRetVal[k].dwCount    = 0;
                    }
                }
                
                // Display it
                DISPDBG((ERRLVL,"%25s %12s %4d %6d %6s %8d",
                              "\"",
                              g_DbgFuncCoverage[i].pszFileName,
                              g_DbgFuncRetVal[j].dwLine,
                              dwCount,"",
                              g_DbgFuncRetVal[j].dwRetVal));   
                
            }
        }

    }

    DISPDBG((ERRLVL,
              "************************************************************"));

    // Clear structures for next round of statistics gathering

    for (i = 0; i < DEBUG_MAX_RETVALS; i++)
    {
        g_DbgFuncRetVal[i].pFuncAddr = NULL;
        g_DbgFuncRetVal[i].dwRetVal   = 0;
        g_DbgFuncRetVal[i].dwLine     = 0;
        g_DbgFuncRetVal[i].dwCount    = 0;        
    }

    for (i= 0; i < DEBUG_MAX_FUNC_COUNT; i++)
    {
        g_DbgFuncCoverage[i].pFuncAddr = NULL;
        g_DbgFuncCoverage[i].pszFuncName = NULL;
        g_DbgFuncCoverage[i].pszFileName = NULL;
        g_DbgFuncCoverage[i].dwLine = 0;
        g_DbgFuncCoverage[i].dwEntryCount = 0;
        g_DbgFuncCoverage[i].dwExitCount = 0;
        g_DbgFuncCoverage[i].dwIndxLastRetVal = 0;        
        g_DbgFuncCoverage[i].LastStartTime = 0;
        g_DbgFuncCoverage[i].MinTime = 0;        
        g_DbgFuncCoverage[i].MaxTime = 0;
        g_DbgFuncCoverage[i].AvgTime = 0;        
    }

    g_dwRetVal_Cnt = 0;
    g_dwFuncCov_Cnt = 0;    
    g_dwFuncCov_Extra = 0;
    
} // Debug_Func_Report

#endif // DBG_TRACK_FUNCS

#if DBG_TRACK_CODE
//-----------------------------------------------------------------------------
//
// ******************** STATEMENT COVERAGE DEBUGGING SUPPORT ******************
//
//-----------------------------------------------------------------------------


// Maximum of code branches to be tracked. Code will take care of not exceeding
// this, but it should be adjusted upward if necessary.
#define DEBUG_MAX_CODE_COUNT 20000

struct {
    VOID    *pCodeAddr;        //
    char    *pszFileName;      //
    DWORD    dwLine;           //
    DWORD    dwCodeType;       //   
    DWORD    dwCountFALSE;     //
    DWORD    dwCountTRUE;      //
} g_DbgCodeCoverage[DEBUG_MAX_CODE_COUNT];

DWORD g_dwCodeCov_Cnt = 0;

static char* g_cDbgCodeStrings[DBG_FOR_CODE+1] = { "NONE",
                                                     "IF" , 
                                                     "WHILE",
                                                     "SWITCH",
                                                     "FOR"    };
                                               
//-----------------------------------------------------------------------------
// __FindCode
//
// Does a binary search on the g_DbgCodeCoverage array
//
// Since 0 is a valid array element, we return DEBUG_MAX_CODE_COUNT if we
// fail to find a suitable match.
//
//-----------------------------------------------------------------------------
DWORD 
__FindCode(
    VOID *pCodeAddr, 
    DWORD *pdwNearFail)
{
    DWORD dwLower ,dwUpper ,dwNewProbe ;

    *pdwNearFail = 0; // default failure value

    if (g_dwCodeCov_Cnt > 0)
    {       
        dwLower = 0;
        dwUpper = g_dwCodeCov_Cnt - 1; // dwUpper points to a valid element
               
        do 
        {       
            dwNewProbe = (dwUpper + dwLower) / 2;
                       
            if (g_DbgCodeCoverage[dwNewProbe].pCodeAddr == pCodeAddr)
            {
                // Found!!!    
                return dwNewProbe;
            }

            *pdwNearFail = dwNewProbe; // nearest element where we failed.

            // The new values for dwNewProbe make sure that we don't retest
            // the same value again unless dwUpper == dwLower in which case
            // we're done.
            if (g_DbgCodeCoverage[dwNewProbe].pCodeAddr > pCodeAddr)
            {
                if (dwNewProbe > 0)
                {
                    dwUpper = dwNewProbe - 1;
                }
                else
                {   // all elements in the array are larger than pCodeAdrr
                    // so this is just a way to exit from the loop since
                    // our vars are unsigned
                    dwUpper = 0; 
                    dwLower = 1;
                }
            }
            else
            {
                dwLower = dwNewProbe + 1;
            }
        } while(dwUpper >= dwLower);
    }

    return DEBUG_MAX_CODE_COUNT;  // return error - element not found
    
} // __FindCode

//-----------------------------------------------------------------------------
// __FindOrAddCode
//
// Does a binary search on the g_DbgCodeCoverage array, but if the element 
// isn't there, it is added.
//
// If we fail to add the element, we return the DEBUG_MAX_CODE_COUNT value
//
//-----------------------------------------------------------------------------
DWORD 
__FindOrAddCode(
    VOID *pCodeAddr,
    DWORD dwLine , 
    char *pszFileName)
{
    DWORD dwNearFail;
    DWORD iEntry;
    DWORD dwNewElem;
    BOOL bNeedToMoveElems;

    // Do the normal search of the element first

    iEntry = __FindCode(pCodeAddr, &dwNearFail);

    if (iEntry != DEBUG_MAX_CODE_COUNT)
    {
        return iEntry; //we're done!
    }

    // Now we have to add the new element. Do we have enough space?
    if (g_dwCodeCov_Cnt == DEBUG_MAX_CODE_COUNT)
    {
        return DEBUG_MAX_CODE_COUNT; // return error - not enough space left
    }

    // Do we need to move elements to insert the new one ?  
    if ( g_dwCodeCov_Cnt == 0)
    {
        bNeedToMoveElems = FALSE;
        dwNewElem = 0;
    }
    else if ( (dwNearFail == g_dwCodeCov_Cnt - 1) &&
              (g_DbgCodeCoverage[dwNearFail].pCodeAddr < pCodeAddr) )
    {
        bNeedToMoveElems = FALSE;
        dwNewElem = g_dwCodeCov_Cnt;    
    }
    else if (g_DbgCodeCoverage[dwNearFail].pCodeAddr < pCodeAddr)
    {
        bNeedToMoveElems = TRUE;   
        dwNewElem = dwNearFail + 1;
    } 
    else
    {
        bNeedToMoveElems = TRUE;  
        dwNewElem = dwNearFail;        
    }

    // Do the move inside the array if necessary
    if (bNeedToMoveElems)
    {
        // we need to move (g_dwFuncCov_Cnt - dwNewElem) elements
        // we use memmove as memcpy doesn't handle overlaps!
        // (remember: first param of memcpy is dst, 2nd is src!)
        memmove(&g_DbgCodeCoverage[dwNewElem+1],
                &g_DbgCodeCoverage[dwNewElem],
                sizeof(g_DbgCodeCoverage[0])*(g_dwCodeCov_Cnt - dwNewElem)); 

        // now cleanup the fields
        memset(&g_DbgCodeCoverage[dwNewElem], 
               0, 
               sizeof(g_DbgCodeCoverage[dwNewElem]));
    }

    // Now init the main fields
    g_DbgCodeCoverage[dwNewElem].pCodeAddr = pCodeAddr;
    g_DbgCodeCoverage[dwNewElem].pszFileName = __ShortFileName(pszFileName);
    g_DbgCodeCoverage[dwNewElem].dwLine = dwLine;    
    g_DbgCodeCoverage[dwNewElem].dwCodeType = 0;    
    g_DbgCodeCoverage[dwNewElem].dwCountFALSE = 0;  
    g_DbgCodeCoverage[dwNewElem].dwCountTRUE = 0;  
    
    // Mark the fact that the array has grown by one element
    g_dwCodeCov_Cnt++;

    // Check if we're about to fail! (in order to report this only once)
    if (g_dwCodeCov_Cnt == DEBUG_MAX_CODE_COUNT)
    {
        DISPDBG((ERRLVL,"*** DEBUG CODE COVERAGE ERROR in Debug_Code_Coverage"));
    }
    
    
    return dwNewElem;
    
} // __FindOrAddCode

//-----------------------------------------------------------------------------
// Debug_Code_Coverage
//-----------------------------------------------------------------------------
BOOL 
Debug_Code_Coverage(
    DWORD dwCodeType, 
    DWORD dwLine , 
    char *pszFileName,
    BOOL bCodeResult)
{
    DWORD iEntry;
    DWORD *pCodeAddr;

    // Get the 32-bit address of our caller from the stack
    __asm mov eax, [ebp+0x4];
    __asm mov pCodeAddr,eax;
    
    // Look for a log element for entry to this code. If not found it
    // is added to the current list of covered code.
    iEntry = __FindOrAddCode(pCodeAddr, dwLine, pszFileName);
    
    // Didn't found one and no more space left in the internal data
    // structures ? Get out and do nothing!
    if (iEntry == DEBUG_MAX_CODE_COUNT)
    {
        return bCodeResult;
    }

    if (dwCodeType == DBG_IF_CODE || dwCodeType == DBG_WHILE_CODE )
    {
        // Update/Add information for this entry
        g_DbgCodeCoverage[iEntry].dwCodeType = dwCodeType;    
        if (bCodeResult)
        {
            g_DbgCodeCoverage[iEntry].dwCountTRUE++;

        }
        else
        {
            g_DbgCodeCoverage[iEntry].dwCountFALSE++; 
        }
    }
    else if (dwCodeType == DBG_SWITCH_CODE)    
    {
        // special case for the switch statement since its multivalued

        // Is the entry new? (uninitalized)
        if(g_DbgCodeCoverage[iEntry].dwCodeType == 0)
        {
            // just init and get out of here
            g_DbgCodeCoverage[iEntry].dwCodeType = DBG_SWITCH_CODE;
            g_DbgCodeCoverage[iEntry].dwCountFALSE = bCodeResult; // switch value
            g_DbgCodeCoverage[iEntry].dwCountTRUE =  1;           // found once
        }
        else
        {
            // need to look for already initialized elememt
            int iLookAt;

            // look at current element and back
            DWORD dwNewElem;
            iLookAt = iEntry;
            
            while ( (iLookAt >= 0 )                                     &&
                    (g_DbgCodeCoverage[iLookAt].pCodeAddr == pCodeAddr)  )
            {
                if (g_DbgCodeCoverage[iLookAt].dwCountFALSE == (DWORD)bCodeResult)
                {
                    // found - so update and get out of here
                    g_DbgCodeCoverage[iLookAt].dwCountTRUE++;                    
                    return bCodeResult;
                }

                // move to previous
                iLookAt--;
            }

            // look forward from current element
            iLookAt = iEntry + 1;
            while ( ((DWORD)iLookAt < g_dwCodeCov_Cnt )                       &&
                    (g_DbgCodeCoverage[iLookAt].pCodeAddr == pCodeAddr)  )
            {
                if (g_DbgCodeCoverage[iLookAt].dwCountFALSE == (DWORD)bCodeResult)
                {
                    // found - so update and get out of here
                    g_DbgCodeCoverage[iLookAt].dwCountTRUE++;                    
                    return bCodeResult;
                }

                // move to next
                iLookAt++;
            }            

            // not found - so we must add it!
            dwNewElem = iEntry;

            // we need to move (g_dwFuncCov_Cnt - dwNewElem) elements
            // we use memmove as memcpy doesn't handle overlaps!
            // (remember: first param of memcpy is dst, 2nd is src!)
            memmove(&g_DbgCodeCoverage[dwNewElem+1],
                    &g_DbgCodeCoverage[dwNewElem],
                    sizeof(g_DbgCodeCoverage[0])*(g_dwCodeCov_Cnt - dwNewElem)); 

            // now cleanup the fields
            memset(&g_DbgCodeCoverage[dwNewElem], 
                   0, 
                   sizeof(g_DbgCodeCoverage[dwNewElem]));   

            // now init them
            g_DbgCodeCoverage[dwNewElem].pCodeAddr = pCodeAddr;
            g_DbgCodeCoverage[dwNewElem].pszFileName = 
                                        g_DbgCodeCoverage[dwNewElem+1].pszFileName;
            g_DbgCodeCoverage[dwNewElem].dwLine = dwLine;              
            g_DbgCodeCoverage[dwNewElem].dwCodeType = DBG_SWITCH_CODE;
            g_DbgCodeCoverage[dwNewElem].dwCountFALSE = bCodeResult; // switch value
            g_DbgCodeCoverage[dwNewElem].dwCountTRUE =  1;           // found once            
            
        }
    }
    
    return bCodeResult;
} // Debug_Code_Coverage

//-----------------------------------------------------------------------------
//
// Debug_Code_Report_And_Reset
//
// Report the accumulated stats and then reset them.
//
// This should be called through the DrvEscape mechanism(Win2K) or through some
// easily controllable code path which we can use to trigger it.
//
//-----------------------------------------------------------------------------  
VOID
Debug_Code_Report_And_Reset(void)
{
    DWORD i; // counters

    DISPDBG((ERRLVL,
                "********* DEBUG FUNC COVERAGE (Debug_Code_Report) *********"));
    
    // Report if we have overflowed in any of our internal structures 
    // which would invalidate much of our results.
    if (g_dwCodeCov_Cnt >= DEBUG_MAX_CODE_COUNT)
    {
       DISPDBG((ERRLVL,"*** DEBUG CODE COVERAGE: g_DbgCodeCoverage exceeded "
                      "%d entries ***",DEBUG_MAX_CODE_COUNT));
    }
    
    // Headers of code coverage report
    DISPDBG((ERRLVL,"%12s %4s %8s %6s %6s",
                   "File","Line","Code","FALSE","TRUE"));

    // Go through each code called and report on its results
    for (i = 0; i < g_dwCodeCov_Cnt; i++)
    {
#if DBG_TRACK_CODE_REPORT_PROBLEMS_ONLY    
        // Report only 
        //   - if's that branched only one way
        //   - while's which were evaluated but not entered
        if ( ( (g_DbgCodeCoverage[i].dwCodeType == DBG_IF_CODE) &&
               (g_DbgCodeCoverage[i].dwCountFALSE == 0 ||
                g_DbgCodeCoverage[i].dwCountTRUE  == 0)            )  ||
             ( (g_DbgCodeCoverage[i].dwCodeType == DBG_WHILE_CODE) &&
               (g_DbgCodeCoverage[i].dwCountTRUE  == 0)            )  ||
             ( (g_DbgCodeCoverage[i].dwCodeType == DBG_SWITCH_CODE))  )
#endif
        // We report all the conditionals we've gone through so far
        DISPDBG((ERRLVL,"%12s %4d %8s %6d %6d",
                        g_DbgCodeCoverage[i].pszFileName,     
                        g_DbgCodeCoverage[i].dwLine,                   
                        g_cDbgCodeStrings[g_DbgCodeCoverage[i].dwCodeType],
                        g_DbgCodeCoverage[i].dwCountFALSE,
                        g_DbgCodeCoverage[i].dwCountTRUE  ));          
    }

    DISPDBG((ERRLVL,
                "************************************************************"));

    // Clear structures for next round of statistics gathering
    for (i= 0; i < DEBUG_MAX_CODE_COUNT; i++)
    {
        g_DbgCodeCoverage[i].pCodeAddr = NULL;
        g_DbgCodeCoverage[i].pszFileName = NULL;
        g_DbgCodeCoverage[i].dwLine = 0;
        g_DbgCodeCoverage[i].dwCodeType = 0;
        g_DbgCodeCoverage[i].dwCountFALSE = 0;
        g_DbgCodeCoverage[i].dwCountTRUE = 0;        
    }

    g_dwCodeCov_Cnt = 0;    
    
} // Debug_Code_Report_And_Reset

#endif // DBG_TRACK_CODE

//-----------------------------------------------------------------------------
//
//  ******************** PUBLIC DATA STRUCTURE DUMPING ************************
//
//-----------------------------------------------------------------------------
// 
// These are functions that help to dump the values of common DDI structures
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//
// DumpD3DBlend
//
// Dumps a D3DBLEND value
//
//-----------------------------------------------------------------------------
void DumpD3DBlend(int Level, DWORD i )
{
    switch ((D3DBLEND)i)
    {
        case D3DBLEND_ZERO:
            DISPDBG((Level, "  ZERO"));
            break;
        case D3DBLEND_ONE:
            DISPDBG((Level, "  ONE"));
            break;      
        case D3DBLEND_SRCCOLOR:
            DISPDBG((Level, "  SRCCOLOR"));
            break;
        case D3DBLEND_INVSRCCOLOR:
            DISPDBG((Level, "  INVSRCCOLOR"));
            break;
        case D3DBLEND_SRCALPHA:
            DISPDBG((Level, "  SRCALPHA"));
            break;
        case D3DBLEND_INVSRCALPHA:
            DISPDBG((Level, "  INVSRCALPHA"));
            break;
        case D3DBLEND_DESTALPHA:
            DISPDBG((Level, "  DESTALPHA"));
            break;
        case D3DBLEND_INVDESTALPHA:
            DISPDBG((Level, "  INVDESTALPHA"));
            break;
        case D3DBLEND_DESTCOLOR:
            DISPDBG((Level, "  DESTCOLOR"));
            break;
        case D3DBLEND_INVDESTCOLOR:
            DISPDBG((Level, "  INVDESTCOLOR"));
            break;
        case D3DBLEND_SRCALPHASAT:
            DISPDBG((Level, "  SRCALPHASAT"));
            break;
        case D3DBLEND_BOTHSRCALPHA:
            DISPDBG((Level, "  BOTHSRCALPHA"));
            break;
        case D3DBLEND_BOTHINVSRCALPHA:
            DISPDBG((Level, "  BOTHINVSRCALPHA"));
            break;
    }
} // DumpD3DBlend

//-----------------------------------------------------------------------------
//
// DumpD3DLight
//
// Dumps a D3DLIGHT7 structure
//
//-----------------------------------------------------------------------------
void DumpD3DLight(int DebugLevel, D3DLIGHT7* pLight)
{
    // FIXME
    DISPDBG((DebugLevel, "dltType:        %d", pLight->dltType));
    DISPDBG((DebugLevel, "dcvDiffuse:       (%f,%f,%f)", 
                          pLight->dcvDiffuse.r, 
                          pLight->dcvDiffuse.g, 
                          pLight->dcvDiffuse.b, 
                          pLight->dcvDiffuse.a));
    DISPDBG((DebugLevel, "dvPosition:     (%f,%f,%f)", 
                          pLight->dvPosition.x, 
                          pLight->dvPosition.y, 
                          pLight->dvPosition.z));
    DISPDBG((DebugLevel, "dvDirection:    (%f,%f,%f)", 
                          pLight->dvDirection.x, 
                          pLight->dvDirection.y, 
                          pLight->dvDirection.z));
    DISPDBG((DebugLevel, "dvRange:        %f", pLight->dvRange));
    DISPDBG((DebugLevel, "dvFalloff:      %f", pLight->dvFalloff));
    DISPDBG((DebugLevel, "dvAttenuation0: %f", pLight->dvAttenuation0));
    DISPDBG((DebugLevel, "dvAttenuation1: %f", pLight->dvAttenuation1));
    DISPDBG((DebugLevel, "dvAttenuation2: %f", pLight->dvAttenuation2));
    DISPDBG((DebugLevel, "dvTheta:        %f", pLight->dvTheta));
    DISPDBG((DebugLevel, "dvPhi:          %f", pLight->dvPhi));
    
} // DumpD3DLight

//-----------------------------------------------------------------------------
//
// DumpD3DMaterial
//
// Dumps a D3DMATERIAL7 structure
//
//-----------------------------------------------------------------------------
void DumpD3DMaterial(int DebugLevel, D3DMATERIAL7* pMaterial)
{
    DISPDBG((DebugLevel, "Diffuse  (%f, %f, %f)", 
                         pMaterial->diffuse.r, 
                         pMaterial->diffuse.g, 
                         pMaterial->diffuse.b, 
                         pMaterial->diffuse.a));
    DISPDBG((DebugLevel, "Ambient  (%f, %f, %f)", 
                         pMaterial->ambient.r, 
                         pMaterial->ambient.g, 
                         pMaterial->ambient.b, 
                         pMaterial->ambient.a));
    DISPDBG((DebugLevel, "Specular (%f, %f, %f)", 
                         pMaterial->specular.r, 
                         pMaterial->specular.g, 
                         pMaterial->specular.b, 
                         pMaterial->specular.a));
    DISPDBG((DebugLevel, "Emmisive (%f, %f, %f)", 
                         pMaterial->emissive.r, 
                         pMaterial->emissive.g, 
                         pMaterial->emissive.b, 
                         pMaterial->emissive.a));
    DISPDBG((DebugLevel, "Power    (%f)", pMaterial->power));
    
} // DumpD3DMaterial

//-----------------------------------------------------------------------------
//
// DumpD3DMatrix
//
// Dumps a D3DMATRIX structure
// 
//-----------------------------------------------------------------------------
void DumpD3DMatrix(int DebugLevel, D3DMATRIX* pMatrix)
{
    DISPDBG((DebugLevel, "(%f) (%f) (%f) (%f)", 
                         pMatrix->_11, 
                         pMatrix->_12, 
                         pMatrix->_13, 
                         pMatrix->_14));
    DISPDBG((DebugLevel, "(%f) (%f) (%f) (%f)", 
                         pMatrix->_21, 
                         pMatrix->_22, 
                         pMatrix->_23, 
                         pMatrix->_24));
    DISPDBG((DebugLevel, "(%f) (%f) (%f) (%f)", 
                         pMatrix->_31, 
                         pMatrix->_32, 
                         pMatrix->_33, 
                         pMatrix->_34));
    DISPDBG((DebugLevel, "(%f) (%f) (%f) (%f)", 
                         pMatrix->_41, 
                         pMatrix->_42, 
                         pMatrix->_43, 
                         pMatrix->_44));
} // DumpD3DMatrix

//-----------------------------------------------------------------------------
//
// DumpD3DState
//
// Dumps relevant D3D RS and TSS
// 
//-----------------------------------------------------------------------------
void DumpD3DState(int lvl, DWORD RS[], TexStageState TS[])
{
#define DUMPRS(rs)    DISPDBG((lvl,"%s = 0x%08x",#rs,RS[rs]));

    DWORD i,j;

    DISPDBG((lvl,"RELEVANT DX7 renderstates:"));
    DUMPRS( D3DRENDERSTATE_ZENABLE );
    DUMPRS( D3DRENDERSTATE_FILLMODE );
    DUMPRS( D3DRENDERSTATE_SHADEMODE );
    DUMPRS( D3DRENDERSTATE_LINEPATTERN );
    DUMPRS( D3DRENDERSTATE_ZWRITEENABLE );
    DUMPRS( D3DRENDERSTATE_ALPHATESTENABLE );
    DUMPRS( D3DRENDERSTATE_LASTPIXEL );
    DUMPRS( D3DRENDERSTATE_SRCBLEND );
    DUMPRS( D3DRENDERSTATE_DESTBLEND );
    DUMPRS( D3DRENDERSTATE_CULLMODE );
    DUMPRS( D3DRENDERSTATE_ZFUNC );
    DUMPRS( D3DRENDERSTATE_ALPHAREF );
    DUMPRS( D3DRENDERSTATE_ALPHAFUNC );
    DUMPRS( D3DRENDERSTATE_DITHERENABLE );
    DUMPRS( D3DRENDERSTATE_BLENDENABLE );
    DUMPRS( D3DRENDERSTATE_FOGENABLE );
    DUMPRS( D3DRENDERSTATE_SPECULARENABLE );
    DUMPRS( D3DRENDERSTATE_ZVISIBLE );
    DUMPRS( D3DRENDERSTATE_STIPPLEDALPHA );
    DUMPRS( D3DRENDERSTATE_FOGCOLOR );
    DUMPRS( D3DRENDERSTATE_FOGTABLEMODE );
    DUMPRS( D3DRENDERSTATE_FOGTABLESTART );
    DUMPRS( D3DRENDERSTATE_FOGTABLEEND );
    DUMPRS( D3DRENDERSTATE_FOGTABLEDENSITY );
    DUMPRS( D3DRENDERSTATE_EDGEANTIALIAS );    
    DUMPRS( D3DRENDERSTATE_ZBIAS );    
    DUMPRS( D3DRENDERSTATE_RANGEFOGENABLE );    
    DUMPRS( D3DRENDERSTATE_STENCILENABLE );
    DUMPRS( D3DRENDERSTATE_STENCILFAIL );            
    DUMPRS( D3DRENDERSTATE_STENCILZFAIL );
    DUMPRS( D3DRENDERSTATE_STENCILPASS );
    DUMPRS( D3DRENDERSTATE_STENCILFUNC );
    DUMPRS( D3DRENDERSTATE_STENCILREF );
    DUMPRS( D3DRENDERSTATE_STENCILMASK );
    DUMPRS( D3DRENDERSTATE_STENCILWRITEMASK );
    DUMPRS( D3DRENDERSTATE_TEXTUREFACTOR );
    DUMPRS( D3DRENDERSTATE_WRAP0 );
    DUMPRS( D3DRENDERSTATE_WRAP1 );        
    DUMPRS( D3DRENDERSTATE_WRAP2 );        
    DUMPRS( D3DRENDERSTATE_WRAP3 );
    DUMPRS( D3DRENDERSTATE_WRAP4 );
    DUMPRS( D3DRENDERSTATE_WRAP5 );
    DUMPRS( D3DRENDERSTATE_WRAP6 );
    DUMPRS( D3DRENDERSTATE_WRAP7 );        
    DUMPRS( D3DRENDERSTATE_LOCALVIEWER );
    DUMPRS( D3DRENDERSTATE_CLIPPING );
    DUMPRS( D3DRENDERSTATE_LIGHTING );
    DUMPRS( D3DRENDERSTATE_AMBIENT );
    DUMPRS( D3DRENDERSTATE_SCENECAPTURE );
    DUMPRS( D3DRENDERSTATE_EVICTMANAGEDTEXTURES );        
    DUMPRS( D3DRENDERSTATE_TEXTUREHANDLE );
    DUMPRS( D3DRENDERSTATE_ANTIALIAS );
    DUMPRS( D3DRENDERSTATE_TEXTUREPERSPECTIVE );
    DUMPRS( D3DRENDERSTATE_TEXTUREMAPBLEND );
    DUMPRS( D3DRENDERSTATE_TEXTUREMAG );
    DUMPRS( D3DRENDERSTATE_TEXTUREMIN );
    DUMPRS( D3DRENDERSTATE_WRAPU );
    DUMPRS( D3DRENDERSTATE_WRAPV );
    DUMPRS( D3DRENDERSTATE_TEXTUREADDRESS );
    DUMPRS( D3DRENDERSTATE_TEXTUREADDRESSU );
    DUMPRS( D3DRENDERSTATE_TEXTUREADDRESSV );
    DUMPRS( D3DRENDERSTATE_MIPMAPLODBIAS );
    DUMPRS( D3DRENDERSTATE_BORDERCOLOR );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN00 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN01 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN02 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN03 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN04 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN05 );   
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN06 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN07 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN08 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN09 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN10 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN11 ); 
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN12 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN13 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN14 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN15 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN16 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN17 ); 
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN18 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN19 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN20 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN21 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN22 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN23 ); 
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN24 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN25 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN26 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN27 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN28 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN29 );   
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN30 );
    DUMPRS( D3DRENDERSTATE_STIPPLEPATTERN31 );     
    DUMPRS( D3DRENDERSTATE_ROP2 );
    DUMPRS( D3DRENDERSTATE_PLANEMASK );
    DUMPRS( D3DRENDERSTATE_MONOENABLE );
    DUMPRS( D3DRENDERSTATE_SUBPIXEL );
    DUMPRS( D3DRENDERSTATE_SUBPIXELX );
    DUMPRS( D3DRENDERSTATE_STIPPLEENABLE );
    DUMPRS( D3DRENDERSTATE_COLORKEYENABLE );

#if DX8_DDI
    DISPDBG((lvl,"RELEVANT DX8 renderstates:"));
    DUMPRS( D3DRS_POINTSIZE );
    DUMPRS( D3DRS_POINTSPRITEENABLE );
    DUMPRS( D3DRS_POINTSIZE_MIN );
    DUMPRS( D3DRS_POINTSIZE_MAX );
    DUMPRS( D3DRS_POINTSCALEENABLE );
    DUMPRS( D3DRS_POINTSCALE_A );
    DUMPRS( D3DRS_POINTSCALE_B );
    DUMPRS( D3DRS_POINTSCALE_C );
    DUMPRS( D3DRS_SOFTWAREVERTEXPROCESSING );
    DUMPRS( D3DRS_COLORWRITEENABLE );
    DUMPRS( D3DRS_MULTISAMPLEANTIALIAS );
#endif // DX8_DDI

    for (i=0; i<D3DHAL_TSS_MAXSTAGES; i++)
    {
        DISPDBG((lvl," TS[%d].",i));
        for (j=0; j<D3DTSS_MAX; j++)
        {
            DISPDBG((lvl, "    .[%d] = 0x%08x",j,TS[i].m_dwVal[j] ));
        }
    }
} // DumpD3DState

//-----------------------------------------------------------------------------
//
// DumpVertices
//
// Dumps vertices from a VB
// 
//-----------------------------------------------------------------------------
void DumpVertices(int lvl,
                  P3_D3DCONTEXT* pContext, 
                  LPBYTE lpVertices, 
                  DWORD dwNumVertices)
{
    DWORD i,j;
    DWORD *lpw = (DWORD *)lpVertices;

    for (i=0 ; i<dwNumVertices; i++)
    {
        DISPDBG((lvl,"Vertex # %d", i));
        for (j=0; j < pContext->FVFData.dwStride; j+=4)
        {
            DISPDBG((lvl,"        0x%08x",*lpw++));
        }
    }
} // DumpVertices

//-----------------------------------------------------------------------------
//
// DumpHexData
//
// Dumps hexadecimal data
// 
//-----------------------------------------------------------------------------
void DumpHexData(int lvl,
                 LPBYTE lpData, 
                 DWORD dwNumBytes)
{
    DWORD i , iRemChars, iSlen;
    DWORD *lpdw = (DWORD *)lpData;
    char  s[80] = "",m[80] = "";

    iRemChars = 80;

    for (i=0 ; i <= (dwNumBytes / sizeof(DWORD)); i++)
    {
        sprintf(s,"0x%08x ",*lpdw++);

        iSlen = strlen(s);

        if (iSlen < iRemChars)
        {
            strncat(m,s,iRemChars);
            iRemChars -= iSlen;       
        }
        
        if ( ((i % 6) == 5) ||
             (i == (dwNumBytes / sizeof(DWORD))) )             
        {
            DISPDBG((lvl,"%s",m));
            s[0] = m[0] = '\0';
        }
    }
 
    
} // DumpVertices

//-----------------------------------------------------------------------------
//
// DumpDDSurface
//
// Dumps a LPDDRAWI_DDRAWSURFACE_LCL ( PDD_SURFACE_LOCAL on Win2K)  structure
// 
//-----------------------------------------------------------------------------
#define CAPS_REPORT(param)                          \
        if (ddsCaps.dwCaps & DDSCAPS_##param)       \
        {                                           \
            DISPDBG((Level, "   " #param));         \
        }

#define CAPS_REPORT2(param)                         \
        if (pSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_##param)     \
        {                                           \
            DISPDBG((Level, "   " #param));         \
        }

void DumpDDSurface(int DebugLevel, LPDDRAWI_DDRAWSURFACE_LCL pSurface)
{
    LPDDPIXELFORMAT pPixFormat;
    P3_SURF_FORMAT* pFormatSurface = _DD_SUR_GetSurfaceFormat(pSurface);
    DDSCAPS ddsCaps;
    int Level = -100;

    if (DebugLevel <= P3R3DX_DebugLevel)
    {
        DISPDBG((Level,"Surface Dump:"));

        DISPDBG((Level,"Format: %s", pFormatSurface->pszStringFormat));
            
        // Get the surface format
        pPixFormat = DDSurf_GetPixelFormat(pSurface);

        ddsCaps = pSurface->ddsCaps;
        DISPDBG((Level, "    Surface Width:          0x%x", pSurface->lpGbl->wWidth));
        DISPDBG((Level, "    Surface Height:         0x%x", pSurface->lpGbl->wHeight));
        DISPDBG((Level, "    Surface Pitch:          0x%x", pSurface->lpGbl->lPitch));
        DISPDBG((Level, "    ddsCaps.dwCaps:         0x%x", pSurface->ddsCaps.dwCaps));
        DISPDBG((Level, "    dwFlags:                0x%x", pSurface->dwFlags));
        DISPDBG((Level, "  Pixel Format:"));
        DISPDBG((Level, "    dwFourCC:               0x%x", pPixFormat->dwFourCC));
        DISPDBG((Level, "    dwRGBBitCount:          0x%x", pPixFormat->dwRGBBitCount));
        DISPDBG((Level, "    dwR/Y BitMask:          0x%x", pPixFormat->dwRBitMask));
        DISPDBG((Level, "    dwG/U BitMask:          0x%x", pPixFormat->dwGBitMask));
        DISPDBG((Level, "    dwB/V BitMask:          0x%x", pPixFormat->dwBBitMask));
        DISPDBG((Level, "    dwRGBAlphaBitMask:      0x%x", pPixFormat->dwRGBAlphaBitMask));
#ifndef WNT_DDRAW
        DISPDBG((Level, "    DestBlt:     dwColorSpaceLowValue:  0x%x", pSurface->ddckCKDestBlt.dwColorSpaceLowValue));
        DISPDBG((Level, "    DestBlt:     dwColorSpaceHighValue: 0x%x", pSurface->ddckCKDestBlt.dwColorSpaceHighValue));
        DISPDBG((Level, "    SrcBlt:      dwColorSpaceLowValue:  0x%x", pSurface->ddckCKSrcBlt.dwColorSpaceLowValue));
        DISPDBG((Level, "    SrcBlt:      dwColorSpaceHighValue: 0x%x", pSurface->ddckCKSrcBlt.dwColorSpaceHighValue));
#endif
        DISPDBG((Level, "  Surface Is:"));

        CAPS_REPORT(TEXTURE);
        CAPS_REPORT(PRIMARYSURFACE);
        CAPS_REPORT(OFFSCREENPLAIN);
        CAPS_REPORT(FRONTBUFFER);
        CAPS_REPORT(BACKBUFFER);
        CAPS_REPORT(COMPLEX);
        CAPS_REPORT(FLIP);
        CAPS_REPORT(OVERLAY);
        CAPS_REPORT(MODEX);
        CAPS_REPORT(ALLOCONLOAD);
        CAPS_REPORT(LIVEVIDEO);
        CAPS_REPORT(PALETTE);
        CAPS_REPORT(SYSTEMMEMORY);
        CAPS_REPORT(3DDEVICE);
        CAPS_REPORT(VIDEOMEMORY);
        CAPS_REPORT(VISIBLE);
        CAPS_REPORT(MIPMAP);
        // not supported in NT until we get NT5 (which will have DX5)
        CAPS_REPORT(VIDEOPORT);
        CAPS_REPORT(LOCALVIDMEM);
        CAPS_REPORT(NONLOCALVIDMEM);
        CAPS_REPORT(WRITEONLY);

        if (pSurface->lpSurfMore)
        {
            CAPS_REPORT2(HARDWAREDEINTERLACE);
            CAPS_REPORT2(HINTDYNAMIC);
            CAPS_REPORT2(HINTSTATIC);
            CAPS_REPORT2(TEXTUREMANAGE);
            CAPS_REPORT2(OPAQUE);
            CAPS_REPORT2(HINTANTIALIASING);
#if W95_DDRAW
            CAPS_REPORT2(VERTEXBUFFER);
            CAPS_REPORT2(COMMANDBUFFER);
#endif
        }

        if (pPixFormat->dwFlags & DDPF_ZBUFFER)
        {
            DISPDBG((Level,"   Z BUFFER"));
        }
        
        if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
        {
            DISPDBG((Level,"   ALPHAPIXELS"));
        }
        
        // not supported in NT until we get NT5
        if (pPixFormat->dwFlags & DDPF_LUMINANCE)
        {
            DISPDBG((Level,"   LUMINANCE"));
        }

        if (pPixFormat->dwFlags & DDPF_ALPHA)
        {
            DISPDBG((Level,"   ALPHA"));
        }
    }
} // DumpDDSurface


char *pcSimpleCapsString(DWORD dwCaps)
{
    static char flags[5];
        
    flags[0] = flags[1] = flags[2] = flags[3] = ' '; flags[4] = 0;
    
    if(dwCaps & DDSCAPS_TEXTURE) flags[1] = 'T';
    if(dwCaps & DDSCAPS_ZBUFFER) flags[2] = 'Z';
    if(dwCaps & DDSCAPS_3DDEVICE) flags[3] = 'R';        

    if(dwCaps & DDSCAPS_VIDEOMEMORY) 
    {
        flags[0] = 'V'; 
    }
    else if(dwCaps & DDSCAPS_NONLOCALVIDMEM) 
    {
        flags[0] = 'A'; 
    }
    else                   
    {
        flags[0] = 'S';
    }

    return flags;
} // cSimpleCapsString


//-----------------------------------------------------------------------------
//
// DumpDDSurfaceDesc
//
// Dumps a DDSURFACEDESC structure
//
//-----------------------------------------------------------------------------
#define CAPS_REPORT_DESC(param)                             \
        if (pDesc->ddsCaps.dwCaps & DDSCAPS_##param)        \
        {                                                   \
            DISPDBG((Level, "   " #param));                 \
        }

#define CAPS_REPORT_DESC2(param)                                          \
        if (((DDSURFACEDESC2*)pDesc)->ddsCaps.dwCaps2 & DDSCAPS2_##param) \
        {                                                                 \
            DISPDBG((Level, "   " #param));                               \
        }

void DumpDDSurfaceDesc(int DebugLevel, DDSURFACEDESC* pDesc)
{
    DDPIXELFORMAT* pPixFormat = &pDesc->ddpfPixelFormat;
    int Level = -100;

    if (DebugLevel <= P3R3DX_DebugLevel)
    {
        DISPDBG((Level,"Surface Dump:"));
        
        DISPDBG((Level, "    Surface Width:          0x%x", pDesc->dwWidth));
        DISPDBG((Level, "    Surface Height:         0x%x", pDesc->dwHeight));
        DISPDBG((Level, "    ddsCaps.dwCaps:         0x%x", pDesc->ddsCaps.dwCaps));
        DISPDBG((Level, "    dwFlags:                0x%x", pDesc->dwFlags));
        DISPDBG((Level, "Pixel Format:"));
        DISPDBG((Level, "    dwFourCC:               0x%x", pPixFormat->dwFourCC));
        DISPDBG((Level, "    dwRGBBitCount:          0x%x", pPixFormat->dwRGBBitCount));
        DISPDBG((Level, "    dwR/Y BitMask:          0x%x", pPixFormat->dwRBitMask));
        DISPDBG((Level, "    dwG/U BitMask:          0x%x", pPixFormat->dwGBitMask));
        DISPDBG((Level, "    dwB/V BitMask:          0x%x", pPixFormat->dwBBitMask));
        DISPDBG((Level, "    dwRGBAlphaBitMask:      0x%x", pPixFormat->dwRGBAlphaBitMask));
        DISPDBG((Level, "Surface Is:"));

        CAPS_REPORT_DESC(TEXTURE);
        CAPS_REPORT_DESC(PRIMARYSURFACE);
        CAPS_REPORT_DESC(OFFSCREENPLAIN);
        CAPS_REPORT_DESC(FRONTBUFFER);
        CAPS_REPORT_DESC(BACKBUFFER);
        CAPS_REPORT_DESC(COMPLEX);
        CAPS_REPORT_DESC(FLIP);
        CAPS_REPORT_DESC(OVERLAY);
        CAPS_REPORT_DESC(MODEX);
        CAPS_REPORT_DESC(ALLOCONLOAD);
        CAPS_REPORT_DESC(LIVEVIDEO);
        CAPS_REPORT_DESC(PALETTE);
        CAPS_REPORT_DESC(SYSTEMMEMORY);
        CAPS_REPORT_DESC(3DDEVICE);
        CAPS_REPORT_DESC(VIDEOMEMORY);
        CAPS_REPORT_DESC(VISIBLE);
        CAPS_REPORT_DESC(MIPMAP);
        CAPS_REPORT_DESC(VIDEOPORT);
        CAPS_REPORT_DESC(LOCALVIDMEM);
        CAPS_REPORT_DESC(NONLOCALVIDMEM);
        CAPS_REPORT_DESC(STANDARDVGAMODE);
        CAPS_REPORT_DESC(OPTIMIZED);
        CAPS_REPORT_DESC(EXECUTEBUFFER);
        CAPS_REPORT_DESC(WRITEONLY);

        if (pDesc->dwSize == sizeof(DDSURFACEDESC2))
        {
            CAPS_REPORT_DESC2(HARDWAREDEINTERLACE);
            CAPS_REPORT_DESC2(HINTDYNAMIC);
            CAPS_REPORT_DESC2(HINTSTATIC);
            CAPS_REPORT_DESC2(TEXTUREMANAGE);
            CAPS_REPORT_DESC2(OPAQUE);
            CAPS_REPORT_DESC2(HINTANTIALIASING);
#if W95_DDRAW
            CAPS_REPORT_DESC2(VERTEXBUFFER);
            CAPS_REPORT_DESC2(COMMANDBUFFER);
#endif
        }

        if (pPixFormat->dwFlags & DDPF_ZBUFFER)
        {
            DISPDBG((Level,"   Z BUFFER"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
        {
            DISPDBG((Level,"   ALPHAPIXELS"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHA)
        {
            DISPDBG((Level,"   ALPHA"));
        }
    }
}

//-----------------------------------------------------------------------------
//
// DumpDP2Flags
//
// Dumps the meaning of the D3D DrawPrimitives2 flags
//
//-----------------------------------------------------------------------------
void
DumpDP2Flags( DWORD lvl, DWORD flags )
{
    if( flags & D3DHALDP2_USERMEMVERTICES )
        DISPDBG((lvl, "    USERMEMVERTICES" ));

    if( flags & D3DHALDP2_EXECUTEBUFFER )
        DISPDBG((lvl, "    EXECUTEBUFFER" ));

    if( flags & D3DHALDP2_SWAPVERTEXBUFFER )
        DISPDBG((lvl, "    SWAPVERTEXBUFFER" ));

    if( flags & D3DHALDP2_SWAPCOMMANDBUFFER )
        DISPDBG((lvl, "    SWAPCOMMANDBUFFER" ));

    if( flags & D3DHALDP2_REQVERTEXBUFSIZE )
        DISPDBG((lvl, "    REQVERTEXBUFSIZE" ));

    if( flags & D3DHALDP2_REQCOMMANDBUFSIZE )
        DISPDBG((lvl, "    REQCOMMANDBUFSIZE" ));
        
} // DumpDP2Flags

//-----------------------------------------------------------------------------
//
//  ********************** LOW LEVEL DEBUGGING SUPPORT ************************
//
//-----------------------------------------------------------------------------

LONG P3R3DX_DebugLevel = 0;

#if W95_DDRAW

void DebugRIP()       
{
    _asm int 1;
}
#endif  //  W95_DDRAW

static char *BIG    = "<+/-large_float>";

#if defined(_X86_)
void
expandFloats(char *flts, char *format, va_list argp)
{
    int ch;
    double f;
    unsigned int ip, fp;
    int *ap = (int *)argp;
    int *dp = ap;

    while (ch = *format++) {
        if (ch == '%') {
            ch = *format++;     // Get the f, s, c, i, d, x etc...
            if (!ch)
                return;         // If someone foolishly gave me "hello %"
            switch (ch) {
            case 'f':
            case 'g':
            case 'e':
                // Here we have a double that needs 
                // replacing with a string equivalent.
                f = *(double *)ap;
                *(format - 1) = 's';    // Tell it to get a string next time!
                *((char **)dp) = flts;  // This is where I'll put the string
                ap += 2;                // Skip the double in the source
                dp++;                   // Skip the new string pointer
                
                if (f < 0) 
                {
                    *flts++ = '-';
                    f = -f;
                }
                
                if (f > LONG_MAX) 
                {
                    *((char **)ap - 2) = BIG;
                    break;
                }
                myFtoi((int*)&ip, (float)f);
                // The state of the floating point flags is indeterminate here.  
                // You may get truncation which you want, you may get rounding,
                // which you don't want.
                if (ip > f)
                {
                    // rounding will have made (ip = f+1) sometimes
                    ip -= 1;
                }
                
                {
                    double fTemp = ((f * 1e6) - (ip * 1e6));
                    myFtoi((int*)&fp, (float)fTemp);
                }
#if W95_DDRAW
                wsprintf(flts, "%u.%06u", ip, fp);
#endif

                flts += 1 + strlen(flts);       // advance the pointer to where 
                                                // the next float will be expanded
                break;

            case '%':
                break;

            default:
                *dp++ = *ap++;      // copy the argument (down) the list
                break;
            }
        }
    }
} // expandFloats()
#else
void
expandFloats(char *flts, char *format, va_list argp)
{
    // do nothing if it's not _X86_
}
#endif // defined(_X86_)

#ifdef WNT_DDRAW
void Drv_strcpy(char *szDest, char *szSrc)
{
    do
    {
        *szDest++ = *szSrc++;
    } while (*szSrc != 0);
    
    *szDest = '\0';
}

void __cdecl DebugPrintNT(LONG  DebugPrintLevel, PCHAR DebugMessage, ...)
{
    char    floatstr[256];
    char    szFormat[256];

    va_list ap;

    va_start(ap, DebugMessage);

    CheckChipErrorFlags();

    if (DebugPrintLevel <= P3R3DX_DebugLevel)
    {
        Drv_strcpy(szFormat, DebugMessage);
        expandFloats(floatstr, szFormat, ap);
        EngDebugPrint("PERM3DD: ", szFormat, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

} // DebugPrint()
#else

#define START_STR   "DX"
#define END_STR     ""

//
// DebugPrint
//
// display a debug message
//     
void __cdecl DebugPrint(LONG DebugLevelPrint, LPSTR format, ... )
{
    char    str[256];
    char    floatstr[256];
    char    szFormat[256];
    
    va_list ap;

    va_start(ap, format);

    // If you set the debug level negative then you don't check the error
    // flags - this lets an optimised debug build run quicker

    if( P3R3DX_DebugLevel >= 0 )
    {
        CheckChipErrorFlags();
    }

    if (DebugLevelPrint <= P3R3DX_DebugLevel)
    {
        // Take a copy of the format string so that I can change "%f" to "%s".
        lstrcpy(szFormat, format);

        expandFloats(floatstr, szFormat, ap);
        if (g_pThisTemp)
        {
         wsprintf((LPSTR)str, "%s(%d):    ", 
                              START_STR, 
                              (int)g_pThisTemp->pGLInfo->dwCurrentContext);
        }
        else
        {
         wsprintf((LPSTR)str, "%s: 0      ", START_STR);
        }
        
        wvsprintf(str + strlen(START_STR) + 7, szFormat, ap);

        wsprintf( str + strlen( str ), "%s", "\r\n" );

        OutputDebugString( str );
    }

    va_end(ap);
} // DebugPrint 

#endif // WNT_DDRAW

//-----------------------------------------------------------------------------
//
//  ****************** HARDWARE DEPENDENT DEBUGGING SUPPORT *******************
//
//-----------------------------------------------------------------------------

P3_THUNKEDDATA* g_pThisTemp = NULL;

BOOL g_bDetectedFIFOError = FALSE;

BOOL CheckFIFOEntries(DWORD Count)
{
    if (g_pThisTemp)
    {
        if (!g_bDetectedFIFOError)
        {
            g_pThisTemp->EntriesLeft -= Count;
            g_pThisTemp->DMAEntriesLeft -= Count;
    
            // TURN_ON_DISCONNECT will set Entries left to -20000
            if ( ( (signed)g_pThisTemp->EntriesLeft < 0 ) && 
                 ( (signed)g_pThisTemp->EntriesLeft > -10000 ) ) 
            {
                g_bDetectedFIFOError = TRUE;
                return TRUE;
            }
            
            // Disconnects are irrelevant to DMA buffers.
            if ( ( (signed)g_pThisTemp->DMAEntriesLeft < 0 ) && 
                 ( (signed)g_pThisTemp->DMAEntriesLeft > -10000 ) ) 
            {
                g_bDetectedFIFOError = TRUE;
                return TRUE;
            }
        }
    }
    return FALSE;
} // CheckFIFOEntries

#ifdef WNT_DDRAW
void
CheckChipErrorFlags()
{
    char Buff[100];

    if (g_pThisTemp != NULL)
    {
        P3_THUNKEDDATA* pThisDisplay = g_pThisTemp;
        DWORD _temp_ul;
        DWORD _temp_ul2;
        
        _temp_ul = READ_GLINT_CTRL_REG(ErrorFlags); 
        _temp_ul2 = READ_GLINT_CTRL_REG(DeltaErrorFlags); 
        
        _temp_ul |= _temp_ul2; 
        _temp_ul &= ~0x2;       // we're not interested in output fifo errors 
        _temp_ul &= ~0x10;      // ignore any Video FIFO underrun errors on P2
        _temp_ul &= ~0x2000;    // ignore any host-in DMA errors 
        if (_temp_ul != 0) 
        { 
            // DISPDBG((-1000, "PERM3DD: %s", Buff));
            //EngDebugBreak();
            LOAD_GLINT_CTRL_REG(ErrorFlags, _temp_ul); 
            LOAD_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul);
        } 
    }
} // CheckChipErrorFlags()
#else
void
CheckChipErrorFlags()
{
    DWORD dw;
    char buff[64];

    if (!g_pThisTemp) return;
    if (!g_pThisTemp->pGLInfo) return;

    // Only check the error flags if we aren't DMA'ing.
    if (!(g_pThisTemp->pGLInfo->GlintBoardStatus & GLINT_DMA_COMPLETE)) return;

    if (g_pThisTemp->pGlint) {
        dw = g_pThisTemp->pGlint->ErrorFlags & ~0x10;
        if (dw & (dw != 2)) {
            wsprintf(buff, "** Render Chip Error ** [0x%X]!\r\n", dw);
            OutputDebugString(buff);
            g_pThisTemp->pGlint->ErrorFlags = dw;
            OutputDebugString("** Cleared... **\r\n");
            DebugRIP();
        }
        dw = g_pThisTemp->pGlint->DeltaErrorFlags & ~0x10;
        if (dw & (dw != 2)) {
            wsprintf(buff, "** Delta Error ** [0x%X]!\r\n", dw);
            OutputDebugString(buff);
            g_pThisTemp->pGlint->DeltaErrorFlags = dw;
            OutputDebugString("** Cleared... **\r\n");
            DebugRIP();
        }
    }
} // CheckChipErrorFlags()
#endif // WNT_DDRAW

void 
ColorArea(
    ULONG_PTR pBuffer, 
    DWORD dwWidth, 
    DWORD dwHeight, 
    DWORD dwPitch, 
    int iBitDepth, 
    DWORD dwValue)
{
    DWORD CountY;
    DWORD CountX;
    switch (iBitDepth)
    {
        case __GLINT_8BITPIXEL:
        {
            for (CountY = 0; CountY < dwHeight; CountY++)
            {
                BYTE* pCurrentPixel = (BYTE*)pBuffer;
                for (CountX = 0; CountX < dwWidth; CountX++)
                {
                    *pCurrentPixel++ = (BYTE)dwValue;
                }
                pBuffer += dwPitch;
            }
        }
        break;
        case __GLINT_16BITPIXEL:
        {
            for (CountY = 0; CountY < dwHeight; CountY++)
            {
                WORD* pCurrentPixel = (WORD*)pBuffer;
                for (CountX = 0; CountX < dwWidth; CountX++)
                {
                    *pCurrentPixel++ = (WORD)dwValue;
                }
                pBuffer += dwPitch;
            }
        }
        break;
        case __GLINT_32BITPIXEL:
        case __GLINT_24BITPIXEL:
        {
            for (CountY = 0; CountY < dwHeight; CountY++)
            {
                DWORD* pCurrentPixel = (DWORD*)pBuffer;
                for (CountX = 0; CountX < dwWidth; CountX++)
                {
                    *pCurrentPixel++ = (DWORD)dwValue;
                }
                pBuffer += dwPitch;
            }
        }
        break;
    }
} // ColorArea

//@@BEGIN_DDKSPLIT   
static int unitsBits[] = {
    13, 12, 11, 10,
    3, 2, 8, 7,
    18, 15, 14, 6,
    5, 1, 0
};

static char *unitNames[] = {
    "HostOut", "FBWrite", "LogicOp", "Dither",
    "Texture/Fog/Blend", "ColourDDA", "FBRead", "LBWrite",
    "YUV", "TextureRead", "TextureAddress", "StencilDepth",
    "LBRead", "Scissor/Stipple", "Rasterizer"
};

#define NUM_UNITS (sizeof(unitsBits) / sizeof(unitsBits[0]))

void
DisableChipUnits()
{
    int     i, count;
    DWORD   inSpace = g_pThisTemp->pGlint->InFIFOSpace;
    BOOL    helped = FALSE;
    volatile DWORD *testReg;
    volatile DWORD *addrMode = &g_pThisTemp->pGlint->TextureAddressMode;

    DISPDBG((ERRLVL, "TextureAddressMode = 0x%08X", *addrMode));

    i = 0;
    testReg = &g_pThisTemp->pGlint->TestRegister;
    for (count = 0; count < NUM_UNITS; count++) {
        i = 1L << unitsBits[count];
        *testReg = i;
        *testReg = 0;
        *testReg = i;
        *testReg = 0;
        if (inSpace != g_pThisTemp->pGlint->InFIFOSpace) {
            DISPDBG((ERRLVL, "Chip unlocked by disabling unit \"%s\"", unitNames[count]));
            helped = TRUE;
            inSpace = g_pThisTemp->pGlint->InFIFOSpace;
        }
    }

    if (helped) {
        DISPDBG((ERRLVL, "Which helped..."));
    } else {
        DISPDBG((ERRLVL, "Chip still locked"));
        *testReg = ~0UL;
        *testReg = 0;
        *testReg = ~0UL;
        *testReg = 0;
        if (inSpace == g_pThisTemp->pGlint->InFIFOSpace) {
            DISPDBG((ERRLVL, "Writing -1 didn't help"));
        } else {
            DISPDBG((ERRLVL, "BUT! Writing -1 frees some space..."));
        }
    }

    DISPDBG((ERRLVL, "TextureAddressMode = 0x%08X", *addrMode));

} // DisableChipUnits()


#if 0
StatRecord stats[LAST_STAT + 2] = {
    {"Locks         ", 0, 0},
    {"TextureChanges", 0, 0},
    {"D3DSynchs     ", 0, 0},
    {"StateChanges  ", 0, 0},
    {"...no change  ", 0, 0},
    {"Blits         ", 0, 0},
    {"DMA Buffers   ", 0, 0},
    {"DMA DWORDS    ", 0, 0},
    {"DMA time > CPU", 0, 0},
    {"CPU time > DMA", 0, 0},
    {"Wait on DMA   ", 0, 0},
    {"Execute       ", 0, 0},
    {"Tris          ", 0, 0},
    {"FF Tris       ", 0, 0},
    {"Vanilla Render", 0, 0},
    {"Points        ", 0, 0},
    {"Lines         ", 0, 0},
    {"DPrm TFans    ", 0, 0},
    {"DPrm TStrps   ", 0, 0},
    {"DPrm TLists   ", 0, 0},
    {"DPrm TFansIdx ", 0, 0},
    {"DPrm TStrpsIdx", 0, 0},
    {"DPrm TListsIdx", 0, 0},
    {"Total vertices", 0, 0},
    {"...cached     ", 0, 0},
    {"Alpha strips  ", 0, 0},
    {"Mip strips    ", 0, 0},
    {"VALIDATEDEVICE", 0, 0},
    // Add any extras just in front of this comment
    {"**scene no**  ", 0, 0},
    {"**flip count**", 0, 0}
};
#endif
//@@END_DDKSPLIT

const char *getTagString( GlintDataPtr glintInfo, ULONG tag ) {
        return p3r3TagString( tag & ((1 << 12) - 1) );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\directx.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: directx.h
*
* Content: DirectX macros and definitions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation
\**************************************************************************/

#ifndef __DIRECTX_H
#define __DIRECTX_H

#ifdef WNT_DDRAW
#include "dx95type.h"
#endif

#ifndef __GLINTDEF
#include "glintdef.h"
#endif

#include "pmdef.h"

#ifndef __P3RXDEF
#include "p3rxdef.h"
#endif

#include "surf_fmt.h"
#include "ddover.h"

//------------------------------------------------------------------
//
//------------------------------------------------------------------
#define VTG_MEMORY_ADDRESS(a) (0x1000F | (((a >> 2) << 4) & 0xFFFF) )
#define VTG_VIDEO_ADDRESS(a) (0x20000 | (((a >> 2) << 4) & 0xFFFF) )
#define MEM_MEMORYSCRATCH 0x10
#define VID_SCREENBASE 0x0
#if DX7_STEREO
#define VID_VIDEOCONTROL        0x58
#define VID_SCREENBASERIGHT     0x80
#define __VIDEO_STEREOENABLE    0x800
#endif 

//------------------------------------------------------------------
//
//------------------------------------------------------------------
#if !DBG
#define STOP_SOFTWARE_CURSOR(pThisDisplay)                           \
            pThisDisplay->pGLInfo->dwFlags |= GMVF_GCOP
#define START_SOFTWARE_CURSOR(pThisDisplay)                          \
            pThisDisplay->pGLInfo->dwFlags &= ~GMVF_GCOP
#else

#define STOP_SOFTWARE_CURSOR(pThisDisplay)                           \
{                                                                    \
    DISPDBG((DBGLVL, "STOP_SW_CURSOR %s %d", __FILE__, __LINE__ ));  \
    if (pThisDisplay->pGLInfo->dwFlags & GMVF_GCOP)                  \
        DISPDBG((WRNLVL,"Stopping Cursor that is already stopped!"));\
    pThisDisplay->pGLInfo->dwFlags |= GMVF_GCOP;                     \
}

#define START_SOFTWARE_CURSOR(pThisDisplay)                          \
{                                                                    \
    DISPDBG((DBGLVL, "START_SW_CURSOR %s, %d", __FILE__, __LINE__ ));\
    if (!(pThisDisplay->pGLInfo->dwFlags & GMVF_GCOP))               \
        DISPDBG((WRNLVL,"Starting Cursor that is already started!"));\
    pThisDisplay->pGLInfo->dwFlags &= ~GMVF_GCOP;                    \
}

#endif // !DBG

//------------------------------------------------------------------
//
//------------------------------------------------------------------
// From MS, undocumented sharing flag
#define HEAP_SHARED     0x04000000      // put heap in shared memory

//------------------------------------------------------------------
// Defines for video flipping, etc.
//------------------------------------------------------------------
#define IN_VBLANK                                                         \
        (pThisDisplay->pGlint->LineCount < pThisDisplay->pGlint->VbEnd)

#define IN_DISPLAY          (!IN_VBLANK)

//------------------------------------------------------------------
//
//------------------------------------------------------------------
#if WNT_DDRAW

#define DXCONTEXT_IMMEDIATE(pThisDisplay)                           \
    vGlintSwitchContext(pThisDisplay->ppdev,                        \
                        pThisDisplay->ppdev->DDContextID);
                        
#define IS_DXCONTEXT_CURRENT(pThisDisplay)                          \
        (((pThisDisplay->ppdev->currentCtxt) !=                     \
          (pThisDisplay->ppdev->DDContextID)) ? FALSE : TRUE)
           
#else   //  WNT_DDRAW

#define DXCONTEXT_IMMEDIATE(pThisDisplay)             \
    ChangeContext(pThisDisplay,                       \
                  pThisDisplay->pGLInfo,              \
                  CONTEXT_DIRECTX_HANDLE); 

#define IS_DXCONTEXT_CURRENT(pThisDisplay)                                   \
    ((pThisDisplay->pGLInfo->dwCurrentContext != CONTEXT_DIRECTX_HANDLE) ?   \
                                                                FALSE : TRUE)
#endif  //  WNT_DDRAW

//------------------------------------------------------------------
// For comparing GUID's
//------------------------------------------------------------------
#ifdef __cplusplus
#define MATCH_GUID(a, b) IsEqualIID((a), (b))
#else
#define MATCH_GUID(a, b) IsEqualIID(&(a), &(b))
#endif



//------------------------------------------------------------------
// Registry
//------------------------------------------------------------------
#ifdef WNT_DDRAW
#define GET_REGISTRY_ULONG_FROM_STRING(a, b)                             \
    bGlintQueryRegistryValueUlong(pThisDisplay->ppdev, L##a, (DWORD*)b)
#define SET_REGISTRY_STRING_FROM_ULONG(a, b)                             \
    bGlintSetRegistryValueString(pThisDisplay->ppdev, L##a, b)
#define GET_REGISTRY_STRING(a, b)                                        \
    bGlintQueryRegistryValueString(pThisDisplay->ppdev, L##a, b, c)
#else
// Win95 calls the same registry call as it always did, 
// NT makes the call with an extra parameter - the ppdev
BOOL bGlintQueryRegistryValueString(LPTSTR valueStr, 
                                    char* pString, 
                                    int StringLen);
BOOL bGlintQueryRegistryValueUlong(LPTSTR valueStr, 
                                   PULONG pData);
BOOL bGlintQueryRegistryValueUlongAsUlong(LPTSTR valueStr, 
                                          PULONG pData);
BOOL bGlintSetRegistryValueString(LPTSTR valueStr, 
                                  ULONG Data);

#define GET_REGISTRY_ULONG_FROM_STRING(a, b)                             \
    bGlintQueryRegistryValueUlong(a, (DWORD*)b)
#define GET_REGISTRY_STRING(a, b)                                        \
    bGlintQueryRegistryValueString(a, b, strlen(a))
#define SET_REGISTRY_STRING_FROM_ULONG(a, b)                             \
    bGlintSetRegistryValueString(a, b)

#endif // WNT_DDRAW

//------------------------------------------------------------------
// Memory Allocation calls 
//------------------------------------------------------------------
#ifdef WNT_DDRAW

#define HEAP_ALLOC(flags, size, tag) ENGALLOCMEM(FL_ZERO_MEMORY, size, tag)
#define HEAP_FREE(ptr)               ENGFREEMEM(ptr)

// Shared memory allocation calls. On NT , the 16 bit ptr is irrelevant and
// the call is resolved as a normal call to HEAP_ALLOC/HEAP_FREE
// The 16 bit ptrs are alwasy defined as DWORD and the 32 bit as ULONG_PTR
__inline void SHARED_HEAP_ALLOC(DWORD *ppData16,
                                ULONG_PTR* ppData32, 
                                DWORD size)
{                                                                
    *ppData32 = (ULONG_PTR) HEAP_ALLOC(FL_ZERO_MEMORY,           
                                       size ,                    
                                       ALLOC_TAG_DX(S));            
    *ppData16 = (DWORD)(*ppData32);                                
}    

__inline void SHARED_HEAP_FREE(DWORD *ppData16,
                               ULONG_PTR * ppData32, 
                               BOOL bZero)   
{                                               
    HEAP_FREE((PVOID)(*ppData32));            

    if (bZero)
    {
        *ppData32 = 0;                              
        *ppData16 = 0;                              
    }
}    

#else

#define FL_ZERO_MEMORY  HEAP_ZERO_MEMORY

#define HEAP_ALLOC(flags, size, tag)                               \
            HeapAlloc((HANDLE)g_DXGlobals.hHeap32, flags, size)
#define HEAP_FREE(ptr)                                             \
            HeapFree((HANDLE)g_DXGlobals.hHeap32, 0, ptr)

BOOL SharedHeapAlloc(DWORD* ppData16, ULONG_PTR* ppData32, DWORD size);
void SharedHeapFree(DWORD ptr16, ULONG_PTR ptr32);

// Shared memory allocation calls. On Win9x , the 16 bit ptr is important.
// We map this calls to some Win9x specific code
#define SHARED_HEAP_ALLOC( ppData16, ppData32, size)             \
            SharedHeapAlloc(ppData16, ppData32, size);

#define SHARED_HEAP_FREE( ppData16, ppData32, bZero)        \
{                                                           \
    SharedHeapFree(*(ppData16), *(ppData32));               \
    if (bZero)                                              \
    {                                                       \
        *ppData32 = 0;                                      \
        *ppData16 = 0;                                      \
    }                                                       \
}

#endif // WNT_DDRAW

//------------------------------------------------------------------
// Display driver's DC
//------------------------------------------------------------------
// Allows us to get the display driver's DC at any point.
// CREATE_DRIVER_DC must be matched by a DELETE_DRIVER_DC.
#define CREATE_DRIVER_DC(pGLInfo) (                                     \
    ( ( (pGLInfo)->szDeviceName[7] == '\0' ) &&                         \
        ( (pGLInfo)->szDeviceName[6] == 'Y' ) &&                        \
        ( (pGLInfo)->szDeviceName[5] == 'A' ) &&                        \
        ( (pGLInfo)->szDeviceName[4] == 'L' ) &&                        \
        ( (pGLInfo)->szDeviceName[3] == 'P' ) &&                        \
        ( (pGLInfo)->szDeviceName[2] == 'S' ) &&                        \
        ( (pGLInfo)->szDeviceName[1] == 'I' ) &&                        \
        ( (pGLInfo)->szDeviceName[0] == 'D' ) ) ?                       \
    /* The Win95 and NT4-compatible version */                          \
    ( CreateDC ( "DISPLAY", NULL, NULL, NULL ) ) :                      \
    /* The Win98 and NT5-compatible multimon version */                 \
    ( CreateDC ( NULL, (pGLInfo)->szDeviceName, NULL, NULL ) )          \
    )

#define DELETE_DRIVER_DC(hDC) DeleteDC(hDC)

//------------------------------------------------------------------
// Macro to define a FOURCC.
// Needed on NT builds.  On Win9x it comes from the DDK.
//------------------------------------------------------------------
#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |       \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif //defined(MAKEFOURCC)

// For the video
#define FOURCC_YUV422  (MAKEFOURCC('Y','U','Y','2'))
#define FOURCC_YUV411  (MAKEFOURCC('Y','4','1','1'))

// Mediamatics private 4CC's
#define FOURCC_MVCA    (MAKEFOURCC('M','V','C','A'))
#define FOURCC_MVSU    (MAKEFOURCC('M','V','S','U'))
#define FOURCC_MVSB    (MAKEFOURCC('M','V','S','B'))


//------------------------------------------------------------------

//------------------------------------------------------------------
#define PACKED_PP_LOOKUP(a) (pThisDisplay->PPCodes[(a) >> 5] & 0x1FF)
#define PACKED_PP_LOOKUP4(a) (pThisDisplay->PPCodes[(a) >> 5])
#define PP0_LOOKUP(a) (PACKED_PP_LOOKUP(a) & 0x7)
#define PP1_LOOKUP(a) ((PACKED_PP_LOOKUP(a) >> 3) & 0x7)
#define PP2_LOOKUP(a) ((PACKED_PP_LOOKUP(a) >> 6) & 0x7)
#define PP3_LOOKUP(a) ((PACKED_PP_LOOKUP(a) >> 9) & 0x7)

//------------------------------------------------------------------
// Globals that are truly global across multiple displays
//------------------------------------------------------------------
typedef enum tagPixelCenterSetting
{
    PIXELCENTER_ZERO,
    PIXELCENTER_NEARLY_HALF,
    PIXELCENTER_HALF,
    PIXELCENTER_FORCE_DWORD = 0xFFFFFFFF
} PixelCenterSetting;

typedef struct tagDirectXGlobals {
    // State
    HINSTANCE           hInstance;              // Instance handle for this DLL
    DWORD               hHeap32;                // Shared 32 bit heap
} DirectXGlobals;

// There is one global structure in the driver.  This is shared across 
// all applications and all cards.  It holds data such as the current 
// driver settings and a handle to the memory heap that is used within 
// the driver. There is also a global pointer that points at the current 
// primary display

extern DirectXGlobals   g_DXGlobals;

//------------------------------------------------------------------
// Driver thunked data
//------------------------------------------------------------------
#if W95_DDRAW
extern P3_THUNKEDDATA* g_pDriverData;
#endif

extern struct tagThunkedData* g_pThisTemp;


#if WNT_DDRAW

#define GET_THUNKEDDATA(pThisDisplay,a)                                  \
{                                                                        \
    pThisDisplay = (P3_THUNKEDDATA*)(((PPDEV) ((a)->dhpdev))->thunkData);\
}

#else   //  WNT_DDRAW

#if !DBG

#define GET_THUNKEDDATA(pThisDisplay,a)                          \
{                                                                \
    if ((a)->dwReserved3)                                        \
    {                                                            \
        pThisDisplay = (P3_THUNKEDDATA*)(a)->dwReserved3;        \
    }                                                            \
    else                                                         \
    {                                                            \
        pThisDisplay = g_pDriverData;                            \
    }                                                            \
}

#else

#define GET_THUNKEDDATA(pThisDisplay,a)                            \
{                                                                  \
    if ((a)->dwReserved3)                                          \
    {                                                              \
        pThisDisplay = (P3_THUNKEDDATA*)(a)->dwReserved3;          \
        DISPDBG((DBGLVL,"Secondary Display: DevHandle=0x%x",       \
        pThisDisplay->pGLInfo->dwDeviceHandle));                   \
    }                                                              \
    else                                                           \
    {                                                              \
        pThisDisplay = g_pDriverData;                              \
        DISPDBG((DBGLVL,"Primary Display DevHandle=0x%x",          \
        pThisDisplay->pGLInfo->dwDeviceHandle));                   \
    }                                                              \
}

#endif // !DBG
#endif  //  WNT_DDRAW



//------------------------------------------------------------------
//
//------------------------------------------------------------------
#define PATCH_SELECTIVE 0
#define PATCH_ALWAYS 1
#define PATCH_NEVER 2


//------------------------------------------------------------------
// Color format conversion macros 
//------------------------------------------------------------------
#define FORMAT_565_32BIT(val)           \
( (((val & 0xF800) >> 8) << 16) |       \
  (((val &  0x7E0) >> 3) <<  8) |       \
  (((val &   0x1F) << 3)      )   )

#define FORMAT_565_32BIT_BGR(val)     \
( (((val & 0xF800) >>  8)     ) |     \
  (((val &  0x7E0) >>  3) << 8) |     \
  (((val &   0x1F) << 19)     )    )

#define FORMAT_565_32BIT_ZEROEXTEND(val)  \
( (((val & 0xF800) >> 11)     ) |         \
  (((val &  0x7E0) >>  3) << 6) |         \
  (((val &   0x1F) << 16) )   )

#define FORMAT_5551_32BIT(val)      \
( (((val & 0x8000) >> 8) << 24) |   \
  (((val & 0x7C00) >> 7) << 16) |   \
  (((val &  0x3E0) >> 2) << 8 ) |   \
  (((val &   0x1F) << 3)      ) )

#define FORMAT_5551_32BIT_BGR(val)  \
( (((val & 0x8000) >> 8) << 24) |   \
  (((val & 0x7C00) >> 7)      ) |   \
  (((val &  0x3E0) >> 2) << 8 ) |   \
  (((val &   0x1F) <<19)      )  )

#define FORMAT_5551_32BIT_ZEROEXTEND(val)   \
( (((val & 0x8000) <<  9 )     ) |          \
  (((val & 0x7C00) >> 10 )     ) |          \
  (((val &  0x3E0) >>  2 ) << 5) |          \
  (((val &   0x1F) << 16 )     )    )

#define FORMAT_4444_32BIT(val)        \
( (((val & 0xF000) << 16)      ) |    \
  (((val &  0xF00) >>  4) << 16) |    \
  (((val &   0xF0) <<  8)      ) |    \
  (((val &    0xF) <<  4)      ) )

#define FORMAT_4444_32BIT_BGR(val)  \
( ((val & 0xF000) << 16) |          \
  ((val &  0xF00) >>  4) |          \
  ((val &   0xF0) <<  8) |          \
  ((val &    0xF) << 20) )

#define FORMAT_4444_32BIT_ZEROEXTEND(val)   \
( ((val & 0xF000) << 12) |                  \
  ((val &  0xF00) >>  8) |                  \
  ((val &   0xF0) <<  4) |                  \
  ((val &    0xF) << 16) )

#define FORMAT_332_32BIT(val)     \
( (((val & 0xE0) << 16)     ) |   \
  (((val & 0x1C) <<  3) << 8) |   \
  (((val &  0x3) <<  6)     ) )

#define FORMAT_332_32BIT_BGR(val)   \
( (((val & 0xE0)      )     ) |     \
  (((val & 0x1C) <<  3) << 8) |     \
  (((val &  0x3) << 22)     )   )

#define FORMAT_332_32BIT_ZEROEXTEND(val)    \
( (((val & 0xE0) >>  5)     ) |             \
  (((val & 0x1C) <<  3) << 3) |             \
  (((val &  0x3) << 16))    )

#define FORMAT_2321_32BIT(val)   \
( (((val & 0x80) << 24)     ) |  \
  (((val & 0x60) << 17)     ) |  \
  (((val & 0x1C) <<  3) << 8) |  \
  (((val &  0x3) <<  6)     ) ) 

#define FORMAT_2321_32BIT_BGR(val)  \
( (((val & 0x80) << 24)     ) |     \
  (((val & 0x60) <<  1)     ) |     \
  (((val & 0x1C) <<  3) << 8) |     \
  (((val &  0x3) << 22)     ))

#define FORMAT_2321_32BIT_ZEROEXTEND(val)  \
( (((val & 0x80) << 17)     ) |            \
  (((val & 0x60) >>  5)     ) |            \
  (((val & 0x1C) <<  3) << 3) |            \
  (((val &  0x3) << 16)     ) )

#define FORMAT_8888_32BIT_BGR(val)  \
( ((val & 0xFF00FF00)      ) |      \
  ((val &   0xFF0000) >> 16) |      \
  ((val &       0xFF) << 16) ) 

#define FORMAT_888_32BIT_BGR(val)   \
( ((val & 0xFF00FF00)      ) |      \
  ((val &   0xFF0000) >> 16) |      \
  ((val &       0xFF) << 16) )

#define CHROMA_UPPER_ALPHA(val) \
    (val | 0xFF000000)

#define CHROMA_LOWER_ALPHA(val) \
    (val & 0x00FFFFFF) 

#define CHROMA_332_UPPER(val)   \
    (val | 0x001F1F3F)

#define FORMAT_PALETTE_32BIT(val) \
    ( ((val & 0xFF)      ) |      \
      ((val & 0xFF) <<  8) |      \
      ((val & 0xFF) << 16))

//------------------------------------------------------------------
// Macros for handling Render IDs.
//------------------------------------------------------------------
#if 1
// The real values
#define RENDER_ID_KNACKERED_BITS   0x00000000
#define RENDER_ID_VALID_BITS_UPPER 0x00000000
#define RENDER_ID_VALID_BITS_LOWER 0xffffffff
#define RENDER_ID_VALID_BITS_UPPER_SHIFT 0
#define RENDER_ID_VALID_BITS_SIGN_SHIFT 0
#define RENDER_ID_LOWER_LIMIT -100
#define RENDER_ID_UPPER_LIMIT 65000

#define RENDER_ID_REGISTER_NAME MemScratch

#else

// For soak-testing - should catch wrap errors much more quickly.
// Also tests the mechanism that copes with dodgy bits in the
// register (P2 MinRegion legacy stuff, but it's free to support).
#define RENDER_ID_KNACKERED_BITS 0xfff0fff0
#define RENDER_ID_VALID_BITS_UPPER 0x000f0000
#define RENDER_ID_VALID_BITS_LOWER 0x0000000f
#define RENDER_ID_VALID_BITS_UPPER_SHIFT 12
#define RENDER_ID_VALID_BITS_SIGN_SHIFT 24
#define RENDER_ID_LOWER_LIMIT -20
#define RENDER_ID_UPPER_LIMIT 100

#endif

//------------------------------------------------------------------
// Flipping compile time switches
//------------------------------------------------------------------
    
#if WNT_DDRAW
// Can't use timeGetTime under WinNT
// We should try to backoff using something else instead, but...
#define USE_FLIP_BACKOFF 0
#else
// Set this to 1 to enable the back-off code for flips and locks.
// On some things it's faster, on some things it's slower - tune as desired.
#define USE_FLIP_BACKOFF 1
#endif

// Get a new render ID. Need to do the OR afterwards to make
// sure the +1 gets the bits carried up properly next time.
// No need to do the OR before, because we assume dwRenderID is
// always a "valid" number, with those bits set.
#define GET_NEW_HOST_RENDER_ID() ( pThisDisplay->dwRenderID = ( pThisDisplay->dwRenderID + 1 ) | RENDER_ID_KNACKERED_BITS, pThisDisplay->dwRenderID )
// Get render ID of last operation.
#define GET_HOST_RENDER_ID() ( pThisDisplay->dwRenderID )

// Send this ID to the chip (do just after the render command).
//#define SEND_HOST_RENDER_ID(my_id) SEND_P3_DATA(RENDER_ID_REGISTER_NAME,(my_id))

#define SEND_HOST_RENDER_ID(my_id)                                              \
        SEND_P3_DATA(VTGAddress, VTG_MEMORY_ADDRESS(MEM_MEMORYSCRATCH));        \
        SEND_P3_DATA(VTGData, my_id)

// Read the current ID from the chip.
#define GET_CURRENT_CHIP_RENDER_ID() ( READ_GLINT_CTRL_REG(RENDER_ID_REGISTER_NAME) | RENDER_ID_KNACKERED_BITS )
// Is the RenderID value on the chip valid?
#define CHIP_RENDER_ID_IS_VALID() ( (BOOL)pThisDisplay->bRenderIDValid )

// Do a render ID comparison. RenderIDs wrap, so you have
// to do the subtraction and _then_ test the top bit,
// not do the comparison between the two directly.
// think about a=0xfffffffe and b=0x1, and then
// about a=0x7ffffffe and b=0x80000001.
// If the two are more than 0x80000000 apart, then this
// will give the wrong result, but that's a _lot_ of renders.
// At a render every 1us (1MHz), that's still about 35 minutes.
// Bear in mind, a render is a sequence of polygons, not just one.
// If apps do as we suggest and send about 50 tris per render, and
// if they manage to get 8million tris a second troughput
// they get about 3.7 hours before wrapping.
// If this really is a problem, just extend it to 64 bits using
// MaxRegion as well.
// On P2, we only have 24 useable bits, so the wrap will happen
// sooner - every 52 seconds. However, this should at the very
// worst cause a few more SYNCs than necessary, even if it does
// go wrong. Use the above "debug" settings to do soak-testing -
// they make only 8 bits valid.
#define RENDER_ID_LESS_THAN(a,b) ( (signed)(a-b) < 0 )

// Decide if a render has finished.
#if !DBG
#define RENDER_ID_HAS_COMPLETED(my_id) ( !RENDER_ID_LESS_THAN ( (GET_CURRENT_CHIP_RENDER_ID()), (my_id) ) )
#else
// A version that is rather more paranoid about correct values.
// It's instantiated in gldd32.c
BOOL HWC_bRenderIDHasCompleted ( DWORD dwID, P3_THUNKEDDATA* pThisDisplay );
#define RENDER_ID_HAS_COMPLETED(my_id) ( HWC_bRenderIDHasCompleted ( (my_id), pThisDisplay ) )
#endif // !DBG

// This should be called once RENDER_ID_HAS_COMPLETED has failed,
// just in case a wrap-round bug has occurred. If it's true, the
// chip needs to be synced, and the surface RenderIDs updated with 
// GET_HOST_RENDER_ID(). This is fairly slow,
// but that's OK, since most things that use RENDER_ID_HAS_COMPLETED
// will start spinning when it fails anyway (locks, flips, etc).
// Note that just re-syncing every time the wrap-around
// happens is not enough - we need to bring the surface
// up to date as well, so this is just as efficient
// as always resyncing, and usually faster.
// This should also never happen in real-life, but it's a
// safety net in case it does. The soak-test settings should be
// aggressive enough to force it to happen.
#define NEED_TO_RESYNC_CHIP_AND_SURFACE(my_id) ( RENDER_ID_LESS_THAN ( GET_HOST_RENDER_ID(), (my_id) ) )

// Set/get a surface's read-from/written-to render ID.
#define SET_SIB_RENDER_ID_WRITE(lpSIB,my_id) (lpSIB)->dwRenderIDWrite = (my_id)
#define SET_SIB_RENDER_ID_READ(lpSIB,my_id) (lpSIB)->dwRenderIDRead = (my_id)
#define GET_SIB_RENDER_ID_WRITE(lpSIB) ((lpSIB)->dwRenderIDWrite)
#define GET_SIB_RENDER_ID_READ(lpSIB) ((lpSIB)->dwRenderIDRead)
#define SIB_WRITE_FINISHED(lpSIB) ( RENDER_ID_HAS_COMPLETED ( GET_SIB_RENDER_ID_WRITE ( lpSIB ) ) )
#define SIB_READ_FINISHED(lpSIB) ( RENDER_ID_HAS_COMPLETED ( GET_SIB_RENDER_ID_READ ( lpSIB ) ) )

//------------------------------------------------------------------
// Macros for determining DDraw surface characteristics
//------------------------------------------------------------------
#define DDSurf_Width(lpLcl)  ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_Pitch(lpLcl)  ( (lpLcl)->lpGbl->lPitch)
#define DDSurf_dwCaps(lpLcl) ( (lpLcl)->ddsCaps.dwCaps)

#if WNT_DDRAW

#define DDSurf_IsAGP(lpLcl)                                           \
        ( ((lpLcl)->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) ? 1 : 0 ) 

#define DDSurf_HasPixelFormat(dwFlags)    (1)

#define DDSurf_BitDepth(lpLcl)                                         \
                        ((lpLcl)->lpGbl->ddpfSurface.dwRGBBitCount)
                        
#define DDSurf_AlphaBitDepth(lpLcl)                                    \
                        ((lpLcl)->lpGbl->ddpfSurface.dwAlphaBitDepth)
                        
#define DDSurf_RGBAlphaBitMask(lpLcl)                                  \
                        ((lpLcl)->lpGbl->ddpfSurface.dwRGBAlphaBitMask)
                        
#define DDSurf_GetPixelFormat(lpLcl)                                   \
                        (&(lpLcl)->lpGbl->ddpfSurface)
#else

#define DDSurf_HasPixelFormat(dwFlags)                                  \
        ((dwFlags & DDRAWISURF_HASPIXELFORMAT) ? 1 : 0)
        
#define DDSurf_IsAGP(lpLcl)                                             \
        ( ((lpLcl)->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) ? 1 : 0 ) 

#define DDS_LCL(pdds) (((DDRAWI_DDRAWSURFACE_INT *)pdds)->lpLcl)
#define DDP_LCL(pddp) (((DDRAWI_DDRAWPALETTE_INT *)pdds)->lpLcl)

#define DDSurf_BitDepth(lpLcl)                                  \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ?          \
      ((lpLcl)->lpGbl->ddpfSurface.dwRGBBitCount) :             \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )

#define DDSurf_AlphaBitDepth(lpLcl)                               \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ?            \
      ((lpLcl)->lpGbl->ddpfSurface.dwAlphaBitDepth) :             \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay.dwAlphaBitDepth) \
    )

#define DDSurf_RGBAlphaBitMask(lpLcl)                               \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ?              \
      ((lpLcl)->lpGbl->ddpfSurface.dwRGBAlphaBitMask) :             \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBAlphaBitMask) \
    )

#define DDSurf_GetPixelFormat(lpLcl)                  \
    (((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
     (&(lpLcl)->lpGbl->ddpfSurface) :                 \
     (&(lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay)     \
    )
#endif  

// Function to return the correct entry in the lookup table
P3_SURF_FORMAT* _DD_SUR_GetSurfaceFormat(LPDDRAWI_DDRAWSURFACE_LCL pLcl);

static DWORD ShiftLookup[5] = { 0, 0, 1, 0, 2};
#define DDSurf_GetPixelShift(a)                      \
        (ShiftLookup[(DDSurf_BitDepth(a) >> 3)])

#define DDSurf_GetPixelToDWORDShift(pSurfLcl)                              \
                (2 - DDSurf_GetPixelShift(pSurfLcl))

#define DDSurf_GetPixelPitch(pSurfLcl)                                     \
    ((DDSurf_BitDepth(pSurfLcl) == 24) ?                                   \
            (DDSurf_Pitch(pSurfLcl) / 3) :                                 \
     (DDSurf_BitDepth(pSurfLcl) == 4) ?                                    \
            (DDSurf_Pitch(pSurfLcl) * 2) :                                 \
            (DDSurf_Pitch(pSurfLcl) >> DDSurf_GetPixelShift(pSurfLcl)))

#define DDSurf_GetByteWidth(pSurfLcl)                                      \
    ((DDSurf_BitDepth(pSurfLcl) == 24) ?                                   \
            (DDSurf_Width(pSurfLcl) * 3) :                                 \
     (DDSurf_BitDepth(pSurfLcl) == 4) ?                                    \
            (DDSurf_Width(pSurfLcl) / 2) :                                 \
            (DDSurf_Width(pSurfLcl) << DDSurf_GetPixelShift(pSurfLcl)))

#define DDSurf_FromInt(pSurfInt)                                             \
    ((LPDDRAWI_DDRAWSURFACE_LCL)((LPDDRAWI_DDRAWSURFACE_INT)pSurfInt)->lpLcl)

// 4bpp = 3, 8bpp = 0, 16bpp = 1, 24bpp = 4, 32bpp = 2
static DWORD ChipPixelSize[9] = { 0, 3, 0, 0, 1, 0, 4, 0, 2 };
#define DDSurf_GetChipPixelSize(pSurf)                    \
            (ChipPixelSize[(DDSurf_BitDepth(pSurf) >> 2)])

#define DDSurf_GetBppMask(pSurfLcl)                       \
            (3 >> (DDSurf_GetChipPixelSize(pSurfLcl)))

// Calculates the offset of this agp surface from the base of the agp region
unsigned long __inline 
DDSurf_SurfaceOffsetFromAGPBase(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    unsigned long ulOffset;

    ASSERTDD(pLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM, 
             "ERROR: DDSurf_SurfaceOffsetFromAGPBase passed non AGP surface");

#if WNT_DDRAW
    // The offset into AGP memory can't be more than 4GB! //azn - check this
    ulOffset = (DWORD)(pLcl->lpGbl->fpHeapOffset - 
                       pLcl->lpGbl->lpVidMemHeap->fpStart);
#else
    ulOffset = (SURFACE_PHYSICALVIDMEM(pLcl->lpGbl) - 
                                pThisDisplay->dwGARTDevBase);
#endif

    return ulOffset;
    
} // DDSurf_SurfaceOffsetFromAGPBase

// Calculates the offset of this surface from the base of the memory as 
// the chip sees it.  For AGP this is the currently scrolled window 
// position on P2, and on P3 it is the real physical memory address
long __inline 
DDSurf_SurfaceOffsetFromMemoryBase(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    long lOffset;

#if WNT_DDRAW
    if (pLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) //azn
    {
        DISPDBG((DBGLVL,"HeapOffset: 0x%x, fpStart: 0x%x", 
                        pLcl->lpGbl->fpHeapOffset, 
                        pLcl->lpGbl->lpVidMemHeap->fpStart));

        if (pThisDisplay->pGLInfo->dwRenderFamily == P3R3_ID)
        {
            // Return the offset into the heap, accounting for the adjustment 
            // we might have made to the base
            lOffset = ((long)pLcl->lpGbl->fpHeapOffset      - 
                       (long)pLcl->lpGbl->lpVidMemHeap->fpStart) +
                                 ((long)pThisDisplay->dwGARTDevBase);
        }
        else
        {
            // Return the offset into the heap, accounting for the adjustment 
            // we might have made to the base
            lOffset = ((long)pLcl->lpGbl->fpHeapOffset      - 
                       (long)pLcl->lpGbl->lpVidMemHeap->fpStart) - 
                      ((long)pThisDisplay->dwGARTDev        - 
                       (long)pThisDisplay->dwGARTDevBase );
        }
    }
    else
    {
        lOffset = ((long)pLcl->lpGbl->fpVidMem - 
                   (long)pThisDisplay->dwScreenFlatAddr);
    }
#else
    if (pThisDisplay->pGLInfo->dwRenderFamily == P3R3_ID)
    {
        if (pLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            lOffset = (long)SURFACE_PHYSICALVIDMEM(pLcl->lpGbl);
        }
        else
        {
            lOffset = ((long)pLcl->lpGbl->fpVidMem - 
                       (long)pThisDisplay->dwScreenFlatAddr);
        }
    }
    else
    {
        if (pLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            lOffset = ((long)SURFACE_PHYSICALVIDMEM(pLcl->lpGbl) - 
                       (long)pThisDisplay->dwGARTDev);
        }
        else
        {
            lOffset = ((long)pLcl->lpGbl->fpVidMem - 
                       (long)pThisDisplay->dwScreenFlatAddr);
        }
    }
#endif // WNT_DDRAW

    return lOffset;
    
} // DDSurf_SurfaceOffsetFromMemoryBase


//------------------------------------------------------------------
// Function to send a command to the VXD.
//------------------------------------------------------------------
#if W95_DDRAW
BOOL VXDCommand(DWORD dwCommand, 
                void* pIn, 
                DWORD dwInSize, 
                void* pOut, 
                DWORD dwOutSize);
#endif

//------------------------------------------------------------------
// DirectDraw Callbacks
//------------------------------------------------------------------
DWORD CALLBACK DdCanCreateSurface( LPDDHAL_CANCREATESURFACEDATA pccsd );
DWORD CALLBACK DdCreateSurface( LPDDHAL_CREATESURFACEDATA pcsd );
DWORD CALLBACK DdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd );
DWORD CALLBACK DdBlt( LPDDHAL_BLTDATA lpBlt );
DWORD CALLBACK UpdateOverlay32(LPDDHAL_UPDATEOVERLAYDATA puod);
DWORD CALLBACK DdSetColorKey(LPDDHAL_SETCOLORKEYDATA psckd);
DWORD CALLBACK DdUpdateOverlay(LPDDHAL_UPDATEOVERLAYDATA puod);

void _D3D_SU_DirectDrawLocalDestroyCallback(HashTable* pTable, 
                                            void* pData, 
                                            void* pExtra);
void _D3D_SU_SurfaceArrayDestroyCallback(PointerArray* pArray, 
                                         void* pData, 
                                         void* pExtra);

void _D3D_SU_PaletteArrayDestroyCallback(PointerArray* pArray, 
                                         void* pData, 
                                         void* pExtra);

#if DX7_STEREO
BOOL _DD_bIsStereoMode(P3_THUNKEDDATA* pThisDisplay,
                       DWORD dwWidth,
                       DWORD dwHeight,
                       DWORD dwBpp);
#endif

#if WNT_DDRAW

DWORD CALLBACK DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory);
DWORD CALLBACK DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

// NT specific callbacks in gdi\heap.c
DWORD CALLBACK DdFreeDriverMemory(PDD_FREEDRIVERMEMORYDATA lpFreeDriverMemory);
DWORD CALLBACK DdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode);
DWORD CALLBACK DdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface);

#else   //  WNT_DDRAW

DWORD CALLBACK DdUpdateNonLocalHeap(LPDDHAL_UPDATENONLOCALHEAPDATA plhd);
DWORD CALLBACK DdGetHeapAlignment(LPDDHAL_GETHEAPALIGNMENTDATA lpGhaData);
DWORD CALLBACK DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

#endif  //  WNT_DDRAW

DWORD CALLBACK DdGetAvailDriverMemory(LPDDHAL_GETAVAILDRIVERMEMORYDATA pgadmd);

// Overlay source update
void _DD_OV_UpdateSource(P3_THUNKEDDATA* pThisDisplay, 
                         LPDDRAWI_DDRAWSURFACE_LCL pSurf);

DWORD CALLBACK SetOverlayPosition32(LPDDHAL_SETOVERLAYPOSITIONDATA psopd);
DWORD CALLBACK DdSetOverlayPosition(LPDDHAL_SETOVERLAYPOSITIONDATA psopd);

#if W95_DDRAW

DWORD CALLBACK DDGetVideoPortConnectInfo(LPDDHAL_GETVPORTCONNECTDATA pInput);
DWORD CALLBACK DdCanCreateVideoPort (LPDDHAL_CANCREATEVPORTDATA pInput);
DWORD CALLBACK DdCreateVideoPort (LPDDHAL_CREATEVPORTDATA pInput);
DWORD CALLBACK DdFlipVideoPort (LPDDHAL_FLIPVPORTDATA pInput);
DWORD CALLBACK DdGetVideoPortBandwidth (LPDDHAL_GETVPORTBANDWIDTHDATA pInput);
DWORD CALLBACK DdGetVideoPortInputFormats (LPDDHAL_GETVPORTINPUTFORMATDATA pInput);
DWORD CALLBACK DdGetVideoPortOutputFormats (LPDDHAL_GETVPORTOUTPUTFORMATDATA pInput);
DWORD CALLBACK DdGetVideoPortField (LPDDHAL_GETVPORTFIELDDATA pInput);
DWORD CALLBACK DdGetVideoPortLine (LPDDHAL_GETVPORTLINEDATA pInput);
DWORD CALLBACK DdDestroyVideoPort (LPDDHAL_DESTROYVPORTDATA pInput);
DWORD CALLBACK DdGetVideoPortFlipStatus (LPDDHAL_GETVPORTFLIPSTATUSDATA pInput);
DWORD CALLBACK DdUpdateVideoPort (LPDDHAL_UPDATEVPORTDATA pInput);
DWORD CALLBACK DdWaitForVideoPortSync (LPDDHAL_WAITFORVPORTSYNCDATA pInput);
DWORD CALLBACK DdGetVideoSignalStatus(LPDDHAL_GETVPORTSIGNALDATA pInput);
DWORD CALLBACK DdSyncSurfaceData(LPDDHAL_SYNCSURFACEDATA pInput);
DWORD CALLBACK DdSyncVideoPortData(LPDDHAL_SYNCVIDEOPORTDATA pInput);
#endif  //  W95_DDRAW

//------------------------------------------------------------------
// Permedia3 Blit Functions
//------------------------------------------------------------------
typedef void (P3RXEFFECTSBLT)(struct tagThunkedData*, 
                              LPDDRAWI_DDRAWSURFACE_LCL pSource, 
                              LPDDRAWI_DDRAWSURFACE_LCL pDest, 
                              P3_SURF_FORMAT* pFormatSource, 
                              P3_SURF_FORMAT* pFormatDest, 
                              LPDDHAL_BLTDATA lpBlt, 
                              RECTL *rSrc, 
                              RECTL *rDest);


VOID 
_DD_BLT_P3Clear(                        // Clearing
    P3_THUNKEDDATA* pThisDisplay,
    RECTL *rDest,
    DWORD   ClearValue,
    BOOL    bDisableFastFill,
    BOOL    bIsZBuffer,
    FLATPTR pDestfpVidMem,
    DWORD   dwDestPatchMode,
    DWORD   dwDestPixelPitch,
    DWORD   dwDestBitDepth
    );

VOID _DD_BLT_P3Clear_AA(
    P3_THUNKEDDATA* pThisDisplay,
    RECTL *rDest,
    DWORD   dwSurfaceOffset,
    DWORD   ClearValue,
    BOOL bDisableFastFill,
    DWORD   dwDestPatchMode,
    DWORD   dwDestPixelPitch,
    DWORD   dwDestBitDepth,
    DDSCAPS DestDdsCaps);
    

void 
_DD_P3Download(                           // Downloads (sysmem -> video)
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,    
    DWORD dwSrcChipPatchMode,
    DWORD dwDestChipPatchMode,  
    DWORD dwSrcPitch,
    DWORD dwDestPitch,   
    DWORD dwDestPixelPitch,  
    DWORD dwDestPixelSize,
    RECTL* rSrc,
    RECTL* rDest);
    
void 
_DD_P3DownloadDD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    RECTL* rSrc,
    RECTL* rDest);

void _DD_P3DownloadDstCh(
    struct tagThunkedData*,  
    LPDDRAWI_DDRAWSURFACE_LCL pSource, 
    LPDDRAWI_DDRAWSURFACE_LCL pDest, 
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest, 
    LPDDHAL_BLTDATA lpBlt, 
    RECTL* rSrc, 
    RECTL* rDest);

VOID _DD_BLT_P3CopyBlt(                      // Blts
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,
    DWORD dwSrcChipPatchMode,
    DWORD dwDestChipPatchMode,
    DWORD dwSrcPitch,
    DWORD dwDestPitch,
    DWORD dwSrcOffset,
    DWORD dwDestOffset,
    DWORD dwDestPixelSize,
    RECTL *rSrc,
    RECTL *rDest);

VOID 
_DD_P3BltStretchSrcChDstCh(
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR fpSrcVidMem,
    P3_SURF_FORMAT* pFormatSource,    
    DWORD dwSrcPixelSize,
    DWORD dwSrcWidth,
    DWORD dwSrcHeight,
    DWORD dwSrcPixelPitch,
    DWORD dwSrcPatchMode,    
    ULONG ulSrcOffsetFromMemBase,    
    DWORD dwSrcFlags,
    DDPIXELFORMAT*  pSrcDDPF,
    BOOL bIsSourceAGP,
    FLATPTR fpDestVidMem,   
    P3_SURF_FORMAT* pFormatDest,    
    DWORD dwDestPixelSize,
    DWORD dwDestWidth,
    DWORD dwDestHeight,
    DWORD dwDestPixelPitch,
    DWORD dwDestPatchMode,
    ULONG ulDestOffsetFromMemBase,
    DWORD dwBltFlags,
    DWORD dwBltDDFX,
    DDCOLORKEY BltSrcColorKey,
    DDCOLORKEY BltDestColorKey,
    RECTL *rSrc,
    RECTL *rDest);

VOID 
_DD_BLT_SysMemToSysMemCopy(
    FLATPTR     fpSrcVidMem,
    LONG        lSrcPitch,
    DWORD       dwSrcBitCount,
    FLATPTR     fpDstVidMem,
    LONG        lDstPitch, 
    DWORD       dwDstBitCount,
    RECTL*      rSource,
    RECTL*      rDest);
                           
// FX Blits
P3RXEFFECTSBLT _DD_P3BltStretchSrcChDstCh_DD;
P3RXEFFECTSBLT _DD_P3BltStretchSrcChDstChOverlap;
P3RXEFFECTSBLT _DD_P3BltSourceChroma;

void P3RX_AA_Shrink(struct _p3_d3dcontext* pContext);

BOOL _DD_BLT_FixRectlOrigin(char *pszPlace, RECTL *rSrc, RECTL *rDest);

DWORD
_DD_BLT_GetBltDirection(    
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,
    RECTL *rSrc,
    RECTL *rDest,
    BOOL  *pbBlocking);

//------------------------------------------------------------------
// DX Utility functions.
//------------------------------------------------------------------
// Initialise 32 Bit data
BOOL _DD_InitDDHAL32Bit(struct tagThunkedData* pThisDisplay);

// Query flip status
HRESULT _DX_QueryFlipStatus( struct tagThunkedData* pThisDisplay,  
                             FLATPTR fpVidMem, 
                             BOOL bAllowDMAFlush );
// Change the mode setup
void ChangeDDHAL32Mode(struct tagThunkedData* pThisDisplay);
                         
// Checks that the current mode info is correct
#define VALIDATE_MODE_AND_STATE(pThisDisplay)     \
    if ((pThisDisplay->bResetMode != 0) ||        \
        (pThisDisplay->bStartOfDay))              \
            ChangeDDHAL32Mode(pThisDisplay);

//-----------------------------------------------------------------------------
//
// ****************** Mathematical definitions and macros *********************
//
//-----------------------------------------------------------------------------

#define math_e 2.718281828f

// Usefull maths stuff
extern float pow4( float x );
extern float myPow( float x, float y );

#if WNT_DDRAW

// Might be running on non-Intel processors.
static __inline void myDiv(float *result, float dividend, float divisor) 
{
    *result = dividend/divisor;
} // myDiv()
#else
static __inline void myDiv(float *result, float dividend, float divisor) 
{
    __asm 
    {
        fld dividend
        fdiv    divisor
        mov eax,result
        fstp dword ptr [eax]
    }
} // myDiv()
#endif  //  WNT_DDRAW

__inline void myFtoi(int *result, float f) 
{
    *result = (int)f;
} //myFtoi

static __inline float myFabs(float f)
{
    float* pFloat = &f;
    DWORD dwReturn = *((DWORD*)pFloat);
    dwReturn &= ~0x80000000;
    return (*((float*)&dwReturn));
} //

// Utility functions, used by NT4, NT5 and Win9X
static __inline int log2(int s)
{
    int d = 1, iter = -1;
    do {
         d *= 2;
         iter++;
    } while (d <= s);
    iter += ((s << 1) != d);
    return iter;
}

#ifdef _X86_

//-----------------------------------------------------------------------------
//
// myPow
//
// Compute x^y for arbitrary x and y
//
//-----------------------------------------------------------------------------
__inline float
myPow( float x, float y )
{
    float res = 0.0f;
    int intres;

    __asm
    {
        fld y                           // y
        fld x                           // x    y
        fyl2x                           // y*log2(x)
        fstp res
    }

    // Remove integer part of res as f2xm1 has limited input range

    myFtoi ( &intres, res );
    res -= intres;

    __asm
    {
        fild intres                     // Stash integer part for FSCALE
        fld res
        f2xm1                           // ST = 2^^fracx - 1
        fld1
        fadd                            // ST = 2^^fracx
        fscale                          // ST = 2^^x
        fstp res
        fstp st(0)                      // Clean up stack
    }

    return res;
} // myPow

#elif defined(_AMD64_)

double pow(double, double);

__inline float
myPow( float x, float y )
{
     return (float)pow((double)x, (double)y);
}

#elif defined(_IA64_)

__inline float
myPow( float x, float y )
{
     return powf(x,y);
}

#else

#error "No Target Architecture"

#endif //_X86_

//-----------------------------------------------------------------------------
//
// pow4
//
// Compute 4^x for arbitrary x 
//
//-----------------------------------------------------------------------------
__inline float
pow4( 
    float x )
{	
#if defined(_IA64_)
    return 0.0F;
#else
    return myPow( 4.0F, x );
#endif
} // pow4

#endif // __DIRECTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\direct3d.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: direct3d.h
*
* Content: Global direct3d definitions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifndef __DIRECT3D_H
#define __DIRECT3D_H

#include "directx.h"

// ************************ Auxiliary D3D declarations ************************

// We define this here because DX7 headers don't have it
#ifndef D3DTSS_MAX
#define D3DTSS_MAX ((D3DTEXTURESTAGESTATETYPE)29)
#endif

#ifndef D3DHAL_TSS_MAXSTAGES
#define D3DHAL_TSS_MAXSTAGES 8
#endif

#if DX8_DDI      
// In DX8 D3DTSS_ADDRESS is obsolete, but we need it for DX7 apps that call us
#define D3DTSS_ADDRESS      12
#endif   

// *********************** Helper function declarations ***********************

typedef struct _p3_d3dcontext P3_D3DCONTEXT;
typedef struct _p3_SURF_INTERNAL P3_SURF_INTERNAL;

// Initialization functions
void _D3DHALCreateDriver(struct tagThunkedData* pThisDisplay);
void _D3DGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

// Primitives renderers

extern void _D3D_R3_PickVertexProcessor( P3_D3DCONTEXT *pC );

typedef void R3_DP2_PRIM_TYPE( P3_D3DCONTEXT *, 
                               DWORD, 
                               LPBYTE, 
                               LPD3DTLVERTEX, 
                               DWORD, 
                               BOOL *);

typedef R3_DP2_PRIM_TYPE *PFNP3TRI;                              

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_Points;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_Points_DWCount;

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_LineList;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_LineListImm;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_LineStrip;

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedLineList;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedLineList2;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedLineStrip;

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleList;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleFan;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleFanImm;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleStrip;

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedTriangleList;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedTriangleList2;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedTriangleFan;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_IndexedTriangleStrip;

#if DX8_POINTSPRITES

extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleListPointSprite;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleFanPointSprite;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_TriangleStripPointSprite;
extern R3_DP2_PRIM_TYPE _D3D_R3_DP2_PointsSprite_DWCount;

#endif //DX8_POINTSPRITES

#if DX8_MULTSTREAMS
typedef void R3_DP2_PRIM_TYPE_MS( P3_D3DCONTEXT *, 
                                  DWORD, 
                                  LPBYTE, 
                                  LPD3DTLVERTEX, 
                                  INT,
                                  DWORD, 
                                  BOOL *);

extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedLineList_MS_16IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedLineStrip_MS_16IND; 
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleList_MS_16IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleStrip_MS_16IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleFan_MS_16IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedLineList_MS_32IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedLineStrip_MS_32IND;   
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleList_MS_32IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleStrip_MS_32IND;
extern R3_DP2_PRIM_TYPE_MS _D3D_R3_DP2_IndexedTriangleFan_MS_32IND;
#endif // DX8_MULTSTREAMS

// Texture functions
void _D3DChangeTextureP3RX(P3_D3DCONTEXT* pContext);
                         
void _D3D_TXT_ParseTextureStageStates(struct _p3_d3dcontext* pContext, 
                                 D3DHAL_DP2TEXTURESTAGESTATE* pState, 
                                 DWORD dwCount,
                                 BOOL bTranslateDX8FilterValueToDX6);

void _D3D_SU_SurfInternalSetMipMapLevelData(P3_THUNKEDDATA* pThisDisplay, 
                                            struct _p3_SURF_INTERNAL* pTexture,
                                            LPDDRAWI_DDRAWSURFACE_LCL pSurf, 
                                            int LOD);
                                                 
// D3D Context Functions
VOID _D3D_CTX_HandleInitialization(VOID);
P3_D3DCONTEXT* _D3D_CTX_HandleToPtr(ULONG_PTR hHandle);

// Rendering State Functions                            
DWORD _D3D_ST_ProcessRenderStates(P3_D3DCONTEXT* pContext, 
                                  DWORD dwStateCount, 
                                  D3DSTATE *pState, 
                                  BOOL bDoOverride);

DWORD _D3D_ST_ProcessOneRenderState(P3_D3DCONTEXT* pContext, 
                                    DWORD dwRSType,
                                    DWORD dwRSVal);
                              
BOOL _D3D_ST_RealizeHWStateChanges(P3_D3DCONTEXT* pContext);                              
BOOL _D3D_ST_CanRenderAntialiased(P3_D3DCONTEXT* pContext,
                                  BOOL bNewAliasBuffer);

//@@BEGIN_DDKSPLIT
#if DX7_VERTEXBUFFERS 
// Functions for handling vertex/execute/command buffers

void _D3D_EB_FlushAllBuffers(P3_THUNKEDDATA* pThisDisplay, BOOL bWait);

void
_D3D_EB_GetAndWaitForBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d ,
    P3_VERTEXBUFFERINFO** ppVertexBufferInfo,
    P3_VERTEXBUFFERINFO** ppCommandBufferInfo);       
    
void
_D3D_EB_UpdateSwapBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d ,
    P3_VERTEXBUFFERINFO* pVertexBufferInfo,
    P3_VERTEXBUFFERINFO* pCommandBufferInfo);
#endif //DX7_VERTEXBUFFERS 
//@@END_DDKSPLIT

// D3D Surfaces
HRESULT _D3D_SU_SurfInternalSetDataRecursive(P3_THUNKEDDATA* pThisDisplay,
                                             PointerArray* pSurfaceArray,
                                             LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                                             LPDDRAWI_DDRAWSURFACE_LCL pRootDDSurfLcl,
                                             LPDDRAWI_DDRAWSURFACE_LCL pCurDDSurfLcl);
BOOL _D3D_SU_SurfInternalSetData(P3_THUNKEDDATA* pThisDisplay, 
                                 P3_SURF_INTERNAL *pSurface,
                                 LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                 DWORD dwSurfaceHandle);
void 
_D3D_SU_DumpSurfInternal(DWORD lvl,
                         char *psHeader,
                         P3_SURF_INTERNAL *pSurface);

// State blocks management functions
void _D3D_SB_DeleteAllStateSets(P3_D3DCONTEXT* pContext);
void _D3D_SB_BeginStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam);
void _D3D_SB_EndStateSet(P3_D3DCONTEXT* pContext);
void _D3D_SB_DeleteStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam);
void _D3D_SB_ExecuteStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam);
void _D3D_SB_CaptureStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam);
void _D3D_SB_RecordStateSetRS(P3_D3DCONTEXT* pContext, 
                              DWORD dwRSType, 
                              DWORD dwRSVal);
void _D3D_SB_RecordStateSetTSS(P3_D3DCONTEXT* pContext, 
                               DWORD dwTSStage, 
                               DWORD dwTSState,
                               DWORD dwTSVal);
void _D3D_SB_Record_VertexShader_Set(P3_D3DCONTEXT* pContext, 
                                     DWORD dwVtxShaderHandle);
void _D3D_SB_Record_MStream_SetSrc(P3_D3DCONTEXT* pContext, 
                                    DWORD dwStream,
                                    DWORD dwVBHandle,
                                    DWORD dwStride);
void _D3D_SB_Record_MStream_SetIndices(P3_D3DCONTEXT* pContext, 
                                       DWORD dwVBHandle,
                                       DWORD dwStride);
void _D3D_SB_Record_Viewport(P3_D3DCONTEXT* pContext,
                             D3DHAL_DP2VIEWPORTINFO* lpvp);
VOID _D3D_SB_Record_ZRange(P3_D3DCONTEXT* pContext,
                           D3DHAL_DP2ZRANGE* lpzr);                          

// D3D Command Buffer Operations

HRESULT _D3D_OP_SetRenderTarget(P3_D3DCONTEXT* pContext, 
                                P3_SURF_INTERNAL* pRender, 
                                P3_SURF_INTERNAL* pZBuffer,
                                BOOL bNewAliasBuffers);  

VOID _D3D_OP_SceneCapture(P3_D3DCONTEXT *pContext,
                          DWORD dwFlag);                           

VOID _D3D_OP_Viewport(P3_D3DCONTEXT* pContext,
                      D3DHAL_DP2VIEWPORTINFO* lpvp);

VOID _D3D_OP_ZRange(P3_D3DCONTEXT* pContext,
                    D3DHAL_DP2ZRANGE* lpzr);

VOID _D3D_OP_Clear2(P3_D3DCONTEXT* pContext,
                    D3DHAL_DP2CLEAR* lpcd2,
                    DWORD dwNumRects);

VOID _D3D_OP_TextureBlt(P3_D3DCONTEXT* pContext, 
                        P3_THUNKEDDATA* pThisDisplay,
                        D3DHAL_DP2TEXBLT* pBlt);

HRESULT _D3D_OP_UpdatePalette(P3_D3DCONTEXT* pContext,
                              D3DHAL_DP2UPDATEPALETTE* pUpdatePalette,
                              DWORD* pdwPalEntries);

HRESULT _D3D_OP_SetPalettes(P3_D3DCONTEXT* pContext,
                            D3DHAL_DP2SETPALETTE* pSetPalettes,
                            int iNumSetPalettes);
                        

#if DX7_TEXMANAGEMENT
VOID _D3D_OP_SetTexLod(P3_D3DCONTEXT *pContext,
                       D3DHAL_DP2SETTEXLOD* pSetTexLod);

VOID _D3D_OP_SetPriority(P3_D3DCONTEXT *pContext,
                        D3DHAL_DP2SETPRIORITY* pSetPriority);

#if DX8_DDI
VOID _D3D_OP_AddDirtyRect(P3_D3DCONTEXT *pContext,
                          D3DHAL_DP2ADDDIRTYRECT* pAddDirtyRect);
                          
VOID _D3D_OP_AddDirtyBox(P3_D3DCONTEXT *pContext,
                         D3DHAL_DP2ADDDIRTYBOX* pAddDirtyBox);
#endif
#endif // DX7_TEXMANAGEMENT

#if DX8_3DTEXTURES
VOID _D3D_OP_VolumeBlt(P3_D3DCONTEXT* pContext, 
                       P3_THUNKEDDATA*pThisDisplay,
                       D3DHAL_DP2VOLUMEBLT* pBlt);
#endif // DX8_3DTEXTURES

#if DX8_DDI   
VOID _D3D_OP_BufferBlt(P3_D3DCONTEXT* pContext, 
                       P3_THUNKEDDATA*pThisDisplay,
                       D3DHAL_DP2BUFFERBLT* pBlt); 
#endif // DX8_DDI                       

#if DX8_VERTEXSHADERS
HRESULT _D3D_OP_VertexShader_Create(P3_D3DCONTEXT* pContext, 
                                    DWORD dwVtxShaderHandle,
                                    DWORD dwDeclSize, 
                                    DWORD dwCodeSize,
                                    BYTE *pShader);
VOID _D3D_OP_VertexShader_Delete(P3_D3DCONTEXT* pContext, 
                                 DWORD dwVtxShaderHandle);
VOID _D3D_OP_VertexShader_Set(P3_D3DCONTEXT* pContext, 
                              DWORD dwVtxShaderHandle);
VOID _D3D_OP_VertexShader_SetConst(P3_D3DCONTEXT* pContext, 
                                   DWORD dwRegister, 
                                   DWORD dwValue, 
                                   DWORD *pdwValues);
#endif // DX8_VERTEXSHADERS

#if DX8_PIXELSHADERS
HRESULT _D3D_OP_PixelShader_Create(P3_D3DCONTEXT* pContext, 
                                   DWORD dwPxlShaderHandle,
                                   DWORD dwCodeSize, 
                                   BYTE *pShader);
VOID _D3D_OP_PixelShader_Delete(P3_D3DCONTEXT* pContext, 
                                DWORD dwPxlShaderHandle);
VOID _D3D_OP_PixelShader_Set(P3_D3DCONTEXT* pContext, 
                             DWORD dwPxlShaderHandle);
VOID _D3D_OP_PixelShader_SetConst(P3_D3DCONTEXT* pContext, 
                                  DWORD dwRegister, 
                                  DWORD dwCount, 
                                  DWORD *pdwValues);
#endif // DX8_PIXELSHADERS

#if DX8_MULTSTREAMS
VOID _D3D_OP_MStream_SetSrc(P3_D3DCONTEXT* pContext, 
                            DWORD dwStream, 
                            DWORD dwVBHandle, 
                            DWORD dwStride);
VOID _D3D_OP_MStream_SetSrcUM(P3_D3DCONTEXT* pContext, 
                               DWORD dwStream, 
                               DWORD dwStride,
                               LPBYTE pUMVtx,
                               DWORD  dwVBSize);
VOID _D3D_OP_MStream_SetIndices(P3_D3DCONTEXT* pContext, 
                                DWORD dwVBHandle, 
                                DWORD dwStride);
VOID _D3D_OP_MStream_DrawPrim(P3_D3DCONTEXT* pContext, 
                              D3DPRIMITIVETYPE primType, 
                              DWORD VStart, 
                              DWORD PrimitiveCount);
VOID _D3D_OP_MStream_DrawIndxP(P3_D3DCONTEXT* pContext, 
                               D3DPRIMITIVETYPE primType, 
                               DWORD BaseVertexIndex, 
                               DWORD MinIndex, 
                               DWORD NumVertices, 
                               DWORD StartIndex,                   
                               DWORD PrimitiveCount);
VOID _D3D_OP_MStream_DrawPrim2(P3_D3DCONTEXT* pContext, 
                               D3DPRIMITIVETYPE primType, 
                               DWORD FirstVertexOffset, 
                               DWORD PrimitiveCount);
VOID _D3D_OP_MStream_DrawIndxP2(P3_D3DCONTEXT* pContext, 
                                D3DPRIMITIVETYPE primType, 
                                INT   BaseVertexOffset, 
                                DWORD MinIndex, 
                                DWORD NumVertices, 
                                DWORD StartIndexOffset, 
                                DWORD PrimitiveCount);

VOID _D3D_OP_MStream_ClipTriFan(P3_D3DCONTEXT* pContext, 
                                DWORD FirstVertexOffset, 
                                DWORD dwEdgeFlags, 
                                DWORD PrimitiveCount);

VOID _D3D_OP_MStream_DrawRectSurface(P3_D3DCONTEXT* pContext, 
                                     DWORD Handle,
                                     DWORD Flags,
                                     PVOID lpPrim);
                                     
VOID _D3D_OP_MStream_DrawTriSurface(P3_D3DCONTEXT* pContext, 
                                    DWORD Handle,
                                    DWORD Flags,
                                    PVOID lpPrim);                                                                      
#endif // DX8_MULTSTREAMS


// Other
void _D3DDisplayWholeTSSPipe ( P3_D3DCONTEXT* pContext, int iDebugNumber );

// ************************** D3D HAL Callbacks ********************************


DWORD CALLBACK D3DCreateSurfaceEx( LPDDHAL_CREATESURFACEEXDATA lpcsxd );
DWORD CALLBACK D3DDestroyDDLocal(LPDDHAL_DESTROYDDLOCALDATA pddl);

DWORD CALLBACK D3DContextCreate(LPD3DHAL_CONTEXTCREATEDATA pccd);
DWORD CALLBACK D3DContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pccd);

DWORD CALLBACK D3DDrawPrimitives2_P3( LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d );
DWORD CALLBACK D3DValidateDeviceP3( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd);
DWORD CALLBACK D3DGetDriverState(LPDDHAL_GETDRIVERSTATEDATA pGS);

DWORD CALLBACK D3DCanCreateD3DBuffer(LPDDHAL_CANCREATESURFACEDATA pccsd);
DWORD CALLBACK D3DCreateD3DBuffer(LPDDHAL_CREATESURFACEDATA pcsd);
DWORD CALLBACK D3DDestroyD3DBuffer(LPDDHAL_DESTROYSURFACEDATA pdd);
DWORD CALLBACK D3DLockD3DBuffer(LPDDHAL_LOCKDATA pld);
DWORD CALLBACK D3DUnlockD3DBuffer(LPDDHAL_UNLOCKDATA puld);

#endif // __DIRECT3D_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\glint.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: glint.h
*
* Content: DX Driver high level definitions and includes
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __GLINT_H
#define __GLINT_H

//*****************************************************
// DRIVER FEATURES CONTROLLED BY DEFINED SYMBOLS
//*****************************************************

#define COMPILE_AS_DX8_DRIVER 1

#if COMPILE_AS_DX8_DRIVER

#define DIRECT3D_VERSION  0x0800 

// DX8_DDI is 1 if the driver is going to advertise itself as a DX8 driver to
// the runtime. Notice that if we are a DX8 driver, we HAVE TO support the
// multisteraming command tokens and a limited semantic of the vertex shader
// tokens to interpret correctly the VertexType being processed
#define DX8_DDI           1
#define DX8_MULTSTREAMS   1
#define DX8_VERTEXSHADERS 1
// These other #defines enable and disable specific DX8 features
// they are included mainly in order to help driver writers locate most of the
// the code specific to the named features. Pixel shaders can't be supported on
// this hardware, only stub functions are offered.
#define DX8_POINTSPRITES  1
#define DX8_PIXELSHADERS  1
#define DX8_3DTEXTURES    1

#if WNT_DDRAW
#define DX8_MULTISAMPLING 1
#else
// On Win9x, AA buffers must be released during Alt-tab switch. Since 
// Perm3 driver doesn't share the D3D context with the 16bit side, this
// feature is disabled to prevent corrupted rendering.
#endif

#else

#define DIRECT3D_VERSION  0x0700 
#define DX8_DDI           0
#define DX8_MULTSTREAMS   0
#define DX8_VERTEXSHADERS 0
#define DX8_POINTSPRITES  0
#define DX8_PIXELSHADERS  0
#define DX8_3DTEXTURES    0
#define DX8_MULTISAMPLING 0
#endif // COMPILE_AS_DX8_DRIVER

// DX7 features which have been highlighted in order to 
// ease their implementation for other hardware parts.
#if WNT_DDRAW
#define DX7_ANTIALIAS      1
#else
// On Win9x, AA buffers must be released during Alt-tab switch. Since 
// Perm3 driver doesn't share the D3D context with the 16bit side, this
// feature is disabled to prevent corrupted rendering.
#endif

#define DX7_D3DSTATEBLOCKS 1
#define DX7_PALETTETEXTURE 1
#define DX7_STEREO         1

// Texture management enables DX8 resource management features
#define DX7_TEXMANAGEMENT  0

//@@BEGIN_DDKSPLIT
//azn W-Buffer disabled because of DCT problems
#define DX7_WBUFFER        0
#define DX7_VERTEXBUFFERS  0
//@@END_DDKSPLIT

// The below symbol is used only to ifdef code which is demonstrative for 
// other DX drivers but which for specific reasons is not part of the 
// current sample driver
#define DX_NOT_SUPPORTED_FEATURE 0

#if DX7_D3DSTATEBLOCKS 
// These #defines bracket code or comments which would be important for 
// TnL capable / pixel shader capable / vertex shader capable parts 
// when processing state blocks commands. 
#define DX7_SB_TNL            0
#define DX8_SB_SHADERS        0
#endif // DX7_D3DSTATEBLOCKS 

//*****************************************************
// PORTING WIN9X-WINNT 
//*****************************************************

// On IA64 , the following Macro sorts out the PCI bus caching problem.
// X86 doesn't need this, but it is handled by the same macro defined in
// ioaccess.h on Win2K/XP. For Win9x we need to define it ourselves as 
// doing nothing.

#if W95_DDRAW
#define MEMORY_BARRIER()
#endif


#if WNT_DDRAW
#define WANT_DMA 1
#endif // WNT_DDRAW

//*****************************************************
// INCLUDE FILES FOR ALL
//*****************************************************

//@@BEGIN_DDKSPLIT
// For internal Win2K build, we can include d3d{8}.h without problem, but
// we have troubles to do so for internal Win9x build, so a couple of error
// codes are patched below. For external DDK builds, both platforms can use
// d3d{8}.h which is what we want to encourage IHVs to do.
#if WNT_DDRAW
//@@END_DDKSPLIT

#if DX8_DDI
#include <d3d8.h>
#else
#include <d3d.h>
#endif

//@@BEGIN_DDKSPLIT
#else
#ifndef D3DERR_WRONGTEXTUREFORMAT

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_DDHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_DDHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_DDHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_DDHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_DDHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_DDHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_DDHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_DDHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_DDHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_DDHRESULT(2082)
#define D3DERR_TOOMANYPRIMITIVES                MAKE_DDHRESULT(2083)
#define D3DERR_INVALIDMATRIX                    MAKE_DDHRESULT(2084)
#define D3DERR_TOOMANYVERTICES                  MAKE_DDHRESULT(2085)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_DDHRESULT(2086)
#define D3DERR_DRIVERINVALIDCALL                MAKE_DDHRESULT(2157)

#endif
#endif
//@@END_DDKSPLIT

#if WNT_DDRAW
#include <stddef.h>
#include <windows.h>

#include <winddi.h>      // This includes d3dnthal.h and ddrawint.h
#include <devioctl.h>
#include <ntddvdeo.h>

#include <ioaccess.h>

#define DX8DDK_DX7HAL_DEFINES
#include <dx95type.h>    // For Win 2000 include dx95type which allows 
                         // us to work almost as if we were on Win9x
#include "driver.h"

#else   //  WNT_DDRAW

// These need to be included in Win9x

#include <windows.h>
#include <ddraw.h>

#ifndef __cplusplus
#include <dciman.h>
#endif

#include <ddrawi.h>

#ifdef __cplusplus
#include <dciman.h> // dciman.h must be included before ddrawi.h, 
#endif              // and it needs windows.h

#include <d3dhal.h>

typedef struct tagLinearAllocatorInfo LinearAllocatorInfo, *pLinearAllocatorInfo;

#endif  //  WNT_DDRAW

#if DX8_DDI
// This include file has some utility macros to process
// the new GetDriverInfo2 GUID calls
#include <d3dhalex.h>
#endif

// Our drivers include files 
#include "debug.h"
#include "softcopy.h"
#include "glglobal.h"
#include "glintreg.h"
#include "d3dstrct.h"
#include "linalloc.h"
#include "glddtk.h"
#include "directx.h"
#include "bitmac2.h"
#include "direct3d.h"
#include "dcontext.h"
#include "d3dsurf.h"
#include "dltamacr.h"

//*****************************************************
// TEXTURE MANAGEMENT DEFINITIONS
//*****************************************************
#if DX7_TEXMANAGEMENT
#if COMPILE_AS_DX8_DRIVER
// We will only collect stats in the DX7 driver
#define DX7_TEXMANAGEMENT_STATS 0
#else
#define DX7_TEXMANAGEMENT_STATS 1
#endif // COMPILE_AS_DX8_DRIVER

#include "d3dtxman.h"

#endif // DX7_TEXMANAGEMENT

#endif __GLINT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dltamacr.h ===
/******************************Module*Header**********************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: dltamacr.h
*
* Content: Hardware specific macro definitions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __DLTAMACR_H
#define __DLTAMACR_H

#define AS_ULONG(val)    *((volatile DWORD *) &(val))

// Macros defining the different Vertex types.

#define VTX_FOG     (0x1 << 25)        
#define VTX_RGB     (0x7 << 21)
#define VTX_R       (0x1 << 21)
#define VTX_RGBA    (0xF << 21)
#define VTX_COLOR   (0x1 << 30)
#define VTX_SPECULAR (0x1 << 31)
#define VTX_STQ     (0x7 << 16)
#define VTX_KSKD    (0x3 << 19)
#define VTX_KS      (0x1 << 19)
#define VTX_XYZ     (0x7 << 26)
#define VTX_XY      (0x3 << 26)
#define VTX_GRP     (0x2 << 14)

#define GAMBIT_XYZ_VTX              (VTX_GRP | VTX_XYZ)
#define GAMBIT_XYZ_COLOR_VTX        (VTX_GRP | VTX_XYZ | VTX_COLOR)
#define GAMBIT_STQ_VTX              (VTX_GRP | VTX_STQ)
#define GAMBIT_XYZ_STQ_VTX          (VTX_GRP | VTX_XYZ | VTX_STQ)

#ifdef ANTIALIAS
// Scale the screen coordinates by 2 for antialising renderers and bilinear filter down afterwards
#define Y_ADJUST(y)        (((y)) * (float)(2.0f))
#else
#define Y_ADJUST(y)        ((y))
#endif

//
// This loses one bit of accuracy, but adds and clamps without ifs.
// We first mask all channels with 0xfe.  This leaves the lsb of
// each channel clear, so when the terms are added, any carry goes
// into the new highest bit.  Now all we have to do is generate a
// mask for any channels that have overflowed.  So we shift is right
// and eliminate everything but the overflow bits, so each channel
// contains either 0x00 or 0x01.  Subtracting each channel from 0x80
// produces 0x7f or 0x80.  We just shift this left once and mask to
// give 0xfe or 0x00.  (We could eliminate the final mask here, but
// it would introduce noise into the low-bit of every channel..)
//                             

#define CLAMP8888(result, color, specular) \
     result = (color & 0xfefefefe) + (specular & 0xfefefe); \
     result |= ((0x808080 - ((result >> 8) & 0x010101)) & 0x7f7f7f) << 1;


//
// The full mip-level calculation is (log2( texArea/pixArea )) / 2.
// We approximate this by subtracting the exponent of pixArea from
// the exponent of texArea, having converted the floats into their
// bit-wise form. As the exponents start at bit 23, we need to shift
// this difference right by 23 and then once more for the divide by 2.
// We include a bias constant before the final shift to allow matching
// with the true sum-of-squares-of-derivatives calculation ( BIAS_SHIFT
// == 1 ) or whatever other reference image you have.
//

#define MIPSHIFT (23 + 1)

// A bias shift of zero matches 3DWB98's reference mipmap images

#ifndef BIAS_SHIFT
#define BIAS_SHIFT 0
#endif

#define BIAS_CONSTANT (1 << (MIPSHIFT - BIAS_SHIFT))

#define FIND_PERMEDIA_MIPLEVEL()                                     \
{                                                                    \
    int aTex = (int)*(DWORD *)&TextureArea;                          \
    int aPix = (int)*(DWORD *)&PixelArea;                            \
    iNewMipLevel = ((aTex - aPix + BIAS_CONSTANT) >> MIPSHIFT);      \
    if( iNewMipLevel > maxLevel )                                    \
        iNewMipLevel = maxLevel;                                     \
    else                                                             \
    {                                                                \
        if( iNewMipLevel < 0 )                                       \
            iNewMipLevel = 0;                                        \
    }                                                                \
}

#define FLUSH_DUE_TO_WRAP(par,vs)       { if( vs ) pContext->flushWrap_##par = TRUE; }
#define DONT_FLUSH_DUE_TO_WRAP(par,vs)  { if( vs ) pContext->flushWrap_##par = FALSE; }

#define RENDER_AREA_STIPPLE_ENABLE(a) a |= 1;
#define RENDER_AREA_STIPPLE_DISABLE(a) a &= ~1;

#define RENDER_LINE_STIPPLE_ENABLE(a) a |= (1 << 1);
#define RENDER_LINE_STIPPLE_DISABLE(a) a &= ~(1 << 1);

#define RENDER_TEXTURE_ENABLE(a) a |= (1 << 13);
#define RENDER_TEXTURE_DISABLE(a) a &= ~(1 << 13);

#define RENDER_FOG_ENABLE(a) a |= (1 << 14);
#define RENDER_FOG_DISABLE(a) a &= ~(1 << 14);

#define RENDER_SUB_PIXEL_CORRECTION_ENABLE(a) a |= (1 << 16);
#define RENDER_SUB_PIXEL_CORRECTION_DISABLE(a) a &= ~(1 << 16);

#define RENDER_LINE(a) a &= ~(1 << 6);

// Disable line stipple when rendering trapezoid
#define RENDER_TRAPEZOID(a) a = (a & ~(1 << 1)) | (1 << 6);

#define RENDER_POINT(a) a = (a & ~(3 << 6)) | (2 << 6);

#define RENDER_NEGATIVE_CULL_P3(a) a |= (1 << 17);
#define RENDER_POSITIVE_CULL_P3(a) a &= ~(1 << 17);

//*****************************************************
// PERMEDIA3 HW DEFINITIONS WE NEED 
//*****************************************************
#ifdef WNT_DDRAW
// NT needs this for the functions it places in DDEnable, which
// live in the mini directory for W95
typedef struct {
    union {
        struct GlintReg     Glint;
    };
}    *PREGISTERS;

#define DEFAULT_SUBBUFFERS 8

#else

#define DEFAULT_SUBBUFFERS 128

#endif // WNT_DDRAW

// Macros to identify the Permedia3 chip type
#define RENDERCHIP_P3RXFAMILY                                                \
                (pThisDisplay->pGLInfo->dwRenderFamily == P3R3_ID)
                
#define RENDERCHIP_PERMEDIAP3                                                \
                ((pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIA3_ID) ||  \
                 (pThisDisplay->pGLInfo->dwRenderChipID == GLINTR3_ID ))
                 
#define TLCHIP_GAMMA ( pThisDisplay->pGLInfo->dwGammaRev != 0)  

//@@BEGIN_DDKSPLIT
//#define RENDERCHIP_PERMEDIAP2 ((pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIA2_ID) || (pThisDisplay->pGLInfo->dwRenderChipID == TIPERMEDIA2_ID))
//#define RENDERCHIP_PERMEDIAFAMILY (pThisDisplay->pGLInfo->dwRenderFamily == PERMEDIA_ID)
//#define RENDERCHIP_PERMEDIAP4 (pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIA4_ID)
//#define RENDERCHIP_PERMEDIAPLUS (pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIAPLUS_ID)
//#define RENDERCHIP_PERMEDIAP2_ST_REV0 (pThisDisplay->pGLInfo->dwRenderChipRev == PERMEDIA2_REV0)
//#define RENDERCHIP_PERMEDIAP2_ST_REV1 (pThisDisplay->pGLInfo->dwRenderChipRev == PERMEDIA2_REV1)
//#define RENDERCHIP_PERMEDIAP2_ST (pThisDisplay->pGLInfo->dwRenderChipID == PERMEDIA2_ID)
//#define RENDERCHIP_GLINTR3 (pThisDisplay->pGLInfo->dwRenderChipID == GLINTR3_ID)
//#define RENDERCHIP_GLINTR4 (pThisDisplay->pGLInfo->dwRenderChipID == GLINTR4_ID)
//#define TLCHIP_GAMMA1 (pThisDisplay->pGLInfo->dwRenderChipID == GAMMA_ID)
//#define TLCHIP_GAMMA3 (pThisDisplay->pGLInfo->dwTLChipID == GAMMA3_ID)
//#define TLCHIP_GAMMAFAMILY (pThisDisplay->pGLInfo->dwTLFamily == GAMMA_ID)
//@@END_DDKSPLIT 


// Depth of FB in pixel size
#define GLINTDEPTH8             0
#define GLINTDEPTH16            1
#define GLINTDEPTH32            2
#define GLINTDEPTH24            4

// Bits in the Render command
#define __RENDER_VARIABLE_SPANS         (1 << 18)
#define __RENDER_SYNC_ON_HOST_DATA      (1 << 12)
#define __RENDER_SYNC_ON_BIT_MASK       (1 << 11)
#define __RENDER_TRAPEZOID_PRIMITIVE    (__GLINT_TRAPEZOID_PRIMITIVE << 6)
#define __RENDER_LINE_PRIMITIVE         (__GLINT_LINE_PRIMITIVE << 6)

#define __RENDER_POINT_PRIMITIVE        (__GLINT_POINT_PRIMITIVE << 6)
#define __RENDER_FAST_FILL_INC(n)       (((n) >> 4) << 4) // n = 8, 16 or 32
#define __RENDER_FAST_FILL_ENABLE       (1 << 3)
#define __RENDER_RESET_LINE_STIPPLE     (1 << 2)
#define __RENDER_LINE_STIPPLE_ENABLE    (1 << 1)
#define __RENDER_AREA_STIPPLE_ENABLE    (1 << 0)
#define __RENDER_TEXTURED_PRIMITIVE     (1 << 13)

// Some constants
#define ONE                     0x00010000

// Macro to take a GLINT logical op and return the enabled LogcialOpMode bits
#define GLINT_ENABLED_LOGICALOP(op)     (((op) << 1) | __PERMEDIA_ENABLE)

#if WNT_DDRAW


// NT Calls to switch hardware contexts
typedef enum COntextType_Tag {
    ContextType_None,
    ContextType_Fixed,
    ContetxType_RegisterList,
    ContextType_Dump
} ContextType;


extern VOID vGlintFreeContext(
        PPDEV   ppdev,
        LONG    ctxtId);
extern LONG GlintAllocateNewContext(
        PPDEV   ppdev,
        DWORD   *pTag,
        LONG    ntags,
        ULONG   NumSubBuffers,
        PVOID   priv,
        ContextType ctxtType);
extern VOID vGlintSwitchContext(
        PPDEV   ppdev,
        LONG    ctxtId);
                

// On NT Registry variables are stored as DWORDS.
extern BOOL bGlintQueryRegistryValueUlong(PPDEV, LPWSTR, PULONG);
#endif //WNT_DDRAW

#endif //__DLTAMACR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dma.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: dma.h
*
* Content: DMA transport definitons and macros
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __DMA_H
#define __DMA_H


//-----------------------------------------------------------------------------
//
// DMA/Fifo utility function declarations
//
//-----------------------------------------------------------------------------
// Enables a driver to switch between FIFO/DMA operations
void HWC_SwitchToFIFO( P3_THUNKEDDATA* pThisDisplay, LPGLINTINFO pGLInfo );
void HWC_SwitchToDMA( P3_THUNKEDDATA* pThisDisplay, LPGLINTINFO pGLInfo );
void HWC_AllocDMABuffer(P3_THUNKEDDATA* pThisDisplay);
DWORD WINAPI HWC_StartDMA(P3_THUNKEDDATA* pThisDisplay, 
                          DWORD dwContext, 
                          DWORD dwSize, 
                          DWORD dwPhys, 
                          ULONG_PTR dwVirt, 
                          DWORD dwEvent);
void HWC_GetDXBuffer( P3_THUNKEDDATA*, char*, int );
void HWC_SetDXBuffer( P3_THUNKEDDATA*, char*, int );
void HWC_FlushDXBuffer( P3_THUNKEDDATA* );

//-----------------------------------------------------------------------------
//
// DMA & Fifo common definitions & macros
//
//-----------------------------------------------------------------------------


// Compute the depth of the FIFO depending on if we are a simple 
// Permedia3 or if we are going through the Gamma chip of the GVX1
#define FIFO_DEPTH      ((ULONG)((TLCHIP_GAMMA) ? 32 : 120))

// Always check the FIFO. Remember that the DMA just loads the FIFO, and even
// if the DMA is empty, there can be tons left in the FIFO.
#define DRAW_ENGINE_BUSY(pThisDisplay)                  \
        ( pThisDisplay->pGlint->InFIFOSpace < FIFO_DEPTH )

// We track the fifo space so that we never wait for entries that we don't 
// need to.  We wait for nEntries + 1 instead of nEntries because of an issue
// in the Gamma chip
#define __WAIT_GLINT_FIFO_SPACE(nEntries)               \
{                                                       \
    DWORD dwEntries;                                    \
    do                                                  \
    {                                                   \
        dwEntries = *inFIFOptr;                         \
        if (dwEntries > 120) dwEntries = 120;           \
    } while (dwEntries < nEntries + 1);                 \
}

// Local variables needed on all DX functions that try to use DMA/FIFO
#define P3_DMA_DEFS()                                   \
    ULONG * volatile dmaPtr;                            \
    ULONG * volatile inFIFOptr =                        \
        (ULONG *)(&pThisDisplay->pGlint->InFIFOSpace)


// Debug & free versions to get / commit / flush a buffer
#if DBG

#define P3_DMA_GET_BUFFER()                                \
    {                                                      \
        HWC_GetDXBuffer( pThisDisplay, __FILE__, __LINE__ );   \
        dmaPtr = pThisDisplay->pGLInfo->CurrentBuffer;     \
    }

#define P3_DMA_COMMIT_BUFFER()                             \
    {                                                      \
        pThisDisplay->pGLInfo->CurrentBuffer = dmaPtr;     \
        HWC_SetDXBuffer( pThisDisplay, __FILE__, __LINE__ );   \
    }
    
#else
    
#define P3_DMA_GET_BUFFER()                                \
        dmaPtr = pThisDisplay->pGLInfo->CurrentBuffer;

#define P3_DMA_COMMIT_BUFFER()                             \
    {                                                      \
        pThisDisplay->pGLInfo->CurrentBuffer =  dmaPtr;    \
    }
      
#endif // DBG


#define P3_DMA_FLUSH_BUFFER()                              \
    {                                                      \
        P3_DMA_COMMIT_BUFFER();                            \
        HWC_FlushDXBuffer( pThisDisplay );                     \
        dmaPtr = pThisDisplay->pGLInfo->CurrentBuffer;     \
    }

#if DBG

#define __SET_FIFO_ENTRIES_LEFT(a)      \
do {                                    \
    g_pThisTemp = pThisDisplay;         \
    pThisDisplay->EntriesLeft = (a);    \
} while (0)

#define __SET_DMA_ENTRIES_LEFT(a)       \
do {                                    \
    g_pThisTemp = pThisDisplay;         \
    pThisDisplay->DMAEntriesLeft = (a); \
} while (0)

#define __RESET_FIFO_ERROR_CHECK g_bDetectedFIFOError = FALSE

#else

#define __SET_FIFO_ENTRIES_LEFT(a)
#define __SET_DMA_ENTRIES_LEFT(a)
#define __RESET_FIFO_ERROR_CHECK


#endif // DBG

#if DBG

// Note the DMAEntriesLeft+=2 compensates for the fact that this macro
// doesn't load a DMA Buffer - it writes to the FIFO directly.  That
// means it does need to wait for FIFO space
#define LOAD_GLINT_REG(r, v)                                   \
{                                                              \
    DISPDBG(( DBGLVL, "LoadGlintReg: %s 0x%x", #r, v ));        \
    __SET_DMA_ENTRIES_LEFT(pThisDisplay->DMAEntriesLeft + 2);  \
    CHECK_FIFO(2);                                             \
    MEMORY_BARRIER();                                          \
    pThisDisplay->pGlint->r = v;                               \
    MEMORY_BARRIER();                                          \
}

// Control registers do not require fifo entries
#define LOAD_GLINT_CTRL_REG(r, v)                 \
{                                                 \
    MEMORY_BARRIER();                             \
    pThisDisplay->pGlint->r = v;                  \
    MEMORY_BARRIER();                             \
}

#else

#define LOAD_GLINT_REG(r, v)         \
{                                    \
    MEMORY_BARRIER();                \
    pThisDisplay->pGlint->r = v;     \
    MEMORY_BARRIER();                \
}

#define LOAD_GLINT_CTRL_REG(r, v)    \
{                                    \
    MEMORY_BARRIER();                \
    pThisDisplay->pGlint->r = v;     \
    MEMORY_BARRIER();                \
}
#endif

#define READ_GLINT_CTRL_REG(r)      (pThisDisplay->pGlint->r)

// We wait for nEntries + 1 instead of nEntries because of a bug in Gamma chip

#define WAIT_GLINT_FIFO(nEntries)                        \
    while((READ_GLINT_CTRL_REG (InFIFOSpace)) < nEntries + 1);

#define READ_OUTPUT_FIFO(d) d = READ_GLINT_CTRL_REG(GPFifo[0])
#define GET_DMA_COUNT(c)    c = READ_GLINT_CTRL_REG(DMACount)

#if DBG
#define SET_MAX_ERROR_CHECK_FIFO_SPACE   pThisDisplay->EntriesLeft = 120;
#define SET_ERROR_CHECK_FIFO_SPACES(a)   pThisDisplay->EntriesLeft = (a);
#else
#define SET_MAX_ERROR_CHECK_FIFO_SPACE
#define SET_ERROR_CHECK_FIFO_SPACES(a)
#endif


//-----------------------------------------------------------------------------
//
// DMA EXCLUSIVE definitions & macros
//
// Below macros are used if we have defined that we want a DMA capable build
//-----------------------------------------------------------------------------
#ifdef WANT_DMA

#define WAIT_FIFO(a)                                          \
do { if(pThisDisplay->pGLInfo->InterfaceType != GLINT_DMA)    \
        __WAIT_GLINT_FIFO_SPACE(a);                           \
        __SET_FIFO_ENTRIES_LEFT(a);                           \
        __RESET_FIFO_ERROR_CHECK;                             \
    } while (0)

#define __ENSURE_DMA_SPACE(entries)    \
{                                    \
    if (pThisDisplay->pGLInfo->InterfaceType != GLINT_NON_DMA)                        \
    {                                                                                \
        if(((ULONG_PTR)dmaPtr + entries) >=                                                    \
                (ULONG_PTR)(pThisDisplay->pGLInfo->DMAPartition[pThisDisplay->pGLInfo->CurrentPartition].MaxAddress))    \
        {                            \
            P3_DMA_FLUSH_BUFFER();        \
        }                            \
    }                                \
    else                            \
    {                                \
        pThisDisplay->pGLInfo->CurrentBuffer = (ULONG*)&pThisDisplay->pGlint->GPFifo;        \
        dmaPtr = pThisDisplay->pGLInfo->CurrentBuffer;                            \
    }    \
    __SET_DMA_ENTRIES_LEFT(entries);                                                \
    __RESET_FIFO_ERROR_CHECK;                                                        \
}


#define P3_ENSURE_DX_SPACE(entries)        \
{                                          \
    __ENSURE_DMA_SPACE(entries)        \
    __SET_DMA_ENTRIES_LEFT(entries);         \
    __RESET_FIFO_ERROR_CHECK;                \
}

#if WNT_DDRAW
#define WAIT_DMA_COMPLETE   DDWaitDMAComplete(pThisDisplay->ppdev);
#else

extern void Wait_2D_DMA_Complete(P3_THUNKEDDATA* pThisDisplay);

#define PATIENTLY_WAIT_DMA()                \
{                                           \
    volatile DWORD count;                   \
    while (GET_DMA_COUNT(count) > 0)        \
    {                                       \
        if (count < 32)                     \
            count = 1;                      \
        else                                \
            count <<= 1;                    \
        while (--count > 0) NULL;           \
    }                                       \
}

#define WAIT_DMA_COMPLETE \
{                                                                                    \
    CHECK_ERROR();                                                                  \
    if (!(pThisDisplay->pGLInfo->GlintBoardStatus & GLINT_DMA_COMPLETE)) {            \
        if (pThisDisplay->pGLInfo->GlintBoardStatus & GLINT_INTR_CONTEXT) {            \
            static int retry = 0;                                                    \
            while (!(pThisDisplay->pGLInfo->GlintBoardStatus & GLINT_DMA_COMPLETE))    \
            {                                                                        \
                LOCKUP();                                                            \
            }                                                                        \
        } else {                                                                    \
            if (pThisDisplay->pGLInfo->dwCurrentContext == CONTEXT_DISPLAY_HANDLE) {\
                Wait_2D_DMA_Complete(pThisDisplay);                                 \
            }                                                                       \
            else {                                                                  \
                PATIENTLY_WAIT_DMA();                                               \
                pThisDisplay->pGLInfo->GlintBoardStatus |= GLINT_DMA_COMPLETE;        \
            }                                                                       \
        }                                                                            \
        ASSERTDD( READ_GLINT_CTRL_REG(DMACount) == 0, "DMACount not zero after WAIT_DMA_COMPLETE" );\
        ASSERTDD((READ_GLINT_CTRL_REG(ByDMAControl) & 3 ) == 0, "Bypass DMA not complete after WAIT_DMA_COMPLETE" );\
    }                                                                               \
    else {                                                                          \
        ASSERTDD( READ_GLINT_CTRL_REG(DMACount) == 0, "DMACount not zero despite GLINT_DMA_COMPLETE" );\
        ASSERTDD((READ_GLINT_CTRL_REG(ByDMAControl) & 3 ) == 0, "Bypass DMA not complete despite GLINT_DMA_COMPLETE" );\
    }                                                                               \
    CHECK_ERROR();                                                                  \
}
#endif // WNT_DDRAW

#if WNT_DDRAW
#define SYNC_WITH_GLINT                                                 \
    vNTSyncWith2DDriver(pThisDisplay->ppdev);                           \
    SET_MAX_ERROR_CHECK_FIFO_SPACE                                      
#else

#define SYNC_WITH_GLINT                                                 \
    DISPDBG(( DBGLVL, "SYNC_WITH_GLINT" ));                             \
    WAIT_DMA_COMPLETE                                                   \
    while( pThisDisplay->pGlint->InFIFOSpace < 6 ) /* void */ ;         \
    SET_ERROR_CHECK_FIFO_SPACES(6);                                     \
    LOAD_GLINT_REG(FilterMode, 0x400);                                  \
    LOAD_GLINT_REG(Sync, 0);                                            \
    LOAD_GLINT_REG(FilterMode, 0x0);                                    \
    do {                                                                \
        while (pThisDisplay->pGlint->OutFIFOWords == 0) /* void */ ;    \
    } while (pThisDisplay->pGlint->GPFifo[0] != 0x188);                 \
    DISPDBG((DBGLVL,"Sync at line %d in %s", __LINE__, __FILE__));      \
    SET_MAX_ERROR_CHECK_FIFO_SPACE                                      
#endif // WNT_DDRAW


//-----------------------------------------------------------------------------
//
// FIFO EXCLUSIVE definitions & macros
//
//-----------------------------------------------------------------------------
#else   //!WANT_DMA

#define WAIT_FIFO(a)                                                \
do {                                                                \
    __WAIT_GLINT_FIFO_SPACE(a);                                     \
    __SET_FIFO_ENTRIES_LEFT(a);                                     \
    __RESET_FIFO_ERROR_CHECK;                                       \
} while(0)

#define P3_ENSURE_DX_SPACE(entries)                                 \
{                                                                   \
    dmaPtr = (unsigned long *) (DWORD)pThisDisplay->pGlint->GPFifo; \
    P3_DMA_COMMIT_BUFFER();                                         \
    __SET_DMA_ENTRIES_LEFT(entries);                                \
    __RESET_FIFO_ERROR_CHECK;                                       \
}

#define P3_DMA_FLUSH_BUFFER()                                        \
{                                                                    \
    dmaPtr = (unsigned long *)  pThisDisplay->pGlint->GPFifo;        \
    P3_DMA_COMMIT_BUFFER();                                          \
}

#define WAIT_DMA_COMPLETE

#define SYNC_WITH_GLINT                                              \
    vNTSyncWith2DDriver(pThisDisplay->ppdev);                        \
    SET_MAX_ERROR_CHECK_FIFO_SPACE

#endif // !WANT_DMA

//-----------------------------------------------------------------------------
//
// Win9x specific definitons & macros
//
//-----------------------------------------------------------------------------
#if W95_DDRAW

// wait for DMA to complete (DMACount becomes zero). So as not to kill the
// PCI bus bandwidth for the DMA put in a backoff based on the amount of data
// still left to DMA. Also set the timer going if at any time, the count we
// read is the same as the previous count.
//

#if DBG

#define LOCKUP()                                                  \
    if(( ++retry & 0xfffff ) == 0 )                               \
    {                                                             \
            DISPDBG(( WRNLVL, "Locked up in WAIT_DMA_COMPLETE"    \
                              " - %d retries", retry ));          \
    }

#else

#define LOCKUP()

#endif
#endif // W95_DDRAW

                                                                                                
//-----------------------------------------------------------------------------
//
// Macros used to send data to the Permedia 3 hardware
//
//-----------------------------------------------------------------------------

#define SEND_P3_DATA(tag,data)       \
    {                                \
    MEMORY_BARRIER();                \
    dmaPtr[0] = tag##_Tag;           \
    MEMORY_BARRIER();                \
    dmaPtr[1] = data;                \
    MEMORY_BARRIER();                \
    dmaPtr+=2;                       \
    CHECK_FIFO(2);                   \
    }

#define SEND_P3_DATA_OFFSET(tag,data, i)    \
    {                                       \
    MEMORY_BARRIER();                       \
    dmaPtr[0] = (tag##_Tag + i);            \
    MEMORY_BARRIER();                       \
    dmaPtr[1] = data;                       \
    MEMORY_BARRIER();                       \
    dmaPtr += 2; CHECK_FIFO(2);             \
    }
    
#define COPY_P3_DATA(tag,data)                \
    {                                         \
    MEMORY_BARRIER();                         \
    dmaPtr[0] = tag##_Tag;                    \
    MEMORY_BARRIER();                         \
    dmaPtr[1] = *((unsigned long*) &(data));  \
    MEMORY_BARRIER();                         \
    dmaPtr += 2;                              \
    CHECK_FIFO(2);                            \
    }

#define COPY_P3_DATA_OFFSET(tag,data,i)        \
    {                                          \
    MEMORY_BARRIER();                          \
    dmaPtr[0] = tag##_Tag + i;                 \
    MEMORY_BARRIER();                          \
    dmaPtr[1] = *((unsigned long*) &(data));   \
    MEMORY_BARRIER();                          \
    dmaPtr += 2;                               \
    CHECK_FIFO(2);                             \
    }

#define P3RX_HOLD_CMD(tag, count)                    \
    {                                                \
    MEMORY_BARRIER();                                \
    dmaPtr[0] = ( tag##_Tag | ((count-1) << 16));    \
    dmaPtr++;                                        \
    CHECK_FIFO(1);                                   \
    }

#define P3_DMA_GET_BUFFER_ENTRIES( fifo_count )    \
    {                                              \
    P3_DMA_GET_BUFFER();                           \
    WAIT_FIFO( fifo_count );                       \
    P3_ENSURE_DX_SPACE((fifo_count));              \
    }

#define ADD_FUNNY_DWORD(a)   \
{                            \
    MEMORY_BARRIER();        \
    *dmaPtr++ = a;           \
    MEMORY_BARRIER();        \
    CHECK_FIFO(1);           \
}   

//-----------------------------------------------------------------------------
//
// Setup/Clear discconnect signals
//
// Setting the FIFODiscon register to 1 forces host write retries until 
// the data is accepted (might affect other time-critical processes though)
//
//-----------------------------------------------------------------------------

#if DBG
#define NO_FIFO_CHECK     pThisDisplay->EntriesLeft = -20000;
#define END_NO_FIFO_CHECK pThisDisplay->EntriesLeft = 0;
#else
#define NO_FIFO_CHECK
#define END_NO_FIFO_CHECK
#endif

#define SET_DISCONNECT_CONTROL(val)                            \
if(pThisDisplay->pGLInfo->InterfaceType == GLINT_NON_DMA)      \
{                                                              \
    WAIT_FIFO(1);                                              \
    if(pThisDisplay->pGLInfo->dwFlags & GMVF_DELTA)            \
    {                                                          \
        LOAD_GLINT_REG(DeltaDisconnectControl,val);            \
    }                                                          \
    else                                                       \
    {                                                          \
        LOAD_GLINT_REG(FIFODiscon,val);                        \
    }                                                          \
}

#define TURN_ON_DISCONNECT      \
    SET_DISCONNECT_CONTROL(0x1) \
    NO_FIFO_CHECK
    
#define TURN_OFF_DISCONNECT     \
    SET_DISCONNECT_CONTROL(0x0) \
    END_NO_FIFO_CHECK

#define SET_D3D_DISCONNECT_CONTROL(val)                        \
if(pThisDisplay->pGLInfo->InterfaceType == GLINT_NON_DMA)      \
{                                                              \
    WAIT_FIFO(1);                                              \
    if(pThisDisplay->pGLInfo->dwFlags & GMVF_DELTA)            \
    {                                                          \
        LOAD_GLINT_REG(DeltaDisconnectControl,val);            \
    }                                                          \
    else                                                       \
    {                                                          \
        LOAD_GLINT_REG(FIFODiscon,val);                        \
    }                                                          \
} 

#define TURN_ON_D3D_DISCONNECT         \
      SET_D3D_DISCONNECT_CONTROL(0x1)  \
      NO_FIFO_CHECK
      

#define TURN_OFF_D3D_DISCONNECT        \
      SET_D3D_DISCONNECT_CONTROL(0x0)  \
      END_NO_FIFO_CHECK



//-----------------------------------------------------------------------------
//
// Macros used to switch the chips hardware context between DDRAW/D3D ops
//
//-----------------------------------------------------------------------------

#define DDRAW_OPERATION(pContext, pThisDisplay)                               \
{                                                                             \
    ASSERTDD(pThisDisplay, "Error: pThisDisplay invalid in DDRAW_OPERATION!");\
    if (!IS_DXCONTEXT_CURRENT(pThisDisplay))                                  \
    {                                                                         \
        DXCONTEXT_IMMEDIATE(pThisDisplay);                                    \
        if (pThisDisplay->b2D_FIFOS == TRUE)                                  \
        {                                                                     \
            HWC_SwitchToFIFO(pThisDisplay, pThisDisplay->pGLInfo);            \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            HWC_SwitchToDMA(pThisDisplay, pThisDisplay->pGLInfo);             \
        }                                                                     \
        HWC_SwitchToDDRAW(pThisDisplay, TRUE);                                \
        pThisDisplay->pGLInfo->dwDirectXState = DIRECTX_LASTOP_2D;            \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        if (pThisDisplay->pGLInfo->dwDirectXState != DIRECTX_LASTOP_2D)       \
        {                                                                     \
            if (pThisDisplay->b2D_FIFOS == TRUE)                              \
            {                                                                 \
                HWC_SwitchToFIFO(pThisDisplay, pThisDisplay->pGLInfo);        \
            }                                                                 \
            else                                                              \
            {                                                                 \
                HWC_SwitchToDMA(pThisDisplay, pThisDisplay->pGLInfo);         \
            }                                                                 \
            HWC_SwitchToDDRAW(pThisDisplay, FALSE);                           \
            pThisDisplay->pGLInfo->dwDirectXState = DIRECTX_LASTOP_2D;        \
        }                                                                     \
    }                                                                         \
}

#define D3D_OPERATION(pContext, pThisDisplay)                                 \
{                                                                             \
    ASSERTDD(pThisDisplay, "Error: pThisDisplay invalid in D3D_OPERATION!");  \
    ASSERTDD(pContext, "Error: pContext invalid in D3D_OPERATION!");          \
    if (!IS_DXCONTEXT_CURRENT(pThisDisplay))                                  \
    {                                                                         \
        DXCONTEXT_IMMEDIATE(pThisDisplay);                                    \
        if (pContext->b3D_FIFOS == TRUE)                                      \
        {                                                                     \
            HWC_SwitchToFIFO(pThisDisplay, pThisDisplay->pGLInfo);            \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            HWC_SwitchToDMA(pThisDisplay, pThisDisplay->pGLInfo);             \
        }                                                                     \
        HWC_SwitchToD3D(pContext, pThisDisplay, TRUE);                        \
        pThisDisplay->pGLInfo->dwDirectXState = (ULONG_PTR)pContext;          \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        if ((pThisDisplay->pGLInfo->dwDirectXState != (ULONG_PTR)pContext) || \
            (pContext->dwDirtyFlags & CONTEXT_DIRTY_RENDER_OFFSETS))          \
        {                                                                     \
            if (pContext->b3D_FIFOS == TRUE)                                  \
            {                                                                 \
                HWC_SwitchToFIFO(pThisDisplay, pThisDisplay->pGLInfo);        \
            }                                                                 \
            else                                                              \
            {                                                                 \
                HWC_SwitchToDMA(pThisDisplay, pThisDisplay->pGLInfo);         \
            }                                                                 \
            HWC_SwitchToD3D(pContext, pThisDisplay, FALSE);                   \
            pThisDisplay->pGLInfo->dwDirectXState = (ULONG_PTR)pContext;      \
        }                                                                     \
    }                                                                         \
}


// Function to update the DDDRAW & D3D Software copy
void HWC_SwitchToDDRAW( P3_THUNKEDDATA* pThisDisplay, BOOL bDXEntry );
void HWC_SwitchToD3D(struct _p3_d3dcontext* pContext, 
                     struct tagThunkedData* pThisDisplay, BOOL bDXEntry);

#endif __DMA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\linalloc.c ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: linalloc.c
*
* Content: Videomemory linear allocator
*
* Copyright (c) 1995-2003 Microsoft Corporation
\**************************************************************************/

#include "glint.h"

//-----------------------------------------------------------------------------
//
// This module implements video memory allocation. It isn't a great
// allocator (though it IS robust), but mainly it shows how to hook
// up your own if you need/wish to.
//
//-----------------------------------------------------------------------------

// In linalloc.h we define MEMORY_MAP_SIZE and LinearAllocatorInfo
// which are key for our implementation

// This define allows allocations to search more efficiently for free
// memory. If you want to keep things simple you can turn it off
// and things will still work fine.
#define ALLOC_OPTIMIZE 1

// Total number of chunks per element of our memory map array 
// (which is of DWORD type , therefore we use sizeof(DWORD) )
#define CHUNKS_PER_ELEM   (sizeof(DWORD)*8)

// Memory to be managed will be subdivided in "memory chunks". Each memory
// chunk status will be signaled by a bit in the memory map by being turned
// on or off.
#define TOTAL_MEM_CHUNKS  (MEMORY_MAP_SIZE * CHUNKS_PER_ELEM)

// Macros to set, clear and test the value of a given chunk bit without
// worrying about the structure internals.
#define CHUNKNUM_BIT(chunk_num)                                                 \
    (1 << ((chunk_num) % CHUNKS_PER_ELEM))
    
#define CHUNKNUM_ELEM(mmap, chunk_num)                                          \
    mmap[ (chunk_num) / CHUNKS_PER_ELEM ]
    
#define SET_MEM_CHUNK(mmap, chunk_num)                                    \
    CHUNKNUM_ELEM(mmap, chunk_num) |= CHUNKNUM_BIT(chunk_num)
    
#define CLR_MEM_CHUNK(mmap, chunk_num)                                    \
    CHUNKNUM_ELEM(mmap, chunk_num) &= ~CHUNKNUM_BIT(chunk_num)
    
#define MEM_CHUNK_VAL(mmap, chunk_num)                                    \
  ((CHUNKNUM_ELEM(mmap, chunk_num) & CHUNKNUM_BIT(chunk_num)) > 0 ? 1 : 0)

// Macros that do the mapping between real (heap) memory pointers and the
// chunking indices.
#define MEM_BYTES_TO_CHUNKS(pAlloc, dwBytes)                          \
    ( (dwBytes) / pAlloc->dwMemPerChunk +                             \
      ( ((dwBytes) %  pAlloc->dwMemPerChunk)? 1 : 0 )                 \
    )
    
#define CHUNK_NUM_TO_PTR(pAlloc, num)                                 \
    ( (num) * pAlloc->dwMemPerChunk + pAlloc->dwMemStart )
    
#define MEM_PTR_TO_CHUNK_NUM(pAlloc, ptr)                             \
    MEM_BYTES_TO_CHUNKS(pAlloc, ((ptr) - pAlloc->dwMemStart) )

//-----------------------------------------------------------------------------
//
// __LIN_AlignPtr
//
// Return an aligned pointer 
//
//-----------------------------------------------------------------------------
DWORD
__LIN_AlignPtr(DWORD pointer, DWORD alignment)
{
    ULONG ulExtraBytes;

    ulExtraBytes = pointer % alignment;
    
    if (ulExtraBytes == 0)
    {
        ulExtraBytes = alignment;
    }

    // add enough to pointer so that its new value % alignment is == 0
    return (pointer + alignment - ulExtraBytes);
} // __LIN_AlignPtr

//-----------------------------------------------------------------------------
//
// __LIN_CalcMaxChunks
//
//  Calculate the number of chunks in the heap
//
//-----------------------------------------------------------------------------
void
__LIN_CalcMaxChunks(LinearAllocatorInfo* pAlloc)
{
    DWORD n, dwSizeHeap;

    // Compute how many chunks we'll need and what size of heap each 
    // chunk will control for this linear allocator.
    dwSizeHeap = pAlloc->dwMemEnd - pAlloc->dwMemStart;

    // We will need dwMemPerChunk * dwMaxChunks to be >= dwSizeHeap. 
    // We also want dwMaxChunks to be as close to TOTAL_MEM_CHUNKS and
    // we would like (though its not necessary) dwMemPerChunk to be as 2^N.
    // (and making them at least 16 bytes makes life easier for 
    // the alignment requirements we have in this driver).

    for(n = 4; n < 32; n++)
    {
        // our current choice of heap size each chunk will control
        pAlloc->dwMemPerChunk = 1 << n; // 2^N  

        // how many chunks do we need for such case?
        pAlloc->dwMaxChunks = dwSizeHeap / pAlloc->dwMemPerChunk;
        if (dwSizeHeap % pAlloc->dwMemPerChunk != 0) 
        {
            pAlloc->dwMaxChunks++;        
        }

        // can we accept this result to fit in our data structure?
        if (pAlloc->dwMaxChunks <= TOTAL_MEM_CHUNKS)
        {
            // We have as finely grained chunks as we can without
            // exceeding our self imposed limits.
            break;
        }
    }

    // 1 << n is the size of 1 chunk which is 1k on P3 with 256MB video memory
    ASSERTDD((n < 32), "__LIN_CalcMaxChunks : Wrong heap size");
}

//-----------------------------------------------------------------------------
//
// __LIN_ReInitWhenNeeded
//
//  Reinitialize heap allocater if needed. This is important only for
// the Win9x driver which can signal us from the 16bit side in a mode 
// change that it needs the heap to be reinitialized completely. (It will
// do this by simple setting bResetLinAllocator to TRUE).
//
//-----------------------------------------------------------------------------
void 
__LIN_ReInitWhenNeeded(LinearAllocatorInfo* pAlloc)
{
#ifdef W95_DDRAW
    if (pAlloc)
    {
        if (pAlloc->bResetLinAllocator)
        {
            // Clean all previous allocation data in the memory map
            if (pAlloc->pMMap)
            {
                memset(pAlloc->pMMap, 0, sizeof(MemoryMap));            
            }

            // Clean all previous lenght data in the memory map
            if (pAlloc->pLenMap)
            {
                memset(pAlloc->pLenMap, 0, sizeof(MemoryMap));            
            }
       
            // Recalculate max chunks due to change of heap's size
            __LIN_CalcMaxChunks(pAlloc);
        }

        // reinitialization completed
        pAlloc->bResetLinAllocator = FALSE;
    }
#endif  // W95_DDRAW    
} // __LIN_ReInitWhenNeeded

//-----------------------------------------------------------------------------
//
// _DX_LIN_InitialiseHeapManager
//
// Creates the heap manager.  This code is fairly common to this 
// sample app and the dd allocator as it will stand.  The operations
// it performs will be in perm3dd and/or mini, though the shared heap
// memory can be allocated from 16 and 32 bit land.
//
//-----------------------------------------------------------------------------
BOOL 
_DX_LIN_InitialiseHeapManager(LinearAllocatorInfo* pAlloc,
                              DWORD dwMemStart, 
                              DWORD dwMemEnd)
{
    DWORD n;

    // Reinitialize heap allocater if needed
    __LIN_ReInitWhenNeeded(pAlloc);  

    pAlloc->dwMemStart = dwMemStart;
    pAlloc->dwMemEnd = dwMemEnd;
    pAlloc->bResetLinAllocator = FALSE;

    // Get memory for the allocator's memory map
    pAlloc->pMMap = (MemoryMap*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                           sizeof(MemoryMap),
                                           ALLOC_TAG_DX(G));
    if(pAlloc->pMMap == NULL)
    {
        // Out of memory
        return FALSE;
    }

    // Clear the memory map
    memset(pAlloc->pMMap, 0, sizeof(MemoryMap));    

    // Calculate the maximum number of chunks
    __LIN_CalcMaxChunks(pAlloc);

    // Get memory for the allocator's lenght memory map. We'll keep here
    // a map of 0's and 1's where 1 will indicate where the current
    // allocated block ends. That way we won't need to keep any binding 
    // between the allocated addresses and the size of each one in order 
    // to do the right thing when we are asked to free the memory
    pAlloc->pLenMap = (MemoryMap*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                           sizeof(MemoryMap),
                                           ALLOC_TAG_DX(H));
    if(pAlloc->pLenMap == NULL)
    {
        // Couln't allocate the lenght map, deallocate the memory map
        HEAP_FREE(pAlloc->pMMap);
        pAlloc->pMMap = NULL;
        
        // Out of memory       
        return FALSE;
    }

    // Clear the lenghts memory map
    memset(pAlloc->pLenMap, 0xFF, sizeof(MemoryMap));       
            
    return TRUE;
    
} // _DX_LIN_InitialiseHeapManager

//-----------------------------------------------------------------------------
//
// _DX_LIN_UnInitialiseHeapManager(pLinearAllocatorInfo pAlloc)
//
// Frees the heap manager.  This code is fairly common to this 
// sample app and the dd allocator as it will stand.  The operations
// it performs will be in p3r3dx and/or mini, though the shared heap
// memory can be allocated from 16 and 32 bit land.
// 
//-----------------------------------------------------------------------------
void _DX_LIN_UnInitialiseHeapManager(LinearAllocatorInfo* pAlloc)
{
    __LIN_ReInitWhenNeeded(pAlloc);

    // Destroy/Clean all previous allocation data
    if (pAlloc)
    {
        if(pAlloc->pMMap)
        {
            HEAP_FREE(pAlloc->pMMap);
            pAlloc->pMMap = NULL;
        }        

        if(pAlloc->pLenMap)
        {
            HEAP_FREE(pAlloc->pLenMap);
            pAlloc->pLenMap = NULL;
        }           
    }

} // _DX_LIN_UnInitialiseHeapManager


//-----------------------------------------------------------------------------
//
// _DX_LIN_AllocateLinearMemory
//
// This is the allocation interface to the allocator.  It gives an
// application the opportunity to allocate a linear chunk of memory
//
//-----------------------------------------------------------------------------
DWORD 
_DX_LIN_AllocateLinearMemory(
    pLinearAllocatorInfo pAlloc, 
    LPMEMREQUEST lpMemReq)
{
    INT i;
    DWORD dwBytes,
          dwCurrStartChunk, 
          dwCurrEndChunk, 
          dwNumContChunksFound, 
          dwContChunksNeeded;
#if ALLOC_OPTIMIZE
    // Each block is CHUNKS_PER_ELE chuncks
    DWORD dwStartLastBlock;
#endif

    // Reinitialize heap allocater if needed
    __LIN_ReInitWhenNeeded(pAlloc);  

    // Validate the passed data
    if ((lpMemReq == NULL) ||
        (lpMemReq->dwSize != sizeof(P3_MEMREQUEST)))
    {
        DISPDBG((ERRLVL,"ERROR: NULL lpMemReq passed!"));
        return GLDD_INVALIDARGS;
    }

    if ((!pAlloc) || 
        (pAlloc->pMMap == NULL) ||
        (pAlloc->pLenMap == NULL) )
    {
        DISPDBG((ERRLVL,"ERROR: invalid pAlloc passed!"));
        return GLDD_INVALIDARGS;
    }       

    // Always ensure that alignment is a DWORD (or DWORD multiple)
    if (lpMemReq->dwAlign < 4) 
    {
        lpMemReq->dwAlign = 4;
    }
    
    while ((lpMemReq->dwAlign % 4) != 0) 
    {
        lpMemReq->dwAlign++;
    }

    // Always align memory requests to a minimum of a 4 byte boundary
    dwBytes = __LIN_AlignPtr(lpMemReq->dwBytes, lpMemReq->dwAlign);
    if (dwBytes == 0)
    {
        DISPDBG((WRNLVL,"ERROR: Requested 0 Bytes!"));
        return GLDD_INVALIDARGS;
    }

    // Determine how many chunks of memory we'll need to allocate
    dwContChunksNeeded = MEM_BYTES_TO_CHUNKS(pAlloc, dwBytes);
    
    // We don't check if we were called with MEM3DL_FIRST_FIT since 
    // that's the only thing we know how to do right now. We decide
    // whether we'll search from back to front or viceversa. We will
    // scan the memory map in the chosen direction looking for a "hole"
    // large enough for the current request.
    if (lpMemReq->dwFlags & MEM3DL_BACK)
    {
        // We will examine the MemoryMap from the end towards the front
        // looking out for a suitable space with the required number of
        // chunks we need
        dwCurrEndChunk = 0;
        dwNumContChunksFound = 0;
        for ( i = pAlloc->dwMaxChunks - 1; i >= 0 ; i--)
        {
#if ALLOC_OPTIMIZE
            // we are about to start testing a specific  DWORD in 
            // the memory map (going from the end to the start)
            if (( i % 32) == 31)
            {
                // If the whole DWORD is 0xFFFFFFFF (meaning all chunks are
                // already allocated) then we can & should skip it altogheter
                while ((i >= 0) &&
                       (CHUNKNUM_ELEM((*pAlloc->pMMap), i) == 0xFFFFFFFF))
                {
                    // Search needs to be restarted
                    dwNumContChunksFound = 0;

                    i -= 32;
                }

                // If the whole DWORD is 0x00000000 (meaning none of the
                // chunks is yet allocated) then we could grab all
                while ((i >= 0) &&
                       (CHUNKNUM_ELEM((*pAlloc->pMMap), i) == 0x00000000) &&
                       !(dwNumContChunksFound >= dwContChunksNeeded))
                {
                    if (dwNumContChunksFound == 0)
                    {
                        dwCurrEndChunk = i;
                    }
                    i -= 32;                    
                    dwNumContChunksFound += 32;
                }

                if (dwNumContChunksFound >= dwContChunksNeeded)
                {
                    // We've found a suitable place! Figure out where it starts
                    dwCurrStartChunk = dwCurrEndChunk - dwContChunksNeeded + 1;
                    break;
                }                 
                else if(!(i >= 0))
                {                    
                    break; // finished examining all memory, break loop here
                }                 
            }            
#endif // ALLOC_OPTIMIZE
            if (MEM_CHUNK_VAL((*pAlloc->pMMap), i ) == 0)
            {
                if (dwNumContChunksFound == 0)
                {
                    // our count so far of contigous chunks is zero, 
                    // meaning that were just starting to find free
                    // chunks. We need to remember where this block
                    // is ending
                    dwCurrEndChunk = i;
                }
                dwNumContChunksFound++;            
            }
            else
            {
                // This chunk is being used and we haven't found a suitable
                // set of chunks, so reset our count of contigous chunks 
                // found so far
                dwNumContChunksFound = 0;        
            }

            if (dwNumContChunksFound >= dwContChunksNeeded)
            {
                // We've found a suitable place! Figure out where it starts.
                dwCurrStartChunk = dwCurrEndChunk - dwContChunksNeeded + 1;
                break; // break loop here
            }            
        }    
    }
    else // even if no flags are set lets allocate at the heaps front
    {
        // We will examine the MemoryMap from the front towards the end
        // looking out for a suitable space with the required number of
        // chunks we need
        dwCurrStartChunk = 0;
        dwNumContChunksFound = 0;

#if ALLOC_OPTIMIZE
        // At the end of the heap there might be a region smaller than 
        // CHUNKS_PER_ELEM(32) of chunks, and optimized search of 32
        // chunk free blocks should be disabled in that region.
        dwStartLastBlock = (pAlloc->dwMaxChunks / CHUNKS_PER_ELEM) * 
                           CHUNKS_PER_ELEM;
#endif

        for ( i = 0 ; i < (INT)pAlloc->dwMaxChunks ; i++)
        {
#if ALLOC_OPTIMIZE

            // we are about to start testing a specific 
            // DWORD in the memory map. 
            if (( i % 32) == 0)
            {
                // If the whole DWORD is 0xFFFFFFFF (meaning all chunks are
                // already allocated) then we can & should skip it altogheter
                while ((i < (INT)dwStartLastBlock) &&
                       (CHUNKNUM_ELEM((*pAlloc->pMMap), i) == 0xFFFFFFFF))
                {
                    // Search needs to be restarted
                    dwNumContChunksFound = 0;

                    i += 32;
                }

                // If the whole DWORD is 0x00000000 (meaning none of the
                // chunks is yet allocated) then we could grab all
                while ((i < (INT)dwStartLastBlock) &&
                       (CHUNKNUM_ELEM((*pAlloc->pMMap), i) == 0x00000000) &&
                       !(dwNumContChunksFound >= dwContChunksNeeded))
                {
                    if (dwNumContChunksFound == 0)
                    {
                        dwCurrStartChunk = i;
                    }
                    i += 32;                    
                    dwNumContChunksFound += 32;
                }

                if (dwNumContChunksFound >= dwContChunksNeeded)
                {
                    break; // We've found a suitable place! Break loop here
                }  
                else if(!(i < (INT)pAlloc->dwMaxChunks))
                {
                    break; // finished examining all memory, break loop here
                }             
                
            }
#endif // ALLOC_OPTIMIZE
            if (MEM_CHUNK_VAL((*pAlloc->pMMap), i) == 0)
            {
                if (dwNumContChunksFound == 0)
                {
                    // our count so far of contigous chunks is zero, 
                    // meaning that were just starting to find free
                    // chunks. We need to remember where this block
                    // is starting
                    dwCurrStartChunk = i;
                }
                dwNumContChunksFound++;            
            }
            else
            {
                // This chunk is being used and we haven't found a suitable
                // set of chunks, so reset our count of contigous chunks 
                // found so far
                dwNumContChunksFound = 0;        
            }

            if (dwNumContChunksFound >= dwContChunksNeeded)
            {
                // We've found a suitable place!
                break; // break loop here
            }            
        }
    }

    // If we found a suitable place lets allocate in it
    if (dwNumContChunksFound >= dwContChunksNeeded)
    {
        // Fill in the return pointer (properly aligned)
        lpMemReq->pMem = __LIN_AlignPtr(CHUNK_NUM_TO_PTR(pAlloc,
                                                         dwCurrStartChunk),
                                        lpMemReq->dwAlign);
        
        for (i = dwCurrStartChunk ; 
             i < (INT)(dwCurrStartChunk + dwContChunksNeeded); 
             i++)
        {
            // Set up the bits in the memory map to indicate those
            // addresses are being used.
            SET_MEM_CHUNK((*pAlloc->pMMap), i);        
            
            // Clear the bits in the lenght memory map to indicate that
            // the alloacted block doesn't end here.
            CLR_MEM_CHUNK((*pAlloc->pLenMap), i);                        
        }

        // Now set the last bit of the lenght map in order to indicate
        // end-of-allocated-block
        SET_MEM_CHUNK((*pAlloc->pLenMap), 
                      dwCurrStartChunk + dwContChunksNeeded - 1);                                

        return GLDD_SUCCESS;
    }    

    return GLDD_NOMEM;

} // _DX_LIN_AllocateLinearMemory


//-----------------------------------------------------------------------------
//
// _DX_LIN_FreeLinearMemory
//
// This is the interface to memory freeing.
// 
//-----------------------------------------------------------------------------
DWORD 
_DX_LIN_FreeLinearMemory(
    pLinearAllocatorInfo pAlloc, 
    DWORD VidPointer)
{
    // Reinitialize heap allocater if needed
    __LIN_ReInitWhenNeeded(pAlloc);  

    if (pAlloc && pAlloc->pMMap && pAlloc->pLenMap)
    {
        DWORD i, dwFirstChunk;
        BOOL bLast = FALSE;
        
        // Now compute the starting chunk for this VidMem ptr
        dwFirstChunk = MEM_PTR_TO_CHUNK_NUM(pAlloc, VidPointer);

        // Clear the relevant bits in the memory map until the 
        // lenght map indicates we've reached the end of the allocated
        // block 

        i = dwFirstChunk;
        
        while ((!bLast) && (i <= pAlloc->dwMaxChunks))
        {
            // First check if this is the end of the block
            bLast = MEM_CHUNK_VAL((*pAlloc->pLenMap), i );

            // Now "delete" it (even if its the end of the block)
            CLR_MEM_CHUNK((*pAlloc->pMMap), i);
            
            // Set the bits in the lenght memory map for future
            // allocations. 
            SET_MEM_CHUNK((*pAlloc->pLenMap), i);            

            i++;
        } 
        
        return GLDD_SUCCESS;                           
    }

    return GLDD_NOMEM;
    
} // _DX_LIN_FreeLinearMemory


//-----------------------------------------------------------------------------
//
// _DX_LIN_GetFreeMemInHeap
//
// Scans the memory map and reports the memory that is available in it.
// 
//-----------------------------------------------------------------------------
DWORD
_DX_LIN_GetFreeMemInHeap(
    pLinearAllocatorInfo pAlloc)
{
    DWORD dwTotalFreeMem = 0;
    DWORD dwLargestBlock = 0;
    DWORD dwTempSize = 0;
    DWORD i;
    
    // Reinitialize heap allocater if needed
    __LIN_ReInitWhenNeeded(pAlloc);  

    // Make sure the linear allocator & memory map are valid
    if (pAlloc && pAlloc->pMMap)
    {
        for (i = 0; i < pAlloc->dwMaxChunks ; i++)
        {
            // Check if chunk is free or in use
            if (MEM_CHUNK_VAL((*pAlloc->pMMap), i) == 0)
            {
                // Keep track of total free memory
                dwTotalFreeMem++;

                // Keep track of largest single memory area
                dwTempSize++;
                if (dwTempSize > dwLargestBlock)
                {
                    dwLargestBlock = dwTempSize;
                }
            }
            else
            {
                dwTempSize = 0;
            }
        }

        // There is a minimum amount for an allocation to succeed since we have
        // to pad these/ surfaces out to 32x32, so a 32bpp surface requires at 
        // least 4K free.
//@@BEGIN_DDKSPLIT
        // If we say that we have 1.5K free, then we'll fail TDDRAW WHQL test.  Ouch!
//@@END_DDKSPLIT    
        if (dwLargestBlock * pAlloc->dwMemPerChunk >= 4096)
        {
            return dwTotalFreeMem * pAlloc->dwMemPerChunk;
        }        
    }

    return 0;    
    
} // _DX_LIN_GetFreeMemInHeap
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\stateset.c ===
/******************************Module*Header**********************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: hwcontxt.c
*
* Content: Manages hardware context switching between GDI/DD/D3D
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
//
// Driver Version
//
// This helps us find out from the debugger what driver is loaded on a given 
// remote system
//
//-----------------------------------------------------------------------------

char gc_DriverVersion[] = 
#if DX8_DDI 
                         " DX8"
#else
                         " DX7"
#endif
                         
#if DBG
                         " CHECKED DRIVER"
#else
                         " FREE DRIVER"
#endif
                         " In Path: "  __FILE__ 
                         " Compiled on Date: "   __DATE__  
                         " Time: "  __TIME__  
                         " With #defines: "                          
                         "  DX8_MULTSTREAMS: "      
#if DX8_MULTSTREAMS
                                "1"
#else
                                "0"
#endif
                         "  DX8_VERTEXSHADERS: "    
#if DX8_VERTEXSHADERS
                                "1"
#else
                                "0"
#endif                       
                         "  DX8_POINTSPRITES: "      
#if DX8_POINTSPRITES
                                "1"
#else
                                "0"
#endif                      
                         "  DX8_PIXELSHADERS: "     
#if DX8_PIXELSHADERS
                                "1"
#else
                                "0"
#endif                         
                         "  DX8_3DTEXTURES: "     
#if DX8_3DTEXTURES
                                "1"
#else
                                "0"
#endif                           
                         "  DX8_MULTISAMPLING: "     
#if DX8_MULTISAMPLING
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_ANTIALIAS: "         
#if DX7_ANTIALIAS
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_D3DSTATEBLOCKS: "    
#if DX7_D3DSTATEBLOCKS
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_PALETTETEXTURE: "    
#if DX7_PALETTETEXTURE
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_STEREO: "            
#if DX7_STEREO
                                "1"
#else
                                "0"
#endif                           
                         "  DX7_TEXMANAGEMENT: "     
#if DX7_TEXMANAGEMENT
                                "1"
#else
                                "0"
#endif                           
                            ;

//-----------------------------------------------------------------------------
//
// __HWC_SwitchToDX
//
// Writes any hardware registers that need updating on entry into the
// DirectX driver, which are appropriate to both DirectDraw and Direct3D.
//
//-----------------------------------------------------------------------------
void __HWC_SwitchToDX( P3_THUNKEDDATA* pThisDisplay, BOOL bDXEntry)
{
    P3_DMA_DEFS();

    P3_DMA_GET_BUFFER_ENTRIES(4);

    SEND_P3_DATA(SizeOfFramebuffer, pThisDisplay->pGLInfo->ddFBSize >> 4);

    // We have entered the DirectX driver from a
    // foreign context (such as the display driver)
    if (bDXEntry)
    {
//@@BEGIN_DDKSPLIT    
#if DX7_VERTEXBUFFERS    
        // First cause a flush of all buffers
        // We know this is safe because the contex switch 
        // from the other driver to here will have caused a sync
        // and the buffers must therefore have been consumed
        // therefore we call with bWait == FALSE
        _D3D_EB_FlushAllBuffers(pThisDisplay, FALSE);
#endif //DX7_VERTEXBUFFERS        
//@@END_DDKSPLIT

        // Reset the hostin ID
        SEND_P3_DATA(HostInID, 0);
        pThisDisplay->dwCurrentSequenceID = 0;
    }

    P3_DMA_COMMIT_BUFFER();

    if (bDXEntry)
    {
        P3_DMA_GET_BUFFER_ENTRIES( 4 );

        // Reset the RenderID to the last-used one.
        SEND_HOST_RENDER_ID ( GET_HOST_RENDER_ID() );
        P3_DMA_FLUSH_BUFFER();

        // Need to push the render ID to the end of the pipe...
        SYNC_WITH_GLINT;

        // ...and now it's valid.
        pThisDisplay->bRenderIDValid = (DWORD)TRUE;

    }
} // __HWC_SwitchToDX

//-----------------------------------------------------------------------------
//
// HWC_SwitchToDDRAW
//
// Writes any hardware registers that need updating on entry into the
// DirectX driver, which are appropriate specifically to DirectDraw
//
//-----------------------------------------------------------------------------
void HWC_SwitchToDDRAW( P3_THUNKEDDATA* pThisDisplay, BOOL bDXEntry)
{
    P3_DMA_DEFS();

    __HWC_SwitchToDX(pThisDisplay, bDXEntry);

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    // Disable various units
    SEND_P3_DATA(AreaStippleMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(LineStippleMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(ScissorMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(ColorDDAMode,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(FogMode,              __PERMEDIA_DISABLE);
    SEND_P3_DATA(AntialiasMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(AlphaTestMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(Window,               __PERMEDIA_DISABLE);
    SEND_P3_DATA(StencilMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(DepthMode,            __PERMEDIA_DISABLE);
    SEND_P3_DATA(DitherMode,           __PERMEDIA_DISABLE);
    SEND_P3_DATA(LogicalOpMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(StatisticMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(FilterMode,           __PERMEDIA_DISABLE);

    P3_ENSURE_DX_SPACE(30);
    WAIT_FIFO(30);

    // Frame buffer
    SEND_P3_DATA(FBSourceData,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBHardwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
    SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
    SEND_P3_DATA(FBWriteMode,         __PERMEDIA_ENABLE);

    // We sometimes use the scissor in DDRAW to scissor out unnecessary pixels.
    SEND_P3_DATA(ScissorMinXY, 0);
    SEND_P3_DATA(ScissorMaxXY, (pThisDisplay->cyMemory << 16) | 
                               (pThisDisplay->cxMemory)         );
    SEND_P3_DATA(ScreenSize, (pThisDisplay->cyMemory << 16) | 
                             (pThisDisplay->cxMemory)           );
    
    SEND_P3_DATA(WindowOrigin, 0x0);

    // DirectDraw might not need to set these up
    SEND_P3_DATA(dXDom, 0x0);
    SEND_P3_DATA(dXSub, 0x0);
    SEND_P3_DATA(dY, 1 << 16);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);
    
    SEND_P3_DATA(GIDMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE);

    // Delta Unit
    SEND_P3_DATA(DeltaControl, 0);
    SEND_P3_DATA(DeltaMode, __PERMEDIA_DISABLE);

    SEND_P3_DATA(FBSourceReadMode,  __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBDestReadMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBDestReadEnables, __PERMEDIA_DISABLE);

    // DDraw driver code doesn't want offsets
    SEND_P3_DATA(LBSourceReadBufferOffset, 0);
    SEND_P3_DATA(LBDestReadBufferOffset,   0);
    SEND_P3_DATA(LBWriteBufferOffset,      0);
    SEND_P3_DATA(FBWriteBufferOffset0,     0);
    SEND_P3_DATA(FBDestReadBufferOffset0,  0);
    SEND_P3_DATA(FBSourceReadBufferOffset, 0);

    P3_ENSURE_DX_SPACE(12);
    WAIT_FIFO(12);
    
    // Local buffer
    SEND_P3_DATA(LBSourceReadMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBDestReadMode,   __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBWriteMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBWriteFormat,    __PERMEDIA_DISABLE);

    // Blending
    SEND_P3_DATA(AlphaBlendAlphaMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(AlphaBlendColorMode, __PERMEDIA_DISABLE);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);
    
    // Texturing (disable)
    SEND_P3_DATA(TextureReadMode0,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureReadMode1,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureIndexMode0,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureIndexMode1,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCompositeMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCoordMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureApplicationMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(ChromaTestMode,            __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureFilterMode,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTTransfer,               __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTIndex,                  __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTAddress,                __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTMode,                   __PERMEDIA_DISABLE);

    SEND_P3_DATA(RasterizerMode,            __PERMEDIA_DISABLE);

    // Router setup.  DDRAW doesn't care about Z Writes
    SEND_P3_DATA(RouterMode, __PERMEDIA_ENABLE);

    P3_DMA_COMMIT_BUFFER();

} //HWC_SwitchToDDRAW

//-----------------------------------------------------------------------------
//
// HWC_SwitchToD3D
//
// Writes any hardware registers that need updating on entry into the
// DirectX driver, which are appropriate specifically to Direct3D
//
//-----------------------------------------------------------------------------
void 
HWC_SwitchToD3D( 
    P3_D3DCONTEXT *pContext, 
    P3_THUNKEDDATA* pThisDisplay, 
    BOOL bDXEntry)
{
    P3_SOFTWARECOPY* pSoftPermedia = &pContext->SoftCopyGlint;
    int i;
    P3_DMA_DEFS();

    // Switch first to the common DX/DDraw/D3D setup
    __HWC_SwitchToDX(pThisDisplay, bDXEntry);

    P3_DMA_GET_BUFFER();

#if DBG
    ASSERTDD(IS_DXCONTEXT_CURRENT(pThisDisplay), 
                    "ERROR: DX Context not current in HWC_SwitchToDDRAW!");
    if ( ((ULONG_PTR)dmaPtr >= (ULONG_PTR)pThisDisplay->pGlint->GPFifo) &&
         ((ULONG_PTR)dmaPtr <= (ULONG_PTR)pThisDisplay->pGlint->GPFifo + 4000) )
    {
        ASSERTDD(pThisDisplay->pGLInfo->InterfaceType != GLINT_DMA,
                 "Error: In FIFO space and setup for DMA");
    }
    else
    {
        ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA,
                 "Error: In DMA space and setup for FIFO's");
    }
#endif

    // Now we restore default values and restore D3D context dependent settings
    // directly from what we stored in our context structure.

    // Common registers
    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(16);
    SEND_P3_DATA(WindowOrigin, 0);
    SEND_P3_DATA(AreaStippleMode, 1);
    COPY_P3_DATA(DitherMode, pSoftPermedia->DitherMode);

    WAIT_FIFO(16);
    COPY_P3_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);
    COPY_P3_DATA(Window, pSoftPermedia->PermediaWindow);
#if DX8_DDI   
    SEND_P3_DATA(FBHardwareWriteMask, pContext->dwColorWriteHWMask);      
    SEND_P3_DATA(FBSoftwareWriteMask, pContext->dwColorWriteSWMask);
#else
    SEND_P3_DATA(FBHardwareWriteMask, 
                            pContext->RenderStates[D3DRENDERSTATE_PLANEMASK]);
    SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);    
#endif
    SEND_P3_DATA(FilterMode,           __PERMEDIA_DISABLE);


    // Force the flat stippled alpha renderers to reload 
    // the stipple pattern if needed.
    P3_ENSURE_DX_SPACE(32);    // First 16 Stipple registers
    WAIT_FIFO(32);
    for( i = 0; i < 16; i++ )
    {
        SEND_P3_DATA_OFFSET( AreaStipplePattern0, 
                            (DWORD)pContext->CurrentStipple[i], i );
    }
    
    P3_ENSURE_DX_SPACE(32);    // Second set of 16 Stipple registers 
    WAIT_FIFO(32);          // (loaded separately to have GVX1 compatibilty)
    for( i = 16; i < 32; i++ )
    {
        SEND_P3_DATA_OFFSET( AreaStipplePattern0, 
                            (DWORD)pContext->CurrentStipple[i], i );
    }

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(GIDMode, 0);

    // Don't want offsets
    SEND_P3_DATA(LBSourceReadBufferOffset, 0);
    SEND_P3_DATA(LBDestReadBufferOffset,   0);
    SEND_P3_DATA(LBWriteBufferOffset,      0);
    SEND_P3_DATA(FBWriteBufferOffset0,     0);
    SEND_P3_DATA(FBDestReadBufferOffset0,  0);
    SEND_P3_DATA(FBSourceReadBufferOffset, 0);

    // Frame buffer
    SEND_P3_DATA(FBSourceReadMode,  __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBDestReadMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBDestReadEnables, __PERMEDIA_DISABLE);

    SEND_P3_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    SEND_P3_DATA(GIDMode, __PERMEDIA_DISABLE);
    SEND_P3_DATA(YUVMode, __PERMEDIA_DISABLE);

    // Frame buffer 
    COPY_P3_DATA(FBWriteMode, pSoftPermedia->P3RXFBWriteMode);

    // Delta
    COPY_P3_DATA(DeltaMode,    pSoftPermedia->P3RX_P3DeltaMode);
    COPY_P3_DATA(DeltaControl, pSoftPermedia->P3RX_P3DeltaControl);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    SEND_P3_DATA(XBias, *(DWORD*)&pContext->XBias);
    SEND_P3_DATA(YBias, *(DWORD*)&pContext->YBias);

    // Disable chroma tests
    SEND_P3_DATA(ChromaTestMode, __PERMEDIA_DISABLE);

    // Router setup
    SEND_P3_DATA(RouterMode, __PERMEDIA_ENABLE);

    SEND_P3_DATA( VertexTagList0, V0FloatX_Tag );
    SEND_P3_DATA( VertexTagList1, V0FloatY_Tag );
    SEND_P3_DATA( VertexTagList2, V0FloatZ_Tag );
    SEND_P3_DATA( VertexTagList3, V0FloatQ_Tag );
    SEND_P3_DATA( VertexTagList4, V0FloatPackedColour_Tag );
    SEND_P3_DATA( VertexTagList5, V0FloatPackedSpecularFog_Tag );
    SEND_P3_DATA( VertexTagList6, V0FloatS_Tag );
    SEND_P3_DATA( VertexTagList7, V0FloatT_Tag );
    SEND_P3_DATA( VertexTagList8, V0FloatS1_Tag );
    SEND_P3_DATA( VertexTagList9, V0FloatT1_Tag );

    // Restore the texturecachereplacement mode.
    COPY_P3_DATA(TextureCacheReplacementMode, 
                        pSoftPermedia->P3RXTextureCacheReplacementMode);

    SEND_P3_DATA( ProvokingVertexMask, 0xfff );    

    P3_ENSURE_DX_SPACE(8);
    WAIT_FIFO(8);

    COPY_P3_DATA( LineStippleMode, pSoftPermedia->PXRXLineStippleMode);    

    P3_DMA_COMMIT_BUFFER();

//@@BEGIN_DDKSPLIT
// azn - is this really necessary???
//@@END_DDKSPLIT

    // This will cause the FVF state to be recalculated
    ZeroMemory(&pContext->FVFData, sizeof(FVFOFFSETS));

    // Force everything to be set up again before rendering
    DIRTY_EVERYTHING(pContext);

} // HWC_SwitchToD3D

//-----------------------------------------------------------------------------
//
// HWC_SwitchToFIFO
//
// Allows us to switch from DMA mode to FIFO transfers 
//
//-----------------------------------------------------------------------------
void HWC_SwitchToFIFO( P3_THUNKEDDATA* pThisDisplay, LPGLINTINFO pGLInfo )
{
    P3_DMA_DEFS();

    if (pGLInfo->InterfaceType != GLINT_NON_DMA)
    {
        DISPDBG((WRNLVL,"Switching to 4K Funny FIFO Memory"));
        
        P3_DMA_GET_BUFFER();
        P3_DMA_FLUSH_BUFFER();
        SYNC_WITH_GLINT;
        
        pGLInfo->InterfaceType = GLINT_NON_DMA;
        pGLInfo->CurrentBuffer = (ULONG *)pThisDisplay->pGlint->GPFifo; 
    }
    else
    {
        // This means we already are in FIFO mode
        DISPDBG((DBGLVL,"NOT Switching to 4K Funny FIFO Memory"));
    }
} // HWC_SwitchToFIFO

//-----------------------------------------------------------------------------
//
// HWC_SwitchToDMA
//
// Allows us to switch from FIFO transfers to DMA mode
//
//-----------------------------------------------------------------------------
void HWC_SwitchToDMA( P3_THUNKEDDATA* pThisDisplay, LPGLINTINFO pGLInfo )
{

    if (pGLInfo->InterfaceType != GLINT_DMA)
    {
        DISPDBG((WRNLVL,"Switching to DMA buffers"));
        SYNC_WITH_GLINT;

        pGLInfo->InterfaceType = GLINT_DMA;
        pGLInfo->CurrentBuffer = 
                    pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr;
    }
    else
    {
        DISPDBG((WRNLVL,"NOT Switching to DMA buffers"));
    }
} // HWC_SwitchToDMA


//-----------------------------------------------------------------------------
//
// __HWC_RecalculateDXDMABuffers
//
// Run through the OpanGL buffer mask to determine which remaining piece of
// buffer is the biggest and setup DirectX to use this buffer.
//
//-----------------------------------------------------------------------------
void 
__HWC_RecalculateDXDMABuffers(
    P3_THUNKEDDATA* pThisDisplay)
{
    DWORD dwSize, i;
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    if (pGLInfo->InterfaceType != GLINT_DMA) 
    {
        // exit if we are not using DMA
        return;
    }

    // Just use the entire DMA Buffer.
    pThisDisplay->DMAInfo.dwBuffSize = 
                    pThisDisplay->pGLInfo->dw3DDMABufferSize;
    pThisDisplay->DMAInfo.dwBuffPhys = 
                    pThisDisplay->pGLInfo->dw3DDMABufferPhys;
    pThisDisplay->DMAInfo.dwBuffVirt = 
                    pThisDisplay->pGLInfo->dw3DDMABufferVirt;
    
    DISPDBG((DBGLVL,"__HWC_RecalculateDXDMABuffers V:0x%p P:0x%x S:0x%x", 
                    pThisDisplay->DMAInfo.dwBuffVirt, 
                    pThisDisplay->DMAInfo.dwBuffPhys, 
                    pThisDisplay->DMAInfo.dwBuffSize));

    dwSize = ((DWORD)(pThisDisplay->DMAInfo.dwBuffSize) / 
                        (DWORD)pGLInfo->NumberOfSubBuffers);
                        
    dwSize = ((dwSize + 3) & ~3);

    pThisDisplay->PartitionSize = dwSize / sizeof(DWORD);

    DISPDBG((DBGLVL,"Got Buffer with 0x%x Sub Buffers", 
                    pGLInfo->NumberOfSubBuffers));

    for (i = 0; i < pGLInfo->NumberOfSubBuffers; i++)
    {
        pGLInfo->DMAPartition[i].VirtAddr =
                        (ULONG *)((char*)(pThisDisplay->DMAInfo.dwBuffVirt) + 
                                  (i * dwSize));
                                
        pGLInfo->DMAPartition[i].PhysAddr =
                        (DWORD)((pThisDisplay->DMAInfo.dwBuffPhys) + 
                                    (i * dwSize));
                                
        pGLInfo->DMAPartition[i].MaxAddress =
                                (ULONG_PTR)pGLInfo->DMAPartition[i].VirtAddr + dwSize;
                        
        pGLInfo->DMAPartition[i].Locked = FALSE;

        DISPDBG((DBGLVL,"   Partition%d: VirtAddr = 0x%x, "
                        "   PhysAddr = 0x%x, MaxAddres = 0x%x",
                        i, 
                        pGLInfo->DMAPartition[i].VirtAddr,
                        pGLInfo->DMAPartition[i].PhysAddr,
                        pGLInfo->DMAPartition[i].MaxAddress));

#if DBG
        pGLInfo->DMAPartition[i].bStampedDMA = TRUE;
//@@BEGIN_DDKSPLIT        
#if 0
//azn hard to say in 64 bits!
        memset((void*)pGLInfo->DMAPartition[i].VirtAddr, 
               0x4D,
               (pGLInfo->DMAPartition[i].MaxAddress - 
                                pGLInfo->DMAPartition[i].VirtAddr));
#endif            
//@@END_DDKSPLIT
#endif

    }

    pGLInfo->CurrentBuffer = 
                pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr;
    
} // __HWC_RecalculateDXDMABuffers

//-----------------------------------------------------------------------------
//
// HWC_StartDMA
//
//-----------------------------------------------------------------------------
DWORD WINAPI
HWC_StartDMA(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD     dwContext,
    DWORD     dwSize, 
    DWORD     dwPhys, 
    ULONG_PTR dwVirt, 
    DWORD     dwEvent)
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    ASSERTDD( (int)dwSize > 0, "DMA buffer size non-positive" );

    ASSERTDD((IS_DXCONTEXT_CURRENT(pThisDisplay) && 
              (pGLInfo->InterfaceType == GLINT_DMA)), 
             "Error, Trying DMA when not setup for it!" );

#if W95_DDRAW
    ASSERTDD( pGLInfo->endIndex != 0, "Trying DMA with zero sub-buffers" );
#endif

#if DBG
    pGLInfo->DMAPartition[pGLInfo->CurrentPartition].bStampedDMA = FALSE;
#endif

#ifdef W95_DDRAW
    ASSERTDD(pThisDisplay->pGLInfo->dwCurrentContext != CONTEXT_DISPLAY_HANDLE,
             "HWC_StartDMA: In display driver context" )

    ASSERTDD( pThisDisplay->pGlint->FilterMode == 0,
             "FilterMode non-zero" );
#endif

#if WNT_DDRAW
    DDSendDMAData(pThisDisplay->ppdev, dwPhys, dwVirt, dwSize);
#else
    StartDMAProper(pThisDisplay, pGLInfo, dwPhys, dwVirt, dwSize);
#endif

    DISPDBG((DBGLVL, "HWC_StartDMA sent %d dwords", dwSize));

    return GLDD_SUCCESS;
} // HWC_StartDMA

//-----------------------------------------------------------------------------
//
// HWC_AllocDMABuffer
//
//-----------------------------------------------------------------------------
void 
HWC_AllocDMABuffer( 
    P3_THUNKEDDATA* pThisDisplay)
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;
    int i;
    DWORD bDMA = TRUE;
    BOOL bRet;
    DWORD Result;

    // Empty the DMA partition slots
    for (i = 0; i < MAX_SUBBUFFERS; i++)
    {
        pGLInfo->DMAPartition[i].PhysAddr = 0;
        pGLInfo->DMAPartition[i].VirtAddr = 0;
        pGLInfo->DMAPartition[i].MaxAddress = 0;
    }

#if WNT_DDRAW
    // DMA turned off
    bDMA = FALSE;
#else
    // Are we allowed to DMA?
    bRet = GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.NoDMA", &Result);
    if ((bRet && (Result != 0)) ||
        (pThisDisplay->pGLInfo->dw3DDMABufferSize == 0))
    {
        bDMA = FALSE;
    }
#endif
 
    // Find out how many sub buffers the user wants.
    bRet = GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.SubBuffers", &Result);
    if ((Result == 0) || (bRet == FALSE))
    {
        // Default
        pGLInfo->NumberOfSubBuffers = DEFAULT_SUBBUFFERS;
    }
    else 
    {
        if (Result > MAX_SUBBUFFERS)
        {
            pGLInfo->NumberOfSubBuffers = MAX_SUBBUFFERS;
        }
        else
        {
            pGLInfo->NumberOfSubBuffers = Result; 
        }
        
        if (pGLInfo->NumberOfSubBuffers < 2)
        {
            pGLInfo->NumberOfSubBuffers = 2;
        }
    }

    // if no interrupt driven DMA or asked for less than 3 buffers then
    // configure no Q for this context 
    if ((pGLInfo->dwFlags & GMVF_NOIRQ) || (pGLInfo->NumberOfSubBuffers < 2))
    {
        pGLInfo->NumberOfSubBuffers = 2;
    }

    DISPDBG((DBGLVL,"Setting 0x%x Sub Buffers", pGLInfo->NumberOfSubBuffers));

    // Initialise for no DMA if DMA has been turned off for whatever reason
    if (!bDMA)
    {
        DISPDBG((WRNLVL,"Using 4K Funny FIFO Memory"));
        
        pGLInfo->InterfaceType = GLINT_NON_DMA;
        pThisDisplay->StartDMA = 0;
        
        pGLInfo->NumberOfSubBuffers = 0;

        pGLInfo->CurrentBuffer = (ULONG *)pThisDisplay->pGlint->GPFifo;

        pThisDisplay->b2D_FIFOS = TRUE;
    }
    else
    {
        // DMA Setup
        pGLInfo->InterfaceType = GLINT_DMA;
        pThisDisplay->StartDMA = HWC_StartDMA;

        // This call will actually setup the partitions
        __HWC_RecalculateDXDMABuffers(pThisDisplay);

        // Is DirectDraw DMA disabled?
        bRet = GET_REGISTRY_ULONG_FROM_STRING("Direct3DHAL.No2DDMA", &Result);
        if (bRet && (Result == 1))
        {
            pThisDisplay->b2D_FIFOS = TRUE;
        }
        else
        {
            pThisDisplay->b2D_FIFOS = FALSE;
        }
    }
#if W95_DDRAW
    // Store the end index in the context.
    SetEndIndex(pGLInfo, 
                CONTEXT_DIRECTX_HANDLE, 
                (unsigned short)pGLInfo->NumberOfSubBuffers);
                
#endif // W95_DDRAW

    if (pGLInfo->InterfaceType == GLINT_NON_DMA) 
    {
        DISPDBG((WRNLVL,"DDRAW: Using FIFO's"));
    }
    else
    {
        DISPDBG((WRNLVL,"DDRAW: Using DMA"));
    }
} // HWC_AllocDMABuffer



//-----------------------------------------------------------------------------
//
// HWC_FlushDXBuffer
//
//-----------------------------------------------------------------------------
void
HWC_FlushDXBuffer( 
    P3_THUNKEDDATA* pThisDisplay )
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    if( pGLInfo->InterfaceType == GLINT_DMA )
    {
        DWORD Send;
        P3_DMAPartition *pCurrDMAPartition;

        pCurrDMAPartition = &(pGLInfo->DMAPartition[pGLInfo->CurrentPartition]);

//@@BEGIN_DDKSPLIT
        // azn - we might lose 64 bit precision here!
//@@END_DDKSPLIT        
        Send = (DWORD)(pGLInfo->CurrentBuffer - pCurrDMAPartition->VirtAddr) 
                / sizeof(DWORD);

        if( Send )
        {
            ASSERTDD( Send < 0x10000, "Wacky DMA size" );

            ((__StartDMA)pThisDisplay->StartDMA)
                    (pThisDisplay, 
                     CONTEXT_DIRECTX_HANDLE, 
                     Send, 
                     (DWORD)(pCurrDMAPartition->PhysAddr),
                     (ULONG_PTR)(pCurrDMAPartition->VirtAddr), 
                     0);
                     
            pGLInfo->CurrentPartition++;

            if (pGLInfo->CurrentPartition == pGLInfo->NumberOfSubBuffers)
            {
                pGLInfo->CurrentPartition = 0;
            }

            ASSERTDD(!pGLInfo->DMAPartition[pGLInfo->CurrentPartition].Locked,
                     "Partition already locked" );
        }

        pGLInfo->CurrentBuffer = 
            pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr;
    }
    else
    {
        pGLInfo->CurrentBuffer = (ULONG *)pThisDisplay->pGlint->GPFifo; 
    }
} // HWC_FlushDXBuffer


#if DBG
//-----------------------------------------------------------------------------
//
// HWC_GetDXBuffer
//
//-----------------------------------------------------------------------------
void
HWC_GetDXBuffer( 
    P3_THUNKEDDATA* pThisDisplay, 
    char *file, 
    int line )
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;
 
    ASSERTDD( pGLInfo->dwFlags & GMVF_GCOP, "VDD not locked out" );

    ASSERTDD( !pThisDisplay->BufferLocked, "Buffer already locked" );

    pThisDisplay->BufferLocked = TRUE;

#ifdef WANT_DMA
    if(( pGLInfo->endIndex > 2 ) && !IS_DXCONTEXT_CURRENT(pThisDisplay))
    {
        ASSERTDD( pGLInfo->CurrentBuffer == 
                  pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr,
                 "Trying to DMA in display driver context" );
    }
#endif

    DISPDBG(( DBGLVL, "HWC_GetDXBuffer: %s %d: Curr part %d, dmaPtr 0x%08x",
                      file, line,
                      pGLInfo->CurrentPartition, pGLInfo->CurrentBuffer ));

    if (pGLInfo->InterfaceType == GLINT_DMA)
    {
        DISPDBG(( DBGLVL, "HWC_GetDXBuffer: %d dwords to flush", 
                          ( pGLInfo->CurrentBuffer - 
                            pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr ) / 4 ));
    }
    else
    {
        DISPDBG(( DBGLVL, "HWC_GetDXBuffer: Using FIFOs"));
    }

#ifdef WANT_DMA
    // Ensure nobody has scribbled on the DMA Buffer
    if(( pGLInfo->InterfaceType == GLINT_DMA ) && 
       (pGLInfo->DMAPartition[pGLInfo->CurrentPartition].bStampedDMA) )
    {
        ASSERTDD( *(DWORD*)pThisDisplay->pGLInfo->CurrentBuffer == 0x4D4D4D4D,
                 "ERROR: DMA Buffer signature invalid!" );
    }


    // Ensure we aren't writing to the wrong region
    if(IS_DXCONTEXT_CURRENT(pThisDisplay) &&
       ( pThisDisplay->pGLInfo->InterfaceType != GLINT_UNKNOWN_INTERFACE ))
    {
        if ((((ULONG_PTR)pThisDisplay->pGLInfo->CurrentBuffer >= 
              (ULONG_PTR)pThisDisplay->pGlint->GPFifo))           &&
            ((ULONG_PTR)pThisDisplay->pGLInfo->CurrentBuffer <= 
             ((ULONG_PTR)pThisDisplay->pGlint->GPFifo + 4000)) )
        {
            ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_NON_DMA,
                     "Error: In FIFO space and setup for DMA");
        }
        else
        {
            ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA,
                     "Error: In DMA space and setup for FIFO's");
        }
    }
#endif
} // HWC_GetDXBuffer

//-----------------------------------------------------------------------------
//
// HWC_SetDXBuffer
//
//-----------------------------------------------------------------------------
void
HWC_SetDXBuffer( 
    P3_THUNKEDDATA* pThisDisplay, 
    char *file, 
    int line )
{
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    ASSERTDD( pGLInfo->dwFlags & GMVF_GCOP, "VDD not locked out" );

    pThisDisplay->BufferLocked = FALSE;

    DISPDBG(( DBGLVL, "HWC_SetDXBuffer: %s %d: Curr part %d, dmaPtr 0x%08x",
                        file, line,
                        pGLInfo->CurrentPartition, pGLInfo->CurrentBuffer ));
    if (pGLInfo->InterfaceType == GLINT_DMA)
    {
        DISPDBG(( DBGLVL, "HWC_SetDXBuffer: %d dwords to flush", 
                      ( pGLInfo->CurrentBuffer - 
                       pGLInfo->DMAPartition[pGLInfo->CurrentPartition].VirtAddr ) / 4 ));
    }
    else
    {
        DISPDBG(( DBGLVL, "HWC_SetDXBuffer: Using FIFOs"));
    }

#ifdef WANT_DMA
    // Ensure nobody has scribbled on the DMA Buffer
    if(( pGLInfo->InterfaceType == GLINT_DMA ) && 
       (pGLInfo->DMAPartition[pGLInfo->CurrentPartition].bStampedDMA) )
    {
        ASSERTDD( *(DWORD*)pThisDisplay->pGLInfo->CurrentBuffer == 0x4D4D4D4D,
                 "ERROR: DMA Buffer signature invalid!" );
    }

    // Ensure we aren't writing to the wrong region
    if(IS_DXCONTEXT_CURRENT(pThisDisplay) &&
       ( pThisDisplay->pGLInfo->InterfaceType != GLINT_UNKNOWN_INTERFACE ))
    {
        if ((((ULONG_PTR)pThisDisplay->pGLInfo->CurrentBuffer >= 
              (ULONG_PTR)pThisDisplay->pGlint->GPFifo))            &&
            ((ULONG_PTR)pThisDisplay->pGLInfo->CurrentBuffer <= 
             ((ULONG_PTR)pThisDisplay->pGlint->GPFifo + 4000))   )
        {
            ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_NON_DMA,
                     "Error: In FIFO space and setup for DMA");
        }
        else
        {
            ASSERTDD(pThisDisplay->pGLInfo->InterfaceType == GLINT_DMA,
                     "Error: In DMA space and setup for FIFO's");
        }
    }

#endif // WANT_DMA
} // HWC_SetDXBuffer


//-----------------------------------------------------------------------------
//
// HWC_bRenderIDHasCompleted
//
// This is simply the paranoid version of the macro
// declared in directx.h. It is present only in checked (debug)
// builds, since the non-debug version is just a
// one-line #define.
//-----------------------------------------------------------------------------
BOOL 
HWC_bRenderIDHasCompleted ( 
    DWORD dwID, 
    P3_THUNKEDDATA* pThisDisplay )
{
    DWORD dwCurID, dwCurHostID;
    int iTemp;

    ASSERTDD (CHIP_RENDER_ID_IS_VALID(), 
              "** RENDER_ID_HAS_COMPLETED: Chip's RenderID is not valid." );

    dwCurID = GET_CURRENT_CHIP_RENDER_ID();
    // Make sure the invalid bits have been zapped.
    ASSERTDD ( ( dwCurID | RENDER_ID_KNACKERED_BITS ) == dwCurID, 
              "** RENDER_ID_HAS_COMPLETED: Current chip ID is invalid" );
    ASSERTDD ( ( dwID | RENDER_ID_KNACKERED_BITS ) == dwID, 
              "** RENDER_ID_HAS_COMPLETED: Checked ID is invalid" );

    // We need to cope with the fact that the MinRegion register sign-extends
    // some bits in the middle, irritatingly. It's not a problem for simple
    // >=< tests, but this wants to know _how much_ we are out.
    // Bits 0xf000f000 are rubbish, so we need to chop them out.
    // This is not a problem on P3, and the RENDER_ID_VALID macros are set up
    // so this code will basically be compiled out of existence.
    dwCurID = ( dwCurID & RENDER_ID_VALID_BITS_LOWER ) | 
              ( ( dwCurID & RENDER_ID_VALID_BITS_UPPER ) >> 
                         RENDER_ID_VALID_BITS_UPPER_SHIFT  );
                         
    dwID    = ( dwID    & RENDER_ID_VALID_BITS_LOWER ) | 
              ( ( dwID    & RENDER_ID_VALID_BITS_UPPER ) >> 
                         RENDER_ID_VALID_BITS_UPPER_SHIFT );

    iTemp = (signed)( dwCurID - dwID );
    
    // Cope with the dodgy sign bits - sign extend the top n bits.
    iTemp <<= RENDER_ID_VALID_BITS_SIGN_SHIFT;
    iTemp >>= RENDER_ID_VALID_BITS_SIGN_SHIFT;
    
    // Some fairly arbitrary boundaries. If they are too small
    // for common use, just enlarge them a bit.
    // Generally, dwCurId can be well ahead of my_id (if the surface
    // hasn't been used for ages), but should not be too far behind,
    // because the pipe isn't _that_ big.
    if ( ( iTemp < RENDER_ID_LOWER_LIMIT ) || 
         ( iTemp > RENDER_ID_UPPER_LIMIT ) )
    {
        DISPDBG (( ERRLVL,"  ** Current chip ID 0x%x, surface ID, 0x%x", 
                     dwCurID, dwID ));
        DISPDBG ((ERRLVL,"** RENDER_ID_HAS_COMPLETED: Current render"
                    " ID is a long way out from surface's." ));
    }

    // We should never have a render ID newer 
    // than the current host render ID.
    dwCurHostID = GET_HOST_RENDER_ID();
    
    // Make sure the invalid bits have been zapped.
    ASSERTDD ( ( dwCurHostID | RENDER_ID_KNACKERED_BITS ) == dwCurHostID, 
              "** RENDER_ID_HAS_COMPLETED: Current host ID is invalid" );
              
    // Get a real contiguous number.
    dwCurHostID = ( dwCurHostID & RENDER_ID_VALID_BITS_LOWER ) | 
                  ( ( dwCurHostID & RENDER_ID_VALID_BITS_UPPER ) >> 
                                     RENDER_ID_VALID_BITS_UPPER_SHIFT );
                                     
    iTemp = (signed)( dwCurHostID - dwID );
    
    // Cope with the dodgy sign bits - sign extend the top n bits.
    iTemp <<= RENDER_ID_VALID_BITS_SIGN_SHIFT;
    iTemp >>= RENDER_ID_VALID_BITS_SIGN_SHIFT;
    
    if ( iTemp < 0 )
    {
        DISPDBG ((ERRLVL,"  ** Current host ID 0x%x, surface ID, 0x%x", 
                      dwCurHostID, dwID ));
                      
        // This may be caused by wrapping, of course.
        DISPDBG ((ERRLVL, "** RENDER_ID_HAS_COMPLETED: Surface's ID is "
                      "more recent than current host render ID." ));
    }

    return ( !RENDER_ID_LESS_THAN ( dwCurID, dwID ) );
    
} // HWC_bRenderIDHasCompleted

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\bitblt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: bitblt.c
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

/************************************************************************\
*
* decompose all rops into GLINT logic ops if the dest is the screen.
* Sometimes we do this in a few stages. The following defines mimic
* the definitions found in the ROP3 table in the books. The idea
* is to minimize errors in constructing the ropTable array below by
* allowing me to copy the reverse Polish notation more or less in
* tact.
*
\**************************************************************************/

#define unset   __GLINT_LOGICOP_CLEAR
#define P       __GLINT_LOGICOP_COPY
#define S       P
#define DPna    __GLINT_LOGICOP_AND_INVERTED
#define DSna    DPna
#define DPa     __GLINT_LOGICOP_AND
#define DSa     DPa
#define PDa     DPa
#define SDa     DPa
#define PDna    __GLINT_LOGICOP_AND_REVERSE
#define SDna    PDna
#define DPno    __GLINT_LOGICOP_OR_INVERT
#define DSno    DPno
#define DPo     __GLINT_LOGICOP_OR
#define DSo     DPo
#define PDo     DPo
#define SDo     DPo
#define PDno    __GLINT_LOGICOP_OR_REVERSE
#define SDno    PDno
#define D       __GLINT_LOGICOP_NOOP
#define Dn      __GLINT_LOGICOP_INVERT
#define Pn      __GLINT_LOGICOP_COPY_INVERT
#define Sn      Pn
#define DPan    __GLINT_LOGICOP_NAND
#define DSan    DPan
#define PDan    DPan
#define SDan    DPan
#define DPon    __GLINT_LOGICOP_NOR
#define DSon    DPon
#define PDon    DPon
#define SDon    DPon
#define DPxn    __GLINT_LOGICOP_EQUIV
#define DSxn    DPxn
#define PDxn    DPxn
#define SDxn    DPxn
#define DPx     __GLINT_LOGICOP_XOR
#define DSx     DPx
#define PDx     DPx
#define SDx     DPx
#define set     __GLINT_LOGICOP_SET

/************************************************************************\
*
* if we have to first combine the source and pattern before downloading
* to GLINT we use the engine to do it using EngBitBlt. So these are the
* chosen rop3s which combine the source with the pattern. We blt into
* a temporary bitmap and use this to download.
*
\**************************************************************************/

#define SPa     0x30
#define PSa     SPa
#define SPan    0x3F
#define PSan    SPan
#define SPna    0x0C
#define PSna    0x30

#define SPo     0xFC
#define PSo     SPo
#define SPon    0x03
#define PSon    SPon
#define SPno    0xCF
#define PSno    0xF3

#define SPx     0x3C
#define PSx     SPx
#define SPxn    0xC3
#define PSxn    SPxn
#define SPnx    SPxn
#define PSnx    SPxn

/************************************************************************\
*
* we set up a junp table for the different rop3's. Each entry contains
* a category and a set of 1, 2 or 3 GLINT logic ops. In the main blt
* routine we switch on the category to figure out what routine to call.
* We pass the GLINT logic op straight in without having to do any further
* conversion. By keeping each entry in the table down to 4 bytes it
* takes up 1K of data. That's not too much. The benefit is that in each
* routine we call we don't have to do any checking to see whether the
* rop really needs pattern or source. I've done some pre-processing on
* some of the rops to decompose them into forms which allow us to use
* the hardware in a series of steps. e.g. pattern fill followed by
* source download. If anything doesn't fit into a defined category then
* we go back to the engine.
*
\**************************************************************************/

// categories

#define SOLID_FILL_1_BLT    0       // must be 0
#define PAT_FILL_1_BLT      1       // must be 1

#define SRC_FILL_1_BLT      2       // must be 2

#define PAT_SRC_2_BLT       3       // PatSrcPatBlt
#define PAT_SRC_PAT_3_BLT   4       // PatSrcPatBlt

#define SRC_PAT_2_BLT       5       // SrcPatSrcBlt
#define SRC_PAT_SRC_3_BLT   6       // SrcPatSrcBlt

#define ENG_DOWNLOAD_2_BLT  7       // EngBitBlt for now
#define ENGINE_BITBLT       8       // EngBitBlt always

// adding new entries here may double the table size.

typedef struct _rop_table {
    UCHAR   func_index;
    UCHAR   logicop[3];
} RopTableRec, *RopTablePtr;

RopTableRec ropTable[] = {
/* 00 */    { SOLID_FILL_1_BLT, unset },
/* 01 */    { SRC_PAT_2_BLT, SDo, DPon, },                                 
/* 02 */    { SRC_PAT_2_BLT, DSna, DPna },
/* 03 */    { SRC_PAT_2_BLT, S, PDon, },
/* 04 */    { SRC_PAT_2_BLT, SDna, DPna, }, 
/* 05 */    { PAT_FILL_1_BLT, DPon, },
/* 06 */    { SRC_PAT_2_BLT, DSxn, PDon, },
/* 07 */    { SRC_PAT_2_BLT, DSa, PDon, },
/* 08 */    { SRC_PAT_2_BLT, DSa, DPna, },
/* 09 */    { SRC_PAT_2_BLT, DSx, PDon, },
/* 0A */    { PAT_FILL_1_BLT, DPna, },
/* 0B */    { SRC_PAT_2_BLT, SDna, PDon, },
/* 0C */    { SRC_PAT_2_BLT, S, DPna, },
/* 0D */    { SRC_PAT_2_BLT, DSna, PDon, },
/* 0E */    { SRC_PAT_2_BLT, DSon, PDon, },
/* 0F */    { PAT_FILL_1_BLT, Pn, },
/* 10 */    { SRC_PAT_2_BLT, DSon, PDa, },
/* 11 */    { SRC_FILL_1_BLT, DSon, },
/* 12 */    { PAT_SRC_2_BLT, DPxn, SDon, },
/* 13 */    { PAT_SRC_2_BLT, DPa, SDon, },
/* 14 */    { ENG_DOWNLOAD_2_BLT, PSx, SDno, },
/* 15 */    { ENG_DOWNLOAD_2_BLT, PSa, DSon, },
/* 16 */    { ENGINE_BITBLT, },
/* 17 */    { ENGINE_BITBLT, },
/* 18 */    { ENGINE_BITBLT, },
/* 19 */    { ENGINE_BITBLT, },
/* 1A */    { ENGINE_BITBLT, },
/* 1B */    { ENGINE_BITBLT, },
/* 1C */    { PAT_SRC_PAT_3_BLT, DPa, SDo, PDx,  },
/* 1D */    { ENGINE_BITBLT, },
/* 1E */    { SRC_PAT_2_BLT, DSo, PDx, },
/* 1F */    { SRC_PAT_2_BLT, DSo, PDan, },
/* 20 */    { SRC_PAT_2_BLT, DSna, PDa, },
/* 21 */    { PAT_SRC_2_BLT, DPx, SDon, },
/* 22 */    { SRC_FILL_1_BLT, DSna, },
/* 23 */    { PAT_SRC_2_BLT, PDna, SDon, },
/* 24 */    { ENGINE_BITBLT, },
/* 25 */    { ENGINE_BITBLT, },
/* 26 */    { ENGINE_BITBLT, },
/* 27 */    { ENGINE_BITBLT, },
/* 28 */    { ENG_DOWNLOAD_2_BLT, PSx, DSa, },
/* 29 */    { ENGINE_BITBLT, },
/* 2A */    { ENG_DOWNLOAD_2_BLT, PSa, DSna, },
/* 2B */    { ENGINE_BITBLT, },
/* 2C */    { SRC_PAT_SRC_3_BLT, DSo, PDa, SDx, },
/* 2D */    { SRC_PAT_2_BLT, SDno, PDx, },
/* 2E */    { PAT_SRC_PAT_3_BLT, DPx, SDo, PDx, },
/* 2F */    { SRC_PAT_2_BLT, SDno, PDan, },
/* 30 */    { SRC_PAT_2_BLT, S, PDna, },
/* 31 */    { PAT_SRC_2_BLT, DPna, SDon, },
/* 32 */    { SRC_PAT_SRC_3_BLT, SDo, PDo, SDx },
/* 33 */    { SRC_FILL_1_BLT, Sn, },
/* 34 */    { SRC_PAT_SRC_3_BLT, DSa, PDo, SDx, },
/* 35 */    { SRC_PAT_SRC_3_BLT, DSxn, PDo, SDx, },
/* 36 */    { PAT_SRC_2_BLT, DPo, SDx, },
/* 37 */    { PAT_SRC_2_BLT, DPo, SDan, },
/* 38 */    { PAT_SRC_PAT_3_BLT, DPo, SDa, PDx, },
/* 39 */    { PAT_SRC_2_BLT, PDno, SDx, },
/* 3A */    { SRC_PAT_SRC_3_BLT, DSx, PDo, SDx, },
/* 3B */    { PAT_SRC_2_BLT, PDno, SDan, },
/* 3C */    { SRC_PAT_2_BLT, S, PDx, },
/* 3D */    { SRC_PAT_SRC_3_BLT, DSon, PDo, SDx, },
/* 3E */    { SRC_PAT_SRC_3_BLT, DSna, PDo, SDx, },
/* 3F */    { SRC_PAT_2_BLT, S, PDan, },
/* 40 */    { SRC_PAT_2_BLT, SDna, PDa, },
/* 41 */    { ENG_DOWNLOAD_2_BLT, PSx, DSon, },
/* 42 */    { ENGINE_BITBLT, },
/* 43 */    { SRC_PAT_SRC_3_BLT, DSan, PDa, SDxn, },
/* 44 */    { SRC_FILL_1_BLT, SDna, },
/* 45 */    { ENG_DOWNLOAD_2_BLT, PSna, DSon, },
/* 46 */    { ENGINE_BITBLT, },
/* 47 */    { PAT_SRC_PAT_3_BLT, DPx, SDa, PDxn, },
/* 48 */    { PAT_SRC_2_BLT, DPx, SDa, },
/* 49 */    { ENGINE_BITBLT, },
/* 4A */    { ENGINE_BITBLT, },
/* 4B */    { SRC_PAT_2_BLT, DSno, PDx, },
/* 4C */    { PAT_SRC_2_BLT, DPan, SDa, },
/* 4D */    { ENGINE_BITBLT, },
/* 4E */    { ENGINE_BITBLT, },
/* 4F */    { SRC_PAT_2_BLT, DSno, PDan, },
/* 50 */    { PAT_FILL_1_BLT, PDna, },
/* 51 */    { ENG_DOWNLOAD_2_BLT, SPna, DSon, },
/* 52 */    { ENGINE_BITBLT, },
/* 53 */    { SRC_PAT_SRC_3_BLT, DSx, PDa, SDxn, },
/* 54 */    { ENG_DOWNLOAD_2_BLT, PSo, SDna, },
/* 55 */    { SOLID_FILL_1_BLT, Dn, },
/* 56 */    { ENG_DOWNLOAD_2_BLT, PSo, DSx, },
/* 57 */    { ENG_DOWNLOAD_2_BLT, PSo, DSan, },
/* 58 */    { ENGINE_BITBLT, },
/* 59 */    { ENG_DOWNLOAD_2_BLT, PSno, DSx, },
/* 5A */    { PAT_FILL_1_BLT, DPx, },
/* 5B */    { ENGINE_BITBLT, },
/* 5C */    { ENGINE_BITBLT, },
/* 5D */    { ENG_DOWNLOAD_2_BLT, PSno, DSan, },
/* 5E */    { ENGINE_BITBLT, },
/* 5F */    { PAT_FILL_1_BLT, DPan, },
/* 60 */    { SRC_PAT_2_BLT, DSx, PDa, },
/* 61 */    { ENGINE_BITBLT, },
/* 62 */    { ENGINE_BITBLT, },
/* 63 */    { PAT_SRC_2_BLT, DPno, SDx, },
/* 64 */    { ENGINE_BITBLT, },
/* 65 */    { ENG_DOWNLOAD_2_BLT, SPno, DSx, },
/* 66 */    { SRC_FILL_1_BLT, DSx, },
/* 67 */    { ENGINE_BITBLT, },
/* 68 */    { ENGINE_BITBLT, },
/* 69 */    { SRC_PAT_2_BLT, DSx, PDxn, },
/* 6A */    { ENG_DOWNLOAD_2_BLT, PSa, DSx, },
/* 6B */    { ENGINE_BITBLT, },
/* 6C */    { PAT_SRC_2_BLT, DPa, SDx, },
/* 6D */    { ENGINE_BITBLT, },
/* 6E */    { ENGINE_BITBLT, },
/* 6F */    { SRC_PAT_2_BLT, DSxn, PDan, },
/* 70 */    { SRC_PAT_2_BLT, DSan, PDa, },
/* 71 */    { ENGINE_BITBLT, },
/* 72 */    { ENGINE_BITBLT, },
/* 73 */    { PAT_SRC_2_BLT, DPno, SDan, },
/* 74 */    { ENGINE_BITBLT, },
/* 75 */    { ENG_DOWNLOAD_2_BLT, SPno, DSan, },
/* 76 */    { ENGINE_BITBLT, },
/* 77 */    { SRC_FILL_1_BLT, DSan, },
/* 78 */    { SRC_PAT_2_BLT, DSa, PDx, },
/* 79 */    { ENGINE_BITBLT, },
/* 7A */    { ENGINE_BITBLT, },
/* 7B */    { PAT_SRC_2_BLT, DPxn, SDan, },
/* 7C */    { SRC_PAT_SRC_3_BLT, DSno, PDa, SDx, },
/* 7D */    { ENG_DOWNLOAD_2_BLT, PSxn, DSan, },
/* 7E */    { ENGINE_BITBLT, },
/* 7F */    { ENG_DOWNLOAD_2_BLT, PSa, DSan, },
/* 80 */    { ENG_DOWNLOAD_2_BLT, PSa, DSa, },
/* 81 */    { ENGINE_BITBLT, },
/* 82 */    { ENG_DOWNLOAD_2_BLT, PSx, DSna, },
/* 83 */    { SRC_PAT_SRC_3_BLT, DSno, PDa, SDxn, },
/* 84 */    { PAT_SRC_2_BLT, DPxn, SDa, },
/* 85 */    { ENGINE_BITBLT, },
/* 86 */    { ENGINE_BITBLT, },
/* 87 */    { SRC_PAT_2_BLT, DSa, PDxn, },
/* 88 */    { SRC_FILL_1_BLT, DSa, },
/* 89 */    { ENGINE_BITBLT, },
/* 8A */    { ENG_DOWNLOAD_2_BLT, SPno, DSa, },
/* 8B */    { ENGINE_BITBLT, },
/* 8C */    { PAT_SRC_2_BLT, DPno, SDa, },
/* 8D */    { ENGINE_BITBLT, },
/* 8E */    { ENGINE_BITBLT, },
/* 8F */    { SRC_PAT_2_BLT, DSan, PDan, },
/* 90 */    { SRC_PAT_2_BLT, DSxn, PDa, },
/* 91 */    { ENGINE_BITBLT, },
/* 92 */    { ENGINE_BITBLT, },
/* 93 */    { PAT_SRC_2_BLT, PDa, SDxn, },
/* 94 */    { ENGINE_BITBLT, },
/* 95 */    { ENG_DOWNLOAD_2_BLT, PSa, DSxn, },
/* 96 */    { SRC_PAT_2_BLT, DSx, PDx, },       /* DPSxx == PDSxx */
/* 97 */    { ENGINE_BITBLT, },
/* 98 */    { ENGINE_BITBLT, },
/* 99 */    { SRC_FILL_1_BLT, DSxn, },
/* 9A */    { ENG_DOWNLOAD_2_BLT, PSna, DSx, },
/* 9B */    { ENGINE_BITBLT, },
/* 9C */    { PAT_SRC_2_BLT, PDna, SDx, },
/* 9D */    { ENGINE_BITBLT, },
/* 9E */    { ENGINE_BITBLT, },
/* 9F */    { SRC_PAT_2_BLT, DSx, PDan, },
/* A0 */    { PAT_FILL_1_BLT, DPa, },
/* A1 */    { ENGINE_BITBLT, },
/* A2 */    { ENG_DOWNLOAD_2_BLT, PSno, DSa, },
/* A3 */    { ENGINE_BITBLT, },
/* A4 */    { ENGINE_BITBLT, },
/* A5 */    { PAT_FILL_1_BLT, PDxn, },
/* A6 */    { ENG_DOWNLOAD_2_BLT, SPna, DSx, },
/* A7 */    { ENGINE_BITBLT, },
/* A8 */    { ENG_DOWNLOAD_2_BLT, PSo, DSa, },
/* A9 */    { ENG_DOWNLOAD_2_BLT, PSo, DSxn, },
/* AA */    { SOLID_FILL_1_BLT, D },
/* AB */    { ENG_DOWNLOAD_2_BLT, PSo, DSno, },
/* AC */    { SRC_PAT_SRC_3_BLT, DSx, PDa, SDx, },
/* AD */    { ENGINE_BITBLT, },
/* AE */    { ENG_DOWNLOAD_2_BLT, SPna, DSo, },
/* AF */    { PAT_FILL_1_BLT, DPno, },
/* B0 */    { SRC_PAT_2_BLT, DSno, PDa, },
/* B1 */    { ENGINE_BITBLT, },
/* B2 */    { ENGINE_BITBLT, },
/* B3 */    { PAT_SRC_2_BLT, DPan, SDan, },
/* B4 */    { SRC_PAT_2_BLT, SDna, PDx, },
/* B5 */    { ENGINE_BITBLT, },
/* B6 */    { ENGINE_BITBLT, },
/* B7 */    { PAT_SRC_2_BLT, DPx, SDan, },
/* B8 */    { PAT_SRC_PAT_3_BLT, DPx, SDa, PDx, },
/* B9 */    { ENGINE_BITBLT, },
/* BA */    { ENG_DOWNLOAD_2_BLT, PSna, DSo, },
/* BB */    { SRC_FILL_1_BLT, DSno, },
/* BC */    { SRC_PAT_SRC_3_BLT, DSan, PDa, SDx, },
/* BD */    { ENGINE_BITBLT, },
/* BE */    { ENG_DOWNLOAD_2_BLT, PSx, DSo, },
/* BF */    { ENG_DOWNLOAD_2_BLT, PSa, DSno, },
/* C0 */    { SRC_PAT_2_BLT, S, PDa, },
/* C1 */    { ENGINE_BITBLT, },
/* C2 */    { ENGINE_BITBLT, },
/* C3 */    { SRC_PAT_2_BLT, S, PDxn, },
/* C4 */    { PAT_SRC_2_BLT, PDno, SDa, },
/* C5 */    { SRC_PAT_SRC_3_BLT, DSx, PDo, SDxn, },
/* C6 */    { PAT_SRC_2_BLT, DPna, SDx, },
/* C7 */    { PAT_SRC_PAT_3_BLT, DPo, SDa, PDxn, },
/* C8 */    { PAT_SRC_2_BLT, DPo, SDa, },
/* C9 */    { PAT_SRC_2_BLT, PDo, SDxn, },
/* CA */    { ENGINE_BITBLT, },
/* CB */    { SRC_PAT_SRC_3_BLT, DSa, PDo, SDxn, },
/* CC */    { SRC_FILL_1_BLT, S, },
/* CD */    { PAT_SRC_2_BLT, DPon, SDo, },
/* CE */    { PAT_SRC_2_BLT, DPna, SDo, },
/* CF */    { SRC_PAT_2_BLT, S, DPno, },
/* D0 */    { SRC_PAT_2_BLT, SDno, PDa, },
/* D1 */    { PAT_SRC_PAT_3_BLT, DPx, SDo, PDxn, },
/* D2 */    { SRC_PAT_2_BLT, DSna, PDx, },
/* D3 */    { SRC_PAT_SRC_3_BLT, DSo, PDa, SDxn, },
/* D4 */    { ENGINE_BITBLT, },
/* D5 */    { ENG_DOWNLOAD_2_BLT, PSan, DSan, },
/* D6 */    { ENGINE_BITBLT, },
/* D7 */    { ENG_DOWNLOAD_2_BLT, PSx, DSan, },
/* D8 */    { ENGINE_BITBLT, },
/* D9 */    { ENGINE_BITBLT, },
/* DA */    { ENGINE_BITBLT, },
/* DB */    { ENGINE_BITBLT, },
/* DC */    { PAT_SRC_2_BLT, PDna, SDo, },
/* DD */    { SRC_FILL_1_BLT, SDno, },
/* DE */    { PAT_SRC_2_BLT, DPx, SDo, },
/* DF */    { ENG_DOWNLOAD_2_BLT, DPan, SDo, },
/* E0 */    { SRC_PAT_2_BLT, DSo, PDa, },
/* E1 */    { SRC_PAT_2_BLT, DSo, PDxn, },
/* E2 */    { ENGINE_BITBLT, },     /* DSPDxax : XXX S3 special cases this */
/* E3 */    { PAT_SRC_PAT_3_BLT, DPa, SDo, PDxn, },
/* E4 */    { ENGINE_BITBLT, },
/* E5 */    { ENGINE_BITBLT, },
/* E6 */    { ENGINE_BITBLT, },
/* E7 */    { ENGINE_BITBLT, },
/* E8 */    { ENGINE_BITBLT, },
/* E9 */    { ENGINE_BITBLT, },
/* EA */    { ENG_DOWNLOAD_2_BLT, PSa, DSo, },
/* EB */    { ENG_DOWNLOAD_2_BLT, PSx, DSno, },
/* EC */    { PAT_SRC_2_BLT, DPa, SDo, },
/* ED */    { PAT_SRC_2_BLT, DPxn, SDo, },
/* EE */    { SRC_FILL_1_BLT, DSo, },
/* EF */    { SRC_PAT_2_BLT, SDo, DPno },
/* F0 */    { PAT_FILL_1_BLT, P, },
/* F1 */    { SRC_PAT_2_BLT, DSon, PDo, },
/* F2 */    { SRC_PAT_2_BLT, DSna, PDo, },
/* F3 */    { SRC_PAT_2_BLT, S, PDno, },
/* F4 */    { SRC_PAT_2_BLT, SDna, PDo, },
/* F5 */    { PAT_FILL_1_BLT, PDno, },
/* F6 */    { SRC_PAT_2_BLT, DSx, PDo, },
/* F7 */    { SRC_PAT_2_BLT, DSan, PDo, },
/* F8 */    { SRC_PAT_2_BLT, DSa, PDo, },
/* F9 */    { SRC_PAT_2_BLT, DSxn, PDo, },
/* FA */    { PAT_FILL_1_BLT, DPo, },
/* FB */    { SRC_PAT_2_BLT, DSno, PDo, },
/* FC */    { SRC_PAT_2_BLT, S, PDo, },
/* FD */    { SRC_PAT_2_BLT, SDno, PDo, },
/* FE */    { ENG_DOWNLOAD_2_BLT, PSo, DSo, },
/* FF */    { SOLID_FILL_1_BLT, set, },
};

// table to determine which logicops need read dest turned on in FBReadMode

DWORD   LogicopReadDest[] = {
    0,                                                  /* 00 */
    __FB_READ_DESTINATION,                              /* 01 */
    __FB_READ_DESTINATION,                              /* 02 */
    0,                                                  /* 03 */
    __FB_READ_DESTINATION,                              /* 04 */
    __FB_READ_DESTINATION,                              /* 05 */
    __FB_READ_DESTINATION,                              /* 06 */
    __FB_READ_DESTINATION,                              /* 07 */
    __FB_READ_DESTINATION,                              /* 08 */
    __FB_READ_DESTINATION,                              /* 09 */
    __FB_READ_DESTINATION,                              /* 10 */
    __FB_READ_DESTINATION,                              /* 11 */
    0,                                                  /* 12 */
    __FB_READ_DESTINATION,                              /* 13 */
    __FB_READ_DESTINATION,                              /* 14 */
    0,                                                  /* 15 */
};

// translate a ROP2 into a GLINT logicop. Note, ROP2's start at 1 so
// entry 0 is not used.

DWORD GlintLogicOpsFromR2[] = {
    0,                                  /* rop2's start at 1 */
    __GLINT_LOGICOP_CLEAR,              /*  0      1 */
    __GLINT_LOGICOP_NOR,                /* DPon    2 */
    __GLINT_LOGICOP_AND_INVERTED,       /* DPna    3 */
    __GLINT_LOGICOP_COPY_INVERT,        /* Pn      4 */
    __GLINT_LOGICOP_AND_REVERSE,        /* PDna    5 */
    __GLINT_LOGICOP_INVERT,             /* Dn      6 */
    __GLINT_LOGICOP_XOR,                /* DPx     7 */
    __GLINT_LOGICOP_NAND,               /* DPan    8 */
    __GLINT_LOGICOP_AND,                /* DPa     9 */
    __GLINT_LOGICOP_EQUIV,              /* DPxn    10 */
    __GLINT_LOGICOP_NOOP,               /* D       11 */
    __GLINT_LOGICOP_OR_INVERT,          /* DPno    12 */
    __GLINT_LOGICOP_COPY,               /* P       13 */
    __GLINT_LOGICOP_OR_REVERSE,         /* PDno    14 */
    __GLINT_LOGICOP_OR,                 /* DPo     15 */
    __GLINT_LOGICOP_SET,                /*  1      16 */
};

BOOL
PatternFillRect(PPDEV, RECTL *, CLIPOBJ *, BRUSHOBJ *,
                POINTL *, ULONG, ULONG);

BOOL
SourceFillRect(PPDEV, RECTL *, CLIPOBJ *, SURFOBJ *, XLATEOBJ *,
               POINTL *, ULONG, ULONG);

BOOL
PatSrcPatBlt(PPDEV, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*,
             POINTL*, BRUSHOBJ*, POINTL*, RopTablePtr);

BOOL
SrcPatSrcBlt(PPDEV, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*,
             POINTL*, BRUSHOBJ*, POINTL*, RopTablePtr);

BOOL
MaskCopyBlt(PPDEV, RECTL*, CLIPOBJ*, SURFOBJ*, SURFOBJ*, POINTL*,
            POINTL*, ULONG, ULONG);

BOOL
bUploadRect(PPDEV, CLIPOBJ *, SURFOBJ *, SURFOBJ *, POINTL *, RECTL *);

BOOL bUploadBlt(
    PPDEV,
    SURFOBJ *,
    SURFOBJ *,
    SURFOBJ *,
    CLIPOBJ  *,
    XLATEOBJ *,
    RECTL *,
    POINTL *,
    POINTL *,
    BRUSHOBJ *,
    POINTL *,
    ROP4);

#if defined(_X86_) 
// Mono upload functions
BOOL DoScreenToMono(
    PDEV*       ppdev, 
    RECTL       *prclDst,
    CLIPOBJ     *pco,
    SURFOBJ*    psoSrc,             // Source surface 
    SURFOBJ*    psoDst,             // Destination surface 
    POINTL*     pptlSrc,            // Original unclipped source point 
    XLATEOBJ*   pxlo);               // Provides colour-compressions information 

VOID vXferScreenTo1bpp(
    PDEV*       ppdev, 
    LONG        c,                  // Count of rectangles, can't be zero 
    RECTL*      prcl,               // List of destination rectangles, in 
                                    //   relative coordinates 
    ULONG       ulHwMix,            // Not used 
    SURFOBJ*    psoSrc,             // Source surface 
    SURFOBJ*    psoDst,             // Destination surface 
    POINTL*     pptlSrc,            // Original unclipped source point 
    RECTL*      prclDst,            // Original unclipped destination rectangle 
    XLATEOBJ*   pxlo);               // Provides colour-compressions information 
#endif  // defined(_X86_) 

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vGlintChangeFBDepth
*
* Change the GLINT packing mode for different depths. We use this to speed
* up rendering for 8 and 16 bpp where we can process up to 4 pixels at a
* time.
*
\**************************************************************************/

VOID vGlintChangeFBDepth(
PPDEV   ppdev,
ULONG   cPelSize)
{
    ULONG cFlags;
    GLINT_DECL;

    DISPDBG((DBGLVL, "setting current pixel depth to %d",
            (cPelSize == 0) ? 8 : (cPelSize == 1) ? 16 : 32));
            
    glintInfo->FBReadMode = glintInfo->packing[cPelSize].readMode;
    glintInfo->currentPelSize = cPelSize;
    
    // Toggle the FBReadMode cache flag
    DISPDBG((DBGLVL, "setting FBReadMode to 0x%08x", glintInfo->FBReadMode));
    cFlags = CHECK_CACHEFLAGS (ppdev, 0xFFFFFFFF);
    SET_CACHEFLAGS (ppdev, (cFlags & ~cFlagFBReadDefault));

    // set FX pixel depth 
    // 0 - 8 bits, 1 - 16 bits and 2 - 32 bits.
    DISPDBG((DBGLVL, "Changing FBDepth for PERMEDIA"));
    WAIT_GLINT_FIFO(1);
    LD_GLINT_FIFO(__PermediaTagFBReadPixel, cPelSize);
}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMsk,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMsk,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4     rop4)

{
    BOOL        bRet;
    PPDEV       ppdev;
    DSURF       *pdsurfDst;
    DSURF       *pdsurfSrc;
    UCHAR       funcIndexFore;
    UCHAR       funcIndexBack;
    XLATECOLORS xlc;
    XLATEOBJ    xlo;
    RopTablePtr pTableFore;
    RopTablePtr pTableBack;
    HSURF       hsurfSrcBitmap, hsurfDstBitmap;
    SURFOBJ     *psoSrcBitmap, *psoDstBitmap;
    SURFOBJ     *psoSrcOrig = psoSrc, *psoDstOrig = psoDst;
    GLINT_DECL_VARS;

    // We need to remove the pointer, but we dont know which surface is valid
    // (if either). 

    if ((psoDst->iType != STYPE_BITMAP) && 
        (((DSURF *)(psoDst->dhsurf))->dt & DT_SCREEN))
    {
        ppdev = (PDEV *)psoDst->dhpdev;
        REMOVE_SWPOINTER(psoDst);
    }
    else if (psoSrc && 
             (psoSrc->iType != STYPE_BITMAP) && 
             (((DSURF *)(psoSrc->dhsurf))->dt & DT_SCREEN))
    {
        ppdev = (PDEV *)psoSrc->dhpdev;
        REMOVE_SWPOINTER(psoSrc);
    }

    // GDI will never give us a Rop4 with the bits in the high-word set
    // (so that we can check if it's actually a Rop3 via the expression
    // (rop4 >> 8) == (rop4 & 0xff))

    ASSERTDD((rop4 >> 16) == 0, "Didn't expect a rop4 with high bits set");

#if !defined(_WIN64) && WNT_DDRAW
    // Touch the source surface 1st and then the destination surface

    vSurfUsed(psoSrc);
    vSurfUsed(psoDst);
#endif

    pdsurfDst = (DSURF *)psoDst->dhsurf;

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt & DT_SCREEN)
        {
            OH*             poh;
            BOOL            bMore;
            CLIPENUM        ce;
            LONG            c;
            RECTL           rcl;
            BYTE            rop3;
            GFNFILL*        pfnFill;
            RBRUSH_COLOR    rbc;        // Realized brush or solid colour
            DWORD           fgLogicop;
            DWORD           bgLogicop;

            ppdev = (PDEV*) psoDst->dhpdev;
            GLINT_DECL_INIT;

            poh = pdsurfDst->poh;

            SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

            VALIDATE_DD_CONTEXT;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

                pfnFill = ppdev->pgfnFillSolid;   // Default to solid fill

                pTableFore = &ropTable[rop4 & 0xff];
                pTableBack = &ropTable[rop4 >> 8];
                fgLogicop = pTableFore->logicop[0];

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)
                {
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):

                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                DISPDBG((WRNLVL, "DrvBitBlt: BRUSHOBJ_pvGetRbrush"
                                                 "failed.calling engine_blt"));
                                GLINT_DECL_INIT;
                                goto engine_blt;
                            }
                        }

                        if (rbc.prb->fl & RBRUSH_2COLOR)
                        {
                            DISPDBG((DBGLVL, "monochrome brush"));
                            pfnFill = ppdev->pgfnFillPatMono;
                        }
                        else
                        {
                            DISPDBG((DBGLVL, "colored brush"));
                            pfnFill = ppdev->pgfnFillPatColor;
                        }

                        bgLogicop = pTableBack->logicop[0];
                    }
                }
                else
                {
                    // Turn some logicops into solid block fills. We get here
                    // only for rops 0, 55, AA and FF.

                    if ((fgLogicop == __GLINT_LOGICOP_SET) ||
                        (fgLogicop == __GLINT_LOGICOP_CLEAR))
                    {
                        rbc.iSolidColor = 0xffffff;    // does any depth
                        if (fgLogicop == __GLINT_LOGICOP_CLEAR)
                        {
                            rbc.iSolidColor = 0;
                        }
                        fgLogicop = __GLINT_LOGICOP_COPY;
                    }
                    else if (fgLogicop == __GLINT_LOGICOP_NOOP)
                    {
                        return(TRUE);   // DST logicop is a noop
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    pfnFill(ppdev, 1, prclDst, fgLogicop, bgLogicop, 
                                rbc, pptlBrush);
                    return TRUE;
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                    {
                        pfnFill(ppdev, 1, &rcl, fgLogicop, bgLogicop, 
                                    rbc, pptlBrush);
                    }
                    return TRUE;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                        {
                            pfnFill(ppdev, c, ce.arcl, fgLogicop, bgLogicop, 
                                        rbc, pptlBrush);
                        }
                    } while (bMore);
                    return TRUE;
                }
            }
        }
    }
    
#if defined(_X86_) 
    if ((pxlo != NULL) &&
        (pxlo->flXlate & XO_TO_MONO) &&
        (psoSrc != NULL) && (pptlSrc != NULL) &&
        (psoDst != NULL) && (psoDst->dhsurf == NULL) &&
        (psoDst->iBitmapFormat == BMF_1BPP))
    {
        BYTE rop3 = (BYTE) rop4;     // Make rop4 into a Rop3 

        ppdev     = (PDEV*)  psoSrc->dhpdev; 
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;

        GLINT_DECL_INIT;
        VALIDATE_DD_CONTEXT;

        if ((ppdev->iBitmapFormat != BMF_24BPP) &&
            (((rop4 >> 8) & 0xff) == (rop4 & 0xff)) &&
            (psoSrc->iType != STYPE_BITMAP) &&
            (pdsurfSrc->dt & DT_SCREEN) &&
            (rop3 == 0xcc))
        { 
            // We special case screen to monochrome blts because they 
            // happen fairly often.  We only handle SRCCOPY rops and 
            // monochrome destinations (to handle a true 1bpp DIB 
            // destination, we would have to do near-colour searches 
            // on every colour; as it is, the foreground colour gets 
            // mapped to '1', and everything else gets mapped to '0'): 

            SETUP_PPDEV_OFFSETS(ppdev, pdsurfSrc);

            ASSERTDD (pdsurfSrc->poh->cy >= psoSrc->sizlBitmap.cy || 
                       pdsurfSrc->poh->cx >= psoSrc->sizlBitmap.cx, 
                       "DrvBitBlt: Got a BAD screen-to-mono size");

            DISPDBG((DBGLVL, "DrvBitBlt: Screen-to-mono, size poh(%d,%d)",
                            pdsurfSrc->poh->cx, pdsurfSrc->poh->cy));
                            
            if (DoScreenToMono (ppdev, prclDst, pco, psoSrc, 
                                    psoDst, pptlSrc, pxlo))
                return (TRUE); 
        } 
    }
#endif //   defined(_X86_) 

    // pdsurfDst is valid only if iType != BITMAP so be careful with the ordering
    //
    if ((psoDst->iType == STYPE_BITMAP) || ((pdsurfDst->dt & DT_SCREEN) == 0))
    {
        // Destination is either a bitmap or an ex offscreen bitmap
        DISPDBG((DBGLVL, "dst is a bitmap or a DIB"));
        if (psoSrc)
        {
            DISPDBG((DBGLVL, "we have a src"));
            pdsurfSrc = (DSURF *)psoSrc->dhsurf;
            if ((psoSrc->iType != STYPE_BITMAP) && 
                (pdsurfSrc->dt & DT_SCREEN))
            {
                ppdev = (PPDEV)psoSrc->dhpdev;
                GLINT_DECL_INIT;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfSrc);

                // if we are ex offscreen, get the DIB pointer.
                if (psoDst->iType != STYPE_BITMAP)
                {
                    psoDst = pdsurfDst->pso;
                }
            
                VALIDATE_DD_CONTEXT;

                DISPDBG((DBGLVL, "uploading from the screen"));

                if (bUploadBlt(ppdev, psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                                pptlSrc, pptlMsk, pbo, pptlBrush, rop4))
                {
                    return (TRUE);
                }

                // If for some reason the upload failed go and do it.    

                DISPDBG((WRNLVL, "DrvBitBlt: bUploadBlt "
                                 "failed.calling engine_blt"));
                goto engine_blt;
            }
        }

        DISPDBG((DBGLVL, "falling through to engine_blt"));

        if (psoDst->iType != STYPE_BITMAP)
        {
            // Destination is an Ex Offscreen Bitmap
            ppdev = (PPDEV)psoDst->dhpdev;
            GLINT_DECL_INIT;
            DISPDBG((DBGLVL, "DrvBitBlt: ex offscreen "
                             "bitmap.calling engine_blt"));
            goto engine_blt;
        }
        else
        {
            // Destination is a Memory Bitmap. We shouldnt ever get here.
            DISPDBG((DBGLVL, "DrvBitBlt: memory bitmap!!."
                             "calling simple_engine_blt"));
            goto simple_engine_blt;
        }
    }

    ppdev = (PPDEV)psoDst->dhpdev;
    GLINT_DECL_INIT;
    VALIDATE_DD_CONTEXT;

    SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

    // pick out the rop table entries for the foreground and background mixes.
    // if we get the same entry for both then we have a rop3.
    //
    pTableFore = &ropTable[rop4 & 0xff];
    pTableBack = &ropTable[rop4 >> 8];
    funcIndexFore = pTableFore->func_index;
    
    // handle rop3 pattern fills where no source is needed
    //
    if ((psoSrc == NULL) && (pTableFore == pTableBack))
    {
        // really a rop3. no mask required

        // solid or pattern fills
        if (funcIndexFore <= PAT_FILL_1_BLT)
        {
            BRUSHOBJ    tmpBrush;
            BRUSHOBJ    *pboTmp;
            ULONG       logicop;

            pboTmp  = pbo;
            logicop = pTableFore->logicop[0];

            // handle the 4 logicops that don't use src or pattern by turning
            // them into optimized solid fills.
            //
            if (funcIndexFore == SOLID_FILL_1_BLT)
            {                
                if ((logicop == __GLINT_LOGICOP_SET) ||
                    (logicop == __GLINT_LOGICOP_CLEAR))
                {
                    // as solid fills we can make use of hardware block fills
                    tmpBrush.iSolidColor = 0xffffff;    // does any depth
                    if (logicop == __GLINT_LOGICOP_CLEAR)
                    {
                        tmpBrush.iSolidColor = 0;
                    }
                    logicop = __GLINT_LOGICOP_COPY;
                    pboTmp  = &tmpBrush;
                }
                else if (logicop == __GLINT_LOGICOP_INVERT)
                {
                    pboTmp = NULL;  // forces a solid fill
                }
                else
                {
                    return(TRUE);   // DST logicop is a noop
                }
            }

            // as fills are performance critical it may be wise to make this
            // code inline as in the sample driver. But for the moment, I'll
            // leave it as a function call.
            //
            if (PatternFillRect(ppdev, prclDst, pco, pboTmp, pptlBrush,
                                                        logicop, logicop))
            {
                return(TRUE);
            }
            
            DISPDBG((DBGLVL, "DrvBitBlt: PatternFillRect "
                             "failed.calling engine_blt"));
            goto engine_blt;
        }
    }

    // this code is important in that it resets psoSrc to be a real DIB surface
    // if src is a DFB converted to a DIB. SourceFillRect() depends on this
    // having been done.
    //
    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVBITMAP))
    {
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;
        if (pdsurfSrc->dt & DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))                            
                        {
                            goto Continue_It;
                        }
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            // pick out the DIB surface that we defined for the DFB when it
            // was created (as our VRAM is linear we always have this).
            //
            psoSrc = pdsurfSrc->pso;
        }
    }

Continue_It:

    // we are now interested in rop3s involving a source
    //
    if (pTableFore == pTableBack)
    {
        if (funcIndexFore == SRC_FILL_1_BLT)
        {
            if (SourceFillRect(ppdev, prclDst, pco, psoSrc, pxlo,
                    pptlSrc, pTableFore->logicop[0], pTableFore->logicop[0]))
            {
                return(TRUE);
            }

            DISPDBG((DBGLVL, "DrvBitBlt: SourceFillRect"
                             " failed.calling engine_blt"));
            goto engine_blt;
        }

        // handle miscellaneous other rop3s. Most of these are done in
        // multiple passes of the hardware.
        //
        switch (funcIndexFore)
        {
            case PAT_SRC_2_BLT:
            case PAT_SRC_PAT_3_BLT:

                DISPDBG((DBGLVL, "PAT_SRC_PAT_BLT, rop 0x%x", 
                                 pTableFore - ropTable));
                                 
                if (PatSrcPatBlt(ppdev, psoSrc, pco, pxlo, prclDst,pptlSrc,
                                                  pbo, pptlBrush, pTableFore))
                {
                    return(TRUE);
                }
                break;

            case SRC_PAT_2_BLT:
            case SRC_PAT_SRC_3_BLT:

                DISPDBG((DBGLVL, "SRC_PAT_SRC_BLT, rop 0x%x", 
                                 pTableFore - ropTable));
                            
                if (SrcPatSrcBlt(ppdev, psoSrc, pco, pxlo, prclDst,pptlSrc,
                                                  pbo, pptlBrush, pTableFore))
                {
                    return(TRUE);
                }
                break;

            case ENG_DOWNLOAD_2_BLT:

                DISPDBG((DBGLVL, "ENG_DOWNLOAD_2_BLT, rop 0x%x", 
                                 pTableFore - ropTable));
                break;

            case ENGINE_BITBLT:

                DISPDBG((DBGLVL, "ENGINE_BITBLT, rop 0x%x", 
                                 pTableFore - ropTable));
                break;

            default:
                break;

        }
        DISPDBG((WRNLVL, "DrvBitBlt: Unhandled rop3.calling engine_blt"));
        goto engine_blt;
    }

    // ROP4
    // we get here if the mix is a true rop4.
    // unlike the above we only handle a few well chosen rop4s.
    // do later.

    DISPDBG((DBGLVL, "got a true rop4 0x%x", rop4));

    funcIndexBack = pTableBack->func_index;
    if (psoMsk != NULL)
    {
        // At this point, we've made sure that we have a true ROP4.
        // This is important because we're about to dereference the
        // mask.  I'll assert to make sure that I haven't inadvertently
        // broken the logic for this:

        ASSERTDD((rop4 & 0xff) != (rop4 >> 8), "This handles true ROP4's only");

        ///////////////////////////////////////////////////////////////////
        // True ROP4's
        ///////////////////////////////////////////////////////////////////

        // Handle ROP4 where no source is required for either Rop3:
        // In this case we handle it by using the mask as a 1bpp
        // source image and we download it. The foreground and
        // background colors are taken from a solid brush.

        if ((funcIndexFore | funcIndexBack) <= PAT_FILL_1_BLT)
        {
            if ((funcIndexFore | funcIndexBack) == PAT_FILL_1_BLT)
            {
                // Fake up a 1bpp XLATEOBJ (note that we should only
                // dereference 'pbo' when it's required by the mix):

                xlc.iForeColor = pbo->iSolidColor;
                xlc.iBackColor = xlc.iForeColor;

                if (xlc.iForeColor == -1)
                {
                    DISPDBG((WRNLVL, "1bpp fake xlate rejected"
                                     " as brush not solid"));
                    goto engine_blt;       // We don't handle non-solid brushes
                }
            }

            // Note that when neither the foreground nor the background mix
            // requires a source, the colours in 'xlc' are allowed to be
            // garbage.

            xlo.pulXlate = (ULONG*) &xlc;
            pxlo         = &xlo;
            psoSrc       = psoMsk;
            pptlSrc      = pptlMsk;

            DISPDBG((DBGLVL, "calling SourceFillRect for rop4 (fg %d, bg %d)",
                            pTableFore->logicop[0], pTableBack->logicop[0]));
                            
            if (SourceFillRect(ppdev, prclDst, pco, psoSrc, pxlo,
                    pptlSrc, pTableFore->logicop[0], pTableBack->logicop[0]))
            {
                return(TRUE);
            }

            DISPDBG((WRNLVL, "DrvBitBlt: SourceFillRect (2) "
                             "failed.calling engine_blt"));
            goto engine_blt;
        }                                    // No pattern required
        else if ((funcIndexFore | funcIndexBack) == SRC_FILL_1_BLT) 
        {
            // We're about to dereference 'psoSrc' and 'pptlSrc' --
            // since we already handled the case where neither ROP3
            // required the source, the ROP4 must require a source,
            // so we're safe.

            ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                     "No source case should already have been handled!");

            // The operation has to be screen-to-screen, and the rectangles
            // cannot overlap:

            if ((psoSrc->iType != STYPE_BITMAP)                  &&
                (psoDst->iType != STYPE_BITMAP)                  &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                !OVERLAP(prclDst, pptlSrc))
            {
                DISPDBG((DBGLVL, "calling MskCopyBlt for rop 4 (fg %d, bg %d)",
                            pTableFore->logicop[0], pTableBack->logicop[0]));
//@@BEGIN_DDKSPLIT
                // TMM: 060897: Removed this for WHQL tests
                //if (MaskCopyBlt(ppdev, prclDst, pco, psoSrc, psoMsk,
                //            pptlSrc, pptlMsk,
                //            pTableFore->logicop[0],
                //            pTableBack->logicop[0]))
                //    return(TRUE);
//@@END_DDKSPLIT

                DISPDBG((WRNLVL, "DrvBitBlt: MaskCopyBlt "
                                 "failed.calling engine_blt"));
                goto engine_blt;
            }
        }
        DISPDBG((DBGLVL, "rejected rop4 0x%x with mask", rop4));
    }
    else if ((pTableBack->logicop[0] == __GLINT_LOGICOP_NOOP) &&
             (funcIndexFore <= PAT_FILL_1_BLT))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP).

        DISPDBG((DBGLVL, "calling PatternFillRect for rop4 (fg %d, bg %d)",
                            pTableFore->logicop[0], pTableBack->logicop[0]));
        if (PatternFillRect(ppdev, prclDst, pco, pbo, pptlBrush,
                            pTableFore->logicop[0], pTableBack->logicop[0]))
        {
            return(TRUE);
        }

        // fall through to engine_blt ...
    }

    DISPDBG((DBGLVL, "fell through to engine_blt"));

engine_blt:

    if (glintInfo->GdiCantAccessFramebuffer)
    {
        // We require the original pointers to decide if we are talking to
        // the screen or not.

        psoSrc = psoSrcOrig;
        psoDst = psoDstOrig;
        hsurfSrcBitmap = (HSURF)NULL;
        hsurfDstBitmap = (HSURF)NULL;
        psoSrcBitmap = (SURFOBJ*)NULL;
        psoDstBitmap = (SURFOBJ*)NULL;

        // if source is the screen then pick out the bitmap surface
        if (psoSrc && (psoSrc->iType != STYPE_BITMAP))
        {    
            ppdev = (PPDEV)psoSrc->dhpdev;
            pdsurfSrc = (DSURF *)psoSrc->dhsurf;
            psoSrc = pdsurfSrc->pso;

            if (pdsurfSrc->dt & DT_SCREEN)
            {
                RECTL    rclTmp;

                DISPDBG((DBGLVL, "Replacing src screen with bitmap Uploading"));

                // We need to upload the area from the screen and use bitmaps
                // to perform the operation

                hsurfSrcBitmap = (HSURF) EngCreateBitmap(psoSrc->sizlBitmap, 0, 
                                                psoSrc->iBitmapFormat, 0, NULL);
                if (hsurfSrcBitmap == NULL)
                {
                    goto drvBitBltFailed;
                }

                if ((psoSrcBitmap = EngLockSurface(hsurfSrcBitmap)) == NULL)
                {
                    goto drvBitBltFailed;
                }

                rclTmp.left   = pptlSrc->x;
                rclTmp.right  = pptlSrc->x + prclDst->right  - prclDst->left;
                rclTmp.top    = pptlSrc->y;
                rclTmp.bottom = pptlSrc->y + prclDst->bottom - prclDst->top;

                GLINT_DECL_INIT;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfSrc);

                VALIDATE_DD_CONTEXT;

                // Call our function to perform image upload to tmp surface
                if (!bUploadRect(ppdev, NULL, psoSrc, psoSrcBitmap, 
                                    pptlSrc, &rclTmp))
                {
                    goto drvBitBltFailed;
                }

                psoSrc = psoSrcBitmap;
            }
        }

        // if target is on screen then pick out the screen DIB surface

        if (psoDst->iType != STYPE_BITMAP)
        {
            ppdev = (PPDEV)psoDst->dhpdev;
            pdsurfDst = (DSURF *)psoDst->dhsurf;
            psoDst = pdsurfDst->pso;

            if (pdsurfDst->dt & DT_SCREEN)
            {
                POINTL   ptlTmp;

                DISPDBG((DBGLVL, "Replacing dst screen with bitmap Uploading"));

                // We need to upload the area from the screen and use bitmaps
                // to perform the operation

                hsurfDstBitmap = (HSURF) EngCreateBitmap(psoDst->sizlBitmap, 0, 
                                                psoDst->iBitmapFormat, 0, NULL);
                if (hsurfDstBitmap == NULL)
                {
                    goto drvBitBltFailed;
                }

                if ((psoDstBitmap = EngLockSurface(hsurfDstBitmap)) == NULL)
                {
                    goto drvBitBltFailed;
                }

                ptlTmp.x = prclDst->left;
                ptlTmp.y = prclDst->top;

                GLINT_DECL_INIT;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                VALIDATE_DD_CONTEXT;

                // Call our function to perform image upload to tmp surface

                if (!bUploadRect(ppdev, pco, psoDst, psoDstBitmap, 
                                    &ptlTmp, prclDst))
                {
                    goto drvBitBltFailed;
                }

                psoDst = psoDstBitmap;
            }
        }

    #if DBG
        if (psoDstBitmap)
        {
            DISPDBG((DBGLVL, "DrvBitBlt dest DIB, psoDst = 0x%08x:", psoDst));
            DISPDBG((DBGLVL,  "\tsize: %d x %d", 
                              psoDst->sizlBitmap.cx, 
                              psoDst->sizlBitmap.cy));
            DISPDBG((DBGLVL,  "\tcjBits = %d", psoDst->cjBits));
            DISPDBG((DBGLVL,  "\tpvBits = 0x%08x", psoDst->pvBits));
            DISPDBG((DBGLVL,  "\tpvScan0 = 0x%08x", psoDst->pvScan0));
            DISPDBG((DBGLVL,  "\tlDelta = %d", psoDst->lDelta));
            DISPDBG((DBGLVL,  "\tiBitmapFormat = %d", psoDst->iBitmapFormat));
            DISPDBG((DBGLVL,  "\tfjBitmap = %d", psoDst->fjBitmap));
         }

         if (psoSrcBitmap)
         {
            DISPDBG((DBGLVL, "DrvBitBlt source DIB, psoSrc = 0x%08x:", psoSrc));
            DISPDBG((DBGLVL, "psoSrc != NULL"));
            DISPDBG((DBGLVL,  "\tsize: %d x %d", 
                              psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy));
            DISPDBG((DBGLVL,  "\tcjBits = %d", psoSrc->cjBits));
            DISPDBG((DBGLVL,  "\tpvBits = 0x%08x", psoSrc->pvBits));
            DISPDBG((DBGLVL,  "\tpvScan0 = 0x%08x", psoSrc->pvScan0));
            DISPDBG((DBGLVL,  "\tlDelta = %d", psoSrc->lDelta));
            DISPDBG((DBGLVL,  "\tiBitmapFormat = %d", psoSrc->iBitmapFormat));
            DISPDBG((DBGLVL,  "\tfjBitmap = %d", psoSrc->fjBitmap));
        }
    #endif

        DISPDBG((DBGLVL, "About to pass to GDI"));

        if (pco && (pco->iDComplexity == DC_COMPLEX))
        {
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        }

        // get GDI to do the blt

        bRet = EngBitBlt(psoDst,
                         psoSrc,
                         psoMsk,
                         pco,
                         pxlo,
                         prclDst,
                         pptlSrc,
                         pptlMsk,
                         pbo,
                         pptlBrush,
                         rop4);

        // if we need the nibbles replicated within each color component we must
        // do it now since GDI will have destroyed one half of each byte.

        if (psoDstBitmap)
        {
            POINTL   ptlTmp;
    
            // We need to upload the destination to the screen now.

            ptlTmp.x = prclDst->left;
            ptlTmp.y = prclDst->top;

            DISPDBG((DBGLVL, "downloading Now"));

            // We assume the dest upload was performed last, 
            // so the offsets will still be correct.

            if (!SourceFillRect(ppdev, prclDst, pco, psoDstBitmap, NULL, &ptlTmp,
                                __GLINT_LOGICOP_COPY, __GLINT_LOGICOP_COPY))
            {
                goto drvBitBltFailed;
            }

            DISPDBG((DBGLVL, "downloading Done 0x%x 0x%x", 
                             psoDstBitmap, hsurfDstBitmap));

            // Now we can discard the destination bitmap too.

            EngUnlockSurface(psoDstBitmap);
            EngDeleteSurface(hsurfDstBitmap);

            DISPDBG((DBGLVL, "Surface deleted"));
        }

        if (psoSrcBitmap)
        {
            // We can just discard the src bitmap if it was created.

            EngUnlockSurface(psoSrcBitmap);
            EngDeleteSurface(hsurfSrcBitmap);
        }

        DISPDBG((DBGLVL, "returning %d", bRet));
        return(bRet);

drvBitBltFailed:

        DISPDBG((WRNLVL, "drvBitBltFailed"));    
        if (psoSrcBitmap)
        {
            EngUnlockSurface(psoSrcBitmap);
        }
        if (hsurfSrcBitmap) 
        {
            EngDeleteSurface(hsurfSrcBitmap);
        }
        if (psoDstBitmap)
        {
            EngUnlockSurface(psoDstBitmap);
        }
        if (hsurfDstBitmap)
        {
            EngDeleteSurface(hsurfDstBitmap);
        }
        return(FALSE);
    } 

simple_engine_blt:

    // if target is on screen then pick out the screen DIB surface

    if (psoDst->iType != STYPE_BITMAP)
    {
        ppdev = (PPDEV)psoDst->dhpdev;
        pdsurfDst = (DSURF *)psoDst->dhsurf;
        psoDst = pdsurfDst->pso;
    }

    // if source is the screen then pick out the bitmap surface

    if (psoSrc && (psoSrc->iType != STYPE_BITMAP))
    {    
        ppdev = (PPDEV)psoSrc->dhpdev;
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;
        psoSrc = pdsurfSrc->pso;
    }

    // get GDI to do the blt

    bRet = EngBitBlt(psoDst,
                     psoSrc,
                     psoMsk,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc,
                     pptlMsk,
                     pbo,
                     pptlBrush,
                     rop4);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL PatternFillRect
*
* Fill a set of rectangles with either a solid color or a pattern. The pattern
* can be either monochrome or colored. If pbo is null then we are using a
* logicop which doesn't require a source. In this case we can set color to
* be anything we want in the low level routine. If pbo is not null then it
* can indicate either a solid color or a mono or colored pattern.
*
* Returns:
*
* True if we handled the fill, False if we want GDI to do it.
*
\**************************************************************************/

BOOL PatternFillRect(
PPDEV       ppdev,
RECTL       *prclDst,
CLIPOBJ     *pco,
BRUSHOBJ    *pbo,
POINTL      *pptlBrush,
DWORD       fgLogicop,
DWORD       bgLogicop)
{
    BYTE        jClip;
    BOOL        bMore;
    RBRUSH      *prb;
    RBRUSH_COLOR rbc;
    CLIPENUM    ce;
    RECTL       rcl;
    LONG        c;
    GFNFILL     *fillFn;

    // if pbo is null then the caller will have ensured that the logic op
    // doesn't need a source so we can do a solid fill. In that case rbc
    // is irrelevant.
    //
    if ((pbo == NULL) || ((rbc.iSolidColor = pbo->iSolidColor) != -1))
    {
        DISPDBG((DBGLVL, "got a solid brush with color 0x%x "
                         "(fgrop %d, bgrop %d)",
                         rbc.iSolidColor, fgLogicop, bgLogicop));
        fillFn = ppdev->pgfnFillSolid;
    }
    else
    {
        DISPDBG((DBGLVL, "Got a real patterned brush. pbo = 0x%x", pbo));

        // got ourselves a real pattern so check it's realized

        if ((prb = pbo->pvRbrush) == NULL)
        {
            DISPDBG((DBGLVL, "calling BRUSHOBJ_pvGetRbrush"));
            prb = BRUSHOBJ_pvGetRbrush(pbo);
            DISPDBG((DBGLVL, "BRUSHOBJ_pvGetRbrush returned 0x%x", prb));
            if (prb == NULL)
            {
                return FALSE;   // let the engine do it
            }
        }

        if (prb->fl & RBRUSH_2COLOR)
        {
            DISPDBG((DBGLVL, "monochrome brush"));
            fillFn = ppdev->pgfnFillPatMono;
        }
        else
        {
            DISPDBG((DBGLVL, "colored brush"));
            fillFn = ppdev->pgfnFillPatColor;
        }

        rbc.prb = prb;   
    }

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (jClip == DC_TRIVIAL)
    {
        DISPDBG((DBGLVL, "trivial clip"));
        (*fillFn)(ppdev, 1, prclDst, fgLogicop, bgLogicop, rbc, pptlBrush);
    }
    else if (jClip == DC_RECT)
    {
        DISPDBG((DBGLVL, "rect clip"));
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
        {
            (*fillFn)(ppdev, 1, &rcl, fgLogicop, bgLogicop, rbc, pptlBrush);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "complex clip"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);
            c = cIntersect(prclDst, ce.arcl, ce.c);
            if (c != 0)
            {
                (*fillFn)(ppdev, c, ce.arcl, fgLogicop,
                          bgLogicop, rbc, pptlBrush);
            }
        } while (bMore);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL SourceFillRect
*
* Fill a set of rectangles by downloading data from the source bitmap. This
* handles both memory-to-screen and screen-to-screen.
*
* Returns:
*
* True if we handled the fill, False if we want GDI to do it.
*
\**************************************************************************/

BOOL SourceFillRect(
PPDEV       ppdev,
RECTL       *prclDst,
CLIPOBJ     *pco,
SURFOBJ     *psoSrc,
XLATEOBJ    *pxlo,
POINTL      *pptlSrc,
ULONG       fgLogicop,
ULONG       bgLogicop)
{
    BYTE        jClip;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL       rcl;
    LONG        c;
    GFNXFER     *fillFn;
    ULONG       iSrcBitmapFormat;
    DSURF       *pdsurfSrc;
    POINTL      ptlSrc;
    ULONG       iDir;
    GlintDataPtr glintInfo = (GlintDataPtr)(ppdev->glintInfo);

    DISPDBG((DBGLVL, "SourceFillRect called"));

    // we don't get into this routine unless dst is the screen
    // if psoSrc was originally a DFB converted to a DIB, it must have been
    // re-assigned to the DIV surface before calling this function.

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (psoSrc->iType != STYPE_BITMAP)
    {
        // screen to screen
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

        ASSERTDD(pdsurfSrc->dt & DT_SCREEN, "Expected screen source");

        SETUP_PPDEV_SRC_OFFSETS(ppdev, pdsurfSrc);

        ptlSrc.x = pptlSrc->x - (ppdev->xOffset - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y;

        pptlSrc  = &ptlSrc;

        if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
        {
            //////////////////////////////////////////////////
            // Screen-to-screen blt with no translate

            if (jClip == DC_TRIVIAL)
            {
                DISPDBG((DBGLVL, "trivial clip calling ppdev->pgfnCopyBlt"));
                (*ppdev->pgfnCopyBlt)(ppdev, prclDst, 1, fgLogicop, pptlSrc,
                                                                prclDst);
            }
            else if (jClip == DC_RECT)
            {
                if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                {
                    DISPDBG((DBGLVL, "rect clip calling ppdev->pgfnCopyBlt"));
                    (*ppdev->pgfnCopyBlt)(ppdev, &rcl, 1, fgLogicop, pptlSrc,
                                                                prclDst);
                }
            }
            else
            {
                // Don't forget that we'll have to draw the
                // rectangles in the correct direction:

                if (pptlSrc->y >= prclDst->top)
                {
                    if (pptlSrc->x >= prclDst->left)
                        iDir = CD_RIGHTDOWN;
                    else
                        iDir = CD_LEFTDOWN;
                }
                else
                {
                    if (pptlSrc->x >= prclDst->left)
                        iDir = CD_RIGHTUP;
                    else
                        iDir = CD_LEFTUP;
                }

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   iDir, 0);

                do {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                          (ULONG*) &ce);

                    c = cIntersect(prclDst, ce.arcl, ce.c);

                    if (c != 0)
                    {
                        DISPDBG((DBGLVL, "complex clip calling "
                                         "ppdev->pgfnCopyBlt"));
                                         
                        (*ppdev->pgfnCopyBlt)(ppdev, 
                                              ce.arcl, 
                                              c, 
                                              fgLogicop, 
                                              pptlSrc, 
                                              prclDst);
                    }

                } while (bMore);
            }

            return TRUE;
        }
    }
    else // (psoSrc->iType == STYPE_BITMAP)
    {
        // Image download
        // here we can use a set of function pointers to handle the 
        // different cases. At the end loop through the cliprects 
        // calling the given function.

        iSrcBitmapFormat = psoSrc->iBitmapFormat;
        if (iSrcBitmapFormat == BMF_1BPP)
        {
            // do 1bpp download
            fillFn = ppdev->pgfnXfer1bpp;       
        }
        else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
        {
            // native depth image download
            fillFn = ppdev->pgfnXferImage;
        }
        else if (iSrcBitmapFormat == BMF_4BPP)
        {
            // 4 to 8,16,32 image download
            DISPDBG((DBGLVL, "4bpp source download."));
            fillFn = ppdev->pgfnXfer4bpp;       
        }
        else if (iSrcBitmapFormat == BMF_8BPP)
        {
            // 8 to 8,16,32 image download
            DISPDBG((DBGLVL, "8bpp source download."));
            fillFn = ppdev->pgfnXfer8bpp;   
        }
        else
        {
            DISPDBG((DBGLVL, "source has format %d,  Punting to GDI", 
                             iSrcBitmapFormat));
            goto ReturnFalse;
        }

        if (jClip == DC_TRIVIAL)
        {
            DISPDBG((DBGLVL, "trivial clip image download"));
            (*fillFn)(ppdev, prclDst, 1, fgLogicop, bgLogicop, psoSrc,
                                                    pptlSrc, prclDst, pxlo);
        }
        else if (jClip == DC_RECT)
        {
            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            {
                DISPDBG((DBGLVL, "rect clip image download"));
                (*fillFn)(ppdev, &rcl, 1, fgLogicop, bgLogicop, psoSrc,
                                                    pptlSrc, prclDst, pxlo);
            }
        }
        else
        {
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
            do {
                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);
                c = cIntersect(prclDst, ce.arcl, ce.c);
                if (c != 0)
                {
                    DISPDBG((DBGLVL, "complex clip image download"));
                    (*fillFn)(ppdev, ce.arcl, c, fgLogicop, bgLogicop, psoSrc,
                                                    pptlSrc, prclDst, pxlo);
                }
            } while (bMore);
        }
        return TRUE;
    }

ReturnFalse:

#if DBG
    DISPDBG((WRNLVL, "SourceFillRect returning false"));
    if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL))
        DISPDBG((WRNLVL, "due to non-trivial xlate"));
#endif

    return FALSE;
}

/******************************Public*Routine******************************\
* BOOL MaskCopyBlt
*
* We do a screen-to-screen blt through a mask. The source surface must not
* be a bitmap.
*
* Returns:
*
* True if we handled the copy, False if we want GDI to do it.
*
\**************************************************************************/

BOOL MaskCopyBlt(
PPDEV       ppdev,
RECTL*      prclDst,
CLIPOBJ*    pco,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
ULONG       fgLogicop,
ULONG       bgLogicop)
{
    BYTE        jClip;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL       rcl;
    LONG        c;
    DSURF       *pdsurfSrc;
    POINTL      ptlSrc;
 
    DISPDBG((DBGLVL, "MaskCopyBlt called"));

    if (psoSrc != NULL)
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

        ASSERTDD(pdsurfSrc->dt & DT_SCREEN, "Expected screen source");

        ptlSrc.x = pptlSrc->x - (ppdev->xOffset - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y + pdsurfSrc->poh->y;

        pptlSrc  = &ptlSrc;
    }

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (jClip == DC_TRIVIAL)
    {
        DISPDBG((DBGLVL, "trivial clip"));
        (*ppdev->pgfnMaskCopyBlt)(ppdev, prclDst, 1, psoMsk, pptlMsk,
                                    fgLogicop, bgLogicop, pptlSrc, prclDst);
    }
    else if (jClip == DC_RECT)
    {
        DISPDBG((DBGLVL, "rect clip"));
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
        {
            (*ppdev->pgfnMaskCopyBlt)(ppdev, &rcl, 1, psoMsk, pptlMsk,
                                    fgLogicop, bgLogicop, pptlSrc, prclDst);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "complex clip"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);
            c = cIntersect(prclDst, ce.arcl, ce.c);
            if (c != 0)
            {
                (*ppdev->pgfnMaskCopyBlt)(ppdev, ce.arcl, c, psoMsk, pptlMsk,
                                    fgLogicop, bgLogicop, pptlSrc, prclDst);
            }
        } while (bMore);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL PatSrcPatBlt
*
* Function to perform a rop3 by combining pattern and source fills. Does a
* pattern fill followed by a source fill. Optionally, it does a further
* pattern fill. Each fill has a separate logicop given in pLogicop.
*
* Returns:
*
* True if we handled the blt, False if we want GDI to do it.
*
\**************************************************************************/

BOOL PatSrcPatBlt(
PPDEV       ppdev,
SURFOBJ     *psoSrc,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
RECTL       *prclDst,
POINTL      *pptlSrc,
BRUSHOBJ    *pbo,
POINTL      *pptlBrush,
RopTablePtr pTable)
{
    ULONG   iSrcBitmapFormat;
    BOOL    bRet;

    DISPDBG((DBGLVL, "PatSrcPatBlt called"));

    // ensure that all calls will pass before we do any rendering. The pattern
    // fills will only fail if we can't realize the brush and that will be
    // detected on the first call. So we only have to ensure that the source
    // download will work since by the time we call the function we will
    // already have done the first pattern fill and it's too late to back out.

    DISPDBG((DBGLVL, "source is of type %s, depth %s",
            (psoSrc->iType == STYPE_DEVBITMAP) ? "DEVBITMAP" :
            (psoSrc->iType == STYPE_BITMAP) ? "BITMAP" : "SCREEN",
            (psoSrc->iBitmapFormat == BMF_1BPP) ? "1" :
            (psoSrc->iBitmapFormat == ppdev->iBitmapFormat) ? "native" : 
                                                              "not supported"
           ));

    // if both source and destination are the screen, we cannot handle this
    // if they overlap since we may destroy the source when we do the first
    // pattern fill.
    //
    if ((psoSrc->iType != STYPE_BITMAP) && (OVERLAP(prclDst, pptlSrc)))
    {
        DISPDBG((DBGLVL, "screen src and dst overlap"));
        return(FALSE);
    }

    if (psoSrc->iType == STYPE_BITMAP)
    {
        iSrcBitmapFormat = psoSrc->iBitmapFormat;
        if ((iSrcBitmapFormat == BMF_1BPP) ||
             ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
              ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))))
        {
            goto Continue_It;
        }
        DISPDBG((DBGLVL, "failed due to bad source bitmap format"));
        return(FALSE);
    }
//@@BEGIN_DDKSPLIT
    // else (psoSrc->iType != STYPE_BITMAP)
//@@END_DDKSPLIT
    if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL))
    {
        DISPDBG((DBGLVL, "failed due to xlate with non-DIB source"));
        return(FALSE);
    }

Continue_It:

    // as part of the B8 rop3 we are sometimes asked to xor with 0. As this is
    // a noop I'll trap it.
    //
    if ((pbo->iSolidColor != 0) || (pTable->logicop[0] != __GLINT_LOGICOP_XOR))
    {    
        // do the first pattern fill. It can only fail if a brush realize fails
        //
        DISPDBG((DBGLVL, "calling pattern fill function, rop %d",
                         pTable->logicop[0]));
                         
        if (!PatternFillRect(ppdev,
                             prclDst,
                             pco,
                             pbo,
                             pptlBrush,
                             pTable->logicop[0],
                             pTable->logicop[0]))
        {
            return(FALSE);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "ignoring xor with solid color 0"));
    }

    // download the source. We've already ensured that the call won't fail

    DISPDBG((DBGLVL, "downloading source bitmap, rop %d", 
                     pTable->logicop[1]));

    bRet = SourceFillRect(ppdev,
                          prclDst,
                          pco,
                          psoSrc,
                          pxlo,
                          pptlSrc,
                          pTable->logicop[1],
                          pTable->logicop[1]);
    ASSERTDD(bRet == TRUE, "PatSrcPatBlt: SourceFillRect returned FALSE");

    if ((pTable->func_index == PAT_SRC_PAT_3_BLT) &&
        ((pbo->iSolidColor != 0) || (pTable->logicop[2] != __GLINT_LOGICOP_XOR)))
    {    

        // fill with the pattern again. This won't fail because the first 
        // pattern fill succeeded.

        DISPDBG((DBGLVL, "calling pattern fill function, rop %d",
                         pTable->logicop[2]));
        bRet = PatternFillRect(ppdev,
                               prclDst,
                               pco,
                               pbo,
                               pptlBrush,
                               pTable->logicop[2],
                               pTable->logicop[2]);
                               
        ASSERTDD(bRet == TRUE, 
                 "PatSrcPatBlt: second PatterFillRect returned FALSE");
    }
#if DBG
    else if (pTable->func_index == PAT_SRC_PAT_3_BLT)
    {
        DISPDBG((DBGLVL, "ignoring xor with solid color 0"));
    }
#endif

    DISPDBG((DBGLVL, "PatSrcPatBlt returning true"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL SrcPatSrcBlt
*
* Function to perform a rop3 by combining pattern and source fills. Does a
* source fill followed by a pattern fill. Optionally, it does a further
* source fill. Each fill has a separate logicop given in pLogicop.
*
* Returns:
*
* True if we handled the blt, False if we want GDI to do it.
*
\**************************************************************************/

BOOL SrcPatSrcBlt(
PPDEV       ppdev,
SURFOBJ     *psoSrc,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
RECTL       *prclDst,
POINTL      *pptlSrc,
BRUSHOBJ    *pbo,
POINTL      *pptlBrush,
RopTablePtr pTable)
{
    RBRUSH  *prb;
    BOOL    bRet;

    DISPDBG((DBGLVL, "SrcPatSrc called"));

    // if both source and destination are the screen, we cannot handle it
    // if they overlap since we may destroy the source with the first two
    // operations before we get to the third one. If we're only a
    // SRC_PAT_2_BLT then we're OK; SourceFillRect will handle
    // the copy direction of the source fill properly.
    //
    if ((psoSrc->iType != STYPE_BITMAP) &&
        (pTable->func_index == SRC_PAT_SRC_3_BLT) &&
        (OVERLAP(prclDst, pptlSrc)))
    {
        return(FALSE);
    }

    // we must ensure that the pattern fill will succeed. It can only fail if
    // we can't realize the brush so do it now.
    //
    if ((pbo != NULL) && (pbo->iSolidColor == -1))
    {
        if ((prb = pbo->pvRbrush) == NULL)
        {
            prb = BRUSHOBJ_pvGetRbrush(pbo);
            if (prb == NULL)
            {
                return FALSE;   // let the engine do it
            }
        }
    }

    // do the first source download. If it succeeds we know the second one
    // will also work. If it fails we simply let the engine do it and we
    // haven't upset anything (except we may have realized the brush without
    // needing to).
    //

    DISPDBG((DBGLVL, "downloading source bitmap, rop %d", 
                     pTable->logicop[0]));
                     
    if (!SourceFillRect(ppdev,
                        prclDst,
                        pco,
                        psoSrc,
                        pxlo,
                        pptlSrc,
                        pTable->logicop[0],
                        pTable->logicop[0]))
    {
        return(FALSE);
    }

    // fill with the pattern again. We've already ensured this will work.

    DISPDBG((DBGLVL, "calling pattern fill function, rop %d", 
                     pTable->logicop[1]));
                     
    bRet = PatternFillRect(ppdev,
                           prclDst,
                           pco,
                           pbo,
                           pptlBrush,
                           pTable->logicop[1],
                           pTable->logicop[1]);
    ASSERTDD(bRet == TRUE, "SrcPatSrcBlt: PatternFillRect returned FALSE");

    if (pTable->func_index == SRC_PAT_SRC_3_BLT)
    {
        // download the source again with the final logic op

        DISPDBG((DBGLVL, "downloading source bitmap, rop %d", 
                         pTable->logicop[2]));
                         
        bRet = SourceFillRect(ppdev,
                              prclDst,
                              pco,
                              psoSrc,
                              pxlo,
                              pptlSrc,
                              pTable->logicop[2],
                              pTable->logicop[2]);

        ASSERTDD(bRet == TRUE, 
                 "SrcPatSrcBlt: second SourceFillRect returned FALSE");
    }

    DISPDBG((DBGLVL, "SrcPatSrcBlt returning true"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bUploadRect
*
* upload a rectangular area. clip to a given CLIPOBJ
*
* Returns:
*
* True if we handled the blt, otherwise False.
*
\**************************************************************************/

BOOL bUploadRect(
PPDEV   ppdev,
CLIPOBJ *pco,
SURFOBJ *psoSrc,
SURFOBJ *psoDst,
POINTL  *pptlSrc,
RECTL   *prclDst)
{
    BYTE        jClip;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL       rcl;
    LONG        c;

    // Perform the clipping and pass to a 
    // function to upload a list of rectangles.

    DISPDBG((DBGLVL, "UploadRect called. Src %d %d To "
                     "dst (%d %d) --> (%d %d)", 
                     pptlSrc->x, pptlSrc->y,
                     prclDst->left, prclDst->top, 
                     prclDst->right, prclDst->bottom));

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
     
    if (jClip == DC_TRIVIAL)
    {
        DISPDBG((DBGLVL, "trivial clip"));
        ppdev->pgfnUpload(ppdev, 1, prclDst, psoDst, pptlSrc, prclDst);
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
        {
            DISPDBG((DBGLVL, "rect clip"));
            ppdev->pgfnUpload(ppdev, 1, &rcl, psoDst, pptlSrc, prclDst);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "complex clip"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);
            c = cIntersect(prclDst, ce.arcl, ce.c);
            if (c != 0)
            {
                ppdev->pgfnUpload(ppdev, c, ce.arcl, psoDst, pptlSrc, prclDst);
            }
        } while (bMore);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bUploadBlt
*
* Returns:
*
* True if we handled the blt, otherwise False.
*
\**************************************************************************/

BOOL bUploadBlt(
PPDEV    ppdev,
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMsk,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL       *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMsk,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4     rop4)
{
    BOOL        bRet;

    DISPDBG((DBGLVL, "bUploadBlt called"));
    if ((rop4 == 0xCCCC) &&
        ((pxlo == NULL) || pxlo->flXlate & XO_TRIVIAL) &&
        (psoDst->iBitmapFormat == ppdev->iBitmapFormat))
    {
        // We have no raster op to worry about, and no translations to perform.
        // All we need to do is upload the data from GLINT and put it in the
        // destination. Practically, most image uploads should be of this type.
        return(bUploadRect(ppdev, pco, psoSrc, psoDst, pptlSrc, prclDst));
    }
    else
    {
        HSURF       hsurfTmp;
        SURFOBJ*    psoTmp;
        SIZEL       sizl;
        POINTL      ptlTmp;
        RECTL       rclTmp;

        // We cant upload directly to the destination, so we create a 
        // temporary bitmap, upload to this bitmap, then call EngBitBlt 
        // to do the hard work of the translation or raster op.

        // Source point in tmp:
        ptlTmp.x      = 0;
        ptlTmp.y      = 0;

        // Dest Area in tmp
        rclTmp.left   = 0; 
        rclTmp.top   = 0;
        rclTmp.right  = prclDst->right  - prclDst->left;
        rclTmp.bottom = prclDst->bottom - prclDst->top; 

        // Work out size of tmp bitmap. We know left and top are zero.
        sizl.cx = rclTmp.right;
        sizl.cy = rclTmp.bottom;

        // Create the bitmap
        hsurfTmp = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                           0, NULL);
        if (hsurfTmp == NULL)
        {
            return(FALSE);
        }

        if ((psoTmp = EngLockSurface(hsurfTmp)) == NULL)
        {
            EngDeleteSurface(hsurfTmp);
            return(FALSE);
        }

        // Call our function to perform image upload to tmp surface
        bRet = bUploadRect(ppdev, NULL, psoSrc, psoTmp, pptlSrc, &rclTmp);

        // Call GDI to blt from tmp surface to destination, 
        // doing all the work for us
        if (bRet)
        {
            bRet = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo, prclDst, 
                                &ptlTmp, pptlMsk, pbo, pptlBrush, rop4);
        }

        // Remove tmp surface
        EngUnlockSurface(psoTmp);
        EngDeleteSurface(hsurfTmp);

        return(bRet);
    }
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
* On the S3 it's faster to do straight SRCCOPY bitblt's through the
* memory aperture than to use the data transfer register; as such, this
* routine is the logical place to put this special case.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    POINTL  ptl;
    RECTL   rcl;
    OH*     pohSrc;
    OH*     pohDst;
    CLIPENUM    ce;
    int         cClipRects;
    BOOL        bMore, bRet, bCopyDone = FALSE;
    GLINT_DECL_VARS;

    DISPDBG((DBGLVL, "DrvCopyBits called"));

    // We need to remove the pointer, but we dont know which surface is valid
    // (if either). 
    if ((psoDst->iType != STYPE_BITMAP) && 
        (((DSURF *)(psoDst->dhsurf))->dt & DT_SCREEN))
    {
        ppdev = (PDEV *)psoDst->dhpdev;
        REMOVE_SWPOINTER(psoDst);
    }
    else if ((psoSrc->iType != STYPE_BITMAP) && 
             (((DSURF *)(psoSrc->dhsurf))->dt & DT_SCREEN))
    {
        ppdev = (PDEV *)psoSrc->dhpdev;
        REMOVE_SWPOINTER(psoSrc);
    } 
#if 0    
    else
    {
        // we shouldn't ever fall here, but we have this just as safeguard code
        return EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);    
    }
#endif    

#if !defined(_WIN64) && WNT_DDRAW
    // Touch the source surface 1st and then the destination surface

    vSurfUsed(psoSrc);
    vSurfUsed(psoDst);
#endif
 
    // Faster route to calling screen-to-screen BLT. The order in the if() is
    // very important to avoid null pointers.

    pdsurfDst = (DSURF*)psoDst->dhsurf;
    pdsurfSrc = (DSURF*)psoSrc->dhsurf;

    if ((psoDst->iType != STYPE_BITMAP) && 
        (pdsurfDst->dt & DT_SCREEN) &&
        psoSrc && 
        (psoSrc->iType != STYPE_BITMAP) && 
        (pdsurfSrc->dt & DT_SCREEN) &&
        ((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        pohSrc = pdsurfSrc->poh;
        pohDst = pdsurfDst->poh;

        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
        ptl.y = pptlSrc->y;

        ppdev = (PDEV*)  psoDst->dhpdev;
        GLINT_DECL_INIT;
        VALIDATE_DD_CONTEXT;

        SETUP_PPDEV_SRC_AND_DST_OFFSETS(ppdev, pdsurfSrc, pdsurfDst);

        (*ppdev->pgfnCopyBltCopyROP)(ppdev, prclDst, 1, __GLINT_LOGICOP_COPY, 
                                        &ptl, prclDst);
        
        return(TRUE);
    }

    if ((psoDst->iType != STYPE_BITMAP) && 
        psoSrc && 
        (psoSrc->iType == STYPE_BITMAP))
    {
        // straight DIB->screen download with translate: see if 
        // we special-case it

        ppdev = (PDEV*)psoDst->dhpdev; 

        if (((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            (psoSrc->iBitmapFormat == psoDst->iBitmapFormat) && 
            ppdev->pgfnCopyXferImage)
        {    
            // native depth download
            pdsurfDst = (DSURF*)psoDst->dhsurf;

            // only accelerate when downloading to the framebuffer
            if (pdsurfDst->dt & DT_SCREEN)
            {
                GLINT_DECL_INIT;
                VALIDATE_DD_CONTEXT;
                pohDst = pdsurfDst->poh;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                if(pco == NULL || pco->iDComplexity == DC_TRIVIAL)
                {
                    ppdev->pgfnCopyXferImage(ppdev, psoSrc, pptlSrc, prclDst, 
                                                prclDst, 1);
                }
                else if(pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl)) 
                    {
                        ppdev->pgfnCopyXferImage(ppdev, psoSrc, pptlSrc, 
                                                    prclDst, &rcl, 1);
                    }
                }
                else //(pco->iDComplexity == DC_COMPLEX)
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do 
                    {
                        bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
                        cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
                        if(cClipRects)
                        {
                            ppdev->pgfnCopyXferImage(ppdev, psoSrc, pptlSrc, 
                                                            prclDst, ce.arcl, 
                                                                cClipRects);
                        }
                    }
                    while(bMore);
                }
                return(TRUE);
            }
        }
        else if (((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                 (psoSrc->iBitmapFormat == BMF_24BPP) &&
                 ppdev->pgfnCopyXfer24bpp)
        {
            pdsurfDst = (DSURF*)psoDst->dhsurf;

            // only accelerate when downloading to the framebuffer

            if (pdsurfDst->dt & DT_SCREEN)
            {
                GLINT_DECL_INIT;
                VALIDATE_DD_CONTEXT;
                pohDst = pdsurfDst->poh;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                if(pco == NULL || pco->iDComplexity == DC_TRIVIAL)
                {
                    ppdev->pgfnCopyXfer24bpp(ppdev, psoSrc, pptlSrc, prclDst, 
                                                prclDst, 1);
                }
                else if(pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                    {
                        ppdev->pgfnCopyXfer24bpp(ppdev, psoSrc, pptlSrc, 
                                                    prclDst, &rcl, 1);
                    }
                }
                else // (pco->iDComplexity == DC_COMPLEX)
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
                        cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
                        if(cClipRects)
                        {
                            ppdev->pgfnCopyXfer24bpp(ppdev, psoSrc, pptlSrc, 
                                                            prclDst, ce.arcl, 
                                                                 cClipRects);
                        }
                    } while(bMore);
                }
                return(TRUE);
            }
        }
        else if (pxlo && (pxlo->flXlate & XO_TABLE) &&
                 (psoSrc->iBitmapFormat == BMF_8BPP) &&
                 (pxlo->cEntries == 256) && ppdev->pgfnCopyXfer8bpp)
        {
            pdsurfDst = (DSURF*)psoDst->dhsurf;

            if (pdsurfDst->dt & DT_SCREEN)
            {
                BOOL bRenderLargeBitmap;

                GLINT_DECL_INIT;
                VALIDATE_DD_CONTEXT;
                pohDst = pdsurfDst->poh;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                bRenderLargeBitmap = (ppdev->pgfnCopyXfer8bppLge != NULL);

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    if(bRenderLargeBitmap)
                    {
                        ppdev->pgfnCopyXfer8bppLge(ppdev, psoSrc, pptlSrc, 
                                                    prclDst, prclDst, 1, pxlo);
                    }
                    else
                    {
                        ppdev->pgfnCopyXfer8bpp(ppdev, psoSrc, pptlSrc, prclDst,
                                                            prclDst, 1, pxlo);
                    }                        
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl)) 
                    {
                        if(bRenderLargeBitmap)
                        {
                            ppdev->pgfnCopyXfer8bppLge(ppdev, psoSrc, pptlSrc, 
                                                        prclDst, &rcl, 1, pxlo);
                        }
                        else
                        {
                            ppdev->pgfnCopyXfer8bpp(ppdev, psoSrc, pptlSrc, 
                                                        prclDst, &rcl, 1, pxlo);
                        }
                    }
                }
                else // (pco->iDComplexity == DC_COMPLEX)
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
                        cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
                        if(cClipRects)
                        {
                            if(bRenderLargeBitmap)
                            {
                                ppdev->pgfnCopyXfer8bppLge(ppdev, psoSrc, 
                                                           pptlSrc, prclDst, 
                                                           ce.arcl, cClipRects, 
                                                           pxlo);
                            }
                            else
                            {
                                ppdev->pgfnCopyXfer8bpp(ppdev, psoSrc, pptlSrc, 
                                                        prclDst, ce.arcl, 
                                                        cClipRects, pxlo);
                            }
                        }
                    } while(bMore);
                }
                return(TRUE);
            }
        }
        else if (pxlo && (pxlo->flXlate & XO_TABLE) && 
                 (psoSrc->iBitmapFormat == BMF_4BPP) && 
                 (pxlo->cEntries == 16) && ppdev->pgfnCopyXfer4bpp)
        {
            pdsurfDst = (DSURF*)psoDst->dhsurf;

            if (pdsurfDst->dt & DT_SCREEN)
            {
                GLINT_DECL_INIT;
                VALIDATE_DD_CONTEXT;
                pohDst = pdsurfDst->poh;

                SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    ppdev->pgfnCopyXfer4bpp(ppdev, psoSrc, pptlSrc, prclDst, 
                                            prclDst, 1, pxlo);
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                    {
                        ppdev->pgfnCopyXfer4bpp(ppdev, psoSrc, pptlSrc, 
                                                prclDst, &rcl, 1, pxlo);
                    }
                }
                else // (pco->iDComplexity == DC_COMPLEX)
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
                        cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
                        if(cClipRects)
                        {
                            ppdev->pgfnCopyXfer4bpp(ppdev, psoSrc, pptlSrc, 
                                                    prclDst, ce.arcl, 
                                                    cClipRects, pxlo);
                        }
                    }
                    while(bMore);
                }
                return(TRUE);
            }
        }
//@@BEGIN_DDKSPLIT
#if DBG && 0
        else if (psoSrc->iBitmapFormat != BMF_1BPP)
        {
            SIZEL sizl;
            int   cEntries = pxlo == 0 ? 0 : pxlo->cEntries;
            int   flXlate =  pxlo == 0 ? 0 : pxlo->flXlate;
            int   iDComplexity = pco == 0 ? 0 : pco->iDComplexity;

            sizl.cx = prclDst->right - prclDst->left;
            sizl.cy = prclDst->bottom - prclDst->top;
            DISPDBG((ERRLVL, "DrvCopyBits() unhandled copy download "
                             "bmf(%xh) pxlo(%p, cEntries=%03xh flXlate=%xh) "
                             "pco(%p, iDComplexity=%02xh), cxcy(%03xh,%03xh)",
                             psoSrc->iBitmapFormat, pxlo, cEntries, flXlate, 
                             pco, iDComplexity, sizl.cx, sizl.cy));

        }
#endif
//@@END_DDKSPLIT
    }

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco) && (pco->iDComplexity != DC_TRIVIAL)) ||
        ((pxlo) && (! (pxlo->flXlate & XO_TRIVIAL))))
    {
        /////////////////////////////////////////////////////////////////
        // A DrvCopyBits is after all just a simplified DrvBitBlt:

        DISPDBG((DBGLVL, "DrvCopyBits fell through to DrvBitBlt"));
        return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, 
                         NULL, NULL, NULL, 0x0000CCCC));

    }

//@@BEGIN_DDKSPLIT
    // Screen to screen case has already been handled at the very beginning.
//@@END_DDKSPLIT
    
    DISPDBG((DBGLVL, "trivial clip and xlate"));

    if ((psoDst->iType != STYPE_BITMAP) && (pdsurfDst->dt & DT_SCREEN))
    {
        // We know the destination is either a DFB or the screen:

        DISPDBG((DBGLVL, "Destination is not a bitmap"));
        
        GLINT_DECL_INIT;
        VALIDATE_DD_CONTEXT;

        // See if the source is a plain DIB:

        ASSERTDD(((psoSrc->iType == STYPE_BITMAP) || (pdsurfSrc->dt & DT_DIB)),
                 "Screen-to-screen case should have been handled");

//@@BEGIN_DDKSPLIT
        // Ah ha, the source is a DFB that's really a DIB.
//@@END_DDKSPLIT

        if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
        {
            if (pdsurfSrc) {
                
                DISPDBG((DBGLVL, "source is DFB that's really a DIB"));
                psoSrc = pdsurfSrc->pso;
                ppdev = pdsurfSrc->ppdev;
            }

            //////////////////////////////////////////////////////
            // DIB-to-screen

            ASSERTDD((psoDst->iType != STYPE_BITMAP) &&
                     (pdsurfDst->dt & DT_SCREEN)     &&
                     (psoSrc->iType == STYPE_BITMAP) &&
                     (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                     "Should be a DIB-to-screen case");

            SETUP_PPDEV_OFFSETS(ppdev, pdsurfDst);

            DISPDBG((DBGLVL, "doing DIB-to-screen transfer"));
            (*ppdev->pgfnXferImage)(ppdev,
                                    prclDst,
                                    1,
                                    __GLINT_LOGICOP_COPY,
                                    __GLINT_LOGICOP_COPY,
                                    psoSrc,
                                    pptlSrc,
                                    prclDst,
                                    NULL);
            bRet = TRUE;
            bCopyDone = TRUE;
        }
    }
    else // The destination is a DIB
    {
        DISPDBG((DBGLVL, "Destination is a bitmap"));

        if (pdsurfDst)
        {
            psoDst = pdsurfDst->pso;
        }
        if (pdsurfSrc)
        {
            ppdev = pdsurfSrc->ppdev;
        }

        if ((ppdev != NULL) &&
            (psoDst->iBitmapFormat == ppdev->iBitmapFormat) &&
            (psoSrc->iType != STYPE_BITMAP) &&
            (pdsurfSrc->dt & DT_SCREEN))
        {
            VOID pxrxMemUpload  (PDEV*, LONG, RECTL*, SURFOBJ*, POINTL*, RECTL*);
        
            GLINT_DECL_INIT;

            SETUP_PPDEV_OFFSETS(ppdev, pdsurfSrc);

            // Perform the upload.
            VALIDATE_DD_CONTEXT;
            DISPDBG((DBGLVL, "doing Screen-to-DIB image upload"));
            
            //(*ppdev->pgfnUpload)
            pxrxMemUpload
                (ppdev, 1, prclDst, psoDst, 
                                 pptlSrc, prclDst);
                                 
            bRet = TRUE;
            bCopyDone = TRUE;

        }
    }


//@@BEGIN_DDKSPLIT
    // NB: we must never get here if the dest is actually the screen (ie. if
    // pdsurfDst->dt & DT_SCREEN and we've changed psoDst to the bypass
    // bitmap). This is because we don't handle nibble replication here which
    // we must do if GDI ever draws directly to the framebuffer. We don't SYNC
    // here because we may be doing a true DIB-to-DIB. We do a SYNC if
    // necessary before jumping here. Currently this happens only if the src
    // is a DFB.
    // 
//@@END_DDKSPLIT

    if (! bCopyDone)
    {
        if (pdsurfDst)
        {
            psoDst = pdsurfDst->pso;
        }
        if (pdsurfSrc)        
        {
            psoSrc = pdsurfSrc->pso;
        }

        ASSERTDD((psoDst->iType == STYPE_BITMAP) &&
                 (psoSrc->iType == STYPE_BITMAP),
                 "Both surfaces should be DIBs to call EngCopyBits");

        DISPDBG((DBGLVL, "DrvCopyBits fell through to EngCopyBits"));

        bRet = EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);
    }

    /////////////////////////////////////////////////////
    // Put It Back Into Off-screen?
    //
    // We take this opportunity to decide if we want to
    // put the DIB back into off-screen memory.  This is
    // a pretty good place to do it because we have to
    // copy the bits to some portion of the screen,
    // anyway.  So we would incur only an extra screen-to-
    // screen blt at this time, much of which will be
    // over-lapped with the CPU.
    //
    // The simple approach we have taken is to move a DIB
    // back into off-screen memory only if there's already
    // room -- we won't throw stuff out to make space
    // (because it's tough to know what ones to throw out,
    // and it's easy to get into thrashing scenarios).
    //
    // Because it takes some time to see if there's room
    // in off-screen memory, we only check one in
    // HEAP_COUNT_DOWN times if there's room.  To bias
    // in favour of bitmaps that are often blt, the
    // counters are reset every time any space is freed
    // up in off-screen memory.  We also don't bother
    // checking if no space has been freed since the
    // last time we checked for this DIB.

    if ((! pdsurfSrc) || (pdsurfSrc->dt & DT_SCREEN))
    {
        return (bRet);
    }


    if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
    {
        if (--pdsurfSrc->cBlt == 0)
        {
            DISPDBG((DBGLVL, "putting src back "
                             "into off-screen"));

            // Failure is safe here
            bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc);
        }
    }
    else
    {
        // Some space was freed up in off-screen memory,
        // so reset the counter for this DFB:

        pdsurfSrc->iUniq = ppdev->iHeapUniq;
        pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
    }

    return (bRet);
}

#if defined(_X86_) 

/******************************Public*Table********************************\ 
* BYTE gajLeftMask[] and BYTE gajRightMask[] 
* 
* Edge tables for vXferScreenTo1bpp. 
\**************************************************************************/ 
 
BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 }; 
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe }; 
 
/******************************Public*Routine******************************\ 
* VOID DoScreenToMono 
* 
* This function works out the clip list and then calls vXferScreenTo1bpp()
* to do ye hard work. 
* 
\**************************************************************************/ 

BOOL DoScreenToMono(
PDEV*       ppdev, 
RECTL       *prclDst,
CLIPOBJ     *pco,
SURFOBJ*    psoSrc,             // Source surface 
SURFOBJ*    psoDst,             // Destination surface 
POINTL*     pptlSrc,            // Original unclipped source point 
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    RECTL       rcl;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DoScreenToMono: Trivial clipping"));
        vXferScreenTo1bpp(ppdev, 1, prclDst, 0, psoSrc, 
                            psoDst, pptlSrc, prclDst, pxlo);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        DISPDBG((DBGLVL, "DoScreenToMono: rect clipping"));
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
        {
            vXferScreenTo1bpp(ppdev, 1, &rcl, 0, psoSrc, 
                                psoDst, pptlSrc, prclDst, pxlo); 
        }
    }
    else // (pco->iDComplexity == DC_COMPLEX)
    {
        CLIPENUM ce;
        int cClipRects;
        BOOL bMore;

        DISPDBG((DBGLVL, "DoScreenToMono: complex clipping"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
            cClipRects = cIntersect(prclDst, ce.arcl, ce.c);
            if(cClipRects)
            {
                vXferScreenTo1bpp (ppdev, cClipRects, ce.arcl, 0, psoSrc, 
                                    psoDst, pptlSrc, prclDst, pxlo); 
            }
        } while(bMore);
    }

    return(TRUE);
} 

/******************************Public*Routine******************************\ 
* VOID vXferScreenTo1bpp 
* 
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp 
* bitmap. 
* 
\**************************************************************************/ 

VOID vXferScreenTo1bpp(         // Type FNXFER 
PDEV*       ppdev, 
LONG        c,                  // Count of rectangles, can't be zero 
RECTL*      prcl,               // List of destination rectangles, in relative 
                                //   coordinates 
ULONG       ulHwMix,            // Not used 
SURFOBJ*    psoSrc,             // Source surface 
SURFOBJ*    psoDst,             // Destination surface 
POINTL*     pptlSrc,            // Original unclipped source point 
RECTL*      prclDst,            // Original unclipped destination rectangle 
XLATEOBJ*   pxlo)               // Provides colour-compressions information 
{ 
    LONG    cjPelSize; 
    VOID*   pfnCompute; 
    SURFOBJ soTmp; 
    ULONG*  pulXlate; 
    ULONG   ulForeColor; 
    RECTL   rclTmp; 
    BYTE*   pjDst; 
    BYTE    jLeftMask; 
    BYTE    jRightMask; 
    BYTE    jNotLeftMask; 
    BYTE    jNotRightMask; 
    LONG    cjMiddle; 
    LONG    lDstDelta; 
    LONG    lSrcDelta; 
    LONG    cyTmpScans; 
    LONG    cyThis; 
    LONG    cyToGo; 
 
    ASSERTDD(c > 0, "Can't handle zero rectangles"); 
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations"); 
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cjPelSize), 
                "Temp buffer has to be larger than widest possible scan"); 

    soTmp = *psoSrc;
    
    // When the destination is a 1bpp bitmap, the foreground colour 
    // maps to '1', and any other colour maps to '0'. 
 
    if (ppdev->iBitmapFormat == BMF_8BPP) 
    { 
        // When the source is 8bpp or less, we find the forground colour 
        // by searching the translate table for the only '1': 
 
        pulXlate = pxlo->pulXlate; 
        while (*pulXlate != 1) 
        {
            pulXlate++; 
        }
        ulForeColor = pulXlate - pxlo->pulXlate; 
    } 
    else 
    { 
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) || 
                 (ppdev->iBitmapFormat == BMF_32BPP), 
                 "This routine only supports 8, 16 or 32bpp"); 
 
        // When the source has a depth greater than 8bpp, the foreground 
        // colour will be the first entry in the translate table we get 
        // from calling 'piVector': 
 
        pulXlate = XLATEOBJ_piVector(pxlo); 
 
        ulForeColor = 0; 
        if (pulXlate != NULL)           // This check isn't really needed... 
        {
            ulForeColor = pulXlate[0]; 
        }
    } 
 
    // We use the temporary buffer to keep a copy of the source 
    // rectangle: 
 
    soTmp.pvScan0 = ppdev->pvTmpBuffer; 
 
    do { 
        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta) 
                                        + (prcl->left >> 3); 
 
        cjPelSize = ppdev->cjPelSize; 
 
        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L)) 
                       * cjPelSize; 
 
        // Our temporary buffer, into which we read a copy of the source, 
        // may be smaller than the source rectangle.  In that case, we 
        // process the source rectangle in batches. 
        // 
        // cyTmpScans is the number of scans we can do in each batch. 
        // cyToGo is the total number of scans we have to do for this 
        // rectangle. 
        // 
        // We take the buffer size less four so that the right edge case 
        // can safely read one dword past the end: 
 
        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta; 
        cyToGo     = prcl->bottom - prcl->top; 
 
        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan"); 
 
        // Initialize variables that don't change within the batch loop: 
 
        rclTmp.top    = 0; 
        rclTmp.left   = prcl->left & 7L; 
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left; 
 
        // Note that we have to be careful with the right mask so that it 
        // isn't zero.  A right mask of zero would mean that we'd always be 
        // touching one byte past the end of the scan (even though we 
        // wouldn't actually be modifying that byte), and we must never 
        // access memory past the end of the bitmap (because we can access 
        // violate if the bitmap end is exactly page-aligned). 
 
        jLeftMask     = gajLeftMask[rclTmp.left & 7]; 
        jRightMask    = gajRightMask[rclTmp.right & 7]; 
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1; 
 
        if (cjMiddle < 0) 
        { 
            // The blt starts and ends in the same byte: 
 
            jLeftMask &= jRightMask; 
            jRightMask = 0; 
            cjMiddle   = 0; 
        } 
 
        jNotLeftMask  = ~jLeftMask; 
        jNotRightMask = ~jRightMask; 
        lDstDelta     = psoDst->lDelta - cjMiddle - 2; 
                                // Delta from the end of the destination 
                                //  to the start on the next scan, accounting 
                                //  for 'left' and 'right' bytes 
 
        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) * cjPelSize); 
                                // Compute source delta for special cases 
                                //  like when cjMiddle gets bumped up to '0', 
                                //  and to correct aligned cases 
 
        do { 
            // This is the loop that breaks the source rectangle into 
            // manageable batches. 
 
            cyThis  = cyTmpScans;
            if( cyToGo < cyThis )
            {
                cyThis = cyToGo; 
            }
            cyToGo -= cyThis; 
 
            rclTmp.bottom = cyThis; 
 
            ppdev->pgfnUpload( ppdev, 1, &rclTmp, &soTmp, pptlSrc, &rclTmp );
            pptlSrc->y += cyThis;
 
            _asm { 
                mov     eax,ulForeColor     ;eax = foreground colour 
                                            ;ebx = temporary storage 
                                            ;ecx = count of middle dst bytes 
                                            ;dl  = destination byte accumulator 
                                            ;dh  = temporary storage 
                mov     esi,soTmp.pvScan0   ;esi = source pointer 
                mov     edi,pjDst           ;edi = destination pointer 
 
                ; Figure out the appropriate compute routine: 
 
                mov     ebx,cjPelSize 
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp 
                dec     ebx 
                jz      short Do_Left_Byte 
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp 
                dec     ebx 
                jz      short Do_Left_Byte 
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp 
 
            Do_Left_Byte: 
                call    pfnCompute 
                and     dl,jLeftMask 
                mov     dh,jNotLeftMask 
                and     dh,[edi] 
                or      dh,dl 
                mov     [edi],dh 
                inc     edi 
                mov     ecx,cjMiddle 
                dec     ecx 
                jl      short Do_Right_Byte 
 
            Do_Middle_Bytes: 
                call    pfnCompute 
                mov     [edi],dl 
                inc     edi 
                dec     ecx 
                jge     short Do_Middle_Bytes 
 
            Do_Right_Byte: 
                call    pfnCompute 
                and     dl,jRightMask 
                mov     dh,jNotRightMask 
                and     dh,[edi] 
                or      dh,dl 
                mov     [edi],dh 
                inc     edi 
 
                add     edi,lDstDelta 
                add     esi,lSrcDelta 
                dec     cyThis 
                jnz     short Do_Left_Byte 
 
                mov     pjDst,edi               ;save for next batch 
 
                jmp     All_Done 
 
            Compute_Destination_Byte_From_8bpp: 
                mov     bl,[esi] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 0 
 
                mov     bl,[esi+1] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 1 
 
                mov     bl,[esi+2] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 2 
 
                mov     bl,[esi+3] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 3 
 
                mov     bl,[esi+4] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 4 
 
                mov     bl,[esi+5] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 5 
 
                mov     bl,[esi+6] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 6 
 
                mov     bl,[esi+7] 
                sub     bl,al 
                cmp     bl,1 
                adc     dl,dl                   ;bit 7 
 
                add     esi,8                   ;advance the source 
                ret 
 
            Compute_Destination_Byte_From_16bpp: 
                mov     bx,[esi] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 0 
 
                mov     bx,[esi+2] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 1 
 
                mov     bx,[esi+4] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 2 
 
                mov     bx,[esi+6] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 3 
 
                mov     bx,[esi+8] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 4 
 
                mov     bx,[esi+10] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 5 
 
                mov     bx,[esi+12] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 6 
 
                mov     bx,[esi+14] 
                sub     bx,ax 
                cmp     bx,1 
                adc     dl,dl                   ;bit 7 
 
                add     esi,16                  ;advance the source 
                ret 
 
            Compute_Destination_Byte_From_32bpp: 
                mov     ebx,[esi] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 0 
 
                mov     ebx,[esi+4] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 1 
 
                mov     ebx,[esi+8] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 2 
 
                mov     ebx,[esi+12] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 3 
 
                mov     ebx,[esi+16] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 4 
 
                mov     ebx,[esi+20] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 5 
 
                mov     ebx,[esi+24] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 6 
 
                mov     ebx,[esi+28] 
                sub     ebx,eax 
                cmp     ebx,1 
                adc     dl,dl                   ;bit 7 
 
                add     esi,32                  ;advance the source 
                ret 
 
            All_Done: 
            } 
        } while (cyToGo > 0); 
 
        prcl++; 
    } while (--c != 0); 
} 

#endif // defined(_X86_) 

#if (_WIN32_WINNT >= 0x500)

//*****************************************************************************
// FUNC: DrvGradientFill
// ARGS: psoDst (I) - destination surface
//       pco (I) - destination clipping
//       pxlo (I) - color translation for pVertex 
//       pVertex (I) - array of trivertex (x,y,color) coordinates
//       nVertex (I) - size of pVertex
//       pMesh (I) - array of GRADIENT_RECT or GRADIENT_TRIANGLE structures
//                   that define the connectivity of pVertex points
//       nMesh (I) - size of pMesh
//       prclExtents (I) - the bounding rectangle
//       pptlDitherOrg (I) - unused
//       ulMode (I) - specifies the fill type (rectangular or triangular)and 
//                    direction
// RETN: TRUE if successful
//-----------------------------------------------------------------------------
// Performs a Gouraud-shaded fill for an array of rectangles or triangles.
// Rectangles can be horizontally or vertically shaded (i.e. we only step the
// color DDA in one direction).
//*****************************************************************************

BOOL DrvGradientFill(
SURFOBJ   *psoDst,
CLIPOBJ   *pco,
XLATEOBJ  *pxlo,
TRIVERTEX *pVertex,
ULONG     nVertex,
PVOID     pMesh,
ULONG     nMesh,
RECTL    *prclExtents,
POINTL   *pptlDitherOrg,
ULONG     ulMode)
{
    SURFOBJ *psoDstOrig = psoDst; // destination surface DIB 
    PDEV    *ppdev;
    DSURF   *pdsurf;
    OH      *poh;
    SURFOBJ *psoDIBDst;
    BOOL bSuccess = FALSE;
    GLINT_DECL_VARS;

    DISPDBG((DBGLVL, "DrvGradientFill entered"));

    ppdev = (PDEV *)psoDst->dhpdev;
    pdsurf = (DSURF *)psoDst->dhsurf;
    GLINT_DECL_INIT;

    if(ppdev->pgfnGradientFillRect == NULL)
    {
        // we don't accelerate this function
        goto punt;
    }

    if(psoDst->iType == STYPE_BITMAP)
    {
        DISPDBG((4, "DrvGradientFill: destination is a DIB - "
                    "punt back to GDI"));
        goto punt;
    }

    if((pdsurf->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvGradientFill: destination is a DFB "
                         "now in host memory - punt back to GDI"));
        goto punt;
    }

    if(ulMode == GRADIENT_FILL_TRIANGLE)
    {
        DISPDBG((DBGLVL, "DrvGradientFill: don't support triangular fills"));
        goto punt;
    }

//@@BEGIN_DDKSPLIT
    /* ignore pxlo: source is always in 16:16:16:16 format
    if(pxlo->iDstType)
    {
        // xlate object is valid
        if((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL))
        {
            DISPDBG((DBGLVL, "DrvGradientFill: "
                             "don't support color translation"));
            goto punt;
        }
    }
    */
//@@END_DDKSPLIT

    VALIDATE_DD_CONTEXT;
    poh = pdsurf->poh;

    SETUP_PPDEV_OFFSETS(ppdev, pdsurf);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvGradientFill: trivial clipping"));
        bSuccess = ppdev->pgfnGradientFillRect(ppdev, 
                                               pVertex, 
                                               nVertex, 
                                               (GRADIENT_RECT *)pMesh, 
                                               nMesh, 
                                               ulMode, 
                                               prclExtents, 
                                               1);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL rcl;

        DISPDBG((DBGLVL, "DrvGradientFill: rectangular clipping"));
        bSuccess = !bIntersect(prclExtents, &pco->rclBounds, &rcl);
        if(!bSuccess)
        {
            bSuccess = ppdev->pgfnGradientFillRect(ppdev, 
                                                   pVertex, 
                                                   nVertex, 
                                                   (GRADIENT_RECT *)pMesh, 
                                                   nMesh, 
                                                   ulMode, 
                                                   &rcl, 
                                                   1);
        }
    }
    else
    {
        CLIPENUM    ce;
        LONG        crcl;
        BOOL        bMore;

        DISPDBG((DBGLVL, "DrvGradientFill: complex clipping"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
            crcl = cIntersect(prclExtents, ce.arcl, ce.c);
            if(crcl)
            {
                bSuccess = ppdev->pgfnGradientFillRect(ppdev, 
                                                       pVertex, 
                                                       nVertex, 
                                                       (GRADIENT_RECT *)pMesh, 
                                                       nMesh, 
                                                       ulMode, 
                                                       ce.arcl, 
                                                       crcl);
            }
        } while(bMore && bSuccess);
    }

    DISPDBG((DBGLVL, "DrvGradientFill done, bSuccess = %d", bSuccess));
    if(bSuccess)
    {
        return(bSuccess);
    }

punt:

    DISPDBG((DBGLVL, "DrvGradientFill: calling EngGradientFill"));

    if(psoDstOrig->iType != STYPE_BITMAP)
    {
        if(!glintInfo->GdiCantAccessFramebuffer)
        {
            psoDstOrig = pdsurf->pso;
        }
    }

    bSuccess = EngGradientFill(psoDstOrig,
                               pco,
                               pxlo,
                               pVertex,
                               nVertex,
                               pMesh,
                               nMesh,
                               prclExtents, 
                               pptlDitherOrg,
                               ulMode);
    return(bSuccess);
}

//*****************************************************************************
// FUNC: DrvTransparentBlt
// ARGS: psoDst (I) - destination surface
//       psoSrc (I) - sources surface
//       pco (I) - destination clipping
//       pxlo (I) - color translation from source to destination
//       prclDst (I) - destination rectangle
//       prclSrc (I) - source rectangle
//       iTransColor (I) - transparent color
// RETN: TRUE if successful
//-----------------------------------------------------------------------------
// Performs a chroma-keyed COPY blt. Source and Destination are guaranteed not
// to overlap.
//*****************************************************************************

BOOL DrvTransparentBlt(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
RECTL    *prclSrc,
ULONG     iTransColor,
ULONG     ulReserved)
{
    SURFOBJ *psoDstOrig = psoDst;
    SURFOBJ *psoSrcOrig = psoSrc;
    PDEV    *ppdev;
    DSURF   *pdsurfSrc, *pdsurfDst;
    OH      *pohSrc, *pohDst;
    ULONG   cxSrc, cySrc, cxDst, cyDst;
    POINTL  ptlSrc;
    BOOL    bSuccess = FALSE;
    GLINT_DECL_VARS;

    DISPDBG((DBGLVL, "DrvTransparentBlt entered"));

    if ((psoSrc->iType == STYPE_BITMAP) &&
        (psoDst->iType == STYPE_BITMAP))
    {
        // we can't obtain any valid ppdev from this
        goto punt_error;
    }

    if (psoSrc->iType != STYPE_BITMAP)
    {
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;
        ppdev = (PDEV *)psoSrc->dhpdev;
    }
    if (psoDst->iType != STYPE_BITMAP)
    {
        pdsurfDst = (DSURF *)psoDst->dhsurf;
        ppdev = (PDEV *)psoDst->dhpdev;
    }

    GLINT_DECL_INIT;

    if (ppdev->pgfnTransparentBlt == NULL)
    {
        // we don't accelerate this function
        goto punt;
    }

    if (psoSrc->iType == STYPE_BITMAP)
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: don't support downloads"));
        goto punt;
    }

    if (psoDst->iType == STYPE_BITMAP)
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: don't support uploads"));
        goto punt;
    }

    if (pxlo && !(pxlo->flXlate & XO_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: don't support xlates"));
        goto punt;
    }

    // screen-to-screen blt
    // ensure both surfaces are in the framebuffer

    if((pdsurfSrc->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: source is a DFB now "
                         "in host memory - punt back to GDI"));
        goto punt;
    }

    if((pdsurfDst->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: destination is a DFB "
                         "now in host memory - punt back to GDI"));
        goto punt;
    }

    cxSrc = prclSrc->right - prclSrc->left;
    cySrc = prclSrc->bottom - prclSrc->top;
    cxDst = prclDst->right - prclDst->left;
    cyDst = prclDst->bottom - prclDst->top;

    if ((cxSrc != cxDst) || (cySrc != cyDst))
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: only support 1:1 blts "
                         "cxySrc(%d,%d) cxyDst(%d,%d)", 
                         cxSrc, cySrc, cxDst, cyDst));
        goto punt;
    }

    GLINT_DECL_INIT;
    VALIDATE_DD_CONTEXT;

    // destination surface base offset plus x offset from that
    pohDst = pdsurfDst->poh;
    pohSrc = pdsurfSrc->poh;

    SETUP_PPDEV_SRC_AND_DST_OFFSETS(ppdev, pdsurfSrc, pdsurfDst);

    ptlSrc.x = prclSrc->left + pohSrc->x;
    ptlSrc.y = prclSrc->top;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvTransparentBlt: trivial clipping"));
        bSuccess = ppdev->pgfnTransparentBlt(ppdev, prclDst, &ptlSrc, 
                                                iTransColor, prclDst, 1);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL rcl;

        DISPDBG((DBGLVL, "DrvTransparentBlt: rectangular clipping"));
        bSuccess = !bIntersect(prclDst, &pco->rclBounds, &rcl);
        if (!bSuccess)
        {
            bSuccess = ppdev->pgfnTransparentBlt(ppdev, prclDst, &ptlSrc, 
                                                    iTransColor, &rcl, 1);
        }
    }
    else
    {
        CLIPENUM    ce;
        LONG        crcl;
        BOOL        bMore;

        DISPDBG((DBGLVL, "DrvTransparentBlt: complex clipping"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
            crcl = cIntersect(prclDst, ce.arcl, ce.c);
            if(crcl)
            {
                bSuccess = ppdev->pgfnTransparentBlt(ppdev,prclDst, &ptlSrc, 
                                                        iTransColor, ce.arcl, 
                                                                        crcl);
            }
        } while(bMore && bSuccess);
    }

    DISPDBG((DBGLVL, "DrvTransparentBlt done, bSuccess = %d", bSuccess));

    if(bSuccess)
    {
        return(bSuccess);
    }

punt:

    DISPDBG((DBGLVL, "DrvTransparentBlt: calling EngTransparentBlt"));

    if(psoDstOrig->iType != STYPE_BITMAP)
    {
        if(!glintInfo->GdiCantAccessFramebuffer)
            psoDstOrig = pdsurfDst->pso;
    }

    if(psoSrcOrig->iType != STYPE_BITMAP)
    {
        if(!glintInfo->GdiCantAccessFramebuffer)
            psoSrcOrig = pdsurfSrc->pso;
    }

punt_error:
    bSuccess = EngTransparentBlt(psoDstOrig,
                                 psoSrcOrig,
                                 pco,
                                 pxlo,
                                 prclDst,
                                 prclSrc,
                                 iTransColor,
                                 ulReserved);

    return(bSuccess);
}

//*****************************************************************************
// FUNC: DrvAlphaBlend
// ARGS: psoDst (I) - destination surface
//       psoSrc (I) - sources surface
//       pco (I) - destination clipping
//       pxlo (I) - color translation from source to destination
//       prclDst (I) - destination rectangle
//       prclSrc (I) - source rectangle
//       pBlendObj (I) - specifies the type of alpha blending
// RETN: TRUE if successful
//-----------------------------------------------------------------------------
// Performs a blt with alpha blending. There are three types of blend 
// operation:-
// 1.) Source has constant alpha. Each destination color component is 
//     calculated using the common blend function:-
//     dC = sC.cA + dC(1 - cA)
// 2.) Source has per pixel alpha. The source is guaranteed to be 32 bits and
//     to have been premultiplied with its alpha. Each destination color 
//     component is calculated using the premult blend function:-
//     dC = sC + dC(1 - sA)
// 3.) Source has per pixel alpha and constant alpha. The source is guaranteed
//     to be 32 bits and to have been premultiplied with its alpha. The 
//     calculation is in two stages, first we calculate the transient value of
//     each component by multiplying the source with the constant alpha:-
//     tC = sC * cA
//     Next, we blend the destination with the premultiplied transient value:-
//     dC = tC + dC(1 - tA)
// 
// dC = destination component, sC = source component, tC = transient component
// cA = constant alpha, sA = source alpha, tA = transient alpha
//*****************************************************************************

BOOL DrvAlphaBlend(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo, 
RECTL    *prclDst,
RECTL    *prclSrc,
BLENDOBJ *pBlendObj)
{  
    SURFOBJ *psoDstOrig = psoDst;
    SURFOBJ *psoSrcOrig = psoSrc;
    PDEV    *ppdev;
    DSURF   *pdsurfDst, *pdsurfSrc;
    OH      *pohDst, *pohSrc;
    ULONG   cxSrc, cySrc, cxDst, cyDst;
    POINTL  ptlSrc;
    CLIPENUM ce;
    BOOL     bMore;
    LONG     crcl;
    BOOL     bSuccess = FALSE;
    GLINT_DECL_VARS;

    DISPDBG((DBGLVL, "DrvAlphaBlend entered"));

    if ((psoSrc->iType == STYPE_BITMAP) &&
        (psoDst->iType == STYPE_BITMAP))
    {
        // we can't obtain any valid ppdev from this
        goto punt_error;
    }

    if (psoSrc->iType != STYPE_BITMAP)
    {
        pdsurfSrc = (DSURF *)psoSrc->dhsurf;
        ppdev = (PDEV *)psoSrc->dhpdev;
    }

    if (psoDst->iType != STYPE_BITMAP)
    {
        pdsurfDst = (DSURF *)psoDst->dhsurf;
        ppdev = (PDEV *)psoDst->dhpdev;
    }

    GLINT_DECL_INIT;

    if (ppdev->pgfnAlphaBlend == NULL)
    {
        // we don't accelerate this function
        goto punt;
    }

    if (psoSrc->iType == STYPE_BITMAP)
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: don't support downloads"));
        goto punt;
    }

    if (psoDst->iType == STYPE_BITMAP)
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: don't support uploads"));
        goto punt;
    }

    if (pxlo && !(pxlo->flXlate & XO_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: don't support xlates"));
        goto punt;
    }

    // screen-to-screen blt
    // ensure both surfaces are in the framebuffer

    if((pdsurfSrc->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: source is a DFB now in host memory "
                         "- punt back to GDI"));
        goto punt;
    }

    if((pdsurfDst->dt & DT_SCREEN) == 0)
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: destination is a DFB now in host "
                         "memory - punt back to GDI"));
        goto punt;
    }

    cxSrc = prclSrc->right - prclSrc->left;
    cySrc = prclSrc->bottom - prclSrc->top;
    cxDst = prclDst->right - prclDst->left;
    cyDst = prclDst->bottom - prclDst->top;

    if((cxSrc != cxDst) || (cySrc != cyDst))
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: only support 1:1 blts "
                         "cxySrc(%d,%d) cxyDst(%d,%d)", 
                         cxSrc, cySrc, cxDst, cyDst));
        goto punt;
    }

    GLINT_DECL_INIT;
    VALIDATE_DD_CONTEXT;

    // destination surface base offset plus x offset from that
    pohDst = pdsurfDst->poh;
    pohSrc = pdsurfSrc->poh;

    SETUP_PPDEV_SRC_AND_DST_OFFSETS(ppdev, pdsurfSrc, pdsurfDst);

    ptlSrc.x = prclSrc->left + pohSrc->x;
    ptlSrc.y = prclSrc->top;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: trivial clipping"));
        bSuccess = ppdev->pgfnAlphaBlend(ppdev, prclDst, &ptlSrc, pBlendObj, 
                                                                   prclDst, 1);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL rcl;

        DISPDBG((DBGLVL, "DrvAlphaBlend: rectangular clipping"));
        bSuccess = !bIntersect(prclDst, &pco->rclBounds, &rcl);
        if (!bSuccess)
        {
            bSuccess = ppdev->pgfnAlphaBlend(ppdev, prclDst, &ptlSrc, 
                                                    pBlendObj, &rcl, 1);
        }
    }
    else
    {
        DISPDBG((DBGLVL, "DrvAlphaBlend: complex clipping"));
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof ce, (ULONG *)&ce);
            crcl = cIntersect(prclDst, ce.arcl, ce.c);
            if(crcl)
            {
                bSuccess = ppdev->pgfnAlphaBlend(ppdev,prclDst, &ptlSrc, 
                                                    pBlendObj, ce.arcl, crcl);
            }
        } while(bMore && bSuccess);
    }

    DISPDBG((DBGLVL, "DrvAlphaBlend done, bSuccess = %d", bSuccess));

    if (bSuccess)
    {
        return(bSuccess);
    }

punt:

    DISPDBG((DBGLVL, "DrvAlphaBlend: calling EngAlphaBlend"));

    if (psoDstOrig->iType != STYPE_BITMAP)
    {
        if (!glintInfo->GdiCantAccessFramebuffer)
            psoDstOrig = pdsurfDst->pso;
    }

    if (psoSrcOrig->iType != STYPE_BITMAP)
    {
        if (!glintInfo->GdiCantAccessFramebuffer)
            psoSrcOrig = pdsurfSrc->pso;
    }

punt_error:

    bSuccess = EngAlphaBlend(psoDstOrig,
                             psoSrcOrig,
                             pco,
                             pxlo,
                             prclDst,
                             prclSrc,
                             pBlendObj);

    return(bSuccess);
}

#endif //(_WIN32_WINNT >= 0x500)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\color.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData); // # of vertices with more than zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\brush.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Brush.c
*
* Content: Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

/////////////////////////////////////////////////////////////////////////////
//
//  bDeviceBrush[SurfaceBpp][PatternBpp]
//
//  0   1       2       3       4       5       6       7       8
//  0   1BPP    4BPP    8BPP    16BPP   24BPP   32BPP   4RLE    8RLE (brush)
//
BOOL bDeviceBrush[BMF_8RLE + 1][BMF_8RLE + 1] = 
{
    {0, 0,      0,      0,      0,      0,      0,      0,      0   }, // 0
    {0, 1,      0,      0,      0,      0,      0,      0,      0   }, // 1bpp
    {0, 0,      0,      0,      0,      0,      0,      0,      0   }, // 4bpp
    {0, 1,      0,      1,      1,      0,      0,      0,      0   }, // 8bpp
    {0, 1,      0,      1,      1,      0,      0,      0,      0   }, // 16bpp
    {0, 1,      0,      0,      0,      0,      0,      0,      0   }, // 24bpp (screen)
    {0, 1,      0,      0,      0,      0,      0,      0,      0   }, // 32bpp
    {0, 0,      0,      0,      0,      0,      0,      0,      0   }, // 4RLE
    {0, 0,      0,      0,      0,      0,      0,      0,      0   }  // 8RLE
};

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It is called by GDI when we've called BRUSHOBJ_pvGetRbrush
* in some other function like DrvBitBlt, and GDI doesn't happen have a cached
* realization lying around.
*
* Input:
*
*   ppdev->bRealizeTransparent -- Hint for whether or not the brush should be
*                              realized for transparency.  If this hint is
*                              wrong, there will be no error, but the brush
*                              will have to be unnecessarily re-realized.
*
* Note: You should always set 'ppdev->bRealizeTransparent' before calling
*       BRUSHOBJ_pvGetRbrush!
*
\**************************************************************************/

BOOL
DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    static ULONG iBrushUniq = 0;
    PDEV*   ppdev = (PDEV*) psoDst->dhpdev;
    ULONG   iPatternFormat;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    USHORT* pusDst;
    LONG    lSrcDelta;
    LONG    cj;
    LONG    i;
    LONG    j;
    RBRUSH* prb;
    ULONG*  pulXlate;
    GLINT_DECL;

    DISPDBG((DBGLVL, "DrvRealizeBrush called for pbo 0x%08X", pbo));

    if( iHatch & RB_DITHERCOLOR )
    {
        // Let GDI to handle this brush.
        goto ReturnFalse;
    }

    iPatternFormat = psoPattern->iBitmapFormat;

    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
    {
        goto ReturnFalse;
    }

    if (bDeviceBrush[ppdev->iBitmapFormat][iPatternFormat])
    {
        prb = BRUSHOBJ_pvAllocRbrush(pbo,
                                     sizeof(RBRUSH) +
                                     (TOTAL_BRUSH_SIZE << ppdev->cPelSize));
        if( prb == NULL )
        {
            goto ReturnFalse;
        }

        // Initialize the fields we need:

        prb->ptlBrushOrg.x = LONG_MIN;
        prb->iUniq         = ++iBrushUniq;
        prb->fl            = 0;
        prb->apbe          = NULL;

        lSrcDelta = psoPattern->lDelta;
        pjSrc     = (BYTE*) psoPattern->pvScan0;
        pjDst     = (BYTE*) &prb->aulPattern[0];

        if (ppdev->iBitmapFormat == iPatternFormat)
        {
            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                DISPDBG((DBGLVL, "Realizing un-translated brush"));

                // The pattern is the same colour depth as the screen, and
                // there's no translation to be done:

                cj = (8 << ppdev->cPelSize);    // Every pattern is 8 pels wide

                for (i = 8; i != 0; i--)
                {
                    RtlCopyMemory(pjDst, pjSrc, cj);
                    pjSrc += lSrcDelta;
                    pjDst += cj;
                }
            }
            else if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                DISPDBG((DBGLVL, "Realizing 8bpp translated brush"));

                // The screen is 8bpp, and there's translation to be done:

                pulXlate = pxlo->pulXlate;

                for (i = 8; i != 0; i--)
                {
                    for (j = 8; j != 0; j--)
                    {
                        *pjDst++ = (BYTE) pulXlate[*pjSrc++];
                    }

                    pjSrc += lSrcDelta - 8;
                }
            }
            else
            {
                goto ReturnFalse;
            }
        }
        else if (iPatternFormat == BMF_1BPP)
        {
            DWORD   Data;

            DISPDBG((DBGLVL, "Realizing 1bpp brush"));

            // We dword align the monochrome bitmap so that every row starts
            // on a new long (so that we can do long writes later to transfer
            // the bitmap to the area stipple unit).

            for (i = 8; i != 0; i--)
            {
                // Replicate the brush to 32 bits wide, as the TX cannot
                // span fill 8 bit wide brushes

                Data = (*pjSrc) & 0xff;
                Data |= Data << 8;
                Data |= Data << 16;
                *(DWORD *)pjDst = Data;

                // area stipple is loaded with DWORDS

                pjDst += sizeof(DWORD);
                pjSrc += lSrcDelta;
            }

            pulXlate         = pxlo->pulXlate;
            prb->fl         |= RBRUSH_2COLOR;
            prb->ulForeColor = pulXlate[1];
            prb->ulBackColor = pulXlate[0];
        }
        else if ((iPatternFormat == BMF_4BPP) &&
                 (ppdev->iBitmapFormat == BMF_8BPP))
        {
            DISPDBG((DBGLVL, "Realizing 4bpp brush"));

            // The screen is 8bpp and the pattern is 4bpp:

            pulXlate = pxlo->pulXlate;

            for (i = 8; i != 0; i--)
            {
                // Inner loop is repeated only 4 times because each iteration
                // handles 2 pixels:

                for (j = 4; j != 0; j--)
                {
                    *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                    *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
                    pjSrc++;
                }

                pjSrc += lSrcDelta - 4;
            }
        }
        else if ((iPatternFormat == BMF_8BPP) &&
                 (ppdev->iBitmapFormat == BMF_16BPP))
        {
            DISPDBG((DBGLVL, "Realizing 8bpp translated brush"));

            // The screen is 16bpp, and there's translation to be done:

            pulXlate = pxlo->pulXlate;

            for (i = 8; i != 0; i--)
            {
                for (j = 8; j != 0; j--)
                {
                    *((USHORT *) pjDst) = (USHORT)pulXlate[*pjSrc++];
                    pjDst += 2;
                }

                pjSrc += lSrcDelta - 8;
            }
        }
        else
        {
            goto ReturnFalse;
        }

        DISPDBG((DBGLVL, "DrvRealizeBrush returning true"));
        return TRUE;
    }

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((WRNLVL, "Failed realization -- "
                         "Type: %li Format: %li cx: %li cy: %li",
                          psoPattern->iType, 
                          psoPattern->iBitmapFormat,
                          psoPattern->sizlBitmap.cx, 
                          psoPattern->sizlBitmap.cy));
    }

    DISPDBG((DBGLVL, "DrvRealizeBrush returning false"));

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\ddraw.c ===
/******************************Module*Header**********************************\
*
*                           *************************
*                           * GDI/DDRAW SAMPLE CODE *
*                           *************************
*
* Module Name: ddraw.c
*
* Content: Provides interfaces back from the DDRAW .lib file into the main NT driver
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

#if WNT_DDRAW

// The code inside this WNT_DDRAW ifdef is code that interfaces between the DirectDraw
// core (as ported from Win 95) and the Win NT display driver.

/*
 *  vNTSyncWith2DDriver ()
 *    --------------------------
 *
 *      Sync DirectDraw with every other subsystem: 2D driver . We
 *      put it in a function to get at the correct data structures.
 */

VOID vNTSyncWith2DDriver(PPDEV ppdev)
{
    GLINT_DECL;
    SYNC_WITH_GLINT;
}

// if we're expecting to use the vblank interrupt but the adapter hasn't been allocated an 
// interrupt, we'll need to provide temporary storage for values that would otherwise have been
// stored within the interrupt block

ULONG gulOverlayEnabled;
ULONG gulVBLANKUpdateOverlay;
ULONG gulVBLANKUpdateOverlayWidth;
ULONG gulVBLANKUpdateOverlayHeight;    

/*
 *  bSetupOffscreenForDDraw ()
 *    --------------------------
 *
 *      This function enables and disables the Display Driver's off-screen video memory.
 *      This allows DirectDraw to take control of the off-screen memory and to
 *      create it's linear heap in the memory.
 *
 *      Note: only implemented for Permedia.
 */

BOOL bSetupOffscreenForDDraw(
BOOL             enableFlag,
PPDEV            ppdev,
volatile DWORD **VBlankAddress,
volatile DWORD **bOverlayEnabled,
volatile DWORD **VBLANKUpdateOverlay,
volatile DWORD **VBLANKUpdateOverlayWidth, 
volatile DWORD **VBLANKUpdateOverlayHeight)
{
    BOOL retVal = TRUE;
    PINTERRUPT_CONTROL_BLOCK pBlock;
    GLINT_DECL;

    DISPDBG((DBGLVL, "bSetupOffscreenForDDraw: in addr 0x%x", VBlankAddress));

    if (enableFlag)
    {
        if((ppdev->flStatus & STAT_LINEAR_HEAP) == 0)
        {
            // disabling DDraw, reenabling 2D offscreeen
            vEnable2DOffscreenMemory(ppdev);
        }

        // Get pointer to interrupt command block

        pBlock = glintInfo->pInterruptCommandBlock;

        // Reset the interrupt flags

        if (INTERRUPTS_ENABLED && (pBlock->Control & DIRECTDRAW_VBLANK_ENABLED))
        {
            // Clear the flag to stop the interrupt routine setting the 
            // flag in the shared structure
            pBlock->Control &= ~DIRECTDRAW_VBLANK_ENABLED;

            // clear VBLANK flag or we'll get an immediate interrupt
            WRITE_GLINT_CTRL_REG(IntFlags,  INTR_CLEAR_VBLANK);

            // Re-instate the original flags
            WRITE_GLINT_CTRL_REG(IntEnable, ppdev->oldIntEnableFlags);
        }
    }
    else
    {
        // enabling DDraw, disabling 2D offscreen
        // We zap off-screen memory chunks on Permedia, only if there
        // aren't any OGL apps running.
        {
            // There aren't any OGL apps running, so grab all the
            // memory for DDraw
            if(ppdev->flStatus & ENABLE_LINEAR_HEAP)
            {
                // DX managed linear heap - we don't need to do anything
                // NB. check against whether we have the capability to use the linear heap, rather than
                //     whether it's currently enabled as it's only enabled much later, in DrvNotify
                retVal = TRUE;
            }
            else
                retVal = bDisable2DOffscreenMemory(ppdev);

            if (retVal == TRUE)
            {
                // We return a pointer to a 'long' which DirectDraw can
                // poll to see if it is zero or not.
                if (VBlankAddress != NULL)
                {
                    DWORD   enableFlags;

                    *VBlankAddress = NULL;

                    if (INTERRUPTS_ENABLED)
                    {
                        // Get pointer to interrupt command block
                        pBlock = glintInfo->pInterruptCommandBlock;

                        // Indicate that we require the miniport to
                        // set a flag for us
                        pBlock->Control |= DIRECTDRAW_VBLANK_ENABLED;

                        // clear VBLANK flag or we'll get an immediate interrupt
                        WRITE_GLINT_CTRL_REG(IntFlags,  INTR_CLEAR_VBLANK);
  
                        // enable the VBLANK interrupt
                        READ_GLINT_CTRL_REG (IntEnable, enableFlags);
                        WRITE_GLINT_CTRL_REG(IntEnable, enableFlags | INTR_ENABLE_VBLANK);

                        // Save the old interrupt flags so that we can restore them
                        ppdev->oldIntEnableFlags = enableFlags;

                        // Set up pointers into the shared memory
                        *VBlankAddress = &pBlock->DDRAW_VBLANK;
                        *bOverlayEnabled = &pBlock->bOverlayEnabled;
                        *VBLANKUpdateOverlay = &pBlock->bVBLANKUpdateOverlay;
                        *VBLANKUpdateOverlayWidth = &pBlock->VBLANKUpdateOverlayWidth;
                        *VBLANKUpdateOverlayHeight = &pBlock->VBLANKUpdateOverlayHeight;
                    }
                    else
                    {
                        *bOverlayEnabled = &gulOverlayEnabled;
                        *VBLANKUpdateOverlay = &gulVBLANKUpdateOverlay;
                        *VBLANKUpdateOverlayWidth = &gulVBLANKUpdateOverlayWidth;
                        *VBLANKUpdateOverlayHeight = &gulVBLANKUpdateOverlayHeight;
                    }

                    DISPDBG((DBGLVL, "bSetupOffscreenForDDraw: configured ptr 0x%x", *VBlankAddress));
                }
            }
        }
    }

    DISPDBG((DBGLVL, "bSetupOffscreenForDDraw: exit %d", retVal));

    return (retVal);
}

/*
 *  GetChipInfoForDDraw ()
 *    ----------------------
 *
 *      A simple helper function to return chip information to DirectDraw
 */

VOID GetChipInfoForDDraw(
PPDEV    ppdev,
DWORD*   pdwChipID,
DWORD*   pdwChipRev,
DWORD*   pdwChipFamily,
DWORD*   pdwGammaRev)
{
    GLINT_DECL;
    
    DISPDBG((DBGLVL,"*** In GetChipInfoForDDraw"));
    DISPDBG((DBGLVL," Chip is PXRX Family"));

    *pdwChipFamily = PERMEDIA3_ID;
    *pdwChipID     = glintInfo->deviceInfo.DeviceId;
    *pdwChipRev    = glintInfo->deviceInfo.RevisionId;
    *pdwGammaRev   = glintInfo->deviceInfo.GammaRevId;
}

/*
 *  GetFBLBInfoForDDraw ()
 *    ----------------------
 *
 *      Return some basic framnebuffer/localbuffer info to DirectDraw.
 */

VOID GetFBLBInfoForDDraw(
PPDEV    ppdev, 
void   **fbPtr,            // Framebuffer pointer
void   **lbPtr,            // Localbuffer pointer
DWORD   *fbSizeInBytes,    // Size of framebuffer
DWORD   *lbSizeInBytes,    // Size of localbuffer
DWORD   *fbOffsetInBytes,  // Offset to 1st 'free' byte in framebuffer
BOOL    *bSDRAM)           // TRUE if SDRAM (i.e. no h/w write mask)
{
    GLINT_DECL;

    *fbPtr = ppdev->pjScreen;                            
    *lbPtr = NULL;                            // We don't know this one
    *fbSizeInBytes = ppdev->FrameBufferLength;
    *lbSizeInBytes = TEXTURE_MEMORY_SIZE;
    *fbOffsetInBytes = ppdev->heap.DDrawOffscreenStart * ppdev->cjPelSize;

    *bSDRAM = (GLINT_HW_WRITE_MASK == FALSE);

    DISPDBG((DBGLVL, "GetFBLBInfoForDDraw: offstart 0x%x, buf[1] 0x%lx, pelsz %d",
                            ppdev->heap.DDrawOffscreenStart, 
                            GLINT_BUFFER_OFFSET(1), 
                            ppdev->cjPelSize));
}


// DDSendDMAData
// Uses DMA to transfer one complete buffer of DDRAW data
// under NT5.
// Before initiating DMA transfer, a check is made to ensure
// that any previous DMA transfer has completed.
// Then the DMA is initiated and the routine returns, so that
// the DMA transfer proceeds in parallel with the processor's
// proceeding execution.

LONG DDSendDMAData(
PDEV*       ppdev,
ULONG       PhysAddr,
ULONG_PTR   VirtAddr,
LONG        nDataEntries)
{
    ULONG   frontIndex, nextIndex;
    volatile ULONG ulValue;

    GLINT_DECL ;

    // PhysAddr += DataOffset;
    // VirtAddr += DataOffset;

    DISPDBG((DBGLVL, "DMASendData: DMA at 0x%x for %d", PhysAddr, nDataEntries));

    ppdev->g_GlintBoardStatus &= ~GLINT_DMA_COMPLETE;

    if (ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT)
    {
        PINTERRUPT_CONTROL_BLOCK pBlock = glintInfo->pInterruptCommandBlock;

        DISPDBG((DBGLVL, "Processing buffer at 0x%x for %d", PhysAddr, nDataEntries));
        DISPDBG((DBGLVL, "Adding buffer to Q"));
        frontIndex = pBlock->frontIndex;
        if ((nextIndex = frontIndex+1) == pBlock->endIndex)
            nextIndex = 0;

        // wait for a free queue entry. We should really do a backoff here.
        while (nextIndex == pBlock->backIndex);

        DISPDBG((DBGLVL, "Add to DMA Q backindex %d frontindex %d",frontIndex, pBlock->backIndex));

        // add the DMA address and count to the new entry.
        pBlock->dmaQueue[frontIndex].address = PhysAddr;
        pBlock->dmaQueue[frontIndex].count = nDataEntries;
        pBlock->frontIndex = nextIndex;

        // wakeup the interrupt handler using an error interrupt. To save on
        // interrupt processing, only do this if a DMA interrupt is not
        // pending.
        //
        //if (!pBlock->InterruptPending)
        {
            DISPDBG((DBGLVL, "Generating error interrupt"));
            WRITE_GLINT_CTRL_REG(ErrorFlags, 0x7);  // clear error flags
            READ_OUTPUT_FIFO(ulValue);              // generate interrupt
        }
    }
    else
    {
        WAIT_IMMEDIATE_DMA_COMPLETE;
        SET_DMA_ADDRESS(PhysAddr, VirtAddr) ;
        SET_DMA_COUNT(nDataEntries);
    }

    DISPDBG((DBGLVL,"DMA count=%d\n", nDataEntries )) ;
    
    return 1 ;
}

// Wrapper function used for requesting a DMA memory buffer 
// from NT for use by D3D. NT 5 only.

LONG DDGetFreeDMABuffer(
DWORD     *physAddr,
ULONG_PTR *virtAddr,
DWORD     *bufferSize)
{
    LONG BuffNum;
    QUERY_DMA_BUFFERS dmaBuffer;
    
    BuffNum = GetFreeDMABuffer(&dmaBuffer);

    if (BuffNum >= 0)
    {
        *physAddr = (DWORD)dmaBuffer.physAddr.LowPart;
        *virtAddr = (ULONG_PTR)dmaBuffer.virtAddr;
        *bufferSize = (DWORD)dmaBuffer.size;
    }
    else
    {
        // Failed to get a free DMA buffer
        *physAddr = 0;
        *virtAddr = 0;
        *bufferSize = 0;
    }
    return BuffNum;
}

// Frees the given DMA buffer.

VOID DDFreeDMABuffer(void* pPhysAddress)
{
    FreeDMABuffer(pPhysAddress);
    return;
}

LONG DDWaitDMAComplete(PDEV *ppdev)
{
    GLINT_DECL ;
    WAIT_DMA_COMPLETE;
    return 0;
}

#endif  WNT_DDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\dbgtags.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Dbgtags.c
*
* Content: Debugging support code
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
*****************************************************************************/

#include <precomp.h>

const char *p3r3TagString( ULONG tag ) {
    switch( tag ) {
        case 0x000: return "StartXDom                      ";
        case 0x001: return "dXDom                          ";
        case 0x002: return "StartXSub                      ";
        case 0x003: return "dXSub                          ";
        case 0x004: return "StartY                         ";
        case 0x005: return "dY                             ";
        case 0x006: return "Count                          ";
        case 0x007: return "Render                         ";
        case 0x008: return "ContinueNewLine                ";
        case 0x009: return "ContinueNewDom                 ";
        case 0x00A: return "ContinueNewSub                 ";
        case 0x00B: return "Continue                       ";
        case 0x00C: return "FlushSpan                      ";
        case 0x00D: return "BitMaskPattern                 ";
        case 0x010: return "PointTable0                    ";
        case 0x011: return "PointTable1                    ";
        case 0x012: return "PointTable2                    ";
        case 0x013: return "PointTable3                    ";
        case 0x014: return "RasterizerMode                 ";
        case 0x015: return "YLimits                        ";
        case 0x016: return "ScanlineOwnership              ";
        case 0x017: return "WaitForCompletion              ";
        case 0x018: return "PixelSize                      ";
        case 0x019: return "StripeOffsetY                  ";
        case 0x026: return "FastBlockLimits                ";
        case 0x030: return "ScissorMode                    ";
        case 0x031: return "ScissorMinXY                   ";
        case 0x032: return "ScissorMaxXY                   ";
        case 0x033: return "ScreenSize                     ";
        case 0x034: return "AreaStippleMode                ";
        case 0x035: return "LineStippleMode                ";
        case 0x036: return "LoadLineStippleCounters        ";
        case 0x037: return "UpdateLineStippleCounters      ";
        case 0x038: return "SaveLineStippleState           ";
        case 0x039: return "WindowOrigin                   ";
        case 0x040: return "AreaStipplePattern0            ";
        case 0x041: return "AreaStipplePattern1            ";
        case 0x042: return "AreaStipplePattern2            ";
        case 0x043: return "AreaStipplePattern3            ";
        case 0x044: return "AreaStipplePattern4            ";
        case 0x045: return "AreaStipplePattern5            ";
        case 0x046: return "AreaStipplePattern6            ";
        case 0x047: return "AreaStipplePattern7            ";
        case 0x048: return "AreaStipplePattern8            ";
        case 0x049: return "AreaStipplePattern9            ";
        case 0x04A: return "AreaStipplePattern10           ";
        case 0x04B: return "AreaStipplePattern11           ";
        case 0x04C: return "AreaStipplePattern12           ";
        case 0x04D: return "AreaStipplePattern13           ";
        case 0x04E: return "AreaStipplePattern14           ";
        case 0x04F: return "AreaStipplePattern15           ";
        case 0x050: return "AreaStipplePattern16           ";
        case 0x051: return "AreaStipplePattern17           ";
        case 0x052: return "AreaStipplePattern18           ";
        case 0x053: return "AreaStipplePattern19           ";
        case 0x054: return "AreaStipplePattern20           ";
        case 0x055: return "AreaStipplePattern21           ";
        case 0x056: return "AreaStipplePattern22           ";
        case 0x057: return "AreaStipplePattern23           ";
        case 0x058: return "AreaStipplePattern24           ";
        case 0x059: return "AreaStipplePattern25           ";
        case 0x05A: return "AreaStipplePattern26           ";
        case 0x05B: return "AreaStipplePattern27           ";
        case 0x05C: return "AreaStipplePattern28           ";
        case 0x05D: return "AreaStipplePattern29           ";
        case 0x05E: return "AreaStipplePattern30           ";
        case 0x05F: return "AreaStipplePattern31           ";
        case 0x060: return "FillFBWriteBufferAddr0         ";
        case 0x061: return "FillFBSourceReadBufferAddr     ";
        case 0x062: return "FillFBDestReadBufferAddr0      ";
        case 0x063: return "FillScissorMinXY               ";
        case 0x064: return "FillScissorMaxXY               ";
        case 0x065: return "FillForegroundColor0           ";
        case 0x066: return "FillBackgroundColor            ";
        case 0x067: return "FillConfig2D0                  ";
        case 0x068: return "FillFBSourceReadBufferOffset   ";
        case 0x069: return "FillRectanglePosition          ";
        case 0x06A: return "FillRender2D                   ";
        case 0x06B: return "FillForegroundColor1           ";
        case 0x06C: return "FillConfig2D1                  ";
        case 0x06D: return "FillGlyphPosition              ";
        case 0x070: return "TextureCoordMode               ";
        case 0x071: return "SStart                         ";
        case 0x072: return "dSdx                           ";
        case 0x073: return "dSdyDom                        ";
        case 0x074: return "TStart                         ";
        case 0x075: return "dTdx                           ";
        case 0x076: return "dTdyDom                        ";
        case 0x077: return "QStart                         ";
        case 0x078: return "dQdx                           ";
        case 0x079: return "dQdyDom                        ";
        case 0x07A: return "LOD                            ";
        case 0x07B: return "dSdy                           ";
        case 0x07C: return "dTdy                           ";
        case 0x07D: return "dQdy                           ";
        case 0x080: return "S1Start                        ";
        case 0x081: return "dS1dx                          ";
        case 0x082: return "dS1dyDom                       ";
        case 0x083: return "T1Start                        ";
        case 0x084: return "dT1dx                          ";
        case 0x085: return "dT1dyDom                       ";
        case 0x086: return "Q1Start                        ";
        case 0x087: return "dQ1dx                          ";
        case 0x088: return "dQ1dyDom                       ";
        case 0x089: return "LOD1                           ";
        case 0x08A: return "TextureLODBiasS                ";
        case 0x08B: return "TextureLODBiasT                ";
        case 0x090: return "TextureReadMode                ";
        case 0x091: return "TextureFormat                  ";
        case 0x092: return "TextureCacheControl            ";
        case 0x095: return "BorderColor0                   ";
        case 0x098: return "LUTIndex                       ";
        case 0x099: return "LUTData                        ";
        case 0x09A: return "LUTAddress                     ";
        case 0x09B: return "LUTTransfer                    ";
        case 0x09C: return "TextureFilterMode              ";
        case 0x09D: return "TextureChromaUpper0            ";
        case 0x09E: return "TextureChromaLower0            ";
        case 0x09F: return "BorderColor1                   ";
        case 0x0A0: return "TextureBaseAddr0               ";
        case 0x0A1: return "TextureBaseAddr1               ";
        case 0x0A2: return "TextureBaseAddr2               ";
        case 0x0A3: return "TextureBaseAddr3               ";
        case 0x0A4: return "TextureBaseAddr4               ";
        case 0x0A5: return "TextureBaseAddr5               ";
        case 0x0A6: return "TextureBaseAddr6               ";
        case 0x0A7: return "TextureBaseAddr7               ";
        case 0x0A8: return "TextureBaseAddr8               ";
        case 0x0A9: return "TextureBaseAddr9               ";
        case 0x0AA: return "TextureBaseAddr10              ";
        case 0x0AB: return "TextureBaseAddr11              ";
        case 0x0AC: return "TextureBaseAddr12              ";
        case 0x0AD: return "TextureBaseAddr13              ";
        case 0x0AE: return "TextureBaseAddr14              ";
        case 0x0AF: return "TextureBaseAddr15              ";
        case 0x0B0: return "TextureMapWidth0               ";
        case 0x0B1: return "TextureMapWidth1               ";
        case 0x0B2: return "TextureMapWidth2               ";
        case 0x0B3: return "TextureMapWidth3               ";
        case 0x0B4: return "TextureMapWidth4               ";
        case 0x0B5: return "TextureMapWidth5               ";
        case 0x0B6: return "TextureMapWidth6               ";
        case 0x0B7: return "TextureMapWidth7               ";
        case 0x0B8: return "TextureMapWidth8               ";
        case 0x0B9: return "TextureMapWidth9               ";
        case 0x0BA: return "TextureMapWidth10              ";
        case 0x0BB: return "TextureMapWidth11              ";
        case 0x0BC: return "TextureMapWidth12              ";
        case 0x0BD: return "TextureMapWidth13              ";
        case 0x0BE: return "TextureMapWidth14              ";
        case 0x0BF: return "TextureMapWidth15              ";
        case 0x0C0: return "TextureChromaUpper1            ";
        case 0x0C1: return "TextureChromaLower1            ";
        case 0x0D0: return "TextureApplicationMode         ";
        case 0x0D1: return "TextureEnvColor                ";
        case 0x0D2: return "FogMode                        ";
        case 0x0D3: return "FogColor                       ";
        case 0x0D4: return "FStart                         ";
        case 0x0D5: return "dFdx                           ";
        case 0x0D6: return "dFdyDom                        ";
        case 0x0D7: return "ZFogBias                       ";
        case 0x0E0: return "TextTGlyphAddr0                ";
        case 0x0E1: return "TextRender2DGlyph0             ";
        case 0x0E2: return "TextTGlyphAddr1                ";
        case 0x0E3: return "TextRender2DGlyph1             ";
        case 0x0E4: return "TextTGlyphAddr2                ";
        case 0x0E5: return "TextRender2DGlyph2             ";
        case 0x0E6: return "TextTGlyphAddr3                ";
        case 0x0E7: return "TextRender2DGlyph3             ";
        case 0x0E8: return "TextTGlyphAddr4                ";
        case 0x0E9: return "TextRender2DGlyph4             ";
        case 0x0EA: return "TextTGlyphAddr5                ";
        case 0x0EB: return "TextRender2DGlyph5             ";
        case 0x0EC: return "TextTGlyphAddr6                ";
        case 0x0ED: return "TextRender2DGlyph6             ";
        case 0x0EE: return "TextTGlyphAddr7                ";
        case 0x0EF: return "TextRender2DGlyph7             ";
        case 0x0F0: return "RStart                         ";
        case 0x0F1: return "dRdx                           ";
        case 0x0F2: return "dRdyDom                        ";
        case 0x0F3: return "GStart                         ";
        case 0x0F4: return "dGdx                           ";
        case 0x0F5: return "dGdyDom                        ";
        case 0x0F6: return "BStart                         ";
        case 0x0F7: return "dBdx                           ";
        case 0x0F8: return "dBdyDom                        ";
        case 0x0F9: return "AStart                         ";
        case 0x0FA: return "dAdx                           ";
        case 0x0FB: return "dAdyDom                        ";
        case 0x0FC: return "ColorDDAMode                   ";
        case 0x0FD: return "ConstantColor                  ";
        case 0x0FE: return "Color                          ";
        case 0x100: return "AlphaTestMode                  ";
        case 0x101: return "AntialiasMode                  ";
        case 0x103: return "DitherMode                     ";
        case 0x104: return "FBSoftwareWriteMask            ";
        case 0x105: return "LogicalOpMode                  ";
        case 0x108: return "RouterMode                     ";
        case 0x110: return "LBReadMode                     ";
        case 0x111: return "LBReadFormat                   ";
        case 0x112: return "LBSourceOffset                 ";
        case 0x114: return "LBSourceData                   ";
        case 0x115: return "LBStencil                      ";
        case 0x116: return "LBDepth                        ";
        case 0x117: return "LBWindowBase                   ";
        case 0x118: return "LBWriteMode                    ";
        case 0x119: return "LBWriteFormat                  ";
        case 0x11D: return "TextureData                    ";
        case 0x11E: return "TextureDownloadOffset          ";
        case 0x11F: return "LBWindowOffset                 ";
        case 0x120: return "HostInID                       ";
        case 0x121: return "Security                       ";
        case 0x122: return "FlushWriteCombining            ";
        case 0x123: return "HostInState                    ";
        case 0x127: return "HostInDMAAddress               ";
        case 0x128: return "HostInState2                   ";
        case 0x12F: return "VertexRename                   ";
        case 0x130: return "Window                         ";
        case 0x131: return "StencilMode                    ";
        case 0x132: return "StencilData                    ";
        case 0x133: return "Stencil                        ";
        case 0x134: return "DepthMode                      ";
        case 0x135: return "Depth                          ";
        case 0x136: return "ZStartU                        ";
        case 0x137: return "ZStartL                        ";
        case 0x138: return "dZdxU                          ";
        case 0x139: return "dZdxL                          ";
        case 0x13A: return "dZdyDomU                       ";
        case 0x13B: return "dZdyDomL                       ";
        case 0x13C: return "FastClearDepth                 ";
        case 0x13D: return "LBCancelWrite                  ";
        case 0x153: return "FBColor                        ";
        case 0x154: return "FBData                         ";
        case 0x155: return "FBSourceData                   ";
        case 0x157: return "FBWriteMode                    ";
        case 0x158: return "FBHardwareWriteMask            ";
        case 0x159: return "FBBlockColor                   ";
        case 0x180: return "FilterMode                     ";
        case 0x181: return "StatisticMode                  ";
        case 0x182: return "MinRegion                      ";
        case 0x183: return "MaxRegion                      ";
        case 0x184: return "ResetPickResult                ";
        case 0x185: return "MinHitRegion                   ";
        case 0x186: return "MaxHitRegion                   ";
        case 0x187: return "PickResult                     ";
        case 0x188: return "Sync                           ";
        case 0x189: return "RLEMask                        ";
        case 0x18B: return "FBBlockColorBackU              ";
        case 0x18C: return "FBBlockColorBackL              ";
        case 0x18D: return "FBBlockColorU                  ";
        case 0x18E: return "FBBlockColorL                  ";
        case 0x18F: return "SuspendUntilFrameBlank         ";
        case 0x190: return "KsRStart                       ";
        case 0x191: return "dKsRdx                         ";
        case 0x192: return "dKsRdyDom                      ";
        case 0x193: return "KsGStart                       ";
        case 0x194: return "dKsGdx                         ";
        case 0x195: return "dKsGdyDom                      ";
        case 0x196: return "KsBStart                       ";
        case 0x197: return "dKsBdx                         ";
        case 0x198: return "dKsBdyDom                      ";
        case 0x1A0: return "KdRStart                       ";
        case 0x1A1: return "dKdRdx                         ";
        case 0x1A2: return "dKdRdyDom                      ";
        case 0x1A3: return "KdGStart                       ";
        case 0x1A4: return "dKdGdx                         ";
        case 0x1A5: return "dKdGdyDom                      ";
        case 0x1A6: return "KdBStart                       ";
        case 0x1A7: return "dKdBdx                         ";
        case 0x1A8: return "dKdBdyDom                      ";
        case 0x1B8: return "ContextDump                    ";
        case 0x1B9: return "ContextRestore                 ";
        case 0x1BA: return "ContextData                    ";
        case 0x1D0: return "LUT0                           ";
        case 0x1D1: return "LUT1                           ";
        case 0x1D2: return "LUT2                           ";
        case 0x1D3: return "LUT3                           ";
        case 0x1D4: return "LUT4                           ";
        case 0x1D5: return "LUT5                           ";
        case 0x1D6: return "LUT6                           ";
        case 0x1D7: return "LUT7                           ";
        case 0x1D8: return "LUT8                           ";
        case 0x1D9: return "LUT9                           ";
        case 0x1DA: return "LUT10                          ";
        case 0x1DB: return "LUT11                          ";
        case 0x1DC: return "LUT12                          ";
        case 0x1DD: return "LUT13                          ";
        case 0x1DE: return "LUT14                          ";
        case 0x1DF: return "LUT15                          ";
        case 0x1E0: return "YUVMode                        ";
        case 0x1E1: return "ChromaUpper                    ";
        case 0x1E2: return "ChromaLower                    ";
        case 0x1E3: return "AlphaMapUpperBound             ";
        case 0x1F1: return "FeedbackX                      ";
        case 0x1F2: return "FeedbackY                      ";
        case 0x1FF: return "EndOfFeedback                  ";
        case 0x200: return "V0FloatS1                      ";
        case 0x201: return "V0FloatT1                      ";
        case 0x202: return "V0FloatQ1                      ";
        case 0x203: return "V0Reserved0                    ";
        case 0x204: return "V0Reserved1                    ";
        case 0x205: return "V0Reserved2                    ";
        case 0x206: return "V0Reserved3                    ";
        case 0x207: return "V0Reserved4                    ";
        case 0x208: return "V0Reserved5                    ";
        case 0x209: return "V0FloatPackedDiffuse           ";
        case 0x20A: return "V0FloatKsR                     ";
        case 0x20B: return "V0FloatKsG                     ";
        case 0x20C: return "V0FloatKsB                     ";
        case 0x20D: return "V0FloatKdR                     ";
        case 0x20E: return "V0FloatKdG                     ";
        case 0x20F: return "V0FloatKdB                     ";
        case 0x210: return "V1FloatS1                      ";
        case 0x211: return "V1FloatT1                      ";
        case 0x212: return "V1FloatQ1                      ";
        case 0x213: return "V1Reserved0                    ";
        case 0x214: return "V1Reserved1                    ";
        case 0x215: return "V1Reserved2                    ";
        case 0x216: return "V1Reserved3                    ";
        case 0x217: return "V1Reserved4                    ";
        case 0x218: return "V1Reserved5                    ";
        case 0x219: return "V1FloatPackedDiffuse           ";
        case 0x21A: return "V1FloatKsR                     ";
        case 0x21B: return "V1FloatKsG                     ";
        case 0x21C: return "V1FloatKsB                     ";
        case 0x21D: return "V1FloatKdR                     ";
        case 0x21E: return "V1FloatKdG                     ";
        case 0x21F: return "V1FloatKdB                     ";
        case 0x220: return "V2FloatS1                      ";
        case 0x221: return "V2FloatT1                      ";
        case 0x222: return "V2FloatQ1                      ";
        case 0x223: return "V2Reserved0                    ";
        case 0x224: return "V2Reserved1                    ";
        case 0x225: return "V2Reserved2                    ";
        case 0x226: return "V2Reserved3                    ";
        case 0x227: return "V2Reserved4                    ";
        case 0x228: return "V2Reserved5                    ";
        case 0x229: return "V2FloatPackedDiffuse           ";
        case 0x22A: return "V2FloatKsR                     ";
        case 0x22B: return "V2FloatKsG                     ";
        case 0x22C: return "V2FloatKsB                     ";
        case 0x22D: return "V2FloatKdR                     ";
        case 0x22E: return "V2FloatKdG                     ";
        case 0x22F: return "V2FloatKdB                     ";
        case 0x230: return "V0FloatS                       ";
        case 0x231: return "V0FloatT                       ";
        case 0x232: return "V0FloatQ                       ";
        case 0x233: return "V0Reserved7                    ";
        case 0x234: return "V0Reserved8                    ";
        case 0x235: return "V0FloatR                       ";
        case 0x236: return "V0FloatG                       ";
        case 0x237: return "V0FloatB                       ";
        case 0x238: return "V0FloatA                       ";
        case 0x239: return "V0FloatF                       ";
        case 0x23A: return "V0FloatX                       ";
        case 0x23B: return "V0FloatY                       ";
        case 0x23C: return "V0FloatZ                       ";
        case 0x23D: return "V0FloatW                       ";
        case 0x23E: return "V0FloatPackedColour            ";
        case 0x23F: return "V0FloatPackedSpecularFog       ";
        case 0x240: return "V1FloatS                       ";
        case 0x241: return "V1FloatT                       ";
        case 0x242: return "V1FloatQ                       ";
        case 0x243: return "V1Reserved7                    ";
        case 0x244: return "V1Reserved8                    ";
        case 0x245: return "V1FloatR                       ";
        case 0x246: return "V1FloatG                       ";
        case 0x247: return "V1FloatB                       ";
        case 0x248: return "V1FloatA                       ";
        case 0x249: return "V1FloatF                       ";
        case 0x24A: return "V1FloatX                       ";
        case 0x24B: return "V1FloatY                       ";
        case 0x24C: return "V1FloatZ                       ";
        case 0x24D: return "V1FloatW                       ";
        case 0x24E: return "V1FloatPackedColour            ";
        case 0x24F: return "V1FloatPackedSpecularFog       ";
        case 0x250: return "V2FloatS                       ";
        case 0x251: return "V2FloatT                       ";
        case 0x252: return "V2FloatQ                       ";
        case 0x253: return "V2Reserved7                    ";
        case 0x254: return "V2Reserved8                    ";
        case 0x255: return "V2FloatR                       ";
        case 0x256: return "V2FloatG                       ";
        case 0x257: return "V2FloatB                       ";
        case 0x258: return "V2FloatA                       ";
        case 0x259: return "V2FloatF                       ";
        case 0x25A: return "V2FloatX                       ";
        case 0x25B: return "V2FloatY                       ";
        case 0x25C: return "V2FloatZ                       ";
        case 0x25D: return "V2FloatW                       ";
        case 0x25E: return "V2FloatPackedColour            ";
        case 0x25F: return "V2FloatPackedSpecularFog       ";
        case 0x260: return "DeltaMode                      ";
        case 0x261: return "DrawTriangle                   ";
        case 0x262: return "RepeatTriangle                 ";
        case 0x263: return "DrawLine01                     ";
        case 0x264: return "DrawLine10                     ";
        case 0x265: return "RepeatLine                     ";
        case 0x266: return "DrawPoint                      ";
        case 0x267: return "ProvokingVertex                ";
        case 0x268: return "TextureLODScale                ";
        case 0x269: return "TextureLODScale1               ";
        case 0x26A: return "DeltaControl                   ";
        case 0x26B: return "ProvokingVertexMask            ";
        case 0x26F: return "BroadcastMask                  ";
        case 0x28B: return "DeltaTexture01                 ";
        case 0x28C: return "DeltaTexture11                 ";
        case 0x28D: return "DeltaTexture21                 ";
        case 0x28E: return "DeltaTexture31                 ";
        case 0x290: return "XBias                          ";
        case 0x291: return "YBias                          ";
        case 0x2EC: return "LineCoord0                     ";
        case 0x2ED: return "DrawLine2D10                   ";
        case 0x2EE: return "LineCoord1                     ";
        case 0x2EF: return "DrawLine2D01                   ";
        case 0x530: return "DMAAddr                        ";
        case 0x531: return "DMACount                       ";
        case 0x532: return "CommandInterrupt               ";
        case 0x535: return "DMARectangleRead               ";
        case 0x536: return "DMARectangleReadAddress        ";
        case 0x537: return "DMARectangleReadLinePitch      ";
        case 0x538: return "DMARectangleReadTarget         ";
        case 0x539: return "DMARectangleWrite              ";
        case 0x53A: return "DMARectangleWriteAddress       ";
        case 0x53B: return "DMARectangleWriteLinePitch     ";
        case 0x53C: return "DMAOutputAddress               ";
        case 0x53D: return "DMAOutputCount                 ";
        case 0x53F: return "DMAContinue                    ";
        case 0x542: return "DMAFeedback                    ";
        case 0x55A: return "DeltaModeAnd                   ";
        case 0x55B: return "DeltaModeOr                    ";
        case 0x564: return "DeltaControlAnd                ";
        case 0x565: return "DeltaControlOr                 ";
        case 0x570: return "WindowAnd                      ";
        case 0x571: return "WindowOr                       ";
        case 0x572: return "LBReadModeAnd                  ";
        case 0x573: return "LBReadModeOr                   ";
        case 0x574: return "RasterizerModeAnd              ";
        case 0x575: return "RasterizerModeOr               ";
        case 0x576: return "ScissorModeAnd                 ";
        case 0x577: return "ScissorModeOr                  ";
        case 0x578: return "LineStippleModeAnd             ";
        case 0x579: return "LineStippleModeOr              ";
        case 0x57A: return "AreaStippleModeAnd             ";
        case 0x57B: return "AreaStippleModeOr              ";
        case 0x57C: return "ColorDDAModeAnd                ";
        case 0x57D: return "ColorDDAModeOr                 ";
        case 0x57E: return "AlphaTestModeAnd               ";
        case 0x57F: return "AlphaTestModeOr                ";
        case 0x580: return "AntialiasModeAnd               ";
        case 0x581: return "AntialiasModeOr                ";
        case 0x582: return "FogModeAnd                     ";
        case 0x583: return "FogModeOr                      ";
        case 0x584: return "TextureCoordModeAnd            ";
        case 0x585: return "TextureCoordModeOr             ";
        case 0x586: return "TextureReadMode0And            ";
        case 0x587: return "TextureReadMode0Or             ";
        case 0x588: return "TextureFormatAnd               ";
        case 0x589: return "TextureFormatOr                ";
        case 0x58A: return "TextureApplicationModeAnd      ";
        case 0x58B: return "TextureApplicationModeOr       ";
        case 0x58C: return "StencilModeAnd                 ";
        case 0x58D: return "StencilModeOr                  ";
        case 0x58E: return "DepthModeAnd                   ";
        case 0x58F: return "DepthModeOr                    ";
        case 0x590: return "LBWriteModeAnd                 ";
        case 0x591: return "LBWriteModeOr                  ";
        case 0x592: return "FBDestReadModeAnd              ";
        case 0x593: return "FBDestReadModeOr               ";
        case 0x594: return "FBSourceReadModeAnd            ";
        case 0x595: return "FBSourceReadModeOr             ";
        case 0x596: return "AlphaBlendColorModeAnd         ";
        case 0x597: return "AlphaBlendColorModeOr          ";
        case 0x598: return "ChromaTestModeAnd              ";
        case 0x599: return "ChromaTestModeOr               ";
        case 0x59A: return "DitherModeAnd                  ";
        case 0x59B: return "DitherModeOr                   ";
        case 0x59C: return "LogicalOpModeAnd               ";
        case 0x59D: return "LogicalOpModeOr                ";
        case 0x59E: return "FBWriteModeAnd                 ";
        case 0x59F: return "FBWriteModeOr                  ";
        case 0x5A0: return "FilterModeAnd                  ";
        case 0x5A1: return "FilterModeOr                   ";
        case 0x5A2: return "StatisticModeAnd               ";
        case 0x5A3: return "StatisticModeOr                ";
        case 0x5A4: return "FBDestReadEnablesAnd           ";
        case 0x5A5: return "FBDestReadEnablesOr            ";
        case 0x5A6: return "AlphaBlendAlphaModeAnd         ";
        case 0x5A7: return "AlphaBlendAlphaModeOr          ";
        case 0x5A8: return "TextureReadMode1And            ";
        case 0x5A9: return "TextureReadMode1Or             ";
        case 0x5AA: return "TextureFilterModeAnd           ";
        case 0x5AB: return "TextureFilterModeOr            ";
        case 0x5AE: return "LUTModeAnd                     ";
        case 0x5AF: return "LUTModeOr                      ";
        case 0x5D0: return "FBDestReadBufferAddr0          ";
        case 0x5D1: return "FBDestReadBufferAddr1          ";
        case 0x5D2: return "FBDestReadBufferAddr2          ";
        case 0x5D3: return "FBDestReadBufferAddr3          ";
        case 0x5D4: return "FBDestReadBufferOffset0        ";
        case 0x5D5: return "FBDestReadBufferOffset1        ";
        case 0x5D6: return "FBDestReadBufferOffset2        ";
        case 0x5D7: return "FBDestReadBufferOffset3        ";
        case 0x5D8: return "FBDestReadBufferWidth0         ";
        case 0x5D9: return "FBDestReadBufferWidth1         ";
        case 0x5DA: return "FBDestReadBufferWidth2         ";
        case 0x5DB: return "FBDestReadBufferWidth3         ";
        case 0x5DC: return "FBDestReadMode                 ";
        case 0x5DD: return "FBDestReadEnables              ";
        case 0x5E0: return "FBSourceReadMode               ";
        case 0x5E1: return "FBSourceReadBufferAddr         ";
        case 0x5E2: return "FBSourceReadBufferOffset       ";
        case 0x5E3: return "FBSourceReadBufferWidth        ";
        case 0x5E7: return "MergeSpanData                  ";
        case 0x5E8: return "PCIWindowBase0                 ";
        case 0x5E9: return "PCIWindowBase1                 ";
        case 0x5EA: return "PCIWindowBase2                 ";
        case 0x5EB: return "PCIWindowBase3                 ";
        case 0x5EC: return "PCIWindowBase4                 ";
        case 0x5ED: return "PCIWindowBase5                 ";
        case 0x5EE: return "PCIWindowBase6                 ";
        case 0x5EF: return "PCIWindowBase7                 ";
        case 0x5F0: return "AlphaSourceColor               ";
        case 0x5F1: return "AlphaDestColor                 ";
        case 0x5F2: return "ChromaPassColor                ";
        case 0x5F3: return "ChromaFailColor                ";
        case 0x5F4: return "AlphaBlendColorMode            ";
        case 0x5F5: return "AlphaBlendAlphaMode            ";
        case 0x5F6: return "ConstantColorDDA               ";
        case 0x5F8: return "D3DAlphaTestMode               ";
        case 0x600: return "FBWriteBufferAddr0             ";
        case 0x601: return "FBWriteBufferAddr1             ";
        case 0x602: return "FBWriteBufferAddr2             ";
        case 0x603: return "FBWriteBufferAddr3             ";
        case 0x604: return "FBWriteBufferOffset0           ";
        case 0x605: return "FBWriteBufferOffset1           ";
        case 0x606: return "FBWriteBufferOffset2           ";
        case 0x607: return "FBWriteBufferOffset3           ";
        case 0x608: return "FBWriteBufferWidth0            ";
        case 0x609: return "FBWriteBufferWidth1            ";
        case 0x60A: return "FBWriteBufferWidth2            ";
        case 0x60B: return "FBWriteBufferWidth3            ";
        case 0x60C: return "FBBlockColor0                  ";
        case 0x60D: return "FBBlockColor1                  ";
        case 0x60E: return "FBBlockColor2                  ";
        case 0x60F: return "FBBlockColor3                  ";
        case 0x610: return "FBBlockColorBack0              ";
        case 0x611: return "FBBlockColorBack1              ";
        case 0x612: return "FBBlockColorBack2              ";
        case 0x613: return "FBBlockColorBack3              ";
        case 0x614: return "FBBlockColorBack               ";
        case 0x615: return "SizeOfFramebuffer              ";
        case 0x616: return "VTGAddress                     ";
        case 0x617: return "VTGData                        ";
        case 0x618: return "ForegroundColor                ";
        case 0x619: return "BackgroundColor                ";
        case 0x61A: return "DownloadAddress                ";
        case 0x61B: return "DownloadData                   ";
        case 0x61C: return "FBBlockColorExt                ";
        case 0x61D: return "FBBlockColorBackExt            ";
        case 0x61E: return "FBWriteMaskExt                 ";
        case 0x620: return "FogTable0                      ";
        case 0x621: return "FogTable1                      ";
        case 0x622: return "FogTable2                      ";
        case 0x623: return "FogTable3                      ";
        case 0x624: return "FogTable4                      ";
        case 0x625: return "FogTable5                      ";
        case 0x626: return "FogTable6                      ";
        case 0x627: return "FogTable7                      ";
        case 0x628: return "FogTable8                      ";
        case 0x629: return "FogTable9                      ";
        case 0x62A: return "FogTable10                     ";
        case 0x62B: return "FogTable11                     ";
        case 0x62C: return "FogTable12                     ";
        case 0x62D: return "FogTable13                     ";
        case 0x62E: return "FogTable14                     ";
        case 0x62F: return "FogTable15                     ";
        case 0x630: return "FogTable16                     ";
        case 0x631: return "FogTable17                     ";
        case 0x632: return "FogTable18                     ";
        case 0x633: return "FogTable19                     ";
        case 0x634: return "FogTable20                     ";
        case 0x635: return "FogTable21                     ";
        case 0x636: return "FogTable22                     ";
        case 0x637: return "FogTable23                     ";
        case 0x638: return "FogTable24                     ";
        case 0x639: return "FogTable25                     ";
        case 0x63A: return "FogTable26                     ";
        case 0x63B: return "FogTable27                     ";
        case 0x63C: return "FogTable28                     ";
        case 0x63D: return "FogTable29                     ";
        case 0x63E: return "FogTable30                     ";
        case 0x63F: return "FogTable31                     ";
        case 0x640: return "FogTable32                     ";
        case 0x641: return "FogTable33                     ";
        case 0x642: return "FogTable34                     ";
        case 0x643: return "FogTable35                     ";
        case 0x644: return "FogTable36                     ";
        case 0x645: return "FogTable37                     ";
        case 0x646: return "FogTable38                     ";
        case 0x647: return "FogTable39                     ";
        case 0x648: return "FogTable40                     ";
        case 0x649: return "FogTable41                     ";
        case 0x64A: return "FogTable42                     ";
        case 0x64B: return "FogTable43                     ";
        case 0x64C: return "FogTable44                     ";
        case 0x64D: return "FogTable45                     ";
        case 0x64E: return "FogTable46                     ";
        case 0x64F: return "FogTable47                     ";
        case 0x650: return "FogTable48                     ";
        case 0x651: return "FogTable49                     ";
        case 0x652: return "FogTable50                     ";
        case 0x653: return "FogTable51                     ";
        case 0x654: return "FogTable52                     ";
        case 0x655: return "FogTable53                     ";
        case 0x656: return "FogTable54                     ";
        case 0x657: return "FogTable55                     ";
        case 0x658: return "FogTable56                     ";
        case 0x659: return "FogTable57                     ";
        case 0x65A: return "FogTable58                     ";
        case 0x65B: return "FogTable59                     ";
        case 0x65C: return "FogTable60                     ";
        case 0x65D: return "FogTable61                     ";
        case 0x65E: return "FogTable62                     ";
        case 0x65F: return "FogTable63                     ";
        case 0x660: return "TextureCompositeMode           ";
        case 0x661: return "TextureCompositeColorMode0     ";
        case 0x662: return "TextureCompositeAlphaMode0     ";
        case 0x663: return "TextureCompositeColorMode1     ";
        case 0x664: return "TextureCompositeAlphaMode1     ";
        case 0x665: return "TextureCompositeFactor0        ";
        case 0x666: return "TextureCompositeFactor1        ";
        case 0x667: return "TextureIndexMode0              ";
        case 0x668: return "TextureIndexMode1              ";
        case 0x669: return "LodRange0                      ";
        case 0x66A: return "LodRange1                      ";
        case 0x66B: return "InvalidateCache                ";
        case 0x66C: return "SetLogicalTexturePage          ";
        case 0x66D: return "UpdateLogicalTextureInfo       ";
        case 0x66E: return "TouchLogicalPage               ";
        case 0x66F: return "LUTMode                        ";
        case 0x670: return "TextureCompositeColorMode0And  ";
        case 0x671: return "TextureCompositeColorMode0Or   ";
        case 0x672: return "TextureCompositeAlphaMode0And  ";
        case 0x673: return "TextureCompositeAlphaMode0Or   ";
        case 0x674: return "TextureCompositeColorMode1And  ";
        case 0x675: return "TextureCompositeColorMode1Or   ";
        case 0x676: return "TextureCompositeAlphaMode1And  ";
        case 0x677: return "TextureCompositeAlphaMode1Or   ";
        case 0x678: return "TextureIndexMode0And           ";
        case 0x679: return "TextureIndexMode0Or            ";
        case 0x67A: return "TextureIndexMode1And           ";
        case 0x67B: return "TextureIndexMode1Or            ";
        case 0x67C: return "StencilDataAnd                 ";
        case 0x680: return "TextureReadMode0               ";
        case 0x681: return "TextureReadMode1               ";
        case 0x685: return "TextureMapSize                 ";
        case 0x686: return "TextureCacheReplacementMode    ";
        case 0x68D: return "StencilDataOr                  ";
        case 0x690: return "HeadPhysicalPageAllocation0    ";
        case 0x691: return "HeadPhysicalPageAllocation1    ";
        case 0x692: return "HeadPhysicalPageAllocation2    ";
        case 0x693: return "HeadPhysicalPageAllocation3    ";
        case 0x694: return "TailPhysicalPageAllocation0    ";
        case 0x695: return "TailPhysicalPageAllocation1    ";
        case 0x696: return "TailPhysicalPageAllocation2    ";
        case 0x697: return "TailPhysicalPageAllocation3    ";
        case 0x698: return "PhysicalPageAllocationTableAddr";
        case 0x699: return "BasePageOfWorkingSet           ";
        case 0x69A: return "LogicalTexturePageTableAddr    ";
        case 0x69B: return "LogicalTexturePageTableLength  ";
        case 0x69C: return "BasePageOfWorkingSetHost       ";
        case 0x6A0: return "LBDestReadMode                 ";
        case 0x6A1: return "LBDestReadEnables              ";
        case 0x6A2: return "LBDestReadBufferAddr           ";
        case 0x6A3: return "LBDestReadBufferOffset         ";
        case 0x6A4: return "LBSourceReadMode               ";
        case 0x6A5: return "LBSourceReadBufferAddr         ";
        case 0x6A6: return "LBSourceReadBufferOffset       ";
        case 0x6A7: return "GIDMode                        ";
        case 0x6A8: return "LBWriteBufferAddr              ";
        case 0x6A9: return "LBWriteBufferOffset            ";
        case 0x6AA: return "LBClearDataL                   ";
        case 0x6AB: return "LBClearDataU                   ";
        case 0x6B0: return "LBDestReadModeAnd              ";
        case 0x6B1: return "LBDestReadModeOr               ";
        case 0x6B2: return "LBDestReadEnablesAnd           ";
        case 0x6B3: return "LBDestReadEnablesOr            ";
        case 0x6B4: return "LBSourceReadModeAnd            ";
        case 0x6B5: return "LBSourceReadModeOr             ";
        case 0x6B6: return "GIDModeAnd                     ";
        case 0x6B7: return "GIDModeOr                      ";
        case 0x6C0: return "RectanglePosition              ";
        case 0x6C1: return "GlyphPosition                  ";
        case 0x6C2: return "RenderPatchOffset              ";
        case 0x6C3: return "Config2D                       ";
        case 0x6C6: return "Packed8Pixels                  ";
        case 0x6C7: return "Packed16Pixels                 ";
        case 0x6C8: return "Render2D                       ";
        case 0x6C9: return "Render2DGlyph                  ";
        case 0x6CA: return "DownloadTarget                 ";
        case 0x6CB: return "DownloadGlyphWidth             ";
        case 0x6CC: return "GlyphData                      ";
        case 0x6CD: return "Packed4Pixels                  ";
        case 0x6CE: return "RLData                         ";
        case 0x6CF: return "RLCount                        ";
        case 0x6D0: return "SClkProfileMask0               ";
        case 0x6D1: return "SClkProfileMask1               ";
        case 0x6D2: return "SClkProfileCount0              ";
        case 0x6D3: return "SClkProfileCount1              ";
        case 0x6D4: return "KClkProfileMask0               ";
        case 0x6D5: return "KClkProfileMask1               ";
        case 0x6D6: return "KClkProfileMask2               ";
        case 0x6D7: return "KClkProfileMask3               ";
        case 0x6D8: return "KClkProfileCount0              ";
        case 0x6D9: return "KClkProfileCount1              ";
        case 0x6DA: return "KClkProfileCount2              ";
        case 0x6DB: return "KClkProfileCount3              ";
        case 0x6E0: return "IndexBaseAddress               ";
        case 0x6E1: return "VertexBaseAddress              ";
        case 0x6E2: return "IndexedTriangleList            ";
        case 0x6E3: return "IndexedTriangleFan             ";
        case 0x6E4: return "IndexedTriangleStrip           ";
        case 0x6E5: return "IndexedLineList                ";
        case 0x6E6: return "IndexedLineStrip               ";
        case 0x6E7: return "IndexedPointList               ";
        case 0x6E8: return "IndexedPolygon                 ";
        case 0x6E9: return "VertexTriangleList             ";
        case 0x6EA: return "VertexTriangleFan              ";
        case 0x6EB: return "VertexTriangleStrip            ";
        case 0x6EC: return "VertexLineList                 ";
        case 0x6ED: return "VertexLineStrip                ";
        case 0x6EE: return "VertexPointList                ";
        case 0x6EF: return "VertexPolygon                  ";
        case 0x6F0: return "DMAMemoryControl               ";
        case 0x6F1: return "VertexValid                    ";
        case 0x6F2: return "VertexFormat                   ";
        case 0x6F3: return "VertexControl                  ";
        case 0x6F4: return "RetainedRender                 ";
        case 0x6F5: return "IndexedVertex                  ";
        case 0x6F6: return "IndexedDoubleVertex            ";
        case 0x6F7: return "Vertex0                        ";
        case 0x6F8: return "Vertex1                        ";
        case 0x6F9: return "Vertex2                        ";
        case 0x6FA: return "VertexData0                    ";
        case 0x6FB: return "VertexData1                    ";
        case 0x6FC: return "VertexData2                    ";
        case 0x6FD: return "VertexData                     ";
        case 0x700: return "VertexTagList0                 ";
        case 0x701: return "VertexTagList1                 ";
        case 0x702: return "VertexTagList2                 ";
        case 0x703: return "VertexTagList3                 ";
        case 0x704: return "VertexTagList4                 ";
        case 0x705: return "VertexTagList5                 ";
        case 0x706: return "VertexTagList6                 ";
        case 0x707: return "VertexTagList7                 ";
        case 0x708: return "VertexTagList8                 ";
        case 0x709: return "VertexTagList9                 ";
        case 0x70A: return "VertexTagList10                ";
        case 0x70B: return "VertexTagList11                ";
        case 0x70C: return "VertexTagList12                ";
        case 0x70D: return "VertexTagList13                ";
        case 0x70E: return "VertexTagList14                ";
        case 0x70F: return "VertexTagList15                ";
        case 0x710: return "VertexTagList16                ";
        case 0x711: return "VertexTagList17                ";
        case 0x712: return "VertexTagList18                ";
        case 0x713: return "VertexTagList19                ";
        case 0x714: return "VertexTagList20                ";
        case 0x715: return "VertexTagList21                ";
        case 0x716: return "VertexTagList22                ";
        case 0x717: return "VertexTagList23                ";
        case 0x718: return "VertexTagList24                ";
        case 0x719: return "VertexTagList25                ";
        case 0x71A: return "VertexTagList26                ";
        case 0x71B: return "VertexTagList27                ";
        case 0x71C: return "VertexTagList28                ";
        case 0x71D: return "VertexTagList29                ";
        case 0x71E: return "VertexTagList30                ";
        case 0x71F: return "VertexTagList31                ";

        default: {
            static char str[] = "P3R3:Reserved_XXX                ";
            char        digit;

            digit = (char) ((tag & 0xF00) >> 8);
            str[14] = (digit > 9) ? (digit + 'A' - 10) : (digit + '0');
            digit = (char) ((tag & 0xF0) >> 4);
            str[15] = (digit > 9) ? (digit + 'A' - 10) : (digit + '0');
            digit = (char) ( tag & 0xF);
            str[16] = (digit > 9) ? (digit + 'A' - 10) : (digit + '0');
        return str; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\debug.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.c
*
* Content: Debug helper routines.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

#if DBG

//@@BEGIN_DDKSPLIT
#if 0

LONG gcFifo = 0;                // Number of currently free FIFO entries

BOOL gbCrtcCriticalSection = FALSE;
                                // Have we acquired the CRTC register
                                //   critical section?

// single-shot list output (checked in DebugPrint)
BOOL bPrintList = FALSE;

// single-shot memory viewer (checked in DebugPrint)
int bSetViewableScanline = 0;
int nViewableScanline = 0;

#define LARGE_LOOP_COUNT  10000000
  
/******************************Public*Routine******************************\
* VOID vCheckDataComplete
\**************************************************************************/

VOID vCheckDataReady(
PDEV*   ppdev)
{
    ASSERTDD((IO_GP_STAT(ppdev) & HARDWARE_BUSY),
             "Not ready for data transfer.");
}

/******************************Public*Routine******************************\
* VOID vCheckDataComplete
\**************************************************************************/

VOID vCheckDataComplete(
PDEV*   ppdev)
{
    LONG i;

    // We loop because it may take a while for the hardware to finish
    // digesting all the data we transferred:

    for (i = LARGE_LOOP_COUNT; i > 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & HARDWARE_BUSY))
            return;
    }

    RIP("Data transfer not complete.");
}

/******************************Public*Routine******************************\
* VOID vOutFifoW
\**************************************************************************/

VOID vOutFifoW(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_PORT_USHORT(p, v);
}

/******************************Public*Routine******************************\
* VOID vOutFifoPseudoD
\**************************************************************************/

VOID vOutFifoPseudoD(
PDEV*   ppdev,
VOID*   p,
ULONG   v)
{
    ULONG ulMiscState;

    ASSERTDD(!(ppdev->flCaps & CAPS_MM_IO),
        "No pseudo 32-bit writes when using memory-mapped I/O");
    ASSERTDD(ppdev->iBitmapFormat == BMF_32BPP,
        "We're trying to do 32bpp output while not in 32bpp mode");

    IO_GP_WAIT(ppdev);                  // Wait so we don't interfere with any
                                        //   pending commands waiting on the
                                        //   FIFO
    IO_READ_SEL(ppdev, 6);              // We'll be reading index 0xE
    IO_GP_WAIT(ppdev);                  // Wait until that's processed
    IO_RD_REG_DT(ppdev, ulMiscState);   // Read ulMiscState

    ASSERTDD((ulMiscState & 0x10) == 0,
            "Register select flag is out of sync");

    gcFifo -= 2;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    OUT_PSEUDO_DWORD(p, v);
}

/******************************Public*Routine******************************\
* VOID vWriteFifoW
\**************************************************************************/

VOID vWriteFifoW(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_REGISTER_USHORT(p, (USHORT) v);
}

/******************************Public*Routine******************************\
* VOID vWriteFifoD
\**************************************************************************/

VOID vWriteFifoD(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_REGISTER_ULONG(p, v);
}

/******************************Public*Routine******************************\
* VOID vIoFifoWait
\**************************************************************************/

VOID vIoFifoWait(
PDEV*   ppdev,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 8), "Illegal wait level");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
#ifdef _PPC_

        if( level == 8 )
            if( IO_GP_STAT(ppdev) & GP_ALL_EMPTY )
                return;         // all fifo slots are empty
            else;
        else
            if( !(IO_GP_STAT(ppdev) & (FIFO_1_EMPTY >> (level))) )
                return;         // There are 'level + 1' entries free

#else
        if (!(IO_GP_STAT(ppdev) & ((FIFO_1_EMPTY << 1) >> (level))))
            return;         // There are 'level' entries free
#endif
    }

    RIP("vIoFifoWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vNwFifoWait
\**************************************************************************/

VOID vNwFifoWait(
PDEV*   ppdev,
BYTE*   pjMmBase,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 13), "Illegal wait level");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (level <= 8)
        {
            if (!(READ_REGISTER_USHORT(pjMmBase + CMD)
                                & (0x0080 >> (level - 1))))
                return;
        }
        else
        {
            if (!(READ_REGISTER_USHORT(pjMmBase + CMD)
                                & (0x8000 >> (level - 9))))
                return;
        }
    }

    RIP("vNwFifoWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vDbgFakeWait
\**************************************************************************/

VOID vDbgFakeWait(
PDEV*   ppdev,
BYTE*   pjMmBase,
LONG    level)
{
    gcFifo = level;
}

/******************************Public*Routine******************************\
* VOID vIoGpWait
\**************************************************************************/

VOID vIoGpWait(
PDEV*   ppdev)
{
    LONG    i;

    gcFifo = (ppdev->flCaps & CAPS_16_ENTRY_FIFO) ? 16 : 8;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & HARDWARE_BUSY))
            return;         // It isn't busy
    }

    RIP("vIoGpWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vNwGpWait
\**************************************************************************/

VOID vNwGpWait(
PDEV*   ppdev,
BYTE*   pjMmBase)
{
    LONG    i;

    gcFifo = 16;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(READ_REGISTER_USHORT(pjMmBase + CMD) & HARDWARE_BUSY))
            return;         // It isn't busy
    }

    RIP("vNwGpWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vIoAllEmpty
\**************************************************************************/

VOID vIoAllEmpty(
PDEV*   ppdev)
{
    LONG    i;

    ASSERTDD(ppdev->flCaps & CAPS_16_ENTRY_FIFO,
             "Can't call ALL_EMPTY on chips with 8-deep FIFOs");

    gcFifo = 16;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (IO_GP_STAT(ppdev) & GP_ALL_EMPTY)   // Not implemented on 911/924s
            return;
    }

    RIP("ALL_EMPTY timeout -- The hardware is in a funky state.");
}

/******************************Public*Routines*****************************\
* UCHAR  jInp()     - INP()
* USHORT wInpW()    - INPW()
* VOID   vOutp()    - OUTP()
* VOID   vOutpW()   - OUTPW()
*
* Debug thunks for general I/O routines.  This is used primarily to verify
* that any code accessing the CRTC register has grabbed the CRTC critical
* section (necessary because with GCAPS_ASYNCMOVE, DrvMovePointer calls
* may happen at any time, and they need to access the CRTC register).
*
\**************************************************************************/

UCHAR jInp(BYTE* pjIoBase, ULONG p)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    return(READ_PORT_UCHAR(pjIoBase + (p)));
}

USHORT wInpW(BYTE* pjIoBase, ULONG p)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    return(READ_PORT_USHORT(pjIoBase + (p)));
}

VOID vOutp(BYTE* pjIoBase, ULONG p, ULONG v)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    WRITE_PORT_UCHAR(pjIoBase + (p), (v));
    CP_EIEIO();
}

VOID vOutpW(BYTE* pjIoBase, ULONG p, ULONG v)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    WRITE_PORT_USHORT(pjIoBase + (p), (v));
    CP_EIEIO();
}

/******************************Public*Routine******************************\
* VOID vAcquireCrtc()
* VOID vReleaseCrtc()
*
* Debug thunks for grabbing the CRTC register critical section.
*
\**************************************************************************/

VOID vAcquireCrtc(PDEV* ppdev)
{
    EngAcquireSemaphore(ppdev->csCrtc);

    if (gbCrtcCriticalSection)
        RIP("Had already acquired Critical Section");
    gbCrtcCriticalSection = TRUE;
}

VOID vReleaseCrtc(PDEV* ppdev)
{
    // 80x/805i/928 and 928PCI chips have a bug where if I/O registers
    // are left unlocked after accessing them, writes to memory with
    // similar addresses can cause writes to I/O registers.  The problem
    // registers are 0x40, 0x58, 0x59 and 0x5c.  We will simply always
    // leave the index set to an innocuous register (namely, the text
    // mode cursor start scan line):

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0xa);

    if (!gbCrtcCriticalSection)
        RIP("Hadn't yet acquired Critical Section");
    gbCrtcCriticalSection = FALSE;
    EngReleaseSemaphore(ppdev->csCrtc);
}

#if VERIFY_CHECKFLAGS
     void __CheckFlags(PDEV *ppdev, ULONG x)
    {
        ULONG lop, fbr, cFlags = ppdev->cFlags;
        GLINT_DECL;

        SYNC_WITH_GLINT;

        READ_GLINT_FIFO_REG (__GlintTagLogicalOpMode, lop);
        READ_GLINT_FIFO_REG (__GlintTagFBReadMode, fbr);
        READ_GLINT_FIFO_REG (__GlintTagLogicalOpMode, lop);

        ASSERTDD ((cFlags & cFlagFBReadDefault) == 0 || ((cFlags & cFlagFBReadDefault) && fbr == glintInfo->FBReadMode), "SCF: Bad check fbread cache flag");
        ASSERTDD ((cFlags & cFlagLogicalOpDisabled) == 0 || ((cFlags & cFlagLogicalOpDisabled) && (lop & 0x1) == 0x0), "SCF: Bad check logicop cache flag");
        ASSERTDD ((cFlags & cFlagConstantFBWrite) == 0 || ((cFlags & cFlagConstantFBWrite) && (lop & (1<<5))), "SCF: Bad check const fbwrite cache flag");
    }
#endif //VERIFY_CHECKFLAGS

#endif // if 0
//@@END_DDKSPLIT

////////////////////////////////////////////////////////////////////////////

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\fillpath.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: fillpath.c
*
* Content: DrvFillPath support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//@@BEGIN_DDKSPLIT
// LATER identify convex polygons and special-case?
// LATER identify vertical edges and special-case?
// LATER move pointed-to variables into automatics in search loops
// LATER punt to the engine with segmented framebuffer callbacks
// LATER handle complex clipping
// LATER coalesce rectangles
//@@END_DDKSPLIT

#include "precomp.h"
#include "glint.h"

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath = 0;
    ULONG BufferMissInFillpath = 0;
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill
    EDGE *pFreeEdges = NULL;   // pointer to memory free for use to store edges                        

    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    GFNFILL     *pfnFill;           // Points to appropriate fill routine

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev = (PDEV*) pso->dhpdev;
    DSURF       *pdsurf;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];
    ULONG        logicop;
    ULONG        bgLogicop;
    GLINT_DECL;

    DISPDBG((DBGLVL, "Entering Fill Path"));

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL)
    {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    }
    else
    {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2)
    {
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;

    if (pdsurf->dt & DT_DIB)
    { 
        DISPDBG((DBGLVL, "Passing to GDI"));
        return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions));
    }

    REMOVE_SWPOINTER(pso);

    VALIDATE_DD_CONTEXT;

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:
//@@BEGIN_DDKSPLIT
#if 1
//@@END_DDKSPLIT
    SETUP_PPDEV_OFFSETS(ppdev, pdsurf);
//@@BEGIN_DDKSPLIT
#else
    ppdev->DstPixelOrigin = pdsurf->poh->pixOffset;
    ppdev->xyOffsetDst = MAKEDWORD_XY( pdsurf->poh->x, pdsurf->poh->y );
    ppdev->xOffset = pdsurf->poh->x;
#endif
//@@END_DDKSPLIT

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    pfnFill = ppdev->pgfnFillSolid;
    logicop = GlintLogicOpsFromR2[mix & 0xFF];
    bgLogicop = GlintLogicOpsFromR2[mix >> 8];
    iSolidColor     = pbo->iSolidColor;
    rbc.iSolidColor = iSolidColor;
    if (rbc.iSolidColor == -1)
    {
        rbc.prb = pbo->pvRbrush;
        if (rbc.prb == NULL)
        {
            DISPDBG((DBGLVL, "Realizing brush"));
            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
            if (rbc.prb == NULL)
            {
                return(FALSE);
            }
            
            DISPDBG((DBGLVL, "Realized brush"));
        }
        if (rbc.prb->fl & RBRUSH_2COLOR)
        {
            pfnFill = ppdev->pgfnFillPatMono;
        }
        else
        {
            pfnFill = ppdev->pgfnFillPatColor;
        }
    }

    if (bMore)
    {
        // FastFill only knows how to take a single contiguous buffer
        // of points.  Unfortunately, GDI sometimes hands us paths
        // that are split over multiple path data records.  Convex
        // figures such as Ellipses, Pies and RoundRects are almost
        // always given in multiple records.  Since probably 90% of
        // multiple record paths could still be done by FastFill, for
        // those cases we simply copy the points into a contiguous
        // buffer...

        // First make sure that the entire path would fit in the
        // temporary buffer, and make sure the path isn't comprised
        // of more than one subpath:

        if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
            (pd.flags & PD_ENDSUBPATH))
        {
            goto SkipFastFill;
        }

        pptfxTmp = &aptfxBuf[0];

        RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

        pptfxTmp     += pd.count;
        cptfxTmp      = pd.count;
        flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
            cptfxTmp += pd.count;
            pptfxTmp += pd.count;
        } while (!(pd.flags & PD_ENDSUBPATH));

        // Fake up the path data record:
        pd.pptfx  = &aptfxBuf[0];
        pd.count  = cptfxTmp;
        pd.flags |= flFirstRecord;

        // If there's more than one subpath, we can't call FastFill:
        DISPDBG((DBGLVL, "More than one subpath!"));
        if (bMore)
            goto SkipFastFill;
    }

    if ((*ppdev->pgfnFillPolygon)(ppdev, pd.count, pd.pptfx, iSolidColor,
                                logicop, bgLogicop, pco, rbc.prb, pptlBrush))
    {
        DISPDBG((DBGLVL, "Fast Fill Succeeded"));
        return(TRUE);
    }

SkipFastFill:

    DISPDBG((DBGLVL, "Fast Fill Skipped"));

    if (jClipping != DC_TRIVIAL)
    {
        if (jClipping != DC_RECT)
        {
            DISPDBG((DBGLVL, "Complex Clipping"));
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    }
    else
    {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }
    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore)
    {
        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

        // We have to start somewhere so assume that most
        // applications specify the top left point  first
        //
        // we want to check that the first two points are
        // either vertically or horizontally aligned.  if
        // they are then we check that the last point [3]
        // is either horizontally or  vertically  aligned,
        // and finally that the 3rd point [2] is  aligned
        // with both the first point and the last point.

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right)
         {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else
         {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

         // if the left is greater than the right then
         // swap them so the blt code doesn't wig out

         if (rectangle->left > rectangle->right)
         {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else
         {
            // if left == right there's nothing to draw

            if (rectangle->left == rectangle->right)
            {
               DISPDBG((DBGLVL, "Nothing to draw"));
               goto ReturnTrue;
            }
         }

         // shift the values to get pixel coordinates

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom)
         {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else
         {
            if (rectangle->top == rectangle->bottom)
            {
               DISPDBG((DBGLVL, "Nothing to draw"));
               goto ReturnTrue;
            }
         }

         // shift the values to get pixel coordinates

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping

         if (jClipping == DC_RECT)
         {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle))
            {
                // Totally clipped, nothing to do
                DISPDBG((DBGLVL, "Nothing to draw"));
                goto ReturnTrue;
            }
         }

         // if we get here then the polygon is a rectangle,
         // set count to 1 and goto bottom to draw it 

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;
    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES)
    {
#if TAKING_ALLOC_STATS
        BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) ENGALLOCMEM(FL_ZERO_MEMORY, 
                                          (ppo->cCurves * sizeof(EDGE)), 
                                          ALLOC_TAG_GDI(6));
        if (pFreeEdges == NULL)
        {
            DISPDBG((DBGLVL, "Too many edges"));
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else
    {
#if TAKING_ALLOC_STATS
        BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
        // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect))
    {
        DISPDBG((DBGLVL, "Outside Range"));
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead)
        {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead)
        {
            if (GETHead.pNext == pGETHead)
            {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        }
        else
        {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead)
            {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY)
        {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {
            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0)
            {
                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            }
            else
            {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X)
            {
                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS)
                {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty
                   (*pfnFill)(ppdev, ulNumRects, prclRects, logicop, bgLogicop,
                               rbc, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT)
                {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right)
                    {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

// Draw the remaining rectangles, if there are any.

draw_remaining_rectangles:

    if (ulNumRects > 0)
    {
        (*pfnFill)(ppdev, ulNumRects, prclRects, logicop, bgLogicop,
                   rbc, pptlBrush);
    }

ReturnTrue:
    DISPDBG((DBGLVL, "Drawn"));
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        ENGFREEMEM(pFreeEdges);
    }

    DISPDBG((DBGLVL, "Returning %s", bRetVal ? "True" : "False"));
    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.

VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0)
        {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        }
        else
        {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0)
            {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.

VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X)
            {
                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.

VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) 
        {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}

// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
    EDGE     *pGETHead,
    EDGE     *pFreeEdges,
    PATHOBJ  *ppo,
    PATHDATA *pd,
    BOOL      bMore,
    RECTL    *pClipRect)
{
    POINTFIX pfxPathStart;    // point that started the current subpath
    POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

    // Create an empty GET with the head node also a tail sentinel

    pGETHead->pNext = pGETHead; // mark that the GET is empty
    pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

    // PATHOBJ_vEnumStart is implicitly performed by engine
    // already and first path is enumerated by the caller.

next_subpath:

    // Make sure the PATHDATA is not empty (is this necessary)

    if (pd->count != 0)
    {
       // If first point starts a subpath, remember it as such
       // and go on to the next point, so we can get an edge

       if (pd->flags & PD_BEGINSUBPATH)
       {
           // the first point starts the subpath; remember it
  
           pfxPathStart    = *pd->pptfx; // the subpath starts here
           pfxPathPrevious = *pd->pptfx; // this points starts the next edge
           pd->pptfx++;                  // advance to the next point
           pd->count--;                  // count off this point
       }

       // Add edges in PATHDATA to GET, in Y-X sorted order 

       while (pd->count--)
       {
           if ((pFreeEdges =
                 AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                              pClipRect)) == NULL)
           {
               goto ReturnFalse;
           }

           pfxPathPrevious = *pd->pptfx; // current point becomes previous
           pd->pptfx++;                  // advance to the next point
       }

       // If last point ends the subpath, insert the edge that
       // connects to first point (is this built in already?)

       if (pd->flags & PD_ENDSUBPATH)
       {
           if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                          &pfxPathStart, pClipRect)) == NULL)
           {
               goto ReturnFalse;
           }
       }
   }

   // The initial loop conditions preclude a do, while or for

   if (bMore)
   {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:

    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.

EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order

    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0)
    {
        return(pFreeEdge);  // zero height; ignore this edge
    }
    else if (iYHeight >= 0)
    {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    }
    else
    {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000)
    {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now

    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0)
    {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    }
    else
    {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000)
    {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight)
    {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1)
        {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    }
    else
    {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0)
    {
        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop)
    {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }

    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive

    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

//@@BEGIN_DDKSPLIT
    // LATER adjust only if needed (if prestepped above)?
//@@END_DDKSPLIT
    if (pFreeEdge->iXDirection == 1)
    {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    }
    else
    {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X)))
    {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    // if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else

    // LONGLONGS are 64 bit integers (We hope!) as the multiply could
    // overflow 32 bit integers. If 64 bit ints are unsupported, the
    // LONGLONG will end up as a double. Hopefully there will be no
    // noticable difference in accuracy.
    LONGLONG NumAdjustDowns;
    LONGLONG tmpError = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    tmpError += (LONGLONG)iErrorAdjustUp * (LONGLONG)yJump;

    // See if the error term turned over even once while skipping
    if (tmpError >= 0)
    {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (tmpError / (LONGLONG)iErrorAdjustDown) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1)
        {
            *pXStart += (LONG) NumAdjustDowns;
        }
        else
        {
            *pXStart -= (LONG) NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        tmpError -= (LONGLONG)iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (LONG)tmpError;

#endif  // X86
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\dma.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: dma.c
*
* Content: Handling of DMA buffers.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

//
// Normally, we should not use global variables but the DMA buffers provided
// by the miniport are global across all PDEVs and need be initialized only
// once.
//

typedef struct _DMA_INFORMATION {
    ULONG             NumDMABuffers;
    QUERY_DMA_BUFFERS DMABuffer[1];
} DMAInformation, *LPDMAInformation;

LPDMAInformation gpDMABufferInfo = (LPDMAInformation)0;

/******************************Public*Routine******************************\
* VOID bGlintInitializeDMA
*
* Interrogate the miniport to see if DMA is supported. If it is, map in the
* DMA buffers ready for use by the 3D extension.
*
\**************************************************************************/

VOID vGlintInitializeDMA(PPDEV ppdev)
{
    DMA_NUM_BUFFERS queryDMA;
    ULONG   enableFlags;
    LONG    Length;
    LONG    ExtraLength;
    ULONG   i;

    GLINT_DECL;

    glintInfo->pxrxDMA = &glintInfo->pxrxDMAnonInterrupt;

    return; //azntst for multimon 

    // check the miniport has initialised DMA
    //
    glintInfo->MaxDMASubBuffers = 0;
    if (!(ppdev->flCaps & CAPS_DMA_AVAILABLE))
    {
        return;
    }


    // in the multi-board case we only want one set of DMA buffers which
    // are global across all boards. But we have an interrupt per board.
    // So if the DMA buffers are sorted out try setting up the interrupt.
    //
    if (gpDMABufferInfo != NULL)
    {
        goto TryInterrupts;
    }

    // query the number of DMA buffers. If this fails we have no DMA
    //
    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_NUM_DMA_BUFFERS,
                         NULL,
                         0,
                         &queryDMA,
                         sizeof(DMA_NUM_BUFFERS),
                         &Length))
    {
        DISPDBG((ERRLVL, "QUERY_NUM_DMA_BUFFERS failed: "
                         "No GLINT DMA available"));
        return;
    }
    
    Length = queryDMA.NumBuffers * queryDMA.BufferInformationLength;
    ExtraLength = sizeof(DMAInformation) - sizeof(QUERY_DMA_BUFFERS);

    DISPDBG((ERRLVL, "%d DMA buffers available. Total info size = 0x%x",
                     queryDMA.NumBuffers, Length));

    // allocate space for the DMA information
    //

    gpDMABufferInfo = (LPDMAInformation)ENGALLOCMEM(
                              FL_ZERO_MEMORY,
                              ExtraLength + Length,
                              ALLOC_TAG_GDI(1));

    if (gpDMABufferInfo == NULL)
    {
        DISPDBG((ERRLVL, "vGlintInitializeDMA: Out of memory"));
        return;
    }

    gpDMABufferInfo->NumDMABuffers = queryDMA.NumBuffers;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_DMA_BUFFERS,
                         NULL,
                         0,
                         (PVOID)(&gpDMABufferInfo->DMABuffer[0]),
                         Length,
                         &Length))
    {
        ENGFREEMEM(gpDMABufferInfo);
        gpDMABufferInfo = NULL;
        DISPDBG((ERRLVL, "QUERY_DMA_BUFFERS failed: No GLINT DMA available"));
        return;
    }

    DISPDBG((ERRLVL, "IOCTL returned length %d", Length));

    // zero the flags for each record
    //
    for (i = 0; i < queryDMA.NumBuffers; ++i)
    {
        gpDMABufferInfo->DMABuffer[i].flags = 0;
    }

#if DBG
    {
        ULONG j;
        PUCHAR pAddr;
        for (i = 0; i < queryDMA.NumBuffers; ++i)
        {
            DISPDBG((ERRLVL,"DMA buffer %d: phys 0x%x, virt 0x%x"
                            ", size 0x%x, flags 0x%x", i,
                            gpDMABufferInfo->DMABuffer[i].physAddr.LowPart,
                            gpDMABufferInfo->DMABuffer[i].virtAddr,
                            gpDMABufferInfo->DMABuffer[i].size,
                            gpDMABufferInfo->DMABuffer[i].flags));
            pAddr = gpDMABufferInfo->DMABuffer[i].virtAddr;
            for (j = 0; j < gpDMABufferInfo->DMABuffer[i].size; ++j)
                *pAddr++ = (UCHAR)(j & 0xff);
        }
    }
#endif

TryInterrupts:

    if (!INTERRUPTS_ENABLED)
    {
        return;
    }

    // map in the interrupt command control block. This is a piece of memory
    // shared with the intrerrupt controller which allows us to send control
    // what happens on VBLANK and DMA interrupts.
    //
    Length = sizeof(PVOID);

    DISPDBG((WRNLVL, "calling IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF"));

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF,
                         NULL,
                         0,
                         (PVOID)&(glintInfo->pInterruptCommandBlock),
                         Length,
                         &Length))
    {
        DISPDBG((ERRLVL, "IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF failed."));
        return;
    }
#if DBG
    else
    {
        DISPDBG((WRNLVL, "got command buffer at 0x%x", 
                         glintInfo->pInterruptCommandBlock));
        DISPDBG((WRNLVL, "front, back, end indexes = %d, %d, %d",
                         glintInfo->pInterruptCommandBlock->frontIndex,
                         glintInfo->pInterruptCommandBlock->backIndex,
                         glintInfo->pInterruptCommandBlock->endIndex));
    }
#endif

    // if we get here we have both DMA and interrupts so set for interrupt
    // driven DMA. Don't turn on interrupts yet. That has to be done on a
    // per context basis.
    //
    DISPDBG((WRNLVL, "Using interrupt driven DMA"));
    glintInfo->flags |= GLICAP_INTERRUPT_DMA;

    glintInfo->MaxDMASubBuffers = glintInfo->pInterruptCommandBlock->maximumIndex;
    glintInfo->pxrxDMA = &glintInfo->pInterruptCommandBlock->pxrxDMA;

    return;
}

/******************************Public*Routine******************************\
* ULONG anyFreeDMABuffers
*
* Return number of unused DMA buffers available
*
\**************************************************************************/

ULONG anyFreeDMABuffers(void)
{
    PQUERY_DMA_BUFFERS pDma;
    ULONG              i;
    ULONG numAvailable = 0;

    if (!gpDMABufferInfo)
    {
        return 0;
    }

    pDma = &gpDMABufferInfo->DMABuffer[0];
    for (i = 0; i < gpDMABufferInfo->NumDMABuffers; ++i)
    {
        if (!(pDma->flags & DMA_BUFFER_INUSE))
        {
            numAvailable++;
        }
        ++pDma;
    }

    return numAvailable;
}

/******************************Public*Routine******************************\
* ULONG GetFreeDMABuffer
*
* Return info about a DMA buffer and mark it as in use.
* -1 is returned if no buffer is available.
*
\**************************************************************************/

LONG GetFreeDMABuffer(PQUERY_DMA_BUFFERS dmaBuf)
{
    PQUERY_DMA_BUFFERS pDma;
    ULONG    i;

    if (!gpDMABufferInfo)
    {
        return(-1);
    }

    pDma = &gpDMABufferInfo->DMABuffer[0];
    for (i = 0; i < gpDMABufferInfo->NumDMABuffers; ++i)
    {
        if (!(pDma->flags & DMA_BUFFER_INUSE))
        {
            pDma->flags |= DMA_BUFFER_INUSE;
            *dmaBuf = *pDma;
            DISPDBG((WRNLVL, "Allocated DMA buffer %d", i));
            return(i);
        }
        ++pDma;
    }

    // all are in use
    DISPDBG((ERRLVL, "No more DMA buffers available"));

    return(-1);
}

/******************************Public*Routine******************************\
* VOID FreeDMABuffer
*
* Mark the given DMA buffer as free. The caller passes in the physical
* address of the buffer.
*
\**************************************************************************/

VOID FreeDMABuffer(PVOID physAddr)
{
    PQUERY_DMA_BUFFERS pDma;
    ULONG    i;

    if (!gpDMABufferInfo)
    {
        return;
    }

    pDma = &gpDMABufferInfo->DMABuffer[0];
    for (i = 0; i < gpDMABufferInfo->NumDMABuffers; ++i)
    {
        if (pDma->physAddr.LowPart == (UINT_PTR)physAddr)
        {
            pDma->flags &= ~DMA_BUFFER_INUSE;
            break;
        }
        ++pDma;
    }             

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\enable.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* Content: 
*
*    This module contains the functions that enable and disable the
*   driver, the pdev, and the surface.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

DWORD g_dwTag = (DWORD) 0;

HSEMAPHORE g_cs = (HSEMAPHORE)0;

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,     // ulVersion
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
#if WNT_DDRAW
     GCAPS_DIRECTDRAW       |
#endif  // WNT_DDRAW
     GCAPS_COLOR_DITHER     |
     GCAPS_ASYNCMOVE),          // NOTE: Only enable ASYNCMOVE if your code
                                //   and hardware can handle DrvMovePointer
                                //   calls at any time, even while another
                                //   thread is in the middle of a drawing
                                //   call such as DrvBitBlt.

                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0,                                          // hpalDefault (filled in later)
#if(_WIN32_WINNT >= 0x500)
    GCAPS2_CHANGEGAMMARAMP,                     // flGraphicsCaps2
#endif // (_WIN32_WINNT >= 0x500)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if DBG || !SYNCHRONIZEACCESS_WORKS

// gadrvfn [] - these entries must be in ascending index order, bad things
//              will happen if they aren't.
//              In this debug version we always thunk because we have to explicitly
//              lock between 2D and 3D operations. DrvEscape doesn't lock.

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },    //  0
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },    //  1
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },    //  2
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },    //  3
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },    //  4
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },    //  5
    {   INDEX_DrvResetPDEV,             (PFN) DbgResetPDEV,         },    //  7
    {   INDEX_DrvDisableDriver,         (PFN) DbgDisableDriver,     },    //  8
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },    // 10
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },    // 11
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },    // 12
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },    // 13
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },    // 14
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },    // 15
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },    // 17
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },    // 18
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },    // 19
//  {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt,        },    // 20
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },    // 22 (SetPalette)
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },    // 23 (TextOut)
    {   INDEX_DrvEscape,                (PFN) DbgEscape             },    // 24
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },    // 29
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },    // 30
    {   INDEX_DrvLineTo,                (PFN) DbgLineTo             },    // 31
    {   INDEX_DrvSynchronize,           (PFN) DbgSynchronize        },    // 38
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },    // 41
#if WNT_DDRAW
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DbgGetDirectDrawInfo  },    // 59
    {   INDEX_DrvEnableDirectDraw,      (PFN) DbgEnableDirectDraw   },    // 60
    {   INDEX_DrvDisableDirectDraw,     (PFN) DbgDisableDirectDraw  },    // 61
#endif // WNT_DDRAW
#if(_WIN32_WINNT >= 0x500)
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DbgIcmSetDeviceGammaRamp }, // 67
//@@BEGIN_DDKSPLIT
// Currently we don't actually have any code to accelerate the following 3 new
// NT5 GDI features, and because P3 driver uses the NT4 driver's way to support
// device bitmap, hooking the entries here will cause failure if strectching is
// involved.
//@@END_DDKSPLIT
#if defined(_NT5GDI)
    {   INDEX_DrvGradientFill,          (PFN) DbgGradientFill       },    // 68
    {   INDEX_DrvAlphaBlend,            (PFN) DbgAlphaBlend         },    // 71
    {   INDEX_DrvTransparentBlt,        (PFN) DbgTransparentBlt     },    // 74
#endif
    {   INDEX_DrvNotify,                (PFN) DbgNotify             },    // 87
//azn    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface      },
#endif  //    (_WIN32_WINNT >= 0x500)
};

#else   // DBG || !SYNCHRONIZEACCESS_WORKS

// gadrvfn [] - these entries must be in ascending index order, bad things
//              will happen if they aren't.
//              On Free builds, directly call the appropriate functions...
// 

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },    //  0
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },    //  1
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },    //  2
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },    //  3
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },    //  4
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },    //  5
    {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV,         },    //  7
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver,     },    //  8
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },    // 10
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },    // 11
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },    // 12
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },    // 13
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },    // 14
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },    // 15
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },    // 17
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },    // 18
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },    // 19
//  {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt,        },    // 20
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },    // 22 (SetPalette)
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },    // 23 (TextOut)
    {   INDEX_DrvEscape,                (PFN) DrvEscape             },    // 24       
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },    // 29
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },    // 30
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },    // 31
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },    // 38
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },    // 41
#if WNT_DDRAW
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },    // 59
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },    // 60
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },    // 61
#endif // WNT_DDRAW
#if(_WIN32_WINNT >= 0x500)
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp }, // 67
#if defined(_NT5GDI)
    {   INDEX_DrvGradientFill,          (PFN) DrvGradientFill       },    // 68
    {   INDEX_DrvAlphaBlend,            (PFN) DrvAlphaBlend         },    // 71
    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt     },    // 74
#endif
    {   INDEX_DrvNotify,                (PFN) DrvNotify             },    // 87
//azn    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface      },
#endif  //    (_WIN32_WINNT >= 0x500)
};

#endif  // DBG || !SYNCHRONIZEACCESS_WORKS
                         
ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL DrvResetPDEV
*
* Notifies the driver of a dynamic mode change.
*
\**************************************************************************/

BOOL DrvResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)
{
    PDEV* ppdevNew = (PDEV*) dhpdevNew;
    PDEV* ppdevOld = (PDEV*) dhpdevOld;
    BOOL bRet = TRUE;

    DISPDBG((DBGLVL, "DrvResetPDEV called: oldPDEV = 0x%x, newPDEV = 0x%x", 
                     ppdevOld, ppdevNew));

#if WNT_DDRAW
    _DD_DDE_ResetPPDEV(ppdevOld, ppdevNew);
#endif
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

// We define here DDI_DRIVER_VERSION_NT5_01 in order to be able to compile
// inside the DX DDK. In the Whistler DDK this shouldn't be necessary
#ifndef DDI_DRIVER_VERSION_NT5_01   
#define DDI_DRIVER_VERSION_NT5_01   0x00030100
#endif

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Set up the indirect information, a multi-boardsystem will call
    // the mul functions a single board system will use the one functions

    DISPDBG((DBGLVL, "DrvEnableDriver called: gc %d, ga 0x%x", 
                     gcdrvfn, gadrvfn));

    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= (sizeof(ULONG) *3))
    {
        pded->pdrvfn = gadrvfn;
    }

    if (cj >= (sizeof(ULONG) * 2))
    {
        pded->c = gcdrvfn;
    }

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
    {
        // Ordered list of supported DDI versions
        ULONG SupportedVersions[] = {
                                        DDI_DRIVER_VERSION_NT5,
                                        DDI_DRIVER_VERSION_NT5_01,
        };
        
        int i = sizeof(SupportedVersions)/sizeof(SupportedVersions[0]);

        // Look for highest version also supported by engine    
        while (--i >= 0)
        {
            if (SupportedVersions[i] <= iEngineVersion) 
            {
                break;
            }
        }

        // Fail if there is no common DDI support
        if (i < 0) 
        {
            return FALSE;
        }

        pded->iDriverVersion = SupportedVersions[i];
    
    }

    // Initialize sync semaphore.

    g_cs = EngCreateSemaphore();

    if (g_cs)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    DISPDBG((DBGLVL, "DrvDisableDriver called:"));
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;
    ULONG   cjOut;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG_GDI(2));
    if (ppdev == NULL)
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Failed memory allocation"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    if (!bAllocateGlintInfo(ppdev))
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Failed bAllocateGlintInfo"));
        goto ReturnFailure1;
    }

    // initially assume we are allowed to create our off-screen resources.
    // If we decide not to create them, unset the appropriate bit. After,
    // initialization, we can temporarily disable a resource by unsetting
    // its ENABLE bit.

    ppdev->flStatus = ENABLE_DEV_BITMAPS;

#if (_WIN32_WINNT >= 0x500 && WNT_DDRAW)

    // Any DX capable card can support linear heaps. Assume we can support 
    // linear heaps here, this value may be updated in bEnableOffscreenHeap()

    ppdev->flStatus |= ENABLE_LINEAR_HEAP;

#endif //(_WIN32_WINNT >= 0x500)

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((ERRLVL, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    // initialize the image download scratch area and the TexelLUT palette

    ppdev->pohImageDownloadArea = NULL;
    ppdev->cbImageDownloadArea = 0;
    ppdev->iPalUniq = (ULONG)-1;
    ppdev->cPalLUTInvalidEntries = 0;

#if WNT_DDRAW
    // Create the DirectDraw structures associated with this new pdev
    if (!_DD_DDE_CreatePPDEV(ppdev))
    {
        goto ReturnFailure1;
    }
#endif
    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((ERRLVL, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

#if WNT_DDRAW
    // Free the DirectDraw info associated with the pdev

    _DD_DDE_DestroyPPDEV(ppdev);
#endif

    vUninitializePalette(ppdev);

    ENGFREEMEM(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface and initializes the hardware.  This is called
* after DrvEnablePDEV, and performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;

    ppdev = (PDEV*) dhpdev;

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // First, create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG_GDI(3));
    if (pdsurf == NULL)
    {
        DISPDBG((ERRLVL, "DrvEnableSurface - Failed pdsurf memory allocation"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;           // Remember it for clean-up
    pdsurf->poh         = ppdev->pohScreen; // The screen is a surface, too
    pdsurf->poh->pdsurf = pdsurf;
    pdsurf->dt          = DT_SCREEN;        // Not to be confused with a DIB DFB
    pdsurf->bOffScreen  = FALSE;            // it's the screen, not offscreen
    pdsurf->sizl.cx     = ppdev->cxScreen;
    pdsurf->sizl.cy     = ppdev->cyScreen;
    pdsurf->ppdev       = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
    if (hsurf == 0)
    {
        DISPDBG((ERRLVL, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((ERRLVL, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    // Create our generic temporary buffer, which may be used by any
    // component.  Because this may get swapped out of memory any time
    // the driver is not active, we want to minimize the number of pages
    // it takes up.  We use 'VirtualAlloc' to get an exactly page-aligned
    // allocation (which 'LocalAlloc' will not do):

    pvTmpBuffer = ENGALLOCMEM(FL_ZERO_MEMORY, TMP_BUFFER_SIZE, ALLOC_TAG_GDI(4));
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((ERRLVL, "DrvEnableSurface - Failed TmpBuffer allocation"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;
 
    /////////////////////////////////////////////////////////////////////
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bInitializeGlint(ppdev))
        goto ReturnFailure;

    // We could simply let GDI synchronize every time it draws on the screen
    // but this would be even slower. So unset the sync hook if the rendering
    // is done in software.
    //
    if (!bCreateScreenDIBForOH(ppdev, pdsurf->poh, HOOK_SYNCHRONIZE))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

//@@BEGIN_DDKSPLIT
#if 0
    if (!bEnablePointerCache(ppdev))
    {
        DISPDBG((ERRLVL, "Pointer cache failed to initialise"));
    }
#endif
//@@END_DDKSPLIT

#if WNT_DDRAW
    if (!_DD_DDE_bEnableDirectDraw(ppdev))
    {
        goto ReturnFailure;
    }
#endif // WNT_DDRAW

    DISPDBG((DBGLVL, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((ERRLVL, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    DSURF*  pdsurf;

    ppdev = (PDEV*) dhpdev;
    pdsurf = ppdev->pdsurfScreen;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

#if WNT_DDRAW

    _DD_DDE_vDisableDirectDraw(ppdev);

#endif // WNT_DDRAW

//@@BEGIN_DDKSPLIT
#if 0
    vDisablePointerCache(ppdev);
#endif
//@@END_DDKSPLIT
    vDisablePalette(ppdev);
    vDisablePointer(ppdev);
    if (pdsurf != NULL)
        vDeleteScreenDIBFromOH(pdsurf->poh);
    vDisableGlint(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);

    ENGFREEMEM(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    ENGFREEMEM(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL/VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

#if WNT_DDRAW
        _DD_DDE_vAssertModeDirectDraw(ppdev, FALSE);
#endif WNT_DDRAW

        vAssertModePalette(ppdev, FALSE);
        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            vAssertModeGlint(ppdev, FALSE);

            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

                return(TRUE);
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            vAssertModeGlint(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);
        vAssertModePalette(ppdev, TRUE);
#if WNT_DDRAW
        _DD_DDE_vAssertModeDirectDraw(ppdev, TRUE);
#endif WNT_DDRAW

    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            vAssertModeGlint(ppdev, TRUE);
            bAssertModeOffscreenHeap(ppdev, TRUE);
            vAssertModePointer(ppdev, TRUE);
            vAssertModePalette(ppdev, TRUE);
#if WNT_DDRAW
            _DD_DDE_vAssertModeDirectDraw(ppdev, TRUE);
#endif // WNT_DDRAW

        #if (_WIN32_WINNT >= 0x500 && FALSE)
            // There is probably a neater way to do this, but: currently the display driver isn't notified
            // about entering / exiting hibernation so it can't save away those GC registers that it has
            // initialized at the start of day and hasn't bothered to context switch. DrvAssertMode(TRUE)
            // is the first display driver call made upon return from hibernation so we take the 
            // opportunity to re-initialize these registers now. Reinitializing these registers at other
            // times when DrvAssertMode(TRUE) is called (e.g. mode change) should do no harm. Non-GC 
            // registers are dealt with in the miniport's PowerOnReset() and HibernationMode() functions
            { 
                extern void ReinitialiseGlintExtContext(PDEV *ppdev);

                // currently, only the extension context initializes but doesn't context switch certain registers
                ReinitialiseGlintExtContext(ppdev);
            }
        #endif //(_WIN32_WINNT >= 0x500)

            ppdev->bEnabled = TRUE;

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((ERRLVL, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion = DM_SPECVERSION;
                pdm->dmDriverVersion = DM_SPECVERSION;

                //
                // We currently do not support Extra information in the driver
                //

                pdm->dmDriverExtra = DRIVER_EXTRA_SIZE;

                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;
                pdm->dmPanningWidth     = pdm->dmPelsWidth;
                pdm->dmPanningHeight    = pdm->dmPelsHeight;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS;
                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((UINT_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((UINT_PTR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    ENGFREEMEM(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    GLINT_DECL;

    if (bEnable)
    {
        DISPDBG((DBGLVL, "enabling hardware"));

        // Call the miniport via an IOCTL to set the graphics mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(DWORD),
                             NULL,
                             0,
                             &ReturnedDataLength) != NO_ERROR)
        {
            DISPDBG((ERRLVL, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_QUERY_CURRENT_MODE,
                             NULL,
                             0,
                             &VideoModeInfo,
                             sizeof(VideoModeInfo),
                             &ReturnedDataLength) != NO_ERROR)
        {
            DISPDBG((ERRLVL, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
            goto ReturnFalse;
        }

        #if DEBUG_HEAP
            VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
            DISPDBG((ERRLVL, "Video Memory Bitmap width and height set to %d x %d",
                            VideoModeInfo.VideoMemoryBitmapWidth,
                            VideoModeInfo.VideoMemoryBitmapHeight));
        #endif

        // The following variables are determined only after the initial
        // modeset:

        ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;
        ppdev->cyMemory = VideoModeInfo.VideoMemoryBitmapHeight;
        ppdev->lDelta   = VideoModeInfo.ScreenStride;
        ppdev->Vrefresh = VideoModeInfo.Frequency;
        ppdev->flCaps   = VideoModeInfo.DriverSpecificAttributeFlags;

        DISPDBG((DBGLVL, "Got flCaps 0x%x", ppdev->flCaps));
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        DISPDBG((DBGLVL, "IOCTL_VIDEO_RESET_DEVICE"));

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn) != NO_ERROR)
        {
            DISPDBG((ERRLVL, "bAssertModeHardware - Failed reset IOCTL"));
            goto ReturnFalse;
        }
    }

    DISPDBG((DBGLVL, "Passed bAssertModeHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((ERRLVL, "Failed bAssertModeHardware"));

    return(FALSE);
}


/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY             VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    DWORD                    ReturnedDataLength;
    LONG                     i;
    VIDEO_PUBLIC_ACCESS_RANGES VideoAccessRange[3];
    
    DISPDBG((DBGLVL, "bEnableHardware Reached"));

    // Map control registers into virtual memory:

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         &VideoMemory,              // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoAccessRange[0],      // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength) != NO_ERROR)
    {
        RIP("bEnableHardware - Initialization error mapping control registers");
        goto ReturnFalse;
    }

    ppdev->pulCtrlBase[0] = (ULONG*) VideoAccessRange[0].VirtualAddress;
    ppdev->pulCtrlBase[1] = (ULONG*) VideoAccessRange[1].VirtualAddress;
    ppdev->pulCtrlBase[2] = (ULONG*) VideoAccessRange[2].VirtualAddress;

    DISPDBG((DBGLVL, "Mapped GLINT control registers[0] at 0x%x", ppdev->pulCtrlBase[0]));
    DISPDBG((DBGLVL, "Mapped GLINT control registers[1] at 0x%x", ppdev->pulCtrlBase[1]));
    DISPDBG((DBGLVL, "Mapped GLINT control registers[2] at 0x%x", ppdev->pulCtrlBase[2]));
    DISPDBG((DBGLVL, "bEnableHardware: ppdev 0x%x", ppdev));

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;
    
    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                         &VideoMemory,      // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoMemoryInfo,  // output buffer
                         sizeof(VideoMemoryInfo),
                         &ReturnedDataLength) != NO_ERROR)
    {
        DISPDBG((ERRLVL, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    DISPDBG((DBGLVL, "FrameBufferBase: %lx", VideoMemoryInfo.FrameBufferBase));

    // Record the Frame Buffer Linear Address.

    ppdev->pjScreen = (BYTE*) VideoMemoryInfo.FrameBufferBase;
    ppdev->FrameBufferLength = VideoMemoryInfo.FrameBufferLength;

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    DISPDBG((DBGLVL, "Width: %li Height: %li Stride: %li Flags: 0x%lx",
            ppdev->cxMemory, ppdev->cyMemory,
            ppdev->lDelta, ppdev->flCaps));

    DISPDBG((DBGLVL, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((ERRLVL, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[3];

    VideoMemory[0].RequestedVirtualAddress = ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                         &VideoMemory[0],
                         sizeof(VIDEO_MEMORY),
                         NULL,
                         0,
                         &ReturnedDataLength) != NO_ERROR)
    {
        DISPDBG((ERRLVL, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

    VideoMemory[0].RequestedVirtualAddress = ppdev->pulCtrlBase[0];
    VideoMemory[1].RequestedVirtualAddress = ppdev->pulCtrlBase[1];
    VideoMemory[2].RequestedVirtualAddress = ppdev->pulCtrlBase[2];

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                         &VideoMemory[0],
                         sizeof(VideoMemory),
                         NULL,
                         0,
                         &ReturnedDataLength) != NO_ERROR)
    {
        DISPDBG((ERRLVL, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
    }
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Determine if we are looking for a default mode:

    if ( ((pdm->dmPelsWidth)    ||
          (pdm->dmPelsHeight)   ||
          (pdm->dmBitsPerPel)   ||
          (pdm->dmDisplayFlags) ||
          (pdm->dmDisplayFrequency)) == 0)
    {
        bSelectDefault = TRUE;
    }
    else
    {
        bSelectDefault = FALSE;
    }

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((DBGLVL, "Default mode requested"));
    }
    else
    {
        DISPDBG((DBGLVL, "Requested mode..."));
        DISPDBG((DBGLVL, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((DBGLVL, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((DBGLVL, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((DBGLVL, "   Frequency     -- %li", pdm->dmDisplayFrequency));
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((DBGLVL, "   Checking against miniport mode:"));
            DISPDBG((DBGLVL, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((DBGLVL, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((DBGLVL, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                           pVideoTemp->NumberOfPlanes));
            DISPDBG((DBGLVL, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel)) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((DBGLVL, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((DBGLVL, "...Couldn't find a mode match!"));
        ENGFREEMEM(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    ENGFREEMEM(pVideoBuffer);

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;

    DISPDBG((DBGLVL, "ScreenStride: %li", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_FILLPATH   |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_LINETO     |
                               HOOK_PAINT      |
                            // HOOK_STRETCHBLT |
#if (_WIN32_WINNT >= 0x500)
#if defined(_NT5GDI)
                               HOOK_GRADIENTFILL |
                               HOOK_TRANSPARENTBLT |
                               HOOK_ALPHABLEND |
#endif
#endif // (_WIN32_WINNT >= 0x500)
                               0);

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;
    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cjPelSize       = 1;
        ppdev->cPelSize        = 0;
        ppdev->iBitmapFormat   = BMF_8BPP;

        if (VideoModeInformation.AttributeFlags & VIDEO_MODE_PALETTE_DRIVEN)
        {
            ppdev->ulWhite         = 0xff;
        }
        else
        {
            ppdev->flRed           = VideoModeInformation.RedMask;
            ppdev->flGreen         = VideoModeInformation.GreenMask;
            ppdev->flBlue          = VideoModeInformation.BlueMask;
            ppdev->ulWhite         = VideoModeInformation.RedMask   |
                                     VideoModeInformation.GreenMask |
                                     VideoModeInformation.BlueMask;

            pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pgdi->ulNumColors      = (ULONG) 256;
            pgdi->ulNumPalReg      = (ULONG) 256;
            pgdi->ulHTOutputFormat = HT_FORMAT_8BPP;
        }
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cjPelSize       = 2;
        ppdev->cPelSize        = 1;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        ppdev->ulWhite         = VideoModeInformation.RedMask   |
                                 VideoModeInformation.GreenMask |
                                 VideoModeInformation.BlueMask;

    }
    else if (VideoModeInformation.BitsPerPlane == 24)
    {
        ppdev->cjPelSize       = 3;
        ppdev->cPelSize        = 4;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->iBitmapFormat   = BMF_24BPP;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        ppdev->ulWhite         = VideoModeInformation.RedMask   |
                                 VideoModeInformation.GreenMask |
                                 VideoModeInformation.BlueMask;
    }
    else
    {
        ASSERTDD((VideoModeInformation.BitsPerPlane == 32) ||
                 (VideoModeInformation.BitsPerPlane == 12),
                 "This driver supports only 8, 16 and 32bpp");

        ppdev->cjPelSize       = 4;
        ppdev->cPelSize        = 2;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;
        ppdev->iBitmapFormat   = BMF_32BPP;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        ppdev->ulWhite         = VideoModeInformation.RedMask   |
                                 VideoModeInformation.GreenMask |
                                 VideoModeInformation.BlueMask;
    }

    DISPDBG((DBGLVL, "Passed bInitializeModeFields"));

    return(TRUE);

ReturnFalse:

    DISPDBG((ERRLVL, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp) != NO_ERROR)
    {
        DISPDBG((ERRLVL, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        ENGALLOCMEM(FL_ZERO_MEMORY,
                                   modes.NumModes * modes.ModeInformationLength,
                                   ALLOC_TAG_GDI(5));

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((ERRLVL, "getAvailableModes - Failed memory allocation"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp) != NO_ERROR)
    {

        DISPDBG((ERRLVL, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        ENGFREEMEM(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 12) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((WRNLVL, "Rejecting miniport mode:"));
            DISPDBG((WRNLVL, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((WRNLVL, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((WRNLVL, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                        pVideoTemp->NumberOfPlanes));
            DISPDBG((WRNLVL, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}

//*****************************************************************************
// FUNC: DrvEscape
// ARGS: pso (I) - the surface affected by this notification
//
//*****************************************************************************
ULONG APIENTRY DrvEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
)
{
    PDEV       *ppdev = (PDEV *) pso->dhpdev;
    ULONG       ulResult = 0;
    INT         iQuery;

    DISPDBG((DBGLVL,"In DrvEscape"));

    switch (iEsc)
    {
        case QUERYESCSUPPORT:
            iQuery = *(int *)pvIn;

            switch(iQuery)
            {
                case ESCAPE_TRACK_FUNCTION_COVERAGE:
                case ESCAPE_TRACK_CODE_COVERAGE:
                case ESCAPE_TRACK_MEMORY_ALLOCATION:
                    DISPDBG((DBGLVL,"In DrvEscape QUERYESCSUPPORT"));
                    ulResult = 1;
                default:
                    ulResult = 0;
            }
            break;

        case ESCAPE_TRACK_FUNCTION_COVERAGE:
            ulResult = 0;
#if DBG
            Debug_Func_Report_And_Reset();
            ulResult = 1;
#endif // DBG
            break;

        case ESCAPE_TRACK_CODE_COVERAGE:
            ulResult = 0;
#if DBG
            Debug_Code_Report_And_Reset();
            ulResult = 1;
#endif // DBG
            break;

        case ESCAPE_TRACK_MEMORY_ALLOCATION:
            ulResult = 0;
#if DBG
#endif // DBG
            break;

#ifdef DBG_EA_TAGS
        case ESCAPE_EA_TAG:
            if (pvIn)
            {
                DWORD dwEnable, dwTag;
                dwTag = *(DWORD *) pvIn;          // tag and enable flag
                dwEnable = dwTag & EA_TAG_ENABLE; // get enable flag
                dwTag &= ~EA_TAG_ENABLE;          // strip enable flag for range comparison

                if ((dwTag < MIN_EA_TAG) || (dwTag > MAX_EA_TAG))
                {
                    ulResult = -3;
                } // Invalid tag value
                else
                {
                    g_dwTag = dwTag | dwEnable;
                    ulResult = 1;
                } // Valid tag for value
            }
            else
            {
                ulResult = -2;
            } // NULL tag pointer
            break;
#endif // DBG_EA_TAGS

        default:
            DISPDBG((WRNLVL, "DrvEscape: unknown escape %d", iEsc));
            ulResult = 0;
    }

    return ulResult;
}

#if(_WIN32_WINNT >= 0x500)

//*****************************************************************************
// FUNC: DrvNotify
// ARGS: pso (I) - the surface affected by this notification
//       iType (I) - notification type
//       pvData (I) - notification data: format depends on iType
// RETN: void
//-----------------------------------------------------------------------------
//*****************************************************************************

VOID DrvNotify(IN SURFOBJ *pso, IN ULONG iType, IN PVOID pvData)
{
    PDEV *ppdev;

    ASSERTDD(pso->iType != STYPE_BITMAP, "ERROR - DrvNotify called for DIB surface!");

    ppdev = (PDEV *)pso->dhpdev;

    switch(iType)
    {
    case DN_ACCELERATION_LEVEL:
        {
            ULONG ul = *(ULONG *)pvData;

            DISPDBG((DBGLVL, "DrvNotify: DN_ACCELERATION_LEVEL = %d", ul));
        }
        break;

    case DN_DEVICE_ORIGIN:
        {
            POINTL ptl = *(POINTL *)pvData;

            DISPDBG((DBGLVL, "DrvNotify: DN_DEVICE_ORIGIN xy == (%xh,%xh)", ptl.x, ptl.y));
        }
        break;

    case DN_SLEEP_MODE:
        DISPDBG((DBGLVL, "DrvNotify: DN_SLEEP_MODE"));
        break;

    case DN_DRAWING_BEGIN:
        DISPDBG((DBGLVL, "DrvNotify: DN_DRAWING_BEGIN"));

#if ENABLE_DXMANAGED_LINEAR_HEAP
        if((ppdev->flStatus & (ENABLE_LINEAR_HEAP | STAT_DEV_BITMAPS)) == (ENABLE_LINEAR_HEAP | STAT_DEV_BITMAPS))
        {
            if(ppdev->heap.cLinearHeaps)
            {
                // finally free to use the DX heap manager
                DISPDBG((DBGLVL, "DrvNotify: enabling DX heap manager"));
                ppdev->flStatus |= STAT_LINEAR_HEAP;
            }
            else
            {
                DISPDBG((ERRLVL, "DrvNotify: DX heap manager not enabled - there are no DX heaps! Remain using the 2D heap manager"));
            }
        }
#endif //ENABLE_DXMANAGED_LINEAR_HEAP
        break;

    default:
        DISPDBG((WRNLVL, "DrvNotify: unknown notification type %d", iType));
    }
}

#endif //(_WIN32_WINNT >= 0x500)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\glntctxt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: glntctxt.c
*
* Content: 
*
*     Context switching for GLINT. Used to create and swap contexts in and out.
*    The display driver has a context, the 3D extension has another 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"
#include "glntctxt.h"

DWORD readableRegistersP3[] = {
    __GlintTagStartXDom,                         // [0x000]
    __GlintTagdXDom,                             // [0x001]
    __GlintTagStartXSub,                         // [0x002]
    __GlintTagdXSub,                             // [0x003]
    __GlintTagStartY,                            // [0x004]
    __GlintTagdY,                                // [0x005]
    __GlintTagCount,                             // [0x006]
    __GlintTagPointTable0,                       // [0x010]
    __GlintTagPointTable1,                       // [0x011]
    __GlintTagPointTable2,                       // [0x012]
    __GlintTagPointTable3,                       // [0x013]
    __GlintTagRasterizerMode,                    // [0x014]
    __GlintTagYLimits,                           // [0x015]
    //__GlintTagScanlineOwnership,               // [0x016]
    __GlintTagPixelSize,                         // [0x018]
    //__GlintTagFastBlockLimits,                 // [0x026]
    __GlintTagScissorMode,                       // [0x030]
    __GlintTagScissorMinXY,                      // [0x031]
    __GlintTagScissorMaxXY,                      // [0x032]
    //__GlintTagScreenSize,                      // [0x033]
    __GlintTagAreaStippleMode,                   // [0x034]
    __GlintTagLineStippleMode,                   // [0x035]
    __GlintTagLoadLineStippleCounters,           // [0x036]
    __GlintTagWindowOrigin,                      // [0x039]
    __GlintTagAreaStipplePattern0,               // [0x040]
    __GlintTagAreaStipplePattern1,               // [0x041]
    __GlintTagAreaStipplePattern2,               // [0x042]
    __GlintTagAreaStipplePattern3,               // [0x043]
    __GlintTagAreaStipplePattern4,               // [0x044]
    __GlintTagAreaStipplePattern5,               // [0x045]
    __GlintTagAreaStipplePattern6,               // [0x046]
    __GlintTagAreaStipplePattern7,               // [0x047]
    __GlintTagAreaStipplePattern8,               // [0x048]
    __GlintTagAreaStipplePattern9,               // [0x049]
    __GlintTagAreaStipplePattern10,              // [0x04A]
    __GlintTagAreaStipplePattern11,              // [0x04B]
    __GlintTagAreaStipplePattern12,              // [0x04C]
    __GlintTagAreaStipplePattern13,              // [0x04D]
    __GlintTagAreaStipplePattern14,              // [0x04E]
    __GlintTagAreaStipplePattern15,              // [0x04F]
    __GlintTagAreaStipplePattern16,              // [0x050]
    __GlintTagAreaStipplePattern17,              // [0x051]
    __GlintTagAreaStipplePattern18,              // [0x052]
    __GlintTagAreaStipplePattern19,              // [0x053]
    __GlintTagAreaStipplePattern20,              // [0x054]
    __GlintTagAreaStipplePattern21,              // [0x055]
    __GlintTagAreaStipplePattern22,              // [0x056]
    __GlintTagAreaStipplePattern23,              // [0x057]
    __GlintTagAreaStipplePattern24,              // [0x058]
    __GlintTagAreaStipplePattern25,              // [0x059]
    __GlintTagAreaStipplePattern26,              // [0x05A]
    __GlintTagAreaStipplePattern27,              // [0x05B]
    __GlintTagAreaStipplePattern28,              // [0x05C]
    __GlintTagAreaStipplePattern29,              // [0x05D]
    __GlintTagAreaStipplePattern30,              // [0x05E]
    __GlintTagAreaStipplePattern31,              // [0x05F]
    __PXRXTagTextureCoordMode,                   // [0x070]
    __GlintTagSStart,                            // [0x071]
    __GlintTagdSdx,                              // [0x072]
    __GlintTagdSdyDom,                           // [0x073]
    __GlintTagTStart,                            // [0x074]
    __GlintTagdTdx,                              // [0x075]
    __GlintTagdTdyDom,                           // [0x076]
    __GlintTagQStart,                            // [0x077]
    __GlintTagdQdx,                              // [0x078]
    __GlintTagdQdyDom,                           // [0x079]
    __GlintTagLOD,                               // [0x07A]
    __GlintTagdSdy,                              // [0x07B]
    __GlintTagdTdy,                              // [0x07C]
    __GlintTagdQdy,                              // [0x07D]
    __PXRXTagS1Start,                            // [0x080]
    __PXRXTagdS1dx,                              // [0x081]
    __PXRXTagdS1dyDom,                           // [0x082]
    __PXRXTagT1Start,                            // [0x083]
    __PXRXTagdT1dx,                              // [0x084]
    __PXRXTagdT1dyDom,                           // [0x085]
    __PXRXTagQ1Start,                            // [0x086]
    __PXRXTagdQ1dx,                              // [0x087]
    __PXRXTagdQ1dyDom,                           // [0x088]
    __GlintTagLOD1,                              // [0x089]
    __GlintTagTextureLODBiasS,                   // [0x08A]
    __GlintTagTextureLODBiasT,                   // [0x08B]
    __GlintTagTextureReadMode,                   // [0x090]
    __GlintTagTextureFormat,                     // [0x091]
    __GlintTagTextureCacheControl,               // [0x092]
    __GlintTagBorderColor,                       // [0x095]
    //__GlintTagLUTIndex,                        // [0x098]
    //__GlintTagLUTData,                         // [0x099]
    //__GlintTagLUTAddress,                      // [0x09A]
    //__GlintTagLUTTransfer,                     // [0x09B]
    __GlintTagTextureFilterMode,                 // [0x09C]
    __GlintTagTextureChromaUpper,                // [0x09D]
    __GlintTagTextureChromaLower,                // [0x09E]
    __GlintTagBorderColor1,                      // [0x09F]
    __GlintTagTextureBaseAddress,                // [0x0A0]
    __GlintTagTextureBaseAddressLR,              // [0x0A1]
    __GlintTagTextureBaseAddress2,               // [0x0A2]
    __GlintTagTextureBaseAddress3,               // [0x0A3]
    __GlintTagTextureBaseAddress4,               // [0x0A4]
    __GlintTagTextureBaseAddress5,               // [0x0A5]
    __GlintTagTextureBaseAddress6,               // [0x0A6]
    __GlintTagTextureBaseAddress7,               // [0x0A7]
    __GlintTagTextureBaseAddress8,               // [0x0A8]
    __GlintTagTextureBaseAddress9,               // [0x0A9]
    __GlintTagTextureBaseAddress10,              // [0x0AA]
    __GlintTagTextureBaseAddress11,              // [0x0AB]
    __GlintTagTextureBaseAddress12,              // [0x0AC]
    __GlintTagTextureBaseAddress13,              // [0x0AD]
    __GlintTagTextureBaseAddress14,              // [0x0AE]
    __GlintTagTextureBaseAddress15,              // [0x0AF]
    __PXRXTagTextureMapWidth0,                   // [0x0B0]
    __PXRXTagTextureMapWidth1,                   // [0x0B1]
    __PXRXTagTextureMapWidth2,                   // [0x0B2]
    __PXRXTagTextureMapWidth3,                   // [0x0B3]
    __PXRXTagTextureMapWidth4,                   // [0x0B4]
    __PXRXTagTextureMapWidth5,                   // [0x0B5]
    __PXRXTagTextureMapWidth6,                   // [0x0B6]
    __PXRXTagTextureMapWidth7,                   // [0x0B7]
    __PXRXTagTextureMapWidth8,                   // [0x0B8]
    __PXRXTagTextureMapWidth9,                   // [0x0B9]
    __PXRXTagTextureMapWidth10,                  // [0x0BA]
    __PXRXTagTextureMapWidth11,                  // [0x0BB]
    __PXRXTagTextureMapWidth12,                  // [0x0BC]
    __PXRXTagTextureMapWidth13,                  // [0x0BD]
    __PXRXTagTextureMapWidth14,                  // [0x0BE]
    __PXRXTagTextureMapWidth15,                  // [0x0BF]
    __PXRXTagTextureChromaUpper1,                // [0x0C0]
    __PXRXTagTextureChromaLower1,                // [0x0C1]
    __PXRXTagTextureApplicationMode,             // [0x0D0]
    __GlintTagTextureEnvColor,                   // [0x0D1]
    __GlintTagFogMode,                           // [0x0D2]
    __GlintTagFogColor,                          // [0x0D3]
    __GlintTagFStart,                            // [0x0D4]
    __GlintTagdFdx,                              // [0x0D5]
    __GlintTagdFdyDom,                           // [0x0D6]
    __GlintTagZFogBias,                          // [0x0D7]
    __GlintTagRStart,                            // [0x0F0]
    __GlintTagdRdx,                              // [0x0F1]
    __GlintTagdRdyDom,                           // [0x0F2]
    __GlintTagGStart,                            // [0x0F3]
    __GlintTagdGdx,                              // [0x0F4]
    __GlintTagdGdyDom,                           // [0x0F5]
    __GlintTagBStart,                            // [0x0F6]
    __GlintTagdBdx,                              // [0x0F7]
    __GlintTagdBdyDom,                           // [0x0F8]
    __GlintTagAStart,                            // [0x0F9]
    __GlintTagdAdx,                              // [0x0FA]
    __GlintTagdAdyDom,                           // [0x0FB]
    __GlintTagColorDDAMode,                      // [0x0FC]
    __GlintTagConstantColor,                     // [0x0FD]
    __GlintTagColor,                             // [0x0FE]
    __GlintTagAlphaTestMode,                     // [0x100]
    __GlintTagAntialiasMode,                     // [0x101]
    __GlintTagDitherMode,                        // [0x103]
    __GlintTagFBSoftwareWriteMask,               // [0x104]
    __GlintTagLogicalOpMode,                     // [0x105]
    __GlintTagRouterMode,                        // [0x108]
    __GlintTagLBReadFormat,                      // [0x111]
    __GlintTagLBSourceOffset,                    // [0x112]
    __GlintTagLBWriteMode,                       // [0x118]
    __GlintTagLBWriteFormat,                     // [0x119]
    //__GlintTagTextureDownloadOffset,           // [0x11E]
    __GlintTagWindow,                            // [0x130]
    __GlintTagStencilMode,                       // [0x131]
    __GlintTagStencilData,                       // [0x132]
    __GlintTagStencil,                           // [0x133]
    __GlintTagDepthMode,                         // [0x134]
    __GlintTagDepth,                             // [0x135]
    __GlintTagZStartU,                           // [0x136]
    __GlintTagZStartL,                           // [0x137]
    __GlintTagdZdxU,                             // [0x138]
    __GlintTagdZdxL,                             // [0x139]
    __GlintTagdZdyDomU,                          // [0x13A]
    __GlintTagdZdyDomL,                          // [0x13B]
    __GlintTagFastClearDepth,                    // [0x13C]
    __GlintTagFBWriteMode,                       // [0x157]
    __GlintTagFBHardwareWriteMask,               // [0x158]
    __GlintTagFBBlockColor,                      // [0x159]
    //__GlintTagFilterMode,                      // [0x180]
    __GlintTagStatisticMode,                     // [0x181]
    __GlintTagMinRegion,                         // [0x182]
    __GlintTagMaxRegion,                         // [0x183]
    __GlintTagRLEMask,                           // [0x189]
    __GlintTagFBBlockColorBackU,                 // [0x18B]
    __GlintTagFBBlockColorBackL,                 // [0x18C]
    //__GlintTagFBBlockColorU,                   // [0x18D]
    //__GlintTagFBBlockColorL,                   // [0x18E]
    __GlintTagKsRStart,                          // [0x190]
    __GlintTagdKsRdx,                            // [0x191]
    __GlintTagdKsRdyDom,                         // [0x192]
    __GlintTagKsGStart,                          // [0x193]
    __GlintTagdKsGdx,                            // [0x194]
    __GlintTagdKsGdyDom,                         // [0x195]
    __GlintTagKsBStart,                          // [0x196]
    __GlintTagdKsBdx,                            // [0x197]
    __GlintTagdKsBdyDom,                         // [0x198]
    __GlintTagKdRStart,                          // [0x1A0]
    __GlintTagdKdRdx,                            // [0x1A1]
    __GlintTagdKdRdyDom,                         // [0x1A2]
    __GlintTagKdGStart,                          // [0x1A3]
    __GlintTagdKdGdx,                            // [0x1A4]
    __GlintTagdKdGdyDom,                         // [0x1A5]
    __GlintTagKdBStart,                          // [0x1A6]
    __GlintTagdKdBdx,                            // [0x1A7]
    __GlintTagdKdBdyDom,                         // [0x1A8]
    //LUT0,                                      // [0x1D0]
    //LUT1,                                      // [0x1D1]
    //LUT2,                                      // [0x1D2]
    //LUT3,                                      // [0x1D3]
    //LUT4,                                      // [0x1D4]
    //LUT5,                                      // [0x1D5]
    //LUT6,                                      // [0x1D6]
    //LUT7,                                      // [0x1D7]
    //LUT8,                                      // [0x1D8]
    //LUT9,                                      // [0x1D9]
    //LUT10,                                     // [0x1DA]
    //LUT11,                                     // [0x1DB]
    //LUT12,                                     // [0x1DC]
    //LUT13,                                     // [0x1DD]
    //LUT14,                                     // [0x1DE]
    //LUT15,                                     // [0x1DF]
    __PXRXTagYUVMode,                            // [0x1E0]
    __PXRXTagChromaUpper,                        // [0x1E1]
    __PXRXTagChromaLower,                        // [0x1E2]
    __GlintTagChromaTestMode,                    // [0x1E3]
    __PXRXTagV0FloatS1,                          // [0x200]
    __PXRXTagV0FloatT1,                          // [0x201]
    __PXRXTagV0FloatQ1,                          // [0x202]
    __PXRXTagV0FloatKsR,                         // [0x20A]
    __PXRXTagV0FloatKsG,                         // [0x20B]
    __PXRXTagV0FloatKsB,                         // [0x20C]
    __PXRXTagV0FloatKdR,                         // [0x20D]
    __PXRXTagV0FloatKdG,                         // [0x20E]
    __PXRXTagV0FloatKdB,                         // [0x20F]
    __PXRXTagV1FloatS1,                          // [0x210]
    __PXRXTagV1FloatT1,                          // [0x211]
    __PXRXTagV1FloatQ1,                          // [0x212]
    __PXRXTagV1FloatKsR,                         // [0x21A]
    __PXRXTagV1FloatKsG,                         // [0x21B]
    __PXRXTagV1FloatKsB,                         // [0x21C]
    __PXRXTagV1FloatKdR,                         // [0x21D]
    __PXRXTagV1FloatKdG,                         // [0x21E]
    __PXRXTagV1FloatKdB,                         // [0x21F]
    __PXRXTagV2FloatS1,                          // [0x220]
    __PXRXTagV2FloatT1,                          // [0x221]
    __PXRXTagV2FloatQ1,                          // [0x222]
    __PXRXTagV2FloatKsR,                         // [0x22A]
    __PXRXTagV2FloatKsG,                         // [0x22B]
    __PXRXTagV2FloatKsB,                         // [0x22C]
    __PXRXTagV2FloatKdR,                         // [0x22D]
    __PXRXTagV2FloatKdG,                         // [0x22E]
    __PXRXTagV2FloatKdB,                         // [0x22F]
    __PXRXTagV0FloatS,                           // [0x230]
    __PXRXTagV0FloatT,                           // [0x231]
    __PXRXTagV0FloatQ,                           // [0x232]
    __PXRXTagV0FloatR,                           // [0x235]
    __PXRXTagV0FloatG,                           // [0x236]
    __PXRXTagV0FloatB,                           // [0x237]
    __PXRXTagV0FloatA,                           // [0x238]
    __PXRXTagV0FloatF,                           // [0x239]
    __PXRXTagV0FloatX,                           // [0x23A]
    __PXRXTagV0FloatY,                           // [0x23B]
    __PXRXTagV0FloatZ,                           // [0x23C]
    __PXRXTagV0FloatW,                           // [0x23D]
    __PXRXTagV0FloatPackedColour,                // [0x23E]
    __PXRXTagV0FloatPackedSpecularFog,           // [0x23F]
    __RXRXTagV1FloatS,                           // [0x240]
    __RXRXTagV1FloatT,                           // [0x241]
    __RXRXTagV1FloatQ,                           // [0x242]
    __RXRXTagV1FloatR,                           // [0x245]
    __RXRXTagV1FloatG,                           // [0x246]
    __RXRXTagV1FloatB,                           // [0x247]
    __RXRXTagV1FloatA,                           // [0x248]
    __RXRXTagV1FloatF,                           // [0x249]
    __RXRXTagV1FloatX,                           // [0x24A]
    __RXRXTagV1FloatY,                           // [0x24B]
    __RXRXTagV1FloatZ,                           // [0x24C]
    __RXRXTagV1FloatW,                           // [0x24D]
    __RXRXTagV1FloatPackedColour,                // [0x24E]
    __RXRXTagV1FloatPackedSpecularFog,           // [0x24F]
    __RXRXTagV2FloatS,                           // [0x250]
    __RXRXTagV2FloatT,                           // [0x251]
    __RXRXTagV2FloatQ,                           // [0x252]
    __RXRXTagV2FloatR,                           // [0x255]
    __RXRXTagV2FloatG,                           // [0x256]
    __RXRXTagV2FloatB,                           // [0x257]
    __RXRXTagV2FloatA,                           // [0x258]
    __RXRXTagV2FloatF,                           // [0x259]
    __RXRXTagV2FloatX,                           // [0x25A]
    __RXRXTagV2FloatY,                           // [0x25B]
    __RXRXTagV2FloatZ,                           // [0x25C]
    __RXRXTagV2FloatW,                           // [0x25D]
    __RXRXTagV2FloatPackedColour,                // [0x25E]
    __RXRXTagV2FloatPackedSpecularFog,           // [0x25F]
    __DeltaTagDeltaMode,                         // [0x260]
    __DeltaTagProvokingVertex,                   // [0x267]
    __DeltaTagTextureLODScale,                   // [0x268]
    __DeltaTagTextureLODScale1,                  // [0x269]
    __DeltaTagDeltaControl,                      // [0x26A]
    __DeltaTagProvokingVertexMask,               // [0x26B]
    //__DeltaTagBroadcastMask,                   // [0x26F]
    //__DeltaTagDeltaTexture01,                  // [0x28B]
    //__DeltaTagDeltaTexture11,                  // [0x28C]
    //__DeltaTagDeltaTexture21,                  // [0x28D]
    //__DeltaTagDeltaTexture31,                  // [0x28E]
    __DeltaTagXBias,                             // [0x290]
    __DeltaTagYBias,                             // [0x291]
    __DeltaTagZBias,                             // [0x29F]
    //__GlintTagDMAAddr,                         // [0x530]
    //__GlintTagDMACount,                        // [0x531]
    //__GlintTagCommandInterrupt,                // [0x532]
    //__GlintTagDMARectangleRead,                // [0x535]
    //__GlintTagDMARectangleReadAddress,         // [0x536]
    //__GlintTagDMARectangleReadLinePitch,       // [0x537]
    //__GlintTagDMARectangleReadTarget,          // [0x538]
    //__GlintTagDMARectangleWrite,               // [0x539]
    //__GlintTagDMARectangleWriteAddress,        // [0x53A]
    //__GlintTagDMARectangleWriteLinePitch,      // [0x53B]
    //__GlintTagDMAOutputAddress,                // [0x53C]
    //__GlintTagDMAOutputCount,                  // [0x53D]
    //__GlintTagDMAFeedback,                     // [0x542]
    __GlintTagFBDestReadBufferAddr0,             // [0x5D0]
    __GlintTagFBDestReadBufferAddr1,             // [0x5D1]
    __GlintTagFBDestReadBufferAddr2,             // [0x5D2]
    __GlintTagFBDestReadBufferAddr3,             // [0x5D3]
    __GlintTagFBDestReadBufferOffset0,           // [0x5D4]
    __GlintTagFBDestReadBufferOffset1,           // [0x5D5]
    __GlintTagFBDestReadBufferOffset2,           // [0x5D6]
    __GlintTagFBDestReadBufferOffset3,           // [0x5D7]
    __GlintTagFBDestReadBufferWidth0,            // [0x5D8]
    __GlintTagFBDestReadBufferWidth1,            // [0x5D9]
    __GlintTagFBDestReadBufferWidth2,            // [0x5DA]
    __GlintTagFBDestReadBufferWidth3,            // [0x5DB]
    __GlintTagFBDestReadMode,                    // [0x5DC]
    __GlintTagFBDestReadEnables,                 // [0x5DD]
    __GlintTagFBSourceReadMode,                  // [0x5E0]
    __GlintTagFBSourceReadBufferAddr,            // [0x5E1]
    __GlintTagFBSourceReadBufferOffset,          // [0x5E2]
    __GlintTagFBSourceReadBufferWidth,           // [0x5E3]
    __GlintTagPCIWindowBase0,                    // [0x5E8]
    __GlintTagPCIWindowBase1,                    // [0x5E9]
    __GlintTagPCIWindowBase2,                    // [0x5EA]
    __GlintTagPCIWindowBase3,                    // [0x5EB]
    __GlintTagPCIWindowBase4,                    // [0x5EC]
    __GlintTagPCIWindowBase5,                    // [0x5ED]
    __GlintTagPCIWindowBase6,                    // [0x5EE]
    __GlintTagPCIWindowBase7,                    // [0x5EF]
    __GlintTagAlphaSourceColor,                  // [0x5F0]
    __GlintTagAlphaDestColor,                    // [0x5F1]
    __GlintTagChromaPassColor,                   // [0x5F2]
    __GlintTagChromaFailColor,                   // [0x5F3]
    __GlintTagAlphaBlendColorMode,               // [0x5F4]
    __GlintTagAlphaBlendAlphaMode,               // [0x5F5]
    //__GlintTagConstantColorDDA,                // [0x5F6]
    //__GlintTagD3DAlphaTestMode,                // [0x5F8]
    __GlintTagFBWriteBufferAddr0,                // [0x600]
    __GlintTagFBWriteBufferAddr1,                // [0x601]
    __GlintTagFBWriteBufferAddr2,                // [0x602]
    __GlintTagFBWriteBufferAddr3,                // [0x603]
    __GlintTagFBWriteBufferOffset0,              // [0x604]
    __GlintTagFBWriteBufferOffset1,              // [0x605]
    __GlintTagFBWriteBufferOffset2,              // [0x606]
    __GlintTagFBWriteBufferOffset3,              // [0x607]
    __GlintTagFBWriteBufferWidth0,               // [0x608]
    __GlintTagFBWriteBufferWidth1,               // [0x609]
    __GlintTagFBWriteBufferWidth2,               // [0x60A]
    __GlintTagFBWriteBufferWidth3,               // [0x60B]
    //__GlintTagFBBlockColor0,                   // [0x60C]
    //__GlintTagFBBlockColor1,                   // [0x60D]
    //__GlintTagFBBlockColor2,                   // [0x60E]
    //__GlintTagFBBlockColor3,                   // [0x60F]
    //__GlintTagFBBlockColorBack0,               // [0x610]
    //__GlintTagFBBlockColorBack1,               // [0x611]
    //__GlintTagFBBlockColorBack2,               // [0x612]
    //__GlintTagFBBlockColorBack3,               // [0x613]
    __GlintTagFBBlockColorBack,                  // [0x614]
    //__GlintTagSizeOfFramebuffer,               // [0x615]
    //__GlintTagVTGAddress,                      // [0x616]
    //__GlintTagVTGData,                         // [0x617]
    //__GlintTagForegroundColor,                 // [0x618]
    //__GlintTagBackgroundColor,                 // [0x619]
    //__GlintTagDownloadAddress,                 // [0x61A]
    //__GlintTagFBBlockColorExt,                 // [0x61C]
    //__GlintTagFBBlockColorBackExt,             // [0x61D]
    //__GlintTagFBWriteMaskExt,                  // [0x61E]
//@@BEGIN_DDKSPLIT
#if 0
    FogTable0,                         // [0x620]
    FogTable1,                         // [0x621]
    FogTable2,                         // [0x622]
    FogTable3,                         // [0x623]
    FogTable4,                         // [0x624]
    FogTable5,                         // [0x625]
    FogTable6,                         // [0x626]
    FogTable7,                         // [0x627]
    FogTable8,                         // [0x628]
    FogTable9,                         // [0x629]
    FogTable10,                        // [0x62A]
    FogTable11                     // [0x62B]
    FogTable12,                        // [0x62C]
    FogTable13,                        // [0x62D]
    FogTable14,                        // [0x62E]
    FogTable15,                        // [0x62F]
    FogTable16,                        // [0x630]
    FogTable17,                        // [0x631]
    FogTable18,                        // [0x632]
    FogTable19,                        // [0x633]
    FogTable20,                        // [0x634]
    FogTable21,                        // [0x635]
    FogTable22,                        // [0x636]
    FogTable23,                        // [0x637]
    FogTable24,                        // [0x638]
    FogTable25,                        // [0x639]
    FogTable26,                        // [0x63A]
    FogTable27,                        // [0x63B]
    FogTable28,                        // [0x63C]
    FogTable29,                        // [0x63D]
    FogTable30,                        // [0x63E]
    FogTable31,                        // [0x63F]
    FogTable32,                        // [0x640]
    FogTable33,                        // [0x641]
    FogTable34,                        // [0x642]
    FogTable35,                        // [0x643]
    FogTable36,                        // [0x644]
    FogTable37,                        // [0x645]
    FogTable38,                        // [0x646]
    FogTable39,                        // [0x647]
    FogTable40,                        // [0x648]
    FogTable41,                        // [0x649]
    FogTable42,                        // [0x64A]
    FogTable43,                        // [0x64B]
    FogTable44,                        // [0x64C]
    FogTable45,                        // [0x64D]
    FogTable46,                        // [0x64E]
    FogTable47,                        // [0x64F]
    FogTable48,                        // [0x650]
    FogTable49,                        // [0x651]
    FogTable50,                        // [0x652]
    FogTable51,                        // [0x653]
    FogTable52,                        // [0x654]
    FogTable53,                        // [0x655]
    FogTable54,                        // [0x656]
    FogTable55,                        // [0x657]
    FogTable56,                        // [0x658]
    FogTable57,                        // [0x659]
    FogTable58,                        // [0x65A]
    FogTable59,                        // [0x65B]
    FogTable60,                        // [0x65C]
    FogTable61,                        // [0x65D]
    FogTable62,                        // [0x65E]
    FogTable63,                        // [0x65F]
#endif
//@@END_DDKSPLIT
    __GlintTagTextureCompositeMode,    // [0x660]
    __GlintTagTextureCompositeColorMode0,        // [0x661]
    __GlintTagTextureCompositeAlphaMode0,        // [0x662]
    __GlintTagTextureCompositeColorMode1,        // [0x663]
    __GlintTagTextureCompositeAlphaMode1,        // [0x664]
    __GlintTagTextureCompositeFactor0,           // [0x665]
    __GlintTagTextureCompositeFactor1,           // [0x666]
    __GlintTagTextureIndexMode0,                 // [0x667]
    __GlintTagTextureIndexMode1,                 // [0x668]
    __GlintTagLodRange0,                         // [0x669]
    __GlintTagLodRange1,                         // [0x66A]
    //__GlintTagSetLogicalTexturePage,           // [0x66C]
    __GlintTagLUTMode,                           // [0x66F]
    __GlintTagTextureReadMode0,                  // [0x680]
    __GlintTagTextureReadMode1,                  // [0x681]
    __GlintTagTextureMapSize,                    // [0x685]
    //HeadPhysicalPageAllocation0,     // [0x690]
    //HeadPhysicalPageAllocation1,     // [0x691]
    //HeadPhysicalPageAllocation2,     // [0x692]
    //HeadPhysicalPageAllocation3,     // [0x693]
    //TailPhysicalPageAllocation0,     // [0x694]
    //TailPhysicalPageAllocation1,     // [0x695]
    //TailPhysicalPageAllocation2,     // [0x696]
    //TailPhysicalPageAllocation3,     // [0x697]
    //PhysicalPageAllocationTableAddr, // [0x698]
    //BasePageOfWorkingSet,            // [0x699]
    //LogicalTexturePageTableAddr,     // [0x69A]
    //LogicalTexturePageTableLength,   // [0x69B]
    __GlintTagLBDestReadMode,                    // [0x6A0]
    __GlintTagLBDestReadEnables,                 // [0x6A1]
    __GlintTagLBDestReadBufferAddr,              // [0x6A2]
    __GlintTagLBDestReadBufferOffset,            // [0x6A3]
    __GlintTagLBSourceReadMode,                  // [0x6A4]
    __GlintTagLBSourceReadBufferAddr,            // [0x6A5]
    __GlintTagLBSourceReadBufferOffset,          // [0x6A6]
    __GlintTagGIDMode,                           // [0x6A7]
    __GlintTagLBWriteBufferAddr,                 // [0x6A8]
    __GlintTagLBWriteBufferOffset,               // [0x6A9]
    __GlintTagLBClearDataL,                      // [0x6AA]
    __GlintTagLBClearDataU,                      // [0x6AB]
    __GlintTagRectanglePosition,                 // [0x6C0]
    //__GlintTagGlyphPosition,                   // [0x6C1]
    __GlintTagRenderPatchOffset,                 // [0x6C2]
    //__GlintTagConfig2D,                        // [0x6C3]
    //__GlintTagRender2D,                        // [0x6C8]
    //__GlintTagRender2DGlyph,                   // [0x6C9]
    __GlintTagDownloadTarget,                    // [0x6CA]
    //__GlintTagDownloadGlyphWidth,              // [0x6CB]
    //__GlintTagGlyphData,                       // [0x6CC]
    //__GlintTagPacked4Pixels,                   // [0x6CD]
    //__GlintTagRLData,                          // [0x6CE]
    //__GlintTagRLCount,                         // [0x6CF]
    //__GlintTagKClkProfileMask0,                // [0x6D4]
    //__GlintTagKClkProfileMask1,                // [0x6D5]
    //__GlintTagKClkProfileMask2,                // [0x6D6]
    //__GlintTagKClkProfileMask3,                // [0x6D7]
    //__GlintTagKClkProfileCount0,               // [0x6D8]
    //__GlintTagKClkProfileCount1,               // [0x6D9]
    //__GlintTagKClkProfileCount2,               // [0x6DA]
    //__GlintTagKClkProfileCount3,               // [0x6DB]
};

#define N_READABLE_TAGSP3                                         \
    (sizeof(readableRegistersP3) / sizeof(readableRegistersP3[0]))

//@@BEGIN_DDKSPLIT
//
// the status flags are used to indicate whether DMA has completed, the
// GLINT is synced etc. This has to be global for each board. The whole
// idea is that we can do a quick check without having to read a chip
// register. So for speed of access we'll make it visible everywhere
//
// !!! azn - we had to reintroduce this g_CC in order to fix the 
//           regular recurrence of bug #158713 (pxrxFifoUpload stall)
//           we have to chk later how to rewrite it
//@@END_DDKSPLIT

/******************************************************************************
 * GlintAllocateNewContext:
 *
 *  Allocate a new context. If all registers are to be saved in the context 
 *  then pTag is passed as null. The priv field is an opaque handle which the 
 *  caller passes in. It is saved as part of the context and used to disable 
 *  any context which causes the chip to lockup.
 *
 ******************************************************************************/
LONG GlintAllocateNewContext(
PPDEV   ppdev,
DWORD   *pTag,
LONG    ntags,
ULONG   NumSubBuffers,
PVOID   priv,
ContextType ctxtType)
{
    GlintCtxtTable      *pCtxtTable, *pNewCtxtTable;
    GlintCtxtRec        **ppEntry;
    GlintCtxtRec        *pEntry;
    CtxtData            *pData;
    LONG                nEntries, size, ctxtId;
    ULONG               *pul;
    GLINT_DECL;

    // first time round allocate the context table of pointers. We will
    // grow this table as required.
    if (ppdev->pGContextTable == NULL)
    {
        DISPDBG((DBGLVL, "creating context table"));
        size = sizeof(GlintCtxtTable);
        pCtxtTable = (GlintCtxtTable*)ENGALLOCMEM(FL_ZERO_MEMORY, 
                                                   size, 
                                                   ALLOC_TAG_GDI(7));
        if (pCtxtTable == NULL)
        {
            DISPDBG((ERRLVL, "Failed to allocate GLINT context table. "
                             "Out of memory"));
            return(-1);
        }
        pCtxtTable->nEntries = CTXT_CHUNK;
        pCtxtTable->size = size;
        ppdev->pGContextTable = pCtxtTable;
    }

    // Always update this. If a new PDEV comes along for this board we need
    // to initialize its current context. One way to do this would be to
    // provide an explicit function to do the job but why do that to update
    // one variable. Anyway context allocation is pretty rare so this extra
    // assign isn't too much of a overhead.
    //
    ppdev->currentCtxt = -1;

    // Find an empty entry in the table
    // I suppose if we have hundreds of contexts this could be a bit slow but
    // allocating the context isn't time critical, swapping in and out is.
    //
    pCtxtTable = ppdev->pGContextTable;
    nEntries = pCtxtTable->nEntries;
    ppEntry = &pCtxtTable->pEntry[0];
    for (ctxtId = 0; ctxtId < nEntries; ++ctxtId)
    {
        if (*ppEntry == 0)
        {
            DISPDBG((DBGLVL, "found free context id %d", ctxtId));
            break;
        }
        ++ppEntry;
    }
    DISPDBG((DBGLVL, "Got ppEntry = 0x%x", ppEntry));
    DISPDBG((DBGLVL, "Got *ppEntry = 0x%x", *ppEntry));

    // if we found no free entries try to grow the table
    if (ctxtId == nEntries)
    {
        DISPDBG((WRNLVL, "context table full so enlarging"));
        size = pCtxtTable->size + (CTXT_CHUNK * sizeof(GlintCtxtRec*));
        pNewCtxtTable = (GlintCtxtTable*)ENGALLOCMEM(FL_ZERO_MEMORY, 
                                                      size, 
                                                      ALLOC_TAG_GDI(8));
        if (pNewCtxtTable == NULL)
        {
            DISPDBG((ERRLVL, "failed to increase GLINT context table. "
                             "Out of memory"));
            return(-1);
        }
        // copy the old table to the new one
        RtlCopyMemory(pNewCtxtTable, pCtxtTable, pCtxtTable->size);
        pNewCtxtTable->size = size;
        pNewCtxtTable->nEntries = nEntries + CTXT_CHUNK;
        ppdev->pGContextTable = pNewCtxtTable;
        
        // first of the newly allocated entries is next free one
        ctxtId = nEntries;
        ppEntry = &pNewCtxtTable->pEntry[ctxtId];

        // free the old context table and reassign some variables
        ENGFREEMEM(pCtxtTable);
        pCtxtTable = pNewCtxtTable;
        nEntries = pCtxtTable->nEntries;
    }

    size = sizeof(GlintCtxtRec) - sizeof(CtxtData);
    if( ctxtType == ContextType_RegisterList )
    {
        // if pTag is passed as null then we are to add all 
        // readable registers to the context.
        if( pTag == NULL )
        {
            DISPDBG((DBGLVL, "adding all readable P3 registers to the context"));
            
            pTag = readableRegistersP3;
            ntags = N_READABLE_TAGSP3;
        }

        // now allocate space for the new entry. We are given the number of 
        // tags to save when context switching. Allocate twice this much 
        // memory as we have to hold the data values as well.
        DISPDBG((DBGLVL, "Allocating space for context. ntags = %d", ntags));
        size += ntags * sizeof(CtxtData);
    }

    *ppEntry = (GlintCtxtRec*)ENGALLOCMEM(FL_ZERO_MEMORY, 
                                         size, 
                                         ALLOC_TAG_GDI(9));
    if (*ppEntry == NULL)
    {
        DISPDBG((ERRLVL, "Out of memory "
                         "trying to allocate space for new context"));
        return(-1);
    }
    
    pEntry = *ppEntry;
    DISPDBG((DBGLVL, "Got pEntry 0x%x", pEntry));
    pEntry->type = ctxtType;

    pEntry->ntags = ntags;
    pEntry->priv = priv;
    pData = pEntry->pData;

    DISPDBG((DBGLVL, "pEntry setup"));

    switch (pEntry->type)
    {
    case ContextType_None:
        DISPDBG((DBGLVL, "context is of type 'None'"));   
        // doing nothing
        break;

    case ContextType_RegisterList:
        DISPDBG((DBGLVL, "context is of type 'RegisterList'"));
        while (--ntags >= 0)
        {
            pData->tag = *pTag++;
            READ_GLINT_FIFO_REG(pData->tag, pData->data);
            ++pData;
        }
        break;

    case ContextType_Fixed:
        DISPDBG((DBGLVL, "context is of type 'Fixed'"));
        pEntry->dumpFunc = (ContextFixedFunc) pTag;
        break;
    default:
        DISPDBG((DBGLVL, "context is of unknown type: %d", ctxtType));    
        break;
    }

    // init the control registers that we save in the context.
    //
    pEntry->DoubleWrite = 0;

//@@BEGIN_DDKSPLIT
    // TMM: Find out the current setting of DISCONNECT and use that one
    // this might seem a bit strange but we want to inherit the crrent
    // setting of Disconnect.
//@@END_DDKSPLIT
    READ_GLINT_CTRL_REG (DisconnectControl, pEntry->inFifoDisc);
    READ_GLINT_CTRL_REG (VideoControl, pEntry->VideoControl);
    READ_GLINT_CTRL_REG (DMAControl, pEntry->DMAControl); 
    
    // if no interrupt driven DMA or asked for less than 3 buffers then
    // configure no Q for this context 
    if (!GLINT_INTERRUPT_DMA || (NumSubBuffers <= 2))
    {
        NumSubBuffers = 0;
    }

    // initialize the size of the Q for interrupt driven DMA. We must always
    // set the Q length to 2 less than the number of sub-buffers. This is so
    // that we block before allowing the application to write to a buffer that
    // has no yet been DMA'ed. Since the Q always has  a blank entry to make
    // it circular the endIndex of the Q is one beyond the end
    // (i.e. the number of entries in the Q is endIndex-1) so subtract one
    // from the number of sub-buffers to get the endIndex.
    // If NumSubBuffers is zero then we are not using interrupt driven DMA
    // for this context.

    if (NumSubBuffers > 0)
    {
        pEntry->endIndex = NumSubBuffers-1;
    }
    else
    {
        pEntry->endIndex = 0;
    }

    DISPDBG((DBGLVL, "Allocated context %d", ctxtId));
    return(ctxtId);
    
} //GlintAllocateNewContext

/******************************************************************************
 * vGlintFreeContext:
 *
 *  Free a previously allocated context
 *
 ******************************************************************************/
VOID vGlintFreeContext(
PPDEV   ppdev,
LONG    ctxtId)
{
    GlintCtxtTable *pCtxtTable;
    GlintCtxtRec   **ppEntry;
    BOOL           bAllCtxtsFreed;
    LONG           i;
    
    pCtxtTable = ppdev->pGContextTable;

    if (pCtxtTable == NULL)
    {
        DISPDBG((ERRLVL,"vGlintFreeContext: no contexts have been created!"));
        return;
    }

    if ((ctxtId < 0) || (ctxtId >= pCtxtTable->nEntries))
    {
        DISPDBG((ERRLVL,
                 "vGlintFreeContext: Trying to free out of range context"));
        return;
    }

    ppEntry = &pCtxtTable->pEntry[ctxtId];

    // If the entry is not yet free (it shouldn't) free it
    if (NULL != *ppEntry)
    {
        ENGFREEMEM(*ppEntry);
        *ppEntry = 0;   // marks it as free
    }
    else
    {
        DISPDBG((WRNLVL, "vGlintFreeContext: ppEntry already freed "
                         "ctxtId = %d", ctxtId));
    }

    // If there are no more valid contexts in the context table, lets
    // destroy it, otherwise it will leak memory. Whenever we get called
    // to allocate a new context, it will be created if necessary
    bAllCtxtsFreed = TRUE;
    for (i = 0; i < pCtxtTable->nEntries; i++)
    {
        bAllCtxtsFreed = bAllCtxtsFreed && (pCtxtTable->pEntry[i] == NULL);
    }
    
    if(bAllCtxtsFreed)
    {
        ENGFREEMEM(ppdev->pGContextTable);
        ppdev->pGContextTable = NULL;
    }

    // if this was the current context, mark the current context as invalid so 
    // we force a reload next time. Guard against null pointers when exiting 
    // from DrvEnableSurface with some error condition
    
    if (ppdev->currentCtxt == ctxtId)
    { 
        if (ppdev->bEnabled)
        {
            // only sync if PDEV is enabled as we can be called from 
            // DrvDisableSUrface after the PDEV was disabled by 
            // DrvAssertMode(,FALSE)
            GLINT_DECL;
            SYNC_WITH_GLINT;
        }
        ppdev->currentCtxt = -1;
        ppdev->g_GlintBoardStatus &= ~(GLINT_INTR_CONTEXT | GLINT_DUAL_CONTEXT);
    }
    
    DISPDBG((DBGLVL, "Released context %d", ctxtId));
    
} // vGlintFreeContext

/******************************************************************************
 * vGlintSwitchContext
 *
 *  Load a new context into the hardware. We assume that this call is protected 
 *  by a test that the given context is not the current one - hence the 
 *  assertion. The code would work but the driver should never try to load an 
 *  already loaded context so we trap it as an error.
 *
 * The NON_GLINT_CONTEXT_ID is used by 2D accelerators on combo boards. Effectively,
 * we use it to extend the context switching to allow syncing between the 2D and
 * the GLINT chips. As they are both talking to the same framebuffer, we cannot
 * allow both to be active at the same time. Of course, in the future we could
 * come up with some mutual exclusion scheme based on the bounding boxes of the
 * areas into which each chip is rendering, but that would require major surgery
 * to both the 2D driver and the 3D extension.
 *
 ******************************************************************************/
VOID vGlintSwitchContext(
PPDEV   ppdev,
LONG    ctxtId)
{
    GlintCtxtTable *pCtxtTable;
    GlintCtxtRec   *pEntry;
    CtxtData       *pData;
    LONG           oldCtxtId;
    ULONG          enableFlags;
    LONG           ntags, n;
    LONG           i;
    ULONG          *pul;
    GLINT_DECL;

    pCtxtTable = ppdev->pGContextTable;


    if (pCtxtTable == NULL)
    {
        DISPDBG((ERRLVL,"vGlintSwitchContext: no contexts have been created!"));
        return;
    }
    
    oldCtxtId = ppdev->currentCtxt;

    DISPDBG((DBGLVL, "swapping from context %d to context %d", 
                     oldCtxtId, ctxtId));

    if ((ctxtId < -1) || (ctxtId >= pCtxtTable->nEntries))
    {
        DISPDBG((ERRLVL,
                 "vGlintSwitchContext: Trying to free out of range context"));
        return;
    }

    // sync with the chip before reading back the current state. The flag
    // is used to control context manipulation on lockup recovery.
    //
    DISPDBG((DBGLVL, "SYNC_WITH_GLINT for context switch"));
    SYNC_WITH_GLINT;

    ASSERTDD(!(ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT) ||
                ((ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT) &&
                    (glintInfo->pInterruptCommandBlock->frontIndex ==
                     glintInfo->pInterruptCommandBlock->backIndex)),
            "Trying to context switch with outstanding DMA queue entries");

    if (oldCtxtId != -1) 
    {
        pEntry = pCtxtTable->pEntry[oldCtxtId];

        if (pEntry != NULL)
        {
            pData  = pEntry->pData;
            ntags  = pEntry->ntags;

            switch (pEntry->type)
            {
            case ContextType_None:
                // nothing doing
                DISPDBG((DBGLVL, "Context is of type none - doing nothing"));
                break;

            case ContextType_Fixed:
                DISPDBG((DBGLVL, "Context is of type fixed, calling dumpFunc "
                                 "0x%08X with FALSE", pEntry->dumpFunc));
                pEntry->dumpFunc(ppdev, FALSE);
                break;

            case ContextType_RegisterList:
                while( --ntags >= 0 )
                {
                    READ_GLINT_FIFO_REG(pData->tag, pData->data);
                    DISPDBG((DBGLVL, "readback tag 0x%x, data 0x%x", 
                                     pData->tag, pData->data));
                    ++pData;
                }
                break;

            default:
                DISPDBG((ERRLVL, "Context is of unknown type!!!"));
            }

            // Save disconnect
            READ_GLINT_CTRL_REG (DisconnectControl, pEntry->inFifoDisc);
            READ_GLINT_CTRL_REG (VideoControl, pEntry->VideoControl);
            READ_GLINT_CTRL_REG (DMAControl, pEntry->DMAControl);

            // disable interrupt driven DMA. New context may re-enable it. 
            // Clear dual TX status while we're at it.
            ppdev->g_GlintBoardStatus &= ~(GLINT_INTR_CONTEXT | GLINT_DUAL_CONTEXT);

            READ_GLINT_CTRL_REG (IntEnable, enableFlags);
            WRITE_GLINT_CTRL_REG(IntEnable, enableFlags & ~(INTR_ENABLE_DMA));
            if (GLINT_DELTA_PRESENT)
            {
                READ_GLINT_CTRL_REG (DeltaIntEnable, enableFlags);
                WRITE_GLINT_CTRL_REG(DeltaIntEnable, 
                                     enableFlags & ~(INTR_ENABLE_DMA));
            }
            
            DISPDBG((DBGLVL, "DMA Interrupt disabled"));             

            // record whether double writes are enabled or not
            if (glintInfo->flags & GLICAP_RACER_DOUBLE_WRITE)
            {
                GET_RACER_DOUBLEWRITE (pEntry->DoubleWrite);
            }
        }
        else
        {
            // nothing doing
            DISPDBG((ERRLVL, "Context pEntry is unexpectedly NULL! (2)"));        
        }
    }


    // load the new context. We allow -1 to be passed so that we can force a
    // save of the current context and force the current context to be
    // undefined.
    //
    if (ctxtId != -1)
    {   
//@@BEGIN_DDKSPLIT    
        // AZN Assert taken out since we now check below for (pEntry != NULL)
        //ASSERTDD(pCtxtTable->pEntry[ctxtId] != 0, 
        //         "Trying to load a freed context");
//@@END_DDKSPLIT        

        pEntry = pCtxtTable->pEntry[ctxtId];

        if (pEntry != NULL)
        {
            switch (pEntry->type)
            {
            case ContextType_None:
                // nothing doing
                DISPDBG((DBGLVL, "Context is of type none, doing nothing"));
                break;

            case ContextType_Fixed:
                DISPDBG((DBGLVL,"Context is of type fixed, "
                                "calling dumpFunc 0x%08X with TRUE", 
                                pEntry->dumpFunc));
                pEntry->dumpFunc(ppdev, TRUE);
                break;

            case ContextType_RegisterList:
                ntags = pEntry->ntags;
                pData = pEntry->pData;

                while (ntags > 0)
                {
                    n = 16;
                    WAIT_GLINT_FIFO(n);
                    ntags -= n;
                    
                    if (ntags < 0)
                    {
                        n += ntags;
                    }
                    
                    while (--n >= 0) 
                    {
                        LD_GLINT_FIFO(pData->tag, pData->data);
                        DISPDBG((DBGLVL, "loading tag 0x%x, data 0x%x", 
                                         pData->tag, pData->data));
                        ++pData;
                    }
                }
                break;

            default:
                DISPDBG((ERRLVL, "Context is of unknown type!!!"));
            }

            // load up the control registers
            //
            if (glintInfo->flags & GLICAP_RACER_DOUBLE_WRITE)
            {
                SET_RACER_DOUBLEWRITE (pEntry->DoubleWrite);            
            }

            // Restore disconnect
            WRITE_GLINT_CTRL_REG (DisconnectControl, pEntry->inFifoDisc);
            WRITE_GLINT_CTRL_REG (VideoControl, 
                                  ((pEntry->VideoControl & 0xFFFFFF87) | 0x29));
            WRITE_GLINT_CTRL_REG (DMAControl, pEntry->DMAControl); 

            // if using interrupt driven DMA for this context (endIndex > 0) then
            // restore the size of the interrupt driven DMA queue for this context
            // and reset the queue.
            //
            if (pEntry->endIndex > 0)
            {
                ASSERTDD(GLINT_INTERRUPT_DMA,
                         "trying to set up DMA Q "
                         "but no interrupt driven DMA available");
                         
                ASSERTDD(glintInfo->pInterruptCommandBlock->frontIndex == 
                         glintInfo->pInterruptCommandBlock->backIndex,
                        "Trying to context switch "
                        "with outstanding DMA queue entries");
                        
                glintInfo->pInterruptCommandBlock->frontIndex = 0;
                glintInfo->pInterruptCommandBlock->backIndex  = 0;
                glintInfo->pInterruptCommandBlock->endIndex = pEntry->endIndex;
                ppdev->g_GlintBoardStatus |= GLINT_INTR_CONTEXT;
                
                READ_GLINT_CTRL_REG (IntEnable, enableFlags);
                DISPDBG((DBGLVL, "DMA Interrupt enabled. flags = 0x%x", 
                                    enableFlags | 
                                    (INTR_ENABLE_DMA|INTR_ENABLE_ERROR)));             

                WRITE_GLINT_CTRL_REG(IntEnable, enableFlags      | 
                                                INTR_ENABLE_DMA  |
                                                INTR_ENABLE_ERROR );
                if (GLINT_DELTA_PRESENT)
                {
                    READ_GLINT_CTRL_REG (DeltaIntEnable, enableFlags);
                    WRITE_GLINT_CTRL_REG(DeltaIntEnable, enableFlags      | 
                                                         INTR_ENABLE_DMA  |
                                                         INTR_ENABLE_ERROR );
                }
            }
        }
        else
        {
            // nothing doing
            DISPDBG((ERRLVL, "Context pEntry is unexpectedly NULL! (1)"));        
        }
    }

    DISPDBG((DBGLVL, "vGlintSwitchContext: context %d now current", ctxtId));
    ppdev->currentCtxt = ctxtId;
    
} // vGlintSwitchContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\glint.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: glint.h
*
* Content: Defines and macros for interfacing to the GLINT hardware.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifndef _GLINT_H_
#define _GLINT_H_

#include <gtag.h>
//#include "glintmsg.h"
#include <glintdef.h>

// USE_SYNC_FUNCTION must be set at the moment for error free builds. The macro
// version requires #including <pxrx.h> which would make re-builds a nightmare.
// On more important issues, there is nomeasurable loss of speed but the driver
// is a fair bit smaller.
#define USE_SYNC_FUNCTION   1

// when enabled, most of the DDI entrypoints in THUNK.C check whether the base viewable scanline 
// variables in DEBUG4.C have been modified, allowing the scanline view to be updated
#define SET_VIEW_MEMORY_ENABLED 0

#if DBG && SET_VIEW_MEMORY_ENABLED
extern void DebugCheckMemoryView(PPDEV ppdev);
#define CHECK_MEMORY_VIEW(ppdev)
#else
#define CHECK_MEMORY_VIEW(ppdev)
#endif

#define COLLECT_TEXT_STATS 0
#if COLLECT_TEXT_STATS
struct TextStats
{
    ULONG aGlyphWidthBytesCached[9]; // [0] = 1 byte, [1] = 2 bytes, ... [7] = 8 bytes, [8] > 8 bytes
    ULONG cCacheableStrings;
    ULONG cUncacheableStrings;
    ULONG cGlyphsCached;

    ULONG cGlyphTotalBytesCached;
    ULONG meanGlyphBytesCached;
    ULONG cProportionalGlyphs;
    ULONG cProportionalStrings;
    
    ULONG meanProportionalGlyphsPerString;
    ULONG cFixedGlyphs;
    ULONG cFixedStrings;
    ULONG meanFixedGlyphsPerString;

    ULONG cClippedGlyphs;
    ULONG cClippedStrings;
    ULONG meanClippedGlyphsPerString;
    ULONG cAllocedFonts;

    ULONG cFreedFonts;
    ULONG cBlownCaches;
};

extern struct TextStats gts;

#define STAT_CACHEABLE_STRING  ++gts.cCacheableStrings
#define STAT_UNCACHEABLE_STRING ++gts.cUncacheableStrings
#define STAT_CACHING_GLYPH(cxGlyphAligned, cyGlyph) \
    do \
    { \
        ++gts.cGlyphsCached; \
        gts.cGlyphTotalBytesCached += (cxGlyphAligned >> 3) * cyGlyph; \
        gts.meanGlyphBytesCached = gts.cGlyphTotalBytesCached / gts.cGlyphsCached; \
        ++gts.aGlyphWidthBytesCached[(cxGlyphAligned >> 3) > 8 ? 8 : (cxGlyphAligned >> 3) - 1]; \
    } \
    while(0) 
#define STAT_PROPORTIONAL_TEXT(cGlyph) \
    do \
    { \
        gts.cProportionalGlyphs += cGlyph; \
        ++gts.cProportionalStrings; \
        gts.meanProportionalGlyphsPerString = gts.cProportionalGlyphs / gts.cProportionalStrings; \
    } \
    while(0)

#define STAT_FIXED_TEXT(cGlyph)    \
    do \
    { \
        gts.cFixedGlyphs += cGlyph; \
        ++gts.cFixedStrings; \
        gts.meanFixedGlyphsPerString = gts.cFixedGlyphs / gts.cFixedStrings; \
    } \
    while(0)
#define STAT_CLIPPED_TEXT(cGlyph) \
    do \
    { \
        gts.cClippedGlyphs += cGlyph; \
        ++gts.cClippedStrings; \
        gts.meanClippedGlyphsPerString = gts.cClippedGlyphs / gts.cClippedStrings; \
    } \
    while(0)
#define STAT_ALLOC_FONT ++gts.cAllocedFonts
#define STAT_FREE_FONT ++gts.cFreedFonts
#define STAT_BLOW_CACHE ++gts.cBlownCaches
#else
#define STAT_CACHEABLE_STRING
#define STAT_UNCACHEABLE_STRING
#define STAT_CACHING_GLYPH(cxGlyphAligned, cyGlyph)
#define STAT_PROPORTIONAL_TEXT(cGlyph)
#define STAT_FIXED_TEXT(cGlyph)
#define STAT_CLIPPED_TEXT(cGlyph)
#define STAT_ALLOC_FONT
#define STAT_FREE_FONT
#define STAT_BLOW_CACHE
#endif

#define DMA_DRIVEN_2D   0

#define GLINT_LOCKUP_TIMEOUT    0
#define GAMMA_CORRECTION        1
#define COLORIFIC_GAMMA_CORRECTION   1              

/*
 *  USE_PCI_DISC_PERM
 *    -----------------
 *
 *  Set USE_PCI_DISC_PERM to 1 for PCI disconnect on permanently or set to 0 for
 *  disconnect off permanently. ( Set to 1 to try and speed things up , set to 0
 *  on Alphas which are sensitive ).
 */
#if defined(_X86_)
    #define USE_PCI_DISC_PERM       1 
#else   // _X86_
    #define USE_PCI_DISC_PERM       0       
#endif  // _X86_

// DMA text rendering gives me a 1 winmark improvement on my P6 200 at 8 & 15bpp, but gives
// no improvement at these depths on a Pentium II 300 and might actually be 1 winmark slower
// at 32bpp
#define ENABLE_DMA_TEXT_RENDERING 0

/********************************************************************************/
// Texture memory allocation macros and structures are in 3DPrivTx.h

// definition of handle to a memory region
typedef  LONG HMEMREGION;
typedef  LONG HMEMCACHE;
typedef enum {RESIDENCY_NOTLOADED, RESIDENCY_PERMANENT, RESIDENCY_TRANSIENT, RESIDENCY_HOST, RESIDENCY_PERMANENT2} MEM_MGR_RESIDENCY;

/********************************************************************************/

/*** DrvEscape commands ***/
#define GLINT_SET_SCANLINE   6000   // Temporary define for setting the displayed scanline (Permedia specific)
#define GLINT_GET_RAMDAC_LUT 6001   // Temporary define for getting the RAMDACs LUT
#define GLINT_SET_RAMDAC_LUT 6002   // Temporary define for getting the RAMDACs LUT
#define GLINT_SET_SAME_VIDEO_MODE 6003  // Temporary define for getting the RAMDACs LUT
// Monitor DDC support:
#define GLINT_QUERY_MONITOR_INFO    6004
#define GLINT_MULTIMON_CMD          6007

#define GLINT_GET_SOFT_ENGINE_INFO  6009

// Debug only escapes:
#define GLINT_DBG_GET_FRAMEBUFFER   6008
#define GLINT_DBG_TEST_PXRX_DMA     6010

/*** DrvDrawEscape commands ***/
#define GLINT_DBG_SEND_TAGS         10238
#define GLINT_DBG_SET_DEBUG         10239

//
// various GLINT devices and revisions
//
#define VENDOR_ID_3DLABS        0x3D3D
#define VENDOR_ID_TI            0x104C
#define GLINT_300SX_ID          0x0001
#define GLINT_500TX_ID          0x0002
#define GLINT_DELTA_ID          0x0003
#define PERMEDIA_ID             0x0004
#define PERMEDIA_P1_ID          0x3D04
#define GLINT_MX_ID             0x0006
#define PERMEDIA2_ID            0x0007          // 3Dlabs Permedia 2
#define PERMEDIA_P2_ID          0x3D07          // TI Permedia 2
#define GLINT_GAMMA_ID          0x0008
#define PERMEDIA_P2S_ID         0x0009          // 3Dlabs Permedia 2ST
#define PERMEDIA3_ID            0x000A
#define GLINT_R3_ID             0x000B
#define PERMEDIA4_ID            0x000C
#define GLINT_R4_ID             0x000D

#define DEVICE_FAMILY_ID(id)    ((id) & 0xff)

#define GLINT_DEVICE_SX         GLINT_300SX_ID
#define GLINT_DEVICE_TX         GLINT_500TX_ID
#define GLINT_DEVICE_MX         GLINT_MX_ID
#define GLINT_DEVICE_FX         PERMEDIA_ID
#define GLINT_DEVICE_P2         PERMEDIA2_ID
#define GLINT_DEVICE_P2S        PERMEDIA_P2S_ID
#define GLINT_DEVICE_P3         PERMEDIA3_ID
#define GLINT_DEVICE_P4         PERMEDIA4_ID
#define GLINT_DEVICE_R3         GLINT_R3_ID
#define GLINT_DEVICE_R4         GLINT_R4_ID

#define GLINT_300SX_REV_1       0x0000
#define GLINT_300SX_REV_2       0x0002
#define GLINT_500TX_REV_1       0x0001
#define GLINT_DELTA_REV_1       0x0001
#define GLINT_PERMEDIA_REV_1    0x0001

#define GLINT_REVISION_SX_1     GLINT_300SX_REV_1
#define GLINT_REVISION_SX_2     GLINT_300SX_REV_2

#define GLINT_REVISION_TX_1     GLINT_500TX_REV_1

#define GLINT_REVISION_1 GLINT_REVISION_SX_1
#define GLINT_REVISION_2 GLINT_REVISION_SX_2

//
// Supported board definitions. Must be the same as in the miniport
//
typedef enum _GLINT_BOARDS {
    GLINT_MONTSERRAT = 0,
    GLINT_RACER,
    DENSAN_300SX,
    ACCELR8_BOARD,
    ACCELPRO_BOARD,
    OMNICOMP_SX88,
    PERMEDIA_BOARD,
    PERMEDIA_NT_BOARD,
    PERMEDIA_LC_BOARD,
    DUALTX_MENTOR_BOARD,
    DUALTX_SYMMETRIC_BOARD,
    ELSA_GLORIA,
    PERMEDIA2_BOARD,
    OMNICOMP_3DEMONPRO,
    GEO_TWIN_BOARD,
    GLINT_RACER_PRO,
    ELSA_GLORIA_XL,
    PERMEDIA3_BOARD,
    MAX_GLINT_BOARD
} GLINT_BOARDS;


//
// Supported RAMDAC definitions. Must be the same as in the miniport
//

typedef enum _GLINT_RAMDACS {
    RGB525_RAMDAC = 0,
    RGB526_RAMDAC,
    RGB526DB_RAMDAC,
    RGB528_RAMDAC,
    RGB528A_RAMDAC,
    RGB624_RAMDAC,
    RGB624DB_RAMDAC,
    RGB640_RAMDAC,
    TVP3026_RAMDAC,
    TVP3030_RAMDAC,
    RGB524_RAMDAC,
    RGB524A_RAMDAC,
    TVP4020_RAMDAC,
    P2RD_RAMDAC,
    P3RD_RAMDAC,
    MAX_GLINT_RAMDAC
} GLINT_RAMDACS;

// extern declarations
extern DWORD    GlintLogicOpsFromR2[];  // translates GDI rop2 to GLINT logic op mode word
extern DWORD    LogicopReadDest[];      // indicates which logic ops need dest read turned on


// values for flags in GlintDataRec
//
typedef enum {
    GLICAP_NT_CONFORMANT_LINES      = 0x00000001,        // draw NT conformant lines
    GLICAP_HW_WRITE_MASK            = 0x00000002,        // hardware planemasking
    GLICAP_COLOR_SPACE_DBL_BUF      = 0x00000004,        // interleaved nibbles
    GLICAP_BITBLT_DBL_BUF           = 0x00000008,        // dbl buf by bitblt
    GLICAP_FULL_SCREEN_DBL_BUF      = 0x00000010,        // hardware can dbl buf
    GLICAP_FIX_FAST_FILLS           = 0x00000020,        // workaround fast fill bug
    GLICAP_INTERRUPT_DMA            = 0x00000080,        // interrupt driven DMA
    GLICAP_RACER_BANK_SELECT        = 0x00000100,        // FS dbl buf uses Racer h/w
    GLICAP_FIX_4MB_FAST_FILLS       = 0x00000200,        // fix blk fill above 4MB
    GLICAP_RACER_DOUBLE_WRITE       = 0x00000400,        // Can double write
    GLICAP_ENHANCED_TX_BANK_SELECT  = 0x00000800,        // Enhanced TX FS dbl buf
    GLICAP_HW_WRITE_MASK_BYTES      = 0x00001000,        // hardware planemasking is bytewise only
    GLICAP_STEREO_BUFFERS           = 0x00002000,        // stereo buffers allocated
} GLINT_CAPS;

//@@BEGIN_DDKSPLIT
// TMM: In the good old days we used to leave the screen scissor enabled
// as a safety-net, however, the screen scissor doesn't work when uploading
// data at 1280 or 1170 screen widths, so I've disabled it.
//@@END_DDKSPLIT

#define SCREEN_SCISSOR_DEFAULT  (0 << 1)

// Currently we support the main display and up to 3 off-screen buffers.
//
#define GLINT_NUM_SCREEN_BUFFERS    4

// currently we support software cursors up to this width and height. This is
// to ensure that we have enough off-screen memory to save the shapes and save
// unders.
//
#define SOFTWARE_POINTER_SIZE   32

// this structure contains the addresses of all the GLINT registers that we
// want to write to. It is used by any macro/functions which needs to talk to
// the GLINT chip. We precompute these addresses so that we get faster access
// on DEC Alpha machines.
//
typedef struct _glint_reg_addrs {

    // Most commonly used non-FIFO registers

    ULONG *   InFIFOSpace;
    ULONG *   OutFIFOWords;
    ULONG *   OutFIFOWordsOdd;
    ULONG *   DMAControl;
    ULONG *   OutDMAAddress;            // P2 only
    ULONG *   OutDMACount;            // P2 only
    ULONG *   ByDMAAddress;            // P2 only
    ULONG *   ByDMAStride;            // P2 only
    ULONG *   ByDMAMemAddr;            // P2 only
    ULONG *   ByDMASize;                // P2 only
    ULONG *   ByDMAByteMask;            // P2 only
    ULONG *   ByDMAControl;            // P2 only
    ULONG *   ByDMAComplete;            // P2 only
    ULONG *   DMAAddress;
    ULONG *   DMACount;
    ULONG *   InFIFOInterface;
    ULONG *   OutFIFOInterface;
    ULONG *   OutFIFOInterfaceOdd;
    ULONG *   FBModeSel;
    ULONG *   FBModeSelOdd;
    ULONG *   IntFlags;
    ULONG *   DeltaIntFlags;

    // PERMEDIA
    ULONG *   ScreenBase;
    ULONG *   ScreenBaseRight;
    ULONG *   LineCount;
    ULONG *   VbEnd;
    ULONG * VideoControl;
    ULONG * MemControl;

    // GAMMA
    ULONG * GammaChipConfig;
    ULONG * GammaCommandMode;
    ULONG * GammaCommandIntEnable;
    ULONG * GammaCommandIntFlags;
    ULONG * GammaCommandErrorFlags;
    ULONG * GammaCommandStatus;
    ULONG * GammaFeedbackSelectCount;
    ULONG * GammaProcessorMode;
    ULONG * GammaMultiGLINTAperture;

    // Core FIFO registers

    ULONG *   tagwr[__MaximumGlintTagValue+1];  
    ULONG *   tagrd[__MaximumGlintTagValue+1];  

    // Other control registers

    ULONG *   VTGHLimit;
    ULONG *   VTGHSyncStart;
    ULONG *   VTGHSyncEnd;
    ULONG *   VTGHBlankEnd;
    ULONG *   VTGHGateStart;
    ULONG *   VTGHGateEnd;
    ULONG *   VTGVLimit;
    ULONG *   VTGVSyncStart;
    ULONG *   VTGVSyncEnd;
    ULONG *   VTGVBlankEnd;
    ULONG *   VTGVGateStart;
    ULONG *   VTGVGateEnd;
    ULONG *   VTGPolarity;
    ULONG *   VTGVLineNumber;
    ULONG *   VTGFrameRowAddr;
    ULONG *   VTGFrameRowAddrOdd;

    ULONG *   LBMemoryCtl;
    ULONG *   LBMemoryEDO;
    ULONG *   FBMemoryCtl;
    ULONG *   IntEnable;
    ULONG *   DeltaIntEnable;
    ULONG *   ResetStatus;
    ULONG *   DisconnectControl;
    ULONG *   ErrorFlags;
    ULONG *   DeltaErrorFlags;

    ULONG *   VTGSerialClk;
    ULONG *   VTGSerialClkOdd;
    ULONG *   VClkCtl;

    // Racer board has these extra registers external to GLINT
    ULONG *   RacerDoubleWrite;
    ULONG *   RacerBankSelect;

    ULONG *   VSConfiguration;    // P2 only

    // Omnicomp 3demonPro16 board has these extra registers external to GLINT
    ULONG *   DemonProDWAndStatus;     // Pro   5000
    ULONG *   DemonProUBufB;           // Pro   7000

    // split framebuffer needs scanline ownership, FBWindowBase and LBWindowBase
    // to be context switched.
    ULONG *   OddGlintScanlineOwnRd;
    ULONG *   OddGlintFBWindowBaseRd;
    ULONG *   OddGlintLBWindowBaseRd;

    // Dual-TX needs area stipple to be different on both chips
    ULONG *   OddTXAreaStippleRd[32];

    // PXRX
    ULONG *      TextureDownloadControl;
    ULONG *      AGPControl;

    ULONG   *LocalMemCaps;
    ULONG   *MemScratch;

    ULONG   *LocalMemProfileMask0;
    ULONG   *LocalMemProfileMask1;
    ULONG   *LocalMemProfileCount0;
    ULONG   *LocalMemProfileCount1;

    ULONG   *PXRXByAperture1Mode;            // 0300h
    ULONG   *PXRXByAperture1Stride;            // 0308h
//  ULONG   *PXRXByAperture1YStart;            // 0310h
//  ULONG   *PXRXByAperture1UStart;            // 0318h
//  ULONG   *PXRXByAperture1VStart;            // 0320h
    ULONG   *PXRXByAperture2Mode;            // 0328h
    ULONG   *PXRXByAperture2Stride;            // 0330h
//  ULONG   *PXRXByAperture2YStart;            // 0338h
//  ULONG   *PXRXByAperture2UStart;            // 0340h
//  ULONG   *PXRXByAperture2VStart;            // 0348h
    ULONG   *PXRXByDMAReadMode;                // 0350h
    ULONG   *PXRXByDMAReadStride;            // 0358h
//  ULONG   *PXRXByDMAReadYStart;            // 0360h
//  ULONG   *PXRXByDMAReadUStart;            // 0368h
//  ULONG   *PXRXByDMAReadVStart;            // 0370h
    ULONG   *PXRXByDMAReadCommandBase;        // 0378h
    ULONG   *PXRXByDMAReadCommandCount;        // 0380h
//  ULONG   *PXRXByDMAWriteMode;            // 0388h
//  ULONG   *PXRXByDMAWriteStride;            // 0390h
//  ULONG   *PXRXByDMAWriteYStart;            // 0398h
//  ULONG   *PXRXByDMAWriteUStart;            // 03A0h
//  ULONG   *PXRXByDMAWriteVStart;            // 03A8h
//  ULONG   *PXRXByDMAWriteCommandBase;        // 03B0h
//  ULONG   *PXRXByDMAWriteCommandCount;    // 03B8h

    // Used for P3 for debug purposes, to examine fifo stages.
    ULONG   *TestOutputRdy;
    ULONG   *TestInputRdy;

} GlintRegAddrRec;


typedef struct _glint_packing_str {
    DWORD   readMode;
    DWORD   modeSel;
    DWORD   dxOffset;
} GlintPackingRec;

// Framebuffer Aperture Information: currently only of interest to GeoTwin
// boards to allow for upload DMA directly from FB0 to FB1 and vice versa
typedef struct FrameBuffer_Aperture_Info
{
    LARGE_INTEGER   pphysBaseAddr;
    ULONG           cjLength;
}
FBAPI;

// PCI device information. Used in an IOCTL return. Ensure this is the same
// as in the miniport drivers glint.h
typedef struct _Glint_Device_Info {
    ULONG SubsystemId;
    ULONG SubsystemVendorId;
    ULONG VendorId;
    ULONG DeviceId;
    ULONG RevisionId;
    ULONG DeltaRevId;
    ULONG GammaRevId;
    ULONG BoardId;
    ULONG LocalbufferLength;
    LONG  LocalbufferWidth;
    ULONG ActualDacId;
    FBAPI FBAperture[2];            // Physical addresses for geo twin framebuffers
    PVOID FBApertureVirtual [2];    // Virtual addresses for geo twin framebuffers
    PVOID FBApertureMapped [2];        // Mapped physical/logical addresses for geo twin framebuffers
    PUCHAR pCNB20;
    LARGE_INTEGER pphysFrameBuffer; // physical address of the framebuffer (use FBAperture instead for geo twins)
}   Glint_Device_Info;

#define GLINT_DELTA_PRESENT     (glintInfo->deviceInfo.DeltaRevId != 0)
#define GLINT_GAMMA_PRESENT     (glintInfo->deviceInfo.GammaRevId != 0)

// before we get Gamma we won't be able to test all the fancy new features,
// after Gamma arrives we'll enable them one at a time; this define allows us
// to do just that
#define USE_MINIMAL_GAMMA_FEATURES 1

typedef struct _Glint_SwPointer_Info {
    LONG    xOff[5], yOff[5];            // offsets into screen of the caches.
    LONG    PixelOffset;                   // pixel offsets into screen of the caches.
    LONG    x, y;                        // x, y position
    LONG    xHot, yHot;                    // Hotspot position
    LONG    width, height;

    BOOL    onScreen;                    // True if pointer is on screen
    LONG    saveCache;                    // The current saveunder cache
    BOOL    duplicateSaveCache;            // Flag to indicate that save cache should be duplicated.
    ULONG   writeMask;                    // The write mask to use when saving and restoring.
    DWORD   *pDMA;                        // Pointer to a DMA buffer
    ULONG   windowBase;                    // Window base

    DSURF*  pdsurf;                        // Surface descriptors for caches                
    HSURF   hsurf;


    // Cached position of the pointer on the screen
    ULONG   scrXDom, scrXSub, scrY, scrCnt;

    // Cached position of the save under cache
    LONG    cacheXDom[5], cacheXSub[5], cacheY[5], cacheCnt[5];

    // Cached position of the visible pars of the save caches
    LONG    scrToCacheXDom[2], scrToCacheXSub[2], scrToCacheY[2], scrToCacheCnt[2];

    // Cached offsets from the various caches.
    LONG    saveOffset[2], constructOffset, maskOffset, shapeOffset;
} Glint_SwPointer_Info;

// Definition of the IOCTL_VIDEO_QUERY_DMA_BUFFER

#define MAX_LINE_SIZE 8192          // No of bytes required to hold 1 complete scanline (i.e., 
                                    // 6400 for 1600x1200x32).
#define DMA_LINEBUF_SIZE (MAX_LINE_SIZE * 2)    // Size in bytes of 'pvTmpBuffer'. 
                                    // This has to be big enough to store 2 entire
                                    // scan lines. I have increased the size from 1 line
                                    // to 2 lines so that P2 can double buffer
                                    // it's line uploads.

typedef struct GENERAL_DMA_BUFFER {
    LARGE_INTEGER       physAddr;        // physical address of DMA buffer
    PVOID               virtAddr;        // mapped virtual address
    ULONG               size;            // size in bytes
    BOOL                cacheEnabled;    // Whether buffer is cached
} GENERAL_DMA_BUFFER, *PGENERAL_DMA_BUFFER;

/*** NB: The PXRXdmaInfo structure is shared with the Miniport ***/
typedef struct PXRXdmaInfo_Tag {
    ULONG           scheme;        // Used by the interrupt handler only

    volatile ULONG  hostInId;    // Current internal HostIn id, used by the HIid DMA scheme
    volatile ULONG  fifoCount;    // Current internal FIFO count, used by various DMA schemes

    ULONG           NTbuff;        // Current buffer number (0 or 1)
    ULONG           *NTptr;        // 32/64 bit ptr Last address written to by NT (but not necesserily the end of a completed buffer)
    ULONG           *NTdone;    // 32/64 bit ptr    Last address NT has finished with (end of a buffer, but not necessarily sent to P3 yet)
    volatile ULONG  *P3at;        // 32/64 bit ptr  Last address sent to the P3

    volatile BOOL   bFlushRequired;        // Is a flush required to empty the FBwrite unit's cache?

    ULONG           *DMAaddrL[2];        // 32/64 bit ptr       Linear address of the start of each DMA buffer
    ULONG           *DMAaddrEndL[2];    // 32/64 bit ptr        Linear address of the end of each DMA buffer
    ULONG           DMAaddrP[2];        // 32 bit ptr           Physical address of the start of each DMA buffer
    ULONG           DMAaddrEndP[2];        // 32 bit ptr            Physical address of the end of each DMA buffer
} PXRXdmaInfo;
/*** NB: The PXRXdmaInfo structure is shared with the Miniport ***/

typedef struct _glint_data {
    DWORD           renderBits;            // saved render bits set by setup routines
    DWORD           FBReadMode;            // software copy of FBReadMode register
    DWORD           FBWriteMode;        // software copy of FBWriteMode register
    DWORD           RasterizerMode;        // software copy of the rasterizer mode
    DWORD           FBPacking;            // software copy of FBModeSel
    DWORD           FBBlockColor;        // software copy of FBBlockColor (P1 only)
    DWORD           TextureAddressMode; // software copy of TextureAddressMode (P2 only)
    DWORD           TextureReadMode;    // software copy of TextureReadMode (P2 & MX only)
    DWORD           dSdx;                // software copy of dSdx (MX only)
    DWORD           dTdyDom;            // software copy of dTdyDom (MX only)
    BOOL            bGlintCoreBusy;        // 2D flag: TRUE if core not synced
    LONG            currentPelSize; // Currently loaded frame store depth
    ULONG           currentCSbuffer;// color space buffer being displayed
    GLINT_CAPS      flags;          // various flags
    GlintRegAddrRec regs;           // precomputed register addresses
    GlintPackingRec packing[5];     // values to load for 4 packing formats (plus one unused)
    LONG            ddCtxtId;       // id of the display drivers context
    LONG            fastFillBlockSz;// number of pixels per fast fill block
    DWORD           fastFillSupport;// render bits for rev 1 fast fill
    DWORD           renderFastFill; // render bits for rev 2+ fast fill
    LONG            PixelOffset;    // last DFB pixel offset
    ULONG           MaxInFifoEntries;// maximum reported free entries FIFO download
    ULONG           CheckFIFO;        // Non-zero if the FIFO has to be checked before loading it
    ULONG           PCIDiscEnabled;    // Non-zero if PCI disconnect is enabled
    ULONG           BroadcastMask2D;// Primary chip broadcast mask
    ULONG           BroadcastMask3D;// broadcast mask to use for 3D contexts
    LONG            vtgvLimit;      // copy of VTGVLimit register
    LONG            scanFudge;      // how much to add onto VTGVLineNumber to
                                    //  get the current video scanline

    OH *            backBufferPoh;    // heap handle for allocated back-buffer
    OH *            savedPoh;        // handle to saved off-screen heap
    ULONG           GMX2KLastLine;    // Last+1 line to be allocated
    BOOLEAN         offscreenEnabledOK;        // Set to TRUE if off-screen enabled

    ULONG           bufferOffset[GLINT_NUM_SCREEN_BUFFERS];
                                    // offset in pixels to the supported bufs
    ULONG           bufferRow[GLINT_NUM_SCREEN_BUFFERS];
                                    // VTGFrameRowAddr for supported buffers
    ULONG           PerfScaleShift;

    //ContextDumpData   GammaContextMask;
    ULONG           HostOutBroadcastMask; // for Gamma output DMA
    ULONG           HostOutChipNumber;      // for Gamma output DMA

#if GAMMA_CORRECTION
    union {
        UCHAR       _clutBuffer[MAX_CLUT_SIZE];
        VIDEO_CLUT  gammaLUT;       // saved gamma LUT contents
    };
#endif

    // interrupt command block.
    struct _glint_interrupt_control *pInterruptCommandBlock;

    // maximum number of sub buffers per DMA buffer.
    ULONG MaxDMASubBuffers;

    // Overlay support: WriteMask can be set around primitives so that
    // they temporarily render thru this mask. Normally it must be set to -1.
    // DefaultWriteMask is the write mask that should be used by the DD
    // context by default, it takes into account overlay planes.
    //
    ULONG OverlayMode;
    ULONG WriteMask;
    ULONG TransparentColor; // pre-shifted so color is in top 8 bits
    ULONG DefaultWriteMask;
    
    // Indicates whether GDI is allowed to access the frame buffer. Always true 
    // on MIPS and ALPHA and true on all architectures in overlay mode.
    ULONG GdiCantAccessFramebuffer;
    ULONG OGLOverlaySavedGCAF;

    // Configuration for texture and Z buffers

    ULONG ZBufferWidth;             // bits per pel
    ULONG ZBufferOffset;            // offset in pels
    ULONG ZBufferSize;              // size in pels
    ULONG FontMemoryOffset;            // offset in dwords
    ULONG FontMemorySize;            // size in dwords
    ULONG TextureMemoryOffset;      // offset in dwords
    ULONG TextureMemorySize;        // size in dwords

    // On P3 due to patching restrictions the Z width
    // may not match the framebuffer screen width.
    ULONG P3RXLocalBufferWidth;

    // PCI configuration id information
    Glint_Device_Info deviceInfo;

    // Software cursor information
    Glint_SwPointer_Info swPointer;

    // Line DMA buffer information
    GENERAL_DMA_BUFFER  LineDMABuffer;
    GENERAL_DMA_BUFFER  PXRXDMABuffer;

    // Current input FIFO count from 0 to 1023
    ULONG   FifoCnt;

    // PXRX specific stuff:
    ULONG   foregroundColour;            // Software copies of various registers
    ULONG   backgroundColour;            // Ditto
    ULONG   config2D;                    // Ditto
    ULONG   fbDestMode;                    // Ditto
    ULONG   fbDestAddr[4];                // Ditto
    ULONG   fbDestOffset[4];            // Ditto
    ULONG   fbDestWidth[4];                // Ditto
    ULONG   fbWriteMode;                // Ditto
    ULONG   fbWriteAddr[4];                // Ditto
    ULONG   fbWriteWidth[4];            // ottiD
    ULONG   fbWriteOffset[4];            // Ditto
    ULONG   fbSourceAddr;                // Ditto
    ULONG   fbSourceWidth;                // ottiD
    ULONG   fbSourceOffset;                // Ditto
    ULONG   lutMode;                    // Ditto
    ULONG   pxrxByDMAReadMode;            // Ditto
    ULONG   lastLine;                    // Delta LineCoord0/1
    ULONG   savedConfig2D;                // Config2D value that we use for integer lines
    ULONG   savedLOP;                    // LogicOp value that we use for lines
    ULONG   savedCol;                    // Colour value that we use for lines
    RECTL * savedClip;                    // Clip rectangle that we use for lines
    ULONG   pxrxFlags;                    // General flags, see below
    ULONG   backBufferXY;                // Offset to add to front buffer to get to the back buffer (for FBWriteBufferOffsetX)
    ULONG   frontRightBufferXY;            // Offset to the stereo front buffer
    ULONG   backRightBufferXY;            // Offset to the stereo back buffer
    ULONG   fbWriteModeDualWrite;        // FBWriteMode for single writes
    ULONG   fbWriteModeSingleWrite;        // FBWriteMode for dual writes
    ULONG   fbWriteModeDualWriteStereo;    // FBWriteMode for stereo mode single writes
    ULONG   fbWriteModeSingleWriteStereo;// FBWriteMode for stereo mode dual writes
    ULONG   render2Dpatching;            // Value to stuff into Render2D to set the required patch mode

    ULONG       usePXRXdma;
    PXRXdmaInfo *pxrxDMA;
    PXRXdmaInfo pxrxDMAnonInterrupt;
//#if PXRX_DMA_BUFFER_CHECK
    // These should be '#if PXRX_DMA_BUFFER_CHECK' really but the
    // hassle with include dependancies and such like means it ain't
    // worth it.
    ULONG   *pxrxDMA_bufferBase;        // Start of the allocated DMA buffer (inc. guard bands)
    ULONG   *pxrxDMA_bufferTop;            // End of the allocated DMA buffer (inc. guard bands)
    ULONG   *NTwait;                    // Last address up to which NT did a wait for space
//#endif
} GlintDataRec, *GlintDataPtr;

#define PXRX_FLAGS_DUAL_WRITE           (1 << 0)        /* Are we in dual write mode                    */
#define PXRX_FLAGS_DUAL_WRITING         (1 << 1)        /* Are dual writes currently active             */
#define PXRX_FLAGS_PATCHING_FRONT       (1 << 2)        /* Is the front buffer running patched          */
#define PXRX_FLAGS_PATCHING_BACK        (1 << 3)        /* Is the back buffer running patched           */
#define PXRX_FLAGS_READ_BACK_BUFFER     (1 << 4)        /* Do we want to read from the back buffer      */
#define PXRX_FLAGS_STEREO_WRITE         (1 << 5)        /* Are we in OpenGL stereo mode                 */
#define PXRX_FLAGS_STEREO_WRITING       (1 << 6)        /* Are stereo writes currently active           */

#if defined(_PPC_)
// on PPC need this even if not using PERFMON
ULONG GetCycleCount(VOID);
#endif

// bit definitions for the status words in ppdev->g_GlintBoardStatus[]:
// Currently used to indicate sync and DMA status. We have the following rules:
// synced means no outstanding DMA as well as synced. DMA_COMPLETE means n
// outstanding DMA but not necessarily synced. Thus when we do a wait on DMA
// complete we turn off the synced bit.
// XXX for the moment we don't use the synced bit as it's awkward to see where
// to unset it - doing so for every access to the chip is too expensive. We
// probably need a "I'm about to start downloading to the FIFO" macro which
// gets put at the start of any routine which writes to the FIFO.
//
#define GLINT_SYNCED                0x01
#define GLINT_DMA_COMPLETE          0x02     // set when there is no outstanding DMA
#define GLINT_INTR_COMPLETE         0x04
#define GLINT_INTR_CONTEXT          0x08     // set if the current context is interrupt enabled
#define GLINT_DUAL_CONTEXT          0x10     // set if the current context uses both TXs

// these macros were taken out on NT 4 so define them

#define READ_FAST_ULONG(a)      READ_REGISTER_ULONG((PULONG)(a))
#define WRITE_FAST_ULONG(a, d)  WRITE_REGISTER_ULONG((PULONG)(a), (d))
#define TRANSLATE_ADDR(a) ((ULONG *)a)
//azn #define INVALID_HANDLE_VALUE    NULL
#define DebugBreak              EngDebugBreak
typedef PVOID                   PGLINT_COUNTER_DATA;

// This will pause the processor whilst using as little
// system bandwidth (either memory or DMA) as possible
#if defined(_X86_)
#   define BUSY_WAIT(c)                            \
    do {                                        \
        __asm nop                               \
    } while( c-- >= 0 )
#else
#   define BUSY_WAIT(c)                            \
    do {                                        \
        _temp_volatile_i = c;                    \
        do {                                    \
            ;                                    \
        } while( _temp_volatile_i-- >= 0 );        \
    } while(0)
#endif

// If we have a sparsely mapped framebuffer then we use the xx_REGISTER_ULONG()
// macros, otherwise we just access the framebuffer.
#define READ_SCREEN_ULONG(a)    ((ppdev->flCaps & CAPS_SPARSE_SPACE) ? (READ_REGISTER_ULONG(a)) : *((volatile PULONG)(a)))
#define WRITE_SCREEN_ULONG(a,d)           \
{                                         \
    if(ppdev->flCaps & CAPS_SPARSE_SPACE) \
    {                                     \
         WRITE_REGISTER_ULONG((a),d);     \
    }                                     \
    else                                  \
    {                                     \
        *(volatile PULONG)(a) = d;        \
    }                                     \
}

// generic macros to access GLINT FIFO and non-FIFO control registers.
// We do nothing sophisticated for the Alpha (yet). We just MEMORY_BARRIER
// everything.
//
#define READ_GLINT_CTRL_REG(r, d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs. r))
            
#define WRITE_GLINT_CTRL_REG(r, v) \
{ \
    MEMORY_BARRIER(); \
    WRITE_FAST_ULONG(glintInfo->regs. r, (ULONG)(v)); \
    DISPDBG((150, "WRITE_GLINT_CTRL_REG(%-20s:0x%08X) <-- 0x%08X", #r, glintInfo->regs.r, v)); \
    MEMORY_BARRIER(); \
}

#define READ_GLINT_FIFO_REG_CHIP(r, d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.tagrd[r]))

#define READ_GLINT_FIFO_REG(r, d) READ_GLINT_FIFO_REG_CHIP(r, d)
   
#define WRITE_GLINT_FIFO_REG(r, v) \
{ \
    MEMORY_BARRIER(); \
    WRITE_FAST_ULONG(glintInfo->regs.tagwr[r], (ULONG)(v)); \
    MEMORY_BARRIER(); \
}

#define READ_ODD_TX_AREA_STIPPLE(r, d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.OddTXAreaStippleRd[r]))
            
#define READ_ODD_GLINT_SCANLINE_OWNERSHIP(d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.OddGlintScanlineOwnRd))

#define READ_ODD_GLINT_FBWINDOWBASE(d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.OddGlintFBWindowBaseRd))

#define READ_ODD_GLINT_LBWINDOWBASE(d) \
    ((d) = READ_FAST_ULONG(glintInfo->regs.OddGlintLBWindowBaseRd))

//
// macros to access the output FIFO
//
#define READ_OUTPUT_FIFO(d) \
            READ_GLINT_CTRL_REG(OutFIFOInterface, d)
#define READ_OUTPUT_FIFO_ODD(d) \
            READ_GLINT_CTRL_REG(OutFIFOInterfaceOdd, d)

#define OUTPUT_FIFO_COUNT(n) \
            READ_GLINT_CTRL_REG(OutFIFOWords, n)
#define OUTPUT_FIFO_COUNT_ODD(n) \
            READ_GLINT_CTRL_REG(OutFIFOWordsOdd, n)
#define WAIT_OUTPUT_FIFO_COUNT(n) \
{ \
    int i; \
    do \
    { \
       OUTPUT_FIFO_COUNT(i); \
    } \
    while(i < (int)n); \
}

#define DUAL_GLINT_WAIT_OUTPUT_FIFO_NOT_EMPTY(nGlint, cWordsOutFifo) \
{ \
    if(nGlint) \
    { \
        WAIT_OUTPUT_FIFO_NOT_EMPTY_ODD(cWordsOutFifo); \
    } \
    else \
    { \
        WAIT_OUTPUT_FIFO_NOT_EMPTY(cWordsOutFifo); \
    } \
}

#define DUAL_GLINT_READ_OUTPUT_FIFO(nGlint, ul) \
{ \
    if(nGlint) \
    { \
        READ_OUTPUT_FIFO_ODD(ul); \
    } \
    else \
    { \
        READ_OUTPUT_FIFO(ul); \
    } \
}

#define DUAL_GLINT_OUTPUT_FIFO_COUNT(nGlint, ul) \
{ \
    if(nGlint) \
    { \
        OUTPUT_FIFO_COUNT_ODD(ul); \
    } \
    else \
    { \
        OUTPUT_FIFO_COUNT(ul); \
    } \
}

//
// macros to access specific GLINT control registers
//

// We decrease the value of InFIFOSpace by 1 because of a bug in Gamma chip
#define GET_INPUT_FIFO_SPACE(n) ( READ_GLINT_CTRL_REG(InFIFOSpace, n) > 120 ? (n=120) : (n>0? n=n-1:n) )


#define GET_DMA_COUNT(c)        READ_GLINT_CTRL_REG(DMACount, c)
#define GET_OUTDMA_COUNT(c)     READ_GLINT_CTRL_REG(OutDMACount, c)

#define SET_DMA_ADDRESS(aPhys, aVirt) { \
    WRITE_GLINT_CTRL_REG(DMAAddress, aPhys); \
}
#define SET_DMA_COUNT(c) { \
    WRITE_GLINT_CTRL_REG(DMACount, c); \
}
#define SET_OUTDMA_ADDRESS(aPhys, aVirt) { \
    WAIT_GLINT_FIFO(2); \
    LD_GLINT_FIFO(GammaTagDMAOutputAddress, aPhys);

#define SET_OUTDMA_COUNT(c) { \
    LD_GLINT_FIFO(GammaTagDMAOutputCount, c);

// Macros to perform logical DMA on a Gamma
//
#define START_QUEUED_DMA(P, C) { \
    WAIT_GLINT_FIFO(2); \
    LD_GLINT_FIFO(GammaTagDMAAddr, P); \
    LD_GLINT_FIFO(GammaTagDMACount, C); \
}

#define WAIT_QUEUED_DMA_COMPLETE { \
    READ_GLINT_CTRL_REG(GammaCommandIntFlags, _temp_volatile_ul); \
    READ_GLINT_CTRL_REG(GammaCommandStatus, _temp_volatile_ul); \
    if (_temp_volatile_ul & GAMMA_STATUS_COMMAND_DMA_BUSY) { \
    do { \
            for (_temp_volatile_ul = 10; _temp_volatile_ul > 0; --_temp_volatile_ul); \
            READ_GLINT_CTRL_REG(GammaCommandStatus, _temp_volatile_ul); \
        } while (_temp_volatile_ul & GAMMA_STATUS_COMMAND_DMA_BUSY); \
    } \
}

#define VERT_RETRACE_FLAG       (0x10)
#define P2_BYPASS_FLAG          (1 << 7)
#define P2_BUFSWAPCTL_FLAG      (3 << 9)
#define RESET_VERT_RETRACE      WRITE_GLINT_CTRL_REG(IntFlags, VERT_RETRACE_FLAG) 

#define LD_GLINT_FIFO_DBG(tag, d) \
{ \
    DISPDBG((100, "tag 0x%03x <-- 0x%08x [%s]", tag, d, GET_TAG_STR(tag))); \
                                        \
    WRITE_GLINT_FIFO_REG(tag, d); \
    READ_GLINT_CTRL_REG(ErrorFlags, _temp_ul); \
    if (GLINT_DELTA_PRESENT) { \
        READ_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul2); \
        _temp_ul |= _temp_ul2; \
    } \
    _temp_ul &= ~0x2; /* we're not interested in output fifo errors */ \
    _temp_ul &= ~0x10; /* ingore any Video FIFO underrun errors on P2 */ \
    _temp_ul &= ~0x2000; /* ingore any HostIn DMA errors on P3 */ \
    if (_temp_ul != 0) { \
        DISPDBG((-1000, "LD_GLINT_FIFO(%s, 0x%X) error 0x%X", GET_TAG_STR(tag), d, _temp_ul)); \
        /*if( _temp_ul & ~0x2000 ) /* ignore, but report, HostIn DMA errors */ \
            /*DebugBreak();*/ \
        WRITE_GLINT_CTRL_REG(ErrorFlags, _temp_ul); \
        if (GLINT_DELTA_PRESENT) \
            WRITE_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul); \
    } \
}


#define LD_GLINT_FIFO_FREE(tag, d)   WRITE_GLINT_FIFO_REG(tag, d)

#if DBG
#define LD_GLINT_FIFO(tag, d) LD_GLINT_FIFO_DBG(tag,d)
#else //DBG
#define LD_GLINT_FIFO(tag, d) LD_GLINT_FIFO_FREE(tag,d)
#endif //DBG

#define LD_FIFO_INTERFACE_DBG(d) \
{ \
    WRITE_GLINT_CTRL_REG(InFIFOInterface, d); \
    READ_GLINT_CTRL_REG(ErrorFlags, _temp_ul); \
    if (GLINT_DELTA_PRESENT) { \
        READ_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul2); \
        _temp_ul |= _temp_ul2; \
    } \
    _temp_ul &= ~0x2; /* we're not interested in output fifo errors */ \
    _temp_ul &= ~0x10; /* ingore any Video FIFO underrun errors on P2 */ \
    if (_temp_ul != 0) { \
        DISPDBG((-1000, "LD_FIFO_INTERFACE(0x%x) error 0x%x", d, _temp_ul)); \
        DebugBreak(); \
        WRITE_GLINT_CTRL_REG(ErrorFlags, _temp_ul); \
        if (GLINT_DELTA_PRESENT) \
            WRITE_GLINT_CTRL_REG(DeltaErrorFlags, _temp_ul); \
    } \
}

#define LD_FIFO_INTERFACE_FREE(d)    WRITE_GLINT_CTRL_REG(InFIFOInterface, d)

#if DBG
#define LD_FIFO_INTERFACE(d) LD_FIFO_INTERFACE_DBG(d)
#else //DBG
#define LD_FIFO_INTERFACE(d) LD_FIFO_INTERFACE_FREE(d)
#endif //DBG

// local variables for all functions that access GLINT. Generally we use GLINT_DECL. Sometimes we have to split it 
// up if ppdev isn't passed into the routine.
// NB. Temporary variables:-
//    These are necessary because VC5 doesn't account for the scope of variables within macros, i.e. each 
//    time a macro with (a variable declaration within it's statement block) is used, the stack of the function
//    referencing the macro grows
#define TEMP_MACRO_VARS                 \
    ULONG           _temp_ul;           \
    ULONG           _temp_ul2;          \
    LONG            _temp_i;            \
    volatile int    _temp_volatile_i;   \
    volatile ULONG  _temp_volatile_ul;  \
    volatile PULONG _temp_volatile_pul

#define GLINT_DECL_VARS                 \
    TEMP_MACRO_VARS;                    \
    GlintDataPtr glintInfo

#define GLINT_DECL_INIT \
    glintInfo = (GlintDataPtr)(ppdev->glintInfo)

#define GLINT_DECL \
    GLINT_DECL_VARS; \
    GLINT_DECL_INIT

//@@BEGIN_DDKSPLIT
// Macro that determines whether the chipset supports RAMDAC overlays
//#define RAMDAC_OVERLAYS_AVAILABLE (ppdev->pgfnRamdacSetOverlayMode != NULL)
//@@END_DDKSPLIT

#if(_X86_)
#define SYNCHRONOUS_WRITE_ULONG(var, value) \
{ \
    ULONG *pul = (ULONG *)&var;                \
    ULONG ul = (ULONG)value;                \
    __asm push  ecx                         \
    __asm mov   ecx, ul                     \
    __asm mov   edx, pul                    \
    __asm xchg  ecx, [edx]                    \
    __asm pop   ecx                         \
}
#define SYNCHRONOUS_WRITE_INDIRECT_ULONG(pvar, value) \
{ \
    ULONG *pul = (ULONG *)pvar;                \
    ULONG ul = (ULONG)value;                \
    __asm push  ecx                         \
    __asm mov   ecx, ul                     \
    __asm mov   edx, pul                    \
    __asm xchg  ecx, [edx]                    \
    __asm pop   ecx                         \
}
#else
// to be defined properly
#define SYNCHRONOUS_WRITE_ULONG(memory, value) {(*(PULONG) &memory) = value;}
#endif

#define GET_INTR_CMD_BLOCK_MUTEX(pBlock)\
do { \
    if(glintInfo->pInterruptCommandBlock) \
    { \
        DISPDBG((20, "display driver waiting for interrupt command block mutex")); \
        ASSERTDD(!(pBlock)->bDisplayDriverHasAccess, "Aquiring mutex when it is already aquired!");    \
        SYNCHRONOUS_WRITE_ULONG((pBlock)->bDisplayDriverHasAccess, TRUE); \
        while((pBlock)->bMiniportHasAccess); \
    } \
} while(0)

#define RELEASE_INTR_CMD_BLOCK_MUTEX(pBlock) \
do { \
    if(glintInfo->pInterruptCommandBlock) \
    { \
        DISPDBG((20, "display driver releasing interrupt command block mutex")); \
        SYNCHRONOUS_WRITE_ULONG((pBlock)->bDisplayDriverHasAccess, FALSE); \
    } \
} while(0)

//
// FIFO functions
//

#define MAX_GLINT_FIFO_ENTRIES      16
#define MAX_PERMEDIA_FIFO_ENTRIES   32
#define MAX_P2_FIFO_ENTRIES         258
#define MAX_GAMMA_FIFO_ENTRIES      32
#define MAX_P3_FIFO_ENTRIES         120

#if DBG
// wait for n entries to become free in the input FIFO
#define WAIT_GLINT_FIFO(n) \
{ \
    if (glintInfo->CheckFIFO)    \
    {    \
        GET_DMA_COUNT(_temp_volatile_ul); \
        if (_temp_volatile_ul != 0) { \
            DISPDBG((-999, "WAIT_GLINT_FIFO: DMACount = %d, glintInfo = 0x%x", _temp_volatile_ul, glintInfo)); \
            ASSERTDD(_temp_volatile_ul == 0, "Break."); \
        } \
        while ((GET_INPUT_FIFO_SPACE(_temp_volatile_ul)) < (ULONG)(n)); \
    }    \
}

#else

// WAIT_GLINT_FIFO() - wait for n entries to become free in the input FIFO.
// If PCI disconnect is on permanently then this function is a no-op.

#define WAIT_GLINT_FIFO(n)            /* Do the wait */ \
{ \
    if (glintInfo->CheckFIFO)    \
    {    \
        while ((GET_INPUT_FIFO_SPACE(_temp_volatile_ul)) < (ULONG)(n)); \
    }    \
}

#endif

// WAIT_FIFO_NOT_FULL() waits for any entries to become free in
// the input FIFO and returns this number. If PCI disconnect is switched
// on then we simply return 16 free entries (an empty FIFO).


#define WAIT_FIFO_NOT_FULL(nFifo)                     /* Return FIFO state  */ \
{ \
    ASSERTDD(GET_DMA_COUNT(nFifo) == 0, "WAIT_FIFO_NOT_FULL: DMACount != 0"); \
    nFifo = glintInfo->MaxInFifoEntries;    \
    if (glintInfo->CheckFIFO)    \
    {    \
        while ((GET_INPUT_FIFO_SPACE(nFifo)) == 0); \
    }    \
}


// Wait for DMA to complete (DMACount becomes zero). So as not to kill the
// PCI bus bandwidth for the DMA put in a backoff based on the amount of data
// still left to DMA. Also set the timer going if at any time, the count we
// read is the same as the previous count.
// New for Gamma: if queued DMA is configured then wait till the CommandStatus
// indicates DMA is not busy and the FIFO empty. We do this test twice
// because there is a possibility that the input FIFO will become empty one
// clock before the DMA busy flag is set.
//
#define WAIT_DMA_COMPLETE \
{ \
    if (!(ppdev->g_GlintBoardStatus & GLINT_DMA_COMPLETE)) { \
        { \
            if (ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT) { \
                /* do any VBLANK wait, wait Q to empty and last DMA to complete */ \
                PINTERRUPT_CONTROL_BLOCK pBlock = glintInfo->pInterruptCommandBlock; \
                while (pBlock->Control & SUSPEND_DMA_TILL_VBLANK); \
                while (pBlock->frontIndex != pBlock->backIndex); \
            } \
            if ((GET_DMA_COUNT(_temp_volatile_i)) > 0) { \
                do { \
                    while (--_temp_volatile_i > 0); \
                } while ((GET_DMA_COUNT(_temp_volatile_i)) > 0); \
            } \
        } \
        ppdev->g_GlintBoardStatus |= GLINT_DMA_COMPLETE; \
    } \
    if (ppdev->currentCtxt == glintInfo->ddCtxtId)    \
        SEND_PXRX_DMA;    \
}


// Simple version which explicitly waits for the DMA to finish ignoring
// interrupt driven DMA and overriding the DMA_COMPLETE flag. This is used
// where code kicks off a DMA but wants to immediately wait for it to
// finish.
//
#define WAIT_IMMEDIATE_DMA_COMPLETE \
{ \
    if ((GET_DMA_COUNT(_temp_volatile_i)) > 0) { \
        do { \
            while (--_temp_volatile_i > 0); \
        } while ((GET_DMA_COUNT(_temp_volatile_i)) > 0); \
    } \
}


#define WAIT_OUTDMA_COMPLETE \
{ \
    if ((GET_OUTDMA_COUNT(_temp_volatile_i)) > 0) { \
        do { \
            while (--_temp_volatile_i > 0); \
        } while ((GET_OUTDMA_COUNT(_temp_volatile_i)) > 0); \
    } \
}

// IS_FIFO_EMPTY() XX

#define IS_FIFO_EMPTY(c) ((glintInfo->CheckFIFO) ? TRUE :    \
            (GET_INPUT_FIFO_SPACE(c) == glintInfo->MaxInFifoEntries))

// wait for the input FIFO to become empty
#define WAIT_INPUT_FIFO_EMPTY \
{ \
    WAIT_GLINT_FIFO(glintInfo->MaxInFifoEntries); \
}

#define WAIT_GLINT_FIFO_AND_DMA(n) \
{ \
    WAIT_DMA_COMPLETE; \
    WAIT_GLINT_FIFO(n); \
}

// wait till the ouput FIFO has some data to be read and return the count
#define WAIT_OUTPUT_FIFO_NOT_EMPTY(n) \
{ \
    do \
    { \
        OUTPUT_FIFO_COUNT(n); \
    } \
    while (n == 0); \
}
#define WAIT_OUTPUT_FIFO_NOT_EMPTY_ODD(n) \
{ \
    do \
    { \
        OUTPUT_FIFO_COUNT_ODD(n); \
    } \
    while (n == 0); \
}

// wait for any data to appear in the output FIFO
#define WAIT_OUTPUT_FIFO_READY                \
{                                             \
    WAIT_OUTPUT_FIFO_NOT_EMPTY(_temp_ul);     \
}
#define WAIT_OUTPUT_FIFO_READY_ODD            \
{                                             \
    WAIT_OUTPUT_FIFO_NOT_EMPTY_ODD(_temp_ul); \
}

#define SYNC_WITH_GLINT         SYNC_WITH_GLINT_CHIP
#define CTXT_SYNC_WITH_GLINT    SYNC_WITH_GLINT

#define GLINT_CORE_BUSY glintInfo->bGlintCoreBusy = TRUE
#define GLINT_CORE_IDLE glintInfo->bGlintCoreBusy = FALSE
#define TEST_GLINT_CORE_BUSY (glintInfo->bGlintCoreBusy)

#define SYNC_IF_CORE_BUSY \
{ \
    if(glintInfo->bGlintCoreBusy) \
    { \
        SYNC_WITH_GLINT; \
    } \
}

//
// PCI Disconnect enable, disable and sync macros
//

// PCI_DISCONNECT_FASTSYNC()
// turn on disconnect for the input FIFO. We could do a SYNC here but it's quite
// expensive. Instead, add RasterizerMode(0) into the FIFO and when the register
// is set we know the FIFO is empty so turn on disconnect and reset RasterizerMode
// to a sensible value. PCI disconnect means we don't wait for FIFO space.
#define P2_BUSY (1 << 31)

#define PCI_DISCONNECT_FASTSYNC()    \
{    \
    WAIT_GLINT_FIFO(1);    \
    LD_GLINT_FIFO(__GlintTagRasterizerMode, 0);    \
    /* when we see RasterizerMode set to zero */    \
    /*we know we've flushed the FIFO and can enable disconnect */    \
    do {    \
        READ_GLINT_FIFO_REG(__GlintTagRasterizerMode, _temp_volatile_ul);    \
    } while(_temp_volatile_ul);    \
    LD_GLINT_FIFO(__GlintTagRasterizerMode, glintInfo->RasterizerMode);    \

// PCI_DISCONNECT_ENABLE()
// If disconnect is not already enabled then enable it and optionally do a fast
// sync.
#define PCI_DISCONNECT_ENABLE(prevDiscState,quickEnable)    \
{    \
    prevDiscState = glintInfo->PCIDiscEnabled;    \
    if (!glintInfo->PCIDiscEnabled)    \
    {    \
        DISPDBG((7, "PCI_DISCONNECT_ENABLE()"));    \
        if (!quickEnable)    \
        {    \
            PCI_DISCONNECT_FASTSYNC();    \
        }    \
        WRITE_GLINT_CTRL_REG(DisconnectControl, DISCONNECT_INPUT_FIFO_ENABLE);    \
        glintInfo->CheckFIFO = FALSE;    \
        glintInfo->PCIDiscEnabled = TRUE;    \
    }    \
}

// PCI_DISCONNECT_DISABLE()
// If disconnect is not already disabled then disable it and optionally do a fast
// sync.

#define PCI_DISCONNECT_DISABLE(prevDiscState, quickDisable)    \
{    \
    prevDiscState = glintInfo->PCIDiscEnabled;    \
    if (glintInfo->PCIDiscEnabled)    \
    {    \
        DISPDBG((7, "PCI_DISCONNECT_DISABLE()"));    \
        if (!quickDisable)    \
        {    \
            PCI_DISCONNECT_FASTSYNC();    \
        }    \
        WRITE_GLINT_CTRL_REG(DisconnectControl, DISCONNECT_INOUT_DISABLE);    \
        glintInfo->CheckFIFO = TRUE;    \
        glintInfo->PCIDiscEnabled = FALSE;    \
    }    \
}

// macros to set and get the framebuffer packing mode
//
#define GLINT_GET_PACKING_MODE(mode) \
    READ_GLINT_CTRL_REG (FBModeSel, mode)

#define GLINT_SET_PACKING_MODE(mode) { \
    DISPDBG((7, "setting FBModeSel to 0x%x", mode)); \
    WRITE_GLINT_CTRL_REG(FBModeSel, mode); \
    /* READ_GLINT_CTRL_REG (FBModeSel, mode); */ \
}


//
// macro to change the framebuffer packing.
//
#define GLINT_SET_FB_DEPTH(cps) \
{ \
    if (glintInfo->currentPelSize != cps) \
        vGlintChangeFBDepth(ppdev, cps); \
}

#define GLINT_DEFAULT_FB_DEPTH  GLINT_SET_FB_DEPTH(ppdev->cPelSize)
#define GLINTDEPTH8             0
#define GLINTDEPTH16            1
#define GLINTDEPTH32            2
#define GLINTDEPTH24            4

// macro to check and reload FBWindowBase if the target DFB changes
//
#define CHECK_PIXEL_ORIGIN(PixOrg) \
{ \
    if ((LONG)(PixOrg) != glintInfo->PixelOffset) \
    { \
        glintInfo->PixelOffset = (PixOrg); \
        WAIT_GLINT_FIFO(1); \
        LD_GLINT_FIFO(__GlintTagFBWindowBase, glintInfo->PixelOffset); \
        DISPDBG((7, "New bitmap origin at offset %d", glintInfo->PixelOffset)); \
    } \
}

#define GET_GAMMA_FEEDBACK_COMPLETED_COUNT(cEntriesWritten) \
{ \
    READ_GLINT_CTRL_REG(GammaFeedbackSelectCount, cEntriesWritten); \
}

#define PREPARE_GAMMA_OUTPUT_DMA \
{ \
    WRITE_GLINT_CTRL_REG(GammaCommandIntFlags, INTR_CLEAR_GAMMA_OUTPUT_DMA); \
}

#define WAIT_GAMMA_OUTPUT_DMA_COMPLETED \
{ \
    READ_GLINT_CTRL_REG(GammaCommandIntFlags, _temp_ul); \
    if (!(_temp_ul & INTR_GAMMA_OUTPUT_DMA_SET)) \
    { \
        do \
        { \
            for(_temp_volatile_i = 100; --_temp_volatile_i;); \
            READ_GLINT_CTRL_REG(GammaCommandIntFlags, _temp_ul); \
        } \
        while(!(_temp_ul & INTR_GAMMA_OUTPUT_DMA_SET)); \
    } \
}

// Bitfield definition for IntFlags register
#define PXRX_HOSTIN_COMMAND_DMA_BIT     0x4000

#define PREPARE_PXRX_OUTPUT_DMA     \
{ \
    WRITE_GLINT_CTRL_REG(IntFlags, PXRX_HOSTIN_COMMAND_DMA_BIT); \
}

#define SEND_PXRX_COMMAND_INTERRUPT     \
{ \
    WAIT_GLINT_FIFO(1);        \
    LD_GLINT_FIFO( CommandInterrupt_Tag, 1);    \
}


#define WAIT_PXRX_OUTPUT_DMA_COMPLETED \
{ \
    READ_GLINT_CTRL_REG(IntFlags, _temp_ul); \
    if (!(_temp_ul & PXRX_HOSTIN_COMMAND_DMA_BIT)) \
    { \
        do \
        { \
            for(_temp_volatile_i = 100; --_temp_volatile_i;); \
            READ_GLINT_CTRL_REG(IntFlags, _temp_ul); \
        } \
        while(!(_temp_ul & PXRX_HOSTIN_COMMAND_DMA_BIT)); \
    } \
}



#define WAIT_GAMMA_INPUT_DMA_COMPLETED \
{ \
    CommandStatusData   CmdSts; \
    READ_GLINT_CTRL_REG(GammaCommandStatus, _temp_ul); \
    CmdSts = *(CommandStatusData *)&_temp_ul; \
    if(CmdSts.CommandDMABusy) \
    { \
        do \
        { \
            for(_temp_volatile_i = 100; --_temp_volatile_i;); \
            READ_GLINT_CTRL_REG(GammaCommandStatus,  _temp_ul); \
            CmdSts = *(CommandStatusData *)&_temp_ul; \
        } \
        while(CmdSts.CommandDMABusy); \
    } \
}

// Macro to set the delta unit broadcast mask.
// We sync when changing the mask to a anything other than both chips
// in order to avoid hitting a problem on some Gamma boards.
#define SET_BROADCAST_MASK(m) \
{ \
    WAIT_GLINT_FIFO(1); \
    LD_GLINT_FIFO(__DeltaTagBroadcastMask, m); \
}


// Macros for the different types of double buffering supported and buffer
// offsets (in pixels). These are mostly required by 3D extension.
//
#define GLINT_CS_DBL_BUF            (glintInfo->flags & GLICAP_COLOR_SPACE_DBL_BUF)
#define GLINT_FS_DBL_BUF            (glintInfo->flags & GLICAP_FULL_SCREEN_DBL_BUF)
#define GLINT_BLT_DBL_BUF           (glintInfo->flags & GLICAP_BITBLT_DBL_BUF)
#define GLINT_FIX_FAST_FILL         (glintInfo->flags & GLICAP_FIX_FAST_FILLS)
#define GLINT_HW_WRITE_MASK         (glintInfo->flags & GLICAP_HW_WRITE_MASK)
#define GLINT_HW_WRITE_MASK_BYTES   (glintInfo->flags & GLICAP_HW_WRITE_MASK_BYTES)
#define GLINT_INTERRUPT_DMA         (glintInfo->flags & GLICAP_INTERRUPT_DMA)
#define GLINT_FAST_FILL_SIZE        (glintInfo->fastFillBlockSz)
#define GLINT_BUFFER_OFFSET(n)      (glintInfo->bufferOffset[n])

// these are generic for both GLINT and PERMEDIA
#define LOCALBUFFER_PIXEL_WIDTH     (glintInfo->ZBufferWidth)  
#define LOCALBUFFER_PIXEL_OFFSET    (glintInfo->ZBufferOffset)  
#define LOCALBUFFER_PIXEL_COUNT     (glintInfo->ZBufferSize)
#define FONT_MEMORY_OFFSET          (glintInfo->FontMemoryOffset)
#define FONT_MEMORY_SIZE            (glintInfo->FontMemorySize)
#define TEXTURE_MEMORY_OFFSET       (glintInfo->TextureMemoryOffset)  
#define TEXTURE_MEMORY_SIZE         (glintInfo->TextureMemorySize)

// Minimum height of off-screen surface we need to allocate for texture map.
// Use this to work out whether we have enough room to allocate permanent
// things like the brush cache and software cursor caches.
//
#define TEXTURE_OH_MIN_HEIGHT \
    ((((2*4*64*64) >> ppdev->cPelSize) + (ppdev->cxMemory-1)) / ppdev->cxMemory)

// macro to poll for VBLANK. Can be called by any routine which defines
// glintInfo (i.e. use GLINT_DECL at the start of a routine if ppdev
// is available). Technically, VBLANK starts at line 1, but we consider
// any line <= VBLANK_LINE_NUMBER as a valid start.
//
#define VBLANK_LINE_NUMBER      2
#define GLINT_WAIT_FOR_VBLANK                         \
{                                                     \
    ULONG lineNo;                                     \
    do {                                              \
        READ_GLINT_CTRL_REG (VTGVLineNumber, lineNo); \
    } while (lineNo > VBLANK_LINE_NUMBER);            \
}

// macro to return the current video scanline. This can be used to better time
// when to perform bitblt'ed double buffering.
//
#define GLINT_GET_VIDEO_SCANLINE(lineNo) \
{ \
    READ_GLINT_CTRL_REG (VTGVLineNumber, lineNo); \
    if (((lineNo) -= glintInfo->scanFudge) < 0) \
        (lineNo) += glintInfo->vtgvLimit; \
}

//
// external interface to the context switching code. The caller can allocate and
// free a context or ask for a switch to a new context. vGlintSwitchContext
// should not be called except through the given macro. The macro assumes
// that ppdev has been defined.
//

typedef enum ContextType_Tag {
    ContextType_None,            // No context information to save for this context
    ContextType_Fixed,            // Restore sets the chip into a fixed state
    ContextType_RegisterList,    // Save/restore a given set of registers
} ContextType;
typedef void (* ContextFixedFunc)(PPDEV ppdev, BOOL switchingIn);

/*
    To create a new context:
    id = GlintAllocateNewContext(ppdev, pTags, nTags, NumSubBuffs, Private, ContextType_RegisterList );
    id = GlintAllocateNewContext(ppdev, (ULONG *) ContextRestoreFunction, 0, 0, NULL, ContextType_Fixed );
*/

extern LONG GlintAllocateNewContext(PPDEV, DWORD *, LONG, ULONG, PVOID, ContextType);
extern VOID vGlintFreeContext(PPDEV, LONG);
extern VOID vGlintSwitchContext(PPDEV, LONG);

#define NON_GLINT_CONTEXT_ID 0x7fffffff

#define GLINT_VALIDATE_CONTEXT(id) \
    if (((ppdev)->currentCtxt) != (id)) \
        vGlintSwitchContext(ppdev, (id))

#define GLINT_VALIDATE_CONTEXT_AND_SYNC(id) { \
    if (((ppdev)->currentCtxt) != (id)) \
        vGlintSwitchContext(ppdev, (id)); \
    else \
        SYNC_WITH_GLINT; \
}

#define USE_INTERRUPTS_FOR_2D_DMA   1
#if USE_INTERRUPTS_FOR_2D_DMA
#define INTERRUPTS_ENABLED  ((ppdev->flCaps & CAPS_INTERRUPTS) && glintInfo->pInterruptCommandBlock)
#else   // USE_INTERRUPTS_FOR_2D_DMA
#define INTERRUPTS_ENABLED  (FALSE)
#endif  //  USE_INTERRUPTS_FOR_2D_DMA

// macro used by display driver to validate its context
#if ENABLE_DMA_TEXT_RENDERING

#define VALIDATE_DD_CONTEXT \
{ \
    if(DD_DMA_XFER_IN_PROGRESS) \
    { \
        DISPDBG((9, "######## Waiting for DMA to complete ########")); \
        WAIT_DD_DMA_COMPLETE; \
    } \
    else \
    { \
        DISPDBG((9, "######## No DMA in progress ########")); \
    } \
    GLINT_VALIDATE_CONTEXT(glintInfo->ddCtxtId); \
}

#else //ENABLE_DMA_TEXT_RENDERING

#define VALIDATE_DD_CONTEXT \
{ \
    GLINT_VALIDATE_CONTEXT(glintInfo->ddCtxtId); \
}

#endif //ENABLE_DMA_TEXT_RENDERING

//
// useful macros not defined in standard GLINT header files. Generally, for
// speed we don't want to use the bitfield structures so we define the bit
// shifts to get at the various fields.
//
#define INTtoFIXED(i)               ((i) << 16)         // int to 16.16 fixed format
#define FIXEDtoINT(i)               ((i) >> 16)         // 16.16 fixed format to int
#define INTofFIXED(i)               ((i) & 0xffff0000)  // int part of 16.16
#define FRACTofFIXED(i)             ((i) & 0xffff)      // fractional part of 16.16

#define FIXtoFIXED(i)               ((i) << 12)         // 12.4 to 16.16
#define FIXtoINT(i)                 ((i) >> 4)          // 28.4 to 28

#define INT16(i)                    ((i) & 0xFFFF)

#define __GLINT_CONSTANT_FB_WRITE   (1 << (4+1))
#define __COLOR_DDA_FLAT_SHADE      (__PERMEDIA_ENABLE | \
                                     (__GLINT_FLAT_SHADE_MODE << 1))
#define __COLOR_DDA_GOURAUD_SHADE   (__PERMEDIA_ENABLE | \
                                     (__GLINT_GOURAUD_SHADE_MODE << 1))

#define MIRROR_BITMASK              (1 << 0)
#define INVERT_BITMASK_BITS         (1 << 1)
#define BYTESWAP_BITMASK            (3 << 7)
#define FORCE_BACKGROUND_COLOR      (1 << 6)    // Permedia only
#define MULTI_GLINT                 (1 << 17)

// bits in the Render command
#define __RENDER_INCREASE_Y             (1 << 22)
#define __RENDER_INCREASE_X             (1 << 21)
#define __RENDER_VARIABLE_SPANS         (1 << 18)
#define __RENDER_REUSE_BIT_MASK         (1 << 17)
#define __RENDER_TEXTURE_ENABLE         (1 << 13)
#define __RENDER_SYNC_ON_HOST_DATA      (1 << 12)
#define __RENDER_SYNC_ON_BIT_MASK       (1 << 11)
#define __RENDER_TRAPEZOID_PRIMITIVE    (__GLINT_TRAPEZOID_PRIMITIVE << 6)
#define __RENDER_LINE_PRIMITIVE         (__GLINT_LINE_PRIMITIVE << 6)
#define __RENDER_POINT_PRIMITIVE        (__GLINT_POINT_PRIMITIVE << 6)
#define __RENDER_FAST_FILL_INC(n)       (((n) >> 4) << 4) // n = 8, 16 or 32
#define __RENDER_FAST_FILL_ENABLE       (1 << 3)
#define __RENDER_RESET_LINE_STIPPLE     (1 << 2)
#define __RENDER_LINE_STIPPLE_ENABLE    (1 << 1)
#define __RENDER_AREA_STIPPLE_ENABLE    (1 << 0)

// bits in the ScissorMode register
#define USER_SCISSOR_ENABLE             (1 << 0)
#define SCREEN_SCISSOR_ENABLE           (1 << 1)
#define SCISSOR_XOFFSET                 0
#define SCISSOR_YOFFSET                 16

// bits in the FBReadMode register
#define __FB_READ_SOURCE                (1 << 9)
#define __FB_READ_DESTINATION           (1 << 10)
#define __FB_COLOR                      (1 << 15)
#define __FB_WINDOW_ORIGIN              (1 << 16)
#define __FB_PACKED_DATA                (1 << 19)
#define __FB_SCAN_INTERVAL_2            (1 << 23)
// extra bits in PERMEDIA FBReadMode
#define __FB_RELATIVE_OFFSET            20

// P2 also provides a version of Relative Offset in the PackedDataLimits register
#define __PDL_RELATIVE_OFFSET           29


// bits in the LBReadMode register
#define __LB_READ_SOURCE                 (1 << 9)
#define __LB_READ_DESTINATION           (1 << 10)
#define __LB_STENCIL                    (1 << 16)
#define __LB_DEPTH                      (1 << 17)
#define __LB_WINDOW_ORIGIN              (1 << 18)
#define __LB_READMODE_PATCH             (1 << 19)
#define __LB_SCAN_INTERVAL_2            (1 << 20)

// bits in the DepthMode register
#define __DEPTH_ENABLE              1
#define __DEPTH_WRITE_ENABLE    (1<<1)
#define __DEPTH_REGISTER_SOURCE     (2<<2)
#define __DEPTH_MSG_SOURCE          (3<<2)
#define __DEPTH_ALWAYS              (7<<4)

// bits in the LBReadFormat/LBWriteFormat registers 
#define __LB_FORMAT_DEPTH32     2

// macros to load indexed tags more efficiently than using __GlintDMATag struct
#define GLINT_TAG_MAJOR(x)        ((x) & 0xff0)
#define GLINT_TAG_MINOR(x)        ((x) & 0x00f)

           
// macro to take a GLINT logical op and return the enabled LogcialOpMode bits
#define GLINT_ENABLED_LOGICALOP(op)     (((op) << 1) | __PERMEDIA_ENABLE)

#define RECTORIGIN_YX(y,x)                (((y) << 16) | ((x) & 0xFFFF))

#define MAKEDWORD_XY(x, y)                (INT16(x) | (INT16(y) << 16))

// area stipple shifts and bit defines

#define AREA_STIPPLE_XSEL(x)        ((x) << 1)
#define AREA_STIPPLE_YSEL(y)        ((y) << 4)
#define AREA_STIPPLE_XOFF(x)        ((x) << 7)
#define AREA_STIPPLE_YOFF(y)        ((y) << 12)
#define AREA_STIPPLE_INVERT_PAT     (1 << 17)
#define AREA_STIPPLE_MIRROR_X       (1 << 18)
#define AREA_STIPPLE_MIRROR_Y       (1 << 19)

// Some constants
#define ONE                     0x00010000
#define MINUS_ONE               0xFFFF0000
#define PLUS_ONE                ONE
#define NEARLY_ONE              0x0000FFFF
#define HALF                    0x00008000
#define NEARLY_HALF             0x00007FFF

// max length of GIQ conformant lines that GLINT can draw
//
#if 0
#define MAX_LENGTH_CONFORMANT_NONINTEGER_LINES  16
#define MAX_LENGTH_CONFORMANT_INTEGER_LINES     194
#else
// Permedia has only 15 bits of fraction so reduce the lengths.
#define MAX_LENGTH_CONFORMANT_NONINTEGER_LINES  (16/2)
#define MAX_LENGTH_CONFORMANT_INTEGER_LINES     (194/2)
#endif

#define MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P    194
#define MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N    175
#define P3_LINES_BIAS_P                             0x3EFFFFFF
#define P3_LINES_BIAS_N                             0x3EFEB600


//
// GLINT DMA definitions
//

#define IOCTL_VIDEO_QUERY_NUM_DMA_BUFFERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DMA_BUFFERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DEVICE_INFO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_DWORD \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_SAVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD9, METHOD_BUFFERED, FILE_ANY_ACCESS)

// structure definitions passed in by the application for mapping and
// unmapping DMA buffers.
//

typedef struct _DMA_NUM_BUFFERS {
    ULONG NumBuffers;
    ULONG BufferInformationLength;
} DMA_NUM_BUFFERS, *PDMA_NUM_BUFFERS;

typedef struct _QUERY_DMA_BUFFERS {
    LARGE_INTEGER physAddr;   // physical address of DMA buffer
    PVOID         virtAddr;   // mapped virtual address
    ULONG         size;       // size in bytes
    ULONG         flags;
} QUERY_DMA_BUFFERS, *PQUERY_DMA_BUFFERS;

// values for flags word
#define DMA_BUFFER_INUSE    0x1

// functions to get and free DMA buffers
VOID FreeDMABuffer(PVOID physAddr);
LONG GetFreeDMABuffer(PQUERY_DMA_BUFFERS dmaBuf);

// Generic locling structure/interface that enables arbitrary buffers
// to be locked/unlocked for accessing.
typedef struct _glint_lockedmem_ {
    struct  _MDL *pMdl;
    ULONG   sizeBytes;
    PVOID   bufferPtr;
    ULONG   accessType;
    ULONG   physicalAddress;
    ULONG   result;
} GLINT_LOCKMEM_REC, *PGLINT_LOCKMEM_PTR;

// Routine to support the obtaining of a physical address from a virtual
// address
typedef struct _glint_physaddr_ {
    PVOID   virtualAddress;
    ULONG   physicalAddress;
} GLINT_PHYSADDR_REC, *PGLINT_PHYSADDR_PTR;

// definitions for DMA transfers

#define INPUT_DMA  0
#define OUTPUT_DMA 1

typedef struct DMA_Transfer_Buffer
{
    VOID    *pv;
    ULONG   cb;
    ULONG   DmaDirection;
}
DMAXFERBFRINFO;

// structure definitions for the file handle mapping ioctl
//
typedef struct _GLINT_MAP_FILE_HANDLE {
    ULONG   Size;
    HANDLE  fHandle;
} GLINT_MAP_FILE_HANDLE, *PGLINT_MAP_FILE_HANDLE;

typedef struct _GLINT_UNMAP_FILE_HANDLE {
    HANDLE  fHandle;
    PVOID   pv;
} GLINT_UNMAP_FILE_HANDLE, *PGLINT_UNMAP_FILE_HANDLE;

// structure for the user memory locking ioctls
typedef struct
{
    void    *pvBfr;
    ULONG   cbBfr;
    ULONG   hMem;
}
LOCKEDUSERMEM;

//
// registry variable names
//
#define REG_NUMBER_OF_SCREEN_BUFFERS    L"DoubleBuffer.NumberOfBuffers"

extern GFNXCOPYD vGlintCopyBltBypassDownloadXlate8bpp;

// function declarations
//
extern BOOL bInitializeGlint(PPDEV);
extern BOOL bAllocateGlintInfo(PPDEV ppdev);
extern VOID vDisableGlint(PPDEV);
extern VOID vAssertModeGlint(PPDEV, BOOL);
extern BOOL bGlintQueryRegistryValueUlong(PPDEV, LPWSTR, PULONG);
extern VOID vGlintChangeFBDepth(PPDEV, ULONG);
extern VOID vGlintInitializeDMA(PPDEV);
extern VOID vSetNewGammaValue(PPDEV ppdev, ULONG ulgvFIX16_16, BOOL waitVBlank);
extern BOOL bInstallGammaLUT(PPDEV ppdev, PVIDEO_CLUT pScreenClut, BOOL waitVBlank);

#define GLINT_ENABLE_OVERLAY    1
#define GLINT_DISABLE_OVERLAY   0

//
// Externs/Defines from Pointer.c
// ==============================
//
// Hardware pointer caching functions/macros.
//
extern VOID HWPointerCacheInit (HWPointerCache * ptrCache);
extern VOID HWPointerCacheInvalidate (HWPointerCache * ptrCache);
#define HWPointerCacheInvalidate(ptrCache) (ptrCache)->ptrCacheInUseCount = 0

extern LONG HWPointerCacheCheckAndAdd (HWPointerCache * ptrCache, ULONG cx, 
                                ULONG cy, LONG lDelta, BYTE * scan0, BOOL * isCached);
extern BYTE gajMask[];

//
// The following structures and macros define the memory map for the GLINT
// control registers. We don't use this memory map to access GLINT registers
// since on Alpha machines we want to precompute the addresses. So we do
// a TRANSLATE_ADDR_ULONG on all the addresses here and save them into a
// GlintRegAddrRec. We use that to obtain the addresses for the different
// registers.

typedef struct {
    ULONG   reg;
    ULONG   pad;
} RAMDAC_REG;

// macros to add padding words to the structures. For the core registers we use
// the tag ids when specifying the pad. So we must multiply by 8 to get a byte
// pad. We need to add an id to make each pad field in the struct unique. The id
// is irrelevant as long as it's different from every other id used in the same
// struct. It's a pity pad##__LINE__ doesn't work.
//
#define PAD(id, n)              UCHAR   pad##id[n]
#define PADRANGE(id, n)         PAD(id, (n)-sizeof(GLINT_REG))
#define PADCORERANGE(id, n)     PADRANGE(id, (n)<<3)

// GLINT registers are 32 bits wide and live on 64-bit boundaries.
typedef struct {
    ULONG   reg;
    ULONG   pad;
} GLINT_REG;

//
// Map of the Core FIFO registers.
//
typedef struct _glint_core_regs {

    // Major Group 0
    GLINT_REG       tag[__MaximumGlintTagValue+1];

} GlintCoreRegMap, *pGlintCoreRegMap;



//
// GLINT PCI Region 0 Address MAP:
//
// All registers are on 64-bit boundaries so we have to define a number of
// padding words. The number given in the coments are offsets from the start
// of the PCI region.
//
typedef struct _glint_region0_map {

    // Control Status Registers:
    GLINT_REG       ResetStatus;                // 0000h
    GLINT_REG       IntEnable;                  // 0008h
    GLINT_REG       IntFlags;                   // 0010h
    GLINT_REG       InFIFOSpace;                // 0018h
    GLINT_REG       OutFIFOWords;               // 0020h
    GLINT_REG       DMAAddress;                 // 0028h
    GLINT_REG       DMACount;                   // 0030h
    GLINT_REG       ErrorFlags;                 // 0038h
    GLINT_REG       VClkCtl;                    // 0040h
    GLINT_REG       TestRegister;               // 0048h
    union a0 {
        // GLINT
        struct b0 {
            GLINT_REG       Aperture0;          // 0050h
            GLINT_REG       Aperture1;          // 0058h
        };
        // PERMEDIA
        struct b1 {
            GLINT_REG       ApertureOne;        // 0050h
            GLINT_REG       ApertureTwo;        // 0058h
        };
    };
    GLINT_REG       DMAControl;                 // 0060h
    GLINT_REG       DisconnectControl;          // 0068h

    // PERMEDIA only
    GLINT_REG       ChipConfig;                 // 0070h

    // P2 only
    GLINT_REG       AGPControl;                 // 0078h
    GLINT_REG       OutDMAAddress;              // 0080h
    GLINT_REG       OutDMACount;                // 0088h  // P3: FeedbackCount
    PADRANGE(2, 0xA0-0x88);
 
    GLINT_REG       ByDMAAddress;               // 00A0h
    PADRANGE(201, 0xB8-0xA0);

    GLINT_REG       ByDMAStride;                // 00B8h
    GLINT_REG       ByDMAMemAddr;                // 00C0h
    GLINT_REG       ByDMASize;                    // 00C8h
    GLINT_REG       ByDMAByteMask;                // 00D0h
    GLINT_REG       ByDMAControl;                // 00D8h
    PADRANGE(202, 0xE8-0xD8);

    GLINT_REG       ByDMAComplete;                // 00E8h
    PADRANGE(203, 0x108-0xE8);

    GLINT_REG       TextureDownloadControl;        // 0108h 
    PADRANGE(204, 0x200-0x108);

    GLINT_REG       TestInputControl;            // 0200h
    GLINT_REG       TestInputRdy;                // 0208h
    GLINT_REG       TestOutputControl;            // 0210h
    GLINT_REG       TestOutputRdy;                // 0218h
    PADRANGE(205, 0x300-0x218);

    GLINT_REG       PXRXByAperture1Mode;        // 0300h
    GLINT_REG       PXRXByAperture1Stride;        // 0308h
    GLINT_REG       PXRXByAperture1YStart;        // 0310h
    GLINT_REG       PXRXByAperture1UStart;        // 0318h
    GLINT_REG       PXRXByAperture1VStart;        // 0320h
    GLINT_REG       PXRXByAperture2Mode;        // 0328h
    GLINT_REG       PXRXByAperture2Stride;        // 0330h
    GLINT_REG       PXRXByAperture2YStart;        // 0338h
    GLINT_REG       PXRXByAperture2UStart;        // 0340h
    GLINT_REG       PXRXByAperture2VStart;        // 0348h
    GLINT_REG       PXRXByDMAReadMode;            // 0350h
    GLINT_REG       PXRXByDMAReadStride;        // 0358h
    GLINT_REG       PXRXByDMAReadYStart;        // 0360h
    GLINT_REG       PXRXByDMAReadUStart;        // 0368h
    GLINT_REG       PXRXByDMAReadVStart;        // 0370h
    GLINT_REG       PXRXByDMAReadCommandBase;    // 0378h
    GLINT_REG       PXRXByDMAReadCommandCount;    // 0380h
    GLINT_REG       PXRXByDMAWriteMode;            // 0388h
    GLINT_REG       PXRXByDMAWriteStride;        // 0390h
    GLINT_REG       PXRXByDMAWriteYStart;        // 0398h
    GLINT_REG       PXRXByDMAWriteUStart;        // 03A0h
    GLINT_REG       PXRXByDMAWriteVStart;        // 03A8h
    GLINT_REG       PXRXByDMAWriteCommandBase;    // 03B0h
    GLINT_REG       PXRXByDMAWriteCommandCount;    // 03B8h
    PADRANGE(206, 0x800-0x3B8);

    // GLINTdelta registers. Registers with the same functionality as on GLINT
    // are at the same offset. XXX are not real registers.
    // NB. all non-XXX registers are also Gamma registers
    //
    GLINT_REG       DeltaReset;                 // 0800h
    GLINT_REG       DeltaIntEnable;             // 0808h
    GLINT_REG       DeltaIntFlags;              // 0810h
    GLINT_REG       DeltaInFIFOSpaceXXX;        // 0818h
    GLINT_REG       DeltaOutFIFOWordsXXX;       // 0820h
    GLINT_REG       DeltaDMAAddressXXX;         // 0828h
    GLINT_REG       DeltaDMACountXXX;           // 0830h
    GLINT_REG       DeltaErrorFlags;            // 0838h
    GLINT_REG       DeltaVClkCtlXXX;            // 0840h
    GLINT_REG       DeltaTestRegister;          // 0848h
    GLINT_REG       DeltaAperture0XXX;          // 0850h
    GLINT_REG       DeltaAperture1XXX;          // 0858h
    GLINT_REG       DeltaDMAControlXXX;         // 0860h
    GLINT_REG       DeltaDisconnectControl;     // 0868h

    // GLINTgamma registers
    //
    GLINT_REG       GammaChipConfig;            // 0870h
    GLINT_REG       GammaCSRAperture;            // 0878h
    PADRANGE(3, 0x0c00-0x878);
    GLINT_REG       GammaPageTableAddr;            // 0c00h
    GLINT_REG       GammaPageTableLength;        // 0c08h
    PADRANGE(301, 0x0c38-0x0c08);
    GLINT_REG       GammaDelayTimer;            // 0c38h
    GLINT_REG       GammaCommandMode;            // 0c40h
    GLINT_REG       GammaCommandIntEnable;        // 0c48h
    GLINT_REG       GammaCommandIntFlags;        // 0c50h
    GLINT_REG       GammaCommandErrorFlags;        // 0c58h
    GLINT_REG       GammaCommandStatus;            // 0c60h
    GLINT_REG       GammaCommandFaultingAddr;    // 0c68h
    GLINT_REG       GammaVertexFaultingAddr;    // 0c70h
    PADRANGE(302, 0x0c88-0x0c70);
    GLINT_REG       GammaWriteFaultingAddr;        // 0c88h
    PADRANGE(303, 0x0c98-0x0c88);
    GLINT_REG       GammaFeedbackSelectCount;    // 0c98h
    PADRANGE(304, 0x0cb8-0x0c98);
    GLINT_REG       GammaProcessorMode;            // 0cb8h
    PADRANGE(305, 0x0d00-0x0cb8);
    GLINT_REG       GammaVGAShadow;                // 0d00h
    GLINT_REG       GammaMultiGLINTAperture;    // 0d08h    
    GLINT_REG       GammaMultiGLINT1;            // 0d10h
    GLINT_REG       GammaMultiGLINT2;            // 0d18h
    PADRANGE(306, 0x0f00-0x0d18);
    GLINT_REG       GammaSerialAccess;            // 0f00h
    PADRANGE(307, 0x1000-0x0f00);


    // Localbuffer Registers
    union x0 {                                  // 1000h
        GLINT_REG   LBMemoryCtl;                //   GLINT
        GLINT_REG   Reboot;                     //   PERMEDIA
    };
    GLINT_REG       LBMemoryEDO;                // 1008h

    // PXRX Memory control registers
    GLINT_REG       MemScratch;                    // 1010h
    GLINT_REG       LocalMemCaps;                // 1018h
    GLINT_REG       LocalMemTiming;                // 1020h
    GLINT_REG       LocalMemControl;            // 1028h
    GLINT_REG       LocalMemRefresh;            // 1030h
    GLINT_REG       LocalMemPowerDown;            // 1038h

    // PERMEDIA only
    GLINT_REG       MemControl;                 // 1040h
    PADRANGE(5, 0x1068-0x1040);
    GLINT_REG       LocalMemProfileMask0;        // 1068h
    GLINT_REG       LocalMemProfileCount0;        // 1070h
    GLINT_REG       LocalMemProfileMask1;        // 1078h
    GLINT_REG       BootAddress;                // 1080h        // [= LocalMemProfileCount1 on PxRx]
    PADRANGE(6, 0x10C0-0x1080);
    GLINT_REG       MemConfig;                  // 10C0h
    PADRANGE(7, 0x1100-0x10C0);
    GLINT_REG       BypassWriteMask;            // 1100h
    PADRANGE(8, 0x1140-0x1100);
    GLINT_REG       FramebufferWriteMask;       // 1140h
    PADRANGE(9, 0x1180-0x1140);
    GLINT_REG       Count;                      // 1180h
    PADRANGE(10, 0x1800-0x1180);

    // Framebuffer Registers
    GLINT_REG       FBMemoryCtl;                // 1800h
    GLINT_REG       FBModeSel;                  // 1808h
    GLINT_REG       FBGCWrMask;                 // 1810h
    GLINT_REG       FBGCColorMask;              // 1818h
    PADRANGE(11, 0x2000-0x1818);
               
    // Graphics Core FIFO Interface
    GLINT_REG       FIFOInterface;              // 2000h
    PADRANGE(12, 0x3000-0x2000);

    // Internal Video Registers
    union x1 {
        // GLINT
        struct s1 {
            GLINT_REG   VTGHLimit;              // 3000h
            GLINT_REG   VTGHSyncStart;          // 3008h
            GLINT_REG   VTGHSyncEnd;            // 3010h
            GLINT_REG   VTGHBlankEnd;           // 3018h
            GLINT_REG   VTGVLimit;              // 3020h
            GLINT_REG   VTGVSyncStart;          // 3028h
            GLINT_REG   VTGVSyncEnd;            // 3030h
            GLINT_REG   VTGVBlankEnd;           // 3038h
            GLINT_REG   VTGHGateStart;          // 3040h
            GLINT_REG   VTGHGateEnd;            // 3048h
            GLINT_REG   VTGVGateStart;          // 3050h
            GLINT_REG   VTGVGateEnd;            // 3058h
            GLINT_REG   VTGPolarity;            // 3060h
            GLINT_REG   VTGFrameRowAddr;        // 3068h
            GLINT_REG   VTGVLineNumber;         // 3070h
            GLINT_REG   VTGSerialClk;           // 3078h
            GLINT_REG   VTGModeCtl;               // 3080h
        };
        // PERMEDIA
        struct s2 {
            GLINT_REG   ScreenBase;             // 3000h
            GLINT_REG   ScreenStride;           // 3008h
            GLINT_REG   HTotal;                 // 3010h
            GLINT_REG   HgEnd;                  // 3018h
            GLINT_REG   HbEnd;                  // 3020h
            GLINT_REG   HsStart;                // 3028h
            GLINT_REG   HsEnd;                  // 3030h
            GLINT_REG   VTotal;                 // 3038h
            GLINT_REG   VbEnd;                  // 3040h
            GLINT_REG   VsStart;                // 3048h
            GLINT_REG   VsEnd;                  // 3050h
            GLINT_REG   VideoControl;           // 3058h
            GLINT_REG   InterruptLine;          // 3060h
            GLINT_REG   DDCData;                // 3068h
            GLINT_REG   LineCount;              // 3070h
            GLINT_REG   FifoControl ;           // 3078h
            GLINT_REG   ScreenBaseRight;          // 3080h
        };
    };

    PADRANGE(13, 0x4000-0x3080);

    // External Video Control Registers
    // Need to cast this to a struct for a particular video generator
    GLINT_REG       ExternalVideo;              // 4000h
    PADRANGE(14, 0x5000-0x4000);

    // P2 specific registers
    union x11 {
        GLINT_REG       ExternalP2Ramdac;           // 5000h
        GLINT_REG       DemonProDWAndStatus;        // 5000h - Pro
    };
    PADRANGE(15, 0x5800-0x5000);
    GLINT_REG       VSConfiguration;            // 5800h
    PADRANGE(16, 0x6000-0x5800);

    union x2 {
        struct s3 {
            GLINT_REG   RacerDoubleWrite;        // 6000h
            GLINT_REG   RacerBankSelect;        // 6008h
        };
        struct s4 {
            // the following array is actually 1024 bytes long
            UCHAR       PermediaVgaCtrl[2*sizeof(GLINT_REG)];
        };
    };

    PADRANGE(17, 0x7000-0x6008);
    GLINT_REG       DemonProUBufB;              // 7000h - Pro
    PADRANGE(18, 0x8000-0x7000);

    // Graphics Core Registers
    GlintCoreRegMap coreRegs;                   // 8000h

} GlintControlRegMap, *pGlintControlRegMap;


//
// DisconnectControl bits
//
#define DISCONNECT_INPUT_FIFO_ENABLE    0x1
#define DISCONNECT_OUTPUT_FIFO_ENABLE   0x2
#define DISCONNECT_INOUT_ENABLE         (DISCONNECT_INPUT_FIFO_ENABLE | \
                                         DISCONNECT_OUTPUT_FIFO_ENABLE)
#define DISCONNECT_INOUT_DISABLE        0x0

//
// Delta bit definitions
//

#define DELTA_BROADCAST_TO_CHIP(n)        (1 << (n))
#define DELTA_BROADCAST_TO_BOTH_CHIPS     (DELTA_BROADCAST_TO_CHIP(0) | \
                                           DELTA_BROADCAST_TO_CHIP(1))

//
// Multi TX
//

#define GLINT_OWN_SCANLINE_0                (0 << 2)
#define GLINT_OWN_SCANLINE_1                (1 << 2)
#define GLINT_OWN_SCANLINE_2                (2 << 2)
#define GLINT_OWN_SCANLINE_3                (3 << 2)

#define GLINT_SCANLINE_INTERVAL_1           (0 << 0)
#define GLINT_SCANLINE_INTERVAL_2           (1 << 0)
#define GLINT_SCANLINE_INTERVAL_4           (2 << 0)
#define GLINT_SCANLINE_INTERVAL_8           (3 << 0)

#define SCANLINE_OWNERSHIP_EVEN_SCANLINES   (GLINT_OWN_SCANLINE_0 | GLINT_SCANLINE_INTERVAL_2)
#define SCANLINE_OWNERSHIP_ODD_SCANLINES    (GLINT_OWN_SCANLINE_1 | GLINT_SCANLINE_INTERVAL_2)

// Glint Interrupt Control Bits
//
    // InterruptEnable register
#define INTR_DISABLE_ALL                0x00
#define INTR_ENABLE_DMA                 0x01
#define INTR_ENABLE_SYNC                0x02
#define INTR_ENABLE_EXTERNAL            0x04
#define INTR_ENABLE_ERROR               0x08
#define INTR_ENABLE_VBLANK              0x10
#define INTR_ENABLE_TEXTURE_FAULT       (1 << 6)


    // InterruptFlags register
#define INTR_DMA_SET                    0x01
#define INTR_SYNC_SET                   0x02
#define INTR_EXTERNAL_SET               0x04
#define INTR_ERROR_SET                  0x08
#define INTR_VBLANK_SET                 0x10
#define INTR_TEXTURE_FAULT_SET          (1 << 6)

#define INTR_CLEAR_ALL                  0x1f
#define INTR_CLEAR_DMA                  0x01
#define INTR_CLEAR_SYNC                 0x02
#define INTR_CLEAR_EXTERNAL             0x04
#define INTR_CLEAR_ERROR                0x08
#define INTR_CLEAR_VBLANK               0x10                    

// Gamma Interrupt Control Bits
//
    // CommandIntEnable register
#define GAMMA_INTR_DISABLE_ALL  0x0000
#define GAMMA_INTR_QUEUED_DMA   0x0001
#define GAMMA_INTR_OUTPUT_DMA   0x0002
#define GAMMA_INTR_COMMAND      0x0004
#define GAMMA_INTR_TIMER        0x0008
#define GAMMA_INTR_ERROR        0x0010
#define GAMMA_INTR_CBFR_TIMEOUT 0x0020
#define GAMMA_INTR_CBFR_SUSPEND 0x0040
#define GAMMA_INTR_TEXDOWNLD    0x0080
#define GAMMA_INTR_PF_COMMAND   0x0100
#define GAMMA_INTR_PF_VERTEX    0x0200
#define GAMMA_INTR_PF_FACENORM  0x0400
#define GAMMA_INTR_PF_INDEX     0x0800
#define GAMMA_INTR_PF_WRITE     0x1000
#define GAMMA_INTR_PF_TEXTURE   0x2000

    // CommandIntFlags register - uses the same defines as CommandIntEnable
#define GAMMA_INTR_CLEAR_ALL            0x3fff

    // Gamma Command Interrupts
#define INTR_DISABLE_GAMMA_ALL          0
#define INTR_ENABLE_GAMMA_QUEUED_DMA    (1 << 0)
#define INTR_ENABLE_GAMMA_OUTPUT_DMA    (1 << 1)
#define INTR_ENABLE_GAMMA_COMMAND       (1 << 2)
#define INTR_ENABLE_GAMMA_TIMER         (1 << 3)
#define INTR_ENABLE_GAMMA_COMMAND_ERROR (1 << 4)
#define INTR_ENABLE_GAMMA_PAGE_FAULT    (1 << 8)
#define INTR_ENABLE_GAMMA_VERTEX_FAULT  (1 << 9)
#define INTR_ENABLE_GAMMA_WRITE_FAULT   (1 << 12)

#define INTR_GAMMA_QUEUED_DMA_SET       (1 << 0)
#define INTR_GAMMA_OUTPUT_DMA_SET       (1 << 1)
#define INTR_GAMMA_COMMAND_SET          (1 << 2)
#define INTR_GAMMA_TIMER_SET            (1 << 3)
#define INTR_GAMMA_COMMAND_ERROR_SET    (1 << 4)
#define INTR_GAMMA_PAGE_FAULT_SET       (1 << 8)
#define INTR_GAMMA_VERTEX_FAULT_SET     (1 << 9)
#define INTR_GAMMA_WRITE_FAULT_SET      (1 << 12)

#define INTR_CLEAR_GAMMA_QUEUED_DMA     (1 << 0)
#define INTR_CLEAR_GAMMA_OUTPUT_DMA     (1 << 1)
#define INTR_CLEAR_GAMMA_COMMAND        (1 << 2)
#define INTR_CLEAR_GAMMA_TIMER          (1 << 3)
#define INTR_CLEAR_GAMMA_COMMAND_ERROR  (1 << 4)
#define INTR_CLEAR_GAMMA_PAGE_FAULT     (1 << 8)
#define INTR_CLEAR_GAMMA_VERTEX_FAULT   (1 << 9)
#define INTR_CLEAR_GAMMA_WRITE_FAULT    (1 << 12)

    // Gamma Command Status
#define GAMMA_STATUS_COMMAND_DMA_BUSY   (1 << 0)
#define GAMMA_STATUS_OUTPUT_DMA_BUSY    (1 << 1)
#define GAMMA_STATUS_INPUT_FIFO_EMPTY   (1 << 2)

    // Gamma Command Mode
#define GAMMA_COMMAND_MODE_QUEUED_DMA           (1 << 0)
#define GAMMA_COMMAND_MODE_LOGICAL_ADDRESSING   (1 << 2)
#define GAMMA_COMMAND_MODE_ABORT_OUTPUT_DMA     (1 << 3)
#define GAMMA_COMMAND_MODE_ABORT_INPUT_DMA      (1 << 6)


// interrupt status bits
typedef enum {
    DMA_INTERRUPT_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
    SUSPEND_DMA_TILL_VBLANK     = 0x04, // Stop doing DMA till after next VBLANK
    DIRECTDRAW_VBLANK_ENABLED   = 0x08,    // Set flag for DirectDraw on VBLANK
    PXRX_SEND_ON_VBLANK_ENABLED = 0x10,    // Set flag for PXRX DMA on VBLANK
    PXRX_CHECK_VFIFO_IN_VBLANK  = 0x20, // Set flag to check VFIFO underruns in VBLANK (vblanks must be permanently enabled)
} INTERRUPT_CONTROL;

// commands to the interrupt controller on the next VBLANK
typedef enum {
    NO_COMMAND = 0,
    COLOR_SPACE_BUFFER_0,
    COLOR_SPACE_BUFFER_1,
    GLINT_RACER_BUFFER_0,
    GLINT_RACER_BUFFER_1
} VBLANK_CONTROL_COMMAND;

// we manage a queue of DMA buffers that are to be loaded under interrupt control
// each entry has a physical address and a count to be loaded into GLINT.
//
typedef struct _glint_dma_queue {
    ULONG   command;
    ULONG   address;
    ULONG   count;
} DMABufferQueue;

// Display driver structure for 'general use'.
typedef struct _pointer_interrupt_control
{
    volatile ULONG  bDisplayDriverHasAccess;
    volatile ULONG  bMiniportHasAccess;
    volatile ULONG  bInterruptPending;
    volatile ULONG  bHidden;
    volatile ULONG  CursorMode;
    volatile ULONG  x, y;
} PTR_INTR_CTL;

// Display driver structure for 'pointer use'.
typedef struct _general_interrupt_control
{
    volatile ULONG  bDisplayDriverHasAccess;
    volatile ULONG  bMiniportHasAccess;
} GEN_INTR_CTL;

//
// The volatile fields are the ones that the interrupt handler can change
// under our feet. But, for example, note that the frontIndex is not
// volatile since the ISR can only read this.
//
typedef struct _glint_interrupt_control {

    // contains various status bits. ** MUST BE THE FIRST FIELD **
    volatile INTERRUPT_CONTROL   Control;

    // profiling counters for GLINT busy time
    ULONG   PerfCounterShift;
    ULONG   BusyTime;   // at DMA interrupt add (TimeNow-StartTime) to this
    ULONG   StartTime;  // set this when DMACount is loaded
    ULONG   IdleTime;
    ULONG   IdleStart;

    // commands to perform on the next VBLANK
    volatile VBLANK_CONTROL_COMMAND   VBCommand;

    // flag to indicate whether we expect another DMA interrupt
    volatile ULONG InterruptPending;

    volatile ULONG  DDRAW_VBLANK;                    // flag for DirectDraw to indicate that a VBLANK occured.
    volatile ULONG  bOverlayEnabled;                // TRUE if the overlay is on at all
    volatile ULONG  bVBLANKUpdateOverlay;            // TRUE if the overlay needs to be updated by the VBLANK routine.
    volatile ULONG  VBLANKUpdateOverlayWidth;        // overlay width (updated in vblank)
    volatile ULONG  VBLANKUpdateOverlayHeight;        // overlay height (updated in vblank)

    // Volatile structures are required to enforce single-threading
    // We need 1 for general display use and 1 for pointer use, because
    // the pointer is synchronous.
    volatile PTR_INTR_CTL   Pointer;
    volatile GEN_INTR_CTL   General;

    // dummy DMA buffer to cause an interrupt but transfer no data
    ULONG   dummyDMAAddress;
    ULONG   dummyDMACount;
    
    // index offsets into the queue for the front, back and end. Using separate
    // front and back offsets allows the display driver to add and the interrupt
    // controller to remove entries without a need for locking code.
    ULONG   frontIndex;
    volatile ULONG   backIndex;
    ULONG   endIndex;
    ULONG   maximumIndex;

    // For PXRX 2D DMA:
    volatile ULONG  lastAddr;
    PXRXdmaInfo     pxrxDMA;

    // array to contain the DMA queue
    DMABufferQueue  dmaQueue[1];

    // DO NOT PUT ANYTHING AFTER THIS

} INTERRUPT_CONTROL_BLOCK, *PINTERRUPT_CONTROL_BLOCK;

/***** RACER FULL SCREEN DOUBLE BUFFERING MACROS ***********
 *
 * These macros were invented because some boards, such as 
 * Omnicomp ones, have their bank-switch registers in different places.
 *
 * The macros are:
 *
 *      SET_RACER_BANKSELECT()   - Sets the bank select register to be bank 0 or 1.
 *      GET_RACER_DOUBLEWRITE()  - Returns 1 if double writes are enabled, else returns 0.
 *      SET_RACER_DOUBLEWRITE()  - Sets the double write register to 0 or 1.
 *      IS_RACER_VARIANT_PRO16() - Returns TRUE if the board is an Omnicomp 3DemonPro16, RevC board.
 */

// We define an Omnicomp 3Demon Pro 16 to be a card that has a 16MB framebuffer.
#define SIXTEEN_MEG (16*1024*1024)
#define IS_RACER_VARIANT_PRO16(ppdev)   (glintInfo->deviceInfo.BoardId == OMNICOMP_3DEMONPRO)

//
// the following defines the offset to the External Video register which allows
// switching of the memory banks on a Glint Racer card.
//
#ifndef FIELD_OFFSET
#define FIELD_OFFSET(a, b)    ((LONG)&(((a *)0)->b))
#endif

// The Omnicomp 3Demon Pro 16 board uses different registers to do it's bank switching.

#define DEMON_BANK_SELECT_OFFSET                        \
((FIELD_OFFSET (GlintControlRegMap, DemonProUBufB)) -    \
(FIELD_OFFSET (GlintControlRegMap, ExternalVideo)))

#define REAL_RACER_BANK_SELECT_OFFSET                   \
((FIELD_OFFSET (GlintControlRegMap, RacerBankSelect)) - \
(FIELD_OFFSET (GlintControlRegMap, ExternalVideo)))

#define RACER_BANK_SELECT_OFFSET                        \
(IS_RACER_VARIANT_PRO16(ppdev) ? (DEMON_BANK_SELECT_OFFSET) : (REAL_RACER_BANK_SELECT_OFFSET))

#define SET_RACER_BANKSELECT(bufNo) {                    \
    if (IS_RACER_VARIANT_PRO16(ppdev))                    \
        {WRITE_GLINT_CTRL_REG (DemonProUBufB, bufNo);}    \
    else                                                \
        {WRITE_GLINT_CTRL_REG (RacerBankSelect, bufNo);}\
}

#define GET_RACER_DOUBLEWRITE(onOffVal) {                \
    if (IS_RACER_VARIANT_PRO16(ppdev)) {                \
        READ_GLINT_CTRL_REG (DemonProDWAndStatus, onOffVal);    \
    }                                                    \
    else                                                \
        {READ_GLINT_CTRL_REG (RacerDoubleWrite, onOffVal);}        \
    onOffVal &= 1 ;                                    \
}

#define SET_RACER_DOUBLEWRITE(onOffVal) {                \
    if (IS_RACER_VARIANT_PRO16(ppdev))                    \
        {WRITE_GLINT_CTRL_REG (DemonProDWAndStatus, (onOffVal & 1));}    \
    else                                                \
        {WRITE_GLINT_CTRL_REG (RacerDoubleWrite, (onOffVal & 1));}    \
}

/***** END OF RACER MACROS ***********/
#define MX_EXTRA_WAIT   1
#define GLINT_MX_SYNC \
{ \
    if (GLINT_MX) \
        /*LD_GLINT_FIFO(__GlintTagFBBlockColor, glintInfo->FBBlockColor); */\
        LD_GLINT_FIFO(__GlintTagSync, 0); \
}
  
// DMAControl register setup, when using AGP DMA (p32 of Gamma HRM).
#define DMA_CONTROL_USE_AGP 0xE 
#define DMA_CONTROL_USE_PCI 0x0 

#if USE_LD_GLINT_FIFO_FUNCTION
#   undef LD_GLINT_FIFO
#   define LD_GLINT_FIFO(t, d)  do { loadGlintFIFO( glintInfo, (ULONG) t, (ULONG) d ); } while(0)

    typedef void (* LoadGlintFIFO)( GlintDataPtr, ULONG, ULONG );
    extern LoadGlintFIFO    loadGlintFIFO;
#endif

#if USE_SYNC_FUNCTION
#   undef SYNC_WITH_GLINT_CHIP
#   undef WAIT_DMA_COMPLETE
#   define SYNC_WITH_GLINT_CHIP     do { syncWithGlint(ppdev, glintInfo); } while(0)
#   define WAIT_DMA_COMPLETE        do { waitDMAcomplete(ppdev, glintInfo); } while(0)

    void syncWithGlint( PPDEV ppdev, GlintDataPtr glintInfo );
    void waitDMAcomplete( PPDEV ppdev, GlintDataPtr glintInfo );
#endif

#define SETUP_PPDEV_OFFSETS(ppdev, pdsurf)                                                    \
do                                                                                          \
{                                                                                            \
    ppdev->DstPixelOrigin = pdsurf->poh->pixOffset;                                            \
    ppdev->DstPixelDelta = pdsurf->poh->lPixDelta;                                            \
    ppdev->xyOffsetDst = MAKEDWORD_XY(pdsurf->poh->x, pdsurf->poh->y);                        \
    ppdev->xOffset = (pdsurf->poh->bDXManaged) ? 0 : pdsurf->poh->x;                        \
    ppdev->bDstOffScreen = pdsurf->bOffScreen;                                                \
                                                                                            \
    if (glintInfo->currentCSbuffer != 0) {                                                    \
        ULONG xAdjust = GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory;                            \
        ppdev->DstPixelOrigin += GLINT_BUFFER_OFFSET(1) - xAdjust;                            \
        ppdev->xOffset += xAdjust;                                                            \
    }                                                                                        \
} while(0);

#define SETUP_PPDEV_SRC_OFFSETS(ppdev, pdsurfSrc)                                            \
do                                                                                          \
{                                                                                            \
    ppdev->SrcPixelOrigin = pdsurfSrc->poh->pixOffset;                                        \
    ppdev->SrcPixelDelta = pdsurfSrc->poh->lPixDelta;                                        \
    ppdev->xyOffsetSrc = MAKEDWORD_XY(pdsurfSrc->poh->x, pdsurfSrc->poh->y);                \
                                                                                            \
    if (glintInfo->currentCSbuffer != 0) {                                                    \
        ULONG xAdjust = GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory;                            \
        ppdev->SrcPixelOrigin += GLINT_BUFFER_OFFSET(1) - xAdjust;                            \
    }                                                                                        \
} while(0)

#define SETUP_PPDEV_SRC_AND_DST_OFFSETS(ppdev, pdsurfSrc, pdsurfDst)                        \
do                                                                                          \
{                                                                                            \
    ppdev->SrcPixelOrigin = pdsurfSrc->poh->pixOffset;                                        \
    ppdev->SrcPixelDelta = pdsurfSrc->poh->lPixDelta;                                        \
    ppdev->xyOffsetSrc = MAKEDWORD_XY(pdsurfSrc->poh->x, pdsurfSrc->poh->y);                \
                                                                                            \
    ppdev->DstPixelOrigin = pdsurfDst->poh->pixOffset;                                        \
    ppdev->DstPixelDelta = pdsurfDst->poh->lPixDelta;                                        \
    ppdev->xyOffsetDst = MAKEDWORD_XY(pdsurfDst->poh->x, pdsurfDst->poh->y);                \
    ppdev->xOffset = (pdsurfDst->poh->bDXManaged) ? 0 : pdsurfDst->poh->x;                    \
    ppdev->bDstOffScreen = pdsurfDst->bOffScreen;                                            \
                                                                                            \
    if (glintInfo->currentCSbuffer != 0) {                                                    \
        ULONG xAdjust = GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory;                            \
        ppdev->DstPixelOrigin += GLINT_BUFFER_OFFSET(1) - xAdjust;                            \
        ppdev->SrcPixelOrigin += GLINT_BUFFER_OFFSET(1) - xAdjust;                            \
        ppdev->xOffset += xAdjust;                                                            \
    }                                                                                        \
} while(0)

#define GET_PPDEV_DST_OFFSETS(ppdev, PixOrigin, PixDelta, xyOffset, xOff, bOffScreen)        \
do                                                                                          \
{                                                                                            \
    PixOrigin = ppdev->DstPixelOrigin;                                                        \
    PixDelta = ppdev->DstPixelDelta;                                                        \
    xyOffset = ppdev->xyOffsetDst;                                                            \
    xOff = ppdev->xOffset;                                                                    \
    bOffScreen = ppdev->bDstOffScreen;                                                        \
} while(0)

#define SET_PPDEV_DST_OFFSETS(ppdev, PixOrigin, PixDelta, xyOffset, xOff, bOffScreen)        \
do                                                                                          \
{                                                                                            \
    ppdev->DstPixelOrigin = PixOrigin;                                                        \
    ppdev->DstPixelDelta = PixDelta;                                                        \
    ppdev->xyOffsetDst = xyOffset;                                                            \
    ppdev->xOffset = xOff;                                                                    \
    ppdev->bDstOffScreen = bOffScreen;                                                        \
} while(0)


#endif  // _GLINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\glntinit.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: glntinit.c
*
* Content: Initialisation for the GLINT chip.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "pxrx.h"

#define  FOUR_MB     (4*1024*1024)

#define  AGP_LONG_READ_DISABLE       (1<<3)    

/******************************Public*Routine******************************\
* VOID vInitCoreRegisters
*
\**************************************************************************/
VOID vInitCoreRegisters(PPDEV ppdev)
{
    ULONG f, b;
    GLINT_DECL;

    if (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE)
    {
        f = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ? 1 : 0;
        b = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) ? 1 : 0;
    }
    else
    {
        f = b = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ? 1 : 0;
    }

    glintInfo->foregroundColour = 0x33BADBAD;
    glintInfo->backgroundColour = 0x33BAAAAD;
    glintInfo->config2D = 0;
    glintInfo->backBufferXY = MAKEDWORD_XY(0, ppdev->cyScreen);        // This is set properly in bInitializeGlint
    glintInfo->frontRightBufferXY = MAKEDWORD_XY(0, ppdev->cyScreen);
    glintInfo->backRightBufferXY = MAKEDWORD_XY(0, ppdev->cyScreen);
    glintInfo->fbDestMode = (1 << 8) | (1 << 1) | (f << 12) | (b << 14);
    if (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE)
    {
        glintInfo->fbDestMode |= (b << 16) | (f << 18);
    }
    glintInfo->fbDestAddr[0] = 0x00000000;
    glintInfo->fbDestAddr[1] = 0x00000000;
    glintInfo->fbDestAddr[2] = 0x00000000;
    glintInfo->fbDestAddr[3] = 0x00000000;
    glintInfo->fbDestWidth[0] = ppdev->cxMemory;
    glintInfo->fbDestWidth[1] = ppdev->cxMemory;
    glintInfo->fbDestWidth[2] = ppdev->cxMemory;
    glintInfo->fbDestWidth[3] = ppdev->cxMemory;
    glintInfo->fbDestOffset[0] = 0;
    glintInfo->fbDestOffset[1] = 0;
    glintInfo->fbDestOffset[2] = 0;
    glintInfo->fbDestOffset[3] = 0;
    glintInfo->fbWriteAddr[0] = 0x00000000;
    glintInfo->fbWriteAddr[1] = 0x00000000;
    glintInfo->fbWriteAddr[2] = 0x00000000;
    glintInfo->fbWriteAddr[3] = 0x00000000;
    glintInfo->fbWriteWidth[0] = ppdev->cxMemory;
    glintInfo->fbWriteWidth[1] = ppdev->cxMemory;
    glintInfo->fbWriteWidth[2] = ppdev->cxMemory;
    glintInfo->fbWriteWidth[3] = ppdev->cxMemory;
    glintInfo->fbWriteOffset[0] = 0;
    glintInfo->fbWriteOffset[1] = 0;
    glintInfo->fbWriteOffset[2] = 0;
    glintInfo->fbWriteOffset[3] = 0;
    glintInfo->fbSourceAddr = 0x00000000;
    glintInfo->fbSourceWidth = ppdev->cxMemory;
    glintInfo->fbSourceOffset = 0;
    glintInfo->lutMode = 0;
    glintInfo->lastLine = 0;
    glintInfo->render2Dpatching = 0;

    pxrxSetupDualWrites_Patching(ppdev);
    pxrxRestore2DContext(ppdev, TRUE);

    // Set the cache flag to say that there is no cache info
    ppdev->cFlags = 0;
    
} // vInitCoreRegisters

/******************************Public*Routine******************************\
* BOOL bAllocateGlintInfo
*
* Allocate ppdev->glintInfo and initialise the board info. We need to do
* this as early as possible because we're getting to the point where we
* need to know the board type very early.
\**************************************************************************/

BOOL bAllocateGlintInfo(PPDEV ppdev)
{
    GlintDataPtr glintInfo;
    ULONG        Length; 

    // Allocate and initialize ppdev->glintInfo. 
    // We store GLINT specific stuff in this structure.

    glintInfo = (PVOID)ENGALLOCMEM(FL_ZERO_MEMORY, 
                                   sizeof(GlintDataRec), 
                                   ALLOC_TAG_GDI(A));
    if (glintInfo == NULL)
    {
        DISPDBG((ERRLVL, "cannot allocate memory for glintInfo struct"));
        return(FALSE);
    }
    
    glintInfo->bGlintCoreBusy = TRUE;
    ppdev->glintInfo = (PVOID)glintInfo;

    // retrieve the PCI configuration information and local buffer size
    Length = sizeof(Glint_Device_Info);

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_DEVICE_INFO,
                         NULL,
                         0,
                         (PVOID)&(glintInfo->deviceInfo),
                         Length,
                         &Length))
    {
        DISPDBG((ERRLVL, "QUERY_DEVICE_INFO failed."));
        return(FALSE);
    }

    return(TRUE);
    
} // bAllocateGlintInfo

/******************************Public*Routine******************************\
* BOOL bInitializeGlint
*
* Called to load the initial values into the chip. We assume the hardware
* has been mapped. All the relevant stuff should be hanging off ppdev. We
* also sort out all the GLINT capabilities etc.
\**************************************************************************/

BOOL bInitializeGlint(PPDEV ppdev)
{
    pGlintControlRegMap pCtrlRegs;
    pGlintControlRegMap pCtrlRegsVTG;
    pGlintControlRegMap pCtrlRegsOdd;
    pGlintCoreRegMap    pCoreRegs;
    pGlintCoreRegMap    pCoreRegsRd;
    pGlintCoreRegMap    pCoreRegsOdd;
    DSURF*  pdsurf;
    OH      *poh = NULL;
    LONG    cPelSize;
    LONG    cx, cy;
    LONG    i, j;
    ULONG   width;
    ULONG   ulValue;
    BOOL    bExists;
    BOOL    bCreateBackBuffer;
    BOOL    bCreateStereoBuffers;
    ULONG   Length;
    LONG    FinalTag;
    GLINT_DECL;

    DISPDBG((DBGLVL, "bInitializeGlint: fbsize: 0x%x", ppdev->FrameBufferLength));

    glintInfo->ddCtxtId = -1; // initialize to no context
    glintInfo->LineDMABuffer.virtAddr = 0;    // Initialise these values
    glintInfo->LineDMABuffer.size = 0;
    glintInfo->PXRXDMABuffer.virtAddr = 0;
    glintInfo->PXRXDMABuffer.size = 0;
    ppdev->DMABuffer.pphysStart.HighPart = 0;
    ppdev->DMABuffer.pphysStart.LowPart = 0;
    ppdev->DMABuffer.cb = 0;
    ppdev->DMABuffer.pulStart = NULL;
    ppdev->DMABuffer.pulCurrent = NULL;
    ppdev->DMABuffer.pulEnd = NULL;

    Length = sizeof(GENERAL_DMA_BUFFER);
    ulValue = 1;
    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER,
                         &ulValue,
                         sizeof(ulValue),
                         (PVOID)&(glintInfo->LineDMABuffer),
                         Length,
                         &Length))
    {
        DISPDBG((ERRLVL, "QUERY_LINE_DMA_BUFFER failed."));
        DISPDBG((ERRLVL, "FATAL ERROR: DRIVER REQUIRES DMA BUFFER FOR 2D"
                         " - UNLOADING DRIVER"));
        return(FALSE);
    }

    bExists = bGlintQueryRegistryValueUlong( ppdev, L"PXRX.DisableDMA", &i );

    if ((bExists && !i) || !bExists)
    {
        Length = sizeof(GENERAL_DMA_BUFFER);
        ulValue = 2;
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER,
                               &ulValue,
                               sizeof(ulValue),
                               (PVOID) &glintInfo->PXRXDMABuffer,
                               Length,
                               &Length))
        {
            DISPDBG((DBGLVL, "QUERY_DMA_BUFFER failed for the PXRX buffer."));
            return FALSE;
        }

        DISPDBG((DBGLVL, "QUERY_DMA_BUFFER(PxRx): P:0x%X:%08X, V:0x%08X, S:%dKb, %s",
                 glintInfo->PXRXDMABuffer.physAddr.HighPart, glintInfo->PXRXDMABuffer.physAddr.LowPart,
                 glintInfo->PXRXDMABuffer.virtAddr, glintInfo->PXRXDMABuffer.size / 1024,
                 glintInfo->PXRXDMABuffer.cacheEnabled ? "Cached" : "Uncached"));
    }
#if DBG
    else
    {
        GENERAL_DMA_BUFFER  dmaBuff;

        Length = sizeof(GENERAL_DMA_BUFFER);
        ulValue = 2;
        if( EngDeviceIoControl(ppdev->hDriver, IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER,
                               &ulValue, sizeof(ulValue), (PVOID) &dmaBuff,
                               Length, &Length) ) {
            DISPDBG((ERRLVL, "QUERY_DMA_BUFFER failed for the PXRX buffer."));
            return FALSE;
        }

        DISPDBG((DBGLVL, "QUERY_DMA_BUFFER(???): P:0x%X:%08X, V:0x%08X, S:%dKb, %s",
                 dmaBuff.physAddr.HighPart, dmaBuff.physAddr.LowPart, dmaBuff.virtAddr, dmaBuff.size / 1024,
                 dmaBuff.cacheEnabled ? "Cached" : "Uncached"));
    }
#endif

//@@BEGIN_DDKSPLIT
    // TMM: Temporary until we fix s/w cursors. Disable s/w cursor.
    ppdev->flStatus &= ~ENABLE_POINTER_CACHE;
//@@END_DDKSPLIT

    // Clear the patching flags to begin with
    glintInfo->pxrxFlags &= ~(PXRX_FLAGS_PATCHING_FRONT | PXRX_FLAGS_PATCHING_BACK);

    // the 2D driver can use the line buffer for other things as well, such as for text rendering
    ppdev->DMABuffer.pphysStart = glintInfo->LineDMABuffer.physAddr;
    ppdev->DMABuffer.cb = glintInfo->LineDMABuffer.size;
    ppdev->DMABuffer.pulStart = glintInfo->LineDMABuffer.virtAddr;
    ppdev->DMABuffer.pulCurrent = glintInfo->LineDMABuffer.virtAddr;
    ppdev->DMABuffer.pulEnd = ppdev->DMABuffer.pulStart + glintInfo->LineDMABuffer.size - 1;

    // set-up the DMA board status - we'll program the registers later
    ppdev->g_GlintBoardStatus = GLINT_DMA_COMPLETE;

    // Init whether or not GDI is allowed to access framebuffer.
    // This must be a variable as it is affected by overlays.

    glintInfo->GdiCantAccessFramebuffer = ((ppdev->flCaps & CAPS_SPARSE_SPACE) == CAPS_SPARSE_SPACE);

    DISPDBG((WRNLVL, "deviceInfo: GdiCantAccessFramebuffer %d", glintInfo->GdiCantAccessFramebuffer)); 

    DISPDBG((WRNLVL, "deviceInfo: VendorId: 0x%x, DevId 0x%x, GammaId 0x%x, RevId %d, SubId %d, SubVId %d, lbuf len 0x%x, lbuf width %d", 
                    glintInfo->deviceInfo.VendorId,
                    glintInfo->deviceInfo.DeviceId,
                    glintInfo->deviceInfo.GammaRevId,
                    glintInfo->deviceInfo.RevisionId,
                    glintInfo->deviceInfo.SubsystemId,
                    glintInfo->deviceInfo.SubsystemVendorId,
                    glintInfo->deviceInfo.LocalbufferLength,
                    glintInfo->deviceInfo.LocalbufferWidth));

    // collect flags as we initialize so zero it here
    glintInfo->flags = 0;


//@@BEGIN_DDKSPLIT
#if 0
    // Try to establish color space double buffering. The actual method
    // depends on the RAMDAC so call the appropriate routine depending on
    // the one we support.
    //
    bExists = ppdev->pgfnPointerCheckCSBuffering(ppdev);
    if (bExists)
    {
        glintInfo->flags |= GLICAP_COLOR_SPACE_DBL_BUF;
    }
#endif
//@@END_DDKSPLIT

    // optional DrvCopyBits acceleration for downloads
    ppdev->pgfnCopyXferImage    = NULL;
    ppdev->pgfnCopyXfer24bpp    = NULL;
    ppdev->pgfnCopyXfer16bpp    = NULL;
    ppdev->pgfnCopyXfer8bppLge  = NULL;
    ppdev->pgfnCopyXfer8bpp     = NULL;
    ppdev->pgfnCopyXfer4bpp     = NULL;

    // optional NT5 acceleration functions
#if(_WIN32_WINNT >= 0x500)
    ppdev->pgfnGradientFillRect = NULL;
    ppdev->pgfnTransparentBlt = NULL;
    ppdev->pgfnAlphaBlend = NULL;
#endif

//@@BEGIN_DDKSPLIT
    // if we're simulating from boot-up then it's OK to use our preferred text method
    // HIDEYUKN, temporary disable host memory cache, until figure out more detail.
    // ppdev->PreferredGlyphRenderingMethod = GLYPH_HOSTMEM_CACHE;
//@@END_DDKSPLIT

    glintInfo->usePXRXdma = USE_PXRX_DMA_FIFO;
    pxrxSetupFunctionPointers( ppdev );

    // Do the translates for all the GLINT registers we use. For dual-TX
    // pCoreRegs points at core registers through Delta
    // pCtrlRegs points at Delta
    // pCtrlRegsVTG points at the TX with the RAMDAC
    // pCtrlRegsOdd points at the non-VTG TX (odd owned scanlines for 3D)
    //
    pCtrlRegs    =
    pCtrlRegsVTG = (pGlintControlRegMap)ppdev->pulCtrlBase[0];
    pCtrlRegsOdd = (pGlintControlRegMap)ppdev->pulCtrlBase[1];
    pCoreRegs    = &(pCtrlRegs->coreRegs);
    pCoreRegsOdd = &(pCtrlRegsOdd->coreRegs);
    pCoreRegsRd  = &(pCtrlRegsVTG->coreRegs);
    glintInfo->BroadcastMask2D = DELTA_BROADCAST_TO_CHIP(0);
    glintInfo->BroadcastMask3D = DELTA_BROADCAST_TO_BOTH_CHIPS;

    if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
    {
        glintInfo->BroadcastMask2D = DELTA_BROADCAST_TO_BOTH_CHIPS;
        pCtrlRegsVTG = (pGlintControlRegMap)ppdev->pulCtrlBase[1];
    }

    ppdev->pulRamdacBase = (PVOID)&(pCtrlRegsVTG->ExternalVideo);

    // FIFO registers. Translate all possible tags
    FinalTag = __MaximumGlintTagValue;

    // record the maximum number if free FIFO entries

    if( GLINT_GAMMA_PRESENT ) {
        glintInfo->MaxInFifoEntries = MAX_GAMMA_FIFO_ENTRIES;
    } else {
        glintInfo->MaxInFifoEntries = MAX_P3_FIFO_ENTRIES;
    }

    // Chip tags may be read/written from different address spaces
    for (i = 0; i < __DeltaTagV0Fixed0; ++i)
    {
        glintInfo->regs.tagwr[i] =
                    TRANSLATE_ADDR(&(pCoreRegs->tag[i]));
        glintInfo->regs.tagrd[i] =
                    TRANSLATE_ADDR(&(pCoreRegsRd->tag[i]));
    }
    // Delta tags are read/written from the same address space
    for (i = __DeltaTagV0Fixed0; i <= FinalTag; ++i)
    {
        glintInfo->regs.tagwr[i] =
                    TRANSLATE_ADDR(&(pCoreRegs->tag[i]));
        glintInfo->regs.tagrd[i] =
                    TRANSLATE_ADDR(&(pCoreRegs->tag[i]));
    }

    // non-FIFO control registers
    
    glintInfo->regs.LBMemoryCtl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->LBMemoryCtl));
    glintInfo->regs.LBMemoryEDO =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->LBMemoryEDO));
    glintInfo->regs.FBMemoryCtl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->FBMemoryCtl));
    glintInfo->regs.FBModeSel =
                    TRANSLATE_ADDR(&(pCtrlRegs->FBModeSel));
    glintInfo->regs.FBModeSelOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->FBModeSel));
    glintInfo->regs.VTGHLimit =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHLimit));
    glintInfo->regs.VTGHSyncStart =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHSyncStart));
    glintInfo->regs.VTGHSyncEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHSyncEnd));
    glintInfo->regs.VTGHBlankEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHBlankEnd));
    glintInfo->regs.VTGHGateStart =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHGateStart));
    glintInfo->regs.VTGHGateEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGHGateEnd));
    glintInfo->regs.VTGVLimit =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVLimit));
    glintInfo->regs.VTGVSyncStart =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVSyncStart));
    glintInfo->regs.VTGVSyncEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVSyncEnd));
    glintInfo->regs.VTGVBlankEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVBlankEnd));
    glintInfo->regs.VTGVGateStart =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVGateStart));
    glintInfo->regs.VTGVGateEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVGateEnd));
    glintInfo->regs.VTGPolarity =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGPolarity));
    glintInfo->regs.VTGVLineNumber =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VTGVLineNumber));
    glintInfo->regs.VTGFrameRowAddr =
                    TRANSLATE_ADDR(&(pCtrlRegs->VTGFrameRowAddr));
    glintInfo->regs.VTGFrameRowAddrOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->VTGFrameRowAddr));
    glintInfo->regs.InFIFOSpace =
                    TRANSLATE_ADDR(&(pCtrlRegs->InFIFOSpace));
    glintInfo->regs.OutFIFOWords =
                    TRANSLATE_ADDR(&(pCtrlRegs->OutFIFOWords));
    glintInfo->regs.OutFIFOWordsOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->OutFIFOWords));
    glintInfo->regs.DMAAddress =
                    TRANSLATE_ADDR(&(pCtrlRegs->DMAAddress));
    glintInfo->regs.DMACount =
                    TRANSLATE_ADDR(&(pCtrlRegs->DMACount));
    glintInfo->regs.InFIFOInterface =
                    TRANSLATE_ADDR(&(pCtrlRegs->FIFOInterface));
    glintInfo->regs.OutFIFOInterface =
                    TRANSLATE_ADDR(&(pCtrlRegs->FIFOInterface));
    glintInfo->regs.OutFIFOInterfaceOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->FIFOInterface));
    glintInfo->regs.IntFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->IntFlags));
    glintInfo->regs.IntEnable =
                    TRANSLATE_ADDR(&(pCtrlRegs->IntEnable));
    glintInfo->regs.ResetStatus =
                    TRANSLATE_ADDR(&(pCtrlRegs->ResetStatus));
    glintInfo->regs.ErrorFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->ErrorFlags));        
    glintInfo->regs.DeltaIntFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->DeltaIntFlags));
    glintInfo->regs.DeltaIntEnable =
                    TRANSLATE_ADDR(&(pCtrlRegs->DeltaIntEnable));
    glintInfo->regs.DeltaErrorFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->DeltaErrorFlags));        
    glintInfo->regs.ScreenBase =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->ScreenBase));
    glintInfo->regs.ScreenBaseRight =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->ScreenBaseRight));
    glintInfo->regs.LineCount =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->LineCount));
    glintInfo->regs.VbEnd =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VbEnd));
    glintInfo->regs.VideoControl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VideoControl));
    glintInfo->regs.MemControl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->MemControl));
    glintInfo->regs.VTGSerialClk =
                    TRANSLATE_ADDR(&(pCtrlRegs->VTGSerialClk));
    glintInfo->regs.VTGSerialClkOdd =
                    TRANSLATE_ADDR(&(pCtrlRegsOdd->VTGSerialClk));
    glintInfo->regs.VClkCtl =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->VClkCtl));
    glintInfo->regs.RacerDoubleWrite =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->RacerDoubleWrite));
    glintInfo->regs.RacerBankSelect =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->RacerBankSelect));
//@@BEGIN_DDKSPLIT
    // TMM: Add support for Omnicomp 3Demon Pro16
//@@END_DDKSPLIT
    glintInfo->regs.DemonProDWAndStatus =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->DemonProDWAndStatus));
    glintInfo->regs.DemonProUBufB =
                    TRANSLATE_ADDR(&(pCtrlRegsVTG->DemonProUBufB));
    glintInfo->regs.DisconnectControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->DisconnectControl));

    // The following regs are P2 only - but it should be safe to calculate them for
    // any chipset
    glintInfo->regs.OutDMAAddress =
                    TRANSLATE_ADDR(&(pCtrlRegs->OutDMAAddress));
    glintInfo->regs.OutDMACount =
                    TRANSLATE_ADDR(&(pCtrlRegs->OutDMACount));
    glintInfo->regs.DMAControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->DMAControl));
    glintInfo->regs.AGPControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->AGPControl));
    glintInfo->regs.ByDMAAddress =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAAddress));
    glintInfo->regs.ByDMAStride =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAStride));
    glintInfo->regs.ByDMAMemAddr =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAMemAddr));
    glintInfo->regs.ByDMASize =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMASize));
    glintInfo->regs.ByDMAByteMask =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAByteMask));
    glintInfo->regs.ByDMAControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAControl));
    glintInfo->regs.ByDMAComplete =
                    TRANSLATE_ADDR(&(pCtrlRegs->ByDMAComplete));
    glintInfo->regs.VSConfiguration =
                    TRANSLATE_ADDR(&(pCtrlRegs->VSConfiguration));
    glintInfo->regs.TextureDownloadControl =
                    TRANSLATE_ADDR(&(pCtrlRegs->TextureDownloadControl));
    glintInfo->regs.LocalMemCaps =
                    TRANSLATE_ADDR(&(pCtrlRegs->LocalMemCaps));
    glintInfo->regs.MemScratch =
                    TRANSLATE_ADDR(&(pCtrlRegs->MemScratch));

    // The following regs are Gamma only - but it should be safe to calculate them for
    // any chipset
    glintInfo->regs.GammaCommandMode =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandMode));
    glintInfo->regs.GammaCommandIntEnable =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandIntEnable));
    glintInfo->regs.GammaCommandIntFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandIntFlags));
    glintInfo->regs.GammaCommandErrorFlags =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandErrorFlags));
    glintInfo->regs.GammaCommandStatus =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaCommandStatus));
    glintInfo->regs.GammaFeedbackSelectCount =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaFeedbackSelectCount));
    glintInfo->regs.GammaProcessorMode =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaProcessorMode));
    glintInfo->regs.GammaChipConfig =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaChipConfig));
    glintInfo->regs.GammaMultiGLINTAperture =
                    TRANSLATE_ADDR(&(pCtrlRegs->GammaMultiGLINTAperture));

    // PXRX only bypass stuff:
    glintInfo->regs.PXRXByAperture1Mode = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByAperture1Mode) );
    glintInfo->regs.PXRXByAperture1Stride = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByAperture1Stride) );
    //glintInfo->regs.PXRXByAperture1YStart
    //glintInfo->regs.PXRXByAperture1UStart
    //glintInfo->regs.PXRXByAperture1VStart
    glintInfo->regs.PXRXByAperture2Mode = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByAperture2Mode) );
    glintInfo->regs.PXRXByAperture2Stride = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByAperture2Stride) );
    //glintInfo->regs.PXRXByAperture2YStart
    //glintInfo->regs.PXRXByAperture2UStart
    //glintInfo->regs.PXRXByAperture2VStart
    glintInfo->regs.PXRXByDMAReadMode = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByDMAReadMode) );
    glintInfo->regs.PXRXByDMAReadStride = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByDMAReadStride) );
    //glintInfo->regs.PXRXByDMAReadYStart
    //glintInfo->regs.PXRXByDMAReadUStart
    //glintInfo->regs.PXRXByDMAReadVStart
    glintInfo->regs.PXRXByDMAReadCommandBase = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByDMAReadCommandBase) );
    glintInfo->regs.PXRXByDMAReadCommandCount = TRANSLATE_ADDR( &(pCtrlRegs->PXRXByDMAReadCommandCount) );
    //glintInfo->regs.PXRXByDMAWriteMode
    //glintInfo->regs.PXRXByDMAWriteStride
    //glintInfo->regs.PXRXByDMAWriteYStart
    //glintInfo->regs.PXRXByDMAWriteUStart
    //glintInfo->regs.PXRXByDMAWriteVStart
    //glintInfo->regs.PXRXByDMAWriteCommandBase
    //glintInfo->regs.PXRXByDMAWriteCommandCount

    // Debug/profile registers on a P3.
    glintInfo->regs.TestOutputRdy           = TRANSLATE_ADDR( &(pCtrlRegs->TestOutputRdy) );
    glintInfo->regs.TestInputRdy            = TRANSLATE_ADDR( &(pCtrlRegs->TestInputRdy) );
    glintInfo->regs.LocalMemProfileMask0    = TRANSLATE_ADDR( &(pCtrlRegs->LocalMemProfileMask0) );
    glintInfo->regs.LocalMemProfileMask1    = TRANSLATE_ADDR( &(pCtrlRegs->LocalMemProfileMask1) );
    glintInfo->regs.LocalMemProfileCount0   = TRANSLATE_ADDR( &(pCtrlRegs->LocalMemProfileCount0) );
    glintInfo->regs.LocalMemProfileCount1   = TRANSLATE_ADDR( &(pCtrlRegs->BootAddress) );

    // initialize the overlay to be disabled
    glintInfo->OverlayMode = GLINT_DISABLE_OVERLAY;
    glintInfo->WriteMask = 0xffffffff;
    glintInfo->DefaultWriteMask = 0xffffffff;

//@@BEGIN_DDKSPLIT
    // TMM: On ELSA Gloria Gamma boards with 640 RAMDACs at 15BPP, bit 15 is used
    // by the RAMDAC to select a different LUT. So we have to mask
    // the top bit out when writing to the framebuffer.
//@@END_DDKSPLIT
    if (glintInfo->deviceInfo.ActualDacId == RGB640_RAMDAC &&
        ppdev->cPelSize == GLINTDEPTH16)
    {
        glintInfo->DefaultWriteMask = 0x7FFF7FFF;
        glintInfo->WriteMask = 0x7FFF7FFF;
    }

    // Initialise current FIFO count
    glintInfo->FifoCnt = 0;

//@@BEGIN_DDKSPLIT
#if 0 // HIDEYUKN
    //
    // If we have a gamma ramp saved in the registry then use that. Otherwise,
    // initialize the LUT with a gamma of 1.0
    //
    if (!bGlintRegistryRetrieveGammaLUT(ppdev, &glintInfo->gammaLUT) ||
        !bInstallGammaLUT(ppdev, &glintInfo->gammaLUT, FALSE))
    {
        vSetNewGammaValue(ppdev, 0x10000, FALSE);
    }
#endif
//@@END_DDKSPLIT

    //
    // initialize our DMA buffers if any are configured
    // 
    vGlintInitializeDMA(ppdev);

    // fill in the glintInfo capability flags and block fill size.
    //
    glintInfo->flags |= GLICAP_NT_CONFORMANT_LINES;
    glintInfo->fastFillSupport = 0;
    glintInfo->renderFastFill = 0;
    glintInfo->fastFillBlockSz = 0;

    {
        ULONG DMAMemoryControl = 0;

        DMAMemoryControl |= 1 << 2;                    // align host-in DMA to 64 bit boundaries
        DMAMemoryControl |= (0 & 0x1f) << 24;        // burst size n == (1 << 7+n)? Spec indicates n * 128
        DMAMemoryControl |= 1 << 31;                // align host-out DMA to 64 bit boundaries

        if( ppdev->flCaps & CAPS_USE_AGP_DMA ) 
            DMAMemoryControl |= 1 << 0;                // host-in DMA uses AGP

        WAIT_GLINT_FIFO(1);
        LD_GLINT_FIFO(__GlintTagDMAMemoryControl, DMAMemoryControl);
    }

    {
        ULONG   *dmaVirt = glintInfo->PXRXDMABuffer.virtAddr;
        ULONG   dmaPhys = (ULONG) glintInfo->PXRXDMABuffer.physAddr.LowPart;
        ULONG   size = (glintInfo->PXRXDMABuffer.size) / sizeof(ULONG);

        DISPDBG((DBGLVL, "PXRX_DMA: allocated: 0x%08X + 0x%08X @ 0x%08X",
                 glintInfo->PXRXDMABuffer.virtAddr, glintInfo->PXRXDMABuffer.size, glintInfo->PXRXDMABuffer.physAddr));

        if ((glintInfo->PXRXDMABuffer.virtAddr == 0) ||
            (glintInfo->PXRXDMABuffer.size == 0 ) ||
            (glintInfo->PXRXDMABuffer.physAddr.LowPart == 0))
        {

            DISPDBG((DBGLVL, "PXRX_DMA: Physical buffer allocation has failed, using a virtual buffer..."));

            size = 256 * 1024;
            dmaVirt = (ULONG *) ENGALLOCMEM(FL_ZERO_MEMORY, 
                                            size * sizeof(ULONG), 
                                            ALLOC_TAG_GDI(B));
            if (NULL == dmaVirt)
            {
                DISPDBG((-1, "FATAL ERROR: DRIVER REQUIRES DMA BUFFER FOR 2D - UNLOADING DRIVER"));
                return(FALSE);
            }

            glintInfo->PXRXDMABuffer.size = size;
            glintInfo->PXRXDMABuffer.virtAddr = dmaVirt;
            glintInfo->PXRXDMABuffer.physAddr.LowPart = 0;
            glintInfo->PXRXDMABuffer.physAddr.HighPart = 0;
            glintInfo->usePXRXdma = USE_PXRX_DMA_FIFO;
            pxrxSetupFunctionPointers( ppdev );
        }

        ASSERTDD( glintInfo->PXRXDMABuffer.virtAddr != 0, "PXRX_DMA: The buffer has no virtual address!" );
        ASSERTDD( glintInfo->PXRXDMABuffer.size != 0,     "PXRX_DMA: The buffer has a zero size!" );

#       if PXRX_DMA_BUFFER_CHECK
        {
            ULONG   protSize = PXRX_DMA_BUFFER_CHECK_SIZE;
            ULONG   buffSize = (size - (protSize * 3)) / 2;
            ULONG   *ptr;
            /*
                  0k -  16k = 16k = protection zone 0
                 16k -  56k = (size - (16 * 3)) / 2 = buffer 0
                 56k -  72k = 16k = protection zone 1
                 72k - 112k = (size - (16 * 3)) / 2 = buffer 1
                112k - 128k = 16k = protection zone 2
            */
            glintInfo->pxrxDMA_bufferBase = dmaVirt;
            glintInfo->pxrxDMA_bufferTop  = &dmaVirt[size];

            gi_pxrxDMA.DMAaddrL[0]        = &dmaVirt[protSize];
            gi_pxrxDMA.DMAaddrEndL[0]    = gi_pxrxDMA.DMAaddrL[0]    + buffSize;
            gi_pxrxDMA.DMAaddrL[1]        = gi_pxrxDMA.DMAaddrEndL[0] + protSize;
            gi_pxrxDMA.DMAaddrEndL[1]    = gi_pxrxDMA.DMAaddrL[1]    + buffSize;

            for( ptr = dmaVirt; ptr < glintInfo->pxrxDMA_bufferTop; ptr++ )
                *ptr = (ULONG)(((ULONG_PTR) ptr) & 0x0FFFFFF0);

            DISPDBG((DBGLVL, "PXRX_DMA: prot 0   = 0x%08X -> 0x%08X", glintInfo->pxrxDMA_bufferBase, gi_pxrxDMA.DMAaddrL[0]));
            DISPDBG((DBGLVL, "PXRX_DMA: buffer 0 = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrL[0],     gi_pxrxDMA.DMAaddrEndL[0]));
            DISPDBG((DBGLVL, "PXRX_DMA: prot 1   = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrEndL[0],  gi_pxrxDMA.DMAaddrL[1]));
            DISPDBG((DBGLVL, "PXRX_DMA: buffer 1 = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrL[1],     gi_pxrxDMA.DMAaddrEndL[1]));
            DISPDBG((DBGLVL, "PXRX_DMA: prot 2   = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrEndL[1],  glintInfo->pxrxDMA_bufferTop));
        }
#       else    // PXRX_DMA_BUFFER_CHECK
            gi_pxrxDMA.DMAaddrL[0]      =  dmaVirt;
            gi_pxrxDMA.DMAaddrL[1]      = &dmaVirt[ size / 2 ];
            gi_pxrxDMA.DMAaddrEndL[0] = &dmaVirt[(size / 2) - 1];
            gi_pxrxDMA.DMAaddrEndL[1] = &dmaVirt[ size      - 1];
#       endif   // PXRX_DMA_BUFFER_CHECK

        gi_pxrxDMA.NTbuff   = 0;
        gi_pxrxDMA.NTptr    = gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff];
        gi_pxrxDMA.NTdone   = gi_pxrxDMA.NTptr;
        gi_pxrxDMA.P3at     = gi_pxrxDMA.NTptr;
#if PXRX_DMA_BUFFER_CHECK
        glintInfo->NTwait   = gi_pxrxDMA.NTptr;
#endif

        gi_pxrxDMA.DMAaddrP[0]      = dmaPhys + (DWORD)((UINT_PTR) gi_pxrxDMA.DMAaddrL[0]    - (UINT_PTR) dmaVirt);
        gi_pxrxDMA.DMAaddrP[1]      = dmaPhys + (DWORD)((UINT_PTR) gi_pxrxDMA.DMAaddrL[1]    - (UINT_PTR) dmaVirt);
        gi_pxrxDMA.DMAaddrEndP[0] = dmaPhys + (DWORD)((UINT_PTR) gi_pxrxDMA.DMAaddrEndL[0] - (UINT_PTR) dmaVirt);
        gi_pxrxDMA.DMAaddrEndP[1] = dmaPhys + (DWORD)((UINT_PTR) gi_pxrxDMA.DMAaddrEndL[1] - (UINT_PTR) dmaVirt);

        DISPDBG((DBGLVL, "PXRX_DMA: buffer 0 = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrL[0], gi_pxrxDMA.DMAaddrEndL[0]));
        DISPDBG((DBGLVL, "PXRX_DMA: buffer 1 = 0x%08X -> 0x%08X", gi_pxrxDMA.DMAaddrL[1], gi_pxrxDMA.DMAaddrEndL[1]));

#if PXRX_DMA_BUFFER_CHECK
        {
            extern ULONG inPxRxContextSwitch;
            inPxRxContextSwitch = TRUE;
            CHECK_PXRX_DMA_VALIDITY( CHECK_SWITCH, 0 );
            inPxRxContextSwitch = FALSE;
        }
#endif
    }

    // Allocate a GLINT context for this PDEV. Save the current context
    // if any and make us the current one but do this by hand since our
    // software copy will be junk if this is the very first PDEV.
    //
    DISPDBG((DBGLVL, "allocating new context"));

    // Create the 2D context:
    glintInfo->ddCtxtId = GlintAllocateNewContext(ppdev,
                                                  (ULONG *) pxrxRestore2DContext,
                                                  0, 0, NULL, ContextType_Fixed);

    if (glintInfo->ddCtxtId < 0)
    {
        DISPDBG((ERRLVL, "failed to allocate GLINT context for display driver"));
        return(FALSE);
    }

    DISPDBG((DBGLVL, "got context id 0x%x", glintInfo->ddCtxtId));

    GLINT_VALIDATE_CONTEXT(-1);
    ppdev->currentCtxt = glintInfo->ddCtxtId;

    DISPDBG((DBGLVL, "context id 0x%x is now current", glintInfo->ddCtxtId));

    if (ppdev->flCaps & CAPS_QUEUED_DMA)
    {
        DISPDBG((DBGLVL, "Enabling queued DMA for Gamma - initializing control regs"));

        READ_GLINT_CTRL_REG(GammaCommandMode, ulValue);
        ulValue |= GAMMA_COMMAND_MODE_QUEUED_DMA;
        WRITE_GLINT_CTRL_REG(GammaCommandMode, ulValue);
    }

    if( GLINT_GAMMA_PRESENT ) 
    {
        //
        // The disconnect should be setup correctly in the miniport. 
        // 

        glintInfo->PCIDiscEnabled = FALSE;

    } else {
 
        // Configure PCI disconnect
        //
        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            glintInfo->PCIDiscEnabled = FALSE;
        }
        else
        {
            glintInfo->PCIDiscEnabled = USE_PCI_DISC_PERM;
        }

        // Enable/Disable PCI disconnect as required
        WRITE_GLINT_CTRL_REG(DisconnectControl, 
                             (glintInfo->PCIDiscEnabled ? DISCONNECT_INPUT_FIFO_ENABLE : 
                                                      DISCONNECT_INOUT_DISABLE));
    }

    // We only want to check the FIFO if disconnect is disabled.
    glintInfo->CheckFIFO = !glintInfo->PCIDiscEnabled;

    // Setup DMA control on GMX or PXRX
    {
        ULONG DMAControl = DMA_CONTROL_USE_PCI;

        if (!(ppdev->flCaps & CAPS_USE_AGP_DMA))
        {
            DMAControl = DMA_CONTROL_USE_PCI;                // AGP not enabled use PCI master DMA
        }
        else
        {
            DMAControl = 2;                                    // PXRX: use AGP master DMA
            // When using AGP SideBandAddressing, the following tweak should be a performance gain
            WRITE_GLINT_CTRL_REG (AGPControl, AGP_LONG_READ_DISABLE );
        }
        // Write DMA control
        WRITE_GLINT_CTRL_REG (DMAControl, DMAControl);
    }

    // there are many mode registers we never use so we must disable them.
    //
    vInitCoreRegisters(ppdev);

    ulValue = 32;

    DISPDBG((DBGLVL, "Using block fill of width %d pixels", ulValue));
    glintInfo->fastFillBlockSz = ulValue;
    glintInfo->fastFillSupport = __RENDER_FAST_FILL_INC(ulValue);
    glintInfo->renderFastFill  = __RENDER_FAST_FILL_ENABLE |
                                 __RENDER_FAST_FILL_INC(ulValue);

    // On a Geo Twin we disable the pointer cache and brush cache.
    // and on a delta-based Geo Twin we disable off-screen bitmaps too, 
    // because they slow things down.

    if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
    {
        // Gamma boards can have off-screen bitmaps, because Gamma has 
        // something called the multi-glint aperture.
        if (GLINT_DELTA_PRESENT)
            ppdev->flStatus &= ~(STAT_DEV_BITMAPS | ENABLE_DEV_BITMAPS);

//@@BEGIN_DDKSPLIT
    //  ppdev->flStatus &= ~(ENABLE_POINTER_CACHE);
    //  ppdev->flStatus &= ~(ENABLE_BRUSH_CACHE);
    //  ppdev->flStatus &= ~(ENABLE_GLYPH_CACHE);
//@@END_DDKSPLIT
    }

    // initially assume that we do not have an off-screen buffer for
    // bitblt and full screen double buffering. So set all buffer offsets
    // to zero. This may get overriden when we init the off-screen heap.
    //
    for (i = 0; i < GLINT_NUM_SCREEN_BUFFERS; ++i)
    {
        glintInfo->bufferOffset[i] = 0;
        glintInfo->bufferRow[i]    = 0;
    }

    // Initialise back-buffer POH
    glintInfo->backBufferPoh = NULL;
    glintInfo->GMX2KLastLine = 0;

    // Work out our double buffering requirements. First read the registry to
    // find out if we need an off-screen buffer. If not then we have nothing
    // to do. We want an off-screen buffer if the string exists and the
    // buffer count is >= 2. For the moment values > 2 mean use two buffers.
    // i.e. we don't support triple or quad buffering etc.
    // Note, for GLINT we assume that the extra buffer always lives
    // below the visible buffer (i.e. not to the right).
    // If the variable doesn't exist, assume 2 buffers.
    //
    bCreateBackBuffer = FALSE;
    bCreateStereoBuffers = FALSE;
    bExists = bGlintQueryRegistryValueUlong(ppdev,
                                     REG_NUMBER_OF_SCREEN_BUFFERS,
                                     &ulValue);
    if (!bExists)
    {
        ulValue = 2;
    }
    if ((ulValue >= 2) && (ppdev->cyMemory >= (ppdev->cyScreen << 1)))
    {
//@@BEGIN_DDKSPLIT

        //ULONG   ulValue;
        LONG    leftOffset;
        LONG    byteTotal;
        LONG    lTotal;
        ULONG   rowSz;

//      if (GLINT_PXRX)        // ???   
        if (1)
        {
#if 0
            // if we have enough SGRAM then we can support both BLT and
            // full screen double buffering.

            glintInfo->flags |= GLICAP_BITBLT_DBL_BUF |
                                GLICAP_FULL_SCREEN_DBL_BUF;
            cx = ppdev->cxMemory;
            cy = ppdev->cyScreen;
            lTotal = cx * cy;
            rowSz = 1;
            leftOffset = 0;
#else
//@@END_DDKSPLIT
            bCreateBackBuffer = TRUE;
//@@BEGIN_DDKSPLIT
            goto ConfigurePermediaBuffers;
#endif
        }
        else
        {
            // we have enough VRAM so we at least support BLT double buffering
            glintInfo->flags |= GLICAP_BITBLT_DBL_BUF;

            // read FBModeSel to get the interleave etc. We're only interested in
            // whether we are up to 2-way or 4-way, so the left shift is adequate.
            // i.e. I don't care that (0 << 1) is "zero-way" rather than 1-way.
            //
            cx = ppdev->cxMemory;
            cy = ppdev->cyScreen;
            lTotal = cx * cy;

//@@BEGIN_DDKSPLIT
// AZN This code was originally not being used
#if 0
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
            {
                OH  *pohTmp;
                ULONG NumpadLines;
                LONG halfWay = ppdev->FrameBufferLength >> 1;        // TMM: This was FOUR_MB
          
                NumpadLines = ((halfWay / ppdev->lDelta) - ppdev->cyScreen; & ~1;
                DISPDBG((DBGLVL, "Allocating padding bitmap of size %d x %d", 
                                 cx, NumpadLines));
                pohTmp = pohAllocate(ppdev, NULL, cx, NumpadLines, 0);
                ASSERTDD(pohTmp != NULL, "pad buffer could not be allocated");

                // now allocate the actual back buffer
                cy = ((((halfWay + ppdev->lDelta - 1) / ppdev->lDelta) - NumpadLines) + 1) & ~1;
                DISPDBG((DBGLVL, "Allocating Racer back buffer of size %d x %d", cx, cy));
                poh = pohAllocate(ppdev, NULL, cx, cy, FLOH_MAKE_PERMANENT);
                ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == (halfWay / ppdev->lDelta)),
                            "Racer off-screen buffer allocated in incorrect position");
                DISPDBG((DBGLVL, "Racer back buffer at %d, %d", poh->x, poh->y));

                // as far as the 3D ext is concerned, the buffer lives at the
                // pixel address of the half-way boundary, but the VTGFrameRowAddr
                // is zero. We will examine the (GLICAP_RACER_BANK_SELECT |
                // GLICAP_ENHANCED_TX_BANK_SELECT) bits at swap time to see which
                // register we should load.
                //
                glintInfo->bufferOffset[1] = halfWay >> ppdev->cPelSize;
                glintInfo->bufferRow[1] = 0;
                DISPDBG((DBGLVL, "Racer offscreen buffer at offset 0x%x", GLINT_BUFFER_OFFSET(1)));

                // release the temporary buffer. We can use this as off-screen
                // memory.
                pohFree(ppdev, pohTmp);
            }
#endif
//@@END_DDKSPLIT

            // now see if we can handle full screen double buffering. This has
            // a slightly more stringent requirement because the second buffer
            // must start on a VRAM RAS line. OK, here's the equation for the
            // number of pixels per RAS line:
            //  512 * interleave_size * width_in_dwords * pixels_per_dword
            // The only dodgy number here is 512 but I am assured that all
            // the VRAMs that GLINT supports have this shift register size.
            //
            READ_GLINT_CTRL_REG (FBModeSel, ulValue);
            DISPDBG((DBGLVL, "FBModeSel = 0x%x", ulValue));
            rowSz = 512 << ((ulValue & 1)        +    // width in dwords
                            ((ulValue >> 8) & 3) +    // interleave value
                            (2 - ppdev->cPelSize));   // pixels per dword
            DISPDBG((DBGLVL, "got FrameRow of size 0x%x pixels", rowSz));

            // we have the RAS line size, so we must ensure that the second
            // buffer starts at a multiple of this many pixels from the
            // origin. This may not be zero in x since the screen stride may
            // not be a multiple of this number. So we calculate the number
            // of extra scanlines we need to span a full buffer that starts
            // on a RAS line boundary. Note, we know that rowSz is a
            // power of 2 so we can subtract 1 to get a mod mask.
            //
            leftOffset = (ULONG)(-lTotal) & (rowSz - 1);
            cy += (leftOffset + (cx-1)) / cx;

            // cx and cy are now the dimensions of the off-screen buffer we
            // want, including the extra scanlines needed to align the full
            // screen buffer. Since cy may have increased, again check we
            // have enough VRAM. If not then the full-screen alignment will
            // have caused us to run over the end. In this case we can position
            // the off-screen buffer immediately after the screen but we can't
            // offset into it the number of pixels required to align a
            // full-screen double buffer.
            //
            if ((ppdev->cyScreen + cy) <= ppdev->cyMemory)
            {
                // We can use VTGRowAddress if:
                //   we don't cross a 4MB boundary or
                //   (we have an interleave factor of 4 and we don't have an Omnicomp 3Demon Pro16)
                // else we can use Racer bank select if we have a Racer board.
                //
                if ((glintInfo->deviceInfo.BoardId == GLINT_RACER) ||
                    (glintInfo->deviceInfo.BoardId == GLINT_RACER_PRO) ||
                    (glintInfo->deviceInfo.BoardId == OMNICOMP_3DEMONPRO) ||
                    (glintInfo->deviceInfo.BoardId == GEO_TWIN_BOARD) ||
                    (glintInfo->deviceInfo.BoardId == ACCELPRO_BOARD) ||
                    (glintInfo->deviceInfo.BoardId == ELSA_GLORIA_XL) ||
                    (glintInfo->deviceInfo.BoardId == ELSA_GLORIA))
                {
                    glintInfo->flags |= GLICAP_FULL_SCREEN_DBL_BUF |
                                        GLICAP_RACER_DOUBLE_WRITE;

                    // The 3Demon Pro16 board does not support, enhanced
                    // mode bank-switching.
                    if ((ppdev->flCaps & CAPS_ENHANCED_TX) && 
                        (!IS_RACER_VARIANT_PRO16(ppdev)))
                    {
                        DISPDBG((DBGLVL, "Enhanced TX full-screen buffering"));
                        glintInfo->flags |= GLICAP_ENHANCED_TX_BANK_SELECT;
                    }
                    else
                    {
                        DISPDBG((DBGLVL, "Racer bank select full-screen buffering"));
                        glintInfo->flags |= GLICAP_RACER_BANK_SELECT;
                    }
                }
                else if (((ppdev->cyScreen + cy) * ppdev->lDelta <= FOUR_MB) ||
                         ((!IS_RACER_VARIANT_PRO16(ppdev))))
                {
                    DISPDBG((DBGLVL, "VTGFrameRowAddress full-screen buffering"));
                    glintInfo->flags |= GLICAP_FULL_SCREEN_DBL_BUF;
                }
            }
            else
                cy = ppdev->cyScreen;
        }

        if (glintInfo->flags & (GLICAP_RACER_BANK_SELECT |
                                GLICAP_ENHANCED_TX_BANK_SELECT))
        {
            // The second buffer must start in the second half of the frame
            // buffer (i.e. at 4MB for an 8MB card and 8MB for a 16MB card) so
            // allocate enough off-screen heap to pad up to the scanline
            // before this boundary. Then we allocate enough lines so that
            // we can move the buffer start to 4MB.
            //
            OH  *pohTmp;
            ULONG padLines;
            LONG halfWay = ppdev->FrameBufferLength >> 1;  // This was FOUR_MB
            LONG lScreenDelta;

            lScreenDelta = ppdev->lDelta;
         
            padLines = (halfWay / lScreenDelta) - ppdev->cyScreen;
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
                padLines &= ~1; // make number of pad lines even
            DISPDBG((DBGLVL, "Allocating padding bitmap of size %d x %d", ppdev->cxScreen, padLines));
            pohTmp = pohAllocate(ppdev, NULL, ppdev->cxScreen, padLines, 0);
            ASSERTDD(pohTmp != NULL, "pad buffer could not be allocated");
            DISPDBG((DBGLVL, "Racer padding bitmap at %d, %d", pohTmp->x, pohTmp->y));

            // now allocate the actual back buffer
            cy = ((halfWay + lScreenDelta - 1) / lScreenDelta) - padLines;
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
                cy = (cy + 1) & ~1; // round up to make even
            DISPDBG((DBGLVL, "Allocating Racer back buffer of size %d x %d", ppdev->cxScreen, cy));
            poh = pohAllocate(ppdev, NULL, ppdev->cxScreen, cy, FLOH_MAKE_PERMANENT);
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER) {
                ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y <= (halfWay / lScreenDelta)) && (poh->y >= ((halfWay / lScreenDelta) - 1)),
                        "Racer back buffer allocated in incorrect position");
            } else {
                ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == (halfWay / lScreenDelta)),
                        "Racer back buffer allocated in incorrect position");
            }
            DISPDBG((DBGLVL, "Racer back buffer at %d, %d", poh->x, poh->y));

            // as far as the 3D ext is concerned, the buffer lives at the
            // pixel address of the half-way boundary, but the VTGFrameRowAddr
            // is zero. We will examine the (GLICAP_RACER_BANK_SELECT |
            // GLICAP_ENHANCED_TX_BANK_SELECT) bits at swap time to see which
            // register we should load.
            //
            glintInfo->bufferOffset[1] = halfWay >> ppdev->cPelSize;
            if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
                glintInfo->bufferOffset[1] >>= 1;
            glintInfo->bufferRow[1] = 0;
            DISPDBG((DBGLVL, "Racer offscreen buffer at offset 0x%x", GLINT_BUFFER_OFFSET(1)));

            // Save the back-buffer POH
            glintInfo->backBufferPoh = poh;

            // release the temporary buffer. We can use this as off-screen
            // memory.
            pohFree(ppdev, pohTmp);
 
            if (cy > ppdev->cyScreen)
            {
                POINTL ptl;
                OH * pohtmptmp;
                LONG lpadLines;
                
                // Calculate padding, ensuring on a Geo we always allocate an
                // even number
                lpadLines = (cy - ppdev->cyScreen) + 1;
                if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER && (lpadLines & 0x1))
                    lpadLines++;

                ptl.x = 0;                    // Allocate strip directly after the front buffer
                ptl.y = ppdev->cyScreen;

                pohtmptmp = pohAllocate (ppdev, &ptl, ppdev->cxScreen, lpadLines, FLOH_MAKE_PERMANENT);

                ASSERTDD (pohtmptmp, "16BPP Pad buffer alloc failed");
            }
        }
        else
        {
            // Allocate the off-screen buffer. When we get it back, its
            // position should be immediately below the visible screen.
            // Since we have checked that we have enough VRAM and GLINT
            // never has off-screen memory to the right, it will fail only
            // if we get our logic mixed up. e.g. if the initialization
            // routines were re-ordered so that the brush cache got called
            // before this routine.
            //
            poh = pohAllocate(ppdev, NULL, cx, cy, FLOH_MAKE_PERMANENT);
            ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == ppdev->cyScreen),
             "off-screen buffer allocated in incorrect position");

            DISPDBG((DBGLVL, "allocated off-screen buffer at (%d,%d), w %d h %d",
                            poh->x, poh->y, poh->cx, poh->cy));
            glintInfo->bufferOffset[1] = lTotal;
            if (GLINT_FS_DBL_BUF)
            {
                glintInfo->bufferOffset[1] += leftOffset;
                glintInfo->bufferRow[1] = (lTotal + leftOffset) / rowSz;
                ASSERTDD(GLINT_BUFFER_OFFSET(1)%rowSz == 0, "off-screen buffer origin not on RAS line");
            }
            else
                leftOffset = 0;
            DISPDBG((DBGLVL, "offscreen buffer at offset 0x%x", GLINT_BUFFER_OFFSET(1)));
        }
                    
#ifdef LATER
            // We want to create a DIB and surface for the off-screen bitmap.
            // However, the bitmap must start at the correct origin. i.e. if
            // we had to offset the origin to match the VRAM page size (for
            // full screen double buffering) we must move the origin in the
            // poh. Since the node is allocated permanently we don't have to
            // worry about changing poh->x and poh->y. Famous last words?
            //
            if (leftOffset > 0)
            {
                poh->x += leftOffset % ppdev->cxMemory;
                poh->y += leftOffset / ppdev->cxMemory;
            }

            // allocate our DSURF object for the off-screen buffer.
            //
            pdsurf = ENGALLOCMEM(FL_ZERO_MEMORY, 
                                 sizeof(DSURF), 
                                 ALLOC_TAG_GDI(C));
            if (pdsurf == NULL)
            {
                DISPDBG((ERRLVL, "bInitializeGlint - Failed pdsurf allocation"));
                return(FALSE);
            }

            ppdev->pdsurfOffScreen = pdsurf;        // Remember it for clean-up

            pdsurf->poh     = poh;
            poh->pdsurf     = pdsurf;
            pdsurf->dt      = DT_SCREEN;
            pdsurf->bOffScreen = TRUE;            
            pdsurf->sizl.cx = ppdev->cxScreen;  // the poh may be bigger but
            pdsurf->sizl.cy = ppdev->cyScreen;  //  this is the valid size.
            pdsurf->ppdev   = ppdev;

            if (!bCreateScreenDIBForOH(ppdev, poh, HOOK_SYNCHRONIZE))
            {
                DISPDBG((WRNLVL, "bCreateScreenDIBForOH failed for off-screen buffer"));
                return(FALSE);
            }
            if(pdsurf->pso)
            {
                DISPDBG((DBGLVL, "pdsurf->pso for off-screen memory:"));
                DISPDBG((DBGLVL, "DHSURF 0x%x", pdsurf->pso->dhsurf));
                DISPDBG((DBGLVL, "HSURF 0x%x", pdsurf->pso->hsurf));
                DISPDBG((DBGLVL, "DHPDEV 0x%x", pdsurf->pso->dhpdev));
                DISPDBG((DBGLVL, "sizlBitmap %d, %d", pdsurf->pso->sizlBitmap.cx, pdsurf->pso->sizlBitmap.cy));
                DISPDBG((DBGLVL, "cjBits 0x%x", pdsurf->pso->cjBits));
                DISPDBG((DBGLVL, "pvBits 0x%x", pdsurf->pso->pvBits));
                DISPDBG((DBGLVL, "pvScan0 0x%x", pdsurf->pso->pvScan0));
                DISPDBG((DBGLVL, "lDelta %d", pdsurf->pso->lDelta));
                DISPDBG((DBGLVL, "iBitmapFormat 0x%x", pdsurf->pso->iBitmapFormat));
                DISPDBG((DBGLVL, "iType 0x%x", pdsurf->pso->iType));
                DISPDBG((DBGLVL, "fjBitmap 0x%x", pdsurf->pso->fjBitmap));
            }
#endif  // LATER
//@@END_DDKSPLIT
    }

//@@BEGIN_DDKSPLIT
ConfigurePermediaBuffers:
//@@END_DDKSPLIT

    // Work out the position and sizes for Z buffer and texture memory.
    // For PERMEDIA we need to reserve these with the heap manager since we
    // have a unified memory. For the moment, we will use all the available
    // extra memory for textures. Maybe later make it configurable to allow
    // the 2D driver some off-screen memory.
    // NB. P2 allocates a font cache here, it may be preferable to use the
    //     registry to determine the size of the cache

    LOCALBUFFER_PIXEL_WIDTH  = 0;    // bits
    LOCALBUFFER_PIXEL_OFFSET = 0;    // Z pels
    LOCALBUFFER_PIXEL_COUNT  = 0;    // Z pels
    FONT_MEMORY_OFFSET       = 0;    // dwords
    FONT_MEMORY_SIZE         = 0;    // dwords
    TEXTURE_MEMORY_OFFSET    = 0;    // dwords
    TEXTURE_MEMORY_SIZE      = 0;    // dwords

    {
        ULONG       cjGlyphCache;
        LONG        LBPelSize, PatchWidth, PatchRemainder, ZScreenWidth;
        ULONG       cyPermanentCaches, cyGlyphCache, cyPointerCache;
        LONG yOrg, ZHeight;

        cjGlyphCache = 300 * 1024;

//@@BEGIN_DDKSPLIT
#if 0
        // we don't have a brush cache for these chips
        ppdev->flStatus &= ~ENABLE_BRUSH_CACHE;
#endif
//@@END_DDKSPLIT

        // 3D extension fails if we have no textures or Z buffer but still
        // operates without a back buffer. So if we don't have enough
        // memory for Z or textures then abort buffer configuration.
        // (if width=16 => pelsize=1,patchwidth=128)
        LOCALBUFFER_PIXEL_WIDTH = 32;
        LBPelSize = 2;
        PatchWidth = 64;

        DISPDBG((DBGLVL, "bInitializeGlint: P3 Localbuffer width set to %i", LOCALBUFFER_PIXEL_WIDTH ));

        if (ppdev->cPelSize >= LBPelSize)
        {
            ZHeight = ppdev->cyScreen >> (ppdev->cPelSize - LBPelSize);
        }
        else
        {
            ZHeight = ppdev->cyScreen << (LBPelSize - ppdev->cPelSize);
        }

        bCreateBackBuffer = TRUE;

        // Decide if we want to allocate some stereo buffers.
        if(ppdev->flCaps & CAPS_STEREO)
        {
            bCreateStereoBuffers = TRUE;
        }

        cy  = ppdev->cyScreen;          // front buffer height
        cy += ZHeight;                  // add on Z buffer height
        cy += TEXTURE_OH_MIN_HEIGHT;    // minimum required texture memory

        if (cy > ppdev->cyMemory)
        {
            // Start DirectDraw after the end of the screen
            ppdev->heap.DDrawOffscreenStart = ppdev->cxMemory * ppdev->cyScreen;
            DISPDBG((ERRLVL, "not enough memory for 3D buffers, dd: 0x%x\n", ppdev->heap.DDrawOffscreenStart));
            goto CompletePermediaBuffers;
        }

        // is there room for a back buffer?

        if ((cy + ppdev->cyScreen) > ppdev->cyMemory)
        {
            bCreateBackBuffer = FALSE;
        }
        else if (bCreateBackBuffer)
        {
            cy += ppdev->cyScreen;
        }

        // is there room for stereo buffers?
        if ((cy + (2*ppdev->cyScreen)) > ppdev->cyMemory)
        {
            bCreateStereoBuffers = FALSE;
        }
        else if (bCreateStereoBuffers)
        {
            cy += (2*ppdev->cyScreen);
        }

        // cy is now the total length of all buffers required for 3D.
        // cyPermanentCaches is the combined height of the 2D caches that lie between the front & back buffers
        cyPermanentCaches = 0;

        // yOrg is the start of offscreen memory
        yOrg = ppdev->cyScreen + cyPermanentCaches;

        if (bCreateBackBuffer)
        {
            glintInfo->flags |= GLICAP_BITBLT_DBL_BUF | GLICAP_FULL_SCREEN_DBL_BUF;

            if (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK)
            {
                ULONG   bb, patchWidth, patchSize, x, y;

/*
                        Align   Size    cPelSize    2 - cPS     4 - cPS
                32bpp:  0x100   0x1000      2        0 >> 1      2 >>  4
                16bpp:  0x 80   0x 800      1        1 >> 2      3 >>  8
                 8bpp:  0x 40   0x 400      0        2 >> 4      4 >> 16

            patchSize = 0x400 << ppdev->cPelSize;    // Bytes
            regAlign  =  0x40 << ppdev->cPelSize;    // 128 bits

            reg = bufferOffset >> (4 - ppdev->cPelSize);
            bufferOffsetAlignment = regAlign << (4 - ppdev->cPelSize);    // 1024
                                = (0x40 << ppdev->cPelSize) << (4 - ppdev->cPelSize);
                                = 0x40 << 4;
                                = 1024;

            NB: verticalAlignment = 16 scanlines;
*/
                bb = ((ppdev->cxMemory * yOrg) + 1023) & ~1023;
                if( bb % ppdev->cxMemory )
                    bb = (bb / ppdev->cxMemory) + 1;
                else
                    bb = bb / ppdev->cxMemory;
                bb = (bb + 15) & ~15;
                bb *= ppdev->cxMemory;

                ppdev->heap.DDrawOffscreenStart =            // Save DirectDraw off-screen offset
                    glintInfo->bufferRow[1]    =
                    glintInfo->bufferOffset[1] = bb;

                x = bb % ppdev->cxMemory;
                y = bb / ppdev->cxMemory;
                glintInfo->backBufferXY = (x & 0xFFFF) | (y << 16);
                //LOAD_FBWRITE_OFFSET( 1, glintInfo->backBufferXY );

                yOrg = y + ppdev->cyScreen;    // Y origin of next buffer
            } 
            else 
            {
                ppdev->heap.DDrawOffscreenStart =        // Save DirectDraw off-screen offset
                glintInfo->bufferRow[1]    =
                glintInfo->bufferOffset[1] = ppdev->cxMemory * yOrg;
                glintInfo->backBufferXY = yOrg << 16;
                //LOAD_FBWRITE_OFFSET( 1, glintInfo->backBufferXY );
                yOrg += ppdev->cyScreen;    // Y origin of next buffer
            }
            DISPDBG((DBGLVL, "offscreen buffer at offset 0x%x", GLINT_BUFFER_OFFSET(1)));
        } 
        else 
        {
            // DirectDraw can use the memory that is left over
            ppdev->heap.DDrawOffscreenStart = ppdev->cxMemory * yOrg;
            DISPDBG((DBGLVL, "No Permedia back buffer being created dd: 0x%x", ppdev->heap.DDrawOffscreenStart));
        }

        // Setup stereo front and back buffers if they're required.
        // We just place them directly after the back buffer.
        // Patching requirements should be satisfied as long as the
        // front and back are patched/unpatched together.
        if (bCreateStereoBuffers)
        {
            // Stereo back buffer
            glintInfo->backRightBufferXY = (glintInfo->backBufferXY + (ppdev->cyScreen << 16));
            glintInfo->bufferRow[2] = glintInfo->bufferOffset[2] =
            (glintInfo->bufferOffset[1] + (ppdev->cxMemory * ppdev->cyScreen));

            // Stereo front buffer
            glintInfo->frontRightBufferXY = glintInfo->backRightBufferXY + (ppdev->cyScreen << 16);
            glintInfo->bufferRow[3] = glintInfo->bufferOffset[3] =
            (glintInfo->bufferOffset[2] + (ppdev->cxMemory * ppdev->cyScreen));

            
            yOrg += (2*ppdev->cyScreen);    // Y origin of next buffer
            
            // We successfully allocated stereo buffers so set the flag.
            glintInfo->flags |= GLICAP_STEREO_BUFFERS;
        }
        else
        {
            // If we aren't in stereo mode then set the right buffers to their
            // left equivalents.
            glintInfo->frontRightBufferXY = 0;
            glintInfo->backRightBufferXY = glintInfo->backBufferXY;
            glintInfo->bufferRow[2] = glintInfo->bufferOffset[2] = glintInfo->bufferOffset[1];
            glintInfo->bufferRow[3] = glintInfo->bufferOffset[3] = glintInfo->bufferOffset[0];
        }

        {
            // Place the local buffer at end of memory (picks up dedicated page selector).
            // Textures are placed between the back buffer and the local buffer memory.
            // The width of the local buffer is controlled via a registry variable.
            
            ULONG TopOfLBMemoryDwords ;


            // If the screen width is not a multiple of the patch size then
            // we allocate a slightly larger Z buffer which is.
            if(PatchRemainder = ppdev->cxScreen % PatchWidth)
            {
                ZScreenWidth = ppdev->cxScreen + (PatchWidth - PatchRemainder);
            }
            else
            {
                ZScreenWidth = ppdev->cxScreen;
            }
            // Store the actual Z buffer width
            glintInfo->P3RXLocalBufferWidth = ZScreenWidth;

            LOCALBUFFER_PIXEL_COUNT = ppdev->cyScreen * ZScreenWidth ;
            
            // LB offset in units of LB pixels
            {
                ULONG TotalMemoryInDwords = (ppdev->cyMemory * ppdev->cxMemory) >> (2 - ppdev->cPelSize) ;
                
                // Working in unit of LB pixels, and working backwards from the end of memory               
                LOCALBUFFER_PIXEL_OFFSET = TotalMemoryInDwords << (2 - LBPelSize) ;
                // Ensure the top left of the last patch starts on a patch boundary
                LOCALBUFFER_PIXEL_OFFSET -= LOCALBUFFER_PIXEL_OFFSET % (PatchWidth*16);

                // Calculate the start of the local buffer memory (used later)
                TopOfLBMemoryDwords = (LOCALBUFFER_PIXEL_OFFSET - LOCALBUFFER_PIXEL_COUNT) >> (2 - LBPelSize) ;

                // Need to subtract one row of patches because origin is at start of 
                // last row of patches
                LOCALBUFFER_PIXEL_OFFSET -= (ZScreenWidth*16) ;
                // Add the offset of the bottom left pixel within the bottom left
                // patch.
                LOCALBUFFER_PIXEL_OFFSET += PatchWidth*15;
            }
            
            DISPDBG((DBGLVL, "bInitializeGlint: P3 cxScreen %i cyScreen %i cPelSize %i", ppdev->cxScreen, ppdev->cyScreen, ppdev->cPelSize));
            DISPDBG((DBGLVL, "bInitializeGlint: P3 cxMemory %i cyMemory %i cPelSize %i", ppdev->cxMemory, ppdev->cyMemory, ppdev->cPelSize));
            DISPDBG((DBGLVL, "bInitializeGlint: P3 LOCALBUFFER_PIXEL_OFFSET %i LOCALBUFFER_PIXEL_COUNT %i ", LOCALBUFFER_PIXEL_OFFSET, LOCALBUFFER_PIXEL_COUNT));

            // Texture memory offset in DWORDS
            TEXTURE_MEMORY_OFFSET = (ppdev->cxMemory * yOrg) >> (2 - ppdev->cPelSize); 
            
            // Texture size calculation
            if (TopOfLBMemoryDwords > TEXTURE_MEMORY_OFFSET)
            {
                TEXTURE_MEMORY_SIZE = TopOfLBMemoryDwords - TEXTURE_MEMORY_OFFSET ;
            }
            else
            {
                TEXTURE_MEMORY_SIZE = 0 ;
            }
                
            DISPDBG((DBGLVL, "bInitializeGlint: P3 TEXTURE_MEMORY_OFFSET %i", TEXTURE_MEMORY_OFFSET));
            DISPDBG((DBGLVL, "bInitializeGlint: P3 TEXTURE_MEMORY_SIZE in dwords %i", TEXTURE_MEMORY_SIZE));
        }

#       if DBG
        {
            ULONG   lbS, lbE, tS, tE;
            DISPDBG((DBGLVL, "bIGlint: front buffer = 0x%08Xp (%4dL) -> 0x%08Xp (%4dL)", glintInfo->bufferOffset[0], glintInfo->fbWriteOffset[0] >> 16, glintInfo->bufferOffset[0] + (ppdev->cyScreen * ppdev->cxMemory), (glintInfo->fbWriteOffset[0] >> 16) + ppdev->cyScreen));
            DISPDBG((DBGLVL, "bIGlint:  back buffer = 0x%08Xp (%4dL) -> 0x%08Xp (%4dL)", glintInfo->bufferOffset[1], glintInfo->backBufferXY     >> 16, glintInfo->bufferOffset[1] + (ppdev->cyScreen * ppdev->cxMemory), (glintInfo->backBufferXY     >> 16) + ppdev->cyScreen));
            lbS = LOCALBUFFER_PIXEL_OFFSET - (ZScreenWidth * (ppdev->cyScreen - 1));
            lbE = LOCALBUFFER_PIXEL_OFFSET + ZScreenWidth;
            if( ppdev->cPelSize >= LBPelSize ) {
                lbS = lbS >> (ppdev->cPelSize - LBPelSize);
                lbE = lbE >> (ppdev->cPelSize - LBPelSize);
            } else {
                lbS = lbS << (LBPelSize - ppdev->cPelSize);
                lbE = lbE << (LBPelSize - ppdev->cPelSize);
            }
            lbS /= ppdev->cxMemory;     lbE /= ppdev->cxMemory;
            DISPDBG((DBGLVL, "bIGlint: local buffer = 0x%08Xp (%4dL) -> 0x%08Xp (%4dL)", LOCALBUFFER_PIXEL_OFFSET - (ZScreenWidth * (ppdev->cyScreen - 1)), lbS, LOCALBUFFER_PIXEL_OFFSET + ZScreenWidth, lbE));
            tS = (TEXTURE_MEMORY_OFFSET << (2 - ppdev->cPelSize)) / ppdev->cxMemory;
            tE = (TEXTURE_MEMORY_SIZE   << (2 - ppdev->cPelSize)) / ppdev->cxMemory;
            DISPDBG((DBGLVL, "bIGlint:      texture = 0x%08Xx (%4dL) + 0x%08Xx = 0x%08Xx (%4dL)", TEXTURE_MEMORY_OFFSET, tS, TEXTURE_MEMORY_SIZE, TEXTURE_MEMORY_OFFSET + TEXTURE_MEMORY_SIZE, tS + tE));
        }
#       endif
    }

CompletePermediaBuffers:
    
    // work out the fudge factor to add onto VTGVLineNumber to get the current
    // video scanline. VTGVLineNumber returns VTGVLimit for the last visible
    // line on the screen and 1 for line after that. Use the
    // GLINT_GET_VIDEO_SCANLINE macro to retrieve the current scanline.
    //
    READ_GLINT_CTRL_REG (VTGVLimit, glintInfo->vtgvLimit);
    glintInfo->scanFudge = glintInfo->vtgvLimit - ppdev->cyScreen + 1;
   
    // work out partial products for the screen stride. We need to record
    // the products for 8, 16 and 32 bit width 'pixels', only one is the
    // correct width, but we want to be able to pretend to use 16 and 32
    // bit pixels occasionally on an 8 bit pixel framestore for speed.

    cPelSize = ppdev->cPelSize;
    if(cPelSize == GLINTDEPTH24)
    {
        // 24bpp: special case (3 bytes per pixel)
        width = ppdev->cxMemory * 3;
    }
    else
    {
        width = ppdev->cxMemory << cPelSize;    // width of framestore in bytes
    }

    DISPDBG((DBGLVL, "assuming screen stride is %d bytes\n", width));

    // Hardware write mask emulation with DRAMS works for byte masks only
    // I.e. 0xFF00FF00 will work, 0x0FF00FF0 will not.

    READ_GLINT_CTRL_REG( LocalMemCaps, ulValue );
    if (ulValue & (1 << 28))
    {
        glintInfo->flags |= GLICAP_HW_WRITE_MASK_BYTES;
    }
    else
    {
        glintInfo->flags |= GLICAP_HW_WRITE_MASK;
    }
  
    DISPDBG((DBGLVL, "bInitializeGlint OK"));

#if DBG
    // print this stuff out for debugging purposes
    if (GLINT_HW_WRITE_MASK)
        DISPDBG((DBGLVL, "Hardware Writemasking enabled"));

    ASSERTDD(!GLINT_CS_DBL_BUF, "Color Space double buffering enabled");

    if (GLINT_FS_DBL_BUF)
    {
        DISPDBG((DBGLVL, "Full screen double buffering enabled"));
        DISPDBG((DBGLVL, "second buffer at pixel offset 0x%x, origin (%d,%d), RowAddr %d",
            GLINT_BUFFER_OFFSET(1),
            GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory,
            GLINT_BUFFER_OFFSET(1) / ppdev->cxMemory,
            glintInfo->bufferRow[1]));
    }
    if (GLINT_BLT_DBL_BUF)
    {
        DISPDBG((DBGLVL, "BITBLT double buffering enabled"));
        DISPDBG((DBGLVL, "second buffer at pixel offset 0x%x, origin (%d,%d)",
            GLINT_BUFFER_OFFSET(1),
            GLINT_BUFFER_OFFSET(1) % ppdev->cxMemory,
            GLINT_BUFFER_OFFSET(1) / ppdev->cxMemory));
    }
    if (GLINT_FAST_FILL_SIZE > 0)
        DISPDBG((DBGLVL, "using fast fill size of %d (%s fast fill bug workarounds)",
            GLINT_FAST_FILL_SIZE, GLINT_FIX_FAST_FILL ? "need" : "don't need"));
#endif  // DBG

    return(TRUE);
    
} // bInitializeGlint

/******************************Public*Routine******************************\
* VOID vDisableGlint
*
* Do whatever we need to when the surface is disabled.
*
\**************************************************************************/

VOID vDisableGlint(PPDEV ppdev)
{
    DSURF*  pdsurf;
    GLINT_DECL;

    if (!glintInfo)
        return;

    if (glintInfo->PXRXDMABuffer.virtAddr && glintInfo->PXRXDMABuffer.physAddr.LowPart == 0)
    {
        DISPDBG((DBGLVL, "DrvDisableSurface: "
                         "freeing PXRX virtual DMA buffer %p, size %xh", 
                         glintInfo->PXRXDMABuffer.virtAddr, 
                         glintInfo->PXRXDMABuffer.size));

        ENGFREEMEM(glintInfo->PXRXDMABuffer.virtAddr);
        glintInfo->PXRXDMABuffer.virtAddr = NULL;
        glintInfo->PXRXDMABuffer.size = 0;
    }

    // free up any contexts we allocated
    //
    if (glintInfo->ddCtxtId >= 0)
    {
        vGlintFreeContext(ppdev, glintInfo->ddCtxtId);
    }

//@@BEGIN_DDKSPLIT
#ifdef  LATER
     pdsurf = ppdev->pdsurfOffScreen;
    if (pdsurf != NULL)
        vDeleteScreenDIBFromOH(pdsurf->poh);
#endif
//@@END_DDKSPLIT

    // Free GlintInfo and zero it.
    ENGFREEMEM(glintInfo);  
    ppdev->glintInfo = NULL;
    
} // vDisableGlint

/******************************Public*Routine******************************\
* VOID vAssertModeGlint
*
* We're about to switch to/from full screen mode so do whatever we need to
* to save context etc.
*
\**************************************************************************/

VOID vAssertModeGlint(PPDEV ppdev, BOOL bEnable)
{
    GLINT_DECL;

    if (!glintInfo)
        return;

    if (!bEnable)
    {
        // Reset our software copy of the depth configured for this PDEV
        // back to the native depth. If we don't do this we may end up
        // with the copy and the hardware being out of sync when we
        // re-enable. Also, do a context switch to save our core register
        // state ready for when we get back in. All this forces a SYNC
        // as well which is a good thing.
        //
        VALIDATE_DD_CONTEXT;
        GLINT_DEFAULT_FB_DEPTH;
        GLINT_VALIDATE_CONTEXT(-1);
    }
    else
    {
        // re-enabling our PDEV so reload our context.
        //
        VALIDATE_DD_CONTEXT;

//@@BEGIN_DDKSPLIT
#if GAMMA_CORRECTION
        //
        // Restore the current gamma LUT.
        //
        bInstallGammaLUT(ppdev, &glintInfo->gammaLUT, FALSE);

#endif  // GAMMA_CORRECTION
//@@END_DDKSPLIT
    }
    
} // vAssertModeGlint
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\glntctxt.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: glntctxt.h
*
* Content: Defines for context switching code.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// each time round allocate this many entries
#define CTXT_CHUNK  8

// each context consists of a set of tags and the corresponding data. so after
// ntags we have 2*ntags*sizeof(DWORD) bytes of memory.
typedef struct _glint_ctxt_data {
    DWORD   tag;
    DWORD   data;
} CtxtData;

typedef struct _glint_ctxt {
    LONG        ntags;
    PVOID       priv;                // opaque handle passed by caller
    DWORD       DoubleWrite;         // Racer double write control
    DWORD       DMAControl;          // AGP or PCI on P2 and Gamma
    ULONG       endIndex;            // endIndex for the interrupt driven DMA Q
    ULONG       inFifoDisc;          // disconnect
    ULONG       VideoControl;        // Video Control
    ContextType type;                // To support reduced size context switching
    ContextFixedFunc    dumpFunc;    // Function for dumping a fixed context
    CtxtData    pData[1];
    // more follows in memory
} GlintCtxtRec;

typedef struct _glint_ctxt_table {
    LONG    size;       // in bytes of the table
    LONG    nEntries;
    GlintCtxtRec*    pEntry[CTXT_CHUNK];
    // more to be allocated in memory if needed
} GlintCtxtTable;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\heap.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: heap.c
*
* Content:
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

#if WNT_DDRAW
#include "linalloc.h"
#endif

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      4           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

const ULONG HEAP_X_ALIGNMENT_P3[5] = {
    4,    // GLINTDEPTH8
    4,    // GLINTDEPTH16
    32,    // GLINTDEPTH32      = 32 pixels
    0,    // ---
    4,    // GLINTDEPTH24
};


/******************************Public*Routine******************************\
* void UploadDFBToDIB
\**************************************************************************/
void UploadDFBToDIB(PDEV *ppdev, SURFOBJ *pso, DSURF *pdsurf)
{
    OH       *poh = pdsurf->poh;
    RECTL    rclDst;
    POINTL   ptlSrc;
    LONG     xOff;
    LONG     pixOffset;
    LONG     pixDelta;
    ULONG    xyOffsetDst;
    BOOL     bOff;
    GLINT_DECL;

    rclDst.left   = 0;
    rclDst.top    = 0;
    rclDst.right  = pdsurf->sizl.cx;
    rclDst.bottom = pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    GET_PPDEV_DST_OFFSETS(ppdev, pixOffset, pixDelta, xyOffsetDst, xOff, bOff);
    SET_PPDEV_DST_OFFSETS(ppdev, poh->pixOffset, poh->lPixDelta, 
                          MAKEDWORD_XY(poh->x, poh->y), 
                          poh->bDXManaged ? 0 : poh->x, pdsurf->bOffScreen);
    VALIDATE_DD_CONTEXT;
    ppdev->pgfnUpload(ppdev, 1, &rclDst, pso, &ptlSrc, &rclDst);

    SET_PPDEV_DST_OFFSETS(ppdev, pixOffset, pixDelta, xyOffsetDst, xOff, bOff);
}

/******************************Public*Routine******************************\
* void DownloadDIBToDFB
\**************************************************************************/
void DownloadDIBToDFB(PDEV *ppdev, SURFOBJ *pso, DSURF *pdsurf)
{
    OH       *poh = pdsurf->poh;
    RECTL    rclDst;
    POINTL   ptlSrc;
    LONG     xOffset;
    LONG     pixOffset;
    LONG     pixDelta;
    ULONG    xyOffsetDst;
    BOOL     bOff;
    GLINT_DECL;

    // call low level download routine to download the DIB data to the
    // new off-screen DFB. Save and restore the ppdev offsets in case
    // we were called from the middle of some blt routine which has
    // already set them up.
    //
    rclDst.left   = 0;
    rclDst.top    = 0;
    rclDst.right  = pdsurf->sizl.cx;
    rclDst.bottom = pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    GET_PPDEV_DST_OFFSETS(ppdev, pixOffset, pixDelta, 
                          xyOffsetDst, xOffset, bOff);
    SET_PPDEV_DST_OFFSETS(ppdev, poh->pixOffset, poh->lPixDelta, 
                          MAKEDWORD_XY(poh->x, poh->y), 
                          poh->bDXManaged ? 0 : poh->x, pdsurf->bOffScreen);

    DISPDBG((DBGLVL,"Converting a DIB back to a DFB. calling image download"));
    VALIDATE_DD_CONTEXT;
    ppdev->pgfnXferImage(ppdev, &rclDst, 1, __GLINT_LOGICOP_COPY, 
                         __GLINT_LOGICOP_COPY, pso, &ptlSrc, &rclDst, NULL);

    SET_PPDEV_DST_OFFSETS(ppdev, pixOffset, pixDelta, 
                          xyOffsetDst, xOffset, bOff);
}

/******************************Private*Routine******************************\
* OH* GlintVidMemAlloc
*
* Use the DX heap manager to allocate linear memory from off-screen
*
\**************************************************************************/

OH *GlintVidMemAlloc(PDEV *ppdev, OH *pohThis, LONG cxThis, LONG cyThis)
{
    FLATPTR             fp = 0;

#if WNT_DDRAW

    P3_MEMREQUEST       mmrq;
    LinearAllocatorInfo *pvmHeap = NULL;
    LONG                iHeap;
    LONG                lDelta;
    ULONG               Mask32bit;
    GLINT_DECL;

    ASSERTDD((ppdev->flStatus & STAT_LINEAR_HEAP), 
              "GlintVidMemAlloc: ERROR - "
              "linear allocator called when linear heap not enabled!");

    DISPDBG((DBGLVL, "GlintVidMemAlloc: want cxy(%xh,%xh), cHeaps(%d)", 
                  cxThis, cyThis, ppdev->heap.cLinearHeaps));

    if(ppdev->heap.cLinearHeaps)
    {
        // align to dword boundaries
        Mask32bit = (1 << (2 - ppdev->cPelSize)) - 1;
        lDelta = cxThis + Mask32bit;
        lDelta &= ~Mask32bit;
        lDelta <<= ppdev->cPelSize;

        memset(&mmrq, 0, sizeof mmrq);
        mmrq.dwSize = sizeof mmrq;
        mmrq.dwBytes = lDelta * cyThis;
        mmrq.dwAlign = 16;    // 16 Byte alignment will work for everything
        mmrq.dwFlags = MEM3DL_FIRST_FIT | MEM3DL_FRONT;

retry:
        for (iHeap = 0, fp = 0; 
             iHeap < (LONG)ppdev->heap.cLinearHeaps && fp == 0; 
             ++iHeap)
        {
            pvmHeap = &ppdev->heap.pvmLinearHeap[iHeap];

            // we don't allocate from the AGP heap at present
            if(pvmHeap)
            {
                if(_DX_LIN_AllocateLinearMemory(pvmHeap, &mmrq) == GLDD_SUCCESS)
                {
                    fp = mmrq.pMem;
                }
                else
                {
                    DISPDBG((DBGLVL, "GlintVidMemAlloc: allocation failed"));
                }
            }
        }
        
        if(fp == 0)
        {
            OH *poh;
            LONG cxcyThis = cxThis * cyThis;
            LONG cxcy;

            do
            {
               poh = ppdev->heap.ohDiscardable.pohPrev;
                if (poh == &ppdev->heap.ohDiscardable)
                {
                    DISPDBG((DBGLVL, "GlintVidMemAlloc: FAILED :"
                                  "No discardable bitmaps remaining in "
                                  "offscreen and still not enough room"));
                    return(NULL);
                }
                
                ASSERTDD(poh != &ppdev->heap.ohDiscardable, 
                         "Ran out of discardable entries");
                ASSERTDD(poh->ohState == OH_DISCARDABLE, 
                         "Non-discardable node in discardable list");

                poh = pohMoveOffscreenDfbToDib(ppdev, poh);
                if (poh == NULL)
                {
                    DISPDBG((DBGLVL, "GlintVidMemAlloc: "
                                  "failed to kick DFB into system memory"));
                    return(NULL);
                }
                
                cxcy = poh->cx * poh->cy;
                cxcyThis -= cxcy;
            } 
            while (cxcyThis > 0);

            goto retry;
        }
    }

    if(fp)
    {
        ULONG pixOffset, x, y, xAligned;
                    
        DISPDBG((DBGLVL, "GlintVidMemAlloc: got some memory"
                      " - fp(%08xh) lDelta(%xh)", (ULONG)fp, lDelta));


        pixOffset = (DWORD)(fp >> ppdev->cPelSize);
        y = pixOffset / ppdev->cxMemory;
        x = pixOffset % ppdev->cxMemory;
        
        DISPDBG((DBGLVL, "GlintVidMemAlloc: rectangular values are: "
                      "pixOffset %08xh = xy(%xh,%xh)", pixOffset, x, y));

        xAligned = x & ~((1 << (2 - ppdev->cPelSize)) - 1);
        pixOffset = y * ppdev->cxMemory + xAligned;
        y = 0;
        x -= xAligned;

        pohThis->x = x;
        pohThis->y = y;
        pohThis->cx = cxThis;
        pohThis->cy = cyThis;
        pohThis->lPixDelta = lDelta >> ppdev->cPelSize;
        pohThis->pixOffset = pixOffset;
        pohThis->cxReserved = 0;
        pohThis->cyReserved = 0;
        pohThis->cxcy = CXCY(cxThis, cyThis);
        pohThis->pdsurf = NULL;
        pohThis->pvScan0 = ppdev->pjScreen + fp;
        pohThis->bDXManaged = TRUE;
        pohThis->pvmHeap = pvmHeap;
        pohThis->fpMem = fp;

        DISPDBG((DBGLVL, "GlintVidMemAlloc: linear values are: "
                      "pixOffset(%08xh), xy(%xh,%xh), cxy(%xh,%xh) Delta(%xh)",
                      pohThis->pixOffset = pixOffset, pohThis->x, pohThis->y, 
                      pohThis->cx, pohThis->cy, pohThis->lPixDelta));
    }
    else
    {
        // didn't get any memory - point at the free list 
        // sentinel to register our disappointment
        DISPDBG((DBGLVL, "GlintVidMemAlloc: "
                         "failed to get any offscreen memory"));
         
        for(pohThis = &ppdev->heap.ohFree; 
            pohThis->cxcy != CXCY_SENTINEL; 
            pohThis = pohThis->pohNext)
        {
            NULL;
        }
    }

#endif // WNT_DDRAW

    return(fp ? pohThis : NULL);
}

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        DISPDBG((DBGLVL, "pohNewNode(): allocating new poha block"));

        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = ENGALLOCMEM(FL_ZERO_MEMORY, OH_ALLOC_SIZE, ALLOC_TAG_GDI(D));
        if (poha == NULL)
        {
            DISPDBG((DBGLVL, "pohNewNode: failed to alloc node array, "
                             "returning NULL"));
            return(NULL);
        }
        
        // Insert this OHALLOC at the begining of the OHALLOC chain:
        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:
        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:
        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    DISPDBG((DBGLVL, "pohNewNode(): returning poh %ph", poh));

    return(poh);
}

/******************************Private*Routine******************************\
* OH* GetFreeNode
*
* returns a node from the free list. If nothing free, returns the sentinel
*
\**************************************************************************/

OH *GetFreeNode(PDEV *ppdev, LONG cxThis, LONG cyThis)
{
    ULONG   cxcyThis = CXCY(cxThis, cyThis);
    OH      *pohThis;

    if((ppdev->flStatus & STAT_LINEAR_HEAP))
    {
        // We don't used the free list - DX does all the heap management
        // just create a node structure and try to alloc from the DX heap. 
        pohThis = pohNewNode(ppdev);
        
        if(pohThis)
        {
            // pohNewNode unlinks the node from the free list - link it 
            // back in as the caller to GetFreeNode will expect it there
            pohThis->pohNext = ppdev->heap.ohFree.pohNext;
            pohThis->pohPrev = ppdev->heap.ohFree.pohNext->pohPrev;
        
            pohThis->pohNext->pohPrev = pohThis;
            pohThis->pohPrev->pohNext = pohThis;

            pohThis = GlintVidMemAlloc(ppdev, pohThis, cxThis, cyThis);
        }
    }
    else
    {
        pohThis  = ppdev->heap.ohFree.pohNext;
    
        // The free list shows holds all the unused (rectangular) regions 
        // on the heap. These are ordered by size. Search through the 
        // list to find the best fit
        while (pohThis->cxcy < cxcyThis)
        {
            ASSERTDD(pohThis->ohState == OH_FREE, 
                     "Non-free node in free list(1)");

            pohThis = pohThis->pohNext;
        }

        while (pohThis->cy < cyThis)
        {
            ASSERTDD(pohThis->ohState == OH_FREE, 
                     "Non-free node in free list(2)");

            pohThis = pohThis->pohNext;
        }
    }
    return(pohThis);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
    {
        return;
    }

    DISPDBG((DBGLVL, "vOhFreeNode(): freeing poh %ph", poh));

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ohState            = OH_FREE; //azn was -1
}

/******************************Public*Routine******************************\
* VOID vCalculateMaximumNonPermanent
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/

VOID vCalculateMaximumNonPermanent(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    cxBounds;
    LONG    cyBounds;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;
    cxBounds = 0;
    cyBounds = 0;

    // First time through, loop through the list of free available
    // rectangles:

    pohSentinel = &ppdev->heap.ohFree;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(poh->ohState != OH_PERMANENT,
                     "Permanent node in free or discardable list");

            if (poh->cx > cxBounds)
            {
                cxBounds = poh->cx;
            }
            
            if (poh->cy > cyBounds)
            {
                cyBounds = poh->cy;
            }

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of discardable
        // rectangles:

        pohSentinel = &ppdev->heap.ohDiscardable;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;
    ppdev->heap.cxBounds = cxBounds;
    ppdev->heap.cyBounds = cyBounds;
}

/******************************Public*Routine******************************\
* BOOL bDiscardEverythingInRectangle
*
* Throws out of the heap any discardable bitmaps that intersect with the
* specified rectangle.
*
\**************************************************************************/

BOOL bDiscardEverythingInRectangle(
PDEV*   ppdev,
LONG    x,
LONG    y,
LONG    cx,
LONG    cy)
{
    BOOL bRet;
    OH*  poh;
    OH*  pohNext;

    bRet = TRUE;        // Assume success

    poh = ppdev->heap.ohDiscardable.pohNext;
    while (poh != &ppdev->heap.ohDiscardable)
    {
        ASSERTDD(poh->ohState == OH_DISCARDABLE,
                 "Non-discardable node in discardable list");

        pohNext = poh->pohNext;

        if ((poh->x < x + cx) &&
            (poh->y < y + cy) &&
            (poh->x + poh->cx > x) &&
            (poh->y + poh->cy > y))
        {
            // The two rectangles intersect.  Give the boot to the
            // discardable bitmap:

            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
            {
                bRet = FALSE;
            }
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bFreeRightAndBottomSpace
*
* Given a free off-screen rectangle, allocates the upper-left part of
* the rectangle to hold the allocation request, and puts the two rectangles
* comprising the unused right and bottom portions on the free list.
*
\**************************************************************************/

BOOL bFreeRightAndBottomSpace(
PDEV*   ppdev,
OH*     pohThis,
LONG    cxThis,
LONG    cyThis,
BOOL    bQuantum)           // Set if inifitely small allocations should be
                            //   allowed
{
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;
    LONG  cxRem;
    LONG  cyRem;
    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;
    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;
    LONG  cQuantum;
    GLINT_DECL;

    ASSERTDD(glintInfo != NULL, 
             "bFreeRightAndBottomSpace: ppdev->glintInfo is NULL");

    ASSERTDD(pohThis->bDXManaged == FALSE, 
             "bFreeRightAndBottomSpace: ERROR - called for linear DFB");

    // We're going to use the upper-left corner of our given rectangle,
    // and divide the unused remainder into two rectangles which will
    // go on the free list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

#if 1
    // We may get better performance by keeping screen wide rectangles intact.
    if(cyRem < OH_QUANTUM || 
       cxRem < OH_QUANTUM || 
       pohThis->cx != ppdev->cxScreen)
    {
        if (cxRem <= cyRem)
        {
            cxBelow  = cxThis + cxRem;
            cyBeside = cyThis;
        }
        else
        {
            cxBelow  = cxThis;
            cyBeside = cyThis + cyRem;
        }
    }
    else
    {
        // we're allocating a block as wide as the screen: force a 
        // horizontal slice to be taken
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
#else
    if (cxRem <= cyRem)
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }
#endif

    // If 'bQuantum' is set, we only make new available rectangles of
    // the unused right and bottom portions if they're greater in
    // dimension than OH_QUANTUM (it hardly makes sense to do the
    // book-work to keep around a 2-pixel wide available space, for
    // example):

    cQuantum = (bQuantum) ? 1 : OH_QUANTUM;

    pohBeside = NULL;
    if (cxBeside >= cQuantum)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(FALSE);
    }

    pohBelow = NULL;
    if (cyBelow >= cQuantum)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(FALSE);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohFree.pohNext;
        
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBelow;
        pohNext->pohPrev   = pohBelow;
        pohBelow->pohPrev  = pohPrev;
        pohBelow->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxReserved = 0;
        pohBelow->cyReserved = 0;
        pohBelow->cxcy       = cxcy;
        pohBelow->ohState    = OH_FREE;
        pohBelow->x          = pohThis->x;
        pohBelow->y          = pohThis->y + cyThis;
        pohBelow->cx         = cxBelow;
        pohBelow->cy         = cyBelow;
        pohBelow->lPixDelta  = ppdev->cxMemory;
        POH_SET_RECTANGULAR_PIXEL_OFFSET(ppdev, pohBelow);

        // Modify the current node to reflect the changes we've made:

        pohThis->cy = cyThis;
    }

    if (cxBeside >= cQuantum)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohFree.pohNext;
        
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = pohBeside;
        pohNext->pohPrev    = pohBeside;
        pohBeside->pohPrev  = pohPrev;
        pohBeside->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxReserved = 0;
        pohBeside->cyReserved = 0;
        pohBeside->cxcy       = cxcy;
        pohBeside->ohState    = OH_FREE;
        pohBeside->x          = pohThis->x + cxThis;
        pohBeside->y          = pohThis->y;
        pohBeside->cx         = cxBeside;
        pohBeside->cy         = cyBeside;
        pohBeside->lPixDelta  = ppdev->cxMemory;
        POH_SET_RECTANGULAR_PIXEL_OFFSET(ppdev, pohBeside);

        // Modify the current node to reflect the changes we've made:
        pohThis->cx = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->cxcy = CXCY(pohThis->cx, pohThis->cy);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAtLocation
*
* Attempts to allocate a rectangle at a specific position.
*
\**************************************************************************/

OH* pohMakeRoomAtLocation(
PDEV*   ppdev,
POINTL* pptl,               // Requested position for the rectangle
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // Allocation flags
{
    OH*     poh;
    OH*     pohTop;
    OH*     pohLeft;
    LONG    cxLeft;
    LONG    cyTop;
    OH*     pohRight;


    ASSERTDD((ppdev->flStatus & STAT_LINEAR_HEAP) == FALSE, 
              "pohMakeRoomAtLocation: ERROR - called for linear DFB");

    if (!(floh & FLOH_ONLY_IF_ROOM))
    {
        // First off, discard any bitmaps that overlap the requested
        // rectangle, assuming we're allowed to:

        if (!bDiscardEverythingInRectangle(ppdev, 
                                           pptl->x, 
                                           pptl->y, 
                                           cxThis, 
                                           cyThis))
        {
            return(NULL);
        }
    }

    // Now see if there is a free rectangle that entirely contains the
    // requested rectangle.

    for (poh = ppdev->heap.ohFree.pohNext;
         poh != &ppdev->heap.ohFree;
         poh = poh->pohNext)
    {
        ASSERTDD(poh->ohState == OH_FREE, "Non-free node in free list(3)");

        // See if the current free rectangle completely contains the
        // requested rectangle:

        if ((poh->x <= pptl->x) &&
            (poh->y <= pptl->y) &&
            (poh->x + poh->cx >= pptl->x + cxThis) &&
            (poh->y + poh->cy >= pptl->y + cyThis))
        {
            // We can't reserve this rectangle, or make it permanent, if it's
            // already been reserved:

            if ((!poh->cxReserved) ||
                ((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0))
            {
                // The 'poh' rectangle entirely contains the requested
                // rectangle.  We may have a situation like this, where
                // the smaller rectangle is the requested rectangle, and
                // the larger rectangle is the available rectangle:
                //
                //     +-------------------+
                //     |                   |
                //     |    +---------+    |
                //     |    |Requested|    |
                //     |    |         |    |
                //     |    +---------+    |
                //     |                   |
                //     +-------------------+
                //
                // We want to make the space to the left and to the top of
                // the requested rectangle available to the heap.  Our
                // free-space routine only knows how to free space to the
                // right and bottom of an allocation, though.  So we will
                // temporarily allocate temporary rectangles to subdivide
                // our rectangle like the following:
                //
                //     +-------------------+
                //     |Top                |
                //     +----+--------------+
                //     |Left|Free          |
                //     |    |              |
                //     |    |              |
                //     |    |              |
                //     +----+--------------+
                //
                // Then, in the resulting 'Free' space, we will allocate the
                // upper-left corner for our requested rectangle, after which
                // we will go back and free the 'Top' and 'Left' temporary
                // rectangles.

                pohTop  = NULL;
                pohLeft = NULL;
                cxLeft  = pptl->x - poh->x;
                cyTop   = pptl->y - poh->y;

                if (cyTop > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, poh->cx, cyTop,
                                                  TRUE))
                    {
                        return(NULL);
                    }

                    pohTop = poh;
                    poh    = pohTop->pohDown;
                }

                if (cxLeft > 0)
                {
                    if (!bFreeRightAndBottomSpace(ppdev, poh, cxLeft, poh->cy,
                                                  TRUE))
                    {
                        pohFree(ppdev, pohTop);
                        return(NULL);
                    }

                    pohLeft = poh;
                    poh     = pohLeft->pohRight;
                }

                ASSERTDD((poh->x == pptl->x) &&
                         (poh->y == pptl->y) &&
                         (poh->x + poh->cx >= poh->x + cxThis) &&
                         (poh->y + poh->cy >= poh->y + cyThis),
                        "poh must properly fit requested rectangle");

                // Finally, we can subdivide to get our requested rectangle:

                if (!bFreeRightAndBottomSpace(ppdev, poh, cxThis, cyThis, FALSE))
                {
                    poh = NULL;         // Fail this call
                }

                // Free our temporary rectangles, if there are any:

                pohFree(ppdev, pohTop);
                pohFree(ppdev, pohLeft);

                return(poh);
            }
        }
    }

    // There was no free rectangle that completely contains the requested
    // rectangle:

    return(NULL);
}

/******************************Public*Routine******************************\
* OH* pohMakeRoomAnywhere
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohMakeRoomAnywhere(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLONG   floh)               // May have FLOH_ONLY_IF_ROOM set
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use
    GLINT_DECL;

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):
    cxThis = (cxThis + (HEAP_X_ALIGNMENT_P3[ppdev->cPelSize] - 1)) & 
               ~(HEAP_X_ALIGNMENT_P3[ppdev->cPelSize] - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxBounds) || (cyThis > ppdev->heap.cyBounds)) 
    {
        DISPDBG((WRNLVL, "Can't allocate (%d x %d) from (%d x %d)!",
                 cxThis, cyThis, ppdev->heap.cxBounds, ppdev->heap.cyBounds));
        return(NULL);
    }

    // Find the first available rectangle the same size 
    // or larger than the requested one:
    cxcyThis = CXCY(cxThis, cyThis);

    pohThis = GetFreeNode(ppdev, cxThis, cyThis);
    if(pohThis == NULL)
    {
        DISPDBG((WRNLVL, "pohMakeRoomAnywhere: "
                         "error, GetFreeNode() returned NULL"));
        return(NULL);
    }

    ASSERTDD(pohThis->ohState == OH_FREE, "Non-free node in free list(9)");

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
        {
            return(NULL);
        }

        DISPDBG((DBGLVL, "> Making room for %li x %li allocation...", 
                         cxThis, cyThis));

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room, oldest allocations first:

        do {
            // (Least-recently created)
            pohThis = ppdev->heap.ohDiscardable.pohPrev;  
            if (pohThis == &ppdev->heap.ohDiscardable)
            {
                return(NULL);
            }

            ASSERTDD(pohThis != &ppdev->heap.ohDiscardable,
                     "Ran out of discardable entries -- Max not set correctly");
            ASSERTDD(pohThis->ohState == OH_DISCARDABLE,
                     "Non-discardable node in discardable list");

            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
            {
                return(NULL);
            }

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    if ((pohThis->cxReserved) && (floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)))
    {
        // We can't reserve this rectangle, or make it permanent, if it's
        // already been reserved.  So throw absolutely everything out and
        // search the free list.
        //
        // NOTE: This is extremely painful!  A better approach would be to
        //       keep separate 'cxMax' and 'cyMax' variables kept for free
        //       rectangles that are not reserved (cxMax and cyMax
        //       currently include reserved free rectangles).

        if (!bDiscardEverythingInRectangle(ppdev, 0, 0,
                                           ppdev->cxMemory, ppdev->cyMemory))
        {
            return(NULL);
        }

        pohThis = &ppdev->heap.ohFree;
        do {
            pohThis = pohThis->pohNext;

            if (pohThis == &ppdev->heap.ohFree)
            {
                return(NULL);
            }

        } // the free list isn't ordered if the heap is DX managed
          while ((ppdev->flStatus & STAT_LINEAR_HEAP) == 0 && 
                 ((pohThis->cxReserved)  ||
                  (pohThis->cx < cxThis) ||
                  (pohThis->cy < cyThis)));
    }

    if((ppdev->flStatus & STAT_LINEAR_HEAP) == 0)
    {
        if (!bFreeRightAndBottomSpace(ppdev, pohThis, cxThis, cyThis, FALSE))
        {
            return(NULL);
        }
    }

    return(pohThis);
}

/******************************Public*Routine******************************\
* BOOL bOhCommit
*
* If 'bCommit' is TRUE, converts a 'reserved' allocation to 'permanent,'
* moving from off-screen memory any discardable allocations that may have
* been using the space.
*
* If 'bCommit' is FALSE, converts a 'permanent' allocation to 'reserved,'
* allowing the space to be used by discardable allocations.
*
\**************************************************************************/

BOOL bOhCommit(
PDEV*   ppdev,
OH*     poh,
BOOL    bCommit)
{
    BOOL    bRet;
    LONG    cx;
    LONG    cy;
    ULONG   cxcy;
    OH*     pohRoot;
    OH*     pohNext;
    OH*     pohPrev;

    bRet = FALSE;       // Assume failure

    if (poh == NULL)
    {
        return(bRet);
    }

    if ((bCommit) && (poh->cxReserved))
    {
        if (bDiscardEverythingInRectangle(ppdev, poh->x, poh->y,
                                          poh->cxReserved, poh->cyReserved))
        {
            DISPDBG((DBGLVL, "Commited %li x %li at (%li, %li)",
                        poh->cx, poh->cy, poh->x, poh->y));

            poh->ohState = OH_PERMANENT;

            // Remove this node from the free list:

            poh->pohPrev->pohNext = poh->pohNext;
            poh->pohNext->pohPrev = poh->pohPrev;

            // Now insert the node at the head of the permanent list:

            pohRoot = &ppdev->heap.ohPermanent;

            poh->pohNext = pohRoot->pohNext;
            poh->pohPrev = pohRoot;

            pohRoot->pohNext->pohPrev = poh;
            pohRoot->pohNext          = poh;

            bRet = TRUE;
        }
    }
    else if ((!bCommit) && (poh->ohState == OH_PERMANENT))
    {
        DISPDBG((DBGLVL, "Decommited %li x %li at (%li, %li)",
                    poh->cx, poh->cy, poh->x, poh->y));

        poh->ohState    = OH_FREE;
        poh->cxReserved = poh->cx;
        poh->cyReserved = poh->cy;

        // Remove this node from the permanent list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;

        // Now insert the node, in order, into the free list:

        cxcy = poh->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = poh;
        pohNext->pohPrev    = poh;
        poh->pohPrev        = pohPrev;
        poh->pohNext        = pohNext;

        bRet = TRUE;
    }

    // Recalculate the biggest rectangle available for allocation:
    vCalculateMaximumNonPermanent(ppdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF   *pdsurf;
    HBITMAP hbmDib;
    SURFOBJ *pso;
    GLINT_DECL;

    DISPDBG((DBGLVL, "Throwing out poh %p -- %li x %li at (%li, %li)!",
                  poh, poh->cx, poh->cy, poh->x, poh->y));

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0 || poh->bDXManaged),
            "Can't make the visible screen into a DIB");
    ASSERTDD((pdsurf->dt & DT_DIB) == 0,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                UploadDFBToDIB(ppdev, pso, pdsurf);

                // delete the screen DIB. Recreate it when 
                // we change the DIB back to a DFB
                vDeleteScreenDIBFromOH(poh);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;
                pdsurf->poh   = NULL;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}


/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    // Throw out any discardable bitmaps over the entire surface:

    return(bDiscardEverythingInRectangle(ppdev, 0, 0,
                                         ppdev->cxMemory, ppdev->cyMemory));
}


/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates a rectangle in off-screen memory.
*
* Types:
*
*   FLOH_RESERVE
*
*     Reserves an off-screen rectangle.  The space may still be used by
*     discardable bitmaps until the rectangle is committed via 'bOhCommit'.
*
*   FLOH_MAKE_PERMANENT
*
*     Allocates an off-screen rectangle that can never be booted
*     of the heap.   It's the caller's responsibility to manage
*     the rectangle, which includes what to do with the memory in
*     DrvAssertMode when the display is changed to full-screen
*     mode.
*
*   Default
*
*     Allocates a 'discardable' off-screen rectangle for a DFB that may
*     be  kicked out of off-screen if the space is needed.
*
* Options:
*
*   FLOH_ONLY_IF_ROOM
*
*     Allocates an off-screen rectangle only if there is free space
*     available -- i.e., no discardable rectangles will be moved out of
*     off-screen to make room.
*
*   Default
*
*     May move discardable rectangles out of off-screen to make room.
*
* Arguments:
*
*   pptl
*
*     If NULL, the rectangle will be allocated anywhere in un-used offscreen
*     memory.
*
*     If non-NULL, is a requested position for the rectangle.
*
*     NOTE: The heap will quickly fragment if arbitrary positions are
*           requested.  This position option works best if there is only
*           one specific rectangle ever requested, or if the allocations
*           are always wider than they are high.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
POINTL* pptl,           // Optional requested position of rectangle
LONG    cxThis,         // Width of rectangle to be allocated
LONG    cyThis,         // Height of rectangle to be allocated
FLOH    floh)           // Allocation flags
{
    OH*     pohThis;    // Points to found available rectangle we'll use
    OH*     pohRoot;    // Point to root of list where we'll insert node
    ULONG   cxcy;
    OH*     pohNext;
    OH*     pohPrev;

    ASSERTDD((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT))
                  != (FLOH_RESERVE | FLOH_MAKE_PERMANENT),
             "Illegal flags -- can't set both "
             "FLOH_RESERVE and FLOH_MAKE_PERMANENT");

    DISPDBG((DBGLVL, "pohAllocate: size  %d %d", cxThis, cyThis));

    if (pptl == NULL)
    {
        pohThis = pohMakeRoomAnywhere(ppdev, cxThis, cyThis, floh);
        if (pohThis == NULL)
        {
            DISPDBG((DBGLVL, "Can't allocate %li x %li with flags %li",
                             cxThis, cyThis, floh));
        }
    }
    else
    {
        pohThis = pohMakeRoomAtLocation(ppdev, pptl, cxThis, cyThis, floh);
        if (pohThis == NULL)
        {
            DISPDBG((DBGLVL, "Can't allocate %li x %li at %li, "
                             "%li with flags %li",
                             cxThis, cyThis, pptl->x, pptl->y, floh));
        }
    }

    if (pohThis == NULL)
    {
        return(NULL);
    }

    // Calculate the effective start address for this bitmap in off-
    // screen memory:

    if(pohThis->bDXManaged)
    {
        // in the linear coordinate system: 
        // pixOffset == offset of DFB from the start of the FB
        // y == scanline offset from pixOffset (always 0)
        // x == pixel offset from pixOffset+y*lDelta 
        // (always the pixel offset from the nearest dword aligned pixel)
        pohThis->pvScan0 = ppdev->pjScreen + 
                           ( ( pohThis->pixOffset              + 
                               pohThis->y * pohThis->lPixDelta + 
                               pohThis->x) 
                             << ppdev->cPelSize );
    }
    else
    {
        // in the rectangular coordinate system, for non-PX/RX chips: 
        // pixOffset == value of y expressed in pixels from the start of FB
        // y == pixOffset / lDelta (lDelta is always cxMemory)
        // x == pixel offset to DFB from the beginning of its scanline.
        // For PX/RX chips pixOffset is always 0, y is the number of scanlines 
        // to the DFB from the start of the FB
        pohThis->pvScan0 = ppdev->pjScreen + 
                           ( ( pohThis->y * pohThis->lPixDelta + 
                               pohThis->x) 
                             << ppdev->cPelSize );
    }

    // The caller is responsible for setting this field:

    pohThis->pdsurf = NULL;

    // Our 'reserve' logic expects the node to have 'free' status:

    ASSERTDD(pohThis->ohState == OH_FREE, "Node not free after making room");
    ASSERTDD(((floh & (FLOH_RESERVE | FLOH_MAKE_PERMANENT)) == 0) ||
             (pohThis->cxReserved == 0),
             "Can't reserve a rectangle that's already reserved");

    if (floh & FLOH_RESERVE)
    {

        ASSERTDD((ppdev->flStatus & STAT_LINEAR_HEAP) == FALSE, 
                  "pohAllocate() - can't reserve when the heap is DX managed");

        // A non-zero value for 'cxReserved' means it's reserved:

        pohThis->cxReserved = pohThis->cx;
        pohThis->cyReserved = pohThis->cy;

        // Remove this node from its place in the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        // Now insert the node, in order, back into the free list:

        cxcy = pohThis->cxcy;

        pohNext = ppdev->heap.ohFree.pohNext;
        
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext = pohThis;
        pohNext->pohPrev = pohThis;
        pohThis->pohPrev = pohPrev;
        pohThis->pohNext = pohNext;
    }
    else
    {
        // Remove this node from the free list:

        pohThis->pohPrev->pohNext = pohThis->pohNext;
        pohThis->pohNext->pohPrev = pohThis->pohPrev;

        if (floh & FLOH_MAKE_PERMANENT)
        {
            // Change status of node and insert into permanent list:

            pohThis->ohState = OH_PERMANENT;
            pohRoot = &ppdev->heap.ohPermanent;

            // Calculate the new maximum size rectangle available
            // for allocation:

            vCalculateMaximumNonPermanent(ppdev);
        }
        else
        {
            // Change status of node and insert into discardable list:

            pohThis->ohState = OH_DISCARDABLE;
            pohRoot = &ppdev->heap.ohDiscardable;
        }

        // Now insert the node at the head of the appropriate list:

        pohThis->pohNext = pohRoot->pohNext;
        pohThis->pohPrev = pohRoot;

        pohRoot->pohNext->pohPrev = pohThis;
        pohRoot->pohNext          = pohThis;
    }

    DISPDBG((DBGLVL, "   Allocated (%li x %li) at (%li, %li) with flags %li",
                cxThis, cyThis, pohThis->x, pohThis->y, floh));

    return(pohThis);
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG   cxcy;
    OH*     pohBeside;
    OH*     pohNext;
    OH*     pohPrev;
    OHSTATE oldState;

    if (poh == NULL)
    {
        DISPDBG((WRNLVL, "pohFree: passed in NULL poh"));
        return(NULL);
    }

    DISPDBG((DBGLVL, "Freeing poh %p -- %li x %li at (%li, %li)", 
                     poh, poh->cx, poh->cy, poh->x, poh->y));

    oldState = poh->ohState;
    if (oldState != OH_DISCARDABLE)
    {
        // We can remove the 'reserved' status unless we are merely
        // deleting a discardable rectangle that was temporarily
        // placed in a reserve rectangle:

        poh->cxReserved = 0;
        poh->cyReserved = 0;
    }

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

    if(poh->bDXManaged)
    {
#if WNT_DDRAW
        
        DISPDBG((DBGLVL, "pohFree: calling DX free for item %p on heap %p", 
                (VOID *)poh->fpMem, poh->pvmHeap));
                
        if(poh->pvmHeap == NULL)
        {
            DISPDBG((ERRLVL,"pohFree: poh %p -- linear DFB is invalid!", poh));
        }
        else
        {
            _DX_LIN_FreeLinearMemory(poh->pvmHeap, (ULONG)(poh->fpMem) );
            poh->pvmHeap = NULL;
            poh->fpMem = 0;
            
#if 1 //azntst for MP leak      
            // Remove this node from whatever list it's in:
            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            // Add the node the the list of free nodes
            vOhFreeNode(ppdev, poh);      

            // Set the current state as FREE
            poh->ohState     = OH_FREE;
            
            return(poh);             // with DX managing it, we can return now.
#endif               
        }
#endif // WNT_DDRAW

     
        goto MergeComplete; //azntst Now a NOP
    }


MergeLoop:

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((poh->cxReserved    != poh->cx)         &&
        (pohBeside->ohState == OH_FREE)         &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the free list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((poh->cyReserved     != poh->cy)        &&
        (pohBeside->ohState  == OH_FREE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Don't do any more merge this rectangle into anything to the
    // top or to the left if it's reserved:

    if (!poh->cxReserved)
    {
        // Try merging with the left sibling:

        pohBeside = poh->pohLeft;
        if ((pohBeside->cxReserved != pohBeside->cx) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cy         == poh->cy)       &&
            (pohBeside->pohUp      == poh->pohUp)    &&
            (pohBeside->pohDown    == poh->pohDown)  &&
            (pohBeside->pohRight   == poh)           &&
            (poh->pohRight->pohLeft != poh))
        {
            // We add our rectangle to the one to the left:

            pohBeside->cx      += poh->cx;
            pohBeside->pohRight = poh->pohRight;

            // Remove 'poh' from whatever list it was in (if we were
            // asked to free a 'permanent' node, it will have been in
            // the permanent list) and free it:

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }

        // Try merging with the upper sibling:

        pohBeside = poh->pohUp;
        if ((pohBeside->cyReserved != pohBeside->cy) &&
            (pohBeside->ohState    == OH_FREE)       &&
            (pohBeside->cx         == poh->cx)       &&
            (pohBeside->pohLeft    == poh->pohLeft)  &&
            (pohBeside->pohRight   == poh->pohRight) &&
            (pohBeside->pohDown    == poh)           &&
            (poh->pohDown->pohUp != poh))
        {
            pohBeside->cy      += poh->cy;
            pohBeside->pohDown  = poh->pohDown;

            poh->pohNext->pohPrev = poh->pohPrev;
            poh->pohPrev->pohNext = poh->pohNext;

            vOhFreeNode(ppdev, poh);

            poh = pohBeside;
            goto MergeLoop;
        }
    }

MergeComplete:

    // Remove this node from whatever list it's in:

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node, in order, into the free list:
    // NB. DX managed DFBs don't need to go in any order - 
    // they are organised by DirectX instead

    pohNext = ppdev->heap.ohFree.pohNext;
    if(!poh->bDXManaged)
    {
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext = poh;
    pohNext->pohPrev = poh;
    poh->pohPrev     = pohPrev;
    poh->pohNext     = pohNext;
    poh->cxcy        = cxcy;
    poh->ohState     = OH_FREE;

    if (oldState == OH_PERMANENT)
    {
        // Removing the permanent entry means that we may be able to
        // enlarge the maximum possible rectangle we can allow:

        vCalculateMaximumNonPermanent(ppdev);
    }

    // Return the node pointer for the new and improved available rectangle:

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bCreateScreenDIBForOH
*
* Given an OH create a surface for the bitmap which is accessible by GDI.
* So if we can't handle any drawing using GLINT we can get GDI to draw
* driectly to the screen. This is possible because we map the screen in
* fully and linearly. We can use this for the screen and off-screen bitmaps.
*
* Returns: FALSE if we didn't create the surface, TRUE if we did.
*
\**************************************************************************/

BOOL
bCreateScreenDIBForOH(PPDEV ppdev, OH *poh, ULONG hooks)
{
    DSURF   *pdsurf = poh->pdsurf;
    UCHAR   *pvBits = poh->pvScan0;
    LONG    lDelta = poh->lPixDelta << ppdev->cPelSize;
    HBITMAP hbmDib;
    SURFOBJ *pso;    

    DISPDBG((DBGLVL, "bCreateScreenDIBForOH: poh at 0x%x, pdsurf at 0x%x, "
                     "pvBits 0x%x", poh, pdsurf, pvBits));

    hbmDib = EngCreateBitmap(pdsurf->sizl,
                            (ULONG)lDelta,
                            (ULONG)(ppdev->iBitmapFormat),
                            (FLONG)(((lDelta > 0) ? BMF_TOPDOWN : 0)),
                            (PVOID)pvBits);
    if (hbmDib) 
    {
        
        // set HOOK_SYNCHRONIZE so that GDI will call DrvSynchronize before
        // drawing on this surface. This means we can call Eng anytime safe
        // in the knowledge that DrvSynchronize will sync for us.
        //
        if (EngAssociateSurface((HSURF)hbmDib, ppdev->hdevEng, hooks))
        {            
            // NB: use the temporary pso so we don't overwrite pdsurf->pso 
            // if we fail
            if (pso = EngLockSurface((HSURF)hbmDib)) 
            {
                pdsurf->pso = pso;
                DISPDBG((DBGLVL, "created surface 0x%x", pso));
                return(TRUE);
            }
        }

        EngDeleteSurface((HSURF)hbmDib);
    }

    DISPDBG((DBGLVL, "bCreateScreenDIBForOH failed"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL vDeleteScreenDIBFromOH
*
* Given an OH delete any screen DIB surface associated with it. We choose to
* do a lazy creation of GDI accessible bitmaps for DFBs. So there may not be
* any surface to delete. 
*
* Returns:
*
\**************************************************************************/

VOID
vDeleteScreenDIBFromOH(OH *poh)
{
    DSURF   *pdsurf = poh->pdsurf;
    SURFOBJ *pso;
    HSURF   hsurf;

    DISPDBG((DBGLVL, "vDeleteScreenDIBFromOH called"));
    if (!(pso = pdsurf->pso)) 
    {
        DISPDBG((DBGLVL, "no surface to delete"));       
        return;
    }

    hsurf = pso->hsurf;         // can't dereference pso when unlocked
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);    // pdsurf->pso can now be reassigned 
                                // to a memory DIB
    DISPDBG((DBGLVL, "surface 0x%x deleted", pso));
}


/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    HSURF       hsurf;
    LONG        cy;

    ASSERTDD(pdsurf->dt & DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:
    if (!ppdev->bEnabled || !(ppdev->flStatus & STAT_DEV_BITMAPS))
    {
        return(FALSE);
    }

    // XXX
    // 
    // for the GeoTwin all off-screen bitmaps must start on an even scanline.
    // This is so that even coordinates always map to the same chip.
    cy = pdsurf->sizl.cy;
    if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
    {
        cy = (cy + 1) & ~1;
        DISPDBG((DBGLVL, "move: sizl.cy evened up to %d for GeoTwin", cy));
    }

    poh = pohAllocate(ppdev, NULL, pdsurf->sizl.cx, cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    poh->pdsurf   = pdsurf;
    pdsurf->poh   = poh;

    // recreate the screen DIB. Do it here so that if we fail we can zap poh and
    // leave the bitmap as a memory DIB.

    if (!bCreateScreenDIBForOH(ppdev, poh, HOOK_SYNCHRONIZE)) 
    {
        DISPDBG((DBGLVL, "bCreateScreenDIBForOH failed"));
        goto ReturnFail;
    }
    
    pdsurf->dt         = DT_SCREEN;
    pdsurf->bOffScreen = TRUE;
    DownloadDIBToDFB(ppdev, pso, pdsurf);

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):
    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);

ReturnFail:
    pohFree(ppdev, poh);
    DISPDBG((DBGLVL, "bMoveDibToOffscreenDfbIfRoom failed"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev = (PDEV*) dhpdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    FLONG   flHooks;
    LONG    cy = sizl.cy;
    LONG    cx = sizl.cx;
    GLINT_DECL;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.
    // Also check that off-screen DFBs are configured.

    if (!ppdev->bEnabled || !(ppdev->flStatus & STAT_DEV_BITMAPS))
    {
        return(0);
    }

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
    {
        DISPDBG((DBGLVL, "DrvCreateDeviceBitmap(): can't create bitmap of "
                         "format %d size(%d,%d), only bitmaps of format %d "
                         "supported!", iFormat, cx, cy, ppdev->iBitmapFormat));
        return(0);
    }

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:

    if ((cx <= 8) && (cy <= 8))
    {
        return(0);
    }

    // XXX
    // 
    // for the GeoTwin all off-screen bitmaps must start on an even scanline.
    // This is so that even coordinates always map to the same chip.
    if (ppdev->flCaps & CAPS_SPLIT_FRAMEBUFFER)
    {
        cy = (cy + 1) & ~1;
        DISPDBG((DBGLVL, "create: sizl.cy evened up to %d for GeoTwin", cy));
    }

    if(ppdev->pohImageDownloadArea)
    {
        DISPDBG((DBGLVL, "DrvCreateDeviceBitmap: discarding image download "
                         "scratch area"));
        pohFree(ppdev, ppdev->pohImageDownloadArea);
        ppdev->pohImageDownloadArea = NULL;
        ppdev->cbImageDownloadArea = 0;
    }

    poh = pohAllocate(ppdev, NULL, cx, cy, 0);
    if (poh != NULL)
    {
        pdsurf = ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG_GDI(E));
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                flHooks = ppdev->flHooks;

                #if SYNCHRONIZEACCESS_WORKS && (_WIN32_WINNT < 0x500)
                {
                // Setting the SYNCHRONIZEACCESS flag tells GDI that we
                // want all drawing to the bitmaps to be synchronized (GDI
                // is multi-threaded and by default does not synchronize
                // device bitmap drawing -- it would be a Bad Thing for us
                // to have multiple threads using the accelerator at the
                // same time):

                flHooks |= HOOK_SYNCHRONIZEACCESS;
                }
                #endif // SYNCHRONIZEACCESS_WORKS && (_WIN32_WINNT < 0x500)

                // It's a device-managed surface; make sure we don't set
                // HOOK_SYNCHRONIZE, otherwise we may confuse GDI:

                flHooks &= ~HOOK_SYNCHRONIZE;

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->bOffScreen = TRUE;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    // create the GDI accessible screen bitmap
                    if (bCreateScreenDIBForOH(ppdev, poh, HOOK_SYNCHRONIZE)) 
                    {
                        DISPDBG((DBGLVL, "DFB created at (%d,%d), w %d, h %d",
                            poh->x, poh->y, poh->cx, poh->cy));

                        return(hbmDevice);
                    }

                    EngDeleteSurface((HSURF) hbmDevice);

                    // Once association is done, EngDeleteSurface
                    // callback driver's DrvDeleteDeviceBitmap,
                    // then pdsurf and poh are freed there, so that
                    // we don't need to free it here.
                }
                else
                {
                    EngDeleteSurface((HSURF) hbmDevice);
                    ENGFREEMEM(pdsurf);
                    pohFree(ppdev, poh);
                }
            }
            else
            {
                ENGFREEMEM(pdsurf);
                pohFree(ppdev, poh);
            }
        }
        else
        {
            pohFree(ppdev, poh);
        }
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if ((pdsurf->dt & DT_DIB) ||
        (pdsurf->dt & DT_DIRECTDRAW))
    {
        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }
    else if (pdsurf->dt & DT_SCREEN)
    {
        vDeleteScreenDIBFromOH(pdsurf->poh);
        pohFree(ppdev, pdsurf->poh);
    }

    ENGFREEMEM(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        ENGFREEMEM(poha);
        poha = pohaNext;
    }

    // the linear heap, if enabled, must be disabled now
    ppdev->flStatus &= ~STAT_LINEAR_HEAP;

}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*         poh;
    SIZEL       sizl;
    HSURF       hsurf;
    POINTL      ptlScreen;
    LONG        virtualcxMemory;
    GLINT_DECL;

    virtualcxMemory = ppdev->cxMemory;

    DISPDBG((DBGLVL, "Screen: %li x %li  Memory: %li x %li, "
                     "virtualcxMem %li x %li", ppdev->cxScreen, 
                     ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory, 
                     virtualcxMemory));

    ASSERTDD((ppdev->cxScreen <= virtualcxMemory) &&
             (ppdev->cyScreen <= ppdev->cyMemory),
             "Memory must not have smaller dimensions than visible screen!");

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
    {
        goto ReturnFalse;
    }

    // The first node describes the entire video memory size:

    poh->pohNext      = &ppdev->heap.ohFree;
    poh->pohPrev      = &ppdev->heap.ohFree;
    poh->ohState      = OH_FREE;
    poh->x            = 0;
    poh->y            = 0;
    poh->lPixDelta    = ppdev->cxMemory;
    poh->cx           = virtualcxMemory;
    poh->cy           = ppdev->cyMemory;
    poh->cxcy         = CXCY(virtualcxMemory, ppdev->cyMemory);
    poh->pohLeft      = &ppdev->heap.ohFree;
    poh->pohUp        = &ppdev->heap.ohFree;
    poh->pohRight     = &ppdev->heap.ohFree;
    poh->pohDown      = &ppdev->heap.ohFree;
    poh->pvScan0      = ppdev->pjScreen;
    poh->pixOffset    = 0;

    // The second node is our free list sentinel:

    ppdev->heap.ohFree.pohNext         = poh;
    ppdev->heap.ohFree.pohPrev         = poh;
    ppdev->heap.ohFree.cxcy            = CXCY_SENTINEL;
    ppdev->heap.ohFree.cx              = 0x7fffffff;
    ppdev->heap.ohFree.cy              = 0x7fffffff;
    ppdev->heap.ohFree.ohState         = OH_FREE;

    // Initialize the discardable list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.
    // This node is also used for the screen-surface, for its offset:

    ppdev->heap.ohDiscardable.pohNext = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.pohPrev = &ppdev->heap.ohDiscardable;
    ppdev->heap.ohDiscardable.ohState = OH_DISCARDABLE;

    // Initialize the permanent list, which will be a circular
    // doubly-linked list kept in order, with a sentinel at the end.

    ppdev->heap.ohPermanent.pohNext = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.pohPrev = &ppdev->heap.ohPermanent;
    ppdev->heap.ohPermanent.ohState = OH_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

#if (_WIN32_WINNT >= 0x500)

    if(ppdev->flStatus & ENABLE_LINEAR_HEAP)
    {
        // in Windows 2000 we use the DX linear heap for DFBs. 
        // NB. the DX heaps aren't initialized until after the display 
        //     driver has initialized, therefore
        //     we use the old rectangular heap for 2D cache allocation.
        ppdev->heap.pvmLinearHeap = NULL;
        ppdev->heap.cLinearHeaps = 0;
    }

#endif //(_WIN32_WINNT >= 0x500)

    ptlScreen.x = 0;
    ptlScreen.y = 0;

    // Finally, reserve the upper-left corner for the screen.  We can
    // actually throw away 'poh' because we'll never need it again
    // (not even for disabling the off-screen heap since everything is
    // freed using OHALLOCs):

    poh = pohAllocate(ppdev, &ptlScreen, ppdev->cxScreen, ppdev->cyScreen,
                      FLOH_MAKE_PERMANENT);

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0) &&
             (poh->cx >= ppdev->cxScreen) && (poh->cy >= ppdev->cyScreen),
             "Screen allocation messed up");

    // Remember it so that we can associate the screen SURFOBJ with this
    // poh:

    ppdev->pohScreen = poh;

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = virtualcxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same capabilities
    // as our primary surface.  We will override the 'lDelta' and 'pvScan0'
    // fields later:

    // We do NOT want to hook any of the drawing functions.  Once we
    // send this surface into the engine, we don't want the driver to
    // get called with it again.  Otherwise we could get into a situation
    // where both the source and dest SURFOBJs for a blt were marked as DIBs.

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((DBGLVL, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((DBGLVL, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((DBGLVL, "Passed bEnableOffscreenHeap"));

    // enable off-screen bitmaps by if configured
    if (ppdev->flStatus & ENABLE_DEV_BITMAPS)
    {
        ppdev->flStatus |= STAT_DEV_BITMAPS;
    }

    if (poh != NULL)
    {
        return(TRUE);
    }

ReturnFalse:

    DISPDBG((DBGLVL, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL vDisable2DOffscreenMemory
*
* 3D apps want to use the offscreen memory. Prevent 2D from using it.
\**************************************************************************/

BOOL bDisable2DOffscreenMemory(PDEV* ppdev)
{
    GLINT_DECL;
    
    if (ppdev->Disable2DCount++ > 0)
    {
        return(TRUE);
    }

    if (ppdev->flStatus & STAT_DEV_BITMAPS)
    {
        if (!bMoveAllDfbsFromOffscreenToDibs(ppdev))
        {
            DISPDBG((DBGLVL, "bDisable2DOffscreenMemory failed"));
            return FALSE;
        }
        ppdev->flStatus &= ~STAT_DEV_BITMAPS;
    }
    
    return TRUE;
}

/******************************Public*Routine******************************\
* VOID vEnable2DOffscreenMemory
*
* 3D apps no longer need offscreen memory. Use it for 2D instead.
\**************************************************************************/

VOID vEnable2DOffscreenMemory(PDEV *ppdev)
{
    GLINT_DECL;

    if (--ppdev->Disable2DCount > 0)
    {
        return;
    }

    if (ppdev->flStatus & ENABLE_DEV_BITMAPS)
    {
        ppdev->flStatus |= STAT_DEV_BITMAPS;
    }
}

#if !defined(_WIN64) && WNT_DDRAW

/******************************Public*Routine******************************\
* VOID vSurfUsed
*
* Notify the heap manager that this surface is touched and it should be
* moved to the end of DdFreeDriverMemory's priority queue 
\**************************************************************************/
VOID vSurfUsed(SURFOBJ *psoSurf)
{
    DSURF* pSurf;
    OH* pohSurf;
    OH* pohHead;
 
    // When psoSurf is the original source surface, it can be NULL
    if (! psoSurf) 
    {
        return;
    }

    // Cast the dhsurf back to the Perm3 GDI surface pointer
    pSurf = (DSURF *)psoSurf->dhsurf;

    // If the surface is a DIB managed by the driver, it shoulf be ignored
    if ((! pSurf) || (pSurf->dt & (DT_DIB | DT_DIRECTDRAW)))
    {
        return;
    }

    // Get the heap node pointer for the surface
    pohSurf = pSurf->poh;

    // Only surface in the discardable chain should be considered
    if ((! pSurf->bOffScreen) || (pohSurf->ohState != OH_DISCARDABLE))
    {
        return;
    }

    // Get the head of the discardable surface chain
    pohHead = &pSurf->ppdev->heap.ohDiscardable;

    // It is quite possible that the surface is already at the end of the queue
    if (pohSurf->pohNext == pohHead)
    {
        return;
    }

    // Remove the surf the priority queue
    pohSurf->pohPrev->pohNext = pohSurf->pohNext;    
    pohSurf->pohNext->pohPrev = pohSurf->pohPrev;

    // Link the surf into the priority queue at the end
    pohSurf->pohPrev = pohHead->pohPrev;
    pohSurf->pohNext = pohHead;

    pohSurf->pohPrev->pohNext = pohSurf;
    pohHead->pohPrev = pohSurf;
}


/******************************Callback*Routine****************************\
* DWORD DdFreeDriverMemory
*
* This function called by DirectDraw when it's running low on memory in
* our heap.  You only need to implement this function if you use the
* DirectDraw 'HeapVidMemAllocAligned' function in your driver, and you
* can boot those allocations out of memory to make room for DirectDraw.
*
* We implement this function in the P3 driver because we have DirectDraw
* entirely manage our off-screen heap, and we use HeapVidMemAllocAligned
* to put GDI device-bitmaps in off-screen memory.  DirectDraw applications
* have a higher priority for getting stuff into video memory, though, and
* so this function is used to boot those GDI surfaces out of memory in
* order to make room for DirectDraw.
*
\**************************************************************************/
DWORD CALLBACK
DdFreeDriverMemory(PDD_FREEDRIVERMEMORYDATA lpFreeDriverMemory)
{
    PPDEV ppdev;
    OH* pohSurf;

    DISPDBG((DBGLVL, "DdFreeDriverMemory is called"));
    
    // Set the return value in case no VM is available
    lpFreeDriverMemory->ddRVal = DDERR_OUTOFMEMORY;

    // Get the head of discardable surface queue
    ppdev = (PPDEV)lpFreeDriverMemory->lpDD->dhpdev;
    pohSurf = ppdev->heap.ohDiscardable.pohNext;

    while (pohSurf != &ppdev->heap.ohDiscardable)
    {
        if (! pohSurf->bDXManaged)
        {
            pohSurf = pohSurf->pohNext;
            continue;
        }

        // Try to demote this VM bitmap to SM
        if (pohMoveOffscreenDfbToDib(ppdev, pohSurf))
        {
            lpFreeDriverMemory->ddRVal = DD_OK;
        }

        break;
    }

    return (DDHAL_DRIVER_HANDLED);
}


/******************************Callback*Routine****************************\
* DdSetExclusiveMode
*
* This function is called by DirectDraw when we switch from the GDI surface,
* to DirectDraw exclusive mode, e.g. to run a game in fullcreen mode.
* You only need to implement this function when you are using the
* 'HeapVidMemAllocAligned' function and allocate memory for Device Bitmaps
* and DirectDraw surfaces from the same heap.
*
* We use this call to disable GDI DeviceBitMaps when we are running in
* DirectDraw exclusive mode. Otherwise a DD app gets confused if both GDI and
* DirectDraw allocate memory from the same heap.
*
*
\**************************************************************************/
DWORD CALLBACK
DdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
    DISPDBG((DBGLVL, "DdSetExclusiveMode is called"));

    if (lpSetExclusiveMode->dwEnterExcl)
    {
        // Remove all GDI device bitmaps from video memory here
        // and make sure they will not be promoted to videomemory
        // until we leave exclusive mode.

        bMoveAllDfbsFromOffscreenToDibs(
            (PDEV*)lpSetExclusiveMode->lpDD->dhpdev);
    }

    lpSetExclusiveMode->ddRVal = DD_OK;

    return (DDHAL_DRIVER_HANDLED);
}


/******************************Callback*Routine****************************\
* DWORD DdFlipToGDISurface
*
* This function is called by DirectDraw when it flips to the surface on which
* GDI can write to.
\**************************************************************************/

#if DX7_STEREO
#define __VIDEO_STEREOENABLE    0x800
#endif

DWORD CALLBACK
DdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
    PDEV* ppdev = (PDEV *)lpFlipToGDISurface->lpDD->dhpdev;
    GLINT_DECL;
    
    DISPDBG((DBGLVL, "DdFlipToGDISurface is called"));

    lpFlipToGDISurface->ddRVal = DD_OK;

#if DX7_STEREO
    READ_GLINT_CTRL_REG(VideoControl, dwVideoControl);
    WRITE_GLINT_CTRL_REG(VideoControl, 
                         (dwVideoControl & (~__VIDEO_STEREOENABLE)));
#endif

    //
    //  Return NOTHANDLED, so that the ddraw runtime takes
    //  care that we flip back to the primary...
    //

    return (DDHAL_DRIVER_NOTHANDLED);
}

#endif

/*****************************Public*Routine*******************************\
*
* HBITMAP DrvDeriveSurface
*
* This function derives and creates a GDI surface from the specified
* DirectDraw surface.
*
* Parameters
*  pDirectDraw-----Points to a DD_DIRECTDRAW_GLOBAL structure that describes
*                  the DirectDraw object. 
*  pSurface--------Points to a DD_SURFACE_LOCAL structure that describes the
*                  DirectDraw surface around which to wrap a GDI surface.
*
* Return Value
*  DrvDeriveSurface returns a handle to the created GDI surface upon success.
*  It returns NULL if the call fails or if the driver cannot accelerate GDI
*  drawing to the specified DirectDraw surface.
*
* Comments
*  DrvDeriveSurface allows the driver to create a GDI surface around a
*  DirectDraw video memory or AGP surface object in order to allow accelerated
*  GDI drawing to the surface. If the driver does not hook this call, all GDI
*  drawing to DirectDraw surfaces is done in software using the DIB engine.
*
*  GDI calls DrvDeriveSurface with RGB surfaces only.
*
*  The driver should call DrvCreateDeviceBitmap to create a GDI surface of the
*  same size and format as that of the DirectDraw surface. Space for the
*  actual pixels need not be allocated since it already exists.
*
\**************************************************************************/

HBITMAP
DrvDeriveSurface(DD_DIRECTDRAW_GLOBAL*  pDirectDraw,
                 DD_SURFACE_LOCAL*      pSurface)
{
    PDEV*               ppdev;
    DSURF*              pdsurf;
    HBITMAP             hbmDevice;
    DD_SURFACE_GLOBAL*  pSurfaceGlobal;
    SIZEL               sizl;

    ppdev = (PDEV*)pDirectDraw->dhpdev;
    pSurfaceGlobal = pSurface->lpGbl;

    // Only accel. primary surface.

    if (pSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        pdsurf = (DSURF*)ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG_GDI(E));

        if (pdsurf != NULL)
        {
            sizl.cx = pSurfaceGlobal->wWidth;
            sizl.cy = pSurfaceGlobal->wHeight;

            hbmDevice = EngCreateDeviceBitmap((DHSURF)pdsurf,
                                               sizl,
                                               ppdev->iBitmapFormat);

            if ((hbmDevice != NULL) &&
                (EngAssociateSurface((HSURF)hbmDevice, ppdev->hdevEng, ppdev->flHooks)))
            {    
                PVOID   pvScan0 = ppdev->pjScreen + pSurfaceGlobal->fpVidMem;

                HBITMAP hbmDib = EngCreateBitmap(
                                     sizl,
                                     (ULONG) pSurfaceGlobal->lPitch,
                                     (ULONG)(ppdev->iBitmapFormat),
                                     (FLONG)(((pSurfaceGlobal->lPitch > 0) ? BMF_TOPDOWN : 0)),
                                     (PVOID) pvScan0);

                if ((hbmDib != NULL) &&
                    (EngAssociateSurface((HSURF)hbmDib, ppdev->hdevEng, HOOK_SYNCHRONIZE)))
                {
                    pdsurf->dt    = DT_SCREEN | DT_DIRECTDRAW;
                    pdsurf->bOffScreen = FALSE;
                    pdsurf->poh   = ppdev->pohScreen;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;

                    if (pdsurf->pso = EngLockSurface((HSURF)hbmDib)) 
                    {
                        return (hbmDevice);
                    }
                }

                if (hbmDib)
                {
                    EngDeleteSurface((HSURF)hbmDib);
                }
            }

            if (hbmDevice)
            {
                EngDeleteSurface((HSURF)hbmDevice);
            }

            ENGFREEMEM(pdsurf);
        }
    }

    return(0);

} // DrvDeriveSurface()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\lineto.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDISAMPLE CODE *
*                           *******************
*
* Module Name: LineTo.c
*
* Content: The code in this file handles the DrvLineTo() API call. 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix)
*
* DrvLineTo() is an optimised, integer co-ordinate, API call that doesn't
* support styling. The integer-line code in Strips.c is called to do the 
* hard work.
*
* Note that:
*   1. pco can be NULL.
*   2. we only handle simple clipping.
*
\**************************************************************************/

BOOL DrvLineTo(
    SURFOBJ*   pso,
    CLIPOBJ*   pco,
    BRUSHOBJ*  pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL      *prclBounds,
    MIX        mix)
{
    PDEV*     ppdev;
    DSURF*    pdsurf;
    BOOL      ResetGLINT;                   // Does GLINT need resetting?
    DWORD     logicOp;
    RECTL*    prclClip = (RECTL*) NULL;
    ULONG     iSolidColor = pbo->iSolidColor;
    BOOL      retVal;  
    GLINT_DECL_VARS;

    // Pass the surface off to GDI if it's a device bitmap 
    // that we've converted to a DIB 
    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt & DT_DIB)
    {
        return(EngLineTo(pdsurf->pso, 
                         pco, 
                         pbo, 
                         x1, 
                         y1, 
                         x2, 
                         y2, 
                         prclBounds, 
                         mix));
    }

    // Return to sender if the clipping is too difficult
    if (pco && pco->iDComplexity == DC_COMPLEX)
    {
        return(FALSE);
    }

    ppdev = (PDEV*) pso->dhpdev;
    GLINT_DECL_INIT;
    REMOVE_SWPOINTER(pso);

    DISPDBG((DBGLVL, "Drawing DrvLines through GLINT"));

    SETUP_PPDEV_OFFSETS(ppdev, pdsurf);

    // Set up the clipping rectangle, if there is one
    if (pco && pco->iDComplexity == DC_RECT)
    {
        prclClip = &(pco->rclBounds);
    }
    
    // Get the logic op.
    logicOp = GlintLogicOpsFromR2[mix & 0xff];

    // Need to set up Glint modes and colors appropriately for the line.
    ResetGLINT = (*ppdev->pgfnInitStrips)(ppdev, 
                                          iSolidColor, 
                                          logicOp, 
                                          prclClip);

    // We have to convert our integer co-ords to 28.4 fixed points.
    retVal = ppdev->pgfnIntegerLine(ppdev, 
                                    x1 << 4,
                                    y1 << 4, 
                                    x2 << 4, 
                                    y2 << 4);

    // If we have to restore the state then... do it.
    if (ResetGLINT)
    {
        (*ppdev->pgfnResetStrips)(ppdev);
    }

    return (retVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\p3rd.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: p3rd.h
*
* Content: This module contains the definitions for the P2ST internal RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define VideoDebugPrint

//
// 3Dlabs P3RD RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _p3rd_regs
{
    RAMDAC_REG  RDPaletteWriteAddress;
    RAMDAC_REG  RDPaletteData;
    RAMDAC_REG  RDPixelMask;
    RAMDAC_REG  RDPaletteAddressRead;
    RAMDAC_REG  RDIndexLow;
    RAMDAC_REG  RDIndexHigh;
    RAMDAC_REG  RDIndexedData;
    RAMDAC_REG  RDIndexControl;

} P3RDRAMDAC, *pP3RDRAMDAC;

// structure containing the mapped addresses for each of the P3RD registers.
// We need this since some chips like the Alpha cannot be accessed by simply
// writing to the memory mapped register. So instead we set up the following
// struct of memory addresses at init time and use these instead. All these
// addresses must be passed to WRITE/READ_FAST_ULONG.
// We also keep software copies of various registers in here so we can turn
// on and off individual bits more easily.
//
typedef struct _p3rd_data {

    // register addresses

    ULONG * RDPaletteWriteAddress;
    ULONG * RDPaletteData;
    ULONG * RDPixelMask;
    ULONG * RDPaletteAddressRead;
    ULONG * RDIndexLow;
    ULONG * RDIndexHigh;
    ULONG * RDIndexedData;
    ULONG * RDIndexControl;

    // RAMDAC state info
    ULONG       cursorModeOff;        // cursor disabled
    ULONG       cursorModeCurrent;    // disabled 32/64 mode cursor 
    ULONG       cursorControl;        // x & y zoom, etc.
    ULONG       cursorSize;            // see P3RD_CURSOR_SIZE_*
    ULONG       x, y;
} P3RDData, *pP3RDData;


// macro declared by any function wishing to use the P2ST internal RAMDAC . MUST be declared
// after GLINT_DECL.
//
#define P3RD_DECL_VARS pP3RDData pP3RDinfo
#define P3RD_DECL_INIT pP3RDinfo = (pP3RDData)(ppdev->pvPointerData = &ppdev->ajPointerData[0])

#define P3RD_DECL \
            P3RD_DECL_VARS; \
            P3RD_DECL_INIT

// use the following macros as the address to pass to the
// WRITE_P3RDREG_ULONG function
//
//  Palette Access
#define P3RD_PAL_WR_ADDR            (pP3RDinfo->RDPaletteWriteAddress)
#define P3RD_PAL_RD_ADDR            (pP3RDinfo->RDPaletteAddressRead)
#define P3RD_PAL_DATA               (pP3RDinfo->RDPaletteData)

// Pixel mask
#define P3RD_PIXEL_MASK             (pP3RDinfo->RDPixelMask)

// Access to the indexed registers
#define P3RD_INDEX_ADDR_LO          (pP3RDinfo->RDIndexLow)
#define P3RD_INDEX_ADDR_HI          (pP3RDinfo->RDIndexHigh)
#define P3RD_INDEX_DATA             (pP3RDinfo->RDIndexedData)
#define P3RD_INDEX_CONTROL          (pP3RDinfo->RDIndexControl)


// bit field definitions for the direct access registers
#define P3RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

// indexed register definitions accessed via P3RD_LOAD_INDEX_REG() and P3RD_READ_INDEX_REG()
#define P3RD_MISC_CONTROL               0x0000
#define P3RD_SYNC_CONTROL               0x0001
#define P3RD_DAC_CONTROL                0x0002
#define P3RD_PIXEL_SIZE                 0x0003
#define P3RD_COLOR_FORMAT               0x0004
#define P3RD_CURSOR_MODE                0x0005
#define P3RD_CURSOR_CONTROL             0x0006
#define P3RD_CURSOR_X_LOW               0x0007
#define P3RD_CURSOR_X_HIGH              0x0008
#define P3RD_CURSOR_Y_LOW               0x0009
#define P3RD_CURSOR_Y_HIGH              0x000a
#define P3RD_CURSOR_HOTSPOT_X           0x000b
#define P3RD_CURSOR_HOTSPOT_Y           0x000c
#define P3RD_OVERLAY_KEY                0x000d
#define P3RD_PAN                        0x000e
#define P3RD_SENSE                      0x000f
#define P3RD_CHECK_CONTROL              0x0018
#define P3RD_CHECK_PIXEL_RED            0x0019
#define P3RD_CHECK_PIXEL_GREEN          0x001a
#define P3RD_CHECK_PIXEL_BLUE           0x001b
#define P3RD_CHECK_LUT_RED              0x001c
#define P3RD_CHECK_LUT_GREEN            0x001d
#define P3RD_CHECK_LUT_BLUE             0x001e
#define P3RD_DCLK_SETUP_1               0x01f0
#define P3RD_DCLK_SETUP_2               0x01f1
#define P3RD_MCLK_SETUP_1               0x01f2
#define P3RD_MCLK_SETUP_2               0x01f3
#define P3RD_DCLK_CONTROL               0x0200
#define P3RD_DCLK0_PRE_SCALE            0x0201
#define P3RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P3RD_DCLK0_POST_SCALE           0x0203
#define P3RD_DCLK1_PRE_SCALE            0x0204
#define P3RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P3RD_DCLK1_POST_SCALE           0x0206
#define P3RD_DCLK2_PRE_SCALE            0x0207
#define P3RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P3RD_DCLK2_POST_SCALE           0x0209
#define P3RD_DCLK3_PRE_SCALE            0x020a
#define P3RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P3RD_DCLK3_POST_SCALE           0x020c
#define P3RD_MCLK_CONTROL               0x020d
#define P3RD_MCLK_PRE_SCALE             0x020e
#define P3RD_MCLK_FEEDBACK_SCALE        0x020f
#define P3RD_MCLK_POST_SCALE            0x0210
#define P3RD_CURSOR_PALETTE_START       0x0303      // 303..32f
#define P3RD_CURSOR_PATTERN_START       0x0400      // 400..7ff

// bit field definitions for the indexed registers
#define P3RD_MISC_CONTROL_OVERLAYS_ENABLED      0x10
#define P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED  0x08
#define P3RD_MISC_CONTROL_HIGHCOLORRES          0x01

#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW  0x00
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW  0x00

#define P3RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED 0x80

#define P3RD_PIXEL_SIZE_8BPP            0x00
#define P3RD_PIXEL_SIZE_16BPP           0x01
#define P3RD_PIXEL_SIZE_24_BPP          0x04
#define P3RD_PIXEL_SIZE_32BPP           0x02

#define P3RD_COLOR_FORMAT_CI8           0x0e
#define P3RD_COLOR_FORMAT_8BPP          0x05
#define P3RD_COLOR_FORMAT_15BPP         0x01
#define P3RD_COLOR_FORMAT_16BPP         0x10
#define P3RD_COLOR_FORMAT_32BPP         0x00
#define P3RD_COLOR_FORMAT_LINEAR_EXT    0x40

#define P3RD_CURSOR_MODE_REVERSE        0x40
#define P3RD_CURSOR_MODE_WINDOWS        0x00
#define P3RD_CURSOR_MODE_X              0x10
#define P3RD_CURSOR_MODE_3COLOR         0x20
#define P3RD_CURSOR_MODE_15COLOR        0x30
#define P3RD_CURSOR_MODE_64x64          0x00
#define P3RD_CURSOR_MODE_P0_32x32x2     0x02
#define P3RD_CURSOR_MODE_P1_32x32x2     0x04
#define P3RD_CURSOR_MODE_P2_32x32x2     0x06
#define P3RD_CURSOR_MODE_P3_32x32x2     0x08
#define P3RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P3RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P3RD_CURSOR_MODE_ENABLED        0x01

#define P3RD_CURSOR_CONTROL_RPOS_ENABLED    0x04
#define P3RD_CURSOR_CONTROL_DOUBLE_Y        0x02
#define P3RD_CURSOR_CONTROL_DOUBLE_X        0x01

#define P3RD_DCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_DCLK_CONTROL_ENABLED   0x01

#define P3RD_MCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_MCLK_CONTROL_ENABLED   0x01

#define P3RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}

#define P3RD_SYNC_WITH_GLINT

//
// generic read/write routines for P3RD registers
//
#define WRITE_P3RDREG_ULONG(r, d) \
{ \
    WRITE_FAST_ULONG(r, d); \
    MEMORY_BARRIER(); \
}

#define READ_P3RDREG_ULONG(r)    READ_FAST_ULONG(r)


#if 0
// need a delay between each write to the P3RD. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
#define P3RD_DELAY \
{ \
    volatile LONG __junk; \
    GLINT_GET_PACKING_MODE(__junk); \
    GLINT_GET_PACKING_MODE(__junk); \
}
#else
#define P3RD_DELAY
#endif

// macro to load a given data value into an internal P3RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define P3RD_INDEX_REG(index) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_LO, (index) & 0xff)); \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P3RD_DELAY; \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_HI, (index) >> 8)); \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_DATA(data) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_DATA, (data) & 0xff)); \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_READ_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    data = READ_P3RDREG_ULONG(P3RD_INDEX_DATA) & 0xff;   \
    P3RD_DELAY; \
    VideoDebugPrint(("0x%x <-- *(0x%x)\n", data, P3RD_INDEX_DATA)); \
}

#define P3RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_DATA,    (ULONG)(data));   \
    P3RD_DELAY; \
}

// macros to load a given RGB triple into the P3RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P3RD_PALETTE_START and multiple P3RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P3RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define P3RD_PALETTE_START_WR(index) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_PALETTE_START_RD(index) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE(red, green, blue) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PAL_WR_ADDR, (ULONG)(index));    \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

// macro to read back a given RGB triple from the P3RD palette. Use after
// a call to P3RD_PALETTE_START_RD
//
#define P3RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(READ_P3RDREG_ULONG(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
    green = (UCHAR)(READ_P3RDREG_ULONG(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
    blue  = (UCHAR)(READ_P3RDREG_ULONG(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define P3RD_SET_PIXEL_READMASK(mask) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_PIXEL_MASK,  (ULONG)(mask)); \
    P3RD_DELAY; \
}

#define P3RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = READ_P3RDREG_ULONG(P3RD_PIXEL_MASK) & 0xff; \
}

// Windows format byte-packed cursor data: each byte represents 4 consecutive pixels
#define P3RD_CURSOR_2_COLOR_BLACK           0x00
#define P3RD_CURSOR_2_COLOR_WHITE           0x55
#define P3RD_CURSOR_2_COLOR_TRANSPARENT     0xAA
#define P3RD_CURSOR_2_COLOR_HIGHLIGHT       0xFF
#define P3RD_CURSOR_3_COLOR_TRANSPARENT     0x00
#define P3RD_CURSOR_15_COLOR_TRANSPARENT    0x00

// macros to load values into the cursor array usage is P3RD_CURSOR_ARRAR_START() followed by 
// n iterations of P3RD_LOAD_CURSOR_ARRAY() or P3RD_READ_CURSOR_ARRAY()
//
#define P3RD_CURSOR_ARRAY_START(offset) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_LO,   (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) & 0xff));  \
    P3RD_DELAY; \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) >> 8));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_CURSOR_ARRAY(data) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_DATA, (ULONG)(data)); \
    P3RD_DELAY; \
}

#define P3RD_READ_CURSOR_ARRAY(data) \
{ \
    data = READ_P3RDREG_ULONG(P3RD_INDEX_DATA) & 0xff; \
    P3RD_DELAY; \
}

// macro to move the cursor
//
#define P3RD_MOVE_CURSOR(x, y) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_HI, (ULONG)0);              \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define P3RD_CURSOR_HOTSPOT(x, y) \
{ \
    WRITE_P3RDREG_ULONG(P3RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
    
// Cursor sizes
#define P3RD_CURSOR_SIZE_64_MONO    0
#define P3RD_CURSOR_SIZE_32_MONO    1
#define P3RD_CURSOR_SIZE_64_3COLOR  0 
#define P3RD_CURSOR_SIZE_32_3COLOR  1
#define P3RD_CURSOR_SIZE_32_15COLOR 5

#define P3RD_CURSOR_SEL(cursorSize, cursorIndex) \
    (((cursorSize + cursorIndex) & 7) << 1)

//
// Warning the P3 has an upside down cursor LUT, which means that
// items read from LUT entry 0 are actually read from entry 14.
// Therefore we have some macros to calculate the right value.
//
// Permedia4 behaves more naturally.
//
#define P3RD_CALCULATE_LUT_INDEX(x) \
    (glintInfo->deviceInfo.DeviceId == PERMEDIA4_ID ? (x) : (14-(x)))

// Exported functions from P3RD.c

PTRENABLE       vEnablePointerP3RD;
PTRDISABLE      vDisablePointerP3RD;
PTRSETSHAPE     bSetPointerShapeP3RD;
PTRMOVE         vMovePointerP3RD;
PTRSHOW         vShowPointerP3RD;
//@@BEGIN_DDKSPLIT
//DACSETUPOVERLAY vSetOverlayModeP3RD;
//PTRSETPIXMSK    vP3RDSetPixelMask;
//PTRSWPCSBUF     bP3RDSwapCSBuffers;
//PTRCHKCSBUF     bP3RDCheckCSBuffering;
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\lines.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: lines.h
*
* Content: Line drawing constants and structures.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)   // S3's line length term is limited to
#define MIN_INTEGER_BOUND  (-512)   //   a maximum value of 2047

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00000100L     // .... ...1 .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_ARBITRARYSTYLED      0x00000400L     // .... .1.. .... ....
#define FL_MASKSTYLED           0x00000800L     // .... 1... .... ....
#define FL_STYLED              (FL_ARBITRARYSTYLED | FL_MASKSTYLED)
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000C00L
#define FL_STYLE_SHIFT          10

// Simpler flag bits in high byte:

#define FL_DONT_DO_HALF_FLIP    0x00002000L     // ..1. .... .... ....
#define FL_PHYSICAL_DEVICE      0x00004000L     // .1.. .... .... ....

// Logical operation which requires a read (for GLINT)
#define FL_READ                 0x00008000L     // 1... .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);

// Strip drawers (P3RX):

VOID vPXRXSolidHorizontalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXSolidVerticalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXSolidDiagonalHorizontalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXSolidDiagonalVerticalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXStyledHorizontalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vPXRXStyledVerticalLine(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\lines.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Lines.c
*
* Content:
*
* Contains the code for drawing short fractional endpoint lines and
* longer lines with strips.  There is also a separate x86 Asm version
* of this code.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}
#define ABS(a)              ((a) < 0 ? -(a) : (a))

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

BOOL bIntegerLine(PDEV*, ULONG, ULONG, ULONG, ULONG);
BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*);

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing Lines Right
* -----------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Style lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the S3 sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code, of which there is a C version in
*    the S3's lines.cxx (or if your display is a frame buffer, fall back
*    to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the S3's
*    fastline.asm for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*       ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line
{

    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx - 1; // Last point in path record
    STYLEPOS  spThis;                             // Style pos for this line

    LONG xmask  = 0xffff800f;
    LONG ymask  = 0xffff800f;
    LONG xmask1 = 0xffff8000;
    LONG ymask1 = 0xffff8000;
    GLINT_DECL;

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        // Check for non-complex-clipped, non-styled integer endpoint lines - ECR
        // Essentially, we allow rendering of any line which 'looks' like an
        // unclipped solid line. Initialization will have set up GLINT appropriatly
        // to produce correct results
        if ((fl & (FL_COMPLEX_CLIP | FL_STYLED))  == 0 ) {

            LONG orx = (LONG) (M0 | dM);
            LONG ory = (LONG) (N0 | dN);

            if (orx < 0) {
                // At least one point was negative. Recompute or using abs points.
                orx = ABS((LONG)M0) | ABS((LONG)dM);
            }
            if (ory < 0) {
                // At least one point was negative. Recompute or using abs points.
                ory = ABS((LONG)N0) | ABS((LONG)dN);
            }

            DISPDBG((7, "Lines: Trying Fast Integer %x %x %x %x", M0, N0, dM, dN));
            // Call fast integer line routines if possible
            if (((orx & xmask) == 0) && ((ory & ymask) == 0))
            {
                if (ppdev->pgfnIntegerLine(ppdev, M0, N0, dM, dN)) {

                    if (fl & FL_READ) {
                        // If we have a logical op which requires reading from the
                        // frame buffer, we cannot guarantee ContinueNewLine's
                        // behaviour when overwriting pixels. Also, avoid
                        // ContinueNewLine on an MX.
                        pptfxFirst = pptfxBuf;
                        pptfxBuf++;
                        continue;
                    }
                    else {
                        // This is an optimisation to use continue new line
                         // to draw any subequent integer lines.    The loop is
                        // essentially the same as the outer loop, however, we
                        // dont need to check for a lot of things that we already
                        // know. We need to be able to fall out to the standard
                        // outer loop if we cant handle a line though.

                        while(TRUE) 
                        {
                            // Have we reached the end of the list of points.
                            if (pptfxBuf == pptfxBufEnd)
                                return(TRUE);
                    
                            pptfxFirst = pptfxBuf;
                            pptfxBuf++;

                            M0 = dM;
                            N0 = dN;
                             dM = (LONG) pptfxBuf->x;
                            dN = (LONG) pptfxBuf->y;

                            // We know M0 and N0 satisfy our criteria for a continue new line
                            // Therefore, we just have to check the new coordinates
                            orx = (LONG) dM;
                            ory = (LONG) dN;

                            if (orx < 0) {
                                // At least one point was negative. Recompute or using abs.
                                orx = ABS((LONG)dM);
                            }
                            if (ory < 0) {
                                // At least one point was negative. Recompute or using abs.
                                ory = ABS((LONG)dN);
                            }

                            // We need to call the routine to continue the line now.
                            // If the line is not a fast integer line, then we need to break
                            // out and try non integer lines. In this case, or will still
                            // be valid, because we know M0, N0 are integer coords that
                            // GLINT can handle.
                            DISPDBG((7, "Lines: Trying Continue Integer %x %x %x %x", M0, N0, dM, dN));
                            if (((orx & xmask) != 0) ||
                                ((ory & ymask) != 0) ||
                                  (!ppdev->pgfnContinueLine(ppdev, M0, N0, dM, dN)))
                                // Either we cant draw the line or the strip drawer failed.
                                    break;
                        }
                    }
                  }
            }

            // Call fast non integer line routines.
            if (((orx & xmask1) == 0) && ((ory & ymask1) == 0))
            {
                if (ppdev->pgfnDrawLine(ppdev, M0, N0, dM, dN)) {
                    // This line done, do next line.
                    pptfxFirst = pptfxBuf;
                    pptfxBuf++;
                    continue;
                  }
            }
           }

        DISPDBG((7, "Lines: Slow Lines %x %x %x %x", M0, N0, dM, dN));
    
        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitude more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)      // We can skip any lines with delta > 2^31 - 1
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;
        if ((LONG) dN < 0)      // We can skip any lines with delta > 2^31 - 1
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = Int32x32To64(dM, N0 + F/2) - Int32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
        ULONG M1 = FXFRAC(M0 + dM);

        x1 = LFLOOR(M0 + dM);

            if (fl & FL_FLIP_H)
            {
            // ---------------------------------------------------------------
            // Line runs right-to-left:  <----

            // Compute x1:

                if (N1 == 0)
                {
                    if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                    {
                        x1++;
                    }
                }
                else if (ABS((LONG) (N1 - F/2)) + M1 > F)
                {
                    x1++;
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                       == (FL_FLIP_SLOPE_ONE))
                {
                // Have to special-case diagonal lines going through our
                // the point exactly equidistant between two horizontal
                // pixels, if we're supposed to round x=1/2 down:

                    if ((N1 > 0) && (M1 == N1 + 8))
                        x1++;

                // Don't you love special cases?  Is this a rhetorical question?

                    if ((N0 > 0) && (M0 == N0 + 8))
                    {
                        x0      = 2;
                        ulDelta = dN;
                        goto right_to_left_compute_y0;
                    }
                }

            // Compute x0:

                x0      = 1;
                ulDelta = 0;
                if (N0 == 0)
                {
                    if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }
                }
                else if (ABS((LONG) (N0 - F/2)) + M0 > F)
                {
                    x0      = 2;
                    ulDelta = dN;
                }

            // Compute y0:

            right_to_left_compute_y0:

                y0 = 0;
                ll = llGamma + (LONGLONG) ulDelta;

                if (ll >= (LONGLONG) (2 * dM - dN))
                    y0 = 2;
                else if (ll >= (LONGLONG) (dM - dN))
                    y0 = 1;
            }
            else
            {
            // ---------------------------------------------------------------
            // Line runs left-to-right:  ---->

            // Compute x1:

                x1--;

                if (M1 > 0)
                {
                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                            x1++;
                    }
                    else if (ABS((LONG) (N1 - F/2)) <= (LONG) M1)
                    {
                        x1++;
                    }
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                       == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                {
                // Have to special-case diagonal lines going through our
                // the point exactly equidistant between two horizontal
                // pixels, if we're supposed to round x=1/2 down:

                    if ((M1 > 0) && (N1 == M1 + 8))
                        x1--;

                    if ((M0 > 0) && (N0 == M0 + 8))
                    {
                        x0 = 0;
                        goto left_to_right_compute_y0;
                    }
                }

            // Compute x0:

                x0 = 0;
                if (M0 > 0)
                {
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                            x0 = 1;
                    }
                    else if (ABS((LONG) (N0 - F/2)) <= (LONG) M0)
                    {
                        x0 = 1;
                    }
                }

            // Compute y0:

            left_to_right_compute_y0:

                y0 = 0;
                if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                {
                    y0 = 1;
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = Int32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = Int32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = Int32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = Int32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = Int32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_ARBITRARYSTYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

    strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED) &&
            !(fl & FL_DONT_DO_HALF_FLIP))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = Int32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf <= pptfxBufEnd);

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\palette.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: palette.c
*
* Content: Palette support.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"
#include <math.h>

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    ULONG           ulMask;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    DISPDBG((DBGLVL, "bInitializePalette called"));

    // mask is zero for palette driven modes
    ulMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;
    if ((ppdev->iBitmapFormat == BMF_8BPP) && (ulMask == 0))
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*)ENGALLOCMEM(FL_ZERO_MEMORY,
                        (sizeof(PALETTEENTRY) * 256), ALLOC_TAG_GDI(F));
        if (ppal == NULL)
        {
            goto ReturnFalse;
        }

        ppdev->pPal = ppal;

        // Generate 256 (8*8*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
            {
                if (!(jGre += 32))
                {
                    jBlu += 64;
                }
            }
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {              
        DISPDBG((DBGLVL, "creating True Color palette, "
                         "masks rgb = 0x%x, 0x%x, 0x%x",
                         ppdev->flRed, ppdev->flGreen, ppdev->flBlue));
                         
        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
    {
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    DISPDBG((WRNLVL, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
    {
        EngDeletePalette(ppdev->hpalDefault);
    }

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
    {
        ENGFREEMEM(ppdev->pPal);
    }
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       ulMask;

    DISPDBG((DBGLVL, "bEnablePalette called"));

    ulMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;

    if ((ppdev->iBitmapFormat == BMF_8BPP) && (ulMask == 0))
    {
        // Fill in pScreenClut header info:
        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:
//@@BEGIN_DDKSPLIT
#pragma prefast(suppress: 203, "pScreenClut points to sufficient ajClutSpace (PREfast bug 611168)")
//@@END_DDKSPLIT
        RtlCopyMemory(pScreenClut->LookupTable, ppdev->pPal,
                      sizeof(ULONG) * 256);

        // Set palette registers:
        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DISPDBG((WRNLVL, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((DBGLVL, "Passed bEnablePalette"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
#if(_WIN32_WINNT >= 0x500)
    // UPDATE: Windows 2000 in multi-monitor mode: DrvSetPalette only sent
    // to the primary monitor on exit from fullscreen (and then only if the
    // primary is in 8bpp mode). If the primary is not 8bpp indexed, but
    // the secondary is, there is no DrvSetPalette for the secondary, even
    // though it was sent DrvAssertMode(FALSE)
    if(bEnable)
        bEnablePalette(ppdev);
    else
        vDisablePalette(ppdev);
#endif
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;
    ULONG           ulMask;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    ulMask = ppdev->flRed | ppdev->flGreen | ppdev->flBlue;    

    if (ulMask != 0)
    {
        DISPDBG((WRNLVL, "DrvSetPalette: trying to set true color palette"));
        return FALSE;
    }

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((WRNLVL, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        goto ReturnFalse;
    }

    // Set the high reserved byte in each palette entry to 0.

    while(cColors--)
    {
        pScreenClutData[cColors].Unused = 0;
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         (PVOID)pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DISPDBG((WRNLVL, "DrvSetPalette failed DeviceIoControl\n"));
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bInstallGammaLUT
*
* Load a given gamma LUT into the RAMDAC and also save it in the registry.
*
\**************************************************************************/

BOOL
bInstallGammaLUT(PPDEV ppdev, PVIDEO_CLUT pScreenClut, BOOL waitVBlank)
{
    ULONG ulReturnedDataLength;
    BOOL bRet;
    GLINT_DECL;

    // only do this for 15, 16 or 32 bpp. Not 15/16 for RGB640.
    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == 0) ||
        ((ppdev->flCaps & CAPS_RGB640_POINTER) && (ppdev->cPelSize == 1)))
    {
        return FALSE;
    }

    if (glintInfo->OverlayMode == GLINT_ENABLE_OVERLAY)
    {
        DISPDBG((WRNLVL, "Overlays enabled. cannot install GAMMA LUT"));
        return FALSE;
    }

    if (pScreenClut->NumEntries == 0)
    {
        DISPDBG((WRNLVL, "bInstallGammaLUT: Empty LUT"));
        return TRUE;
    }

    // Set palette registers.
    if (waitVBlank)
    {
        GLINT_WAIT_FOR_VBLANK;
    }

    bRet = !EngDeviceIoControl(
                        ppdev->hDriver,
                        IOCTL_VIDEO_SET_COLOR_REGISTERS,
                        pScreenClut,
                        MAX_CLUT_SIZE,
                        NULL,
                        0,
                        &ulReturnedDataLength);

//@@BEGIN_DDKSPLIT
#if 0
    // if we succeeded save the ramp in the registry and locally

    if (bRet)
    {
        bGlintRegistrySaveGammaLUT(ppdev, pScreenClut);
    }
#endif
//@@END_DDKSPLIT

    return(bRet);
}        

/******************************Public*Routine******************************\
* VOID vSetNewGammaValue
*
* Loads up a true color palette with the specified gamma correction factor.
* This is straightforward for 24 bit true color. For 15 and 16 bpp we rely
* on the miniport having enabled the palette for sparse lookup. i.e. each
* 5 or 6 bit component is shifted left to create an 8 bit component before
* the lookup.
*
* Note: the display driver shouldn't really do anything with floats or
* doubles. I restrict their use to this function which is why the gamma
* value is presented as a 16.16 fixed point number. And this function must
* be called only from within an OPELGL escape. On NT 4 FP regs are saved
* and restored for OGL escapes only.
*
\**************************************************************************/

VOID
vSetNewGammaValue(PPDEV ppdev, ULONG ulgv, BOOL waitVBlank)
{
    PVIDEO_CLUTDATA pScreenClutData;
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       i;
    UCHAR       gc;
    double      gv;
    double      dcol;
    GLINT_DECL;

    // gamma can't be zero or we blow up
    if (ulgv == 0)
    {
        DISPDBG((WRNLVL, "can't use gamma value of zero"));
        return;
    }

    // only do this for 15, 16 or 32 bpp.

    if ((ppdev->ulWhite == 0x0f0f0f) || (ppdev->cPelSize == 0))
    {
        return;
    }

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = 256;
    pScreenClut->FirstEntry = 0;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    //
    // special case gamma of 1.0 so we can load the LUT at startup without
    // needing any floating point calculations. NT 4 only allows FP ops in
    // an OGL escape. Can't use FLOATOBJ because we need to use pow().
    //
    if (ulgv == 0x10000)
    {
        for (i = 0; i < 256; ++i)
        {
            pScreenClutData[i].Red    = (UCHAR)i;
            pScreenClutData[i].Green  = (UCHAR)i;
            pScreenClutData[i].Blue   = (UCHAR)i;
            pScreenClutData[i].Unused = 0;
        }
    }
    else
    {
        // pre-work out 1/gamma
        gv = (double)(ulgv >> 16) + (double)(ulgv & 0xffff) / 65536.0;
        gv = 1.0 / gv;

        for (i = 0; i < 256; ++i)
        {
            dcol = (double)i;
            gc = (UCHAR)(255.0 * pow((dcol/255.0), gv));

            pScreenClutData[i].Red    = gc;
            pScreenClutData[i].Green  = gc;
            pScreenClutData[i].Blue   = gc;
            pScreenClutData[i].Unused = 0;
        }
    }

    if (bInstallGammaLUT(ppdev, pScreenClut, waitVBlank))
    {
        RtlCopyMemory(&glintInfo->gammaLUT, pScreenClut, MAX_CLUT_SIZE);
    }
}

//*****************************************************************************
// FUNC: DrvIcmSetDeviceGammaRamp
// ARGS: dhpdev (I) - handle to physical device object
//       iFormat (I) - always IGRF_RGB_256WORDS
//       lpRamp (I) - when iFormat == IGRF_RGB_256WORDS, this points to a 
//                    GAMMARAMP structure
// RETN: TRUE if successful
//-----------------------------------------------------------------------------
// Sets the hardware Gamma ramp
//*****************************************************************************

BOOL DrvIcmSetDeviceGammaRamp(DHPDEV dhpdev, ULONG iFormat, VOID *pRamp)
{
    BOOL            bRet = FALSE;
    PDEV            *ppdev  = (PDEV *) dhpdev;
    GAMMARAMP       *pgr    = (GAMMARAMP *)pRamp;
    PVIDEO_CLUTDATA pScreenClutData;
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    ULONG           i;
    ULONG           cj;

    DISPDBG((DBGLVL, "DrvIcmSetDeviceGammaRamp"));

    if(iFormat == IGRF_RGB_256WORDS)
    {
        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        for (i = 0; i < 256; ++i)
        {
            pScreenClutData[i].Red    = (UCHAR)(pgr->Red[i] >> 8);
            pScreenClutData[i].Green  = (UCHAR)(pgr->Green[i] >> 8);
            pScreenClutData[i].Blue   = (UCHAR)(pgr->Blue[i] >> 8);
            pScreenClutData[i].Unused = 0;
        }

        bRet = bInstallGammaLUT(ppdev, pScreenClut, FALSE);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\paint.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: paint.c
*
* Content: DrvPaint support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = gaMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    BOOL bRet;
    ROP4 rop4;

    rop4 = ((MIX) gaMix[mix >> 8] << 8) | gaMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

    DISPDBG((DBGLVL, "DrvPaint: calling DrvBitBlt"));

    if (rop4 == 0x5555)
    {
        // special processing for Invert

        bRet = DrvBitBlt(pso,               // Dst
                         pso,               // Src
                         NULL,              // Mask
                         pco,               // Clip
                         NULL,              // pxlo
                         &pco->rclBounds,   // Bounding Dest rect
                         (POINTL*)(&pco->rclBounds), // Source point
                         NULL,              // Mask point
                         NULL,              // Brush
                         NULL,              // brush origin
                         0x3333);           // not src
    }
    else
    {
        bRet = DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                         NULL, pbo, pptlBrush, rop4);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pointer.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pointer.c
*
* Content:
*
* This module contains the hardware pointer support for the display
* driver. This supports the IBM RGB525 RAMDAC pointer. We also have
* support for color space double buffering using the RAMDAC pixel
* read mask.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"
#include "p3rd.h"

BOOL bSet3ColorPointerShapeP3RD(PPDEV ppdev, SURFOBJ *psoMask, SURFOBJ *psoColor, 
                                LONG x, LONG y, LONG xHot, LONG yHot);
BOOL bSet15ColorPointerShapeP3RD(PPDEV ppdev, SURFOBJ *psoMask, SURFOBJ *psoColor, 
                                 LONG x, LONG y, LONG xHot, LONG yHot);


/******************************Public*Routine******************************\
* VOID DrvMovePointer
*
* NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
*       time, even while we're executing another drawing call!
*
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    OH*     poh;
    PDEV*   ppdev = (PDEV*) pso->dhpdev;

    DISPDBG((DBGLVL, "DrvMovePointer called"));

    if (x > -1)
    {
        // Convert the pointer's position from relative to absolute
        // coordinates (this is only significant for multiple board
        // support):

        poh = ((DSURF*) pso->dhsurf)->poh;
        x += poh->x;
        y += poh->y;

        // If we're doing any hardware zooming then the cusor position will
        // have to be doubled.
        //
        if (ppdev->flCaps & CAPS_ZOOM_Y_BY2)
            y *= 2;
        if (ppdev->flCaps & CAPS_ZOOM_X_BY2)
                x *= 2;

        // If they have genuinely moved the cursor, then 
        // move it
        if (x != ppdev->HWPtrPos_X || y != ppdev->HWPtrPos_Y)
        {
            vMovePointerP3RD(ppdev, x, y);

            ppdev->HWPtrPos_X = x;
            ppdev->HWPtrPos_Y = y;
        }

        // We may have to make the pointer visible:

        if (!(ppdev->flPointer & PTR_HW_ACTIVE))
        {
            DISPDBG((DBGLVL, "Showing hardware pointer"));
            ppdev->flPointer |= PTR_HW_ACTIVE;
            vShowPointerP3RD(ppdev, TRUE);
        }
    }
    else if (ppdev->flPointer & PTR_HW_ACTIVE)
    {
        // The pointer is visible, and we've been asked to hide it:

        DISPDBG((DBGLVL, "Hiding hardware pointer"));
        ppdev->flPointer &= ~PTR_HW_ACTIVE;
        vShowPointerP3RD(ppdev, FALSE);
    }
#if DBG
    else
    {
        DISPDBG((DBGLVL, "DrvMovePointer: x == -1 but not PTR_HW_ACTIVE"));
    }
#endif

    // Note that we don't have to modify 'prcl', since we have a
    // NOEXCLUDE pointer...

    DISPDBG((DBGLVL, "DrvMovePointer exited"));
}                                                  

/******************************Public*Routine******************************\
* VOID DrvSetPointerShape
*
* Sets the new pointer shape.
*                                                                              
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    PDEV*   ppdev;
    OH      *poh;
    BOOL    bAccept;
    DISPDBG((DBGLVL, "DrvSetPointerShape called"));

    ppdev = (PDEV*) pso->dhpdev;

    if (!(fl & SPS_CHANGE))
    {
        goto HideAndDecline;
    }

    ASSERTDD(psoMsk != NULL, "GDI gave us a NULL psoMsk.  It can't do that!");
    ASSERTDD(pso->iType == STYPE_DEVICE, "GDI gave us a weird surface");

    if (x != -1)
    {
        // Convert the pointer's position from relative to absolute
        // coordinates (this is only significant for multiple board
        // support):

        if (pso->dhsurf != NULL)
        {
            poh = ((DSURF*) pso->dhsurf)->poh;
            x += poh->x;
            y += poh->y;
        }

        // If we're doing any hardware zooming then the cusor position will
        // have to be doubled.
        //
        if (ppdev->flCaps & CAPS_ZOOM_Y_BY2)
            y *= 2;
        if (ppdev->flCaps & CAPS_ZOOM_X_BY2)
            x *= 2;
    }

    // See if our hardware cursor can handle this.
    bAccept = bSetPointerShapeP3RD(ppdev, psoMsk, psoColor, pxlo,
                                   x, y, xHot, yHot);

    if (bAccept)
    {
        if (x != -1)
        {
            // Save the X and Y values
            ppdev->HWPtrPos_X = x;
            ppdev->HWPtrPos_Y = y;

            ppdev->flPointer |= PTR_HW_ACTIVE;
        }
        else
        {
            ppdev->flPointer &= ~PTR_HW_ACTIVE;
        }

        // Since it's a hardware pointer, GDI doesn't have to worry about
        // overwriting the pointer on drawing operations (meaning that it
        // doesn't have to exclude the pointer), so we return 'NOEXCLUDE'.
        // Since we're returning 'NOEXCLUDE', we also don't have to update
        // the 'prcl' that GDI passed us.

        return(SPS_ACCEPT_NOEXCLUDE);
    }
    
HideAndDecline:

    // Remove whatever pointer is installed.
    DrvMovePointer(pso, -2, -1, NULL);

    DISPDBG((DBGLVL, "Cursor declined"));

    return(SPS_DECLINE);
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
PDEV*   ppdev)
{
    if(ppdev->bPointerEnabled)
    {
        vDisablePointerP3RD(ppdev);
    }
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
* Do whatever has to be done to enable everything but hide the pointer.
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Invalidate the hardware pointer cache
    HWPointerCacheInvalidate (&(ppdev->HWPtrCache));

    // Remove the hardware pointer
    vShowPointerP3RD(ppdev, FALSE);

    ppdev->flPointer &= ~PTR_HW_ACTIVE;
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    // Initialise the pointer cache.
    HWPointerCacheInit (&(ppdev->HWPtrCache));

    // Set the last cursor to something invalid
    ppdev->HWPtrLastCursor = HWPTRCACHE_INVALIDENTRY;

    // Initialise the X and Y values to something invalid.
    ppdev->HWPtrPos_X = 1000000000;
    ppdev->HWPtrPos_Y = 1000000000;

    // Call the enable function
    vEnablePointerP3RD(ppdev);

    // Mark the pointer as enabled for this PDEV
    ppdev->bPointerEnabled = TRUE;

    return(TRUE);
}

/****************************************************************************************
 *                                                                                      *
 * 64 x 64 Hardware Pointer Caching                                                     *
 * --------------------------------                                                        *
 * The code below implements hardware independent caching of pointers, it maintains     *
 * a cache big enough to store ONE 64x64 cursor or FOUR 32x32 cursors. The code will    *
 * work with all RAMDACs that support this form of caching (i.e. the RGB525 and TVP3033)*
 * however the TVP3026 supports a 64x64 cursor but this can't be broken down into 4     *
 * smaller ones.                                                                        *
 *                                                                                        *
 ****************************************************************************************/

/******************************Public*Routine******************************\
* LONG HWPointerCacheInit
* 
* Initialise the hardware pointer cache.
\**************************************************************************/

VOID
HWPointerCacheInit (HWPointerCache * ptrCache)
{
    ptrCache->ptrCacheInUseCount   = 0;
    ptrCache->ptrCacheCurTimeStamp = 0;
}

/******************************Public*Routine******************************\
* LONG HWPointerCacheCheckAndAdd
* 
* This function does a byte-by-byte comparison of the supplied pointer data
* with each pointer that is in cache, if it finds a matching one then it 
* returns the index of the item in the cache (0 to 3) otherwise it adds it to
* the cache and returns the index.
\**************************************************************************/

LONG
HWPointerCacheCheckAndAdd (HWPointerCache * ptrCache, ULONG cx, ULONG cy, 
                           LONG lDelta, BYTE * scan0, BOOL * isCached)
{
    BOOL pointerIsCached = FALSE;
    BOOL isLargePtr = (cx > 32) || (cy > 32);
    LONG i, j, z;
    LONG cacheItem;

#if !defined(_WIN64)
//@@BEGIN_DDKSPLIT
// Quick Fix IA64 AV 
//@@END_DDKSPLIT
    // If there are entries in the cache and they are the same format as the one
    // that we are looking for then search the cache.
    if (ptrCache->ptrCacheInUseCount && ptrCache->ptrCacheIsLargePtr == isLargePtr)
    {
        // *** SEARCH THE CACHE ***

        LONG xInBytes       = (cx >> 3);
        LONG yInLines       = (cy << 1);            // The AND plane and the XOR plane
        BYTE jMask          = gajMask [cx & 0x7];
        LONG cacheCnt       = ptrCache->ptrCacheInUseCount;

        // Examine all valid entries in the cache to see if they are the same as the
        // pointer that we've been handed.
        for (z = 0; !pointerIsCached && z < cacheCnt; z++)
        {
            BYTE * cacheLinePtr = ((BYTE *) ptrCache->ptrCacheData) + (z * SMALL_POINTER_MEM);
            BYTE * cachePtr;
            LONG   cacheLDelta  = ptrCache->ptrCacheItemList [z].ptrCacheLDelta;
            BYTE * scanLinePtr  = (BYTE *) scan0;
            BYTE * scanPtr;

            // Compare the data
            for (i = 0, pointerIsCached = TRUE; pointerIsCached && i < yInLines; i++)
            {
                cachePtr = cacheLinePtr;
                scanPtr = scanLinePtr;

                // Compare each byte - could do a series of long comparisons here.
                for (j = 0; (j < xInBytes) && (*scanPtr == *cachePtr); j++, scanPtr++, cachePtr++)
                    ;
                
                pointerIsCached = (j == xInBytes) && 
                                  ((*scanPtr & jMask) == (*cachePtr & jMask));

                cacheLinePtr += cacheLDelta;
                scanLinePtr  += lDelta;
            }
                
            cacheItem = z;
        }
    }
#endif //  !defined(_WIN64)

    // If we couldn't find an entry in the pointer cache then add one to the cache.
    if (!pointerIsCached)
    {
        /* **** ADD POINTER TO THE CACHE ****** */

        LONG xInBytes        = ((cx + 7) >> 3);
        LONG yInLines        = (cy << 1);            // The AND plane and the XOR plane
        BYTE * scanLinePtr   = (BYTE *) scan0;
        BYTE * scanPtr;
        BYTE * cacheLinePtr;
        BYTE * cachePtr;
        LONG cacheLDelta    = (cx <= 32) ? 4 : 8;
        BYTE jMask          = gajMask [cx & 0x7];

        // If the new pointer is a big one then re-use item 0, else if
        // the pointer is small and there are some spare entries then allocate
        // a free entry, otherwise find the least recently used entry and use 
        // that.
        if (isLargePtr)
        {
            cacheItem = 0;
        }
        else if (ptrCache->ptrCacheInUseCount < SMALL_POINTER_MAX)
        {
            cacheItem = ptrCache->ptrCacheInUseCount++;
        }
        else
        {
            ULONG oldestValue = 0xFFFFFFFF;

            // look for the LRU entry
            for (z = 0, cacheItem = 0; z < SMALL_POINTER_MAX; z++)
            {
                if (ptrCache->ptrCacheItemList [z].ptrCacheTimeStamp < oldestValue)
                {
                    cacheItem = z;
                    oldestValue = ptrCache->ptrCacheItemList [z].ptrCacheTimeStamp;
                }
            }
        }
        
        // Get a pointer to the first line in the cache
        cacheLinePtr = ((BYTE *) ptrCache->ptrCacheData) + (cacheItem * SMALL_POINTER_MEM);

        // Add the pointer to the cache
        for (i = 0; i < yInLines; i++)
        {
            cachePtr = cacheLinePtr;
            scanPtr = scanLinePtr;

            for (j = 0; (j < xInBytes); j++, scanPtr++, cachePtr++)
                *cachePtr = *scanPtr;
            
            cacheLinePtr += cacheLDelta;
            scanLinePtr  += lDelta;
        }

        // If the pointer type is different then reset the whole
        // cache
        if (ptrCache->ptrCacheIsLargePtr != isLargePtr)
        {
            ptrCache->ptrCacheInUseCount = 1;
            ptrCache->ptrCacheIsLargePtr = (BYTE)isLargePtr;
        }

        // Set up the cache entry
        ptrCache->ptrCacheItemList [cacheItem].ptrCacheLDelta   = cacheLDelta;
        ptrCache->ptrCacheItemList [cacheItem].ptrCacheCX       = cx;
        ptrCache->ptrCacheItemList [cacheItem].ptrCacheCY       = cy;
    }

    // Set the timestamp
    ptrCache->ptrCacheItemList [cacheItem].ptrCacheTimeStamp = ptrCache->ptrCacheCurTimeStamp++;

    // Set up the return value to say whether the pointer was cached
    *isCached = pointerIsCached;

    return (cacheItem);
}

//@@BEGIN_DDKSPLIT
// NickM says we have to disable the cursor to stop nasty flashing occurring,
// however there is a potential exploding flashing cursor syndrome that this may 
// cause.
// Note that this problem only seems to cause us problems when switching between
// mono and colour cursors.
//@@END_DDKSPLIT

#define DISABLE_CURSOR_MODE(){                                                            \
    ULONG curCurMode, curLine;                                                            \
    ULONG start = (pP3RDinfo->y > 8) ? (pP3RDinfo->y - 8) : 0;                            \
    ULONG end = pP3RDinfo->y + 64;                                                        \
    do  {                                                                                \
        READ_GLINT_CTRL_REG (LineCount, curLine);                                        \
    } while ((curLine >= start) && (curLine <= end));                                    \
    P3RD_READ_INDEX_REG(P3RD_CURSOR_MODE, curCurMode);                                    \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_MODE, (curCurMode & (~P3RD_CURSOR_MODE_ENABLED)));    \
}

// Look-up table for masking the right edge of the given pointer bitmap:
//
BYTE gajMask[] = {
    0x00, 0x80, 0xC0, 0xE0,
    0xF0, 0xF8, 0xFC, 0xFE,
};

/******************************Public*Routine******************************\
* VOID vShowPointerP3RD
*
* Show or hide the 3Dlabs P3RD hardware pointer.
*
\**************************************************************************/

VOID
vShowPointerP3RD(
PPDEV   ppdev,
BOOL    bShow)
{
    ULONG cmr;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "vShowPointerP3RD (%s)", bShow ? "on" : "off"));

    if (bShow)
    {
        // no need to sync since this case is called only if we've just moved
        // the cursor and that will already have done a sync.
        P3RD_LOAD_INDEX_REG(P3RD_CURSOR_MODE, (pP3RDinfo->cursorModeCurrent | P3RD_CURSOR_MODE_ENABLED));
        P3RD_MOVE_CURSOR (pP3RDinfo->x, pP3RDinfo->y);
    }
    else
    {
        // move the cursor off screen
        P3RD_LOAD_INDEX_REG(P3RD_CURSOR_Y_HIGH, 0xff);
    }
}

/******************************Public*Routine******************************\
* VOID vMovePointerP3RD
*
* Move the 3Dlabs P3RD hardware pointer.
*
\**************************************************************************/

VOID
vMovePointerP3RD(
PPDEV   ppdev,
LONG    x,
LONG    y)
{
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "vMovePointerP3RD to (%d, %d)", x, y));

    pP3RDinfo->x = x;
    pP3RDinfo->y = y;

    P3RD_SYNC_WITH_GLINT;

    P3RD_MOVE_CURSOR (x, y);
}

/******************************Public*Routine******************************\
* BOOL bSetPointerShapeP3RD
*
* Set the 3Dlabs hardware pointer shape.
*
\**************************************************************************/

UCHAR nibbleToByteP3RD[] = {

    0x00,   // 0000 --> 00000000
    0x80,   // 0001 --> 10000000
    0x20,   // 0010 --> 00100000
    0xA0,   // 0011 --> 10100000
    0x08,   // 0100 --> 00001000
    0x88,   // 0101 --> 10001000
    0x28,   // 0110 --> 00101000
    0xA8,   // 0111 --> 10101000
    0x02,   // 1000 --> 00000010
    0x82,   // 1001 --> 10000010
    0x22,   // 1010 --> 00100010
    0xA2,   // 1011 --> 10100010
    0x0A,   // 1100 --> 00001010
    0x8A,   // 1101 --> 10001010
    0x2A,   // 1110 --> 00101010
    0xAA,   // 1111 --> 10101010
};

BOOL
bSetPointerShapeP3RD(
PPDEV       ppdev,
SURFOBJ     *pso,       // defines AND and MASK bits for cursor
SURFOBJ     *psoColor,  // we may handle some color cursors at some point
XLATEOBJ*   pxlo,
LONG        x,          // If -1, pointer should be created hidden
LONG        y,
LONG        xHot,
LONG        yHot)
{
    ULONG   cx;
    ULONG   cy;
    LONG    i;
    LONG    j;
    ULONG   ulValue;
    BYTE*   pjAndScan;
    BYTE*   pjXorScan;
    BYTE*   pjAnd;
    BYTE*   pjXor;
    BYTE    andByte;
    BYTE    xorByte;
    BYTE    jMask;
    LONG    lDelta;
    LONG    cpelFraction;
    LONG    cjWhole;
    LONG    cClear;
    LONG    cRemPels;
    BOOL    pointerIsCached;
    LONG    cacheItem;
    LONG    cursorBytes;
    LONG    cursorRAMOff;
    ULONG   lutIndex0, lutIndex1;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "bSetPointerShapeP3RD started"));

    // Do we have a colour cursor ?
    if (psoColor != NULL)
    {
        HSURF   hsurfDst = NULL;    // We'll use these later.
        SURFOBJ * psoDst = NULL;

        if (psoColor->iType == STYPE_DEVBITMAP)
        {
            // it's an offscreen bitmap: we'll use its DIB
            DSURF *pdsurfSrc = (DSURF *)psoColor->dhsurf;
            psoColor = pdsurfSrc->pso;

            // If we have patching enabled then it could be that we aren't allowed
            // to directly access framebuffer memory, if that is the case then
            // we have to fall-back to software. Note that when running 3D apps there
            // won't be any off-screen memory so cursors will be hardware ones.
            // Note that bitmaps that were in off-screen and have been kicked back
            // into host memory will have pdsurfSrc->dt set to DT_DIB.
            if (glintInfo->GdiCantAccessFramebuffer && ((pdsurfSrc->dt & DT_DIB) == 0))
            {
                DISPDBG((DBGLVL, "declining off-screen cursor in a patched framebuffer"));
                return (FALSE);
            }
        }

        // Is it 15,16 or 32BPP.

        if(!(ppdev->iBitmapFormat == BMF_16BPP || ppdev->iBitmapFormat == BMF_32BPP))
        {
            // currently we only handle DIB cursors at 32bpp, 16bpp & 15bpp.
            DISPDBG((DBGLVL, "declining non-32bpp, non-16bpp colored cursor - iType(%d) iBitmapFormat(%d)", psoColor->iType, psoColor->iBitmapFormat));
            return FALSE;
        }

        // If we have a bitmap which we don't understand then we have to convert it using
        // the EngCopyBits() function.
        if ((pxlo != NULL && pxlo->flXlate != XO_TRIVIAL)    ||
            (psoColor->iType != STYPE_BITMAP)                  )
        {
            RECTL   rclDst;
            SIZEL   sizlDst;
            ULONG   DstPixelOrigin;
            POINTL  ptlSrc;

#if DBG
            if(pxlo != NULL && pxlo->flXlate != XO_TRIVIAL) 
            {
                DISPDBG((DBGLVL, "colored cursor - nontrivial xlate: flXlate(%xh)", pxlo->flXlate));
            }
#endif  //  DBG

            // Firstly we need to create a bitmap (hsurfDst) and a surface (psoDst) 
            // which we can translate the cursor data in psoColor into.
            sizlDst.cy = pso->sizlBitmap.cy >> 1;    // divide by 2 'cos cy includes AND and XOR masks
            sizlDst.cx = pso->sizlBitmap.cx;

            DISPDBG((DBGLVL, "Creating bitmap for destination: dimension %dx%d", sizlDst.cx, sizlDst.cy));
            
            hsurfDst = (HSURF) EngCreateBitmap(sizlDst, BMF_TOPDOWN, ppdev->iBitmapFormat, 0, NULL);
            if (hsurfDst == NULL)
            {
                DISPDBG((DBGLVL, "bSetPointerShapeP3RD: EngCreateBitmap failed"));
                return FALSE;
            }

            // Now we lock the bitmap to get ourselves a surface object. 
            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
            {
                DISPDBG((DBGLVL, "bSetPointerShapeP3RD: EngLockSurface failed"));
            }
            else
            {
                // Now do the bitmap conversion using EngCopyBits(). The 
                // destination rectangle is the minimum size and the source starts
                // from (0,0) into pso->pvScan0.
                rclDst.left = 0;
                rclDst.top = 0;
                rclDst.right = sizlDst.cx;
                rclDst.bottom = sizlDst.cy;
                ptlSrc.x = 0;
                ptlSrc.y = 0;
                
                DISPDBG((DBGLVL, "bSetPointerShapeP3RD: copying to bitmap"));

                if (!EngCopyBits(psoDst, psoColor, NULL, pxlo, &rclDst, &ptlSrc))
                {
                    // Oh no copybits failed, free up the the surfaces & bitmaps.
                    DISPDBG((DBGLVL, "bSetPointerShapeP3RD: EngLockSurface failed"));

                    EngUnlockSurface(psoDst);
                    EngDeleteSurface(hsurfDst);
                    return FALSE;
                }
                else
                {
                    // Copybits suceeded, set psoColor to point at the translated
                    // data.
                    DISPDBG((DBGLVL, "bSetPointerShapeP3RD: EngLockSurface OK"));

                    psoColor = psoDst;
                }
            }
        }

        // Draw the cursor, this function will return an error if there are
        // too many colours in the pointer.
        if(!bSet15ColorPointerShapeP3RD(ppdev, pso, psoColor, x, y, xHot, yHot)) 
        {
            DISPDBG((DBGLVL, "declining colored cursor"));
            return FALSE;
        }

        // If we, earlier, translated psoColor into the framebuffer pixel format then
        // we now need to free the intermediate surfaces and bitmaps.
        if (psoDst)
        {
            EngUnlockSurface(psoDst);
        }
        if (hsurfDst)
        {
            EngDeleteSurface(hsurfDst);
        }
        
        DISPDBG((DBGLVL, "bSetPointerShapeP3RD done"));
        return(TRUE);
    }

    // If we are switching from a colour cursor to a mono one then disable
    // the cursor in the cursor mode. Note that this is potentially dangerous
    // and we are seeing screen flashes on occasions.

    if (pP3RDinfo->cursorSize != P3RD_CURSOR_SIZE_32_MONO &&
        pP3RDinfo->cursorSize != P3RD_CURSOR_SIZE_64_MONO)
    {
        DISABLE_CURSOR_MODE();
    }

    // Note that 'sizlBitmap.cy' accounts for the double height due to the inclusion of both the AND masks
    // and the XOR masks. We're only interested in the true pointer dimensions, so we divide by 2.
    cx = pso->sizlBitmap.cx;            
    cy = pso->sizlBitmap.cy >> 1;       

    // we can handle up to 64x64.  cValid indicates the number of
    // bytes occupied by cursor on one line
    if (cx <= 32 && cy <= 32)
    {
        // 32 horiz pixels: 2 bits per pixel, 1 horiz line per 8 bytes
        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_32_MONO;
        cursorBytes = 32 * 32 * 2 / 8;
        cClear   = 8 - 2 * ((cx+7) / 8);
        cRemPels = (32 - cy) << 3;
    }
    else if (cx <= 64 && cy <= 64)
    {
        // 64 horiz pixels: 2 bits per pixel, 1 horiz line per 16 bytes
        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_64_MONO;
        cursorBytes = 64 * 64 * 2 / 8;
        cClear   = 16 - 2 * ((cx+7) / 8);
        cRemPels = (64 - cy) << 4;
    }
    else
    {
        DISPDBG((DBGLVL, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    // Check to see if the pointer is cached, add it to the cache if it isn't
    cacheItem = HWPointerCacheCheckAndAdd (&(ppdev->HWPtrCache), cx, cy, pso->lDelta, pso->pvScan0, &pointerIsCached);
    
    DISPDBG((DBGLVL, "bSetPointerShapeP3RD: Add Cache iscac %d item %d", (int) pointerIsCached, cacheItem));

    pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff | P3RD_CURSOR_SEL(pP3RDinfo->cursorSize, cacheItem);

    // hide the pointer
    vShowPointerP3RD(ppdev, FALSE);

    if (!pointerIsCached)
    {
        // Now we're going to take the requested pointer AND masks and XOR
        // masks and interleave them by taking a nibble at a time from each,
        // expanding each out and or'ing together. Use the nibbleToByteP3RD array
        // to help this.
        //
        // 'psoMsk' is actually cy * 2 scans high; the first 'cy' scans
        // define the AND mask.

        pjAndScan = pso->pvScan0;
        lDelta    = pso->lDelta;
        pjXorScan = pjAndScan + (cy * lDelta);

        cjWhole      = cx >> 3;                 // Each byte accounts for 8 pels
        cpelFraction = cx & 0x7;                // Number of fractional pels
        jMask        = gajMask[cpelFraction];

        // we've got auto-increment turned on so just point to the first entry to write to
        // in the array then write repeatedly until the cursor pattern has been transferred
        cursorRAMOff = cacheItem * cursorBytes;
        P3RD_CURSOR_ARRAY_START(cursorRAMOff);

        for (i = cy; --i >= 0; pjXorScan += lDelta, pjAndScan += lDelta)
        {
            pjAnd = pjAndScan;
            pjXor = pjXorScan;

            // interleave nibbles from whole words. We are using Windows cursor mode.
            // Note, the AND bit occupies the higher bit position for each
            // 2bpp cursor pel; the XOR bit is in the lower bit position.
            // The nibbleToByteP3RD array expands each nibble to occupy the bit
            // positions for the AND bytes. So when we use it to calculate
            // the XOR bits we shift the result right by 1.
            //
            for (j = cjWhole; --j >= 0; ++pjAnd, ++pjXor)
            {
                andByte = *pjAnd;
                xorByte = *pjXor;
                ulValue = nibbleToByteP3RD[andByte >> 4] | (nibbleToByteP3RD[xorByte >> 4] >> 1);
                P3RD_LOAD_CURSOR_ARRAY (ulValue);

                andByte &= 0xf;
                xorByte &= 0xf;
                ulValue = nibbleToByteP3RD[andByte] | (nibbleToByteP3RD[xorByte] >> 1);
                P3RD_LOAD_CURSOR_ARRAY (ulValue);
            }

            if (cpelFraction) 
            {
                andByte = *pjAnd & jMask;
                xorByte = *pjXor & jMask;
                ulValue = nibbleToByteP3RD[andByte >> 4] | (nibbleToByteP3RD[xorByte >> 4] >> 1);
                P3RD_LOAD_CURSOR_ARRAY (ulValue);

                andByte &= 0xf;
                xorByte &= 0xf;
                ulValue = nibbleToByteP3RD[andByte] | (nibbleToByteP3RD[xorByte] >> 1);
                P3RD_LOAD_CURSOR_ARRAY (ulValue);
            }

            // finally clear out any remaining cursor pels on this line.
            //
            if (cClear) 
            {
                for (j = 0; j < cClear; ++j) 
                {
                    P3RD_LOAD_CURSOR_ARRAY (P3RD_CURSOR_2_COLOR_TRANSPARENT);
                }
            }
        }

        // if we've loaded fewer than the full number of lines configured in the
        // cursor RAM, clear out the remaining lines. cRemPels is precalculated to
        // be the number of lines * number of pels per line.
        //
        if (cRemPels > 0)
        {
            do 
            {
                P3RD_LOAD_CURSOR_ARRAY (P3RD_CURSOR_2_COLOR_TRANSPARENT);
            } 
            while (--cRemPels > 0);
        }
    }

    // now set-up the cursor colors
    // Norte that the P3 cursor has the color LUT upside down.
    lutIndex0 = P3RD_CALCULATE_LUT_INDEX (0);
    lutIndex1 = P3RD_CALCULATE_LUT_INDEX (1);

    P3RD_CURSOR_PALETTE_CURSOR_RGB(lutIndex0, 0x00, 0x00, 0x00);
    P3RD_CURSOR_PALETTE_CURSOR_RGB(lutIndex1, 0xFF, 0xFF, 0xFF);

    // If the new cursor is different to the last cursor then set up
    // the hot spot and other bits'n'pieces. As we currently only support
    // mono cursors we don't need to reload the cursor palette
    if (ppdev->HWPtrLastCursor != cacheItem || !pointerIsCached)
    {
        // Make this item the last item
        ppdev->HWPtrLastCursor = cacheItem;

        P3RD_CURSOR_HOTSPOT(xHot, yHot);
    }

    if (x != -1)
    {
        vMovePointerP3RD (ppdev, x, y);

        // need to explicitly show the pointer
        vShowPointerP3RD(ppdev, TRUE);
    }

    DISPDBG((DBGLVL, "bSetPointerShapeP3RD done"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSet3ColorPointerShapeP3RD
*
* stores the 3-color cursor in the RAMDAC: currently only 32bpp and 15/16bpp
* cursors are supported
*
\**************************************************************************/

BOOL
bSet3ColorPointerShapeP3RD(
PPDEV       ppdev,
SURFOBJ     *psoMask,   // defines AND and MASK bits for cursor
SURFOBJ     *psoColor,  // we may handle some color cursors at some point
LONG        x,          // If -1, pointer should be created hidden
LONG        y,
LONG        xHot,
LONG        yHot)
{
    LONG    cx, cy;
    LONG    cxcyCache;
    LONG    cjCacheRow, cjCacheRemx, cjCacheRemy, cj;
    BYTE    *pjAndMask, *pj;
    ULONG   *pulColor, *pul;
    LONG    cjAndDelta, cjColorDelta;
    LONG    iRow, iCol;
    BYTE    AndBit, AndByte;
    ULONG   CI2ColorIndex, CI2ColorData;
    ULONG   ulColor;
    ULONG   aulColorsIndexed[3];
    LONG    Index, HighestIndex = 0;
    ULONG   r, g, b;
    ULONG   whichOne = 0;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD started"));

    cx = psoColor->sizlBitmap.cx;
    cy = psoColor->sizlBitmap.cy;

    if (cx <= 32 && cy <= 32)
    {
        ULONG curItem;
        cxcyCache = 32;

        // If we are using a mono/3-colour cursor in the first or second entry then
        // download to the third entry, otherwise use the first entry.
        curItem = (pP3RDinfo->cursorModeCurrent >> 1) & 0x7;
        if (curItem == 1 || curItem == 2)
            whichOne = 2;

        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_32_3COLOR;
        pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff | P3RD_CURSOR_SEL(pP3RDinfo->cursorSize, whichOne) | P3RD_CURSOR_MODE_3COLOR;

        // We don't cache color cursors, because we want to force the mono cursor to use the 
        // either the first or third entries we can't just do a HWPointerCacheInvalidate(), because
        // the mono cursor code will use the first entry or the time. So, if we want the 
        // mono code to use the 3rd entry we say that first 2 cache entries are valid but mess them        
        // up by incrementing the first byte, so that the cache check will always fail.
        ppdev->HWPtrCache.ptrCacheInUseCount = (BYTE) whichOne;
        for (iCol = 0; iCol < ppdev->HWPtrCache.ptrCacheInUseCount; iCol++)
            (*(((BYTE *) ppdev->HWPtrCache.ptrCacheData) + (iCol * SMALL_POINTER_MEM)))++;

    }
    else if (cx <= 64 && cy <= 64)
    {
        // 64x64 cursor : we'll cache it in cursor partition 0 and scrub the old cache
        cxcyCache = 64;

        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_64_3COLOR;
        pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff | P3RD_CURSOR_SEL(pP3RDinfo->cursorSize, 0) | P3RD_CURSOR_MODE_3COLOR;

        // we don't cache color cursors
        HWPointerCacheInvalidate (&(ppdev->HWPtrCache));
    }
    else
    {
        DISPDBG((DBGLVL, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    // work out the remaining bytes in the cache (in x and y) that will need clearing
    cjCacheRow  = 2 * cxcyCache / 8;
    cjCacheRemx =  cjCacheRow - 2 * ((cx+7) / 8);
    cjCacheRemy = (cxcyCache - cy) * cjCacheRow;

    // set-up a pointer to the 1bpp AND mask bitmap
    pjAndMask = psoMask->pvScan0;
    cjAndDelta = psoMask->lDelta;

    // set-up a pointer to the 32bpp color bitmap
    pulColor = psoColor->pvScan0;
    cjColorDelta = psoColor->lDelta;

    // Hide the pointer
    vShowPointerP3RD(ppdev, FALSE);

    // load the cursor array (we have auto-increment turned on so initialize to entry 0 here)
    P3RD_CURSOR_ARRAY_START(whichOne * (32 * 32 * 2 / 8));
    for (iRow = 0; iRow < cy; ++iRow, pjAndMask += cjAndDelta, (BYTE *)pulColor += cjColorDelta)
    {
        DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: Row %d (of %d): pjAndMask(%p) pulColor(%p)", iRow, cy, pjAndMask, pulColor));
        pj = pjAndMask;
        pul = pulColor;
        CI2ColorIndex = CI2ColorData = 0;

        for (iCol = 0; iCol < cx; ++iCol, CI2ColorIndex += 2)
        {
            AndBit = (BYTE)(7 - (iCol & 7));
            if (AndBit == 7)
            {
                // we're onto the next byte of the and mask
                AndByte = *pj++;
            }
            if (CI2ColorIndex == 8)
            {
                // we've filled a byte with 4 CI2 colors
                DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: writing cursor data %xh", CI2ColorData));
                P3RD_LOAD_CURSOR_ARRAY(CI2ColorData);
                CI2ColorData = 0;
                CI2ColorIndex = 0;
            }

            // get the source pixel
            if (ppdev->cPelSize == GLINTDEPTH32)
            {
                ulColor = *pul++;
            }
            else
            {
                ulColor = *(USHORT *)pul;
                (USHORT *)pul += 1;
            }

            DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: Column %d (of %d) AndByte(%08xh) AndBit(%d) ulColor(%08xh)", iCol, cx, AndByte, AndBit, ulColor));

//@@BEGIN_DDKSPLIT
#if 0
            // TMM: We only used to assume a pixel was transparent if the
            // AND mask bit was set and the pixel was zero, I am pretty sure
            // that this is wrong. We also used to do some stuff with 
            // inverse pixels but that was wrong as well.
            if(AndByte & (1 << AndBit))
            {
                // transparent and seeing as the CI2ColorData is initialized to 0 we don't
                // have to explicitly clear these bits - go on to the next pixel
                DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: transparent - ignore"));
                continue;
            }
#else
//@@END_DDKSPLIT
            // Figure out what to do with it:-
            // AND  Color   Result
            //  0     X     color
            //  1     0     transparent
            //  1     1     inverse
            if (AndByte & (1 << AndBit))
            {
                // Transparent or inverse
                if (ulColor == ppdev->ulWhite)
                {
                    // color == white: inverse, but we don't support this. We've destroyed the cache for nothing
                    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: failed - inverted colors aren't supported"));
                    return(FALSE);
                }

//@@BEGIN_DDKSPLIT
                // if we get here the color should be black. However, if the pointer surface has been translated it
                // might not be exactly black (e.g. as for the pointer at the start of Riven), so we don't do the test
                //if(ulColor == 0)
//@@END_DDKSPLIT
                {
                    // color == black: transparent and seeing as the CI2ColorData is initialized to 0 we don't
                    //have to explicitly clear these bits - go on to the next pixel
                    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: transparent - ignore"));
                    continue;
                }
            }
//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT

            // get the index for this color: first see if we've already indexed it
            DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: looking up color %08xh", ulColor));

            for(Index = 0; Index < HighestIndex && aulColorsIndexed[Index] != ulColor; ++Index);

            if (Index == 3)
            {
                // too many colors in this cursor
                DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: failed - cursor has more than 3 colors"));
                return(FALSE);
            }
            else if (Index == HighestIndex)
            {
                // we've found another color: add it to the color index
                DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: adding %08xh to cursor palette", ulColor));
                aulColorsIndexed[HighestIndex++] = ulColor;
            }
            // add this pixel's index to the CI2 cursor data. NB. Need Index+1 as 0 == transparent
            CI2ColorData |= (Index + 1) <<  CI2ColorIndex;
        }

        // end of the cursor row: save the remaining indexed pixels then blank any unused columns
        DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: writing remaining data for this row (%08xh) and %d trailing bytes", CI2ColorData, cjCacheRemx));

        P3RD_LOAD_CURSOR_ARRAY(CI2ColorData);

        if (cjCacheRemx)
        {
            for (cj = cjCacheRemx; --cj >=0;)
            {
                P3RD_LOAD_CURSOR_ARRAY(P3RD_CURSOR_3_COLOR_TRANSPARENT);
            }
        }
    }

    // end of cursor: blank any unused rows Nb. cjCacheRemy == cy blank rows * cj bytes per row
    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: writing %d trailing bytes for this cursor", cjCacheRemy));

    for (cj = cjCacheRemy; --cj >= 0;)
    {
        // 0 == transparent
        P3RD_LOAD_CURSOR_ARRAY(P3RD_CURSOR_3_COLOR_TRANSPARENT);
    }

    DISPDBG((DBGLVL, "bSet3ColorPointerShapeP3RD: setting up the cursor palette"));

    // now set-up the cursor palette

    for (iCol = 0; iCol < HighestIndex; ++iCol)
    {
        ULONG lutIndex;

        // the cursor colors are at native depth, convert them to 24bpp
        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            // 32bpp
            b = 0xff &  aulColorsIndexed[iCol];
            g = 0xff & (aulColorsIndexed[iCol] >> 8);
            r = 0xff & (aulColorsIndexed[iCol] >> 16);
        }
        else //(ppdev->cPelSize == GLINTDEPTH16)
        {
            if (ppdev->ulWhite == 0xffff)
            {
                // 16bpp
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x3f & (aulColorsIndexed[iCol] >> 5))   << 2;
                r = (0x1f & (aulColorsIndexed[iCol] >> 11))  << 3;
            }
            else
            {
                // 15bpp
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x1f & (aulColorsIndexed[iCol] >> 5))   << 3;
                r = (0x1f & (aulColorsIndexed[iCol] >> 10))  << 3;
            }
        }
        // The P3 cursor has the color LUT upside down.
        lutIndex = P3RD_CALCULATE_LUT_INDEX (iCol);
        P3RD_CURSOR_PALETTE_CURSOR_RGB(lutIndex, r, g, b);
    }

    // enable the cursor
    P3RD_CURSOR_HOTSPOT(xHot, yHot);
    if (x != -1)
    {
        vMovePointerP3RD (ppdev, x, y);

        // need to explicitly show the pointer
        vShowPointerP3RD(ppdev, TRUE);
    }

    DISPDBG((DBGLVL, "b3ColorSetPointerShapeP3RD done"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSet15ColorPointerShapeP3RD
*
* stores the 15-color cursor in the RAMDAC: currently only 32bpp and 15/16bpp
* cursors are supported
*
\**************************************************************************/

BOOL
bSet15ColorPointerShapeP3RD(
PPDEV       ppdev,
SURFOBJ     *psoMask,   // defines AND and MASK bits for cursor
SURFOBJ     *psoColor,  // we may handle some color cursors at some point
LONG        x,          // If -1, pointer should be created hidden
LONG        y,
LONG        xHot,
LONG        yHot)
{
    LONG    cx, cy;
    LONG    cxcyCache;
    LONG    cjCacheRow, cjCacheRemx, cjCacheRemy, cj;
    BYTE    *pjAndMask, *pj;
    ULONG   *pulColor, *pul;
    LONG    cjAndDelta, cjColorDelta;
    LONG    iRow, iCol;
    BYTE    AndBit, AndByte;
    ULONG   CI4ColorIndex, CI4ColorData;
    ULONG   ulColor;
    ULONG   aulColorsIndexed[15];
    LONG    Index, HighestIndex = 0;
    ULONG   r, g, b;
    ULONG   whichOne = 0;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD started"));

    // If we are switching from a mono cursor to a colour one then disable
    // the cursor in the cursor mode. Note that this is potentially dangerous
    // and we are seeing screen flashes on occasions.
    if (pP3RDinfo->cursorSize == P3RD_CURSOR_SIZE_32_MONO || pP3RDinfo->cursorSize == P3RD_CURSOR_SIZE_64_MONO)
    {
        DISABLE_CURSOR_MODE();
    }

    cx = psoColor->sizlBitmap.cx;
    cy = psoColor->sizlBitmap.cy;

    if (cx <= 32 && cy <= 32)
    {
        ULONG curItem;
        cxcyCache = 32;

        // If we are using a mono cursor in the first or second entry, or we have a
        // 15 colour cursor in the top half of cursor memory then download
        // this colour cursor to the download to the 2nd half of cursor memory, otherwise
        // download to the top half.
        curItem = (pP3RDinfo->cursorModeCurrent >> 1) & 0x7;
        if (curItem == 1 || curItem == 2 || curItem == 5)
            whichOne = 1;
        
        pP3RDinfo->cursorSize = P3RD_CURSOR_SIZE_32_15COLOR;
        pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff | P3RD_CURSOR_SEL(pP3RDinfo->cursorSize, whichOne) | P3RD_CURSOR_MODE_15COLOR;

        // We don't cache color cursors, because we want to force the mono cursor to use the 
        // either the first or third entries we can't just do a HWPointerCacheInvalidate(), because
        // the mono cursor code will use the first entry or the time. So, if we want the 
        // mono code to use the 3rd entry we say that first 2 cache entries are valid but mess them
        // up by incrementing the first byte, so that the cache check will always fail.
        ppdev->HWPtrCache.ptrCacheInUseCount = (whichOne == 0) ? 2 : 0;
        for (iCol = 0; iCol < ppdev->HWPtrCache.ptrCacheInUseCount; iCol++)
            (*(((BYTE *) ppdev->HWPtrCache.ptrCacheData) + (iCol * SMALL_POINTER_MEM)))++;
    }
    else if (cx <= 64 && cy <= 64)
    {
        // it's too big to cache as a fifteen color cursor, but we might just be able to cache it
        // if it has 3 or fewer colors
        BOOL bRet;

        bRet = bSet3ColorPointerShapeP3RD(ppdev, psoMask, psoColor, x, y, xHot, yHot);
        return(bRet);
    }
    else
    {
        DISPDBG((DBGLVL, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    // work out the remaining bytes in the cache (in x and y) that will need clearing
    cjCacheRow  = 2 * cxcyCache / 8;
    cjCacheRemx =  cjCacheRow - 2 * ((cx+7) / 8);
    cjCacheRemy = (cxcyCache - cy) * cjCacheRow;

    // set-up a pointer to the 1bpp AND mask bitmap
    pjAndMask = psoMask->pvScan0;
    cjAndDelta = psoMask->lDelta;

    // set-up a pointer to the 32bpp color bitmap
    pulColor = psoColor->pvScan0;
    cjColorDelta = psoColor->lDelta;

    // hide the pointer
    vShowPointerP3RD(ppdev, FALSE);

    // load the cursor array (we have auto-increment turned on so initialize to entry 0 here)
    P3RD_CURSOR_ARRAY_START(whichOne * (32 * 32 * 4 / 8));
    for (iRow = 0; iRow < cy; ++iRow, pjAndMask += cjAndDelta, (BYTE *)pulColor += cjColorDelta)
    {
        DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: Row %d (of %d): pjAndMask(%p) pulColor(%p)", iRow, cy, pjAndMask, pulColor));
        pj = pjAndMask;
        pul = pulColor;
        CI4ColorIndex = CI4ColorData = 0;

        for (iCol = 0; iCol < cx; ++iCol, CI4ColorIndex += 4)
        {
            AndBit = (BYTE)(7 - (iCol & 7));
            if (AndBit == 7)
            {
                // we're onto the next byte of the and mask
                AndByte = *pj++;
            }
            if (CI4ColorIndex == 8)
            {
                // we've filled a byte with 2 CI4 colors
                DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: writing cursor data %xh", CI4ColorData));
                P3RD_LOAD_CURSOR_ARRAY(CI4ColorData);
                CI4ColorData = 0;
                CI4ColorIndex = 0;
            }

            // get the source pixel
            if (ppdev->cPelSize == GLINTDEPTH32)
            {
                ulColor = *pul++;
            }
            else
            {
                ulColor = *(USHORT *)pul;
                (USHORT *)pul += 1;
            }

            DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: Column %d (of %d) AndByte(%08xh) AndBit(%d) ulColor(%08xh)", iCol, cx, AndByte, AndBit, ulColor));

//@@BEGIN_DDKSPLIT
#if 0
            // TMM: We only used to assume a pixel was transparent if the
            // AND mask bit was set and the pixel was zero, I am pretty sure
            // that this is wrong. We also used to do some stuff with 
            // inverse pixels but that was wrong as well.
            if(AndByte & (1 << AndBit))
            {
                // transparent and seeing as the CI2ColorData is initialized to 0 we don't
                // have to explicitly clear these bits - go on to the next pixel
                DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: transparent - ignore"));
                continue;
            }
#else
//@@END_DDKSPLIT
            // Figure out what to do with it:-
            // AND  Color   Result
            //  0     X     color
            //  1     0     transparent
            //  1     1     inverse
            if (AndByte & (1 << AndBit))
            {
                // Transparent or inverse
                if(ulColor == ppdev->ulWhite)
                {
                    // color == white: inverse, but we don't support this. We've destroyed the cache for nothing
                    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: failed - inverted colors aren't supported"));
                    return(FALSE);
                }

                // if we get here the color should be black. However, if the pointer surface has been translated it
                // might not be exactly black (e.g. as for the pointer at the start of Riven), so we don't do the test
                //if(ulColor == 0)
                {
                    // color == black: transparent and seeing as the CI2ColorData is initialized to 0 we don't
                    //have to explicitly clear these bits - go on to the next pixel
                    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: transparent - ignore"));
                    continue;
                }
            }
//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT

            // get the index for this color: first see if we've already indexed it
            DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: looking up color %08xh", ulColor));

            for (Index = 0; Index < HighestIndex && aulColorsIndexed[Index] != ulColor; ++Index);

            if (Index == 15)
            {
                // too many colors in this cursor
                DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: failed - cursor has more than 15 colors"));
                return(FALSE);
            }
            else if (Index == HighestIndex)
            {
                // we've found another color: add it to the color index
                DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: adding %08xh to cursor palette", ulColor));
                aulColorsIndexed[HighestIndex++] = ulColor;
            }
            // add this pixel's index to the CI4 cursor data. NB. Need Index+1 as 0 == transparent
            CI4ColorData |= (Index + 1) << CI4ColorIndex;
        }

        // end of the cursor row: save the remaining indexed pixels then blank any unused columns
        DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: writing remaining data for this row (%08xh) and %d trailing bytes", CI4ColorData, cjCacheRemx));

        P3RD_LOAD_CURSOR_ARRAY(CI4ColorData);

        if (cjCacheRemx)
        {
            for (cj = cjCacheRemx; --cj >=0;)
            {
                P3RD_LOAD_CURSOR_ARRAY(P3RD_CURSOR_15_COLOR_TRANSPARENT);
            }
        }
    }

    // end of cursor: blank any unused rows Nb. cjCacheRemy == cy blank rows * cj bytes per row

    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: writing %d trailing bytes for this cursor", cjCacheRemy));

    for (cj = cjCacheRemy; --cj >= 0;)
    {
        // 0 == transparent
        P3RD_LOAD_CURSOR_ARRAY(P3RD_CURSOR_15_COLOR_TRANSPARENT);
    }

    DISPDBG((DBGLVL, "bSet15ColorPointerShapeP3RD: setting up the cursor palette"));

    // now set-up the cursor palette

    for (iCol = 0; iCol < HighestIndex; ++iCol)
    {
        ULONG lutIndex;

        // the cursor colors are at native depth, convert them to 24bpp

        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            // 32bpp
            b = 0xff &  aulColorsIndexed[iCol];
            g = 0xff & (aulColorsIndexed[iCol] >> 8);
            r = 0xff & (aulColorsIndexed[iCol] >> 16);
        }
        else //(ppdev->cPelSize == GLINTDEPTH16)
        {
            if (ppdev->ulWhite == 0xffff)
            {
                // 16bpp
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x3f & (aulColorsIndexed[iCol] >> 5))   << 2;
                r = (0x1f & (aulColorsIndexed[iCol] >> 11))  << 3;
            }
            else
            {
                // 15bpp
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x1f & (aulColorsIndexed[iCol] >> 5))   << 3;
                r = (0x1f & (aulColorsIndexed[iCol] >> 10))  << 3;
            }
        }
        // The P3 cursor has the color LUT upside down.
        lutIndex = P3RD_CALCULATE_LUT_INDEX (iCol);
        P3RD_CURSOR_PALETTE_CURSOR_RGB(lutIndex, r, g, b);
    }

    // enable the cursor
    P3RD_CURSOR_HOTSPOT(xHot, yHot);
    if (x != -1)
    {
        vMovePointerP3RD (ppdev, x, y);
        // need to explicitly show the pointer
        vShowPointerP3RD(ppdev, TRUE);
    }

    DISPDBG((DBGLVL, "b3ColorSetPointerShapeP3RD done"));
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vEnablePointerP3RD
*
* Get the hardware ready to use the 3Dlabs P3RD hardware pointer.
*
\**************************************************************************/

VOID
vEnablePointerP3RD(
PPDEV ppdev)
{
    pP3RDRAMDAC pRamdac;
    ULONG       ul;

    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    
    GLINT_DECL_INIT;

    DISPDBG((DBGLVL, "vEnablePointerP3RD called"));

    ppdev->pvPointerData = &ppdev->ajPointerData[0];
    
    P3RD_DECL_INIT;
    // get a pointer to the RAMDAC registers from the memory mapped
    // control register space.
    //
    pRamdac = (pP3RDRAMDAC)(ppdev->pulRamdacBase);

    // set up memory mapping for the control registers and save in the pointer
    // specific area provided in ppdev.
    //

    P3RD_PAL_WR_ADDR    = TRANSLATE_ADDR(&(pRamdac->RDPaletteWriteAddress));
    P3RD_PAL_RD_ADDR    = TRANSLATE_ADDR(&(pRamdac->RDPaletteAddressRead));
    P3RD_PAL_DATA       = TRANSLATE_ADDR(&(pRamdac->RDPaletteData));
    P3RD_PIXEL_MASK     = TRANSLATE_ADDR(&(pRamdac->RDPixelMask));
    P3RD_INDEX_ADDR_HI  = TRANSLATE_ADDR(&(pRamdac->RDIndexHigh));
    P3RD_INDEX_ADDR_LO  = TRANSLATE_ADDR(&(pRamdac->RDIndexLow));
    P3RD_INDEX_DATA     = TRANSLATE_ADDR(&(pRamdac->RDIndexedData));
    P3RD_INDEX_CONTROL  = TRANSLATE_ADDR(&(pRamdac->RDIndexControl));

    // not used, but set-up zero anyway
    ppdev->xPointerHot = 0;
    ppdev->yPointerHot = 0;

    // enable auto-increment
    ul = READ_P3RDREG_ULONG(P3RD_INDEX_CONTROL);
    ul |= P3RD_IDX_CTL_AUTOINCREMENT_ENABLED;
    WRITE_P3RDREG_ULONG(P3RD_INDEX_CONTROL, ul);

    P3RD_READ_INDEX_REG(P3RD_CURSOR_CONTROL, pP3RDinfo->cursorControl);

    pP3RDinfo->cursorModeCurrent = pP3RDinfo->cursorModeOff = 0;
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_MODE, pP3RDinfo->cursorModeOff);

    P3RD_INDEX_REG(P3RD_CURSOR_X_LOW);
    P3RD_LOAD_DATA(0);    // cursor x low
    P3RD_LOAD_DATA(0);    // cursor x high
    P3RD_LOAD_DATA(0);    // cursor y low
    P3RD_LOAD_DATA(0xff); // cursor y high
    P3RD_LOAD_DATA(0);    // cursor x hotspot
    P3RD_LOAD_DATA(0);    // cursor y hotspot
}

/******************************Public*Routine******************************\
* BOOL vDisablePointerP3RD
*
* Does basic pointer tidying up.
\**************************************************************************/

VOID vDisablePointerP3RD(PDEV * ppdev)
{
    // Undraw the pointer, may not be necessary on P3, but we do it
    // on P2.
    vShowPointerP3RD(ppdev, FALSE);
}

//@@BEGIN_DDKSPLIT
#if 0
/******************************Public*Routine******************************\
* VOID vSetOverlayModeP3RD
*
* Enable or disable RAMDAC overlays for the P3RD RAMDAC.
*
*
\**************************************************************************/

VOID
vSetOverlayModeP3RD (PDEV * ppdev, 
ULONG   EnableOverlay,                // 0 to disable, 1 to enable
ULONG   TransparentColor)
{
    ULONG p3rdVal;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    P3RD_READ_INDEX_REG (P3RD_MISC_CONTROL, p3rdVal);        // Read current setting

    if (EnableOverlay == GLINT_ENABLE_OVERLAY)
    {
        // Enable Overlay
        p3rdVal |= P3RD_MISC_CONTROL_OVERLAYS_ENABLED;        // Enable overlays
        p3rdVal |= P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;    // Enable direct colour
        P3RD_LOAD_INDEX_REG (P3RD_MISC_CONTROL, p3rdVal);

        P3RD_LOAD_INDEX_REG (P3RD_OVERLAY_KEY, TransparentColor);    // Set transparent colour
    }
    else
    {
        // Disable Overlay
        p3rdVal &= ~P3RD_MISC_CONTROL_OVERLAYS_ENABLED;        // Disable overlays
        p3rdVal &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;    // Disable direct colour
        P3RD_LOAD_INDEX_REG (P3RD_MISC_CONTROL, p3rdVal);
    }
}

VOID 
vP3RDSetPixelMask(
PPDEV   ppdev,
ULONG   ulMask)
{
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;
    P3RD_SET_PIXEL_READMASK (ulMask);
}

/******************************Public*Routine******************************\
* BOOL bP3RDSwapCSBuffers
*
* Use the pixel read mask to perform color space double buffering. This is
* only called when we have 12bpp with interleaved nibbles. We do a polled
* wait for VBLANK before the swap. In the future we may do all this in the
* miniport via interrupts.
*
* Returns
*   We should never be called if this is inappropriate so return TRUE.
*
\**************************************************************************/

BOOL
bP3RDSwapCSBuffers(
PPDEV   ppdev,
LONG    bufNo)
{
    ULONG index;
    ULONG color;
    GLINT_DECL_VARS;
    P3RD_DECL_VARS;
    GLINT_DECL_INIT;
    P3RD_DECL_INIT;

    // work out the RAMDAC read pixel mask for the buffer, wait for VBLANK
    // and switch it.
    //
    DISPDBG((DBGLVL, "loading the palette to swap to buffer %d", bufNo));
    P3RD_PALETTE_START_WR (0);
    GLINT_WAIT_FOR_VBLANK;     
    if (bufNo == 0)
    {
        for (index = 0; index < 16; ++index)
            for (color = 0; color <= 0xff; color += 0x11)
                P3RD_LOAD_PALETTE (color, color, color);
    }
    else
    {
        for (color = 0; color <= 0xff; color += 0x11)
            for (index = 0; index < 16; ++index)
                P3RD_LOAD_PALETTE (color, color, color);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bP3RDCheckCSBuffering
*
* Determine whether we can do color space double buffering in the current
* mode.
*
* Returns
*   TRUE if we can do the color space double buffering, FALSE otherwise.
*
\**************************************************************************/

BOOL
bP3RDCheckCSBuffering(PPDEV ppdev)
{
    // pixels must be 32 bits deep. White is set to the combined masks for
    // each of red, green and blue. The pattern 0x0f0f0f is unique to
    // interleaved 12 bpp mode.
    //
    return ((ppdev->cPelSize == 2) && (ppdev->ulWhite == 0x0f0f0f));
}

#endif
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\precomp.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: precomp.h
*
* Content: Common headers used throughout the display driver.  This entire 
*          include file will typically be pre-compiled.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#define GLINT   1
#define DBG_TRACK_CODE 0

#include "driver.h"
#include "glint.h"
#include "lines.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrxstrp.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrxstrp.c
*
* Content:
*
//@@BEGIN_DDKSPLIT
* All the line code in this driver amounts to a big bag of dirt.  Someday,
* I'm going to rewrite it all.  Not today, though (sigh)...
* Original comment!. Rewritten for GLINT. Styled lines could do with more
* work, but Solid lines should be about as optimal as possible without
* rewriting the algorithm that calls these functions.
//@@END_DDKSPLIT
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "pxrx.h"

/**************************************************************************\
*
* BOOL pxrxInitStrips
*
\**************************************************************************/
BOOL pxrxInitStrips( 
    PPDEV ppdev, 
    ULONG ulColor, 
    DWORD logicOp, 
    RECTL *prclClip ) 
{
    DWORD config2D;
    BOOL  bInvalidateScissor = FALSE;
    GLINT_DECL;

    VALIDATE_DD_CONTEXT;

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 7 );

    if( logicOp == __GLINT_LOGICOP_COPY ) 
    {
        config2D = __CONFIG2D_CONSTANTSRC | 
                   __CONFIG2D_FBWRITE;
    } 
    else 
    {
        config2D = __CONFIG2D_LOGOP_FORE(logicOp) | 
                   __CONFIG2D_CONSTANTSRC         | 
                   __CONFIG2D_FBWRITE;

        if( LogicopReadDest[logicOp] ) 
        {
            config2D |= __CONFIG2D_FBDESTREAD;
            SET_READ_BUFFERS;
        }
    }

    LOAD_FOREGROUNDCOLOUR( ulColor );

    if( prclClip ) 
    {
        config2D |= __CONFIG2D_USERSCISSOR;
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY, 
                            MAKEDWORD_XY(prclClip->left,  prclClip->top   ) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 
                            MAKEDWORD_XY(prclClip->right, prclClip->bottom) );
        
        if(ppdev->cPelSize == GLINTDEPTH32)
        {
            bInvalidateScissor = TRUE;
        }
    }
    
    LOAD_CONFIG2D( config2D );

    SEND_PXRX_DMA_BATCH;

    glintInfo->savedConfig2D = config2D;
    glintInfo->savedLOP = logicOp;
    glintInfo->savedCol = ulColor;
    glintInfo->savedClip = prclClip;

    DISPDBG((DBGLVL, "pxrxInitStrips done"));
    return (bInvalidateScissor);
}

/**************************************************************************\
*
* VOID pxrxResetStrips
*
\**************************************************************************/
VOID pxrxResetStrips( 
    PPDEV ppdev ) 
{
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxResetStrips called"));

    // Reset the scissor maximums:
    WAIT_PXRX_DMA_TAGS( 1 );
    QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    SEND_PXRX_DMA_BATCH;
}

/**************************************************************************\
*
* VOID pxrxIntegerLine
*
\**************************************************************************/
BOOL pxrxIntegerLine( 
    PPDEV ppdev, 
    LONG  X1, 
    LONG  Y1, 
    LONG  X2, 
    LONG  Y2 ) 
{
    LONG    dx, dy, adx, ady;
    GLINT_DECL;

    // Convert points to INT format:
    X1 >>= 4;
    Y1 >>= 4;
    X2 >>= 4;
    Y2 >>= 4;

    if( (adx = dx = X2 - X1) < 0 )
    {
        adx = -adx;
    }

    if( (ady = dy = Y2 - Y1) < 0 )
    {
        ady = -ady;
    }

    WAIT_PXRX_DMA_TAGS( 3+2 );
    if( adx > ady ) 
    {
        // X major line:
        if( ady == dy ) 
        {
            // +ve minor delta
            if((ady)        && 
               (adx != ady) && 
               (adx > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P) ) 
            {
                DISPDBG((DBGLVL, "pxrxIntegerLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxIntegerLine: [X +] delta = (%d, %d), "
                             "bias = (0x%08x)", 
                             dx, dy, P3_LINES_BIAS_P));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagYBias, P3_LINES_BIAS_P );
        } 
        else 
        {
            // -ve minor delta
            if( (ady)        && 
                (adx != ady) && 
                (adx > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N) ) 
            {
                DISPDBG((DBGLVL, "pxrxIntegerLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxIntegerLine: [X -] delta = (%d, %d), "
                             "bias = (0x%08x)", 
                             dx, dy, P3_LINES_BIAS_N));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagYBias, P3_LINES_BIAS_N );
        }
    } 
    else 
    {
        // Y major line:
        if( adx == dx ) 
        {
            // +ve minor delta
            if( (adx)        && 
                (adx != ady) && 
                (ady > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P) ) 
            {
                DISPDBG((DBGLVL, "pxrxIntegerLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxIntegerLine: [Y +] delta = (%d, %d), "
                             "bias = (0x%08x)", 
                             dx, dy, P3_LINES_BIAS_P));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagXBias, P3_LINES_BIAS_P );
        } 
        else 
        {
            // -ve minor delta
            if( (adx)        && 
                (adx != ady) && 
                (ady > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N) ) 
            {
                DISPDBG((DBGLVL, "pxrxIntegerLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxIntegerLine: [Y -] delta = (%d, %d), "
                             "bias = (0x%08x)", 
                             dx, dy, P3_LINES_BIAS_N));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagXBias, P3_LINES_BIAS_N );
        }
    }

    QUEUE_PXRX_DMA_INDEX3( __DeltaTagLineCoord0, 
                           __DeltaTagLineCoord1, 
                           __DeltaTagDrawLine2D01 );
                           
    QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X1, Y1) );
    QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X2, Y2) );
    QUEUE_PXRX_DMA_DWORD( 0 );

    SEND_PXRX_DMA_BATCH;

    glintInfo->lastLine = 1;

    DISPDBG((DBGLVL, "pxrxIntegerLine done"));
    return TRUE;
}

/**************************************************************************\
*
* BOOL pxrxContinueLine
*
\**************************************************************************/
BOOL pxrxContinueLine( 
    PPDEV ppdev, 
    LONG  X1, 
    LONG  Y1, 
    LONG  X2, 
    LONG  Y2 ) 
{
    LONG    dx, dy, adx, ady;
    GLINT_DECL;

    // Convert points to INT format:
    X1 >>= 4;
    Y1 >>= 4;
    X2 >>= 4;
    Y2 >>= 4;

    if( (adx = dx = X2 - X1) < 0 )
    {
        adx = -adx;
    }

    if( (ady = dy = Y2 - Y1) < 0 )
    {
        ady = -ady;
    }

    WAIT_PXRX_DMA_TAGS( 3+2 );
    
    if( adx > ady ) 
    {
        // X major line:
        if( ady == dy ) 
        {
            // +ve minor delta
            if( (ady)        && 
                (adx != ady) && 
                (adx > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P) ) 
            {
                DISPDBG((DBGLVL, "pxrxContinueLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxContinueLine: delta = (%d, %d), "
                             "bias = (0x%08x), last = %d", 
                             dx, dy, P3_LINES_BIAS_P, glintInfo->lastLine));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagYBias, P3_LINES_BIAS_P );
        } 
        else 
        {
            // -ve minor delta
            if( (ady)        && 
                (adx != ady) && 
                (adx > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N) ) 
            {
                DISPDBG((DBGLVL, "pxrxContinueLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxContinueLine: delta = (%d, %d), "
                             "bias = (0x%08x), last = %d", 
                             dx, dy, P3_LINES_BIAS_N, glintInfo->lastLine));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagYBias, P3_LINES_BIAS_N );
        }
    } 
    else 
    {
        // Y major line:
        if( adx == dx ) 
        {
            // +ve minor delta
            if( (adx)        && 
                (adx != ady) && 
                (ady > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_P) ) 
            {
                DISPDBG((DBGLVL, "pxrxContinueLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxContinueLine: delta = (%d, %d), "
                             "bias = (0x%08x), last = %d", 
                             dx, dy, P3_LINES_BIAS_P, glintInfo->lastLine));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagXBias, P3_LINES_BIAS_P );
        } 
        else 
        {
            // -ve minor delta
            if( (adx)        && 
                (adx != ady) && 
                (ady > MAX_LENGTH_CONFORMANT_P3_INTEGER_LINES_N) ) 
            {
                DISPDBG((DBGLVL, "pxrxContinueLine failed"));
                return FALSE;
            }

            DISPDBG((DBGLVL, "pxrxContinueLine: delta = (%d, %d), "
                             "bias = (0x%08x), last = %d", 
                             dx, dy, P3_LINES_BIAS_N, glintInfo->lastLine));
                             
            QUEUE_PXRX_DMA_TAG( __DeltaTagXBias, P3_LINES_BIAS_N );
        }
    }

    if( glintInfo->lastLine == 0 ) 
    {
        QUEUE_PXRX_DMA_INDEX2( __DeltaTagLineCoord1, 
                               __DeltaTagDrawLine2D01 );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X2, Y2) );
        QUEUE_PXRX_DMA_DWORD( 0 );
        glintInfo->lastLine = 1;
    } 
    else if( glintInfo->lastLine == 1 ) 
    {
        QUEUE_PXRX_DMA_INDEX2( __DeltaTagLineCoord0, 
                               __DeltaTagDrawLine2D10 );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X2, Y2) );
        QUEUE_PXRX_DMA_DWORD( 0 );
        glintInfo->lastLine = 0;
    }
    else
    {
        // lastline == 2
        QUEUE_PXRX_DMA_INDEX3( __DeltaTagLineCoord0, 
                               __DeltaTagLineCoord1, 
                               __DeltaTagDrawLine2D01 );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X1, Y1) );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(X2, Y2) );
        QUEUE_PXRX_DMA_DWORD( 0 );

        glintInfo->lastLine = 1;
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxContinueLine done"));
    return TRUE;
}


/******************************Public*Routine******************************\
* VOID vPXRXSolidHorizontalLine
*
* Draws left-to-right x-major near-horizontal lines using short-stroke
* vectors.  
*
\**************************************************************************/

VOID vPXRXSolidHorizontalLine( 
    PDEV      *ppdev, 
    STRIP     *pStrip, 
    LINESTATE *pLineState )
{
    LONG    cStrips;
    PLONG   pStrips;
    LONG    iCurrent;
    GLINT_DECL;

    cStrips = pStrip->cStrips;

    WAIT_PXRX_DMA_TAGS( 10 );

    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom, 0 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXSub, 0 );

    // Set up the start point
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(pStrip->ptlStart.x) );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartY,    INTtoFIXED(pStrip->ptlStart.y) );

    // Set up the deltas for rectangle drawing. Also set Y return value.
    if( !(pStrip->flFlips & FL_FLIP_V) ) 
    {
        QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(1) );
        pStrip->ptlStart.y += cStrips;
    } 
    else 
    {
        QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(-1) );
        pStrip->ptlStart.y -= cStrips;
    }

    pStrips = pStrip->alStrips;

    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    iCurrent = pStrip->ptlStart.x + *pStrips++; // Xsub, Start of next strip
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
    QUEUE_PXRX_DMA_TAG( __GlintTagCount,     1 );// Rectangle 1 scanline high
    QUEUE_PXRX_DMA_TAG( __GlintTagRender,    __RENDER_TRAPEZOID_PRIMITIVE );

    if( --cStrips ) 
    {
        while( cStrips > 1 ) 
        {
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            iCurrent += *pStrips++;
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, 1 );

            WAIT_PXRX_DMA_TAGS( 2 + 2 );

            // Second strip of each pair to fill. XDom is valid. Need new XSub
            iCurrent += *pStrips++;
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub, 1 );

            cStrips -=2;
        }

        // We may have one last line to draw. Xsub will be valid.
        if( cStrips ) 
        {
            iCurrent += *pStrips++;
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, 1 );
        }
    }

    SEND_PXRX_DMA_BATCH;

    // Return last point. Y already calculated when we knew the direction.
    pStrip->ptlStart.x = iCurrent;
}

/******************************Public*Routine******************************\
* VOID vPXRXSolidVertical
*
* Draws left-to-right y-major near-vertical lines using short-stroke
* vectors.  
*
\**************************************************************************/

VOID vPXRXSolidVerticalLine( 
    PDEV      *ppdev, 
    STRIP     *pStrip, 
    LINESTATE *pLineState )
{
    LONG    cStrips, yDir;
    PLONG   pStrips;
    LONG    iCurrent, iLen, iLenSum;
    GLINT_DECL;

    cStrips = pStrip->cStrips;

    WAIT_PXRX_DMA_TAGS( 10 );

    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,        0 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,        0 );

    // Set up the start point
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(pStrip->ptlStart.x) );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartY,    INTtoFIXED(pStrip->ptlStart.y) );

    // Set up the deltas for rectangle drawing.
    if( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }
    
    QUEUE_PXRX_DMA_TAG( __GlintTagdY, INTtoFIXED(yDir) );

    pStrips = pStrip->alStrips;

    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    iCurrent = pStrip->ptlStart.x + 1;          // Xsub, Start of next strip
    iLenSum = (iLen = *pStrips++);
    
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
    QUEUE_PXRX_DMA_TAG( __GlintTagCount, iLen ); // Rectangle 1 scanline high
    QUEUE_PXRX_DMA_TAG( __GlintTagRender, __RENDER_TRAPEZOID_PRIMITIVE );

    if( --cStrips ) 
    {
        while( cStrips > 1 ) 
        {
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            iCurrent++;
            iLenSum += (iLen = *pStrips++);
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, iLen );

            WAIT_PXRX_DMA_TAGS( 2 + 2 );

            // Second strip of each pair to fill. XDom is valid. Need new XSub
            iCurrent++;
            iLenSum += (iLen = *pStrips++);
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub, iLen );      
            cStrips -=2;
        }

        // We may have one last line to draw. Xsub will be valid.
        if( cStrips ) 
        {
            iCurrent++;
            iLenSum += (iLen = *pStrips++);
            QUEUE_PXRX_DMA_TAG(__GlintTagStartXDom, INTtoFIXED(iCurrent));
            QUEUE_PXRX_DMA_TAG(__GlintTagContinueNewDom, iLen);
        }
    }

    SEND_PXRX_DMA_BATCH;

    // Return last point. 
    pStrip->ptlStart.x = iCurrent;
    pStrip->ptlStart.y += iLenSum * yDir;
}

/******************************Public*Routine******************************\
* VOID vPXRXSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using short-stroke
* vectors.  
*
\**************************************************************************/

VOID vPXRXSolidDiagonalVerticalLine( 
    PDEV      *ppdev, 
    STRIP     *pStrip, 
    LINESTATE *pLineState )
{
    LONG    cStrips, yDir;
    PLONG   pStrips;
    LONG    iCurrent, iLen, iLenSum;
    GLINT_DECL;

    cStrips = pStrip->cStrips;

    if( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }

    WAIT_PXRX_DMA_TAGS( 10 );

    // Set up the deltas for rectangle drawing.
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,        INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,        INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,           INTtoFIXED(yDir) );

    pStrips = pStrip->alStrips;

    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    QUEUE_PXRX_DMA_TAG( __GlintTagStartY,    INTtoFIXED(pStrip->ptlStart.y) );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(pStrip->ptlStart.x+1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(pStrip->ptlStart.x) );

    iLenSum = (iLen = *pStrips++);
    iCurrent = pStrip->ptlStart.x + iLen - 1;       // Start of next strip

    QUEUE_PXRX_DMA_TAG( __GlintTagCount, iLen);     // Trap iLen scanline high
    QUEUE_PXRX_DMA_TAG( __GlintTagRender, __RENDER_TRAPEZOID_PRIMITIVE);

    if( --cStrips ) 
    {
        while( cStrips > 1 ) 
        {
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, iLen );

            WAIT_PXRX_DMA_TAGS( 2 + 2 );

            // Second strip of each pair to fill. XDom is valid. Need new XSub
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, INTtoFIXED(iCurrent) );
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub, iLen );      

            cStrips -=2;
        }

        // We may have one last line to draw. Xsub will be valid.
        if (cStrips) 
        {
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, INTtoFIXED(iCurrent) );
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, iLen );
        }
    }

    SEND_PXRX_DMA_BATCH;

    // Return last point. 
    pStrip->ptlStart.x = iCurrent;
    pStrip->ptlStart.y += iLenSum * yDir;
}

/******************************Public*Routine******************************\
* VOID vPXRXSolidDiagonalHorizontalLine
*
* Draws left-to-right x-major near-diagonal lines using short-stroke
* vectors.  
*
\**************************************************************************/

VOID vPXRXSolidDiagonalHorizontalLine( 
    PDEV      *ppdev, 
    STRIP     *pStrip, 
    LINESTATE *pLineState )
{
    LONG    cStrips, yDir, xCurrent, yCurrent, iLen;
    PLONG   pStrips;
    GLINT_DECL;

    // This routine has to be implemented in a different way to the other 3
    // solid line drawing functions because the rasterizer unit will not 
    // produce 2 pixels on the same scanline without a lot of effort in 
    // producing delta values. In this case, we have to draw a complete new
    // primitive for each strip. Therefore, we have to use lines rather than
    // trapezoids to generate the required strips. With lines we use 4 messages
    // per strip, where trapezoids would use 5.

    cStrips = pStrip->cStrips;

    if( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }

    pStrips = pStrip->alStrips;

    xCurrent = pStrip->ptlStart.x;
    yCurrent = pStrip->ptlStart.y;

    WAIT_PXRX_DMA_TAGS( 3 + 4 );

    // Set up the deltas for rectangle drawing.
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,    INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(yDir) );

    while( TRUE ) 
    {
        // Set up the start point
        QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    INTtoFIXED(xCurrent) );
        QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       INTtoFIXED(yCurrent) );

        iLen = *pStrips++;
        QUEUE_PXRX_DMA_TAG( __GlintTagCount, iLen );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender, __RENDER_LINE_PRIMITIVE );

        xCurrent += iLen;
        if( yDir > 0 ) 
        {
            yCurrent += iLen - 1;
        }
        else
        {
            yCurrent -= iLen - 1;
        }

        if( !(--cStrips) )
        {
            break;
        }

        WAIT_PXRX_DMA_TAGS( 4 );
    }

    SEND_PXRX_DMA_BATCH;

    // Return last point. 
    pStrip->ptlStart.x = xCurrent;
    pStrip->ptlStart.y = yCurrent;
}


/******************************Public*Routine******************************\
* VOID vPXRXStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vPXRXStyledHorizontalLine( 
    PDEV      *ppdev, 
    STRIP     *pstrip, 
    LINESTATE *pls )
{
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    GLINT_DECL;

//@@BEGIN_DDKSPLIT
    // This routine does some quite complex things with patterns. For ease of
    // implementation on GLINT, I have just changed the relevant parts. This,
    // therefore, is definitly not an optimal solution. However, styled lines
    // are really not that important. If anyone feels inclined to do more work
    // here, then fine! XXXX
//@@END_DDKSPLIT    

    if( pstrip->flFlips & FL_FLIP_V )
    {
        dy  = -1;
    }
    else
    {
        dy  = 1;
    }

    cStrips = pstrip->cStrips;        // Total number of strips we'll do
    plStrip = pstrip->alStrips;        // Points to current strip
    x       = pstrip->ptlStart.x;    // x position of start of first strip
    y       = pstrip->ptlStart.y;    // y position of start of first strip

    // Set up the deltas for horizontal line drawing.
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    INTtoFIXED(1) );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,       0 );

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if( bIsGap )
    {
        goto SkipAGap;
    }
    else
    {
        goto OutputADash;
    }

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
    {
        pls->psp = pls->pspStart;
    }

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
    {
        goto SkipAGap;
    }

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
        {
            goto AllDone;
        }

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
        {
            goto PrepareToOutputADash;
        }
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
    {
        pls->psp = pls->pspStart;
    }

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'y'
        // to be the current scan:

        goto OutputADash;
    }

    while( TRUE ) 
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if( cStrips == 0 )
        {
            goto AllDone;
        }

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        // With glint we just download the lines to draw

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    INTtoFIXED(x) );
        QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       INTtoFIXED(y) );
        QUEUE_PXRX_DMA_TAG( __GlintTagCount,        cThis );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender,       __GLINT_LINE_PRIMITIVE );

        x += cThis;

        if( cStyle == 0 )
        {
            goto PrepareToSkipAGap;
        }
    }

AllDone:

    SEND_PXRX_DMA_BATCH;

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vPXRXStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vPXRXStyledVerticalLine( 
    PDEV      *ppdev, 
    STRIP     *pstrip, 
    LINESTATE *pls )
{
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    GLINT_DECL;

//@@BEGIN_DDKSPLIT
    // This routine does some quite complex things with patterns. For ease of
    // implemantation on GLINT, I have just changed the relevant parts. This,
    // therefore, is definitly not an optimal solution. However, styled lines
    // are really not that important. If anyone feels inclined to do more work
    // here, then fine! XXXX
//@@END_DDKSPLIT

    if( pstrip->flFlips & FL_FLIP_V )
    {
        dy = -1;
    }
    else
    {
        dy = 1;
    }

    cStrips = pstrip->cStrips;        // Total number of strips we'll do
    plStrip = pstrip->alStrips;        // Points to current strip
    x       = pstrip->ptlStart.x;    // x position of start of first strip
    y       = pstrip->ptlStart.y;    // y position of start of first strip

    // Set up the deltas for vertical line drawing.
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    0 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(dy) );

    // dxDom and dXSub are initialised to 0, 0, so 
    // we don't need  to re-load them here.

    cStrip = *plStrip;                // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
    {
        goto SkipAGap;
    }
    else
    {
        goto OutputADash;
    }

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
    {
        pls->psp = pls->pspStart;
    }

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
    {
        goto SkipAGap;
    }

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
        {
            goto AllDone;
        }

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
        {
            goto PrepareToOutputADash;
        }
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
    {
        pls->psp = pls->pspStart;
    }

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        goto OutputADash;
    }

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
        {
            goto AllDone;
        }

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        // With glint we just download the lines to draw

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    INTtoFIXED(x) );
        QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       INTtoFIXED(y) );
        QUEUE_PXRX_DMA_TAG( __GlintTagCount,        cThis );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender,       __GLINT_LINE_PRIMITIVE );

        y += (dy > 0) ? cThis : -cThis;

        if( cStyle == 0 )
        {
            goto PrepareToSkipAGap;
        }
    }

AllDone:

    SEND_PXRX_DMA_BATCH;

    // Update our state variables so that the next line can continue
    // where we left off:
    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/**************************************************************************\
 * For a given sub-pixel coordinate (x.m, y.n) in 28.4 fixed point
 * format this array is indexed by (m,n) and indicates whether the
 * given sub-pixel is within a GIQ diamond. m coordinates run left
 * to right; n coordinates ru top to bottom so index the array with
 * ((n<<4)+m). The array as seen here really contains 4 quarter
 * diamonds.
\**************************************************************************/
static unsigned char    in_diamond[] = {
/*          0 1 2 3 4 5 6 7 8 9 a b c d e f          */

/* 0 */     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,    /* 0 */
/* 1 */     1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,    /* 1 */
/* 2 */     1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,    /* 2 */
/* 3 */     1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,    /* 3 */
/* 4 */     1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,    /* 4 */
/* 5 */     1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,    /* 5 */
/* 6 */     1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,    /* 6 */
/* 7 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 7 */
/* 8 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 8 */
/* 9 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 9 */
/* a */     1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,    /* a */
/* b */     1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,    /* b */
/* c */     1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,    /* c */
/* d */     1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,    /* d */
/* e */     1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,    /* e */
/* f */     1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,    /* f */

/*          0 1 2 3 4 5 6 7 8 9 a b c d e f          */
};
/*
 * For lines with abs(slope) != 1 use IN_DIAMOND to determine if an
 * end point is in a diamond. For lines of slope = 1 use IN_S1DIAMOND.
 * For lines of slope = -1 use IN_SM1DIAMOND. The last two are a bit
 * strange. The documentation leaves us with a problem for slope 1
 * lines which run exactly betwen the diamonds. According to the docs
 * such a line can enter a diamond, leave it and enter again. This is
 * plainly rubbish so along the appropriate edge of the diamond we
 * consider a slope 1 line to be inside the diamond. This is the
 * bottom right edge for lines of slope -1 and the bottom left edge for
 * lines of slope 1.
 */
#define IN_DIAMOND(m, n)    (in_diamond[((m) << 4) + (n)])
#define IN_S1DIAMOND(m, n)  ((in_diamond[((m) << 4) + (n)]) || \
                        ((m) - (n) == 8))
#define IN_SM1DIAMOND(m, n) ((in_diamond[((m) << 4) + (n)]) || \
                        ((m) + (n) == 8))

/**************************************************************************\
*
* BOOL pxrxDrawLine
*
\**************************************************************************/

BOOL pxrxDrawLine( 
    PPDEV ppdev, 
    LONG  fx1, 
    LONG  fy1, 
    LONG  fx2, 
    LONG  fy2 ) 
{
    register LONG   adx, ady, tmp;
    FIX     m1, n1, m2, n2;
    LONG    dx, dy;
    LONG    dX, dY;
    LONG    count, startX, startY;
    GLINT_DECL;

    // This function is only called if we have a line with non integer end 
    // points and the unsigned coordinates are no greater than 15.4. 
    //
    // We can only guarantee to do lines whose coords need <= 12 bits
    // of integer. This is because to get the delta we must shift
    // by 16 bits. This includes 4 bits of fraction which means if
    // we have more than 12 bits of integer we get overrun on the
    // shift. We could use floating point to give us a better 16
    // bits of integer but this requires an extra set of multiplies
    // and divides in order to convert from 28.4 to fp. In any case
    // we have to have a test to reject coords needing > 16 bits
    // of integer.
    // Actually, we can deal with 16.4 coordinates provided dx and dy
    // never require more than 12 bits of integer.
    // So optimise for the common case where the line is completely
    // on the screen (actually 0 to 2047.f). Since the coords have
    // 4 bits of fraction we note that a 32 bit signed number
    // outside the range 0 to 2047.f will have one of its top 17
    // bits set. So logical or all the coords and test against
    // 0xffff8000. This is about as quick a test as we can get for
    // both ends of the line being on the screen. If this test fails
    // then we can check everything else at a leisurely pace.

    // get signed and absolute deltas 
    if ((adx = dx = fx2 - fx1) < 0)
    {
        adx = -adx;
    }
    
    if ((ady = dy = fy2 - fy1) < 0)
    {
        ady = -ady;
    }

    // Refuse to draw any lines whose delta is out of range.
    // We have to shift the delta by 16, so we dont want to loose any
    // precision. 
    if ((adx | ady) & 0xffff8000)
    {
        return(FALSE);
    }

    // fractional bits are used to check if point is in a diamond
    m1 = fx1 & 0xf;
    n1 = fy1 & 0xf;
    m2 = fx2 & 0xf;
    n2 = fy2 & 0xf;


    // The rest of the code is a series of cases. Each one is "called" by a
    // goto. This is simply to keep the nesting down. Main cases are: lines
    // with absolute slope == 1; x-major lines; and y-major lines. We draw
    // lines as they are given rather than always drawing in one direction.
    // This adds extra code but saves the time required to swap the points
    // and adjust for not drawing the end point.

    startX = fx1 << 12;
    startY = fy1 << 12;

    DISPDBG((DBGLVL, "GDI Line %x, %x  deltas %x, %x", 
                     startX, startY, dx, dy));

    if (adx < ady)
    {
        goto y_major;
    }

    if (adx > ady)
    {
        goto x_major;
    }


//slope1_line:

    // All slope 1 lines are sampled in X. i.e. we move the start coord to
    // an integer x and let GLINT truncate in y. This is because all GIQ
    // lines are rounded down in y for values exactly half way between two
    // pixels. If we sampled in y then we would have to round up in x for
    // lines of slope 1 and round down in x for other lines. Sampling in x
    // allows us to use the same GLINT bias in all cases (0x7fff). We do
    // the x round up or down when we move the start point.
 
    if (dx != dy)
    {
        goto slope_minus_1;
    }
    
    if (dx < 0)
    {
        goto slope1_reverse;
    }

    dX = 1 << 16;
    dY = 1 << 16;

    if (IN_S1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x8000) & ~0xffff;
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;
    }
    
    startY += tmp - startX;
    startX = tmp;
    
    if (IN_S1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x8) & ~0xf;   // nearest integer 
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer 
    }
    
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

slope1_reverse:
    dX = -1 << 16;
    dY = -1 << 16;
    
    if (IN_S1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x8000) & ~0xffff;
    }
    else
    {
        tmp = startX & ~0xffff;
    }
    
    startY += tmp - startX;
    startX = tmp;
    
    if (IN_S1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x8) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;            // previous integer 
    }
    
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

slope_minus_1:
    if (dx < 0)
    {
        goto slope_minus_dx;
    }

    // dx > 0, dy < 0 
    
    dX = 1 << 16;
    dY = -1 << 16;
    
    if (IN_SM1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;
    }
    
    startY += startX - tmp;
    startX = tmp;
    
    if (IN_SM1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }
    
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

slope_minus_dx:

    dX = -1 << 16;
    dY = 1 << 16;
    
    if (IN_SM1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;
    }
    else
    {
        tmp = startX & ~0xffff;
    }
    
    startY += startX - tmp;
    startX = tmp;
    
    if (IN_SM1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;            // previous integer
    }
        
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

x_major:
    // Dont necessarily render through glint if we are worried
    // about conformance.
    if ((adx > (MAX_LENGTH_CONFORMANT_NONINTEGER_LINES << 4)) &&
        (glintInfo->flags & GLICAP_NT_CONFORMANT_LINES)      &&
        (ady != 0))
    {
        return(FALSE);
    }

    if (dx < 0)
    {
        goto right_to_left_x;
    }

// left_to_right_x:

     // line goes left to right. Round up the start x to an integer
     // coordinate. This is the coord of the first diamond that the
     // line crosses. Adjust start y to match this point on the line.

    dX = 1 << 16;
    
    if (IN_DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;  // next integer
    }

    // we can optimise for horizontal lines
    if (dy != 0) 
    {
        dY = dy << 16;

        // Need to explicitly round delta down for -ve deltas.
        if (dy < 0)
        {
            dY -= adx - 1;
        }
    
        dY /= adx;
        startY += (((tmp - startX) >> 12) * dY) >> 4;
    }
    else
    {
        dY = 0;
    }
    
    startX = tmp;

    if (IN_DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }
    
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

right_to_left_x:

    dX = -1 << 16;
    
    if (IN_DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = startX & ~0xffff;         // previous integer
    }

    // we can optimise for horizontal lines 
    if (dy != 0) 
    {
        dY = dy << 16;

        // Need to explicitly round delta down for -ve deltas.
        if (dy < 0)
        {
            dY -= adx - 1;
        }
    
        dY /= adx;
        startY += (((startX - tmp) >> 12) * dY) >> 4;
    }
    else
    {
        dY = 0;
    }
    
    startX = tmp;

    if (IN_DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;               // previous integer
    }
    
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

y_major:
    // Dont necessarily render through glint if we are worried
    // about conformance.
    if ((ady > (MAX_LENGTH_CONFORMANT_NONINTEGER_LINES << 4)) &&
        (glintInfo->flags & GLICAP_NT_CONFORMANT_LINES)       &&
        (adx != 0))
    {
        return(FALSE);
    }

    if (dy < 0)
    {
        goto high_to_low_y;
    }

// low_to_high_y:

    dY = 1 << 16;
    
    if (IN_DIAMOND(m1, n1))
    {
        tmp = (startY + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = (startY + 0xffff) & ~0xffff;  // next integer
    }

    // we can optimise for vertical lines
    if (dx != 0) 
    {
        dX = dx << 16;

        // Need to explicitly round delta down for -ve deltas.
        if (dx < 0)
        {
            dX -= ady - 1;
        }
    
        dX /= ady;
        startX += (((tmp - startY) >> 12) * dX) >> 4;
    }
    else
    {
        dX = 0;
    }
    
    startY = tmp;

    if (IN_DIAMOND(m2, n2))
    {
        fy2 = (fy2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fy2 = (fy2 + 0xf) & ~0xf;   // next integer
    }
    
    count = (fy2 >> 4) - (startY >> 16);

    goto Draw_Line;

high_to_low_y:

    dY = -1 << 16;
    
    if (IN_DIAMOND(m1, n1))
    {
        tmp = (startY + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = startY & ~0xffff;         // previous integer
    }

    // we can optimise for horizontal lines
    if (dx != 0) 
    {
        dX = dx << 16;

        // Need to explicitly round delta down for -ve deltas.
        if (dx < 0)
        {
            dX -= ady - 1;
        }
    
        dX /= ady;
        startX += (((startY - tmp) >> 12) * dX) >> 4;
    }
    else
    {
        dX = 0;
    }
    
    startY = tmp;

    if (IN_DIAMOND(m2, n2))
    {
        fy2 = (fy2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fy2 &= ~0xf;            // previous integer
    }
    
    count = (startY >> 16) - (fy2 >> 4);

Draw_Line:
    WAIT_PXRX_DMA_TAGS( 6 );

    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    startX + 0x7fff );
    QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       startY + 0x7fff );
    QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,        dX );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY,           dY );
    QUEUE_PXRX_DMA_TAG( __GlintTagCount,        count );
    QUEUE_PXRX_DMA_TAG( __GlintTagRender,       __RENDER_LINE_PRIMITIVE );

    SEND_PXRX_DMA_BATCH;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrxxfer.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrxXfer.c
*
* Content: Bit transfer code
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "ereg.h"
#include "pxrx.h"

#if _DEBUG
static BOOL trapOnMisAlignment = TRUE;

#define  TEST_DWORD_ALIGNED(ptr)                                           \
    do {                                                                   \
        ULONG   addr = (ULONG) ptr;                                        \
                                                                           \
        if( trapOnMisAlignment )                                           \
            ASSERTDD((addr & 3) == 0, "TEST_DWORD_ALIGNED(ptr) failed!");  \
        else                                                               \
        if( addr & 3 )                                                     \
            DISPDBG((-1, "TEST_DWORD_ALIGNED(0x%08X) is out by %d bytes!", \
                          addr, addr & 3));                                \
    } while(0)
#else
#   define  TEST_DWORD_ALIGNED(addr)        do { ; } while(0)
#endif

/**************************************************************************\
*
* VOID pxrxXfer1bpp
*
\**************************************************************************/
VOID pxrxXfer1bpp( 
    PPDEV    ppdev, 
    RECTL    *prcl, 
    LONG     count, 
    ULONG    fgLogicOp, 
    ULONG    bgLogicOp, 
    SURFOBJ  *psoSrc, 
    POINTL   *pptlSrc, 
    RECTL    *prclDst, 
    XLATEOBJ *pxlo ) 
{
    DWORD   config2D, render2D;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE    *pjSrcScan0;
    BYTE    *pjSrc;
    LONG    dxSrc;
    LONG    dySrc;
    LONG    xLeft;
    LONG    yTop;
    LONG    xOffset;
    ULONG   fgColor;
    ULONG   bgColor;
    RBRUSH_COLOR    rbc;
    GLINT_DECL;

    ASSERTDD(count > 0, "Can't handle zero rectangles");
    ASSERTDD(fgLogicOp <= 15, "Weird fg hardware Rop");
    ASSERTDD(bgLogicOp <= 15, "Weird bg hardware Rop");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");

    DISPDBG((DBGLVL, "pxrxXfer1bpp: original dstRect: (%d,%d) to (%d,%d)", 
                     prclDst->left, prclDst->top, 
                     prclDst->right, prclDst->bottom));

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;    // Add to destination to get source

    lSrcDelta = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;
    
    DISPDBG((DBGLVL, "bitmap baseAddr 0x%x, stride %d, w %d, h %d", 
                     pjSrcScan0, lSrcDelta, 
                     psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy));
    DISPDBG((DBGLVL, "fgColor 0x%x, bgColor 0x%x", 
                     pxlo->pulXlate[1], pxlo->pulXlate[0]));
    DISPDBG((DBGLVL, "fgLogicOp %d, bgLogicOp %d", 
                     fgLogicOp, bgLogicOp));

    fgColor = pxlo->pulXlate[1];
    bgColor = pxlo->pulXlate[0];

    // we get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.

    if( ((fgLogicOp == __GLINT_LOGICOP_AND) && (fgColor == ppdev->ulWhite)) ||
        ((fgLogicOp == __GLINT_LOGICOP_OR ) && (fgColor == 0))              ||
        ((fgLogicOp == __GLINT_LOGICOP_XOR) && (fgColor == 0))               )
    {
        fgLogicOp = __GLINT_LOGICOP_NOOP;
    }

    // same for background
    if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite)) ||
        ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))              ||
        ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0))               )
    {
        bgLogicOp = __GLINT_LOGICOP_NOOP;
    }

    if( (fgLogicOp == __GLINT_LOGICOP_NOOP) && 
        (bgLogicOp == __GLINT_LOGICOP_NOOP) ) 
    {
        DISPDBG((DBGLVL, "both ops are no-op so lets quit now"));
        return;
    }

    config2D = glintInfo->config2D;
    
    config2D &= ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                  __CONFIG2D_LOGOP_BACK_ENABLE | 
                  __CONFIG2D_ENABLES);
                  
    config2D |= __CONFIG2D_CONSTANTSRC | 
                __CONFIG2D_FBWRITE | 
                __CONFIG2D_USERSCISSOR;
                
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_OP_SYNCBITMASK;

    if( (fgLogicOp != __GLINT_LOGICOP_COPY) || 
        (bgLogicOp != __GLINT_LOGICOP_NOOP) ) 
    {
        config2D &= ~(__CONFIG2D_LOGOP_FORE_MASK | 
                      __CONFIG2D_LOGOP_BACK_MASK);
        config2D |= __CONFIG2D_OPAQUESPANS | 
                    __CONFIG2D_LOGOP_FORE(fgLogicOp) | 
                    __CONFIG2D_LOGOP_BACK(bgLogicOp);
        render2D |= __RENDER2D_SPANS;
    }

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 6 );

    if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) 
    {
        config2D |= __CONFIG2D_FBDESTREAD;
        SET_READ_BUFFERS;
    }

    if( LogicOpReadSrc[fgLogicOp] )
    {
        LOAD_FOREGROUNDCOLOUR( fgColor );
    }
    
    if( LogicOpReadSrc[bgLogicOp] )
    {
        LOAD_BACKGROUNDCOLOUR( bgColor );
    }

    LOAD_CONFIG2D( config2D );

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "mono download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        yTop  = prcl->top;
        xLeft = prcl->left;
        cx = prcl->right - xLeft;
        cy = prcl->bottom - yTop;

        // pjSrc is first dword containing a bit to download. xOffset is the
        // offset to that bit. i.e. the bit offset from the previous 32bit
        // boundary at the left hand edge of the rectangle.
        xOffset = (xLeft + dxSrc) & 0x1f;
        pjSrc = (BYTE*)((UINT_PTR)(pjSrcScan0 +
                               (yTop  + dySrc) * lSrcDelta +
                               (xLeft + dxSrc) / 8  // byte aligned
                              ) & ~3);              // dword aligned

        DISPDBG((DBGLVL, "pjSrc 0x%x, lSrcDelta %d", pjSrc, lSrcDelta));
        DISPDBG((DBGLVL, "\txOffset %d, cx %d, cy %d", xOffset, cx, cy));

        // this algorithm downloads aligned 32-bit chunks from the
        // source but uses the scissor clip to define the edge of the
        // rectangle.
        //
        {
            ULONG   AlignWidth, LeftEdge;
            AlignWidth = (xOffset + cx + 31) & ~31;
            LeftEdge = xLeft - xOffset;

            DISPDBG((7, "AlignWidth %d", AlignWidth));

            WAIT_PXRX_DMA_DWORDS( 5 );
            QUEUE_PXRX_DMA_INDEX4( __GlintTagFillScissorMinXY, 
                                   __GlintTagFillScissorMaxXY, 
                                   __GlintTagFillRectanglePosition, 
                                   __GlintTagFillRender2D );

            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(xLeft,             0) );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(prcl->right, 0x7fff) );

            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(LeftEdge,             yTop) );
            QUEUE_PXRX_DMA_DWORD( render2D | 
                                  __RENDER2D_WIDTH(AlignWidth) | 
                                  __RENDER2D_HEIGHT(cy) );
            SEND_PXRX_DMA_BATCH;

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
            pxrxMonoDownloadRLE( ppdev, 
                                 AlignWidth, 
                                 (ULONG *) pjSrc, 
                                 lSrcDelta >> 2, 
                                 cy );
#else
//@@END_DDKSPLIT
            pxrxMonoDownloadRaw( ppdev, 
                                 AlignWidth, 
                                 (ULONG *) pjSrc, 
                                 lSrcDelta >> 2, 
                                 cy );
//@@BEGIN_DDKSPLIT                                 
#endif
//@@END_DDKSPLIT
        }

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset the scissor maximums:
    if( ppdev->cPelSize == GLINTDEPTH32 ) {
        WAIT_PXRX_DMA_TAGS( 1 );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
//@@BEGIN_DDKSPLIT        
//      SEND_PXRX_DMA_BATCH;
//@@END_DDKSPLIT
    }

    FLUSH_PXRX_PATCHED_RENDER2D(prclDst->left, prclDst->right);
    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxXfer1bpp returning"));
}

/**************************************************************************\
*
* void pxrxMonoDownloadRaw
*
\**************************************************************************/
void pxrxMonoDownloadRaw( 
    PPDEV ppdev, 
    ULONG AlignWidth, 
    ULONG *pjSrc, 
    LONG lSrcDelta, 
    LONG cy ) 
{
    GLINT_DECL;

    if( AlignWidth == 32 ) 
    {
        LONG    nSpaces = 0;
        ULONG   bits;
        DISPDBG((DBGLVL, "Doing Single Word per scan download"));
        do 
        {
            nSpaces = 10;
            WAIT_FREE_PXRX_DMA_DWORDS( nSpaces );
            
            if( cy < --nSpaces )
            {
                nSpaces = cy;
            }
            
            cy -= nSpaces;

            QUEUE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern, nSpaces );
            
            while( --nSpaces >= 0 ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                QUEUE_PXRX_DMA_DWORD( *pjSrc );
                pjSrc += lSrcDelta;
            }
            
            SEND_PXRX_DMA_BATCH;
        } while( cy > 0 );        
    } 
    else 
    {
        // multiple 32 bit words per scanline. convert the delta to the
        // delta as we need it at the end of each line by subtracting the
        // width in bytes of the data we're downloading. Note, pjSrc
        // is always 1 LONG short of the end of the line because we break
        // before adding on the last ULONG. Thus, we subtract sizeof(ULONG)
        // from the original adjustment.
        LONG    nScan = AlignWidth >> 5;
        LONG    nRemainder;
        ULONG   bits;

        DISPDBG((7, "Doing Multiple Word per scan download"));
        while( TRUE ) 
        {
            WAIT_PXRX_DMA_DWORDS( nScan + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern, nScan );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, nScan );
            SEND_PXRX_DMA_BATCH;
            pjSrc += lSrcDelta;

            if( --cy == 0 )
            {
                break;
            }
        }
    }
}


/**************************************************************************\
*
* VOID pxrxXfer8bpp
*
\**************************************************************************/
VOID pxrxXfer8bpp( 
    PPDEV ppdev, 
    RECTL *prcl, 
    LONG count, 
    ULONG logicOp, 
    ULONG bgLogicOp, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    XLATEOBJ *pxlo ) 
{
    ULONG       config2D, render2D, lutMode, pixelSize;
    BOOL        invalidLUT = FALSE;
    LONG        dx, dy, cy;
    LONG        lSrcDelta, lSrcDeltaDW, lTrueDelta, alignOff;
    ULONG       AlignWidth, LeftEdge;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    UINT_PTR    startPos;
    LONG        cPelInv;
    ULONG       ul;
    LONG        nRemainder;
//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    ULONG       len, data, holdCount;
    ULONG       *tagPtr;
#endif
//@@END_DDKSPLIT
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxXfer8bpp(): src = (%d,%d) -> (%d,%d), "
                     "count = %d, logicOp = %d, palette id = %d", 
                     prcl->left, prcl->right, prcl->top, prcl->bottom, 
                     count, logicOp, pxlo->iUniq));

    // Set up the LUT table:

    if( (ppdev->PalLUTType != LUTCACHE_XLATE) || 
        (ppdev->iPalUniq != pxlo->iUniq) ) 
    {
        // Someone has hijacked the LUT so we need to invalidate it:
        ppdev->PalLUTType = LUTCACHE_XLATE;
        ppdev->iPalUniq = pxlo->iUniq;
        invalidLUT = TRUE;
    } 
    else 
    {
        DISPDBG((DBGLVL, "pxrxXfer8bpp: reusing cached xlate"));
    }

    WAIT_PXRX_DMA_TAGS( 1 + 1 );

    lutMode = glintInfo->lutMode & ~((3 << 2) | (1 << 4) | (7 << 8));
    lutMode |= (ppdev->cPelSize + 2) << 8;
    LOAD_LUTMODE( lutMode );

    if( invalidLUT ) 
    {
        ULONG   *pulXlate = pxlo->pulXlate;
        LONG    cEntries = 256;

        QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, 0 );

        if( ppdev->cPelSize == 0 ) 
        {
            // 8bpp
            WAIT_PXRX_DMA_TAGS( cEntries );

            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 8;
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        } 
        else if( ppdev->cPelSize == 1 ) 
        {    
            // 16bpp
            WAIT_PXRX_DMA_TAGS( cEntries );

            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        } 
        else 
        {
            WAIT_PXRX_DMA_DWORDS( 1 + cEntries );

            QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, cEntries );
            QUEUE_PXRX_DMA_BUFF( pulXlate, cEntries );
        }
    }

    config2D = __CONFIG2D_FBWRITE     | 
               __CONFIG2D_USERSCISSOR | 
               __CONFIG2D_EXTERNALSRC | 
               __CONFIG2D_LUTENABLE;
               
    render2D = __RENDER2D_INCX        |  
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 6 );

    if( logicOp != __GLINT_LOGICOP_COPY ) 
    {
        config2D |= __CONFIG2D_LOGOP_FORE(logicOp) | __CONFIG2D_FBWRITE;
        render2D |= __RENDER2D_SPANS;

        if( LogicopReadDest[logicOp] ) 
        {
            config2D |= __CONFIG2D_FBDESTREAD;
            SET_READ_BUFFERS;
        }
    }

    LOAD_CONFIG2D( config2D );

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, __GlintTagColor );
#endif
//@@END_DDKSPLIT

    cPelInv = 2 - ppdev->cPelSize;
    pixelSize = (1 << 31)       | // Everything before the LUT runs at 8bpp
                (2 << 2)        | 
                (2 << 4)        | 
                (2 << 6)        |        
                (cPelInv << 8)  | 
                (cPelInv << 10) | 
                (cPelInv << 12) | 
                (cPelInv << 14);
                
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, pixelSize );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, 
                         prcl->right, prcl->bottom));

        // 8bpp => 1 pixel per byte => 4 pixels per dword

        // Assume source bitmap width is dword aligned
        ASSERTDD((lSrcDelta & 3) == 0, 
                 "pxrxXfer8bpp: SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!");

        startPos = (((UINT_PTR) pjSrcScan0) + ((prcl->top + dy) * lSrcDelta)) 
                        + (prcl->left + dx);    // pointer to first pixel, 
                                                // in pixels/bytes
        pjSrc    = (ULONG *) (startPos & ~3);   // dword pointer to dword 
                                                // aligned first pixel

        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: pxrxXfer8bpp return ,has pjSrc NULL"));
            return;
        }
        
        alignOff = (ULONG)(startPos & 3); // number of pixels past dword 
                                          // alignment of a scanline
        LeftEdge = prcl->left - alignOff; // dword aligned left edge in pixels
        AlignWidth = ((prcl->right - LeftEdge) + 3) & ~3; // dword aligned width 
                                                          // in pixels
        cy = prcl->bottom - prcl->top;    // number of scanlines to do

        DISPDBG((DBGLVL, "pjSrcScan0 = 0x%08X, "
                         "startPos = 0x%08X, pjSrc = 0x%08X", 
                         pjSrcScan0, startPos, pjSrc));
        DISPDBG((DBGLVL, "offset = %d pixels", alignOff));
        DISPDBG((DBGLVL, "Aligned rect = (%d -> %d) => %d pixels => %d dwords", 
                         LeftEdge, LeftEdge + AlignWidth, 
                         AlignWidth, AlignWidth >> 2));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         
                                    MAKEDWORD_XY(prcl->left,       0) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         
                                    MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                    MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             
                                    render2D                     | 
                                    __RENDER2D_WIDTH(AlignWidth) | 
                                    __RENDER2D_HEIGHT(cy) );
        SEND_PXRX_DMA_BATCH;

        AlignWidth  >>= 2;            // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2; // scanline delta in dwords 
                                      // (start to start)
        lTrueDelta  = lSrcDeltaDW - AlignWidth; // scanline delta in dwords 
                                                // (end   to start)
        DISPDBG((DBGLVL, "Delta = %d bytes = %d dwords -> %d - %d dwords", 
                         lSrcDelta, lSrcDeltaDW, lTrueDelta, AlignWidth));

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
        // Do an RLE download:
        tagPtr = NULL;

        do 
        {
            WAIT_PXRX_DMA_TAGS( AlignWidth + 1 );

            nRemainder = AlignWidth;
            while( nRemainder-- ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                data = *(pjSrc++);
                len = 1;

                TEST_DWORD_ALIGNED( pjSrc );
                while( nRemainder && (*pjSrc == data) ) 
                {
                    pjSrc++;
                    len++;
                    nRemainder--;
                    TEST_DWORD_ALIGNED( pjSrc );
                }

                if( len >= 4 ) 
                {
                    if( tagPtr ) 
                    {
                        *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, 
                                                          holdCount );
                        tagPtr = NULL;
                    }

                    QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, 
                                           __GlintTagRLCount );
                    QUEUE_PXRX_DMA_DWORD( data );
                    QUEUE_PXRX_DMA_DWORD( len );
                    len = 0;
                } 
                else 
                {
                    if( !tagPtr ) 
                    {
                        QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                        holdCount = 0;
                    }

                    holdCount += len;
                    while( len-- )
                    {
                        QUEUE_PXRX_DMA_DWORD( data );
                    }
                }
            }

            if( tagPtr ) 
            {
                *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, 
                                                  holdCount );
                tagPtr = NULL;
            }
            pjSrc += lTrueDelta;
            SEND_PXRX_DMA_BATCH;
        } while( --cy > 0 );
#else
//@@END_DDKSPLIT
        // Do a raw download:
        while( TRUE ) 
        {
            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidth + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, AlignWidth );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidth );
            SEND_PXRX_DMA_BATCH;

            if( --cy == 0 )
            {
                break;
            }

            pjSrc += lSrcDeltaDW;
        }
//@@BEGIN_DDKSPLIT        
#endif
//@@END_DDKSPLIT

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset some defaults:
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, cPelInv );
    if( ppdev->cPelSize == GLINTDEPTH32 )
    {
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxXfer8bpp return"));
}

/**************************************************************************\
*
* VOID pxrxXferImage
*
\**************************************************************************/
VOID pxrxXferImage( 
    PPDEV ppdev, 
    RECTL *prcl, 
    LONG count, 
    ULONG logicOp, 
    ULONG bgLogicOp, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    XLATEOBJ *pxlo ) 
{
    DWORD       config2D, render2D;
    LONG        dx, dy, cy;
    LONG        lSrcDelta, lTrueDelta, lSrcDeltaDW, alignOff;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    UINT_PTR    startPos;
    LONG        cPel, cPelInv;
    ULONG       cPelMask;
    ULONG       AlignWidth, LeftEdge;
    LONG        nRemainder;
//@@BEGIN_DDKSPLIT    
#if USE_RLE_DOWNLOADS
    ULONG       len, data, holdCount;
    ULONG       *tagPtr;
#endif
//@@END_DDKSPLIT
    GLINT_DECL;

    SEND_PXRX_DMA_FORCE;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL), 
             "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat, 
             "Source must be same colour depth as screen");
    ASSERTDD(count > 0, 
             "Can't handle zero rectangles");
    ASSERTDD(logicOp <= 15, 
             "Weird hardware Rop");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top; // Add to destination to get source
    cPel = ppdev->cPelSize;         // number of bytes per pixel = 1 << cPel
    cPelInv = 2 - cPel;             // number of pixels per byte = 1 << cPelInv
                                    // (pixels -> dwords = >> cPenInv)
    cPelMask = (1 << cPelInv) - 1;  // mask to obtain number of pixels 
                                    // past a dword

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    DISPDBG((DBGLVL, "pxrxXferImage with logic op %d for %d rects", 
                     logicOp, count));

    config2D = glintInfo->config2D & ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                                       __CONFIG2D_LOGOP_BACK_ENABLE | 
                                       __CONFIG2D_ENABLES);
    config2D |= __CONFIG2D_FBWRITE    | 
                __CONFIG2D_USERSCISSOR;
    render2D = __RENDER2D_INCX        | 
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;
    
    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 );

    if( logicOp != __GLINT_LOGICOP_COPY ) 
    {
        config2D &= ~__CONFIG2D_LOGOP_FORE_MASK;
        config2D |= __CONFIG2D_LOGOP_FORE(logicOp) | 
                    __CONFIG2D_EXTERNALSRC;

        if( LogicopReadDest[logicOp] ) 
        {
            config2D |= __CONFIG2D_FBDESTREAD;
            SET_READ_BUFFERS;
        }
    }

    LOAD_CONFIG2D( config2D );

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, 
                        __GlintTagColor );
#endif
//@@END_DDKSPLIT

    while( TRUE ) 
    {
        cy = prcl->bottom - prcl->top;

        DISPDBG((DBGLVL, "download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        ASSERTDD((lSrcDelta & 3) == 0, 
                 "pxrxXferImage: SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!");

        // pjSrc points to the first pixel to copy
        // lTrueDelta is the additional amount to add onto the pjSrc pointer
        //    when we get to the end of the scanline.
        startPos = ((UINT_PTR) pjSrcScan0) + ((prcl->top + dy) * lSrcDelta) + 
                                                  ((prcl->left + dx) << cPel);
        alignOff = ((ULONG) (startPos & 3)) >> cPel;  // number of pixels past
                                                      // dword aligned start
        pjSrc = (ULONG *) (startPos & ~3); // dword aligned pointer to 1st pixel
        
        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: "
                             "pxrxXferImage return because of pjSrc NULL"));
            return;
        }        
        
        // dword aligned left edge in pixels
        LeftEdge    = prcl->left - alignOff;                            
        // dword aligned width in pixels
        AlignWidth  = (prcl->right - LeftEdge + cPelMask) & ~cPelMask;    
        
        DISPDBG((DBGLVL, "Aligned rect = (%d -> %d) => %d pixels", 
                         LeftEdge, LeftEdge + AlignWidth, AlignWidth));
        DISPDBG((DBGLVL, "pjSrcScan0 = 0x%08X, "
                         "pjSrc = 0x%08X, alignOff = %d pixels", 
                         pjSrcScan0, pjSrc, alignOff));

        ASSERTDD( ((UINT_PTR) pjSrcScan0) + ((prcl->top + dy) * lSrcDelta) + 
                              ((LeftEdge + dx) << cPel) == (UINT_PTR) pjSrc,
                  "pxrxXferImage: "
                  "Aligned left edge does not match aligned pjSrc!" );

        WAIT_PXRX_DMA_DWORDS( 5 );

        QUEUE_PXRX_DMA_INDEX4( __GlintTagFillScissorMinXY, 
                               __GlintTagFillScissorMaxXY, 
                               __GlintTagFillRectanglePosition, 
                               __GlintTagFillRender2D );
                               
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(prcl->left, 0) );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_DWORD( render2D | 
                              __RENDER2D_WIDTH(AlignWidth) | 
                              __RENDER2D_HEIGHT(cy) );
        SEND_PXRX_DMA_BATCH;

        AlignWidth >>= cPelInv;                 // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2;           // scanline delta in dwords 
                                                //(start to start)
        lTrueDelta  = lSrcDeltaDW - AlignWidth; // scanline delta in dwords 
                                                // (end   to start)
                                                
        DISPDBG((DBGLVL, "Delta = %d bytes = %d dwords -> %d - %d dwords", 
                         lSrcDelta, lSrcDeltaDW, lTrueDelta, AlignWidth));

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
        // Do an RLE download:
        tagPtr = NULL;

        do 
        {
            WAIT_PXRX_DMA_TAGS( AlignWidth + 1 );

            nRemainder = AlignWidth;
            while( nRemainder-- ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                data = *(pjSrc++);
                len = 1;

                TEST_DWORD_ALIGNED( pjSrc );
                while( nRemainder && (*pjSrc == data) ) 
                {
                    pjSrc++;
                    len++;
                    nRemainder--;
                    TEST_DWORD_ALIGNED( pjSrc );
                }

                if( len >= 4 ) 
                {
                    if( tagPtr ) 
                    {
                        *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, 
                                                          holdCount );
                        tagPtr = NULL;
                    }

                    QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, 
                                           __GlintTagRLCount );
                                           
                    QUEUE_PXRX_DMA_DWORD( data );
                    QUEUE_PXRX_DMA_DWORD( len );
                    len = 0;
                    
                } 
                else 
                {
                    if( !tagPtr ) 
                    {
                        QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                        holdCount = 0;
                    }

                    holdCount += len;
                    while( len-- )
                    {
                        QUEUE_PXRX_DMA_DWORD( data );
                    }
                }
            }

            if( tagPtr ) 
            {
                *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, holdCount );
                tagPtr = NULL;
            }
            pjSrc += lTrueDelta;
//          SEND_PXRX_DMA_BATCH;
        } while( --cy > 0 );
#else
//@@END_DDKSPLIT
        // Do a raw download:
        while( TRUE ) 
        {
            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidth + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, AlignWidth );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidth );
//          SEND_PXRX_DMA_BATCH;

            if( --cy == 0 )
            {
                break;
            }
            pjSrc += lSrcDeltaDW;
        }
//@@BEGIN_DDKSPLIT        
#endif
//@@END_DDKSPLIT

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset the scissor maximums:
    if( ppdev->cPelSize == GLINTDEPTH32 ) 
    {
        WAIT_PXRX_DMA_TAGS( 1 );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
//      SEND_PXRX_DMA_BATCH;
    }
    FLUSH_PXRX_PATCHED_RENDER2D(prclDst->left, prclDst->right);
    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxXferImage return"));
}

/**************************************************************************\
*
* VOID pxrxXfer4bpp
*
\**************************************************************************/      
VOID pxrxXfer4bpp( 
    PPDEV ppdev, 
    RECTL *prcl, 
    LONG count, 
    ULONG logicOp, 
    ULONG bgLogicOp, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    XLATEOBJ *pxlo ) 
{
    ULONG       config2D, render2D, lutMode, pixelSize;
    BOOL        invalidLUT = FALSE;
    LONG        dx, dy;
    LONG        cy;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    LONG        cPelInv;
    ULONG       ul;
    ULONG       AlignWidth, LeftEdge;
    UINT_PTR    startPos;
    LONG        nRemainder;
    LONG        lSrcDelta, lSrcDeltaDW;
    LONG        alignOff;
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxXfer4bpp(): src = (%d,%d) -> (%d,%d), count = %d, "
                     "logicOp = %d, palette id = %d", 
                     prcl->left, prcl->right, prcl->top, prcl->bottom, count, 
                     logicOp, pxlo->iUniq));

    // Set up the LUT table:
    if( (ppdev->PalLUTType != LUTCACHE_XLATE) || 
        (ppdev->iPalUniq != pxlo->iUniq) ) 
    {
        // Someone has hijacked the LUT so we need to invalidate it:
        ppdev->PalLUTType = LUTCACHE_XLATE;
        ppdev->iPalUniq = pxlo->iUniq;
        invalidLUT = TRUE;
    } 
    else 
    {
        DISPDBG((DBGLVL, "pxrxXfer4bpp: reusing cached xlate"));
    }

    WAIT_PXRX_DMA_TAGS( 1 + 1 + 16 );

    lutMode = glintInfo->lutMode & ~((3 << 2) | (1 << 4) | (7 << 8));
    lutMode |= (ppdev->cPelSize + 2) << 8;
    LOAD_LUTMODE( lutMode );

    if( invalidLUT ) 
    {
        ULONG   *pulXlate = pxlo->pulXlate;
        LONG    cEntries = 16;

        QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, 0 );

        if( ppdev->cPelSize == 0 )    // 8bpp
        {
            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 8;
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        }
        else if( ppdev->cPelSize == 1 )    // 16bpp
        {
            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        }
        else 
        {
            QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, cEntries );
            QUEUE_PXRX_DMA_BUFF( pulXlate, cEntries );
        }
    }

    config2D = glintInfo->config2D & ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                                       __CONFIG2D_LOGOP_BACK_ENABLE | 
                                       __CONFIG2D_ENABLES);
                                       
    config2D |= __CONFIG2D_FBWRITE    | 
                __CONFIG2D_USERSCISSOR;
                
    render2D = __RENDER2D_INCX        | 
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 6 );

    if( logicOp != __GLINT_LOGICOP_COPY ) 
    {
        config2D &= ~(__CONFIG2D_LOGOP_FORE_MASK | 
                      __CONFIG2D_LOGOP_BACK_MASK);
        config2D |= __CONFIG2D_LOGOP_FORE(logicOp) | 
                    __CONFIG2D_FBWRITE;
                    
        render2D |= __RENDER2D_SPANS;

        if( LogicopReadDest[logicOp] ) 
        {
            config2D |= __CONFIG2D_FBDESTREAD;
            SET_READ_BUFFERS;
        }

        if( LogicOpReadSrc[logicOp] ) 
        {
            config2D |= __CONFIG2D_EXTERNALSRC | 
                        __CONFIG2D_LUTENABLE;
        }
    } 
    else 
    {
        config2D |= __CONFIG2D_EXTERNALSRC | 
                    __CONFIG2D_LUTENABLE;
    }

    LOAD_CONFIG2D( config2D );

    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, __GlintTagColor );
    cPelInv = 2 - ppdev->cPelSize;
    // Everything before the LUT runs at 8bpp
    pixelSize = (1 << 31)       | 
                (2 << 2)        | 
                (2 << 4)        | 
                (2 << 6)        | 
                (2 << 16)       |        
                (cPelInv << 8)  | 
                (cPelInv << 10) | 
                (cPelInv << 12) | 
                (cPelInv << 14);
                
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, pixelSize );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;  // Add to destination to get source
//  cPel = ppdev->cPelSize;
//  cPelMask = (1 << cPelInv) - 1;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        // 4bpp => 2 pixels per byte => 8 pixels per dword

        // Assume source bitmap width is dword aligned
        ASSERTDD( (lSrcDelta & 3) == 0, 
                  "pxrxXfer4bpp: SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!");

        // pointer to first pixel, in bytes (32/64 bits long)
        startPos = (((UINT_PTR) pjSrcScan0) + ((prcl->top + dy) * lSrcDelta)) + 
                                                       ((prcl->left + dx) >> 1);    
        pjSrc = (ULONG *) (startPos & ~3); // dword pointer to dword 
                                           // aligned first pixel

        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: "
                             "pxrxXfer4bpp return because of pjSrc NULL"));            
            return;
        }

        // pointer to first pixel, in pixels (33/65 bits long!)
        startPos = (( ((UINT_PTR) pjSrcScan0) + 
                      ((prcl->top + dy) * lSrcDelta)) << 1) 
                   + (prcl->left + dx);    
                   
        alignOff = (ULONG)(startPos & 7); // number of pixels past dword 
                                          // alignment of a scanline

        LeftEdge = prcl->left - alignOff; // dword aligned left edge in pixels
        // dword aligned width in pixels
        AlignWidth  = ((prcl->right - LeftEdge) + 7) & ~7;    
        cy          = prcl->bottom - prcl->top; // number of scanlines to do

        DISPDBG((DBGLVL, "pjSrcScan0 = 0x%08X, startPos = 0x%08X (>>1), "
                         "pjSrc = 0x%08X", 
                         pjSrcScan0, startPos >> 1, pjSrc));
        DISPDBG((DBGLVL, "offset = %d pixels", alignOff));
        DISPDBG((DBGLVL, "Aligned rect = (%d -> %d) => %d pixels => %d dwords", 
                         LeftEdge, LeftEdge + AlignWidth, 
                         AlignWidth, AlignWidth >> 3));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         
                                        MAKEDWORD_XY(prcl->left,       0) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         
                                        MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                        MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,  render2D | 
                                                 __RENDER2D_WIDTH(AlignWidth) |
                                                 __RENDER2D_HEIGHT(cy) );
        SEND_PXRX_DMA_BATCH;

        AlignWidth  >>= 3;            // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2; // dword aligned scanline offset in dwords
        
        DISPDBG((DBGLVL, "Delta = %d pixels = %d dwords", 
                         lSrcDelta << 1, lSrcDeltaDW));

        //    pjSrc       = dword aligned pointer to first 
        //                         dword of first scanline
        //    AlignWidth  = number of dwords per scanline
        //    lTrueDelta  = dword offset between first dwords 
        //                         of consecutive scanlines
        //    cy          = number of scanlines

        while( TRUE ) 
        {
            nRemainder = AlignWidth;

            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidth + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagPacked4Pixels, AlignWidth );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidth );

            if( --cy == 0 )
            {
                break;
            }
            pjSrc += lSrcDeltaDW;
            SEND_PXRX_DMA_BATCH;
        }

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset some defaults:
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, cPelInv );
    if( ppdev->cPelSize == GLINTDEPTH32 )
    {
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxXfer4bpp return"));
}

/**************************************************************************\
*
* VOID pxrxCopyXfer24bpp
*
\**************************************************************************/      

VOID pxrxCopyXfer24bpp( 
    PPDEV ppdev, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    RECTL *prcl, 
    LONG count ) 
{
    ULONG   config2D, render2D, pixelSize;
    LONG        dx, dy, cy, LeftEdge;
    LONG        lSrcDelta, lSrcDeltaDW, lTrueDelta, alignOff;
    UINT_PTR    startPos;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    LONG        cPelInv;
    ULONG       ul, nRemainder;
    ULONG       padLeft, padLeftDW, padRight, padRightDW, dataWidth;
    ULONG       AlignWidth, AlignWidthDW, AlignExtra;
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxCopyXfer24bpp(): "
                     "src = (%d,%d) -> (%d,%d), count = %d", 
                     prcl->left, prcl->right, prcl->top, prcl->bottom, count));

    config2D = glintInfo->config2D & ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                                       __CONFIG2D_LOGOP_BACK_ENABLE | 
                                       __CONFIG2D_ENABLES);
    config2D |= __CONFIG2D_FBWRITE     | 
                __CONFIG2D_EXTERNALSRC | 
                __CONFIG2D_USERSCISSOR;
                
    render2D = __RENDER2D_INCX        | 
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 3 );

    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget,       __GlintTagColor );
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadGlyphWidth,   3 );
    LOAD_CONFIG2D( config2D );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "download to rect "
                         "(%d,%d -> %d,%d) + (%d, %d) = (%d x %d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom,
                         dx, dy, 
                         prcl->right - prcl->left, 
                         prcl->bottom - prcl->top));

        // 24bpp => 1 pixel per 3 bytes => 4 pixel per 3 dwords

        // Assume source bitmap width is dword aligned
        ASSERTDD( (lSrcDelta & 3) == 0, 
                  "pxrxCopyXfer24bpp: "
                  "SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!" );
        ASSERTDD( (((UINT_PTR) pjSrcScan0) & 3) == 0, 
                  "pxrxCopyXfer24bpp: "
                  "SOURCE BITMAP START LOCATION IS NOT DWORD ALIGNED!!!" );

        cy = prcl->bottom - prcl->top;  // number of scanlines to do
        startPos = (((UINT_PTR) pjSrcScan0) + 
                     ((prcl->top + dy) * lSrcDelta)) + 
                   ((prcl->left + dx) * 3); // pointer to first pixel of first 
                                            // scanline, in bytes
                                            
        alignOff = (ULONG)(startPos & 3);    // number of bytes past dword 
                                             // alignment to first pixel
        pjSrc = (ULONG *) (startPos & ~3);   // dword pointer to dword aligned 
                                             // first pixel

        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: "
                             "pxrxCopyXfer24bpp return because of pjSrc NULL"));            
            return;
        }
        
        padLeft = (4 - alignOff) % 4;   // number of pixels to add to regain 
                                        // dword alignment on left edge
        padLeftDW = (padLeft * 3) / 4;  // number of dwords to add 
                                        // on the left edge
        LeftEdge = prcl->left - padLeft;

        // dword aligned width in pixels (= 4 pixel aligned = 3 dword aligned!)
        AlignWidth = (prcl->right - LeftEdge + 3) & ~3;        
        // number of pixels overhang on the right
        padRight = (LeftEdge + AlignWidth) - prcl->right;    
        // number of dwords to add on the right edge
        padRightDW = (padRight * 3) / 4;                        

        AlignWidthDW = (AlignWidth * 3) / 4; // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2;        // dword aligned scanline offset 
                                             //                    in dwords
        // the amount of AlignWidth which is actually src bitmap                                             
        dataWidth = AlignWidthDW - padLeftDW - padRightDW;    

        DISPDBG((DBGLVL, "startPos = 0x%08X, alignOff = %d, "
                         "pjSrc = 0x%08X, lSrcDeltaDW = %d", 
                         startPos, alignOff, pjSrc, lSrcDeltaDW));
        DISPDBG((DBGLVL, "padLeft = %d pixels = %d dwords, LeftEdge = %d", 
                         padLeft, padLeftDW, LeftEdge));
        DISPDBG((DBGLVL, "AlignWidth = %d pixels = %d dwords", 
                         AlignWidth, AlignWidthDW));
        DISPDBG((DBGLVL, "padRight = %d pixels = %d dwords", padRight, padRightDW));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         
                                            MAKEDWORD_XY(prcl->left,       0));
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         
                                            MAKEDWORD_XY(prcl->right, 0x7fff));
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                            MAKEDWORD_XY(LeftEdge, prcl->top));
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,  render2D                     | 
                                                 __RENDER2D_WIDTH(AlignWidth) | 
                                                 __RENDER2D_HEIGHT(cy) );

        while( cy-- ) 
        {
            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidthDW + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagGlyphData, AlignWidthDW );

            if( padLeftDW )
            {
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );
            }
            
            if( padLeftDW == 2 )
            {
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );
            }

            QUEUE_PXRX_DMA_BUFF( pjSrc, dataWidth );

            if( padRightDW )
            {
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );
            }
            
            if( padRightDW == 2 )
            {
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );
            }

            SEND_PXRX_DMA_BATCH;

            pjSrc += lSrcDeltaDW;
        }
        
//@@BEGIN_DDKSPLIT        
/*/
        alignOff    = (prcl->left + dx + 3) & ~3;                // number of pixels past dword alignment of first pixel of a scanline
        pjSrc       = (ULONG *) (startPos - (alignOff * 3));    // dword pointer to dword aligned first pixel
        LeftEdge    = prcl->left - alignOff;                    // dword aligned left edge in pixels
        AlignWidth  = ((((prcl->right - LeftEdge) * 3) + 3) & ~3) / 3;        // dword aligned width in pixels (IS NOT = 4 pixel aligned = 3 dword aligned!)
        AlignExtra  = AlignWidth - (prcl->right - LeftEdge);    // extra pixels beyond the genuine width (which might overstomp a page boundary)
        if( AlignExtra )
            cy--;

        DISPDBG((7, "pjSrcScan0 = 0x%08X, startPos = 0x%08X, pjSrc = 0x%08X", pjSrcScan0, startPos, pjSrc));
        DISPDBG((7, "offset = %d pixels", alignOff));
        DISPDBG((7, "Aligned rect = (%d -> %d) => %d pixels", LeftEdge, LeftEdge + AlignWidth, AlignWidth));
        DISPDBG((7, "Rendering %d scanlines", cy));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         MAKEDWORD_XY(prcl->left,       0) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(AlignWidth) | __RENDER2D_HEIGHT(cy) );

        AlignWidthDW    = (AlignWidth * 3) / 4;                    // dword aligned width in dwords
        lSrcDeltaDW     = lSrcDelta >> 2;                        // dword aligned scanline offset in dwords
        DISPDBG((7, "Delta = %d bytes = %d dwords (%d dwords wide)", lSrcDelta, lSrcDeltaDW, AlignWidthDW));

        while( cy-- ) {
            DISPDBG((9, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidthDW + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagGlyphData, AlignWidthDW );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidthDW );
            SEND_PXRX_DMA_BATCH;

            pjSrc += lSrcDeltaDW;
        }

        if( AlignExtra ) {
            ULONG   dataWidth;
            ULONG   dataExtra;

            dataWidth = ((((prcl->right - LeftEdge) * 3) + 3) & ~3) / 4;    // dword aligned width in dwords, 1 dword aligned
            dataExtra = AlignWidthDW - dataWidth;                            // extra dwords past end of image
            DISPDBG((7, "Last scanline: %d + %d = %d pixels = %d + %d = %d dwords",
                     prcl->right - LeftEdge, AlignExtra, AlignWidth, dataWidth, dataExtra, AlignWidthDW));
            ASSERTDD( (dataWidth + dataExtra) == AlignWidthDW, "pxrxCopyXfer24bpp: Last scanline does not add up!" );

            WAIT_PXRX_DMA_DWORDS( AlignWidthDW + 5 );

            QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(LeftEdge, prcl->bottom - 1) );
            QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(AlignWidth) | __RENDER2D_HEIGHT(1) );

            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_HOLD( __GlintTagGlyphData, AlignWidthDW );
            QUEUE_PXRX_DMA_BUFF( pjSrc, dataWidth );                    // Send the partial scanline
            while( dataExtra-- )
                QUEUE_PXRX_DMA_DWORD( 0xDEADDEAD );                        // Pad out to flush the data

            // Resend download target to flush the remaining partial pixels ???
        }
/**/
//@@END_DDKSPLIT

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset the scissor maximums:
    if( ppdev->cPelSize == GLINTDEPTH32 ) 
    {
        WAIT_PXRX_DMA_TAGS( 1 );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxCopyXfer24bpp return"));
}

/**************************************************************************\
*
* VOID pxrxCopyXfer8bppLge
*
\**************************************************************************/     
VOID pxrxCopyXfer8bppLge( 
    PPDEV ppdev, 
    SURFOBJ *psoSrc, 
    POINTL *pptlSrc, 
    RECTL *prclDst, 
    RECTL *prcl, 
    LONG count, 
    XLATEOBJ *pxlo ) 
{
    ULONG       config2D, render2D, lutMode, pixelSize;
    BOOL        invalidLUT = FALSE;
    LONG        dx, dy, cy;
    LONG        lSrcDelta, lSrcDeltaDW, lTrueDelta, alignOff;
    ULONG       AlignWidth, LeftEdge;
    BYTE*       pjSrcScan0;
    ULONG*      pjSrc;
    UINT_PTR    startPos;
    LONG        cPelInv;
    ULONG       ul, i;
    LONG        nRemainder;
//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    ULONG       len, data, holdCount;
#endif
//@@END_DDKSPLIT
    ULONG       *tagPtr;
    ULONG       *pulXlate = pxlo->pulXlate;
    GLINT_DECL;

    DISPDBG((DBGLVL, "pxrxCopyXfer8bpp(): src = (%d,%d) -> (%d,%d), "
                     "count = %d, palette id = %d", 
                     prcl->left, prcl->right, prcl->top, prcl->bottom, 
                     count, pxlo->iUniq));

    SET_WRITE_BUFFERS;

    if( (count == 1) && 
        ((cy = (prcl->bottom - prcl->top)) == 1) ) 
    {
        ULONG   width = prcl->right - prcl->left, extra;
        BYTE    *srcPtr;

        config2D = __CONFIG2D_FBWRITE    | 
                   __CONFIG2D_EXTERNALSRC;
        render2D = __RENDER2D_INCX        | 
                   __RENDER2D_INCY        | 
                   __RENDER2D_OP_SYNCDATA | 
                   __RENDER2D_SPANS;

        dx = pptlSrc->x - prclDst->left;
        dy = pptlSrc->y - prclDst->top;  // Add to destination to get source

        lSrcDelta  = psoSrc->lDelta;
        pjSrcScan0 = psoSrc->pvScan0;
        startPos = (((UINT_PTR) pjSrcScan0) + 
                     ((prcl->top + dy) * lSrcDelta)) + (prcl->left + dx);
        srcPtr = (BYTE *) startPos;

        WAIT_PXRX_DMA_DWORDS( 7 + width );

        LOAD_CONFIG2D( config2D );

        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                        MAKEDWORD_XY(prcl->left, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,  render2D | 
                                                 __RENDER2D_WIDTH(width) | 
                                                 __RENDER2D_HEIGHT(1) );

        if( ppdev->cPelSize == 0 )     // 8bpp
        {
            extra = width & 3;
            width >>= 2;

            if( extra ) 
            {
                QUEUE_PXRX_DMA_HOLD( __GlintTagColor, width + 1 );
                QUEUE_PXRX_DMA_BUFF_DELAYED( tagPtr, width + 1 );
            } else {
                QUEUE_PXRX_DMA_HOLD( __GlintTagColor, width );
                QUEUE_PXRX_DMA_BUFF_DELAYED( tagPtr, width );
            }

            DISPDBG((DBGLVL, "width was %d, is now %d + %d", 
                             prcl->right - prcl->left, width, extra));

            for( i = 0; i < width; i++, srcPtr += 4 )
            {
                *(tagPtr++) = (pulXlate[srcPtr[3]] << 24) | 
                              (pulXlate[srcPtr[2]] << 16) | 
                              (pulXlate[srcPtr[1]] <<  8) | 
                               pulXlate[srcPtr[0]];
            }

            if( extra == 1 )
            {
                *(tagPtr++) = pulXlate[srcPtr[0]];
            }
            else if( extra == 2 )
            {
                *(tagPtr++) = (pulXlate[srcPtr[1]] << 8) | 
                               pulXlate[srcPtr[0]];
            }
            else if (extra == 3)
            {
                *(tagPtr++) = (pulXlate[srcPtr[2]] << 16) | 
                              (pulXlate[srcPtr[1]] <<  8) | 
                               pulXlate[srcPtr[0]];
            }
        } 
        else if( ppdev->cPelSize == 1 )     // 16bpp
        {
            extra = width & 1;
            width >>= 1;

            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, width + extra );
            QUEUE_PXRX_DMA_BUFF_DELAYED( tagPtr, width + extra );

            DISPDBG((DBGLVL, "width was %d, is now %d + %d", 
                             prcl->right - prcl->left, width, extra));

            for( i = 0; i < width; i++, srcPtr += 2 )
            {
                *(tagPtr++) = (pulXlate[srcPtr[1]] << 16) | 
                               pulXlate[srcPtr[0]];
            }

            if( extra )
            {
                *(tagPtr++) = pulXlate[srcPtr[0]];
            }
        } 
        else 
        {
            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, width );
            QUEUE_PXRX_DMA_BUFF_DELAYED( tagPtr, width );

            DISPDBG((DBGLVL, "width was %d, is now %d + %d", 
                             prcl->right - prcl->left, width, 0));

            for( i = 0; i < width; i++ )
            {
                *(tagPtr++) = pulXlate[*(srcPtr++)];
            }
        }

        SEND_PXRX_DMA_BATCH;

        return;
    }

    // Set up the LUT table:

    if( (ppdev->PalLUTType != LUTCACHE_XLATE) || 
        (ppdev->iPalUniq != pxlo->iUniq) ) 
    {
        // Someone has hijacked the LUT so we need to invalidate it:
        ppdev->PalLUTType = LUTCACHE_XLATE;
        ppdev->iPalUniq = pxlo->iUniq;
        invalidLUT = TRUE;
    } 
    else 
    {
        DISPDBG((DBGLVL, "pxrxCopyXfer8bpp: reusing cached xlate"));
    }

    WAIT_PXRX_DMA_TAGS( 1 + 1 );

    lutMode = glintInfo->lutMode & ~((3 << 2) | (1 << 4) | (7 << 8));
    lutMode |= (ppdev->cPelSize + 2) << 8;
    LOAD_LUTMODE( lutMode );

    if( invalidLUT ) 
    {
        LONG    cEntries = 256;
        
        pulXlate = pxlo->pulXlate;        

        QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, 0 );

        if( ppdev->cPelSize == 0 )     // 8bpp
        {
            WAIT_PXRX_DMA_TAGS( cEntries );

            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 8;
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        } 
        else if( ppdev->cPelSize == 1 )     // 16bpp
        {
            WAIT_PXRX_DMA_TAGS( cEntries );

            do 
            {
                ul = *(pulXlate++);
                ul |= ul << 16;
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTData, ul );
            } while( --cEntries );
        } 
        else 
        {
            WAIT_PXRX_DMA_DWORDS( 1 + cEntries );

            QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, cEntries );
            QUEUE_PXRX_DMA_BUFF( pulXlate, cEntries );
        }
    }

    config2D = glintInfo->config2D & ~(__CONFIG2D_LOGOP_FORE_ENABLE | 
                                       __CONFIG2D_LOGOP_BACK_ENABLE | 
                                       __CONFIG2D_ENABLES);
    config2D |= __CONFIG2D_FBWRITE     | 
                __CONFIG2D_USERSCISSOR | 
                __CONFIG2D_EXTERNALSRC | 
                __CONFIG2D_LUTENABLE;
    render2D = __RENDER2D_INCX        | 
               __RENDER2D_INCY        | 
               __RENDER2D_OP_SYNCDATA | 
               __RENDER2D_SPANS;

    WAIT_PXRX_DMA_TAGS( 3 );

    LOAD_CONFIG2D( config2D );

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, __GlintTagColor );
#endif
//@@END_DDKSPLIT

    cPelInv = 2 - ppdev->cPelSize;
    // Everything before the LUT runs at 8bpp
    pixelSize = (1 << 31)       | 
                (2 << 2)        | 
                (2 << 4)        | 
                (2 << 6)        |        
                (cPelInv << 8)  | 
                (cPelInv << 10) | 
                (cPelInv << 12) | 
                (cPelInv << 14);
                
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, pixelSize );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while( TRUE ) 
    {
        DISPDBG((DBGLVL, "download to rect (%d,%d) to (%d,%d)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        // 8bpp => 1 pixel per byte => 4 pixels per dword

        // Assume source bitmap width is dword aligned
        ASSERTDD( (lSrcDelta & 3) == 0, 
                  "pxrxCopyXfer8bpp: "
                  "SOURCE BITMAP WIDTH IS NOT DWORD ALIGNED!!!" );

        // pointer to first pixel, in pixels/bytes
        startPos    = (((UINT_PTR) pjSrcScan0) + 
                        ((prcl->top + dy) * lSrcDelta)) 
                      + (prcl->left + dx);    

        // dword pointer to dword aligned first pixel                      
        pjSrc       = (ULONG *) (startPos & ~3);     
        
        if(NULL == pjSrc)
        {
            DISPDBG((ERRLVL, "ERROR: pxrxCopyXfer8bppLge "
                             "return because of pjSrc NULL"));
            return;
        }
        
        alignOff = (ULONG)(startPos & 3);  // number of pixels past dword 
                                           // alignment of a scanline
        LeftEdge = prcl->left - alignOff;  // dword aligned left edge in pixels
        AlignWidth = ((prcl->right - LeftEdge) + 3) & ~3; // dword aligned width 
                                                          // in pixels
        cy = prcl->bottom - prcl->top;     // number of scanlines to do

        DISPDBG((DBGLVL, "pjSrcScan0 = 0x%08X, startPos = 0x%08X, "
                         "pjSrc = 0x%08X", 
                         pjSrcScan0, startPos, pjSrc));
        DISPDBG((DBGLVL, "offset = %d pixels", alignOff));
        DISPDBG((DBGLVL, "Aligned rect = (%d -> %d) => %d pixels => %d dwords", 
                         LeftEdge, LeftEdge + AlignWidth, 
                         AlignWidth, AlignWidth >> 2));

        WAIT_PXRX_DMA_TAGS( 4 );

        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY,         
                                        MAKEDWORD_XY(prcl->left,       0) );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY,         
                                        MAKEDWORD_XY(prcl->right, 0x7fff) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    
                                        MAKEDWORD_XY(LeftEdge, prcl->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D, render2D                     | 
                                                __RENDER2D_WIDTH(AlignWidth) | 
                                                __RENDER2D_HEIGHT(cy) );
        SEND_PXRX_DMA_BATCH;

        AlignWidth  >>= 2;              // dword aligned width in dwords
        lSrcDeltaDW = lSrcDelta >> 2;   // scanline delta in dwords 
                                        // (start to start)
        lTrueDelta  = lSrcDeltaDW - AlignWidth;  // scanline delta in dwords 
                                                 // (end   to start)
                                                 
        DISPDBG((DBGLVL, "Delta = %d bytes = %d dwords -> %d - %d dwords", 
                         lSrcDelta, lSrcDeltaDW, lTrueDelta, AlignWidth));

//@@BEGIN_DDKSPLIT
#if USE_RLE_DOWNLOADS
        // Do an RLE download:
        tagPtr = NULL;

        do 
        {
            WAIT_PXRX_DMA_TAGS( AlignWidth + 1 );

            nRemainder = AlignWidth;
            while( nRemainder-- ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                data = *(pjSrc++);
                len = 1;

                TEST_DWORD_ALIGNED( pjSrc );
                while( nRemainder && (*pjSrc == data) ) 
                {
                    pjSrc++;
                    len++;
                    nRemainder--;
                    TEST_DWORD_ALIGNED( pjSrc );
                }

                if( len >= 4 ) 
                {
                    if( tagPtr ) 
                    {
                        *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, 
                                                          holdCount );
                        tagPtr = NULL;
                    }

                    QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, __GlintTagRLCount );
                    QUEUE_PXRX_DMA_DWORD( data );
                    QUEUE_PXRX_DMA_DWORD( len );
                    len = 0;
                } 
                else 
                {
                    if( !tagPtr ) 
                    {
                        QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                        holdCount = 0;
                    }

                    holdCount += len;
                    
                    while( len-- )
                    {
                        QUEUE_PXRX_DMA_DWORD( data );
                    }
                }
            }

            if( tagPtr ) 
            {
                *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagColor, holdCount );
                tagPtr = NULL;
            }
            
            pjSrc += lTrueDelta;
            SEND_PXRX_DMA_BATCH;
        } while( --cy > 0 );
#else
//@@END_DDKSPLIT
        // Do a raw download:
        while( TRUE ) 
        {
            DISPDBG((DBGLVL, "cy = %d", cy));

            WAIT_PXRX_DMA_DWORDS( AlignWidth + 1 );
            QUEUE_PXRX_DMA_HOLD( __GlintTagColor, AlignWidth );
            TEST_DWORD_ALIGNED( pjSrc );
            QUEUE_PXRX_DMA_BUFF( pjSrc, AlignWidth );
            SEND_PXRX_DMA_BATCH;

            if( --cy == 0 )
            {
                break;
            }

            pjSrc += lSrcDeltaDW;
        }
//@@BEGIN_DDKSPLIT        
#endif
//@@END_DDKSPLIT

        if( --count == 0 )
        {
            break;
        }

        prcl++;
    }

    // Reset some defaults:
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize, cPelInv );
    if( ppdev->cPelSize == GLINTDEPTH32 )
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );

    SEND_PXRX_DMA_BATCH;

    DISPDBG((DBGLVL, "pxrxCopyXfer8bpp return"));
}


//****************************************************************************
// FUNC: pxrxMemUpload
// ARGS: ppdev (I) - pointer to the physical device object
//       crcl (I) - number of destination clipping rectangles
//       prcl (I) - array of destination clipping rectangles
//       psoDst (I) - destination surface
//       pptlSrc (I) - offset into source surface
//       prclDst (I) - unclipped destination rectangle
// RETN:  void
//****************************************************************************
VOID pxrxMemUpload(
    PPDEV ppdev, 
    LONG crcl, 
    RECTL *prcl, 
    SURFOBJ *psoDst, 
    POINTL *pptlSrc, 
    RECTL *prclDst)
{
    BYTE *pDst, *pSrc;
    LONG dwScanLineSize, cySrc, lSrcOff, lSrcStride;
    GLINT_DECL;

    // Make sure we're not performing other operations on the fb areas we want
    SYNC_WITH_GLINT;
    
    ASSERTDD(psoDst->iBitmapFormat == ppdev->iBitmapFormat, 
             "Dest must be same colour depth as screen");
             
    ASSERTDD(crcl > 0, "Can't handle zero rectangles");

    for(; --crcl >= 0; ++prcl) 
    {
        // This gives an offset for offscreen DIBs (zero for primary rectangles)
        lSrcOff = ppdev->DstPixelOrigin + 
                  (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

        // Determine stride on wheter we are blitting from the 
        // primary or from an offscreen DIB
        if (( ppdev->DstPixelOrigin == 0 ) && 
            (ppdev->xyOffsetDst == 0)       )
        {
            lSrcStride = ppdev->lDelta;
        }
        else
        {
            lSrcStride = ppdev->DstPixelDelta * ppdev->cjPelSize;
        }              
    
        // pSrc must point to mem mapped primary      
        pSrc = (BYTE *)ppdev->pjScreen 
                 + (lSrcOff * ppdev->cjPelSize)         
                 + ((LONG)pptlSrc->x * ppdev->cjPelSize) 
                 + ((LONG)pptlSrc->y * lSrcStride); 
  
        // pDst must point to the sysmem SURFOBJ 
        pDst = (BYTE *)psoDst->pvScan0 
                 + ((LONG)prcl->left * ppdev->cjPelSize) 
                 + ((LONG)prcl->top  * (LONG)psoDst->lDelta);                     

        // dwScanLineSize must have the right size to transfer in bytes
        dwScanLineSize = ((LONG)prcl->right - (LONG)prcl->left) * ppdev->cjPelSize;

        // Number of scan lines to transfer
        cySrc = prcl->bottom - prcl->top;

        // Do the copy
        while (--cySrc >= 0) 
        {
            // memcpy(dst, src, size)
            memcpy(pDst, pSrc, dwScanLineSize);
            pDst += psoDst->lDelta; // add stride
            pSrc += lSrcStride;  // add stride
        }
    }

} // pxrxMemUpload


//****************************************************************************
// FUNC: pxrxFifoUpload
// ARGS: ppdev (I) - pointer to the physical device object
//       crcl (I) - number of destination clipping rectangles
//       prcl (I) - array of destination clipping rectangles
//       psoDst (I) - destination surface
//       pptlSrc (I) - offset into source surface
//       prclDst (I) - unclipped destination rectangle
// RETN:  void
//----------------------------------------------------------------------------
// upload from on-chip source into host memory surface. Upload in spans 
// (64-bit aligned) to minimise messages through the core and entries in the 
// host out fifo.
//****************************************************************************
VOID pxrxFifoUpload(
    PPDEV ppdev, 
    LONG crcl, 
    RECTL *prcl, 
    SURFOBJ *psoDst, 
    POINTL *pptlSrc, 
    RECTL *prclDst)
{
    LONG    xDomSrc, xSubSrc, yStartSrc, cxSrc, cySrc;
    LONG    culPerSrcScan;
    LONG    culDstDelta;
    BOOL    bRemPerSrcScan;
    ULONG   *pulDst, *pulDstScan;
    ULONG   leftMask, rightMask;
    LONG    cul, ul;
    LONG    cFifoSpaces;
    __GlintFilterModeFmat FilterMode;
    GLINT_DECL;

    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadMode, (glintInfo->fbDestMode | 0x103));
    SEND_PXRX_DMA_FORCE;

//@@BEGIN_DDKSPLIT
#if USE_RLE_UPLOADS

    // NB. using cxSrc >= 16 is slightly slower overall. These tests were empirically developed 
    //     from WB99 BG & HE benchmarks
    cxSrc = prcl->right - prcl->left;
    if(cxSrc >= 32 && (cxSrc < 80 || (cxSrc >= 128 && cxSrc < 256) || cxSrc == ppdev->cxScreen))
    {
        pxrxRLEFifoUpload(ppdev, crcl, prcl, psoDst, pptlSrc, prclDst);
        return;
    }

#endif //USE_RLE_UPLOADS
//@@END_DDKSPLIT

    DISPDBG((DBGLVL, "pxrxFifoUpload: prcl = (%d, %d -> %d, %d), "
                     "prclDst = (%d, %d -> %d, %d), ptlSrc(%d, %d), count = %d",
                     prcl->left, prcl->top, prcl->right, prcl->bottom, 
                     prclDst->left, prclDst->top, prclDst->right, 
                     prclDst->bottom, pptlSrc->x, pptlSrc->y, crcl));

    DISPDBG((DBGLVL, "pxrxFifoUpload: psoDst: cx = %d, cy = %d, "
                     "lDelta = %d, pvScan0=%P)",
                     psoDst->sizlBitmap.cx, psoDst->sizlBitmap.cy, 
                     psoDst->lDelta, psoDst->pvScan0));
                     
    DISPDBG((DBGLVL, "pxrxFifoUpload: xyOffsetDst = (%d, %d), "
                     "xyOffsetSrc = (%d, %d)",
                     ppdev->xyOffsetDst & 0xFFFF, ppdev->xyOffsetDst >> 16,
                     ppdev->xyOffsetSrc & 0xFFFF, ppdev->xyOffsetSrc >> 16));

    ASSERTDD(psoDst->iBitmapFormat == ppdev->iBitmapFormat, 
             "Dest must be same colour depth as screen");
    ASSERTDD(crcl > 0, "Can't handle zero rectangles");

    WAIT_PXRX_DMA_TAGS(5);

    LOAD_CONFIG2D(__CONFIG2D_FBDESTREAD);
    SET_READ_BUFFERS;

    // enable filter mode so we can get Sync 
    // and color messages on the output FIFO
    *(DWORD *)(&FilterMode) = 0;
    FilterMode.Synchronization = __GLINT_FILTER_TAG;
    FilterMode.Color             = __GLINT_FILTER_DATA;
    QUEUE_PXRX_DMA_TAG(__GlintTagFilterMode, *(DWORD *)(&FilterMode));

    for(; --crcl >= 0; ++prcl) 
    {
        DISPDBG((DBGLVL, "pxrxFifoUpload: dest prcl(%xh,%xh..%xh,%xh)", 
                         prcl->left, prcl->top, prcl->right, prcl->bottom));

        // calculate pixel-aligned source
        xDomSrc   = pptlSrc->x + prcl->left  - prclDst->left;
        xSubSrc   = pptlSrc->x + prcl->right - prclDst->left;
        yStartSrc = pptlSrc->y + prcl->top   - prclDst->top;
        cySrc     = prcl->bottom - prcl->top;

        DISPDBG((DBGLVL, "pxrxFifoUpload: src (%xh,%xh..%xh,%xh)", 
                         xDomSrc, yStartSrc, xSubSrc, yStartSrc + cySrc));

        // will upload ulongs aligned to ulongs
        if (ppdev->cPelSize == GLINTDEPTH32) 
        {
            cxSrc = xSubSrc - xDomSrc;
            culPerSrcScan = cxSrc;
            leftMask  = 0xFFFFFFFF;
            rightMask = 0xFFFFFFFF;
        }    
        else 
        {
            if (ppdev->cPelSize == GLINTDEPTH16) 
            {
                ULONG cPixFromUlongBoundary = prcl->left & 1;

                xDomSrc -= cPixFromUlongBoundary;
                cxSrc = xSubSrc - xDomSrc;
                culPerSrcScan  = (xSubSrc - xDomSrc + 1) >> 1;

                leftMask  = 0xFFFFFFFF << (cPixFromUlongBoundary << 4);
                rightMask = 0xFFFFFFFF >> (((xDomSrc - xSubSrc) & 1) << 4);

            }
            else 
            {
                ULONG cPixFromUlongBoundary = prcl->left & 3;

                xDomSrc -= cPixFromUlongBoundary;
                cxSrc = xSubSrc - xDomSrc;
                culPerSrcScan  = (xSubSrc - xDomSrc + 3) >> 2;

                leftMask  = 0xFFFFFFFF << (cPixFromUlongBoundary << 3);
                rightMask = 0xFFFFFFFF >> (((xDomSrc - xSubSrc) & 3) << 3);

            }     
            // We just want a single mask if the area to upload is less 
            // than one word wide.
            if (culPerSrcScan == 1)
            {
                leftMask &= rightMask;
            }
        }

        // uploading 64 bit aligned source
        bRemPerSrcScan = culPerSrcScan & 1;

        // Work out where the destination data goes to
        culDstDelta = psoDst->lDelta >> 2;
        pulDst = ((ULONG *)psoDst->pvScan0) + 
                  (prcl->left >> (2 - ppdev->cPelSize)) 
                 + culDstDelta * prcl->top;

        DISPDBG((DBGLVL, "pxrxFifoUpload: uploading aligned "
                         "src (%xh,%xh..%xh,%xh)", 
                         xDomSrc, yStartSrc, 
                         xDomSrc + cxSrc, yStartSrc + cySrc));

        // Render the rectangle
        WAIT_PXRX_DMA_TAGS(2);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,
                                            MAKEDWORD_XY(xDomSrc, yStartSrc));
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,         
                                            __RENDER2D_OP_NORMAL    | 
                                            __RENDER2D_SPANS        |
                                            __RENDER2D_INCY         | 
                                            __RENDER2D_INCX         | 
                                            __RENDER2D_WIDTH(cxSrc) | 
                                            __RENDER2D_HEIGHT(cySrc));
        SEND_PXRX_DMA_FORCE;
        
        // If the start and end masks are 0xffffffff, we can just upload 
        // the words and put them directly into the destination. Otherwise, 
        // or the first and last word on any scanline we have to mask 
        // off any pixels that are outside the render area. We know the 
        // glint will have 0 in the undesired right hand edge pixels, as 
        // these were not in the render area. We dont know anything about 
        // the destination though.
        
        if ((leftMask == 0xFFFFFFFF) && (rightMask == 0xFFFFFFFF))
        {
            DISPDBG((DBGLVL, "pxrxFifoUpload: no edge masks"));
            
            while (--cySrc >= 0) 
            {
                pulDstScan = pulDst;
                pulDst += culDstDelta;

                DISPDBG((DBGLVL, "pxrxFifoUpload: uploading scan of %xh "
                                 "ulongs to %p (Remainder %xh)", 
                                 culPerSrcScan, pulDstScan, bRemPerSrcScan));

                cul = culPerSrcScan;
                while(cul)
                {
                    WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                    if (cFifoSpaces > cul)
                    {
                        cFifoSpaces = cul;
                    }

                    cul -= cFifoSpaces;
                    while (--cFifoSpaces >= 0) 
                    {
                        READ_OUTPUT_FIFO(ul);
                        DISPDBG((DBGLVL, "pxrxFifoUpload: read %08.8xh from "
                                         "output FIFO", ul));
                         *pulDstScan++ = ul;
                    }
                }
                
                if(bRemPerSrcScan)
                {
                    WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                    READ_OUTPUT_FIFO(ul);
                    DISPDBG((DBGLVL, "pxrxFifoUpload: read remainder %08.8xh "
                                     "from output FIFO", ul));
                }
            }
        }
        else if(culPerSrcScan == 1)
        {
            DISPDBG((DBGLVL, "pxrxFifoUpload: single ulong per scan"));

            while (--cySrc >= 0) 
            {
                WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                READ_OUTPUT_FIFO(ul);
                DISPDBG((DBGLVL, "pxrxFifoUpload: "
                                 "read %08.8xh from output FIFO", ul));

                // leftMask contains both masks in this case
                *pulDst = (*pulDst & ~leftMask) | (ul & leftMask);

                ASSERTDD(bRemPerSrcScan, "one word per scan upload should "
                                         "always leave a remainder");
                WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                READ_OUTPUT_FIFO(ul);
                DISPDBG((DBGLVL, "pxrxFifoUpload: read remainder %08.8xh "
                                 "from output FIFO", ul));
                pulDst += culDstDelta;
            }
        }
        else
        {
            DISPDBG((DBGLVL, "pxrxFifoUpload: scan with left & right edge "
                             "masks: %08.8x .. %08.8x", leftMask, rightMask));

            while (--cySrc >= 0) 
            {
                pulDstScan = pulDst;
                pulDst += culDstDelta;

                DISPDBG((DBGLVL, "pxrxFifoUpload: uploading scan of %xh "
                                 "ulongs to %p", culPerSrcScan, pulDstScan));

                // get first ulong
                WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                --cFifoSpaces;
                READ_OUTPUT_FIFO(ul);
                
                DISPDBG((DBGLVL, "pxrxFifoUpload: "
                                 "read %08.8xh from output FIFO", ul));
                                 
                *pulDstScan++ = (*pulDstScan & ~leftMask) | (ul & leftMask);
                 
                // get middle ulongs
                cul = culPerSrcScan - 2; 
                while (cul) 
                {
                    if (cFifoSpaces > cul)
                    {
                        cFifoSpaces = cul;
                    }

                    cul -= cFifoSpaces;
                    while (--cFifoSpaces >= 0) 
                    {
                        READ_OUTPUT_FIFO(ul);
                        DISPDBG((DBGLVL, "pxrxFifoUpload: "
                                         "read %08.8xh from output FIFO", ul));
                         *pulDstScan++ = ul;
                    }
                    WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                }
                  
                // get last ulong
                READ_OUTPUT_FIFO(ul);
                DISPDBG((DBGLVL, "pxrxFifoUpload: "
                                 "read %08.8xh from output FIFO", ul));
                                 
                *pulDstScan = (*pulDstScan & ~rightMask) | (ul & rightMask);

                if(bRemPerSrcScan)
                {
                    WAIT_OUTPUT_FIFO_NOT_EMPTY(cFifoSpaces);
                    READ_OUTPUT_FIFO(ul);
                    DISPDBG((DBGLVL, "pxrxFifoUpload: read remainder "
                                     "%08.8xh from output FIFO", ul));
                }
            }
        }
    }

#if DBG
    cul = 0xaa55aa55;
    DISPDBG((DBGLVL, "pxrxFifoUpload: waiting for sync (id = %08.8xh)", cul));
    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagSync, cul);
    SEND_PXRX_DMA_FORCE;
    do
    {
        WAIT_OUTPUT_FIFO_READY;
        READ_OUTPUT_FIFO(ul);
        DISPDBG((DBGLVL, "pxrxFifoUpload: read %08.8xh from output FIFO", ul));
        if(ul != __GlintTagSync)
        {
            DISPDBG((ERRLVL,"pxrxFifoUpload: didn't read back sync!"));
        }
    }
    while(ul != __GlintTagSync);
    DISPDBG((DBGLVL, "pxrxFifoUpload: got sync"));
#endif

    // no need to initiate DMA with this tag - it will get flushed with the 
    // next primitive and meanwhile will not affect local memory
    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagFilterMode, 0);
    SEND_PXRX_DMA_BATCH;

    GLINT_CORE_IDLE;

    DISPDBG((DBGLVL, "pxrxFifoUpload: done"));
}

//****************************************************************************
// VOID vGlintCopyBltBypassDownloadXlate8bpp
//
// using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
// NB. supports 32bpp and 16bpp destinations
//****************************************************************************
VOID vGlintCopyBltBypassDownloadXlate8bpp(
    PDEV     *ppdev,
    SURFOBJ  *psoSrc,
    POINTL   *pptlSrc,
    RECTL    *prclDst,
    RECTL    *prclClip,
    LONG      crclClip,
    XLATEOBJ *pxlo)
{
    LONG    xOff;
    BYTE    *pjSrcScan0;
    LONG    cjSrcDelta, xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan, c;
    ULONG   cjSrcDeltaRem, cjDstDeltaRem;
    ULONG   *aulXlate;
    BYTE    *pjSrc;
    GLINT_DECL;

//@@BEGIN_DDKSPLIT
#if 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((DBGLVL, "vGlintCopyBltBypassDownloadXlate8bpp(): "
                         "cRects(%d) sizlDst(%d,%d)", 
                         crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG
//@@END_DDKSPLIT

    pjSrcScan0 = (BYTE *)psoSrc->pvScan0;
    cjSrcDelta = psoSrc->lDelta;
    
    // need to add arclClip[n].left to get xSrc
    xSrcOff = pptlSrc->x - prclDst->left; 
    // need to add arclClip[n].top to get ySrc
    ySrcOff = pptlSrc->y - prclDst->top;  

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    aulXlate = pxlo->pulXlate;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;
        cjSrcDeltaRem = cjSrcDelta - cPixPerScan;
        pjSrc = -1 + pjSrcScan0 + xSrcOff + prclClip->left
                + ((prclClip->top + ySrcOff) * cjSrcDelta);

        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            ULONG *pulDst;
            cjDstDeltaRem = (culDstDelta - cPixPerScan) << 2;
            pulDst = -1 + pulDstScan0 + xDstOff + prclClip->left
                     + prclClip->top * culDstDelta;
                     
            for (; 
                 --cScans >= 0; 
                 pjSrc += cjSrcDeltaRem, (BYTE *)pulDst += cjDstDeltaRem)
            {
                for(c = cPixPerScan; --c >= 0;)
                {
                    *++pulDst = aulXlate[*++pjSrc];
                }
            }
        }
        else // (GLINTDEPTH16)
        {
            USHORT *pusDst;
            cjDstDeltaRem = 
                        (culDstDelta << 2) - (cPixPerScan << ppdev->cPelSize);
                        
            pusDst = -1 + (USHORT *)pulDstScan0 + xDstOff + prclClip->left
                        + ((prclClip->top * culDstDelta) << 1);
                     
            for (; 
                 --cScans >= 0; 
                 pjSrc += cjSrcDeltaRem, (BYTE *)pusDst += cjDstDeltaRem)
            {
                for (c = cPixPerScan; --c >= 0;)
                {
                    *++pusDst = (USHORT)aulXlate[*++pjSrc];
                }
            }
        }
    }
}

//@@BEGIN_DDKSPLIT
#if 0
/**************************************************************************\
*
* void pxrxMonoDownloadRLE
*
\**************************************************************************/
void pxrxMonoDownloadRLE( 
    PPDEV ppdev, 
    ULONG AlignWidth, 
    ULONG *pjSrc, 
    LONG lSrcDelta, 
    LONG cy ) 
{
    ULONG   len, data, holdCount;
    ULONG   *tagPtr = NULL;
    GLINT_DECL;

    WAIT_PXRX_DMA_TAGS( 1 );
    QUEUE_PXRX_DMA_TAG( __GlintTagDownloadTarget, 
                        __GlintTagBitMaskPattern );

    if( AlignWidth == 32 ) 
    {
        ULONG   bits;
        DISPDBG((DBGLVL, "Doing Single Word per scan download"));

        WAIT_PXRX_DMA_DWORDS( cy + 1 );

        while( cy-- ) 
        {
            TEST_DWORD_ALIGNED( pjSrc );
            data = *pjSrc;
            pjSrc += lSrcDelta;
            len = 1;

            TEST_DWORD_ALIGNED( pjSrc );
            while( cy && (*pjSrc == data) ) 
            {
                pjSrc += lSrcDelta;
                len++;
                cy--;
                TEST_DWORD_ALIGNED( pjSrc );
            }

            if( len >= 4 ) 
            {
                if( tagPtr ) 
                {
                    *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern,
                                                      holdCount );
                    tagPtr = NULL;
                }

                QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, __GlintTagRLCount );
                QUEUE_PXRX_DMA_DWORD( data );
                QUEUE_PXRX_DMA_DWORD( len );
                len = 0;
            } 
            else 
            {
                if( !tagPtr ) 
                {
                    QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                    holdCount = 0;
                }

                holdCount += len;
                while( len-- )
                {
                    QUEUE_PXRX_DMA_DWORD( data );
                }
            }
        }

        if( tagPtr ) 
        {
            *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern, 
                                              holdCount );
            tagPtr = NULL;
        }
    } 
    else 
    {
        // multiple 32 bit words per scanline. convert the delta to the
        // delta as we need it at the end of each line by subtracting the
        // width in bytes of the data we're downloading. Note, pjSrc
        // is always 1 LONG short of the end of the line because we break
        // before adding on the last ULONG. Thus, we subtract sizeof(ULONG)
        // from the original adjustment.
        LONG    nRemainder;
        ULONG   bits;
        LONG    lSrcDeltaScan = lSrcDelta - (AlignWidth >> 5);

        DISPDBG((DBGLVL, "Doing Multiple Word per scan download"));

        while( TRUE ) 
        {
            nRemainder = AlignWidth >> 5;
            WAIT_PXRX_DMA_DWORDS( nRemainder + 1 );

            while( nRemainder-- ) 
            {
                TEST_DWORD_ALIGNED( pjSrc );
                data = *(pjSrc++);
                len = 1;

                TEST_DWORD_ALIGNED( pjSrc );
                while( nRemainder && (*pjSrc == data) ) 
                {
                    pjSrc++;
                    len++;
                    nRemainder--;
                    TEST_DWORD_ALIGNED( pjSrc );
                }

                if( len >= 4 ) 
                {
                    if( tagPtr ) 
                    {
                        *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( 
                                            __GlintTagBitMaskPattern, 
                                            holdCount );
                        tagPtr = NULL;
                    }

                    QUEUE_PXRX_DMA_INDEX2( __GlintTagRLData, 
                                           __GlintTagRLCount );
                    QUEUE_PXRX_DMA_DWORD( data );
                    QUEUE_PXRX_DMA_DWORD( len );
                    len = 0;
                } 
                else 
                {
                    if( !tagPtr ) 
                    {
                        QUEUE_PXRX_DMA_DWORD_DELAYED( tagPtr );
                        holdCount = 0;
                    }

                    holdCount += len;
                    while( len-- )
                    {
                        QUEUE_PXRX_DMA_DWORD( data );
                    }
                }
            }

            if( tagPtr ) 
            {
                *tagPtr = ASSEMBLE_PXRX_DMA_HOLD( __GlintTagBitMaskPattern, 
                                                  holdCount );
                tagPtr = NULL;
            }

            if( --cy == 0 )
            {
                break;
            }

            SEND_PXRX_DMA_BATCH;
            pjSrc += lSrcDeltaScan;
        }
    }
    SEND_PXRX_DMA_BATCH;
}


//*********************************************************************************************
// FUNC: pxrxRLEFifoUpload
// ARGS: ppdev (I) - pointer to the physical device object
//       crcl (I) - number of destination clipping rectangles
//       prcl (I) - array of destination clipping rectangles
//       psoDst (I) - destination surface
//       pptlSrc (I) - offset into source surface
//       prclDst (I) - unclipped destination rectangle
// RETN:  void
//---------------------------------------------------------------------------------------------
// upload from on-chip source into host memory surface. Upload in spans (64-bit aligned) to 
// minimise messages through the core and entries in the host out fifo. Upload is RLE encoded.
//*********************************************************************************************
VOID pxrxRLEFifoUpload(PPDEV ppdev, LONG crcl, RECTL *prcl, SURFOBJ *psoDst, POINTL *pptlSrc, RECTL *prclDst)
{
    LONG    xDomSrc, xSubSrc, yStartSrc, cxSrc, cySrc;
    LONG    culPerSrcScan;
    LONG    culDstDelta;
    BOOL    bRemPerSrcScan;
    ULONG   *pulDst, *pulDstScan;
    ULONG   leftMask, rightMask;
    LONG    cul, ul;
    LONG    cFifoSpaces;
    ULONG   RLECount, RLEData;
    __GlintFilterModeFmat FilterMode;
    GLINT_DECL;

    DISPDBG((7, "pxrxFifoUpload: prcl = (%d, %d -> %d, %d), prclDst = (%d, %d -> %d, %d), ptlSrc(%d, %d), count = %d",
                 prcl->left, prcl->top, prcl->right, prcl->bottom, 
                 prclDst->left, prclDst->top, prclDst->right, prclDst->bottom, pptlSrc->x, pptlSrc->y, crcl));

    DISPDBG((7, "pxrxFifoUpload: psoDst: cx = %d, cy = %d, lDelta = %d, pvScan0=%P)",
                 psoDst->sizlBitmap.cx, psoDst->sizlBitmap.cy, psoDst->lDelta, psoDst->pvScan0));
    DISPDBG((7, "pxrxFifoUpload: xyOffsetDst = (%d, %d), xyOffsetSrc = (%d, %d)",
                 ppdev->xyOffsetDst & 0xFFFF, ppdev->xyOffsetDst >> 16,
                 ppdev->xyOffsetSrc & 0xFFFF, ppdev->xyOffsetSrc >> 16));

    ASSERTDD(psoDst->iBitmapFormat == ppdev->iBitmapFormat, "Dest must be same colour depth as screen");
    ASSERTDD(crcl > 0, "Can't handle zero rectangles");

    WAIT_PXRX_DMA_TAGS(6);
    QUEUE_PXRX_DMA_TAG( __GlintTagRLEMask,  0xffffffff);
    LOAD_CONFIG2D(__CONFIG2D_FBDESTREAD);
    SET_READ_BUFFERS;

    // enable filter mode so we can get Sync and color messages on the output FIFO
    *(DWORD *)(&FilterMode) = 0;   
    FilterMode.Synchronization = __GLINT_FILTER_TAG;
    FilterMode.Color             = __GLINT_FILTER_DATA;
    FilterMode.RLEHostOut      = TRUE;
    QUEUE_PXRX_DMA_TAG(__GlintTagFilterMode, *(DWORD*)(&FilterMode));

    for(; --crcl >= 0; ++prcl) 
    {
        DISPDBG((7, "pxrxFifoUpload: dest prcl(%xh,%xh..%xh,%xh)", prcl->left, prcl->top, prcl->right, prcl->bottom));

        // calculate pixel-aligned source
        xDomSrc   = pptlSrc->x + prcl->left  - prclDst->left;
        xSubSrc   = pptlSrc->x + prcl->right - prclDst->left;
        yStartSrc = pptlSrc->y + prcl->top   - prclDst->top;
        cySrc     = prcl->bottom - prcl->top;

        DISPDBG((8, "pxrxFifoUpload: src (%xh,%xh..%xh,%xh)", xDomSrc, yStartSrc, xSubSrc, yStartSrc + cySrc));

        // will upload ulongs aligned to ulongs
        if (ppdev->cPelSize == GLINTDEPTH32) 
        {
            cxSrc = xSubSrc - xDomSrc;
            culPerSrcScan = cxSrc;
            leftMask  = 0xFFFFFFFF;
            rightMask = 0xFFFFFFFF;
        }    
        else 
        {
            if (ppdev->cPelSize == GLINTDEPTH16) 
            {
                ULONG cPixFromUlongBoundary = prcl->left & 1;

                xDomSrc -= cPixFromUlongBoundary;
                cxSrc = xSubSrc - xDomSrc;
                culPerSrcScan  = (xSubSrc - xDomSrc + 1) >> 1;

                leftMask  = 0xFFFFFFFF << (cPixFromUlongBoundary << 4);
                rightMask = 0xFFFFFFFF >> (((xDomSrc - xSubSrc) & 1) << 4);

            }
            else 
            {
                ULONG cPixFromUlongBoundary = prcl->left & 3;

                xDomSrc -= cPixFromUlongBoundary;
                cxSrc = xSubSrc - xDomSrc;
                culPerSrcScan  = (xSubSrc - xDomSrc + 3) >> 2;

                leftMask  = 0xFFFFFFFF << (cPixFromUlongBoundary << 3);
                rightMask = 0xFFFFFFFF >> (((xDomSrc - xSubSrc) & 3) << 3);

            }     
            // We just want a single mask if the area to upload is less than one word wide.
            if (culPerSrcScan == 1)
                leftMask &= rightMask;
        }

        // uploading 64 bit aligned source
        bRemPerSrcScan = culPerSrcScan & 1;

        // the remainder will be encoded in the run: it's simpler just to add it in now
        // then check bRemPerSrcScan during the upload
        DISPDBG((8, "pxrxFifoUpload: Adding remainder into culPerSrcScan for RLE"));
        culPerSrcScan += bRemPerSrcScan;

        // Work out where the destination data goes to
        culDstDelta = psoDst->lDelta >> 2;
        pulDst = ((ULONG *)psoDst->pvScan0) + (prcl->left >> (2 - ppdev->cPelSize)) + culDstDelta * prcl->top;

        DISPDBG((8, "pxrxFifoUpload: uploading aligned src (%xh,%xh..%xh,%xh)", xDomSrc, yStartSrc, 
                                                                             xDomSrc + cxSrc, yStartSrc + cySrc));

        // Render the rectangle
        WAIT_PXRX_DMA_TAGS(2);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,MAKEDWORD_XY(xDomSrc, yStartSrc));
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,         __RENDER2D_OP_NORMAL | __RENDER2D_SPANS |
                                                        __RENDER2D_INCY | __RENDER2D_INCX | 
                                                        __RENDER2D_WIDTH(cxSrc) | __RENDER2D_HEIGHT(cySrc));
        SEND_PXRX_DMA_FORCE;
        
        // If the start and end masks are 0xffffffff, we can just upload the words and put them
        // directly into the destination. Otherwise, or the first and last word on any scanline
        // we have to mask off any pixels that are outside the render area. We know the glint will
        // have 0 in the undesired right hand edge pixels, as these were not in the render area. We
        // dont know anything about the destination though.
        if (leftMask == 0xFFFFFFFF && rightMask == 0xFFFFFFFF) 
        {
            DISPDBG((8, "pxrxFifoUpload: no edge masks"));
            while (--cySrc >= 0) 
            {
                pulDstScan = pulDst;
                pulDst += culDstDelta;

                DISPDBG((9, "pxrxFifoUpload: uploading scan of %xh ulongs to %p (Remainder %xh)", 
                            culPerSrcScan, pulDstScan, bRemPerSrcScan));

                cul = culPerSrcScan;
                while(cul)
                {
                    WAIT_OUTPUT_FIFO_COUNT(2);
                    READ_OUTPUT_FIFO(RLECount);
                    READ_OUTPUT_FIFO(RLEData);
                    DISPDBG((10, "pxrxFifoUpload: RLECount = %xh RLEData = 08.8xh", RLECount, RLEData));
                    cul -= RLECount;
                    if(cul == 0 && bRemPerSrcScan)
                    {
                        // discard the last ulong
                        --RLECount;
                    }
                    while(RLECount--)
                    {
                        DISPDBG((10, "pxrxFifoUpload: written ulong"));
                           *pulDstScan++ = RLEData;
                    }
                }
            }
        }
        else if(culPerSrcScan == 1)
        {
            DISPDBG((8, "pxrxFifoUpload: single ulong per scan"));

            while (--cySrc >= 0) 
            {
                // the remainder has already been added into culPerSrcScan so this can't happen
                DISPDBG((ERRLVL,"pxrxFifoUpload: got single ulong per scan - but we always upload 64 bit quanta!"));
                pulDst += culDstDelta;
            }
        }
        else
        {
            DISPDBG((8, "pxrxFifoUpload: scan with left & right edge masks: %08.8x .. %08.8x", leftMask, rightMask));

            while (--cySrc >= 0) 
            {
                pulDstScan = pulDst;
                pulDst += culDstDelta;

                DISPDBG((9, "pxrxFifoUpload: uploading scan of %xh ulongs to %p", culPerSrcScan, pulDstScan));

                cul = culPerSrcScan;
                while(cul)
                {
                    WAIT_OUTPUT_FIFO_COUNT(2);
                    READ_OUTPUT_FIFO(RLECount);
                    READ_OUTPUT_FIFO(RLEData);
                    DISPDBG((10, "pxrxFifoUpload: RLECount = %xh RLEData = %08.8xh", RLECount, RLEData));

                    if(cul - bRemPerSrcScan == 0)
                    {
                        DISPDBG((10, "pxrxFifoUpload: discarding last ulong"));
                        break;
                    }

                    if(culPerSrcScan - bRemPerSrcScan == 1)
                    {
                        // one pixel per scan
                        DISPDBG((10, "pxrxFifoUpload: written single pixel scan"));
                        *pulDstScan = (*pulDstScan & ~leftMask) | (RLEData & leftMask);
                        cul -= RLECount;
                        continue;
                    }

                    if(cul == culPerSrcScan)
                    {
                        DISPDBG((10, "pxrxFifoUpload: written left edge"));
                        *pulDstScan++ = (*pulDstScan & ~leftMask) | (RLEData & leftMask); // first ulong
                        --RLECount;
                        --cul;
                    }
                    cul -= RLECount;
                    if(cul == 0)
                    {
                        // this is the last run of the scan: process the last ulong separately in order
                        // to apply the right edge mask
                        RLECount -= 1 + bRemPerSrcScan;
                    }
                    else if(cul - bRemPerSrcScan == 0)
                    {
                        // this is the penultimate run of the scan and the last one will just include the
                        // remainder: process the last ulong separately in order to apply the right edge mask
                        --RLECount;
                    }
                    while(RLECount--)
                    {
                        DISPDBG((10, "pxrxFifoUpload: written middle ulong"));
                           *pulDstScan++ = RLEData;
                    }

                    if(cul == 0 || cul - bRemPerSrcScan == 0)
                    {
                        DISPDBG((10, "pxrxFifoUpload: written right edge"));
                        *pulDstScan = (*pulDstScan & ~rightMask) | (RLEData & rightMask); // last ulong
#if DBG
                        if(cul - bRemPerSrcScan == 0)
                        {
                            DISPDBG((10, "pxrxFifoUpload: discarding last ulong"));
                        }
#endif
                    }
                }
            }
        }
    }

#if DBG
    cul = 0xaa55aa55;
    DISPDBG((8, "pxrxFifoUpload: waiting for sync (id = %08.8xh)", cul));
    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagSync, cul);
    SEND_PXRX_DMA_FORCE;
    do
    {
        WAIT_OUTPUT_FIFO_READY;
        READ_OUTPUT_FIFO(ul);
        DISPDBG((8, "pxrxFifoUpload: read %08.8xh from output FIFO", ul));
        if(ul != __GlintTagSync)
        {
            DISPDBG((ERRLVL,"pxrxFifoUpload: didn't read back sync!"));
        }
    }
    while(ul != __GlintTagSync);
    DISPDBG((8, "pxrxFifoUpload: got sync"));
#endif

    // no need to initiate DMA with this tag - it will get flushed with the next primitive and
    // meanwhile will not affect local memory
    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagFilterMode, 0);
    SEND_PXRX_DMA_BATCH;

    GLINT_CORE_IDLE;

    DISPDBG((7, "pxrxFifoUpload: done"));
}


//****************************************************************************
// FUNC: vGlintCopyBltBypassDownload32bpp
// DESC: using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
//****************************************************************************

VOID vGlintCopyBltBypassDownload32bpp(
PDEV    *ppdev,
SURFOBJ *psoSrc,
POINTL  *pptlSrc,
RECTL   *prclDst,
RECTL   *prclClip,
LONG    crclClip)
{
    LONG    xOff;
    ULONG   *pulSrcScan0;
    LONG    culSrcDelta, xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan, c;
    ULONG   cjSrcDeltaRem, cjDstDeltaRem;
    ULONG   *pulSrc;
    ULONG   *pulDst;
    ULONG   tmp0, tmp1, tmp2;
    GLINT_DECL;

#if DBG && 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((-1, "vGlintCopyBltBypassDownload32bpp(): cRects(%d) sizlDst(%d,%d)", crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG

    pulSrcScan0 = (ULONG *)psoSrc->pvScan0;
    culSrcDelta = psoSrc->lDelta >> 2;
    xSrcOff = pptlSrc->x - prclDst->left; // need to add arclClip[n].left to get xSrc
    ySrcOff = pptlSrc->y - prclDst->top;  // need to add arclClip[n].top to get ySrc

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;
        cjSrcDeltaRem = (culSrcDelta - cPixPerScan) * 4;
        cjDstDeltaRem = (culDstDelta - cPixPerScan) * 4;

        // calc source & destination address, -1 to allow for prefix-increment
        pulSrc = -1 + pulSrcScan0 + xSrcOff + prclClip->left
                 + ((prclClip->top + ySrcOff) * culSrcDelta);
        pulDst = -1 + pulDstScan0 + xDstOff + prclClip->left
                 + prclClip->top * culDstDelta;

        for (; --cScans >= 0; (BYTE *)pulSrc += cjSrcDeltaRem, (BYTE *)pulDst += cjDstDeltaRem)
        {
#if defined(_X86_)
            __asm
            {
                mov     edi, pulDst
                mov     ecx, cPixPerScan
                mov     esi, pulSrc
                shr     ecx, 2
                push    ebp
                test    ecx, ecx
                jle     EndOfLine
              LoopFours:
                mov     eax, [esi+4]
                mov     ebx, [esi+8]
                mov     edx, [esi+12]
                mov     ebp, [esi+16]
                add     esi, 16
                mov     [edi+4], eax
                mov     [edi+8], ebx
                add     edi, 16
                mov     [edi-4], edx
                dec     ecx
                mov     [edi], ebp
                jne     LoopFours
              EndOfLine:
                pop     ebp
                mov     pulSrc, esi
                mov     pulDst, edi
            }     
            // do the remaining 0, 1, 2 or 3 pixels on this line
            switch (cPixPerScan & 3)
            {
                case 3:
                    tmp0 = *++pulSrc;
                    tmp1 = *++pulSrc;
                    tmp2 = *++pulSrc;
                    *++pulDst = tmp0;
                    *++pulDst = tmp1;
                    *++pulDst = tmp2;
                    break;
               case 2:
                    tmp0 = *++pulSrc;
                    tmp1 = *++pulSrc;
                    *++pulDst = tmp0;
                    *++pulDst = tmp1;
                    break;
                case 1:
                    tmp0 = *++pulSrc;
                    *++pulDst = tmp0;
            }

#else
            for(c = cPixPerScan; --c >= 0;)
            {
                *++pulDst = *++pulSrc;
            }
#endif
        }
    }
}

//****************************************************************************
// FUNC: vGlintCopyBltBypassDownload24bppTo32bpp
// DESC: using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
//****************************************************************************

VOID vGlintCopyBltBypassDownload24bppTo32bpp(
PDEV    *ppdev,
SURFOBJ *psoSrc,
POINTL  *pptlSrc,
RECTL   *prclDst,
RECTL   *prclClip,
LONG    crclClip)
{
    LONG    xOff;
    BYTE    *pjSrcScan0;
    LONG    cjSrcDelta;
    LONG    xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan, c;
    BYTE    *pjSrc;
    BYTE    *pj;
    ULONG   *pulDst, *puld;
    GLINT_DECL;

#if DBG && 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((-1, "vGlintCopyBltBypassDownload24bppTo32bpp(): cRects(%d) sizlDst(%d,%d)", crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG

    pjSrcScan0 = (BYTE *)psoSrc->pvScan0;
    cjSrcDelta = psoSrc->lDelta;
    xSrcOff = pptlSrc->x - prclDst->left; // need to add arclClip[n].left to get xSrc
    ySrcOff = pptlSrc->y - prclDst->top;  // need to add arclClip[n].top to get ySrc

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;

        // calc source & destination address, -1 to allow for prefix-increment
        // convert x values to 24bpp coords (but avoid multiplication by 3)
        c = xSrcOff + prclClip->left;
        c = c + (c << 1);
        pjSrc = pjSrcScan0 + c + ((prclClip->top + ySrcOff) * cjSrcDelta);
        pulDst = -1 + pulDstScan0 + xDstOff + prclClip->left
                 + prclClip->top * culDstDelta;

        for (; --cScans >= 0; pjSrc += cjSrcDelta, pulDst += culDstDelta)
        {
            // read one less pixel per scan than there actually is to avoid any possibility of 
            // a memory access violation (we read 4 bytes but only 3 of them might be valid)
            for (pj = pjSrc, puld = pulDst, c = cPixPerScan-1; --c >= 0; pj += 3)
            {
                *++puld = *(ULONG *)pj & 0x00ffffff;
            }
            // now do the last pixel
            ++puld;
            *(USHORT *)puld = *(USHORT *)pj;
            ((BYTE *)puld)[2] = ((BYTE *)pj)[2];
        }
    }
}

//****************************************************************************
// FUNC: vGlintCopyBltBypassDownload16bpp
// DESC: using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
//****************************************************************************

VOID vGlintCopyBltBypassDownload16bpp(
PDEV    *ppdev,
SURFOBJ *psoSrc,
POINTL  *pptlSrc,
RECTL   *prclDst,
RECTL   *prclClip,
LONG     crclClip)
{
    LONG    xOff;
    ULONG   *pulSrcScan0;
    LONG    culSrcDelta, xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan;
    ULONG   *pulSrc;
    ULONG   *pulDst;
    GLINT_DECL;

#if DBG && 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((-1, "vGlintCopyBltBypassDownload16bpp(): cRects(%d) sizlDst(%d,%d)", crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG

    pulSrcScan0 = (ULONG *)psoSrc->pvScan0;
    culSrcDelta = psoSrc->lDelta >> 2;
    xSrcOff = pptlSrc->x - prclDst->left; // need to add arclClip[n].left to get xSrc
    ySrcOff = pptlSrc->y - prclDst->top;  // need to add arclClip[n].top to get ySrc

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;

        pulSrc = (ULONG *)((USHORT *)pulSrcScan0 + xSrcOff + prclClip->left)
                   + ((prclClip->top + ySrcOff) * culSrcDelta);
        pulDst = (ULONG *)((USHORT *)pulDstScan0 + xDstOff + prclClip->left)
                   + prclClip->top * culDstDelta;

        for (; --cScans >= 0; pulSrc += culSrcDelta, pulDst += culDstDelta)
        {
            ULONG   *pulSrcScan = pulSrc;
            ULONG   *pulDstScan = pulDst;
            LONG    cPix = cPixPerScan;
            LONG    cWords;

            if ((UINT_PTR)pulDstScan % sizeof(ULONG))
            {
                // we're not on a ulong boundary so write the first pixel of the scanline
                *(USHORT *)pulDstScan = *(USHORT *)pulSrcScan;
                pulDstScan = (ULONG *)((USHORT *)pulDstScan + 1);
                pulSrcScan = (ULONG *)((USHORT *)pulSrcScan + 1);
                --cPix;
            }

            // write out the ulong-aligned words of the scanline
            for (cWords = cPix / 2; --cWords >= 0;)
            {
                *pulDstScan++ = *pulSrcScan++;
            }

            // write any remaining pixel
            if (cPix % 2)
            {
                *(USHORT *)pulDstScan = *(USHORT *)pulSrcScan;
            }
        }
    }
}

//****************************************************************************
// FUNC: vGlintCopyBltBypassDownloadXlate4bpp
// DESC: using the bypass mechanism we can take advantage of write-combining
//       which can be quicker than using the FIFO
// NB. supports 32bpp and 16bpp destinations. Doesn't yet support 24bpp 
//     destinations. No plans to add 8bpp support.
//****************************************************************************

VOID vGlintCopyBltBypassDownloadXlate4bpp(
PDEV     *ppdev,
SURFOBJ  *psoSrc,
POINTL   *pptlSrc,
RECTL    *prclDst,
RECTL    *prclClip,
LONG      crclClip,
XLATEOBJ *pxlo)
{
    LONG    xOff;
    BYTE    *pjSrcScan0;
    LONG    cjSrcDelta, xSrcOff, ySrcOff;
    ULONG   *pulDstScan0;
    LONG    culDstDelta, xDstOff;
    LONG    cScans, cPixPerScan, c;
    ULONG   cjSrcDeltaRem, cjDstDeltaRem;
    ULONG   *aulXlate;
    BOOL    bSrcLowNybble;
    BYTE    *pjSrc, j, *pj;
    GLINT_DECL;

#if DBG && 0
    {
        SIZEL sizlDst;
        sizlDst.cx = prclClip->right - prclClip->left;
        sizlDst.cy = prclClip->bottom - prclClip->top;
        DISPDBG((-1, "vGlintCopyBltBypassDownloadXlate4bpp(): cRects(%d) sizlDst(%d,%d)", crclClip, sizlDst.cx, sizlDst.cy));
    }
#endif //DBG

    pjSrcScan0 = (BYTE *)psoSrc->pvScan0;
    cjSrcDelta = psoSrc->lDelta;
    xSrcOff = pptlSrc->x - prclDst->left; // need to add arclClip[n].left to get xSrc
    ySrcOff = pptlSrc->y - prclDst->top;  // need to add arclClip[n].top to get ySrc

    pulDstScan0 = (ULONG *)ppdev->pjScreen;
    culDstDelta = ppdev->DstPixelDelta >> (2 - ppdev->cPelSize);
    xDstOff     = ppdev->DstPixelOrigin + (ppdev->xyOffsetDst & 0xffff) +
                  (ppdev->xyOffsetDst >> 16) * ppdev->DstPixelDelta;

    aulXlate = pxlo->pulXlate;

    SYNC_IF_CORE_BUSY;

    for (; --crclClip >= 0; ++prclClip)
    {
        cScans = prclClip->bottom - prclClip->top;
        cPixPerScan = prclClip->right - prclClip->left;
        bSrcLowNybble = (xSrcOff + prclClip->left) & 1;
        cjSrcDeltaRem = cjSrcDelta - (cPixPerScan / 2 + ((cPixPerScan & 1) || bSrcLowNybble));
        pjSrc = -1 + pjSrcScan0 + (xSrcOff + prclClip->left) / 2 
                + ((prclClip->top + ySrcOff) * cjSrcDelta);

        if (ppdev->cPelSize == GLINTDEPTH32)
        {
            ULONG   *pulDst;

            cjDstDeltaRem = (culDstDelta - cPixPerScan) * 4;
            pulDst = -1 + pulDstScan0 + xDstOff + prclClip->left + prclClip->top * culDstDelta;

            if (bSrcLowNybble)
            {
                for (; --cScans >= 0; pjSrc += cjSrcDeltaRem, (BYTE *)pulDst += cjDstDeltaRem)
                {
                    j = *++pjSrc;
                    for (c = cPixPerScan / 2; --c >= 0;)
                    {
                        *++pulDst = aulXlate[j & 0xf];
                        j = *++pjSrc;
                        *++pulDst = aulXlate[j >> 4];
                    }
                    if (cPixPerScan & 1)
                    {
                        *++pulDst = aulXlate[j & 0xf];
                    }
                }
            }
            else
            {
                for (; --cScans >= 0; pjSrc += cjSrcDeltaRem, (BYTE *)pulDst += cjDstDeltaRem)
                {
                    for (c = cPixPerScan / 2; --c >= 0;)
                    {
                        j = *++pjSrc;
                        *++pulDst = aulXlate[j >> 4];
                        *++pulDst = aulXlate[j & 0xf];
                    }
                    if (cPixPerScan & 1)
                    {
                        j = *++pjSrc;
                        *++pulDst = aulXlate[j >> 4];
                    }
                }
            }
        }
        else if (ppdev->cPelSize == GLINTDEPTH16)
        {
            USHORT  *pusDst;

            cjDstDeltaRem = (culDstDelta << 2) - (cPixPerScan << ppdev->cPelSize);
            pusDst = -1 + (USHORT *)pulDstScan0 + xDstOff + prclClip->left
                     + prclClip->top * culDstDelta * 2;

            if (bSrcLowNybble)
            {
                for (; --cScans >= 0; pjSrc += cjSrcDeltaRem, (BYTE *)pusDst += cjDstDeltaRem)
                {
                    j = *++pjSrc;
                    for (c = cPixPerScan / 2; --c >= 0;)
                    {
                        *++pusDst = (USHORT)aulXlate[j & 0xf];
                        j = *++pjSrc;
                        *++pusDst = (USHORT)aulXlate[j >> 4];
                    }
                    if (cPixPerScan & 1)
                    {
                        *++pusDst = (USHORT)aulXlate[j & 0xf];
                    }
                }
            }
            else
            {
                for (; --cScans >= 0; pjSrc += cjSrcDeltaRem, (BYTE *)pusDst += cjDstDeltaRem)
                {
                    for (c = cPixPerScan / 2; --c >= 0;)
                    {
                        j = *++pjSrc;
                        *++pusDst = (USHORT)aulXlate[j >> 4];
                        *++pusDst = (USHORT)aulXlate[j & 0xf];
                    }
                    if (cPixPerScan & 1)
                    {
                        j = *++pjSrc;
                        *++pusDst = (USHORT)aulXlate[j >> 4];
                    }
                }
            }
        }
    }
}

#endif
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrx.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrx.c
*
* Content: Permedia3 code.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"
#include "pxrx.h"


#if DBG
    ULONG   inPxRxContextSwitch = FALSE;
#endif


#define TEST_MINIMUM_FIFO_SPACE(min, str)        do { ; } while(0)

extern GAPFNstripFunc   gapfnStripPXRX[];

// table to determine which logicops use a source colour/pixel
const DWORD LogicOpReadSrc[] = {
    0,                                /* 00 */
    1,                                /* 01 */
    1,                                /* 02 */
    1,                                /* 03 */
    1,                                /* 04 */
    0,                                /* 05 */
    1,                                /* 06 */
    1,                                /* 07 */
    1,                                /* 08 */
    1,                                /* 09 */
    0,                                /* 10 */
    1,                                /* 11 */
    1,                                /* 12 */
    1,                                /* 13 */
    1,                                /* 14 */
    0,                                /* 15 */
};

const ULONG render2D_NativeBlt[16] = {
    /*  0:     0        clear        */ __RENDER2D_SPANS,
    /*  1:   S &  D     AND          */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  2:   S & ~D     AND reverse  */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  3:   S          COPY         */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  4:  ~S &  D     AND inverted */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  5:        D     no op        */ __RENDER2D_SPANS,
    /*  6:   S ^  D     XOR          */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  7:   S |  D     OR           */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  8: ~(S |  D)    NOR          */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /*  9: ~(S ^  D)    equiv        */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 10:       ~D     invert       */ __RENDER2D_SPANS,
    /* 11:   S | ~D     OR reverse   */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 12:  ~S          copy invert  */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 13:  ~S | D      OR invert    */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 14: ~(S & D)     NAND         */ __RENDER2D_SPANS | __RENDER2D_FBSRCREAD,
    /* 15:     1        set          */ __RENDER2D_SPANS,
};

const ULONG render2D_FillSolid[16] = {
    /*  0:     0        clear        */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  1:   S &  D     AND          */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  2:   S & ~D     AND reverse  */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  3:   S          COPY         */ __RENDER2D_INCX | __RENDER2D_INCY,
    /*  4:  ~S &  D     AND inverted */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  5:        D     no op        */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  6:   S ^  D     XOR          */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  7:   S |  D     OR           */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  8: ~(S |  D)    NOR          */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /*  9: ~(S ^  D)    equiv        */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 10:       ~D     invert       */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 11:   S | ~D     OR reverse   */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 12:  ~S          copy invert  */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 13:  ~S | D      OR invert    */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 14: ~(S & D)     NAND         */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
    /* 15:     1        set          */ __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS,
};

const ULONG config2D_FillColour[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS                                                     | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(12)                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillColour32bpp[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_USERSCISSOR                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(12)                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillColourDual[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 3)                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(12)                            | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD | __CONFIG2D_EXTERNALSRC | __CONFIG2D_LUTENABLE,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillSolid[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(12),
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillSolidVariableSpans[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 3),
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(12),
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_FillSolid32bpp[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_USERSCISSOR,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(12),
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_CONSTANTSRC | __CONFIG2D_LOGOP_FORE(15),
};

const ULONG config2D_NativeBlt[16] = {
    /*  0:     0        clear        */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 0),
    /*  1:   S &  D     AND          */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 1) | __CONFIG2D_FBDESTREAD,
    /*  2:   S & ~D     AND reverse  */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 2) | __CONFIG2D_FBDESTREAD,
    /*  3:   S          COPY         */ __CONFIG2D_FBWRITE,
    /*  4:  ~S &  D     AND inverted */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 4) | __CONFIG2D_FBDESTREAD,
    /*  5:        D     no op        */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 5) | __CONFIG2D_FBDESTREAD,
    /*  6:   S ^  D     XOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 6) | __CONFIG2D_FBDESTREAD,
    /*  7:   S |  D     OR           */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 7) | __CONFIG2D_FBDESTREAD,
    /*  8: ~(S |  D)    NOR          */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 8) | __CONFIG2D_FBDESTREAD,
    /*  9: ~(S ^  D)    equiv        */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE( 9) | __CONFIG2D_FBDESTREAD,
    /* 10:       ~D     invert       */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(10) | __CONFIG2D_FBDESTREAD,
    /* 11:   S | ~D     OR reverse   */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(11) | __CONFIG2D_FBDESTREAD,
    /* 12:  ~S          copy invert  */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(12),
    /* 13:  ~S | D      OR invert    */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(13) | __CONFIG2D_FBDESTREAD,
    /* 14: ~(S & D)     NAND         */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(14) | __CONFIG2D_FBDESTREAD,
    /* 15:     1        set          */ __CONFIG2D_FBWRITE | __CONFIG2D_LOGOP_FORE(15),
};

typedef struct Tag_Data_TAG {
    ULONG   tag;
    ULONG   data;
} Tag_Data;

Tag_Data DefaultContext_P3[] = {
    { __GlintTagFilterMode,                     0x00000000 },    // [0x180]
//    { __GlintTagAStart,                           0x00000000 },    // [0x0F9]
//    { __GlintTagBStart,                           0x00000000 },    // [0x0F6]
//    { __GlintTagFStart,                           0x00000000 },    // [0x0D4]
//    { __GlintTagGStart,                           0x00000000 },    // [0x0F3]

    { __GlintTagAlphaBlendAlphaMode,            __PERMEDIA_DISABLE },    // [0x5F5]
    { __GlintTagAlphaBlendColorMode,            __PERMEDIA_DISABLE },    // [0x5F4]
    { __GlintTagAlphaDestColor,                 0xFFFFFFFF },    // [0x5F1]
    { __GlintTagAlphaSourceColor,               0xFFFFFFFF },    // [0x5F0]
    { __GlintTagAlphaTestMode,                  __PERMEDIA_DISABLE },    // [0x100]
    { __GlintTagAntialiasMode,                  __PERMEDIA_DISABLE },    // [0x101]
    { __GlintTagAreaStippleMode,                __PERMEDIA_DISABLE },    // [0x034]

    { __GlintTagColor,                          0xFFFFFFFF },    // [0x0FE]
    { __GlintTagColorDDAMode,                   __PERMEDIA_DISABLE },    // [0x0FC]
    { __GlintTagConstantColor,                  0xFFFFFFFF },    // [0x0FD]

//    { __GlintTagBasePageOfWorkingSet,         0x00000000 },    // [0x699]
    { __GlintTagBitMaskPattern,                 0xFFFFFFFF },    // [0x00D]
//    { __GlintTagBorderColor0,                 0x00000000 },    // [0x095]
//    { __GlintTagBorderColor1,                 0x00000000 },    // [0x09F]

    { __GlintTagChromaFailColor,                0x00000000 },    // [0x5F3]
    { __GlintTagChromaPassColor,                0xFFFFFFFF },    // [0x5F2]
    { __GlintTagChromaTestMode,                 __PERMEDIA_DISABLE },    // [0x1E3]
    {  __PXRXTagChromaLower,                    0x00000000 },    // [0x1E2]
    {  __PXRXTagChromaUpper,                    0xFFFFFFFF },    // [0x1E1]

//    { __GlintTagD3DAlphaTestMode,             0x00000000 },    // [0x5F8]
    { __DeltaTagDeltaMode,                         (1 << 19) },    // [0x260]
//    { __DeltaTagDeltaControl,                    (1 << 11) },    // [0x26A]    // P3, R3 & P4 Only
//    { __GlintTagDeltaTexture01,                   0x00000000 },    // [0x28B]
//    { __GlintTagDeltaTexture11,                   0x00000000 },    // [0x28C]
//    { __GlintTagDeltaTexture21,                   0x00000000 },    // [0x28D]
//    { __GlintTagDeltaTexture31,                   0x00000000 },    // [0x28E]
    { __DeltaTagXBias,                          P3_LINES_BIAS_P },    // [0x290]
    { __DeltaTagYBias,                          P3_LINES_BIAS_P },    // [0x291]

    { __GlintTagDepth,                          0x00000000 },    // [0x135]
    { __GlintTagDepthMode,                      __PERMEDIA_DISABLE },    // [0x134]
    { __GlintTagDitherMode,                     __PERMEDIA_DISABLE },// ??? 0x00000403,    // [0x103]
//    { __GlintTagEndOfFeedback,                    0x00000000 },    // [0x1FF]

//    { __GlintTagFBBlockColor,                 0x00000000 },    // [0x159]
//    { __GlintTagFBBlockColor0,                    0x00000000 },    // [0x60C]
//    { __GlintTagFBBlockColor1,                    0x00000000 },    // [0x60D]
//    { __GlintTagFBBlockColor2,                    0x00000000 },    // [0x60E]
//    { __GlintTagFBBlockColor3,                    0x00000000 },    // [0x60F]
//    { __GlintTagFBBlockColorBack,             0x00000000 },    // [0x614]
//    { __GlintTagFBBlockColorBack0,                0x00000000 },    // [0x610]
//    { __GlintTagFBBlockColorBack1,                0x00000000 },    // [0x611]
//    { __GlintTagFBBlockColorBack2,                0x00000000 },    // [0x612]
//    { __GlintTagFBBlockColorBack3,                0x00000000 },    // [0x613]
//    { __GlintTagFBBlockColorBackExt,          0x00000000 },    // [0x61D]
//    { __GlintTagFBBlockColorBackL,                0x00000000 },    // [0x18C]
//    { __GlintTagFBBlockColorBackU,                0x00000000 },    // [0x18B]
//    { __GlintTagFBBlockColorExt,              0x00000000 },    // [0x61C]
//    { __GlintTagFBBlockColorL,                    0x00000000 },    // [0x18E]
//    { __GlintTagFBBlockColorU,                    0x00000000 },    // [0x18D]
//    { __GlintTagFBColor,                      0x00000000 },    // [0x153]
//    { __GlintTagFBData,                           0x00000000 },    // [0x154]

//    { __GlintTagFBDestReadEnables,                0x00000000 },    // [0x5DD]
    { __GlintTagFBSoftwareWriteMask,            0xFFFFFFFF },    // [0x104]
    { __GlintTagFBSourceData,                   0x00000000 },    // [0x155]
//    { __GlintTagFBWriteMaskExt,                   0x00000000 },    // [0x61E]

//    { __GlintTagFastBlockLimits,              0x00000000 },    // [0x026]
//    { __GlintTagFastClearDepth,                   0x00000000 },    // [0x13C]
//    { __GlintTagFeedbackX,                        0x00000000 },    // [0x1F1]
//    { __GlintTagFeedbackY,                        0x00000000 },    // [0x1F2]
//    { __GlintTagFlushSpan,                        0x00000000 },    // [0x00C]
    { __GlintTagFogColor,                       0xFFFFFFFF },    // [0x0D3]
    { __GlintTagFogMode,                        0x00000001 },    // [0x0D2]

    { __GlintTagGIDMode,                        __PERMEDIA_DISABLE },    // [0x6A7]
//    { __GlintTagGlyphData,                        0x00000000 },    // [0x6CC]
//    { __GlintTagGlyphPosition,                    0x00000000 },    // [0x6C1]
//    { __GlintTagHeadPhysicalPageAllocation0,  0x00000000 },    // [0x690]
//    { __GlintTagHeadPhysicalPageAllocation1,  0x00000000 },    // [0x691]
//    { __GlintTagHeadPhysicalPageAllocation2,  0x00000000 },    // [0x692]
//    { __GlintTagHeadPhysicalPageAllocation3,  0x00000000 },    // [0x693]
//    { __GlintTagInvalidateCache,              0x00000000 },    // [0x66B]
//    { __GlintTagKdBStart,                     0x00000000 },    // [0x1A6]
//    { __GlintTagKdGStart,                     0x00000000 },    // [0x1A3]
//    { __GlintTagKdRStart,                     0x00000000 },    // [0x1A0]
//    { __GlintTagKsBStart,                     0x00000000 },    // [0x196]
//    { __GlintTagKsGStart,                     0x00000000 },    // [0x193]
//    { __GlintTagKsRStart,                     0x00000000 },    // [0x190]

//    { __GlintTagLBCancelWrite,                    0x00000000 },    // [0x13D]        // Obsoleted !!! ??? !!!
//    { __GlintTagLBClearDataL,                 0x00000000 },    // [0x6AA]
//    { __GlintTagLBClearDataU,                 0x00000000 },    // [0x6AB]
//    { __GlintTagLBDepth,                      0x00000000 },    // [0x116]
//    { __GlintTagLBDestReadBufferAddr,         0x005FF000 },    // [0x6A2]        ???
//    { __GlintTagLBDestReadBufferOffset,           0x00000000 },    // [0x6A3]
//    { __GlintTagLBDestReadEnables,                0x00000000 },    // [0x6A1]
//    { __GlintTagLBReadFormat,                 0x0C4C0420 },    // [0x111]        ???
//    { __GlintTagLBReadMode,                       0x00000000 },    // [0x110]        // Obsoleted !!! ??? !!!
//    { __GlintTagLBSourceData,                 0x00000000 },    // [0x114]
//    { __GlintTagLBSourceOffset,                   0x00000000 },    // [0x112]
//    { __GlintTagLBSourceReadBufferAddr,           0x005FF000 },    // [0x6A5]        ???
//    { __GlintTagLBSourceReadBufferOffset,     0x00000000 },    // [0x6A6]
//    { __GlintTagLBStencil,                        0x00000000 },    // [0x115]
//    { __GlintTagLBWindowBase,                 0x00000000 },    // [0x117]
//    { __GlintTagLBWindowOffset,                   0x00000000 },    // [0x11F]
//    { __GlintTagLBWriteBufferAddr,                0x005FF000 },    // [0x6A8]        ???
//    { __GlintTagLBWriteBufferOffset,          0x00000000 },    // [0x6A9]
//    { __GlintTagLBWriteFormat,                    0x0C4C0420 },    // [0x119]        ???

//    { __GlintTagLUTIndex,                     0x00000000 },    // [0x098]
//    { __GlintTagLUTData,                      0x00000000 },    // [0x099]
//    { __GlintTagLUTAddress,                       0x00000000 },    // [0x09A]
//    { __GlintTagLUTTransfer,                  0x00000000 },    // [0x09B]
    { __GlintTagLineStippleMode,                __PERMEDIA_DISABLE },    // [0x035]
//    { __GlintTagLoadLineStippleCounters,      0x00000000 },    // [0x036]
//    { __GlintTagLOD,                          0x00000000 },    // [0x07A]
    { __GlintTagLOD1,                           0x00000000 },    // [0x089]
    { __GlintTagLodRange0,                      0x00C00000 },    // [0x669]
    { __GlintTagLodRange1,                      0x00C00000 },    // [0x66A]
    { __GlintTagLogicalOpMode,                  __PERMEDIA_DISABLE },    // [0x105]
//    { __GlintTagLogicalTexturePageTableAddr,  0x00000000 },    // [0x69A]
//    { __GlintTagLogicalTexturePageTableLength,    0x00000000 },    // [0x69B]
//    { __GlintTagMaxHitRegion,                 0x00000000 },    // [0x186]
//    { __GlintTagMaxRegion,                        0x00000000 },    // [0x183]
//    { __GlintTagMergeSpanData,                    0x00000000 },    // [0x5E7]
//    { __GlintTagMinHitRegion,                 0x00000000 },    // [0x185]
//    { __GlintTagMinRegion,                        0x00000000 },    // [0x182]
//    { __GlintTagPCIWindowBase0,                   0x00000000 },    // [0x5E8]
//    { __GlintTagPCIWindowBase1,                   0x00000000 },    // [0x5E9]
//    { __GlintTagPCIWindowBase2,                   0x00000000 },    // [0x5EA]
//    { __GlintTagPCIWindowBase3,                   0x00000000 },    // [0x5EB]
//    { __GlintTagPCIWindowBase4,                   0x00000000 },    // [0x5EC]
//    { __GlintTagPCIWindowBase5,                   0x00000000 },    // [0x5ED]
//    { __GlintTagPCIWindowBase6,                   0x00000000 },    // [0x5EE]
//    { __GlintTagPCIWindowBase7,                   0x00000000 },    // [0x5EF]
//    { __GlintTagPacked4Pixels,                    0x00000000 },    // [0x6CD]
//    { __GlintTagPhysicalPageAllocationTableAddr,0x00000000 },    // [0x698]
//    { __GlintTagPickResult,                       0x00000000 },    // [0x187]
//    { __GlintTagPointTable0,                  0x00000000 },    // [0x010]
//    { __GlintTagPointTable1,                  0x00000000 },    // [0x011]
//    { __GlintTagPointTable2,                  0x00000000 },    // [0x012]
//    { __GlintTagPointTable3,                  0x00000000 },    // [0x013]
//    { __GlintTagPrepareToRender,              0x00000000 },    // [0x021]
//    { __GlintTagProvokingVertex,              0x00000000 },    // [0x267]
//    { __GlintTagQ1Start,                      0x00000000 },    // [0x086]
//    { __GlintTagRLCount,                      0x00000000 },    // [0x6CF]
//    { __GlintTagRLData,                           0x00000000 },    // [0x6CE]
//    { __GlintTagRLEMask,                      0x00000000 },    // [0x189]
//    { __GlintTagRStart,                           0x00000000 },    // [0x0F0]
    { __GlintTagRasterizerMode,                                    // [0x014]
                                                (1 << 0) |         // mirror bitmasks
                                                (3 << 7) |        // byteswap bitmasks ABCD => DCBA
                                                (1 << 18) },    // YLimits enabled
//    { __GlintTagRectangleOrigin,              0x00000000 },    // [0x6C0]
    { __GlintTagRenderPatchOffset,              0x00000000 },    // [0x6C2]
//    { __GlintTagRepeatLine,                       0x00000000 },    // [0x265]
//    { __GlintTagRepeatTriangle,                   0x00000000 },    // [0x262]
//    { __GlintTagResetPickResult,              0x00000000 },    // [0x184]
    { __GlintTagRouterMode,                     0x00000000 },    // [0x108]
//    { __GlintTagS1Start,                      0x00000000 },    // [0x080]
//    { __GlintTagSaveLineStippleCounters,      0x00000000 },    // [0x038]
//    { __GlintTagScanlineOwnership,                0x00000000 },    // [0x016]
    { __GlintTagScissorMaxXY,                   0x7FFF7FFF },    // [0x032]
//    { __GlintTagScissorMinXY,                 0x00000000 },    // [0x031]
    { __GlintTagScissorMode,                    __PERMEDIA_DISABLE },    // [0x030]
//    { __GlintTagSetLogicalTexturePage,            0x00000000 },    // [0x66C]
    { __GlintTagSizeOfFramebuffer,              0x00080000 },    // [0x615]
//    { __GlintTagStartXDom,                        0x00000000 },    // [0x000]
//    { __GlintTagStartXSub,                        0x00000000 },    // [0x002]
//    { __GlintTagStartY,                           0x00000000 },    // [0x004]
    { __GlintTagStatisticMode,                  0x00000000 },    // [0x181]
//    { __GlintTagStencil,                      0x00000000 },    // [0x133]
    { __GlintTagStencilData,                    0x00FFFFFF },    // [0x132]
    { __GlintTagStencilMode,                    0x00040000 },    // [0x131]        ???
//    { __GlintTagSuspendUntilFrameBlank,           0x00000000 },    // [0x18F]
//    { __GlintTagSync,                         0x00000000 },    // [0x188]
//    { __GlintTagT1Start,                      0x00000000 },    // [0x083]
//    { __GlintTagTailPhysicalPageAllocation0,  0x00000000 },    // [0x694]
//    { __GlintTagTailPhysicalPageAllocation1,  0x00000000 },    // [0x695]
//    { __GlintTagTailPhysicalPageAllocation2,  0x00000000 },    // [0x696]
//    { __GlintTagTailPhysicalPageAllocation3,  0x00000000 },    // [0x697]
    {  __PXRXTagTextureApplicationMode,         __PERMEDIA_DISABLE },    // [0x0D0]
    { __GlintTagQStart,                         0x00000000 },    // [0x077]
    { __GlintTagSStart,                         0x00000000 },    // [0x071]
    { __GlintTagTStart,                         0x00000000 },    // [0x074]

//    { __GlintTagTextureCacheControl,          0x00000000 },    // [0x092]
//    { __GlintTagTextureChromaLower0,          0x00000000 },    // [0x09E]
//    { __GlintTagTextureChromaLower1,          0x00000000 },    // [0x0C1]
//    { __GlintTagTextureChromaUpper0,          0x00000000 },    // [0x09D]
//    { __GlintTagTextureChromaUpper1,          0x00000000 },    // [0x0C0]
    { __GlintTagTextureCompositeAlphaMode0,     0x00008000 },    // [0x662]    ???
    { __GlintTagTextureCompositeAlphaMode1,     0x00008000 },    // [0x664]    ???
    { __GlintTagTextureCompositeColorMode0,     __PERMEDIA_DISABLE },    // [0x661]
    { __GlintTagTextureCompositeColorMode1,     0x00008000 },    // [0x663]    ???
    { __GlintTagTextureCompositeFactor0,        0xFFFFFFFF },    // [0x665]    ???
    { __GlintTagTextureCompositeFactor1,        0xFFFFFFFF },    // [0x666]    ???
    { __GlintTagTextureCompositeMode,           0x00000000 },    // [0x660]
    {  __PXRXTagTextureCoordMode,               __PERMEDIA_ENABLE |    // [0x070]
                                                    (1 << 1) |        // SWrap repeat
                                                    (1 << 3) |        // TWrap repeat
                                                    (1 << 17) },    // texture map type == 2D
//    { __GlintTagTextureData,                  0x00000000 },    // [0x11D]
//    { __GlintTagTextureDownloadOffset,            0x00000000 },    // [0x11E]
    { __GlintTagTextureEnvColor,                0xFFFFFFFF },    // [0x0D1]
    { __GlintTagTextureFilterMode,              __PERMEDIA_DISABLE },    // [0x09C]
//    { __GlintTagTextureFormat,                    0x00000000 },    // [0x091]
    { __GlintTagTextureIndexMode0,              __PERMEDIA_ENABLE |    // [0x667]
                                                    (10 << 1) |        // texture map log2(width) == log2(1024)
                                                    (10 << 5) |        // texture map log2(height) == log2(1024)
                                                    (1 << 10) |        // UWrap repeat
                                                    (1 << 12) |        // VWrap repeat
                                                    (1 << 14) |        // texture map type == 2D
                                                    (1 << 21) },    // nearest neighbour bias = 0
    { __GlintTagTextureIndexMode1,              0x00200000 },    // [0x668]    ???
    { __GlintTagTextureLODBiasS,                0x00000000 },    // [0x08A]    ???
    { __GlintTagTextureLODBiasT,                0x00000000 },    // [0x08B]    ???
//    { __GlintTagTextureLODScale,              0x00000000 },    // [0x268]
//    { __GlintTagTextureLODScale1,             0x00000000 },    // [0x269]
//    { __GlintTagTextureMapWidth0,             0x00000000 },    // [0x683]
//    { __GlintTagTextureMapWidth1,             0x00000000 },    // [0x684]
//    { __GlintTagTextureReadMode,              0x00000000 },    // [0x090]
    { __GlintTagTextureReadMode0,               __PERMEDIA_ENABLE |    // [0x680]
                                                    (7 << 25) |        // byteswap: HGFEDCBA
                                                    (1 << 28) },    // mirror bitmap
    { __GlintTagTextureReadMode1,               0x00000400 },    // [0x681]    ???

//    { __GlintTagTouchLogicalPage,             0x00000000 },    // [0x66E]
//    { __GlintTagUpdateLineStippleCounters,        0x00000000 },    // [0x037]
//    { __GlintTagUpdateLogicalTextureInfo,     0x00000000 },    // [0x66D]
//    { __GlintTagV0FloatA,                     0x00000000 },    // [0x238]
//    { __GlintTagV0FloatB,                     0x00000000 },    // [0x237]
//    { __GlintTagV0FloatF,                     0x00000000 },    // [0x239]
//    { __GlintTagV0FloatG,                     0x00000000 },    // [0x236]
//    { __GlintTagV0FloatKdB,                       0x00000000 },    // [0x20F]
//    { __GlintTagV0FloatKdG,                       0x00000000 },    // [0x20E]
//    { __GlintTagV0FloatKdR,                       0x00000000 },    // [0x20D]
//    { __GlintTagV0FloatKsB,                       0x00000000 },    // [0x20C]
//    { __GlintTagV0FloatKsG,                       0x00000000 },    // [0x20B]
//    { __GlintTagV0FloatKsR,                       0x00000000 },    // [0x20A]
//    { __GlintTagV0FloatPackedColour,          0x00000000 },    // [0x23E]
//    { __GlintTagV0FloatPackedSpecularFog,     0x00000000 },    // [0x23F]
//    { __GlintTagV0FloatQ,                     0x00000000 },    // [0x232]
//    { __GlintTagV0FloatQ1,                        0x00000000 },    // [0x202]
//    { __GlintTagV0FloatR,                     0x00000000 },    // [0x235]
//    { __GlintTagV0FloatS,                     0x00000000 },    // [0x230]
//    { __GlintTagV0FloatS1,                        0x00000000 },    // [0x200]
//    { __GlintTagV0FloatT,                     0x00000000 },    // [0x231]
//    { __GlintTagV0FloatT1,                        0x00000000 },    // [0x201]
//    { __GlintTagV0FloatX,                     0x00000000 },    // [0x23A]
//    { __GlintTagV0FloatY,                     0x00000000 },    // [0x23B]
//    { __GlintTagV0FloatZ,                     0x00000000 },    // [0x23C]
//    { __GlintTagV0Reserved0,                  0x00000000 },    // [0x203]
//    { __GlintTagV0Reserved1,                  0x00000000 },    // [0x204]
//    { __GlintTagV0Reserved2,                  0x00000000 },    // [0x205]
//    { __GlintTagV0Reserved3,                  0x00000000 },    // [0x206]
//    { __GlintTagV0Reserved4,                  0x00000000 },    // [0x207]
//    { __GlintTagV0Reserved5,                  0x00000000 },    // [0x208]
//    { __GlintTagV0Reserved6,                  0x00000000 },    // [0x209]
//    { __GlintTagV0Reserved7,                  0x00000000 },    // [0x233]
//    { __GlintTagV0Reserved8,                  0x00000000 },    // [0x234]
//    { __GlintTagV1FloatA,                     0x00000000 },    // [0x248]
//    { __GlintTagV1FloatB,                     0x00000000 },    // [0x247]
//    { __GlintTagV1FloatF,                     0x00000000 },    // [0x249]
//    { __GlintTagV1FloatG,                     0x00000000 },    // [0x246]
//    { __GlintTagV1FloatKdB,                       0x00000000 },    // [0x21F]
//    { __GlintTagV1FloatKdG,                       0x00000000 },    // [0x21E]
//    { __GlintTagV1FloatKdR,                       0x00000000 },    // [0x21D]
//    { __GlintTagV1FloatKsB,                       0x00000000 },    // [0x21C]
//    { __GlintTagV1FloatKsG,                       0x00000000 },    // [0x21B]
//    { __GlintTagV1FloatKsR,                       0x00000000 },    // [0x21A]
//    { __GlintTagV1FloatPackedColour,          0x00000000 },    // [0x24E]
//    { __GlintTagV1FloatPackedSpecularFog,     0x00000000 },    // [0x24F]
//    { __GlintTagV1FloatQ,                     0x00000000 },    // [0x242]
//    { __GlintTagV1FloatQ1,                        0x00000000 },    // [0x212]
//    { __GlintTagV1FloatR,                     0x00000000 },    // [0x245]
//    { __GlintTagV1FloatS,                     0x00000000 },    // [0x240]
//    { __GlintTagV1FloatS1,                        0x00000000 },    // [0x210]
//    { __GlintTagV1FloatT,                     0x00000000 },    // [0x241]
//    { __GlintTagV1FloatT1,                        0x00000000 },    // [0x211]
//    { __GlintTagV1FloatX,                     0x00000000 },    // [0x24A]
//    { __GlintTagV1FloatY,                     0x00000000 },    // [0x24B]
//    { __GlintTagV1FloatZ,                     0x00000000 },    // [0x24C]
//    { __GlintTagV1Reserved0,                  0x00000000 },    // [0x213]
//    { __GlintTagV1Reserved1,                  0x00000000 },    // [0x214]
//    { __GlintTagV1Reserved2,                  0x00000000 },    // [0x215]
//    { __GlintTagV1Reserved3,                  0x00000000 },    // [0x216]
//    { __GlintTagV1Reserved4,                  0x00000000 },    // [0x217]
//    { __GlintTagV1Reserved5,                  0x00000000 },    // [0x218]
//    { __GlintTagV1Reserved6,                  0x00000000 },    // [0x219]
//    { __GlintTagV1Reserved7,                  0x00000000 },    // [0x243]
//    { __GlintTagV1Reserved8,                  0x00000000 },    // [0x244]
//    { __GlintTagV2FloatA,                     0x00000000 },    // [0x258]
//    { __GlintTagV2FloatB,                     0x00000000 },    // [0x257]
//    { __GlintTagV2FloatF,                     0x00000000 },    // [0x259]
//    { __GlintTagV2FloatG,                     0x00000000 },    // [0x256]
//    { __GlintTagV2FloatKdB,                       0x00000000 },    // [0x22F]
//    { __GlintTagV2FloatKdG,                       0x00000000 },    // [0x22E]
//    { __GlintTagV2FloatKdR,                       0x00000000 },    // [0x22D]
//    { __GlintTagV2FloatKsB,                       0x00000000 },    // [0x22C]
//    { __GlintTagV2FloatKsG,                       0x00000000 },    // [0x22B]
//    { __GlintTagV2FloatKsR,                       0x00000000 },    // [0x22A]
//    { __GlintTagV2FloatPackedColour,          0x00000000 },    // [0x25E]
//    { __GlintTagV2FloatPackedSpecularFog,     0x00000000 },    // [0x25F]
//    { __GlintTagV2FloatQ,                     0x00000000 },    // [0x252]
//    { __GlintTagV2FloatQ1,                        0x00000000 },    // [0x222]
//    { __GlintTagV2FloatR,                     0x00000000 },    // [0x255]
//    { __GlintTagV2FloatS,                     0x00000000 },    // [0x250]
//    { __GlintTagV2FloatS1,                        0x00000000 },    // [0x220]
//    { __GlintTagV2FloatT,                     0x00000000 },    // [0x251]
//    { __GlintTagV2FloatT1,                        0x00000000 },    // [0x221]
//    { __GlintTagV2FloatX,                     0x00000000 },    // [0x25A]
//    { __GlintTagV2FloatY,                     0x00000000 },    // [0x25B]
//    { __GlintTagV2FloatZ,                     0x00000000 },    // [0x25C]
//    { __GlintTagV2Reserved0,                  0x00000000 },    // [0x223]
//    { __GlintTagV2Reserved1,                  0x00000000 },    // [0x224]
//    { __GlintTagV2Reserved2,                  0x00000000 },    // [0x225]
//    { __GlintTagV2Reserved3,                  0x00000000 },    // [0x226]
//    { __GlintTagV2Reserved4,                  0x00000000 },    // [0x227]
//    { __GlintTagV2Reserved5,                  0x00000000 },    // [0x228]
//    { __GlintTagV2Reserved6,                  0x00000000 },    // [0x229]
//    { __GlintTagV2Reserved7,                  0x00000000 },    // [0x253]
//    { __GlintTagV2Reserved8,                  0x00000000 },    // [0x254]
//    { __GlintTagVTGAddress,                       0x00000000 },    // [0x616]
//    { __GlintTagVTGData,                      0x00000000 },    // [0x617]
//    { __GlintTagWaitForCompletion,                0x00000000 },    // [0x017]

    { __GlintTagWindow,                         0x00000000 },    // [0x130]
    { __GlintTagWindowOrigin,                   0x00000000 },    // [0x039]
//    { __GlintTagXBias,                            0x00000000 },    // [0x290]
//    { __GlintTagYBias,                            0x00000000 },    // [0x291]
    { __GlintTagYLimits,                        0x7FFF0000 },    // [0x015]    // Allow y values from 0 to 32767
    {  __PXRXTagYUVMode,                        __PERMEDIA_DISABLE },    // [0x1E0]

//    { __GlintTagZFogBias,                     0x00000000 },    // [0x0D7]
//    { __GlintTagZStartL,                      0x00000000 },    // [0x137]
//    { __GlintTagZStartU,                      0x00000000 },    // [0x136]
//    { __GlintTagdAdx,                         0x00000000 },    // [0x0FA]
//    { __GlintTagdAdyDom,                      0x00000000 },    // [0x0FB]
//    { __GlintTagdBdx,                         0x00000000 },    // [0x0F7]
//    { __GlintTagdBdyDom,                      0x00000000 },    // [0x0F8]
//    { __GlintTagdFdx,                         0x00000000 },    // [0x0D5]
//    { __GlintTagdFdyDom,                      0x00000000 },    // [0x0D6]
//    { __GlintTagdGdx,                         0x00000000 },    // [0x0F4]
//    { __GlintTagdGdyDom,                      0x00000000 },    // [0x0F5]
//    { __GlintTagdKdBdx,                           0x00000000 },    // [0x1A7]
//    { __GlintTagdKdBdyDom,                        0x00000000 },    // [0x1A8]
//    { __GlintTagdKdGdx,                           0x00000000 },    // [0x1A4]
//    { __GlintTagdKdGdyDom,                        0x00000000 },    // [0x1A5]
//    { __GlintTagdKdRdx,                           0x00000000 },    // [0x1A1]
//    { __GlintTagdKdRdyDom,                        0x00000000 },    // [0x1A2]
//    { __GlintTagdKsBdx,                           0x00000000 },    // [0x197]
//    { __GlintTagdKsBdyDom,                        0x00000000 },    // [0x198]
//    { __GlintTagdKsGdx,                           0x00000000 },    // [0x194]
//    { __GlintTagdKsGdyDom,                        0x00000000 },    // [0x195]
//    { __GlintTagdKsRdx,                           0x00000000 },    // [0x191]
//    { __GlintTagdKsRdyDom,                        0x00000000 },    // [0x192]
//    { __GlintTagdQ1dx,                            0x00000000 },    // [0x087]
//    { __GlintTagdQ1dyDom,                     0x00000000 },    // [0x088]
    { __GlintTagdQdx,                           0x00000000 },    // [0x078]
    { __GlintTagdQdy,                           0x00000000 },    // [0x07D]
    { __GlintTagdQdyDom,                        0x00000000 },    // [0x079]
//    { __GlintTagdRdx,                         0x00000000 },    // [0x0F1]
//    { __GlintTagdRdyDom,                      0x00000000 },    // [0x0F2]
//    { __GlintTagdS1dx,                            0x00000000 },    // [0x081]
//    { __GlintTagdS1dyDom,                     0x00000000 },    // [0x082]
    { __GlintTagdSdx,                           1 << (32 - 10) },    // [0x072]
    { __GlintTagdSdy,                           0x00000000 },    // [0x07B]
    { __GlintTagdSdyDom,                        0x00000000 },    // [0x073]
//    { __GlintTagdT1dx,                            0x00000000 },    // [0x084]
//    { __GlintTagdT1dyDom,                     0x00000000 },    // [0x085]
    { __GlintTagdTdx,                           0x00000000 },    // [0x075]
    { __GlintTagdTdy,                           0x00000000 },    // [0x07C]
    { __GlintTagdTdyDom,                        1 << (32 - 10) },    // [0x076]

    { __GlintTagdXDom,                          0          },    // [0x001]
    { __GlintTagdXSub,                          0          },    // [0x003]
    { __GlintTagdY,                             INTtoFIXED(1) },    // [0x005]
//    { __GlintTagdZdxL,                            0x00000000 },    // [0x139]
//    { __GlintTagdZdxU,                            0x00000000 },    // [0x138]
//    { __GlintTagdZdyDomL,                     0x00000000 },    // [0x13B]
//    { __GlintTagdZdyDomU,                     0x00000000 },    // [0x13A]
    { __GlintTagLBDestReadMode,                 0x00000000 },  // [0x6A0]
    { __GlintTagLBSourceReadMode,               0x00000000 },  // [0x6A4]
    { __GlintTagLBWriteMode,                    0x00000000 },  // [0x118]
};

DWORD   NUM_P3_CTXT_TAGS = (sizeof(DefaultContext_P3) / sizeof(DefaultContext_P3[0]));

void pxrxSetupDualWrites_Patching( PPDEV ppdev ) {
    ULONG   bypass = 0;
    GLINT_DECL;

    DISPDBG((7, "pxrxSetupDualWrites_Patching entered"));

    __RENDER2D_OP_PATCHORDER = 0;

    glintInfo->fbWriteModeSingleWrite = 1;
    glintInfo->fbWriteModeDualWrite = 1 | (1 << 4) | (1 << 12) | (1 << 13);
    glintInfo->fbWriteModeSingleWriteStereo = 1 | (1 << 4) | (1 << 12) | (1 << 15);
    glintInfo->fbWriteModeDualWriteStereo = 1 | (1 << 4) | (1 << 12) | (1 << 13) | (1 << 14) | (1 << 15);

    if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT ) {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Enabling front buffer patching"));

        __RENDER2D_OP_PATCHORDER = __RENDER2D_OP_PATCHORDER_PATCHED;
        glintInfo->fbWriteModeSingleWrite |= (1 << 16) | (1 << 18) | (1 << 20) | (1 << 22);
        glintInfo->fbWriteModeDualWrite |= (1 << 16);
        glintInfo->fbWriteModeSingleWriteStereo |= (1 << 16) | (1 << 18) | (1 << 20) | (1 << 22);
        glintInfo->fbWriteModeDualWriteStereo |= (1 << 16) | (1 << 20);
    }

    bypass |= ppdev->cPelSize << 5;
    if( ppdev->cxMemory <= 1024 )
        bypass |= (0 << 7);
    else if( ppdev->cxMemory <= 2048 )
        bypass |= (1 << 7);
    else if( ppdev->cxMemory <= 4096 )
        bypass |= (2 << 7);
    else if( ppdev->cxMemory <= 8192 )
        bypass |= (3 << 7);

    if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Enabling back buffer patching"));

        __RENDER2D_OP_PATCHORDER = __RENDER2D_OP_PATCHORDER_PATCHED;
        glintInfo->fbWriteModeDualWrite |= (1 << 18);
        glintInfo->fbWriteModeDualWriteStereo |= (1 << 18) | (1 << 22);
    }

    if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT ) {
        if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) {
            // Patched front and back:
            bypass |= (1 << 2);

            // We need to do very odd things with a non power of 2 stride :-(.
//          if( ppdev->cxMemory > 8192 )
            if( ppdev->cxMemory != 1024 )
                glintInfo->GdiCantAccessFramebuffer = TRUE; // bypass 'effective stride' is too big
        } else {
            // Patched front only:
            glintInfo->GdiCantAccessFramebuffer = TRUE;
        }
    } else {
        if( glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) {
            // Patched back only:
            glintInfo->GdiCantAccessFramebuffer = TRUE;
        } else {
            // Linear front and back:
        }
    }

    if( glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE ) {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Enabling dual writes"));

        if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE )
            glintInfo->fbWriteMode = glintInfo->fbWriteModeDualWriteStereo;
        else
            glintInfo->fbWriteMode = glintInfo->fbWriteModeDualWrite;

        glintInfo->pxrxFlags |= PXRX_FLAGS_DUAL_WRITING;

        glintInfo->fbWriteOffset[1] = glintInfo->backBufferXY;
        glintInfo->fbWriteOffset[2] = glintInfo->backRightBufferXY;

    } else {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Disabling dual writes"));

        if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE )
            glintInfo->fbWriteMode = glintInfo->fbWriteModeSingleWriteStereo;
        else
            glintInfo->fbWriteMode = glintInfo->fbWriteModeSingleWrite;

        glintInfo->pxrxFlags &= ~PXRX_FLAGS_DUAL_WRITING;

        glintInfo->fbWriteOffset[1] = 0x00000000;
        glintInfo->fbWriteOffset[2] = 0x00000000;
    }

    if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE ) {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Enabling stereo writes"));

        glintInfo->pxrxFlags |= PXRX_FLAGS_STEREO_WRITING;
    
        glintInfo->fbWriteOffset[3] = glintInfo->frontRightBufferXY;
    }
    else {
        DISPDBG((7, "pxrxSetupDualWrites_Patching: Disabling stereo writes"));

        glintInfo->pxrxFlags &= ~PXRX_FLAGS_STEREO_WRITING;
    
        glintInfo->fbWriteOffset[3] = 0x00000000;
    }

    if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ) {
        // Unfortunately, the bypass requires the back buffer to be aligned on a
        // (power of 2) * 1MB boundary. So for the time being, just pretend we
        // can't actually dual write through it.

        // Also, we can't set the bypass up to read from the back buffer. So when
        // OGL has page flipped so that the back buffer is now the current buffer
        // any logic-ops will get source data from the wrong location :-(.

        glintInfo->GdiCantAccessFramebuffer = TRUE;
        /*{
            ULONG   size = (ppdev->cxMemory * (glintInfo->backBufferXY >> 16)) + (glintInfo->backBufferXY & 0xFFFF);
            int     i;

            size <<= ppdev->cPelSize;
            size >>= 20;
            for( i = 0; i <= 7; i++ )
                if( size & (1 << i) )
                    break;

            if( i < 0 )
                glintInfo->GdiCantAccessFramebuffer = TRUE;
            else
                bypass |= (i << 7);
        }*/
    }

//@@BEGIN_DDKSPLIT
//  if( GLINT_P3R3 ) {
//@@END_DDKSPLIT
        switch( ppdev->cPelSize ) {
            case GLINTDEPTH32:
                if( (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ||
                    (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK) ) {
                    ppdev->pgfnFillSolid    = p3r3FillSolidVariableSpans;
                    ppdev->pgfnFillPatColor = p3r3FillPatColorVariableSpans;
                    ppdev->pgfnFillPatMono  = p3r3FillPatMonoVariableSpans;
                } else {
                    ppdev->pgfnFillSolid    = p3r3FillSolid32bpp;
                    ppdev->pgfnFillPatColor = p3r3FillPatColor32bpp;
                    ppdev->pgfnFillPatMono  = p3r3FillPatMono32bpp;
                }
            break;

            case GLINTDEPTH8:
                if( (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ||
                    (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK) ) {
                    ppdev->pgfnFillPatMono  = p3r3FillPatMonoVariableSpans;
                } else {
                    ppdev->pgfnFillPatMono  = pxrxFillPatMono;
                }
            break;
        }
//@@BEGIN_DDKSPLIT
//  }
//@@END_DDKSPLIT

    if( (glintInfo->pxrxFlags & (PXRX_FLAGS_PATCHING_FRONT | PXRX_FLAGS_PATCHING_BACK)) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ||
        glintInfo->GdiCantAccessFramebuffer ||
        ((ppdev->cPelSize != GLINTDEPTH16) && (ppdev->cPelSize != GLINTDEPTH32)) ) 
    {
        ppdev->pgfnCopyXfer8bppLge  = pxrxCopyXfer8bppLge;
        ppdev->pgfnCopyXfer8bpp     = pxrxCopyXfer8bppLge;
    } else {
        ppdev->pgfnCopyXfer8bppLge  = pxrxCopyXfer8bppLge;
        ppdev->pgfnCopyXfer8bpp     = vGlintCopyBltBypassDownloadXlate8bpp;
    }

    WRITE_GLINT_CTRL_REG( PXRXByAperture2Stride,    ppdev->cxMemory );
    WRITE_GLINT_CTRL_REG( PXRXByAperture2Mode,      bypass );

    glintInfo->pxrxByDMAReadMode = bypass;

    if(ppdev->flCaps & CAPS_USE_AGP_DMA)
        glintInfo->pxrxByDMAReadMode |= PXRX_BYPASS_READ_DMA_AGP_BIT;

    WRITE_GLINT_CTRL_REG( PXRXByDMAReadMode,        glintInfo->pxrxByDMAReadMode );
    WRITE_GLINT_CTRL_REG( PXRXByDMAReadStride,      ppdev->cxMemory );

    DISPDBG((7, "pxrxSetupDualWrites_Patching exited"));
}

void pxrxRestore2DContext( PPDEV ppdev, BOOL switchingIn ) {
    ULONG   i, f, b;
    ULONG   enableFlags;
    GLINT_DECL;

#if DBG
    inPxRxContextSwitch = TRUE;
#endif

    DISPDBG((7, "pxrxRestore2DContext entered"));

    if( switchingIn ) {
        // Switching in to 2D...
        gi_pxrxDMA.NTbuff   = 0;
        gi_pxrxDMA.NTptr    = gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff];
        gi_pxrxDMA.P3at     = gi_pxrxDMA.NTptr;
        gi_pxrxDMA.NTdone   = gi_pxrxDMA.NTptr;
#if PXRX_DMA_BUFFER_CHECK
        glintInfo->NTwait   = gi_pxrxDMA.NTptr;
#endif

        CHECK_PXRX_DMA_VALIDITY( CHECK_SWITCH, 0 );

        pxrxSetupDualWrites_Patching( ppdev );

        DISPDBG((8, "pxrxRestore2DContext: restoring core registers"));

        WAIT_PXRX_DMA_TAGS( NUM_P3_CTXT_TAGS );

        for( i = 0; i < NUM_P3_CTXT_TAGS; i++ )
            QUEUE_PXRX_DMA_TAG( DefaultContext_P3[i].tag, DefaultContext_P3[i].data );

        if( glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE ) {
            f = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ? 1 : 0;
            b = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_BACK ) ? 1 : 0;
        } else
            f = b = (glintInfo->pxrxFlags & PXRX_FLAGS_PATCHING_FRONT) ? 1 : 0;

        WAIT_PXRX_DMA_TAGS( 40 );


        QUEUE_PXRX_DMA_TAG( __DeltaTagDeltaControl,                (1 << 11) );

        QUEUE_PXRX_DMA_TAG( __GlintTagPixelSize,                    2 - ppdev->cPelSize );            // [0x018]

        QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor,              glintInfo->foregroundColour );    // [0x618]
        QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor,              glintInfo->backgroundColour );    // [0x619]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr0,        glintInfo->fbDestAddr[0] );        // [0x5D0]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr1,        glintInfo->fbDestAddr[1] );        // [0x5D1]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr2,        glintInfo->fbDestAddr[2] );        // [0x5D2]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr3,        glintInfo->fbDestAddr[3] );        // [0x5D3]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset0,      glintInfo->fbDestOffset[0] );    // [0x5D4]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset1,      glintInfo->fbDestOffset[1] );    // [0x5D5]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset2,      glintInfo->fbDestOffset[2] );    // [0x5D6]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset3,      glintInfo->fbDestOffset[3] );    // [0x5D7]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth0,       glintInfo->fbDestWidth[0] );    // [0x5D8]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth1,       glintInfo->fbDestWidth[1] );    // [0x5D9]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth2,       glintInfo->fbDestWidth[2] );    // [0x5DA]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth3,       glintInfo->fbDestWidth[3] );    // [0x5DB]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferAddr,       glintInfo->fbSourceAddr );        // [0x5E1]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferOffset,     glintInfo->fbSourceOffset );    // [0x5E2]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferWidth,      glintInfo->fbSourceWidth );        // [0x5E3]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr0,           glintInfo->fbWriteAddr[0] );    // [0x600]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr1,           glintInfo->fbWriteAddr[1] );    // [0x601]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr2,           glintInfo->fbWriteAddr[2] );    // [0x602]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr3,           glintInfo->fbWriteAddr[3] );    // [0x603]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset0,         glintInfo->fbWriteOffset[0] );    // [0x604]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset1,         glintInfo->fbWriteOffset[1] );    // [0x605]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset2,         glintInfo->fbWriteOffset[2] );    // [0x606]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset3,         glintInfo->fbWriteOffset[3] );    // [0x607]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth0,          glintInfo->fbWriteWidth[0] );    // [0x608]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth1,          glintInfo->fbWriteWidth[1] );    // [0x609]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth2,          glintInfo->fbWriteWidth[2] );    // [0x60A]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth3,          glintInfo->fbWriteWidth[3] );    // [0x60B]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode,                  glintInfo->fbWriteMode );        // [0x157]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBHardwareWriteMask,          glintInfo->DefaultWriteMask );    // [0x158]
        glintInfo->WriteMask = glintInfo->DefaultWriteMask;

        QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadMode,               glintInfo->fbDestMode);            // [0x5DC]
        QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadMode,                (1 << 0) | (1 << 1) | (f << 8) );    // [0x5E0]

        QUEUE_PXRX_DMA_TAG( __GlintTagScreenSize,                   MAKEDWORD_XY(ppdev->cxScreen, ppdev->cyScreen) );    // [0x033]

        QUEUE_PXRX_DMA_TAG( __GlintTagLUTMode,                      glintInfo->lutMode );            // [0x66F]
        QUEUE_PXRX_DMA_TAG( __GlintTagConfig2D,                     glintInfo->config2D );            // [0x6C3]

        SEND_PXRX_DMA_FORCE;

        //wait for host in id to come out.
        SYNC_WITH_GLINT;

        // Invalidate some caches:
        ppdev->PalLUTType = LUTCACHE_INVALID;
        RtlZeroMemory( &ppdev->abeMono, sizeof(ppdev->abeMono) );

        DISPDBG((7, "pxrxRestore2DContext: restoring control registers"));

        if( (ppdev->sendPXRXdmaBatch != ppdev->sendPXRXdmaForce) && INTERRUPTS_ENABLED ) {
            gi_pxrxDMA.scheme = glintInfo->usePXRXdma;
            glintInfo->pInterruptCommandBlock->Control |= PXRX_SEND_ON_VBLANK_ENABLED;
            READ_GLINT_CTRL_REG ( IntEnable, enableFlags );
            WRITE_GLINT_CTRL_REG( IntEnable, enableFlags | INTR_ENABLE_VBLANK );
        } else
            gi_pxrxDMA.scheme = USE_PXRX_DMA_NONE;

    } else {
        // Switching out of 2D...
        if( INTERRUPTS_ENABLED )
            glintInfo->pInterruptCommandBlock->Control &= ~PXRX_SEND_ON_VBLANK_ENABLED;
    }

#if DBG
    inPxRxContextSwitch = FALSE;
#endif

    DISPDBG((7, "pxrxRestore2DContext exited"));
}

VOID pxrxSetupFunctionPointers( PPDEV ppdev )
{
    ULONG   ul;
    GLINT_DECL;

    switch( glintInfo->usePXRXdma ) {
        case USE_PXRX_DMA_FIFO:
            ppdev->sendPXRXdmaForce             = sendPXRXdmaFIFO;
            ppdev->sendPXRXdmaQuery             = sendPXRXdmaFIFO;
            ppdev->sendPXRXdmaBatch             = sendPXRXdmaFIFO;
            ppdev->switchPXRXdmaBuffer          = switchPXRXdmaBufferFIFO;
            ppdev->waitPXRXdmaCompletedBuffer   = waitPXRXdmaCompletedBufferFIFO;
        break;

        default:
            DISPDBG((ERRLVL,"Unknown PXRX dma scheme!"));
    }

    if( !INTERRUPTS_ENABLED )
        ppdev->sendPXRXdmaBatch = ppdev->sendPXRXdmaQuery = ppdev->sendPXRXdmaForce;

    ppdev->pgfnCopyBltCopyROP   = pxrxCopyBltNative;
    ppdev->pgfnCopyBltNative    = pxrxCopyBltNative;
    ppdev->pgfnCopyBlt          = pxrxCopyBltNative;
    ppdev->pgfnFillSolid        = pxrxFillSolid;
    ppdev->pgfnFillPatMono      = pxrxFillPatMono;
    ppdev->pgfnFillPatColor     = pxrxFillPatColor;
    ppdev->pgfnXfer1bpp         = pxrxXfer1bpp;
    ppdev->pgfnXfer4bpp         = pxrxXfer4bpp;
    ppdev->pgfnXfer8bpp         = pxrxXfer8bpp;
//  ppdev->pgfnXfer16bpp        = pxrxXfer16bpp;
//  ppdev->pgfnXfer24bpp        = pxrxXfer24bpp;
    ppdev->pgfnXferImage        = pxrxXferImage;
    ppdev->pgfnMaskCopyBlt      = pxrxMaskCopyBlt;
    ppdev->pgfnPatRealize       = pxrxPatRealize;
    ppdev->pgfnMonoOffset       = pxrxMonoOffset;
    ppdev->pgfnFillPolygon      = bGlintFastFillPolygon;
    ppdev->pgfnDrawLine         = pxrxDrawLine;
    ppdev->pgfnIntegerLine      = pxrxIntegerLine;
    ppdev->pgfnContinueLine     = pxrxContinueLine;
    ppdev->pgfnInitStrips       = pxrxInitStrips;
    ppdev->pgfnResetStrips      = pxrxResetStrips;
    ppdev->pgfnRepNibbles       = pxrxRepNibbles;

    ppdev->pgfnUpload = pxrxFifoUpload; 

    // add any depth-specific function overrides here
    switch( ppdev->cPelSize ) 
    {
        case GLINTDEPTH32:
            ppdev->pgfnFillSolid    = p3r3FillSolid32bpp;
            ppdev->pgfnFillPatColor = p3r3FillPatColor32bpp;
            ppdev->pgfnFillPatMono  = p3r3FillPatMono32bpp;
        break;

        case GLINTDEPTH16:
            // this specialization seems to give the same 
            // performance as the generic color pattern fill
            //ppdev->pgfnFillPatColor   = p3r3FillPatColor16bpp;
        break;

        case GLINTDEPTH8:
            ppdev->pgfnFillSolid    = p3r3FillSolidVariableSpans;
            ppdev->pgfnFillPatColor = p3r3FillPatColorVariableSpans;
        break;
    }

    ppdev->pgfnCopyXferImage    = NULL; 
    ppdev->pgfnCopyXfer24bpp    = pxrxCopyXfer24bpp;
    ppdev->pgfnCopyXfer4bpp     = NULL;
    if( (glintInfo->pxrxFlags & (PXRX_FLAGS_PATCHING_FRONT | PXRX_FLAGS_PATCHING_BACK)) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ||
        glintInfo->GdiCantAccessFramebuffer ||
        ((ppdev->cPelSize != GLINTDEPTH16) && (ppdev->cPelSize != 
        GLINTDEPTH32)) )
    {
        ppdev->pgfnCopyXfer8bppLge  = pxrxCopyXfer8bppLge;
        ppdev->pgfnCopyXfer8bpp     = pxrxCopyXfer8bppLge;
    } else {
        ppdev->pgfnCopyXfer8bppLge  = pxrxCopyXfer8bppLge;
        ppdev->pgfnCopyXfer8bpp     = vGlintCopyBltBypassDownloadXlate8bpp;
    }

    ppdev->gapfnStrip = &gapfnStripPXRX[0];
}

VOID pxrxCopyBltNative( PPDEV ppdev, RECTL *pRect, LONG count, DWORD logicOp, POINTL *pptlSrc, RECTL *pRectDst )
{
    ULONG   config2D, render2D;
    int     dx, dy;
    GLINT_DECL;

    DISPDBG((7, "pxrxCopyBltNative: (%d, %d) => (%d,%d -> %d,%d) x %d, logicOp = %d, offset = (%d, %d)",
                 pptlSrc->x, pptlSrc->y, pRectDst->left, pRectDst->top, pRectDst->right, pRectDst->bottom,
                 count, logicOp, ppdev->xyOffsetDst & 0xffff, ppdev->xyOffsetDst >> 16));

    ASSERTDD(count > 0, "Can't handle zero rectangles");
    ASSERTDD(logicOp <= 15, "Weird hardware Rop");

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 7 + 3 );

    config2D = config2D_NativeBlt[logicOp];
    render2D = render2D_NativeBlt[logicOp] | __RENDER2D_OP_PATCHORDER;

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    dx = pptlSrc->x - pRectDst->left;
    dy = pptlSrc->y - pRectDst->top;

    if(ppdev->DstPixelOrigin == ppdev->SrcPixelOrigin)
    {
        if( dy >= 0 )
            render2D |= __RENDER2D_INCY;

        if( dx >= 0 )
            render2D |= __RENDER2D_INCX;
        // source and dest are part of the same surface
        if( (dy == 0) && (dx > -64) && (dx < 64) )
                config2D |= __CONFIG2D_FBBLOCKING;
    }

    LOAD_FBSOURCE_ADDR( ppdev->SrcPixelOrigin );
    LOAD_FBSOURCE_OFFSET_XY( dx + ppdev->xOffset, dy + (ppdev->xyOffsetSrc >> 16) );
    LOAD_FBSOURCE_WIDTH( ppdev->SrcPixelDelta );
    LOAD_CONFIG2D( config2D );

    DISPDBG((8, "offset: (%d, %d) -> (%d, %d), d = (%d, %d), %cve X, %cve Y", pptlSrc->x, pptlSrc->y, pRectDst->left, pRectDst->top,
             dx, dy, (render2D & __RENDER2D_INCX) ? '+' : '-', (render2D & __RENDER2D_INCY) ? '+' : '-'));

    while( 1 ) {
        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);

        DISPDBG((8, "dest rect: (%d, %d -> %d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        QUEUE_PXRX_DMA_INDEX2( __GlintTagFillRectanglePosition, __GlintTagFillRender2D );
        QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_DWORD( render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if( !(--count) )
            break;

        ++pRect;

        WAIT_PXRX_DMA_DWORDS( 3 );
    }

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxFillSolid( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    DWORD   config2D, render2D;
    ULONG   ulColor = rbc.iSolidColor;
    GLINT_DECL;

    DISPDBG((7, "pxrxFillSolid: %d rects, logicOp = %d, colour = 0x%08X", count, logicOp, rbc.iSolidColor));

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    config2D = config2D_FillSolid[logicOp];
    render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    LOAD_FOREGROUNDCOLOUR( ulColor );
    LOAD_CONFIG2D( config2D );

    while( 1 ) {
        DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if( !(--count) )
            break;

        ++pRect;

        WAIT_PXRX_DMA_TAGS( 2 );
    }
    
    SEND_PXRX_DMA_BATCH;
}

VOID p3r3FillSolidVariableSpans( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    DWORD   config2D, render2D;
    ULONG   ulColor = rbc.iSolidColor;
    GLINT_DECL;

    DISPDBG((7, "p3r3FillSolidVariableSpans: %d rects, logicOp = %d, colour = 0x%08X", count, logicOp, rbc.iSolidColor));

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    config2D = config2D_FillSolidVariableSpans[logicOp];
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    LOAD_FOREGROUNDCOLOUR( ulColor );
    LOAD_CONFIG2D( config2D );

    while( 1 ) {
        DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if( !(--count) )
            break;

        ++pRect;

        WAIT_PXRX_DMA_TAGS( 2 );
    }

    SEND_PXRX_DMA_BATCH;
}

VOID p3r3FillSolid32bpp( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    DWORD   config2D, render2D;
    ULONG   ulColor = rbc.iSolidColor, left;
    GLINT_DECL;

    config2D = config2D_FillSolid32bpp[logicOp];
    render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

    if(OFFSCREEN_LIN_DST(ppdev) && (config2D & __CONFIG2D_USERSCISSOR))
    {
        // When filling linear DFBs we can't use the scissor and align to a 32 pixel boundary in x because
        // the coords aren't aligned to a scanline boundary in x. NB. Rectangular DFBs coords in x are always
        // relative to the start of a scanline so the scissor alignment works.
        p3r3FillSolidVariableSpans(ppdev, count, pRect, logicOp, bgLogicOp, rbc, pptlBrush);
        return;
    }

    DISPDBG((7, "p3r3FillSolid32bpp: %d rects, logicOp = %d, colour = 0x%08X", count, logicOp, rbc.iSolidColor));

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    LOAD_FOREGROUNDCOLOUR( ulColor );
    LOAD_CONFIG2D( config2D );

    if( config2D & __CONFIG2D_USERSCISSOR ) {
        while( 1 ) {
            left = pRect->left & ~31;

            DISPDBG((8, "rect: (%d:%d, %d) to (%d, %d)", pRect->left, left, pRect->top, pRect->right, pRect->bottom));

            render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
            render2D |= __RENDER2D_WIDTH(pRect->right - left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);

            QUEUE_PXRX_DMA_INDEX3( __GlintTagFillScissorMinXY, __GlintTagFillRectanglePosition, __GlintTagFillRender2D );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(pRect->left ,      0) );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(left, pRect->top) );
            QUEUE_PXRX_DMA_DWORD( render2D );

            FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

            if( !(--count) )
                break;

            ++pRect;

            WAIT_PXRX_DMA_DWORDS( 5 );
        }
    } else {
        while( 1 ) {

            DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

            render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
            render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
            QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
            QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

            FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

            if( !(--count) )
                break;

            ++pRect;

            WAIT_PXRX_DMA_TAGS( 2 );
        }
    }

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxFillPatMono( PPDEV ppdev, LONG count, RECTL *pRect, ULONG fgLogicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    BRUSHENTRY  *pbe;
    ULONG       fgColor, bgColor;
    DWORD       config2D, render2D;
    LONG        c;
    GLINT_DECL;

    DISPDBG((7, "pxrxFillPatMono: %d rects. fgLogicOp = %d, bgLogicop %d", count, fgLogicOp, bgLogicOp));

    // if anything has changed with the brush we must re-realize it. If the brush
    // has been kicked out of the area stipple unit we must fully realize it. If
    // only the alignment has changed we can simply update the alignment for the
    // stipple.
    //
    pbe = rbc.prb->apbe;
    if( (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "full brush realise"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, pptlBrush);
    }
    else if( (rbc.prb->ptlBrushOrg.x != pptlBrush->x) ||
             (rbc.prb->ptlBrushOrg.y != pptlBrush->y) ) {
        DISPDBG((8, "changing brush offset"));
        (*ppdev->pgfnMonoOffset)(ppdev, rbc.prb, pptlBrush);
    }

    fgColor = rbc.prb->ulForeColor;
    bgColor = rbc.prb->ulBackColor;
    DISPDBG((8, "fgColor 0x%x, bgColor 0x%x", fgColor, bgColor));

    // we get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.

    if( ((fgLogicOp == __GLINT_LOGICOP_AND) && (fgColor == ppdev->ulWhite))
        || ((fgLogicOp == __GLINT_LOGICOP_OR ) && (fgColor == 0))
        || ((fgLogicOp == __GLINT_LOGICOP_XOR) && (fgColor == 0)) )
            fgLogicOp = __GLINT_LOGICOP_NOOP;

    // same for background
    if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite))
        || ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))
        || ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0)) )
            bgLogicOp = __GLINT_LOGICOP_NOOP;

    if( (fgLogicOp == __GLINT_LOGICOP_NOOP) && (bgLogicOp == __GLINT_LOGICOP_NOOP) ) {
        DISPDBG((8, "both ops are no-op so lets quit now"));
        return;
    }

    config2D = __CONFIG2D_CONSTANTSRC | __CONFIG2D_FBWRITE;
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_AREASTIPPLE | __RENDER2D_OP_PATCHORDER;
    
    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 9 + 2 );

    if( (fgLogicOp != __GLINT_LOGICOP_COPY) || (bgLogicOp != __GLINT_LOGICOP_NOOP) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ) {
        config2D |= __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_LOGOP_BACK(bgLogicOp);
        render2D |= __RENDER2D_SPANS;
    } else {
        LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
        LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
        LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
    }

    if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) {
        config2D |= __CONFIG2D_FBDESTREAD;
        SET_READ_BUFFERS;
    }

    if( LogicOpReadSrc[fgLogicOp] )
        LOAD_FOREGROUNDCOLOUR( fgColor );
    if( LogicOpReadSrc[bgLogicOp] )
        LOAD_BACKGROUNDCOLOUR( bgColor );

    LOAD_CONFIG2D( config2D );

    c = count;
    while( TRUE ) {
        DISPDBG((8, "mono pattern fill to rect (%d,%d) to (%d,%d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top) );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if (--c == 0)
            break;

        pRect++;
        WAIT_PXRX_DMA_TAGS( 2 );
    }

    SEND_PXRX_DMA_BATCH;

    DISPDBG((7, "pxrxFillPatMono returning"));
}

VOID p3r3FillPatMonoVariableSpans( PPDEV ppdev, LONG count, RECTL *pRect, ULONG fgLogicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    BRUSHENTRY  *pbe;
    ULONG       fgColor, bgColor;
    DWORD       config2D, render2D;
    LONG        c;
    GLINT_DECL;

    DISPDBG((7, "p3r3FillPatMonoVariableSpans: %d rects. fgLogicOp = %d, bgLogicop %d", count, fgLogicOp, bgLogicOp));

    // if anything has changed with the brush we must re-realize it. If the brush
    // has been kicked out of the area stipple unit we must fully realize it. If
    // only the alignment has changed we can simply update the alignment for the
    // stipple.
    //
    pbe = rbc.prb->apbe;
    if( (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "full brush realise"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, pptlBrush);
    }
    else if( (rbc.prb->ptlBrushOrg.x != pptlBrush->x) ||
             (rbc.prb->ptlBrushOrg.y != pptlBrush->y) ) {
        DISPDBG((8, "changing brush offset"));
        (*ppdev->pgfnMonoOffset)(ppdev, rbc.prb, pptlBrush);
    }

    fgColor = rbc.prb->ulForeColor;
    bgColor = rbc.prb->ulBackColor;
    DISPDBG((8, "fgColor 0x%x, bgColor 0x%x", fgColor, bgColor));

    // we get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.

    if( ((fgLogicOp == __GLINT_LOGICOP_AND) && (fgColor == ppdev->ulWhite))
        || ((fgLogicOp == __GLINT_LOGICOP_OR ) && (fgColor == 0))
        || ((fgLogicOp == __GLINT_LOGICOP_XOR) && (fgColor == 0)) )
            fgLogicOp = __GLINT_LOGICOP_NOOP;

    // same for background
    if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite))
        || ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))
        || ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0)) )
            bgLogicOp = __GLINT_LOGICOP_NOOP;

    if( (fgLogicOp == __GLINT_LOGICOP_NOOP) && (bgLogicOp == __GLINT_LOGICOP_NOOP) ) {
        DISPDBG((8, "both ops are no-op so lets quit now"));
        return;
    }

    config2D = __CONFIG2D_CONSTANTSRC | __CONFIG2D_FBWRITE;
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_AREASTIPPLE | __RENDER2D_OP_PATCHORDER;
    
    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 7 + 2 );

    config2D |= __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_LOGOP_BACK(bgLogicOp);

    if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) {
        config2D |= __CONFIG2D_FBDESTREAD;
        SET_READ_BUFFERS;
    }

    if( LogicOpReadSrc[fgLogicOp] )
        LOAD_FOREGROUNDCOLOUR( fgColor );
    if( LogicOpReadSrc[bgLogicOp] )
        LOAD_BACKGROUNDCOLOUR( bgColor );

    LOAD_CONFIG2D( config2D );

    c = count;
    while( TRUE ) {
        DISPDBG((8, "mono pattern fill to rect (%d,%d) to (%d,%d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top) );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        if (--c == 0)
            break;

        pRect++;
        WAIT_PXRX_DMA_TAGS( 2 );
    }
    
    SEND_PXRX_DMA_BATCH;

    DISPDBG((7, "p3r3FillPatMonoVariableSpans returning"));
}

VOID p3r3FillPatMono32bpp( PPDEV ppdev, LONG count, RECTL *pRect, ULONG fgLogicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush )
{
    BRUSHENTRY  *pbe;
    ULONG       fgColor, bgColor;
    DWORD       config2D, render2D;
    LONG        c, left;
    GLINT_DECL;

    DISPDBG((7, "p3r3FillPatMono32bpp: %d rects. fgLogicOp = %d, bgLogicop %d", count, fgLogicOp, bgLogicOp));

    // if anything has changed with the brush we must re-realize it. If the brush
    // has been kicked out of the area stipple unit we must fully realize it. If
    // only the alignment has changed we can simply update the alignment for the
    // stipple.
    //
    pbe = rbc.prb->apbe;
    if( (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "full brush realise"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, pptlBrush);
    }
    else if( (rbc.prb->ptlBrushOrg.x != pptlBrush->x) ||
             (rbc.prb->ptlBrushOrg.y != pptlBrush->y) ) {
        DISPDBG((8, "changing brush offset"));
        (*ppdev->pgfnMonoOffset)(ppdev, rbc.prb, pptlBrush);
    }

    fgColor = rbc.prb->ulForeColor;
    bgColor = rbc.prb->ulBackColor;
    DISPDBG((8, "fgColor 0x%x, bgColor 0x%x", fgColor, bgColor));

    // we get some common operations which are really noops. we can save
    // lots of time by cutting these out. As this happens a lot for masking
    // operations it's worth doing.

    if( ((fgLogicOp == __GLINT_LOGICOP_AND) && (fgColor == ppdev->ulWhite))
        || ((fgLogicOp == __GLINT_LOGICOP_OR ) && (fgColor == 0))
        || ((fgLogicOp == __GLINT_LOGICOP_XOR) && (fgColor == 0)) )
            fgLogicOp = __GLINT_LOGICOP_NOOP;

    // same for background
    if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite))
        || ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))
        || ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0)) )
            bgLogicOp = __GLINT_LOGICOP_NOOP;

    if( (fgLogicOp == __GLINT_LOGICOP_NOOP) && (bgLogicOp == __GLINT_LOGICOP_NOOP) ) {
        DISPDBG((8, "both ops are no-op so lets quit now"));
        return;
    }

    config2D = __CONFIG2D_CONSTANTSRC | __CONFIG2D_FBWRITE;
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_AREASTIPPLE | __RENDER2D_OP_PATCHORDER;
    
    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 9 + 3 );

    if( (fgLogicOp != __GLINT_LOGICOP_COPY) || (bgLogicOp != __GLINT_LOGICOP_NOOP) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING)  ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ||
        OFFSCREEN_LIN_DST(ppdev)) {
        config2D |= __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_LOGOP_BACK(bgLogicOp);
        render2D |= __RENDER2D_SPANS;
    } else {
        config2D |= __CONFIG2D_USERSCISSOR;
        LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
        LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
        LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
    }

    if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) {
        config2D |= __CONFIG2D_FBDESTREAD;
        SET_READ_BUFFERS;
    }

    if( LogicOpReadSrc[fgLogicOp] )
        LOAD_FOREGROUNDCOLOUR( fgColor );
    if( LogicOpReadSrc[bgLogicOp] )
        LOAD_BACKGROUNDCOLOUR( bgColor );

    LOAD_CONFIG2D( config2D );

    c = count;
    if( config2D & __CONFIG2D_USERSCISSOR ) {
        while( TRUE ) {
            left = pRect->left & ~31;

            DISPDBG((8, "rect: (%d:%d, %d) to (%d, %d)", pRect->left, left, pRect->top, pRect->right, pRect->bottom));

            QUEUE_PXRX_DMA_INDEX3( __GlintTagFillScissorMinXY, __GlintTagFillRectanglePosition, __GlintTagFillRender2D );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(pRect->left ,      0) );
            QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(left, pRect->top) );
            QUEUE_PXRX_DMA_DWORD( render2D | __RENDER2D_WIDTH(pRect->right - left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top) );

            if (--c == 0)
                break;

            pRect++;
            WAIT_PXRX_DMA_DWORDS( 5 );
        }
    } else {
        while( TRUE ) {
            DISPDBG((8, "mono pattern fill to rect (%d,%d) to (%d,%d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

            QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
            QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D | __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top) );

            FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

            if (--c == 0)
                break;

            pRect++;
            WAIT_PXRX_DMA_TAGS( 2 );
        }
    }
    
    SEND_PXRX_DMA_BATCH;

    DISPDBG((7, "p3r3FillPatMono32bpp returning"));
}

/*
     8 Bpp:
        orgmodeCopy     = 3;
        orgmodeLogic    = 3;
        lmodeCopy       = (1 << 27);
        lmodeLogic      = (1 << 27);

    15 Bpp:
    16 Bpp:
    32 Bpp:
        orgmodeCopy     = 1;
        orgmodeLogic    = 3;
        lmodeCopy       = (1 << 27);
        lmodeLogic      = (1 << 27);

ULONG   orgmodeCopy = 1,            orgmodeLogic = 3;
ULONG     lmodeCopy = (1 << 27),      lmodeLogic = (1 << 27);

ULONG   orgmode;
ULONG   lmode;
*/

VOID pxrxFillPatColor( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush ) {
    BRUSHENTRY  *pbe;
    DWORD       config2D, render2D;
    LONG        index = 0, i;
    ULONG       *pulBrush;
    ULONG       cRows, cCols;
    POINTL      brushOrg;
    GLINT_DECL;

    DISPDBG((7, "pxrxFillPatColor: %d rects, logicOp = %d, brush = 0x%08X", count, logicOp, rbc.prb));

    // Determine the brush origin:
    brushOrg = *pptlBrush;
    if( (logicOp == __GLINT_LOGICOP_COPY) && (ppdev->cPelSize != 0) )
        brushOrg.x +=  (8 - (ppdev->xyOffsetDst & 0xFFFF)) & 7;

    // If anything has changed with the brush we must re-realize it.
    pbe = rbc.prb->apbe;
    if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "realising brush"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, &brushOrg);
    } else
    if( (rbc.prb->ptlBrushOrg.x != brushOrg.x) || (rbc.prb->ptlBrushOrg.y != brushOrg.y) ||
        (rbc.prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {
        ULONG   lutMode = glintInfo->lutMode;
        DISPDBG((8, "resetting LUTMode"));

        rbc.prb->ptlBrushOrg.x = brushOrg.x;
        rbc.prb->ptlBrushOrg.y = brushOrg.y;

        DISPDBG((8, "setting new LUT brush origin to (%d, %d)", rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));

        lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));
        lutMode |= (1 << 27) | (1 << 8) | (rbc.prb->patternBase << 18) |
                   (((8 - rbc.prb->ptlBrushOrg.x) & 7) << 12) | (((8 - rbc.prb->ptlBrushOrg.y) & 7) << 15);
        WAIT_PXRX_DMA_TAGS( 1 );
        LOAD_LUTMODE( lutMode );
    } else {
        // we're cached already!
        DISPDBG((7, "pxrxFillPatColor: reusing LUT for brush @ %d, origin = (%d,%d)", rbc.prb->patternBase, rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));
    }

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||
        (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ) {
        config2D = config2D_FillColourDual[logicOp];
        render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;    // render2D_FillSolidDual[logicOp]

        if( LogicopReadDest[logicOp] )
            SET_READ_BUFFERS;
    } else {
        config2D = config2D_FillColour[logicOp];
        render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

        if( LogicopReadDest[logicOp] ) {
            SET_READ_BUFFERS;
        }
        else if( logicOp == __GLINT_LOGICOP_COPY ) {
            LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
            LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
            LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
        }
    }

    LOAD_CONFIG2D( config2D );

    while( 1 ) {
        DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        WAIT_PXRX_DMA_TAGS( 2 );

        if( !(--count) )
            break;

        ++pRect;
    }

    // Invalidate the foreground/background colours 'cos the LUT has just corrupted them!
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );
    QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );

    SEND_PXRX_DMA_BATCH;
}

VOID p3r3FillPatColorVariableSpans( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush ) {
    BRUSHENTRY  *pbe;
    DWORD       config2D, render2D;
    LONG        index = 0, i;
    ULONG       *pulBrush;
    ULONG       cRows, cCols;
    POINTL      brushOrg;
    GLINT_DECL;

    DISPDBG((7, "p3r3FillPatColorVariableSpans: %d rects, logicOp = %d, brush = 0x%08X", count, logicOp, rbc.prb));

    // Determine the brush origin:
    brushOrg = *pptlBrush;
    if( (logicOp == __GLINT_LOGICOP_COPY) && (ppdev->cPelSize != 0) )
        brushOrg.x +=  (8 - (ppdev->xyOffsetDst & 0xFFFF)) & 7;

    // If anything has changed with the brush we must re-realize it.
    pbe = rbc.prb->apbe;
    if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "realising brush"));
        (*ppdev->pgfnPatRealize)(ppdev, rbc.prb, &brushOrg);
    } else
    if( (rbc.prb->ptlBrushOrg.x != brushOrg.x) || (rbc.prb->ptlBrushOrg.y != brushOrg.y) ||
        (rbc.prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {
        ULONG   lutMode = glintInfo->lutMode;
        DISPDBG((8, "resetting LUTMode"));

        rbc.prb->ptlBrushOrg.x = brushOrg.x;
        rbc.prb->ptlBrushOrg.y = brushOrg.y;

        DISPDBG((8, "setting new LUT brush origin to (%d, %d)", rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));

        lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));
        lutMode |= (1 << 27) | (1 << 8) | (rbc.prb->patternBase << 18) |
                   (((8 - rbc.prb->ptlBrushOrg.x) & 7) << 12) | (((8 - rbc.prb->ptlBrushOrg.y) & 7) << 15);
        WAIT_PXRX_DMA_TAGS( 1 );
        LOAD_LUTMODE( lutMode );
    } else {
        // we're cached already!
        DISPDBG((7, "p3r3FillPatColorVariableSpans: reusing LUT for brush @ %d, origin = (%d,%d)", rbc.prb->patternBase, rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));
    }

    SET_WRITE_BUFFERS;

    WAIT_PXRX_DMA_TAGS( 5 + 2 );

    config2D = config2D_FillColourDual[logicOp];
    render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;

    if( LogicopReadDest[logicOp] )
        SET_READ_BUFFERS;

    LOAD_CONFIG2D( config2D );

    while( 1 ) {
        DISPDBG((8, "rect: (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        WAIT_PXRX_DMA_TAGS( 2 );

        if( !(--count) )
            break;

        ++pRect;
    }

    // Invalidate the foreground/background colours 'cos the LUT has just corrupted them!
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );
    QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxCacheBrush16bpp(PDEV *ppdev, RBRUSH_COLOR rbc, POINTL *pbrushOrg)
{
    BRUSHENTRY  *pbe;
    GLINT_DECL;

    // If anything has changed with the brush we must re-realize it.
    pbe = rbc.prb->apbe;
    if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "pxrxCacheBrush16bpp: realising brush"));
        ppdev->pgfnPatRealize(ppdev, rbc.prb, pbrushOrg);
    } else
    if( (rbc.prb->ptlBrushOrg.x != pbrushOrg->x) || (rbc.prb->ptlBrushOrg.y != pbrushOrg->y) ||
        (rbc.prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {
        ULONG   lutMode = glintInfo->lutMode;
        DISPDBG((8, "pxrxCacheBrush16bpp: resetting LUTMode"));

        rbc.prb->ptlBrushOrg.x = pbrushOrg->x;
        rbc.prb->ptlBrushOrg.y = pbrushOrg->y;

        DISPDBG((8, "pxrxCacheBrush16bpp: setting new LUT brush origin to (%d, %d)", rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));

        lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));
        lutMode |= (1 << 27) | (1 << 8) | (rbc.prb->patternBase << 18) |
                   (((8 - rbc.prb->ptlBrushOrg.x) & 7) << 12) | (((8 - rbc.prb->ptlBrushOrg.y) & 7) << 15);
        WAIT_PXRX_DMA_TAGS( 1 );
        LOAD_LUTMODE( lutMode );
    } else {
        // we're cached already!
        DISPDBG((7, "pxrxCacheBrush16bpp: reusing LUT for brush @ %d, origin = (%d,%d)", rbc.prb->patternBase, rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));
    }
}

VOID p3r3FillPatColor16bpp( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush ) {
    DWORD       config2D, render2D;
    LONG        cx, cy, i;
    POINTL      brushOrg;
    BOOL        bCoreInitialized = FALSE;
    BOOL        bBypassInitialized = FALSE;
    GLINT_DECL;

    DISPDBG((7, "pxrxFillPatColor16bpp: %d rects, logicOp = %d, brush = 0x%08X", count, logicOp, rbc.prb));

    // Determine the brush origin:
    brushOrg = *pptlBrush;
    if( (logicOp == __GLINT_LOGICOP_COPY) && (ppdev->cPelSize != 0) )
        brushOrg.x +=  (8 - (ppdev->xyOffsetDst & 0xFFFF)) & 7;

    while( 1 ) {
        cx = pRect->right - pRect->left;
        cy = pRect->bottom - pRect->top;

        // render through core
        if(!bCoreInitialized) {
            pxrxCacheBrush16bpp(ppdev, rbc, &brushOrg);

            SET_WRITE_BUFFERS;

            WAIT_PXRX_DMA_TAGS( 5 + 2 );

            if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||
                (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ) {
                config2D = config2D_FillColourDual[logicOp];
                render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;    // render2D_FillSolidDual[logicOp]

                if( LogicopReadDest[logicOp] )
                    SET_READ_BUFFERS;
            } else {
                config2D = config2D_FillColour[logicOp];
                render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

                if( LogicopReadDest[logicOp] ) {
                    SET_READ_BUFFERS;
                }
                else if( logicOp == __GLINT_LOGICOP_COPY ) {
                    LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
                    LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
                    LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
                }
            }

            LOAD_CONFIG2D( config2D );

            bCoreInitialized = TRUE;
        }
        render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
        render2D |= __RENDER2D_WIDTH(pRect->right - pRect->left) | __RENDER2D_HEIGHT(pRect->bottom - pRect->top);
        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

        FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

        WAIT_PXRX_DMA_TAGS( 2 );

        if( !(--count) )
            break;

        ++pRect;
    }

    // Invalidate the foreground/background colours 'cos the LUT has just corrupted them!
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );
    QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxCacheBrush32bpp(PDEV *ppdev, RBRUSH_COLOR rbc, POINTL *pbrushOrg)
{
    BRUSHENTRY  *pbe;
    GLINT_DECL;

    // If anything has changed with the brush we must re-realize it.
    pbe = rbc.prb->apbe;
    if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != rbc.prb) ) {
        DISPDBG((8, "pxrxCacheBrush32bpp: realising brush"));
        ppdev->pgfnPatRealize(ppdev, rbc.prb, pbrushOrg);
    } else
    if( (rbc.prb->ptlBrushOrg.x != pbrushOrg->x) || (rbc.prb->ptlBrushOrg.y != pbrushOrg->y) ||
        (rbc.prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {
        ULONG   lutMode = glintInfo->lutMode;
        DISPDBG((8, "pxrxCacheBrush32bpp: resetting LUTMode"));

        rbc.prb->ptlBrushOrg.x = pbrushOrg->x;
        rbc.prb->ptlBrushOrg.y = pbrushOrg->y;

        DISPDBG((8, "pxrxCacheBrush32bpp: setting new LUT brush origin to (%d, %d)", rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));

        lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));
        lutMode |= (1 << 27) | (1 << 8) | (rbc.prb->patternBase << 18) |
                   (((8 - rbc.prb->ptlBrushOrg.x) & 7) << 12) | (((8 - rbc.prb->ptlBrushOrg.y) & 7) << 15);
        WAIT_PXRX_DMA_TAGS( 1 );
        LOAD_LUTMODE( lutMode );
    } else {
        // we're cached already!
        DISPDBG((7, "pxrxCacheBrush32bpp: reusing LUT for brush @ %d, origin = (%d, %d)", rbc.prb->patternBase, rbc.prb->ptlBrushOrg.x & 7, rbc.prb->ptlBrushOrg.y & 7));
    }
}

VOID p3r3FillPatColor32bpp( PPDEV ppdev, LONG count, RECTL *pRect, ULONG logicOp, ULONG bgLogicOp, RBRUSH_COLOR rbc, POINTL *pptlBrush ) {
    POINTL      brushOrg;
    DWORD       config2D, render2D;
    LONG        cx, cy, i, left;
    BOOL        bCoreInitialized = FALSE;
    BOOL        bBypassInitialized = FALSE;
    GLINT_DECL;

    // Determine the brush origin:
    brushOrg = *pptlBrush;

    DISPDBG((7, "p3r3FillPatColor32bpp: %d rects, logicOp = %d, brush = 0x%08X", count, logicOp, rbc.prb));

    while( 1 ) {
        cx = pRect->right - pRect->left;
        cy = pRect->bottom - pRect->top;

        // render through core
        if(!bCoreInitialized) {
            pxrxCacheBrush32bpp(ppdev, rbc, &brushOrg);
            SET_WRITE_BUFFERS;

            WAIT_PXRX_DMA_TAGS( 5 + 2 );

            if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||
                (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ||
                OFFSCREEN_LIN_DST(ppdev)) {
                config2D = config2D_FillColourDual[logicOp];
                render2D = __RENDER2D_INCX | __RENDER2D_INCY | __RENDER2D_SPANS | __RENDER2D_OP_PATCHORDER;    // render2D_FillSolidDual[logicOp]

                if( LogicopReadDest[logicOp] )
                    SET_READ_BUFFERS;
            } else {
                config2D = config2D_FillColour32bpp[logicOp];
                render2D = render2D_FillSolid[logicOp] | __RENDER2D_OP_PATCHORDER;

                if( LogicopReadDest[logicOp] ) {
                    SET_READ_BUFFERS;
                }
                else if( logicOp == __GLINT_LOGICOP_COPY ) {
                    LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );
                    LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );
                    LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );
                }
            }
            LOAD_CONFIG2D( config2D );

            bCoreInitialized = TRUE;
            if( config2D & __CONFIG2D_USERSCISSOR ) {
                left = pRect->left & ~31;

                DISPDBG((8, "p3r3FillPatColor32bpp: scissor core fill (%d:%d, %d) to (%d, %d)", pRect->left, left, pRect->top, pRect->right, pRect->bottom));

                render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
                render2D |= __RENDER2D_WIDTH(pRect->right - left) | __RENDER2D_HEIGHT(cy);

                QUEUE_PXRX_DMA_INDEX3( __GlintTagFillScissorMinXY, __GlintTagFillRectanglePosition, __GlintTagFillRender2D );
                QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(pRect->left ,    0) );
                QUEUE_PXRX_DMA_DWORD( MAKEDWORD_XY(left,            pRect->top) );
                QUEUE_PXRX_DMA_DWORD( render2D );

                FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

                WAIT_PXRX_DMA_DWORDS( 5 );
            } else {
                DISPDBG((8, "p3r3FillPatColor32bpp: core fill (%d, %d) to (%d, %d)", pRect->left, pRect->top, pRect->right, pRect->bottom));

                render2D &= ~(__RENDER2D_WIDTH_MASK | __RENDER2D_HEIGHT_MASK);
                render2D |= __RENDER2D_WIDTH(cx) | __RENDER2D_HEIGHT(cy);
                QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition,    MAKEDWORD_XY(pRect->left, pRect->top) );
                QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,             render2D );

                FLUSH_PXRX_PATCHED_RENDER2D(pRect->left, pRect->right);

                WAIT_PXRX_DMA_TAGS( 2 );
            }
        }
        if( !(--count) )
            break;

        ++pRect;
    }


    // Invalidate the foreground/background colours 'cos the LUT has just corrupted them!
    WAIT_PXRX_DMA_TAGS( 2 );
    QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );
    QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );

    SEND_PXRX_DMA_BATCH;
}

VOID pxrxMaskCopyBlt( PPDEV ppdev, RECTL *a, LONG b, SURFOBJ *c, POINTL *d, ULONG e, ULONG f, POINTL *g, RECTL *h ) {
    DISPDBG((ERRLVL,"pxrxMaskCopyBlt was called"));
}

VOID pxrxPatRealize( PPDEV ppdev, RBRUSH *prb, POINTL *pptlBrush )
{
    BRUSHENTRY  *pbe;
    LONG        iBrushCache;
    LONG        i;
    DWORD       *pSrc;
    GLINT_DECL;

    DISPDBG((7, "pxrxPatRealize started"));

    pbe = prb->apbe;
    if( prb->fl & RBRUSH_2COLOR ) {
        if( (pbe == NULL) || (pbe->prbVerify != prb) ) {
            // mono brushes are realized into the area stipple unit. For this we
            // have a set of special BRUSHENTRYs, one for each board.
            DISPDBG((8, "loading mono brush into cache"));
            pbe = &ppdev->abeMono;
            pbe->prbVerify           = prb;
            prb->apbe = pbe;
        }
    } else {
        if( ppdev->PalLUTType != LUTCACHE_BRUSH ) {
            // Someone has hijacked the LUT so we need to invalidate it:
            ppdev->PalLUTType = LUTCACHE_BRUSH;

            for( i = 0; i < MAX_P3_BRUSHES; i++ )
                ppdev->abeP3[i].prbVerify = NULL;
        }

        if( (pbe == NULL) || (pbe->prbVerify != prb) ) {
            // colourbrushes are realized into the LUT unit table.
            DISPDBG((8, "loading colour brush into cache"));

            iBrushCache = ppdev->iBrushCacheP3;
            pbe         = &ppdev->abeP3[iBrushCache];

            // Update our links:
            pbe->prbVerify                  = prb;
            prb->apbe        = pbe;
            prb->patternBase    = iBrushCache * (256 / MAX_P3_BRUSHES);        // Should be related to colour depth ???
            DISPDBG((8, "new cache entry allocated for color brush @ entry %d", prb->patternBase));

            iBrushCache++;
            if( iBrushCache >= MAX_P3_BRUSHES )
                iBrushCache = 0;
            ppdev->iBrushCacheP3 = iBrushCache;
        }
    }

    pSrc = &prb->aulPattern[0];

    // we're going to load mono patterns into the area stipple and set the
    // start offset to the brush origin. WARNING: we assume that we are
    // running little endian. I believe this is always true for NT.
    if( prb->fl & RBRUSH_2COLOR ) {

        // this function loads the stipple offset into the hardware. We also call
        // this function on its own if the brush is realized but its offset changes.
        // In that case we don't have to go through a complete realize again.
        (*ppdev->pgfnMonoOffset)(ppdev, prb, pptlBrush);

        DISPDBG((8, "area stipple pattern:"));
        WAIT_PXRX_DMA_DWORDS( 9 );
        QUEUE_PXRX_DMA_INC( __GlintTagAreaStipplePattern0, 8 );
        QUEUE_PXRX_DMA_BUFF( pSrc, 8 );
        SEND_PXRX_DMA_BATCH;

        //for( i = 0; i < 8; ++i, ++pSrc ) {
        //  DISPDBG((8, "\t0x%08x", *pSrc));
        //}

        DISPDBG((7, "area stipple downloaded. pxrxPatRealize done"));
        return;
    } else {
        ULONG   lutMode;

        prb->ptlBrushOrg.x = pptlBrush->x;
        prb->ptlBrushOrg.y = pptlBrush->y;
        lutMode = (1 << 27) | (1 << 8) | (prb->patternBase << 18) |        // SpanOp = 8x8 brush, pattern base, x-offset, y-offset
                (((8 - prb->ptlBrushOrg.x) & 7) << 12) | (((8 - prb->ptlBrushOrg.y) & 7) << 15);

        DISPDBG((8, "setting new LUT brush origin to (%d, %d) @ %d", prb->ptlBrushOrg.x & 7, prb->ptlBrushOrg.y & 7, prb->patternBase));

        switch( ppdev->cPelSize ) {
            case 0:                // 8 bpp
                DISPDBG((8, "LUT pattern (8bpp, 8x8):"));

                WAIT_PXRX_DMA_DWORDS( 4 + 17 );
                LOAD_LUTMODE( lutMode );
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, prb->patternBase );
                QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, 8 * 2 );
                QUEUE_PXRX_DMA_BUFF( pSrc, 8 * 2 );

                //for( i = 0; i < 8; ++i ) {
                //  DISPDBG((8, "\t0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x",
                //             pSrc[0] & 0xFF, (pSrc[0] >> 8) & 0xFF, (pSrc[0] >> 16) & 0xFF, (pSrc[0] >> 24) & 0xFF,
                //             pSrc[1] & 0xFF, (pSrc[1] >> 8) & 0xFF, (pSrc[2] >> 16) & 0xFF, (pSrc[3] >> 24) & 0xFF));
                //  pSrc += 2;
                //}
                SEND_PXRX_DMA_BATCH;

                DISPDBG((7, "LUT downloaded. pxrxPatRealize done"));
            return;

            case 1:                // 16 bpp
                DISPDBG((8, "LUT pattern (16bpp, 8x8):"));

                WAIT_PXRX_DMA_DWORDS( 4 + 33 );
                LOAD_LUTMODE( lutMode );
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, prb->patternBase );
                QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, 8 * 4 );
                QUEUE_PXRX_DMA_BUFF( pSrc, 8 * 4 );

                //for( i = 0; i < 8; ++i ) {
                //  DISPDBG((8, "\t0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x",
                //             pSrc[0] & 0xFFFF, pSrc[0] >> 16, pSrc[1] & 0xFFFF, pSrc[1] >> 16,
                //             pSrc[2] & 0xFFFF, pSrc[2] >> 16, pSrc[3] & 0xFFFF, pSrc[3] >> 16));
                //  pSrc += 4;
                //}
                SEND_PXRX_DMA_BATCH;

                DISPDBG((7, "LUT downloaded. pxrxPatRealize done"));
            return;

            case 2:                // 32 bpp
                DISPDBG((8, "LUT pattern (32bpp, 8x8):"));

                WAIT_PXRX_DMA_DWORDS( 4 + 65 );
                LOAD_LUTMODE( lutMode );
                QUEUE_PXRX_DMA_TAG( __PXRXTagLUTIndex, prb->patternBase );
                QUEUE_PXRX_DMA_HOLD( __PXRXTagLUTData, 8 * 8 );
                QUEUE_PXRX_DMA_BUFF( pSrc, 8 * 8 );

                //for( i = 0; i < 8; ++i ) {
                //  DISPDBG((8, "\t0x%06x, 0x%06x, 0x%06x, 0x%06x, 0x%06x, 0x%06x, 0x%06x, 0x%06x",
                //             pSrc[0], pSrc[1], pSrc[2], pSrc[3], pSrc[4], pSrc[5], pSrc[6], pSrc[7]));
                //  pSrc += 8;
                //}
                SEND_PXRX_DMA_BATCH;

                DISPDBG((7, "LUT downloaded. pxrxPatRealize done"));
            return;
        }
    }

    DISPDBG((-1, "pxrxPatRealize: Failed to realize brush!"));
}

VOID pxrxMonoOffset( PPDEV ppdev, RBRUSH *prb, POINTL *pptlBrush )
{
    DWORD   mode;
    GLINT_DECL;

    DISPDBG((7, "pxrxMonoOffset started"));
    // construct the AreaStippleMode value. It contains the pattern size,
    // the offset for the brush origin and the enable bit. Remember the
    // offset so we can later check if it changes and update the hardware.
    // Remember the mode so we can do a mirrored stipple easily.
    prb->ptlBrushOrg.x = pptlBrush->x;
    prb->ptlBrushOrg.y = pptlBrush->y;
    mode =  __PERMEDIA_ENABLE |
            AREA_STIPPLE_XSEL(__GLINT_AREA_STIPPLE_32_PIXEL_PATTERN) |
            AREA_STIPPLE_YSEL(__GLINT_AREA_STIPPLE_8_PIXEL_PATTERN) |
            AREA_STIPPLE_MIRROR_X |
            AREA_STIPPLE_XOFF(8 - (prb->ptlBrushOrg.x & 7)) |
            AREA_STIPPLE_YOFF(8 - (prb->ptlBrushOrg.y & 7));
    if( glintInfo->config2D & __CONFIG2D_OPAQUESPANS )
        mode |= (1 << 20);
    prb->areaStippleMode = mode;

    DISPDBG((8, "setting new area stipple offset to %d, %d",
                    8 - (prb->ptlBrushOrg.x & 7),
                    8 - (prb->ptlBrushOrg.y & 7)));

    WAIT_PXRX_DMA_TAGS( 1 );
    QUEUE_PXRX_DMA_TAG( __GlintTagAreaStippleMode, mode );
//  SEND_PXRX_DMA_BATCH;
    DISPDBG((7, "pxrxMonoOffset done"));
}

VOID pxrxRepNibbles( PPDEV ppdev, RECTL *a, CLIPOBJ *b ) {
    DISPDBG((ERRLVL,"pxrxRepNibbles was called"));
}


#if PXRX_DMA_BUFFER_CHECK
void checkPXRXdmaValidBuffer( PPDEV ppdev, GlintDataPtr glintInfo, ULONG type, ULONG count ) {
    ULONG   *ptr, origCount = count, failure = FALSE;

    if(!inPxRxContextSwitch && (*ppdev->pCurrentCtxt != glintInfo->ddCtxtId))
    {
        DISPDBG((-1000, "CHECK_PXRX_DMA_VALIDITY: ERROR - not in 2D context!!!" ));
        return;
    }

    ASSERTDD( (gi_pxrxDMA.NTbuff == 0) || (gi_pxrxDMA.NTbuff == 1), "CHECK_PXRX_DMA_VALIDITY failed for NTbuff!");

    /*
          0k -  16k = 16k = protection zone 0          pxrxDMA.bufferBase
         16k -  56k = 40k = buffer 0 (40k)          gi_pxrxDMA.DMAaddrL[0]
         56k -  72k = 16k = protection zone 1       gi_pxrxDMA.DMAaddrEndL[0]
         72k - 112k = 40k = buffer 1                gi_pxrxDMA.DMAaddrL[1]
        112k - 128k = 16k = protection zone 2       gi_pxrxDMA.DMAaddrEndL[1]
                                                       pxrxDMA.bufferTop
    */

//  DISPDBG((-1, "0x%08X - 0x%08X = 0x%08X ?=? 0x%08X", gi_pxrxDMA.DMAaddrL[0],    pxrxDMA_bufferBase    , (gi_pxrxDMA.DMAaddrL[0] -    pxrxDMA_bufferBase    ), PXRX_DMA_BUFFER_CHECK_SIZE));
//  DISPDBG((-1, "0x%08X - 0x%08X = 0x%08X ?=? 0x%08X", gi_pxrxDMA.DMAaddrL[1], gi_pxrxDMA.DMAaddrEndL[0], (gi_pxrxDMA.DMAaddrL[1] - gi_pxrxDMA.DMAaddrEndL[0]), PXRX_DMA_BUFFER_CHECK_SIZE));
//  DISPDBG((-1, "0x%08X - 0x%08X = 0x%08X ?=? 0x%08X",    pxrxDMA_bufferTop  , gi_pxrxDMA.DMAaddrEndL[1], (   pxrxDMA_bufferTop   - gi_pxrxDMA.DMAaddrEndL[1]), PXRX_DMA_BUFFER_CHECK_SIZE));

    // start0 - base == bufferSize
    if( (gi_pxrxDMA.DMAaddrL[0] - glintInfo->pxrxDMA_bufferBase) != (PXRX_DMA_BUFFER_CHECK_SIZE) ) {
        DISPDBG((-1000, "CHECK_BUFF failed on protection zone 0's size! (%d vs %d)",
                 gi_pxrxDMA.DMAaddrL[0] - glintInfo->pxrxDMA_bufferBase, PXRX_DMA_BUFFER_CHECK_SIZE));
        DebugBreak();
    }
    // start1 - end0 == bufferSize
    if( (gi_pxrxDMA.DMAaddrL[1] - gi_pxrxDMA.DMAaddrEndL[0]) != (PXRX_DMA_BUFFER_CHECK_SIZE) ) {
        DISPDBG((-1000, "CHECK_BUFF failed on protection zone 1's size! (%d vs %d)",
                 gi_pxrxDMA.DMAaddrL[1] - gi_pxrxDMA.DMAaddrEndL[0], PXRX_DMA_BUFFER_CHECK_SIZE));
        DebugBreak();
    }
    // top - end1 == bufferSize
    if( (glintInfo->pxrxDMA_bufferTop - gi_pxrxDMA.DMAaddrEndL[1]) != (PXRX_DMA_BUFFER_CHECK_SIZE) ) {
        DISPDBG((-1000, "CHECK_BUFF failed on protection zone 2's size! (%d vs %d)",
                 glintInfo->pxrxDMA_bufferTop - gi_pxrxDMA.DMAaddrEndL[1], PXRX_DMA_BUFFER_CHECK_SIZE));
        DebugBreak();
    }

    // end0 - start0 == end1 - start1
    if( (gi_pxrxDMA.DMAaddrEndL[0] - gi_pxrxDMA.DMAaddrL[0]) != (gi_pxrxDMA.DMAaddrEndL[1] - gi_pxrxDMA.DMAaddrL[1]) ) {
        DISPDBG((-1000, "CHECK_BUFF failed on buffer sizes! (%d vs %d)",
                 gi_pxrxDMA.DMAaddrEndL[0] - gi_pxrxDMA.DMAaddrL[0], gi_pxrxDMA.DMAaddrEndL[1] - gi_pxrxDMA.DMAaddrL[1]));
        DebugBreak();
    }

    // (start0 <= NTptr <= end0) || (start1 <= NTptr <= end1)
    if( ((gi_pxrxDMA.NTptr < gi_pxrxDMA.DMAaddrL[0]) || (gi_pxrxDMA.NTptr > gi_pxrxDMA.DMAaddrEndL[0])) &&
        ((gi_pxrxDMA.NTptr < gi_pxrxDMA.DMAaddrL[1]) || (gi_pxrxDMA.NTptr > gi_pxrxDMA.DMAaddrEndL[1])) ) {
        DISPDBG((-1000, "CHECK_BUFF failed for NTptr!"));
        DISPDBG((-1000, "    0x%08X: (0x%08X:0x%08X) or (0x%08X:0x%08X)", gi_pxrxDMA.NTptr,
                gi_pxrxDMA.DMAaddrL[0], gi_pxrxDMA.DMAaddrEndL[0],
                gi_pxrxDMA.DMAaddrL[1], gi_pxrxDMA.DMAaddrEndL[1]));
        DebugBreak();
    } else {
        // startCurrent <= NTptr <= endCurrent
        if( (gi_pxrxDMA.NTptr < gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff]) ||
            (gi_pxrxDMA.NTptr > gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]) ) {
            DISPDBG((-1000, "CHECK_BUFF failed for NTptr II!"));
            DISPDBG((-1000, "    0x%08X <= 0x%08X <= 0x%08X",
                    gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff], gi_pxrxDMA.NTptr,
                    gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]));
            DebugBreak();
        }
    }
    // (start0 <= P3ptr <= end0) || (start1 <= P3ptr <= end1)
    if( ((gi_pxrxDMA.P3at < gi_pxrxDMA.DMAaddrL[0]) && (gi_pxrxDMA.P3at > gi_pxrxDMA.DMAaddrEndL[0])) &&
        ((gi_pxrxDMA.P3at < gi_pxrxDMA.DMAaddrL[1]) && (gi_pxrxDMA.P3at > gi_pxrxDMA.DMAaddrEndL[1])) ) {
        DISPDBG((-1000, "CHECK_BUFF failed for P3at!"));
        DISPDBG((-1000, "    0x%08X: (0x%08X:0x%08X) or (0x%08X:0x%08X)", gi_pxrxDMA.P3at,
                gi_pxrxDMA.DMAaddrL[0], gi_pxrxDMA.DMAaddrEndL[0],
                gi_pxrxDMA.DMAaddrL[1], gi_pxrxDMA.DMAaddrEndL[1]));
        DebugBreak();
    }

    // P3at <= NTptr (if in the same buffer)
    if( (gi_pxrxDMA.P3at >= gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff]) && (gi_pxrxDMA.P3at <= gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]) ) {
        if( gi_pxrxDMA.P3at > gi_pxrxDMA.NTptr ) {
            DISPDBG((-1000, "CHECK_BUFF failed for P3at vs NTptr! (0x%08X <= 0x%08X)", gi_pxrxDMA.P3at, gi_pxrxDMA.NTptr));
            DebugBreak();
        }
    }
    // NTptr <= NTwait 
    if( gi_pxrxDMA.NTptr > glintInfo->NTwait ) {
        DISPDBG((-1000, "CHECK_BUFF failed for NTptr vs NTwait! (0x%08X <= 0x%08X)", gi_pxrxDMA.NTptr, glintInfo->NTwait));
        DebugBreak();
    }

//@@BEGIN_DDKSPLIT
//AZN
// Here we have a FI AV when glintInfo->pxrxDMA_bufferBase != NULL but points
// to invalid memory!
//@@END_DDKSPLIT
    // Protection zone 0: should be filled with (addr & 0x0FFFFFF0)
    for( ptr = glintInfo->pxrxDMA_bufferBase; ptr < gi_pxrxDMA.DMAaddrL[0]; ptr++ ) {
        ASSERTDBG(*ptr == (((ULONG_PTR) ptr) & 0x0FFFFFF0), (-1000, 
                               "CHECK_BUFF failed on protection zone 0: 0x%08X vs 0x%08X!", 
                                ((ULONG_PTR) ptr) & 0x0FFFFFF0, *ptr));
        //if( ptr > glintInfo->pxrxDMA_bufferBase + 40 )        break;
    }

    // Protection zone 1: should be filled with (addr & 0x0FFFFFF0)
    for( ptr = gi_pxrxDMA.DMAaddrEndL[0]; ptr < gi_pxrxDMA.DMAaddrL[1]; ptr++ ) {
        ASSERTDBG(*ptr == (((ULONG_PTR) ptr) & 0x0FFFFFF0), (-1000, 
                                "CHECK_BUFF failed on protection zone 1: 0x%08X vs 0x%08X!", 
                                ((ULONG_PTR) ptr) & 0x0FFFFFF0, *ptr));
        //if( ptr > gi_pxrxDMA.DMAaddrEndL[0] + 40 )        break;
    }

    // Protection zone 2: should be filled with (addr & 0x0FFFFFF0)
    for( ptr = gi_pxrxDMA.DMAaddrEndL[1]; ptr < glintInfo->pxrxDMA_bufferTop; ptr++ ) {
        ASSERTDBG(*ptr == (((ULONG_PTR) ptr) & 0x0FFFFFF0), (-1000, 
                                "CHECK_BUFF failed on protection zone 2: 0x%08X vs 0x%08X!", 
                                ((ULONG_PTR) ptr) & 0x0FFFFFF0, *ptr));
        //if( ptr > gi_pxrxDMA.DMAaddrEndL[1] + 40 )        break;
    }

    switch( type ) {
        case CHECK_QUEUE:
            // Check that each dword contains 0x12345678:
            while( count-- ) {
                ptr = gi_pxrxDMA.NTptr + count;
                if( *ptr != 0x12345678 ) {
                    DISPDBG((-1000, "CHECK_QUEUE failed: 0x%08X vs 0x12345678 @ 0x%08X!", *ptr, ptr));
                    failure = TRUE;
                }
            }
        break;

        case CHECK_WAIT:
            // Check that each dword contains its address...
            // Then replace it with 0x12345678:

            while( count-- ) {
                ptr = gi_pxrxDMA.NTptr + count;
                if( (*ptr != (ULONG_PTR) ptr) && (*ptr != 0x12345678) ) {
                    DISPDBG((-1000, "CHECK_WAIT failed: 0x%08X vs 0x%08X @ 0x%08X!", 
                                    *ptr, (ULONG_PTR) ptr, ptr));
                    failure = TRUE;
                }
                *ptr = 0x12345678;
            }
        break;

        case CHECK_SEND:
            // Check that each dword contains neither its address nor 0x12345678:
            for( ptr = (ULONG *) gi_pxrxDMA.P3at; ptr < gi_pxrxDMA.NTptr; ptr++ ) {
                if( *ptr == (ULONG_PTR) ptr ) {
                    DISPDBG((-1000, "CHECK_SEND failed I: 0x%08X is 0x%08X!", ptr, *ptr));
                    failure = TRUE;
                }

                if( *ptr == 0x12345678 ) {
                    DISPDBG((-1000, "CHECK_SEND failed II: 0x%08X is 0x%08X!", ptr, *ptr));
                    failure = TRUE;
                }
            }

            for( ptr = gi_pxrxDMA.NTptr; ptr < gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]; ptr++ ) {
                if( (*ptr != (ULONG_PTR) ptr) && (*ptr != 0x12345678) ) {
                    DISPDBG((-1000, "CHECK_SEND failed III: 0x%08X vs 0x%08X/0x12345678 @ 0x%08X!", *ptr, 
                                    (ULONG_PTR) ptr, ptr));
                    failure = TRUE;
                }

                if( ptr > (gi_pxrxDMA.NTptr + 4) )
                    break;
            }
        break;

        case CHECK_SWITCH:
            // Fill each dword with its address:
            for( ptr = gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff]; ptr < gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff]; ptr++ )
                *ptr = PtrToUlong(ptr);
        break;
    }

    if( failure ) {
        DISPDBG((-1000, "Check failed, count = %d", origCount));
        DebugBreak();
    }

}
#endif


/*******************************************************/
/*** Assorted versions of the SEND_PXRX_DMA 'macro'  ***/
/*** For use with the FAKE_DMA flag to test that DMA ***/
/*** will actually work on all combinations of P3,   ***/
/*** Gamma, & buggy motherboards!                    ***/
/*******************************************************/



/*******************/
/*** FIFO Access ***/
void sendPXRXdmaFIFO( PPDEV ppdev, GlintDataPtr glintInfo ) {
    LONG    count;
    ULONG   *NTptr = gi_pxrxDMA.NTptr;
    ULONG   *P3at = (ULONG *) gi_pxrxDMA.P3at;
    
    CHECK_PXRX_DMA_VALIDITY( CHECK_SEND, 0 );
    
    count = (DWORD)(NTptr - P3at);
    
    DISPDBG((DBGLVL, "SEND_PXRX_DMA:fifo() %d dwords @ %d:0x%08X -> 0x%08X", count, gi_pxrxDMA.NTbuff, P3at, NTptr));

    if( count > 0) {
        volatile ULONG  *dst;
        ULONG           *src, space;

        DISPDBG((DBGLVL, "Sending FIFO tags (0x%08X x %d)", P3at, count));

        src = P3at;
        while( count > 0 ) {
            GET_INPUT_FIFO_SPACE( space );

            // Don't exceed real FIFO size
            space = min (space, glintInfo->MaxInFifoEntries);

            dst = (ULONG *) glintInfo->regs.InFIFOInterface;
            while( space-- && count-- ) {
                MEMORY_BARRIER();
                WRITE_FAST_ULONG( dst, *src );
                MEMORY_BARRIER();
                dst++;
                src++;
            }
        }
    }
    GLINT_CORE_BUSY;

    gi_pxrxDMA.NTdone = NTptr;
    gi_pxrxDMA.P3at   = NTptr;
    DISPDBG((DBGLVL, "Sent PXRX DMA"));
}

void switchPXRXdmaBufferFIFO( PPDEV ppdev, GlintDataPtr glintInfo ) {
    TEMP_MACRO_VARS;

    DISPDBG((DBGLVL, "SWITCH_PXRX_DMA_BUFFER() from %d:0x%08X", gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr));    

    /* Close the old buffer and post it     */
    SEND_PXRX_DMA_FORCE;

    /* Switch to the new buffer             */
    gi_pxrxDMA.NTbuff = !gi_pxrxDMA.NTbuff;

    /* Ensure that the new buffer is empty  */
    //WAIT_PXRX_DMA_COMPLETED_BUFFER;    // Not needed when running through FIFOs.

    /* Start using the new buffer           */
    gi_pxrxDMA.NTptr  = gi_pxrxDMA.DMAaddrL[gi_pxrxDMA.NTbuff];
    gi_pxrxDMA.P3at   = gi_pxrxDMA.NTptr;
#if PXRX_DMA_BUFFER_CHECK
    glintInfo->NTwait = gi_pxrxDMA.NTptr;
#endif
    DISPDBG((DBGLVL, "SWITCH_PXRX_DMA_BUFFER() to %d:0x%08X", gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr));

    CHECK_PXRX_DMA_VALIDITY( CHECK_SWITCH, 0 );
}

void waitPXRXdmaCompletedBufferFIFO( PPDEV ppdev, GlintDataPtr glintInfo ) {
    ASSERTDD(FALSE,"waitPXRXdmaCompletedBufferFIFO was called!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\stroke.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Stroke.c
*
* Content: DrvStrokePath support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

typedef VOID    (* GAPFNstripFunc)(PPDEV, STRIP*, LINESTATE*);

GAPFNstripFunc  gapfnStripPXRX[] =
{
    vPXRXSolidHorizontalLine,
    vPXRXSolidVerticalLine,
    vPXRXSolidDiagonalHorizontalLine,
    vPXRXSolidDiagonalVerticalLine,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vPXRXSolidHorizontalLine,
    vPXRXSolidVerticalLine,
    vPXRXSolidDiagonalHorizontalLine,
    vPXRXSolidDiagonalVerticalLine,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vPXRXStyledHorizontalLine,
    vPXRXStyledVerticalLine,
    vPXRXStyledVerticalLine,  // Diagonal goes here
    vPXRXStyledVerticalLine,  // Diagonal goes here

    vPXRXStyledHorizontalLine,
    vPXRXStyledVerticalLine,
    vPXRXStyledVerticalLine,  // Diagonal goes here
    vPXRXStyledVerticalLine,  // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    DSURF*    pdsurf;
    OH*       poh;
    RECTL     arclClip[4];                  // For rectangular clipping
    BOOL      ResetGLINT;                   // Does GLINT need resetting?
    BOOL      bRet;
    DWORD     logicOp;
    GLINT_DECL_VARS;

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB or if Glint Line debugging has been turned off.

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt & DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

    ppdev = (PDEV*) pso->dhpdev;
    GLINT_DECL_INIT;

    REMOVE_SWPOINTER(pso);

    DISPDBG((DBGLVL, "Drawing Lines through GLINT"));

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    SETUP_PPDEV_OFFSETS(ppdev, pdsurf);

    fl = 0;

    // Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_ARBITRARYSTYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

        // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_ARBITRARYSTYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    bRet = TRUE;
    apfn = &ppdev->gapfnStrip[NUM_STRIP_DRAW_STYLES * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

    // Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            // This is the only clip region of importance to GLINT
            arclClip[0]        =  pco->rclBounds;

            // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

            // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

            // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        pd.flags = 0;

        // Get the logic op and set up the flag to indicate reads from
        // the frame buffer will occur.
        logicOp = GlintLogicOpsFromR2[mix & 0xff];
        if (LogicopReadDest[logicOp])
            fl |= FL_READ;

        // Need to set up Glint modes and colors appropriately for the lines.

        ResetGLINT = (*ppdev->pgfnInitStrips)(ppdev, pbo->iSolidColor,
                            logicOp, prclClip);

        PATHOBJ_vEnumStart(ppo);

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
            {
                ls.spNext = 0;
            }

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl)) {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl)) {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
            // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

            // Masked styles don't normalize the style state.  It's a good
            // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
            {
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;
            }

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
        // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[FIELD_OFFSET(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

        // Need to set up Glint modes and colors appropriately for the lines.
        // NOTE, with a complex clip, we can not yet use GLINT for fast lines

        ResetGLINT = (*ppdev->pgfnInitStrips)(ppdev, pbo->iSolidColor,
                            GlintLogicOpsFromR2[mix & 0xff], NULL);

        // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }

                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }
        } while (bMore);
    }

ResetReturn:

    if (ResetGLINT)
    {
        (*ppdev->pgfnResetStrips)(ppdev);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrx.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrx.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef PXRX_H
#define PXRX_H

//@@BEGIN_DDKSPLIT
//AZN since these are defines as 0 in the source code, we'll ifdef out the
//    relevant code and later delete it all together
#define USE_RLE_DOWNLOADS       0
#define USE_RLE_UPLOADS         0
//@@END_DDKSPLIT

//@@BEGIN_DDKSPLIT
// AZN don't do on IA64 as IA64 doesn't like this code
//@@END_DDKSPLIT
#if 0 //!defined(_WIN64) && DBG
#   define PXRX_DMA_BUFFER_CHECK            1
//  NB: the size is in dwords...
#   define PXRX_DMA_BUFFER_CHECK_SIZE       4
#endif

enum {
    USE_PXRX_DMA_NONE = 0,
    USE_PXRX_DMA_FIFO,
};

// PxRx structures

typedef struct BypassDMACmd
{
    ULONG   physSysAddr;        // physical address of DMA buffer in system memory, 128 bit aligned
    ULONG   physVidMemAddr;        // physical address of video memory source/dest of transfer, 128 bit aligned
    USHORT  ByteEnableFirst;    // byte enable mask for the first 128 bits
    USHORT  ByteEnableLast;        // byte enable mask for the last 128 bits
    ULONG   Length;                // length of transfer, in 128 bit units
}
BYDMACMD;

#define PXRX_BYPASS_READ_DMA_ACTIVE_BIT     (1 << 22)
#define PXRX_BYPASS_READ_DMA_AGP_BIT        (1 << 23)

//@@BEGIN_DDKSPLIT
/*
    FBDestReadBufferAddr[0] = Frame buffer
    FBDestReadBufferAddr[1] = Scratch 1
    FBDestReadBufferAddr[2] = Scratch 2
    FBDestReadBufferAddr[3] = Scratch 3

    FBDestReadBufferOffset[0] = (x, y) of visible screen
    FBDestReadBufferOffset[1] = ?
    FBDestReadBufferOffset[2] = ?
    FBDestReadBufferOffset[3] = ?


    FBWriteBufferAddr[0] = Frame buffer
    FBWriteBufferAddr[1] = Scratch 1
    FBWriteBufferAddr[2] = Frame buffer (for double writes)
    FBWriteBufferAddr[3] = Scratch 2

    FBWriteBufferOffset[0] = (x, y) of front buffer
    FBWriteBufferOffset[1] = ?
    FBWriteBufferOffset[2] = (x, y) of back buffer
    FBWriteBufferOffset[3] = ?


    FBSourceBufferAddr   = Frame buffer
    FBSourceBufferOffset = Scratch

    NB:
        ScissorMaxXY is assumed to be 0x7FFF7FFF.
        If changed, it must be reset at the end of the primitive.
*/

/*
    DMA transfer schemes:
    ---------------------

    Current DMA method:
        P3 only:
            DMACounts are sent to the input FIFO on a regular basis.
            P3 itself concatenates these into huge DMA buffers thus
            keeping the FIFOs empty and the PCI bus bursting.

        P3 + Gamma:
            Write only the initial DMAAddress + DMACount to the FIFO.
            When the DMA interrupt occurs, write a single address +
            count for all the DMA blocks which have occured in the
            mean time. If non are pending, restart from the beginning.

        P3 + Gamma (non-interrupt):
            Write DMAAddress + DMACount to the input FIFO on a regular
            basis. When the FIFO is full, sit around waiting for it to
            empty.
            This means very limited DMA bursting and no load spreading,
            i.e. fast and slow portions of the rendering will not even
            themselves out. Instead the host and chip will almost be
            running in lockstep.

    Proposed, new improved DMA method:
        P3 only:
            Queue data in DMA buffers.
            SEND_DMA only updates a shared memory buffer end pointer.
            On VBlank, miniport kicks off a DMA up to the current buffer end pointer.
            Exception: if buffer end is too far ahead of buffer start, SEND_DMA will kick of the DMA anyway.
            Problem: how do we know where the buffer start pointer is currently at?

            [buf]Size       = amount of data in buffer
            [buf]Start      = address of first data element in buffer
            [buf]Ptr        = current address of operator within buffer
            [buf]End        = address of last data element in buffer

            buffer          = whole DMA buffer allocated, irrespective of current use
            queued data     = just going into buffer, driver is not yet aware
            pending data    = sitting in buffer, chip is not yet aware
            working data    = chip knows about it and is working its way through

            WAIT for space:
                if( (queuePtr + requiredSpace + 1) > bufferEnd )
                    wrapPoint = queuePtr
                    send queued data to pending data
                    send pending data to working data
                    reset queue
                    reset pending
                    workingStart = bufferStart

                while( (queuePtr + requiredSpace + 1) > queueEnd )
                    wait
                    queueEnd = workingPtr
                    if( queueEnd < bufferStart )
                        queueEnd = wrapPoint - (bufferStart - queueEnd)

            QUEUE data:
                *queuePtr = dataElement
                queuePtr++

            SEND data:
                send queued data to pending data
                if( pendingSize > maxThreshold )        // Too much data is waiting to go
                    send pending data to working data

            VBLANK:
                if( pendingSize > 0 )
                    send pending data to working data

            Queued -> Pending:
                pendingEnd = queuePtr

            Pending -> Working:
                workingExtend   += pendingEnd - pendingStart
                pendingStart     = pendingEnd

            Reset Queue:
                    queuedPtr    = bufferStart

            Reset Pending:
                    pendingStart = bufferStart
                    pendingEnd   = bufferStart


            Notes:
                workingStart    = LoadReg(DMAAddress)
                workingPtr      = ReadReg(DMAAddress), has problems when workingStart is changed
                workingExtend   = LoadReg(DMAContinue)

                wrapPoint       = address of the end of the used buffer (not necessary == bufferEnd)

                assert( (queueEnd + 1) <= workingPtr ) [ always at least '???>->***', never '???>>***']
                    'queueEnd == queuePtr == workingPtr' causes problems of is everything done
                    and dusted or not yet started?

                gaps at the end of the buffer are a problem:
                    the 'workingPtr < bufferStart' case is affected as the actual workingPtr must be
                    determined relative to the end of the used buffer rather than the entire buffer

                workingPtr is cached as queueEnd:
                    reading workingPtr is a slow operation and, moreover, will delay the DMA itself
                    so this is cached to speed up the million and one WAIT calls



            bufferStart       workingPtr         pendingStart     pendingEnd     queuePtr      bufferEnd
                |---------------->********************|++++++++++++++++|?????????????>-------------|


            bufferStart       queuePtr         workingPtr     pendingStart     pendingEnd      bufferEnd
    invalid     |????????????????>------------------>****************|+++++++++++++++|?????????????|
       \/
       \/
       \/   bufferStart                                                                            bufferEnd
        >>>     |????????????????>------------------>*******************************************|##|
    pendingStart/pendingEnd   queuePtr         workingPtr                               wrapPoint


            bufferStart       pendingEnd         queuePtr     workingPtr                           bufferEnd
                |+++++++++++++++++|??????????????????>------------->****************************|##|
           pendingStart                                                                 wrapPoint


            bufferStart       pendingStart         pendingEnd     queuePtr      workingPtr         bufferEnd
    @...........|****************|++++++++++++++++++++|????????????????>------------->**********|##|
workingPtr                                                                              wrapPoint

                                        -        = buffer   [empty space]
                                        *        = working  [owned by the chip]
                                        +        = pending  [owned by the driver]
                                        ?        = working  [owned by the current primitive]
                                        #        = wasted   [skipped over because a primitive did not fit]


    Emergency backup method:
        Do not use DMA, do everything via the input FIFO.


    DMA transfer macros & data storage:
    -----------------------------------

    WAIT_FREE_PXRX_DMA_TAGS(count)      wait for space for count tag/data pair, return the number of free tag/data pair spaces
    WAIT_FREE_PXRX_DMA_DWORDS(count)    wait for space for count dwords,        return the number of free dword spaces
    WAIT_PXRX_DMA_TAGS(count)           wait for space for count tag/data pairs
    WAIT_PXRX_DMA_DWORDS(count)         wait for space for count tag/data

    SEND_PXRX_DMA_FORCE                 Post the current queue to the chip (guarantees to do the send)
    SEND_PXRX_DMA_QUERY                     "        (will only send if the chip is not blocked)
    SEND_PXRX_DMA_BATCH                     "        (will merely batch the data to be sent later)

    QUEUE_PXRX_DMA_TAG(tag, data)       queue a tag/data pair
    QUEUE_PXRX_DMA_HOLD(tag, count)     prepare to queue count dwords as data for held tag
    QUEUE_PXRX_DMA_INC(tag, count)      prepare to queue count dwords as data for incremented tag
    QUEUE_PXRX_DMA_INDEXn(tagN, ...)    prepare to queue n dwords as data for indexed tags
    QUEUE_PXRX_DMA_DWORD(data)          queue a dword
    QUEUE_PXRX_DMA_BUFF(ptr, len)       queue len dwords starting from ptr
    QUEUE_PXRX_DMA_DWORD_DELAYED(ptr)   advance the next free entry one dword, return a pointer the skipped dword

    NTbuff          0 or 1      Buffer NT is currently writing into
    NTptr           address     Next address NT will write to

    P3at            address     Address P3 was last told to read to

    DMAaddrL[2]     lin addr    Linear start address of DMA buffers 0 and 1
    DMAaddrEndL[2]  lin addr    Linear end address of DMA buffers 0 and 1
    DMAaddrP[2]     phys addr   Physical start address of DMA buffers 0 and 1
    DMAaddrEndP[2]  phys addr   Physical end address of DMA buffers 0 and 1

    At start of day:
        NTbuff = 0;
        NTptr = DMAaddrL[NTbuff];
        P3at = NTptr;
        WRITE_PXRX_4KREG( __GlintTagDMAAddress, DMAaddrP[NTbuff] );
*/
//@@END_DDKSPLIT

#define gi_pxrxDMA      (*glintInfo->pxrxDMA)

#define PXRX_DMA_POST_NOW                do{ ; } while(0)

/**********************************/
/*** Macros for assembling tags ***/

#define ASSEMBLE_PXRX_DMA_HOLD(tag, count)        ( (tag) | (((count) - 1) << 16)                )
#define ASSEMBLE_PXRX_DMA_INC(tag, count)        ( (tag) | (((count) - 1) << 16) | (1 << 14)    )

#define PXRX_DMA_INDEX_GROUP(Tag)                                                    ( (Tag & 0xFF0) | (2 << 14) )
#define ASSEMBLE_PXRX_DMA_INDEX2(Tag1, Tag2)                                        ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX3(Tag1, Tag2, Tag3)                                    ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX4(Tag1, Tag2, Tag3, Tag4)                            ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX5(Tag1, Tag2, Tag3, Tag4, Tag5)                        ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) | (1 << ((Tag5 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX6(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6)                ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) | (1 << ((Tag5 & 0xF) + 16)) | (1 << ((Tag6 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX7(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7)            ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) | (1 << ((Tag5 & 0xF) + 16)) | (1 << ((Tag6 & 0xF) + 16)) | (1 << ((Tag7 & 0xF) + 16)) )
#define ASSEMBLE_PXRX_DMA_INDEX8(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7, Tag8)    ( PXRX_DMA_INDEX_GROUP(Tag1) | (1 << ((Tag1 & 0xF) + 16)) | (1 << ((Tag2 & 0xF) + 16)) | (1 << ((Tag3 & 0xF) + 16)) | (1 << ((Tag4 & 0xF) + 16)) | (1 << ((Tag5 & 0xF) + 16)) | (1 << ((Tag6 & 0xF) + 16)) | (1 << ((Tag7 & 0xF) + 16)) | (1 << ((Tag8 & 0xF) + 16)) )

/********************************/
/*** Macros for queueing data ***/

#define NTCON_FAKE_DMA_DWORD(data)        ( data )
#define NTCON_FAKE_DMA_INC(tag, count)    ( ASSEMBLE_PXRX_DMA_INC(tag, count) )
#define NTCON_FAKE_DMA_COPY(buff, size)  do { RtlCopyMemory( gi_pxrxDMA.NTptr, buff, size * sizeof(ULONG) ); } while(0)

/*
    Debug output format:
        'operation( data ) @ <buffer number>:<buffer address> [Q <batch>:<queue>:<wait>]'

    Where:
        batch   = data waiting to be sent to the chip
        queue   = data still being assembled
        wait    = remaining space which has been waited for
*/

#define QUEUE_PXRX_DMA_TAG(tag, data)                                                \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 2);                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_TAG(  %s, 0x%08X) @ %d:0x%08X [Q %d:%d:%d]",    \
                 GET_TAG_STR(tag), data, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,        \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + 2 - gi_pxrxDMA.NTdone,                            \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 2));                        \
        *(gi_pxrxDMA.NTptr) = NTCON_FAKE_DMA_DWORD(tag);                            \
        *(gi_pxrxDMA.NTptr + 1) = NTCON_FAKE_DMA_DWORD(data);                        \
        gi_pxrxDMA.NTptr += 2;                                                        \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_DWORD(data)                                                    \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 1);                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_DWORD(0x%08X) @ %d:0x%08X [Q %d:%d:%d]",    \
                 data, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                            \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + 1 - gi_pxrxDMA.NTdone,                            \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 1));                        \
        *(gi_pxrxDMA.NTptr++) = NTCON_FAKE_DMA_DWORD(data);                            \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_BUFF(buff, size)                                                \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, (size));                                \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_BUFF( 0x%08X + %d) @ %d:0x%08X [Q %d:%d:%d]",    \
                 buff, (size), gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                    \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + size - gi_pxrxDMA.NTdone,                        \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - size));                        \
        NTCON_FAKE_DMA_COPY( buff, (size) );                                        \
        gi_pxrxDMA.NTptr += size;                                                    \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_HOLD(tag, count)                                                \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 1);                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_HOLD( %s x %d) @ %d:0x%08X [Q %d:%d:%d]",    \
                 GET_TAG_STR(tag), count, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,        \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + 1 - gi_pxrxDMA.NTdone,                            \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 1));                        \
        *(gi_pxrxDMA.NTptr++) = ASSEMBLE_PXRX_DMA_HOLD(NTCON_FAKE_DMA_DWORD(tag), count);    \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_INC(tag, count)                                                \
    do {                                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 1);                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_INC(  %s x %d) @ %d:0x%08X [Q %d:%d:%d]",    \
                 GET_TAG_STR(tag), count, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,        \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                                \
                 gi_pxrxDMA.NTptr + 1 - gi_pxrxDMA.NTdone,                            \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 1));                        \
        *(gi_pxrxDMA.NTptr++) = NTCON_FAKE_DMA_INC(tag, count);                        \
        PXRX_DMA_POST_NOW;                                                            \
    } while(0)

#define QUEUE_PXRX_DMA_DWORD_DELAYED(ptr)                                        \
    do {                                                                        \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, 1);                                \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_DELAYED(0x%08X) @ %d:0x%08X [Q %d:%d:%d]",    \
                 gi_pxrxDMA.NTptr, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,            \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                            \
                 gi_pxrxDMA.NTptr + 1 - gi_pxrxDMA.NTdone,                        \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - 1));                    \
        ptr = gi_pxrxDMA.NTptr++;                                                \
    } while(0)

#define QUEUE_PXRX_DMA_BUFF_DELAYED(ptr, size)                                    \
    do {                                                                        \
        CHECK_PXRX_DMA_VALIDITY(CHECK_QUEUE, size);                                \
        ptr = gi_pxrxDMA.NTptr;                                                    \
        DISPDBG((DBGLVL, "QUEUE_PXRX_DMA_BUFF_DELAYED(0x%08X x %d) @ %d:0x%08X [Q %d:%d:%d]",    \
                 ptr, size, gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at,                            \
                 gi_pxrxDMA.NTptr + size - gi_pxrxDMA.NTdone,                    \
                 glintInfo->NTwait - gi_pxrxDMA.NTptr - size));                    \
        gi_pxrxDMA.NTptr += size;                                                \
    } while(0)

#define QUEUE_PXRX_DMA_INDEX2(Tag1, Tag2)                                       do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX2(Tag1, Tag2) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX3(Tag1, Tag2, Tag3)                                 do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX3(Tag1, Tag2, Tag3) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX4(Tag1, Tag2, Tag3, Tag4)                           do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX4(Tag1, Tag2, Tag3, Tag4) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX5(Tag1, Tag2, Tag3, Tag4, Tag5)                     do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX5(Tag1, Tag2, Tag3, Tag4, Tag5) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX6(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6)               do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX6(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX7(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7)         do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX7(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7) ); } while(0)
#define QUEUE_PXRX_DMA_INDEX8(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7, Tag8)   do { QUEUE_PXRX_DMA_DWORD( ASSEMBLE_PXRX_DMA_INDEX8(Tag1, Tag2, Tag3, Tag4, Tag5, Tag6, Tag7, Tag8) ); } while(0)

/*****************************************/
/*** Macros for waiting for free space ***/

#if PXRX_DMA_BUFFER_CHECK
#   define SET_WAIT_POINTER(dwords)     glintInfo->NTwait = gi_pxrxDMA.NTptr + (dwords)
#else
#   define SET_WAIT_POINTER(dwords)
#endif

#define WAIT_PXRX_DMA_TAGS(count)                                                                \
    do {                                                                                        \
        DISPDBG((DBGLVL, "WAIT_PXRX_DMA_TAGS(  %d) %d free @ %d:0x%08X [Q %d:%d]", (count),        \
                 (gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) / 2,            \
                 gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                                            \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at, gi_pxrxDMA.NTptr - gi_pxrxDMA.NTdone));    \
        /* If no room, need to switch buffers */                                                \
        if( (gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) <= ((LONG) (count) * 2) ) {    \
            /* The current buffer is full so switch to a new one    */                            \
            SWITCH_PXRX_DMA_BUFFER;                                                                \
        }                                                                                        \
        ASSERTDD((gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) > ((LONG) (count) * 2), "WAIT_PXRX_DMA_TAGS: run out of space!");    \
        SET_WAIT_POINTER((count) * 2);                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_WAIT, (count) * 2);                                        \
    } while(0)

#define WAIT_PXRX_DMA_DWORDS(count)                                                                \
    do {                                                                                        \
        DISPDBG((DBGLVL, "WAIT_PXRX_DMA_DWORDS(%d) %d free @ %d:0x%08X [Q %d:%d]", (count),        \
                 gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr,                    \
                 gi_pxrxDMA.NTbuff, gi_pxrxDMA.NTptr,                                            \
                 gi_pxrxDMA.NTdone - gi_pxrxDMA.P3at, gi_pxrxDMA.NTptr - gi_pxrxDMA.NTdone));    \
        if( (gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) <= ((LONG) (count)) ) {        \
            /* The current buffer is full so switch to a new one    */                            \
            SWITCH_PXRX_DMA_BUFFER;                                                                \
        }                                                                                        \
        ASSERTDD((gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) > ((LONG) (count)), "WAIT_PXRX_DMA_DWORDS: run out of space!");        \
        SET_WAIT_POINTER(count);                                                                \
        CHECK_PXRX_DMA_VALIDITY(CHECK_WAIT, count);                                                \
    } while(0)

#define WAIT_FREE_PXRX_DMA_TAGS(count)                                                            \
    do {                                                                                        \
        /* Wait for space */                                                                    \
        WAIT_PXRX_DMA_TAGS((count));                                                            \
        /* Return the total free space */                                                        \
        count = (DWORD)((gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr) / 2);   \
        SET_WAIT_POINTER((count) * 2);                                                            \
        CHECK_PXRX_DMA_VALIDITY(CHECK_WAIT, (count) * 2);                                        \
    } while(0)

#define WAIT_FREE_PXRX_DMA_DWORDS(count)                                                        \
    do {                                                                                        \
        /* Wait for space */                                                                    \
        WAIT_PXRX_DMA_DWORDS ((count));                                                            \
        /* Return the total free space */                                                        \
        count = (DWORD)(gi_pxrxDMA.DMAaddrEndL[gi_pxrxDMA.NTbuff] - gi_pxrxDMA.NTptr);                    \
        SET_WAIT_POINTER(count);                                                                \
        CHECK_PXRX_DMA_VALIDITY(CHECK_WAIT, count);                                                \
    } while(0)



/****************************************************/
/*** DMA buffer validity and other error checking ***/
#if PXRX_DMA_BUFFER_CHECK
#   define CHECK_PXRX_DMA_VALIDITY(type, count)     do { checkPXRXdmaValidBuffer(ppdev, glintInfo, type, count); } while(0)
#   define CHECK_QUEUE  0
#   define CHECK_WAIT   1
#   define CHECK_SEND   2
#   define CHECK_SWITCH 3

    void    checkPXRXdmaValidBuffer( PPDEV, GlintDataPtr, ULONG, ULONG );
#else   // PXRX_DMA_BUFFER_CHECK
#   define CHECK_PXRX_DMA_VALIDITY(type, count)     do { ; } while(0)
#endif  // PXRX_DMA_BUFFER_CHECK


/****************************************************/

/******************************************************/
/*** The actual DMA processing macros and functions ***/
    /*
        Function pointers:
            sendPXRXdmaForce                Will not return until the DMA has been started
            sendPXRXdmaQuery                Will send if there is FIFO space
            sendPXRXdmaBatch                Will only batch the data up
            switchPXRXdmaBuffer             Switches from one buffer to another
            waitPXRXdmaCompletedBuffer      Waits for next buffer to become available
    */

    void sendPXRXdmaFIFO                        ( PPDEV ppdev, GlintDataPtr glintInfo );
    void switchPXRXdmaBufferFIFO                ( PPDEV ppdev, GlintDataPtr glintInfo );
    void waitPXRXdmaCompletedBufferFIFO         ( PPDEV ppdev, GlintDataPtr glintInfo );

#   define SEND_PXRX_DMA_FORCE              do { ppdev->          sendPXRXdmaForce( ppdev, glintInfo ); } while(0)
#   define SEND_PXRX_DMA_QUERY              do { ppdev->          sendPXRXdmaQuery( ppdev, glintInfo ); } while(0)
#   define SEND_PXRX_DMA_BATCH              do { ppdev->          sendPXRXdmaBatch( ppdev, glintInfo ); } while(0)
#   define SWITCH_PXRX_DMA_BUFFER           do { ppdev->       switchPXRXdmaBuffer( ppdev, glintInfo ); } while(0)
#   define WAIT_PXRX_DMA_COMPLETED_BUFFER   do { ppdev->waitPXRXdmaCompletedBuffer( ppdev, glintInfo ); } while(0)

/************ End of PXRX DMA macros ************/
/************************************************/


#define LOAD_FOREGROUNDCOLOUR(value)                                                    \
    do {                                                                                \
        if( (value) != glintInfo->foregroundColour ) {                                    \
            glintInfo->foregroundColour = (value);                                        \
            QUEUE_PXRX_DMA_TAG( __GlintTagForegroundColor, glintInfo->foregroundColour );    \
        }                                                                                \
    } while(0)

#define LOAD_BACKGROUNDCOLOUR(value)                                                    \
    do {                                                                                \
        if( (value) != glintInfo->backgroundColour ) {                                    \
            glintInfo->backgroundColour = (value);                                        \
            QUEUE_PXRX_DMA_TAG( __GlintTagBackgroundColor, glintInfo->backgroundColour );    \
        }                                                                                \
    } while(0)

////////////////////////
// FBWriteBuffer[0-3] //
#define USE_FBWRITE_BUFFERS(mask)                                                        \
    do {                                                                                \
        if( ((mask) << 12) != (glintInfo->fbWriteMode & (15 << 12)) ) {                    \
            glintInfo->fbWriteMode &= ~(15 << 12);                                        \
            glintInfo->fbWriteMode |= ((mask) << 12);                                    \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );        \
        }                                                                                \
    } while(0)

#define LOAD_FBWRITE_OFFSET(buff, xy)                                                    \
    do {                                                                                \
        if( glintInfo->fbWriteOffset[buff] != (xy) ) {                                    \
            glintInfo->fbWriteOffset[buff] = (xy);                                        \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferOffset0 + buff, (xy) );            \
            DISPDBG((7, "LOAD_FBWRITE_OFFSET(%d, %08x)", buff, (xy)));                    \
        }                                                                                \
    } while(0)

#define LOAD_FBWRITE_OFFSET_XY(buff, x, y)                                                \
    do {                                                                                \
        _temp_ul = MAKEDWORD_XY(x, y);                                                    \
        LOAD_FBWRITE_OFFSET(buff, _temp_ul);                                            \
    } while(0)

#define LOAD_FBWRITE_ADDR(buff, addr)                                                    \
    do {                                                                                \
        _temp_ul = (addr) << ppdev->cPelSize;                                            \
        if( glintInfo->fbWriteAddr[buff] != (ULONG)_temp_ul ) {                            \
            glintInfo->fbWriteAddr[buff] = (ULONG)_temp_ul;                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferAddr0 + buff, _temp_ul);            \
            DISPDBG((7, "LOAD_FBWRITE_ADDR(%d, %08x)", buff, _temp_ul));                \
        }                                                                                \
    } while(0)

#define LOAD_FBWRITE_WIDTH(buff, width)                                                    \
    do {                                                                                \
        if( glintInfo->fbWriteWidth[buff] != (ULONG)(width) ) {                            \
            glintInfo->fbWriteWidth[buff] = (ULONG)(width);                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteBufferWidth0 + buff, (width) );        \
            DISPDBG((7, "LOAD_FBWRITE_WIDTH(%d, %08x)", buff, (width)));                \
        }                                                                                \
    } while(0)

// With rectangular heaps offscreen destinations always have DstPixelOrigin == 0 && xyOffsetDst != 0
// With linear heaps offscreen destinations always have DstPixelOrigin != 0
// For onscreen destinations both these values are guaranteed to be 0 for either heap method
#define OFFSCREEN_DST(ppdev)        (ppdev->bDstOffScreen)

#if(_WIN32_WINNT < 0x500)
#define OFFSCREEN_RECT_DST(ppdev)   OFFSCREEN_DST(ppdev)
#define OFFSCREEN_LIN_DST(ppdev)    (FALSE)
#else
#define OFFSCREEN_RECT_DST(ppdev)    (OFFSCREEN_DST(ppdev) && (ppdev->flStatus & STAT_LINEAR_HEAP) == 0)
#define OFFSCREEN_LIN_DST(ppdev)    (OFFSCREEN_DST(ppdev) && (ppdev->flStatus & STAT_LINEAR_HEAP))
#endif

#define SET_WRITE_BUFFERS                                                                       \
    do {                                                                                        \
        gi_pxrxDMA.bFlushRequired = FALSE;                                                        \
                                                                                                \
        if( (glintInfo->fbWriteOffset[0] != (ULONG) ppdev->xyOffsetDst) ||                         \
            (glintInfo->fbWriteWidth[0] != (ULONG) ppdev->DstPixelDelta) ||                        \
            (glintInfo->fbWriteAddr[0] != (ULONG) (ppdev->DstPixelOrigin << ppdev->cPelSize)) ||    \
            (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) ||                                    \
            (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE)) {                                    \
                                                                                                \
            WAIT_PXRX_DMA_TAGS( 14 );                                                            \
            LOAD_FBWRITE_ADDR( 0, ppdev->DstPixelOrigin );                                        \
            LOAD_FBWRITE_WIDTH( 0, ppdev->DstPixelDelta );                                        \
            LOAD_FBWRITE_OFFSET( 0, ppdev->xyOffsetDst );                                        \
                                                                                                \
            /* Are we rendering to the screen? */                                                \
            if( OFFSCREEN_DST(ppdev) ) {                                                        \
                DISPDBG((DBGLVL, "PXRX: Offscreen bitmap"));                                \
                /* No. So make sure multiple writes are off */                                    \
                if( ((glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) &&                        \
                    (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING)) ||                        \
                    ((glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) &&                            \
                    (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING)) ) {                        \
                    DISPDBG((DBGLVL, "PXRX: Disabling multiple writes"));                    \
                                                                                                \
                    glintInfo->fbWriteMode = glintInfo->fbWriteModeSingleWrite;                    \
                    QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );        \
                    glintInfo->pxrxFlags &= ~PXRX_FLAGS_DUAL_WRITING;                            \
                    glintInfo->pxrxFlags &= ~PXRX_FLAGS_STEREO_WRITING;                            \
                }                                                                                \
            } else {                                                                            \
                DISPDBG((DBGLVL, "PXRX: Visible screen"));                                    \
                /* Yes. So do we need to re-enable multiple writes? */                            \
                if( glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE ) {                            \
                    LOAD_FBWRITE_ADDR( 1, 0 );                                                    \
                    LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );                                \
                    LOAD_FBWRITE_ADDR( 2, 0 );                                                    \
                    LOAD_FBWRITE_WIDTH( 2, ppdev->DstPixelDelta );                                \
                    if( glintInfo->currentCSbuffer == 0 ) {                                        \
                        LOAD_FBWRITE_OFFSET( 1, glintInfo->backBufferXY );                        \
                        LOAD_FBWRITE_OFFSET( 2, glintInfo->backRightBufferXY );                    \
                    } else {                                                                    \
                        LOAD_FBWRITE_OFFSET( 1, 0 );                                            \
                        LOAD_FBWRITE_OFFSET( 2, glintInfo->frontRightBufferXY );                \
                    }                                                                            \
                }                                                                                \
                if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE ) {                            \
                    LOAD_FBWRITE_ADDR( 3, 0 );                                                    \
                    LOAD_FBWRITE_WIDTH( 3, ppdev->DstPixelDelta );                                \
                    if( glintInfo->currentCSbuffer == 0 ) {                                        \
                        LOAD_FBWRITE_OFFSET( 3, glintInfo->frontRightBufferXY );                \
                    }                                                                            \
                    else {                                                                        \
                        LOAD_FBWRITE_OFFSET( 3, glintInfo->backRightBufferXY );                \
                    }                                                                            \
                }                                                                                \
                if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE) &&                            \
                    (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ) {                        \
                    if( !((glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) &&                    \
                         (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING)) ) {                \
                        DISPDBG((DBGLVL, "PXRX: Re-enabling dual stereo writes"));            \
                                                                                                \
                        glintInfo->fbWriteMode = glintInfo->fbWriteModeDualWriteStereo;            \
                        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );    \
                        glintInfo->pxrxFlags |= PXRX_FLAGS_DUAL_WRITING;                        \
                        glintInfo->pxrxFlags |= PXRX_FLAGS_STEREO_WRITING;                        \
                    }                                                                            \
                }                                                                                \
                else if( glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITE ) {                        \
                    if( !(glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ) {                    \
                        DISPDBG((DBGLVL, "PXRX: Re-enabling dual writes"));                \
                                                                                                \
                        glintInfo->fbWriteMode = glintInfo->fbWriteModeDualWrite;                \
                        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );    \
                        glintInfo->pxrxFlags |= PXRX_FLAGS_DUAL_WRITING;                        \
                    }                                                                            \
                }                                                                                \
                else if( glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE ) {                        \
                    if( !(glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITING) ) {                    \
                        DISPDBG((DBGLVL, "PXRX: Re-enabling stereo writes"));                \
                                                                                                \
                        glintInfo->fbWriteMode = glintInfo->fbWriteModeSingleWriteStereo;        \
                        QUEUE_PXRX_DMA_TAG( __GlintTagFBWriteMode, glintInfo->fbWriteMode );    \
                        glintInfo->pxrxFlags |= PXRX_FLAGS_STEREO_WRITING;                        \
                    }                                                                            \
                }                                                                                \
            }                                                                                    \
                                                                                                \
            DISPDBG((DBGLVL, "setWriteBuffers: current = %d", glintInfo->currentCSbuffer));                                            \
            DISPDBG((DBGLVL, "setWriteBuffers:   ppdev = 0x%08X, 0x%08X", ppdev->DstPixelOrigin, ppdev->xyOffsetDst));                \
            DISPDBG((DBGLVL, "setWriteBuffers: buff[0] = 0x%08X, 0x%08X", glintInfo->fbWriteAddr[0], glintInfo->fbWriteOffset[0]));    \
            DISPDBG((DBGLVL, "setWriteBuffers: buff[1] = 0x%08X, 0x%08X", glintInfo->fbWriteAddr[1], glintInfo->fbWriteOffset[1]));    \
        }                                                                                        \
    } while(0)

///////////////////////////
// FBDestReadBuffer[0-3] //
#define SET_READ_BUFFERS                                                                \
    do {                                                                                \
        LOAD_FBDEST_ADDR( 0, ppdev->DstPixelOrigin );                                    \
        LOAD_FBDEST_WIDTH( 0, ppdev->DstPixelDelta );                                    \
        LOAD_FBDEST_OFFSET( 0, ppdev->xyOffsetDst );                                    \
    } while(0)

#define LOAD_FBDEST_ADDR(buff, addr)                                                    \
    do {                                                                                \
        _temp_ul = (addr) << ppdev->cPelSize;                                            \
        if( glintInfo->fbDestAddr[buff] != (ULONG)_temp_ul ) {                            \
            glintInfo->fbDestAddr[buff] = (ULONG)_temp_ul;                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferAddr0 + buff, _temp_ul );        \
            DISPDBG((7, "LOAD_FBDEST_ADDR(%d, %08x)", buff, _temp_ul));                    \
        }                                                                                \
    } while(0)

#define LOAD_FBDEST_OFFSET(buff, xy)                                                    \
    do {                                                                                \
        if( glintInfo->fbDestOffset[buff] != (xy) ) {                                    \
            glintInfo->fbDestOffset[buff] = (xy);                                        \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferOffset0 + buff, (xy) );        \
            DISPDBG((7, "LOAD_FBDEST_OFFSET(%d, %08x)", buff, (xy)));                    \
        }                                                                                \
    } while(0)

#define LOAD_FBDEST_WIDTH(buff, width)                                                    \
    do {                                                                                \
        if( glintInfo->fbDestWidth[buff] != (ULONG)(width) ) {                            \
            glintInfo->fbDestWidth[buff] = (ULONG)(width);                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBDestReadBufferWidth0 + buff, (width) );        \
            DISPDBG((7, "LOAD_FBDEST_WIDTH(%d, %08x)", buff, (width)));                    \
        }                                                                                \
    } while(0)

////////////////////////
// FBSourceReadBuffer //
#define LOAD_FBSOURCE_OFFSET(xy)                                                        \
    do {                                                                                \
        if( glintInfo->fbSourceOffset != (xy) ) {                                        \
            glintInfo->fbSourceOffset = (xy);                                            \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferOffset, (xy) );                \
            DISPDBG((7, "LOAD_FBSOURCE_OFFSET(%08x)", (xy)));                            \
        }                                                                                \
    } while(0)

#define LOAD_FBSOURCE_OFFSET_XY(x, y)                                                    \
    do {                                                                                \
        _temp_ul = MAKEDWORD_XY((x), (y));                                                \
        LOAD_FBSOURCE_OFFSET(_temp_ul);                                                    \
    } while(0)

#define LOAD_FBSOURCE_ADDR(addr)                                                        \
    do {                                                                                \
        _temp_ul = (addr) << ppdev->cPelSize;                                            \
        if( glintInfo->fbSourceAddr != _temp_ul ) {                                        \
            glintInfo->fbSourceAddr = _temp_ul;                                            \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferAddr, _temp_ul );            \
            DISPDBG((7, "LOAD_FBSOURCE_ADDR(%08x)", _temp_ul));                            \
        }                                                                                \
    } while(0)

#define LOAD_FBSOURCE_WIDTH(width)                                                        \
    do {                                                                                \
        if( glintInfo->fbSourceWidth != (ULONG)(width) ) {                                \
            glintInfo->fbSourceWidth = (ULONG)(width);                                    \
            QUEUE_PXRX_DMA_TAG( __GlintTagFBSourceReadBufferWidth, (width) );            \
            DISPDBG((7, "LOAD_FBSOURCE_WIDTH(%08x)", (width)));                            \
        }                                                                                \
    } while(0)

// NB: Enable must never be set in 'mode' when calling LOAD_LUTMODE
#define LOAD_LUTMODE(mode)                                                                \
    do {                                                                                \
        if( glintInfo->config2D & __CONFIG2D_LUTENABLE )                                \
            (mode) |= (1 << 0);                                                            \
                                                                                        \
        if( (mode) != glintInfo->lutMode ) {                                            \
            glintInfo->lutMode = (mode);                                                \
            QUEUE_PXRX_DMA_TAG( __GlintTagLUTMode, glintInfo->lutMode );                \
        }                                                                                \
    } while(0)


// FLUSH_PXRX_PATCHED_RENDER2D
// We only need to send a continue new sub for the final primitive in a patched framebuffer and then only if
// it falls within a single patch in X and is rendered using the Render2D command. The preferred method is to
// have the message sent during the vblank period, the bFlushRequired flag is reset every SET_WRITE_BUFFERS 
// so that the message is only sent when the display driver becomes idle.
#define FLUSH_PXRX_PATCHED_RENDER2D(left, right)                                                              \
    do                                                                                                          \
    {                                                                                                          \
        if(glintInfo->pxrxFlags & (PXRX_FLAGS_PATCHING_FRONT | PXRX_FLAGS_PATCHING_BACK))                      \
        {                                                                                                      \
            if( INTERRUPTS_ENABLED && (glintInfo->pInterruptCommandBlock->Control & PXRX_SEND_ON_VBLANK_ENABLED) )      \
            {                                                                                                  \
                gi_pxrxDMA.bFlushRequired = TRUE;                                                                \
            }                                                                                                  \
            else                                                                                              \
            {                                                                                                  \
                ULONG PatchMask = 0x40 << (2 - ppdev->cPelSize);                                              \
                ULONG labs = left + (ppdev->xyOffsetDst & 0xFFFF);                                              \
                ULONG rabs = right + (ppdev->xyOffsetDst & 0xFFFF);                                              \
                                                                                                              \
                if((labs & PatchMask) == (rabs & PatchMask))                                                  \
                {                                                                                              \
                    WAIT_PXRX_DMA_TAGS(1);                                                                      \
                    QUEUE_PXRX_DMA_TAG(__GlintTagContinueNewSub, 0);                                          \
                }                                                                                              \
            }                                                                                                  \
        }                                                                                                      \
    }                                                                                                          \
    while(0)

// bits in the Config2D register (PXRX only)
#define __CONFIG2D_OPAQUESPANS          (1 << 0)
#define __CONFIG2D_MULTIRX              (1 << 1)
#define __CONFIG2D_USERSCISSOR          (1 << 2)
#define __CONFIG2D_FBDESTREAD           (1 << 3)
#define __CONFIG2D_ALPHABLEND           (1 << 4)
#define __CONFIG2D_DITHER               (1 << 5)
#define __CONFIG2D_LOGOP_FORE(op)       ((1 << 6) | ((op) << 7))
#define __CONFIG2D_LOGOP_FORE_ENABLE    (1 << 6)
#define __CONFIG2D_LOGOP_FORE_MASK      (31 << 6)
#define __CONFIG2D_LOGOP_BACK(op)       ((1 << 11) | ((op) << 12))
#define __CONFIG2D_LOGOP_BACK_ENABLE    (1 << 11)
#define __CONFIG2D_LOGOP_BACK_MASK      (31 << 11)
#define __CONFIG2D_CONSTANTSRC          (1 << 16)
#define __CONFIG2D_FBWRITE              (1 << 17)
#define __CONFIG2D_FBBLOCKING           (1 << 18)
#define __CONFIG2D_EXTERNALSRC          (1 << 19)
#define __CONFIG2D_LUTENABLE            (1 << 20)
#define __CONFIG2D_ENABLES              (__CONFIG2D_OPAQUESPANS | \
                                         __CONFIG2D_USERSCISSOR | \
                                         __CONFIG2D_FBDESTREAD  | \
                                         __CONFIG2D_ALPHABLEND  | \
                                         __CONFIG2D_DITHER      | \
                                         __CONFIG2D_CONSTANTSRC | \
                                         __CONFIG2D_FBWRITE     | \
                                         __CONFIG2D_FBBLOCKING  | \
                                         __CONFIG2D_EXTERNALSRC | \
                                         __CONFIG2D_LUTENABLE)

#define LOAD_CONFIG2D(value)                                               \
    do {                                                                   \
        if( (value) != glintInfo->config2D ) {                             \
            glintInfo->config2D = (value);                                 \
            QUEUE_PXRX_DMA_TAG( __GlintTagConfig2D, glintInfo->config2D ); \
        }                                                                  \
    } while(0)

// bits in the Render2D command (PXRX only)
#define __RENDER2D_WIDTH(width)             (INT16(width))
#define __RENDER2D_HEIGHT(height)           (INT16(height) << 16)
#define __RENDER2D_OP_NORMAL                (0 << 12)
#define __RENDER2D_OP_SYNCDATA              (1 << 12)
#define __RENDER2D_OP_SYNCBITMASK           (2 << 12)
#define __RENDER2D_OP_PATCHORDER_PATCHED    (3 << 12)
#define __RENDER2D_FBSRCREAD                (1 << 14)
#define __RENDER2D_SPANS                    (1 << 15)
#define __RENDER2D_INCY                     (1 << 29)
#define __RENDER2D_INCX                     (1 << 28)
#define __RENDER2D_AREASTIPPLE              (1 << 30)
#define __RENDER2D_WIDTH_MASK               (4095 << 0)
#define __RENDER2D_HEIGHT_MASK              (4095 << 16)

#define __RENDER2D_OP_PATCHORDER            glintInfo->render2Dpatching

extern const DWORD  LogicOpReadSrc[];            // indicates which logic ops need a source colour
extern const ULONG  render2D_NativeBlt[16];
extern const ULONG  render2D_FillSolid[16];
extern const ULONG  render2D_FillSolidDual[16];
extern const ULONG  config2D_FillColour[16];
extern const ULONG  config2D_FillColourDual[16];
extern const ULONG  config2D_FillSolid[16];
extern const ULONG  config2D_FillSolidVariableSpans[16];
extern const ULONG  config2D_NativeBlt[16];

void pxrxSetupFunctionPointers( PPDEV );
void pxrxRestore2DContext( PPDEV ppdev, BOOL switchingIn );
void pxrxSetupDualWrites_Patching( PPDEV ppdev );

void pxrxMonoDownloadRaw    ( PPDEV ppdev, ULONG AlignWidth, ULONG *pjSrc, LONG lSrcDelta, LONG cy );
void pxrxMonoDownloadRLE    ( PPDEV ppdev, ULONG AlignWidth, ULONG *pjSrc, LONG lSrcDelta, LONG cy );

VOID pxrxCopyBltNative  (PDEV*, RECTL*, LONG, DWORD, POINTL*, RECTL*);
VOID pxrxFillSolid      (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID pxrxFillPatMono    (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID pxrxFillPatColor   (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID pxrxXfer1bpp       (PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*, RECTL*, XLATEOBJ*);
VOID pxrxXfer4bpp       (PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*, RECTL*, XLATEOBJ*);
VOID pxrxXfer8bpp       (PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*, RECTL*, XLATEOBJ*);
VOID pxrxXferImage      (PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*, RECTL*, XLATEOBJ*);
VOID pxrxMaskCopyBlt    (PDEV*, RECTL*, LONG, SURFOBJ*, POINTL*, ULONG, ULONG, POINTL*, RECTL*);
VOID pxrxPatRealize     (PDEV*, RBRUSH*, POINTL*);
VOID pxrxMonoOffset     (PDEV*, RBRUSH*, POINTL*);
BOOL bGlintFastFillPolygon    (PDEV*, LONG, POINTFIX*, ULONG, ULONG, DWORD, CLIPOBJ*, RBRUSH*, POINTL*);
BOOL pxrxDrawLine       (PDEV*, LONG, LONG, LONG, LONG);
BOOL pxrxIntegerLine    (PDEV*, LONG, LONG, LONG, LONG);
BOOL pxrxContinueLine   (PDEV*, LONG, LONG, LONG, LONG);
BOOL pxrxInitStrips     (PDEV*, ULONG, DWORD, RECTL*);
VOID pxrxResetStrips    (PDEV*);
VOID pxrxRepNibbles     (PDEV*, RECTL*, CLIPOBJ*);
VOID pxrxFifoUpload     (PDEV*, LONG, RECTL*, SURFOBJ*, POINTL*, RECTL*);
VOID pxrxMemUpload  (PDEV*, LONG, RECTL*, SURFOBJ*, POINTL*, RECTL*);
VOID pxrxRLEFifoUpload(PPDEV ppdev, LONG crcl, RECTL *prcl, SURFOBJ *psoDst, POINTL *pptlSrc, RECTL *prclDst);
VOID pxrxCopyXfer24bpp  (PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG);
VOID pxrxCopyXfer8bppLge(PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG, XLATEOBJ *);
VOID pxrxCopyXfer8bpp   (PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG, XLATEOBJ *);

BOOL bPxRxUncachedText              (PDEV* ppdev, GLYPHPOS* pgp, LONG cGlyph, ULONG ulCharInc);
BOOL bPxRxUncachedClippedText       (PDEV* ppdev, GLYPHPOS* pgp, LONG cGlyph, ULONG ulCharInc, CLIPOBJ *pco);

VOID p3r3FillSolidVariableSpans     (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillSolid32bpp             (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatMono32bpp           (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatMonoVariableSpans   (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatColor32bpp          (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatColor16bpp          (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
VOID p3r3FillPatColorVariableSpans  (PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR, POINTL*);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\pxrxpoly.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pxrxPoly.c
*
* Content: Draws polygons.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define DBG_TRACK_CODE 0

#include "precomp.h"
#include "pxrx.h"

#define DO_SPANONLY_VERSION 0
#define RIGHT 0
#define LEFT  1
#define ABS(a)    ((a) < 0 ? -(a) : (a))

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      lErrorDown;       // DDA error adjustment
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
} EDGEDATA;                        

#define GetMoreFifoEntries( numberNeeded )              \
    do {                                                \
        nSpaces -= numberNeeded;                        \
        if( nSpaces <= 0 ) {                            \
            do {                                        \
                nSpaces = 10 + numberNeeded;            \
                WAIT_FREE_PXRX_DMA_TAGS( nSpaces );     \
                nSpaces -= numberNeeded;                \
            } while( nSpaces <= 0 );                    \
        }                                               \
    } while(0)


/*
#define SETUP_COLOUR_STUFF      do { setupColourStuff(ppdev, glintInfo,                                        \
                                                      &fgColor, &fgLogicOp,                                    \
                                                      &bgColor, &bgLogicOp,                                    \
                                                      prb, pptlBrush,                                        \
                                                      &config2D, &renderMsg, &invalidatedFGBG); } while(0)

static void setupColourStuff( PDEV *ppdev, GlintDataRec *glintInfo,
                              ULONG *fgColor_In, ULONG *fgLogicOp_In,
                              ULONG *bgColor_In, ULONG *bgLogicOp_In,
                              RBRUSH *prb, POINTL *pptlBrush,
                              ULONG *config2D_In, ULONG *renderMsg_In, ULONG *invalidatedFGBG_In ) {
    ULONG   fgColor = *fgColor_In, fgLogicOp = *fgLogicOp_In;
    ULONG   bgColor = *bgColor_In, bgLogicOp = *bgLogicOp_In;
    ULONG   config2D = *config2D_In, renderMsg = *renderMsg_In;
    ULONG   invalidatedFGBG = *invalidatedFGBG_In;
    TEMP_MACRO_VARS;
*/

#define SETUP_COLOUR_STUFF                                                                                  \
    do {                                                                                                    \
        SET_WRITE_BUFFERS;                                                                                    \
                                                                                                            \
        if( fgColor != 0xFFFFFFFF ) {                                                                        \
            WAIT_PXRX_DMA_TAGS( 4 );                                                                        \
            /* Solid colour filled polygon */                                                                \
            if( (fgLogicOp == __GLINT_LOGICOP_COPY) &&                                                        \
                (ppdev->cPelSize != GLINTDEPTH8) && (ppdev->cPelSize != GLINTDEPTH32) ) {                    \
                config2D |= __CONFIG2D_CONSTANTSRC;                                                            \
            } else {                                                                                        \
                config2D |= __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_CONSTANTSRC;                        \
                renderMsg |= __RENDER_VARIABLE_SPANS;                                                        \
                                                                                                            \
                if( LogicopReadDest[fgLogicOp] ) {                                                            \
                    config2D |= __CONFIG2D_FBDESTREAD;                                                        \
                    SET_READ_BUFFERS;                                                                        \
                }                                                                                            \
            }                                                                                                \
                                                                                                            \
            if( LogicOpReadSrc[fgLogicOp] )                                                                    \
                LOAD_FOREGROUNDCOLOUR( fgColor );                                                            \
                                                                                                            \
            DISPDBG((DBGLVL, "bGlintFastFillPolygon: solid fill, col = 0x%08x, logicOp = %d", fgColor, fgLogicOp));    \
        } else {                                                                                            \
            /* Brush filled polygon */                                                                        \
            BRUSHENTRY *pbe;                                                                                \
                                                                                                            \
            pbe = prb->apbe;                                                                    \
                                                                                                            \
            if( prb->fl & RBRUSH_2COLOR ) {                                                                    \
                /* Monochrome brush */                                                                        \
                config2D |= __CONFIG2D_CONSTANTSRC;                                                            \
                renderMsg |= __RENDER_AREA_STIPPLE_ENABLE;                                                    \
                                                                                                            \
                /* if anything has changed with the brush we must re-realize it. If the brush */            \
                /* has been kicked out of the area stipple unit we must fully realize it. If  */            \
                /* only the alignment has changed we can simply update the alignment for the  */            \
                /* stipple.                                                                      */            \
                if( (pbe == NULL) || (pbe->prbVerify != prb) ) {                                            \
                    DISPDBG((DBGLVL, "full brush realise"));                                                        \
                    (*ppdev->pgfnPatRealize)(ppdev, prb, pptlBrush);                                        \
                } else if( (prb->ptlBrushOrg.x != pptlBrush->x) ||                            \
                         (prb->ptlBrushOrg.y != pptlBrush->y) ) {                            \
                    DISPDBG((DBGLVL, "changing brush offset"));                                                    \
                    (*ppdev->pgfnMonoOffset)(ppdev, prb, pptlBrush);                                        \
                }                                                                                            \
                                                                                                            \
                fgColor = prb->ulForeColor;                                                                    \
                bgColor = prb->ulBackColor;                                                                    \
                                                                                                            \
                if( ((bgLogicOp == __GLINT_LOGICOP_AND) && (bgColor == ppdev->ulWhite))                        \
                    || ((bgLogicOp == __GLINT_LOGICOP_OR ) && (bgColor == 0))                                \
                    || ((bgLogicOp == __GLINT_LOGICOP_XOR) && (bgColor == 0)) )                                \
                        bgLogicOp = __GLINT_LOGICOP_NOOP;                                                    \
                                                                                                            \
                if( ((fgLogicOp != __GLINT_LOGICOP_COPY) || (bgLogicOp != __GLINT_LOGICOP_NOOP)) ||            \
                    (ppdev->cPelSize == GLINTDEPTH32) || (ppdev->cPelSize == GLINTDEPTH8) ) {                \
                    config2D |= __CONFIG2D_OPAQUESPANS | __CONFIG2D_LOGOP_FORE(fgLogicOp) | __CONFIG2D_LOGOP_BACK(bgLogicOp);        \
                    renderMsg |= __RENDER_VARIABLE_SPANS;                                                    \
                }                                                                                            \
                                                                                                            \
                WAIT_PXRX_DMA_TAGS( 5 );                                                                    \
                                                                                                            \
                if( LogicopReadDest[fgLogicOp] || LogicopReadDest[bgLogicOp] ) {                            \
                    config2D |= __CONFIG2D_FBDESTREAD;                                                        \
                    SET_READ_BUFFERS;                                                                        \
                }                                                                                            \
                                                                                                            \
                if( LogicOpReadSrc[fgLogicOp] )                                                                \
                    LOAD_FOREGROUNDCOLOUR( fgColor );                                                        \
                if( LogicOpReadSrc[bgLogicOp] )                                                                \
                    LOAD_BACKGROUNDCOLOUR( bgColor );                                                        \
                                                                                                            \
                DISPDBG((DBGLVL, "bGlintFastFillPolygon: mono pat fill, col = 0x%08x:0x%08x, logicOp = %d:%d",            \
                            fgColor, bgColor, fgLogicOp, bgLogicOp));                                        \
            } else {                                                                                        \
                /* Colour brush */                                                                            \
                POINTL  brushOrg;                                                                            \
                                                                                                            \
                brushOrg = *pptlBrush;                                                                        \
                if( (fgLogicOp == __GLINT_LOGICOP_COPY) && (ppdev->cPelSize != 0) )                            \
                    brushOrg.x +=  (8 - (ppdev->xyOffsetDst & 0xFFFF)) & 7;                                    \
                                                                                                            \
                if( (ppdev->PalLUTType != LUTCACHE_BRUSH) || (pbe == NULL) || (pbe->prbVerify != prb) ) {    \
                    DISPDBG((DBGLVL, "realising brush"));                                                        \
                    (*ppdev->pgfnPatRealize)(ppdev, prb, &brushOrg);                                        \
                } else                                                                                      \
                if( (prb->ptlBrushOrg.x != brushOrg.x) || (prb->ptlBrushOrg.y != brushOrg.y) ||                \
                    (prb->patternBase != ((glintInfo->lutMode >> 18) & 255)) ) {                \
                    ULONG   lutMode = glintInfo->lutMode;                                                    \
                                                                                                            \
                    DISPDBG((DBGLVL, "resetting LUTMode"));                                                        \
                                                                                                            \
                    prb->ptlBrushOrg.x = brushOrg.x;                                            \
                    prb->ptlBrushOrg.y = brushOrg.y;                                            \
                                                                                                            \
                    DISPDBG((DBGLVL, "setting new LUT offset to %d, %d", (8 - prb->ptlBrushOrg.x) & 7, (8 - prb->ptlBrushOrg.y) & 7));            \
                                                                                                            \
                    lutMode &= ~((7 << 8) | (7 << 12) | (7 << 15) | (255 << 18) | (1 << 26) | (1 << 27));    \
                    lutMode |= (1 << 8) | (1 << 27) | (prb->patternBase << 18) |                \
                               (((8 - prb->ptlBrushOrg.x) & 7) << 12) | (((8 - prb->ptlBrushOrg.y) & 7) << 15);                                \
                    WAIT_PXRX_DMA_TAGS( 1 );                                                                \
                    LOAD_LUTMODE( lutMode );                                                                \
                } else {                                                                                    \
                    /* we're cached already! */                                                                \
                    DISPDBG((DBGLVL, "reusing LUT for brush @ %d, origin = (%d,%d)", prb->patternBase, prb->ptlBrushOrg.x, prb->ptlBrushOrg.y));    \
                }                                                                                            \
                                                                                                            \
                WAIT_PXRX_DMA_TAGS( 4 );                                                                    \
                if( (glintInfo->pxrxFlags & PXRX_FLAGS_DUAL_WRITING) ||                                        \
                    (glintInfo->pxrxFlags & PXRX_FLAGS_STEREO_WRITE) ||                                        \
                    (ppdev->cPelSize == GLINTDEPTH8) || (ppdev->cPelSize == GLINTDEPTH32) ) {                \
                    config2D |= config2D_FillColourDual[fgLogicOp];                                            \
                                                                                                            \
                    if( LogicopReadDest[fgLogicOp] )                                                        \
                        SET_READ_BUFFERS;                                                                    \
                                                                                                            \
                    renderMsg |= __RENDER_VARIABLE_SPANS;                                                    \
                } else {                                                                                    \
                    config2D |= config2D_FillColour[fgLogicOp];                                                \
                                                                                                            \
                    if( fgLogicOp != __GLINT_LOGICOP_COPY )                                                    \
                        renderMsg |= __RENDER_VARIABLE_SPANS;                                                \
                                                                                                            \
                    if( LogicopReadDest[fgLogicOp] ) {                                                        \
                        SET_READ_BUFFERS;                                                                    \
                    } else if( fgLogicOp == __GLINT_LOGICOP_COPY ) {                                        \
                        LOAD_FBWRITE_ADDR( 1, ppdev->DstPixelOrigin );                                        \
                        LOAD_FBWRITE_WIDTH( 1, ppdev->DstPixelDelta );                                        \
                        LOAD_FBWRITE_OFFSET( 1, ppdev->xyOffsetDst );                                        \
                    }                                                                                        \
                }                                                                                            \
                                                                                                            \
                if( config2D & __CONFIG2D_LUTENABLE )                                                        \
                    invalidatedFGBG = TRUE;                                                                    \
                                                                                                            \
                DISPDBG((DBGLVL, "bGlintFastFillPolygon: colour pat fill, patBase = %d, logicOp = %d", prb->patternBase, fgLogicOp));                    \
            }                                                                                                \
        }                                                                                                    \
                                                                                                            \
        WAIT_PXRX_DMA_TAGS( 1 );                                                                            \
        LOAD_CONFIG2D( config2D );                                                                            \
        nSpaces = 0;                                                                                        \
    } while( 0 )

/*
;
    *fgColor_In         = fgColor;
    *fgLogicOp_In       = fgLogicOp;
    *bgColor_In         = bgColor;
    *bgLogicOp_In       = bgLogicOp;
    *config2D_In        = config2D;
    *renderMsg_In       = renderMsg;
    *invalidatedFGBG_In = invalidatedFGBG;
}
*/


/******************************Public*Routine******************************\
* BOOL bGlintFastFillPolygon
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or 4.0.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the glint area stipple can be
* used.  The reason for this is that once the stipple initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference of an extra bit in the render command).
*
* We break each polygon down to a sequenze of screen aligned trapeziods, which
* the glint can handle.
*
* Optimisation list follows ....
*
* This routine is in no way the ultimate convex polygon drawing routine
* Some obvious things that would make it faster:
*
*    1) Write it in Assembler
*
*    2) Make the non-complex polygon detection faster.  If I could have
*       modified memory before the start of after the end of the buffer,
*       I could have simplified the detection code.  But since I expect
*       this buffer to come from GDI, I can't do that.  Another thing
*       would be to have GDI give a flag on calls that are guaranteed
*       to be convex, such as 'Ellipses' and 'RoundRects'.  Note that
*       the buffer would still have to be scanned to find the top-most
*       point.
*
*    3) Implement support for a single sub-path that spans multiple
*       path data records, so that we don't have to copy all the points
*       to a single buffer like we do in 'fillpath.c'.
*
*    4) Use 'ebp' and/or 'esp' as a general register in the inner loops
*       of the Asm loops, and also Pentium-optimize the code.  It's safe
*       to use 'esp' on NT because it's guaranteed that no interrupts
*       will be taken in our thread context, and nobody else looks at the
*       stack pointer from our context.
*
*    5) When we get to a part of the polygon where both vertices are of 
*       equal height, the algorithm essentially starts the polygon again.
*       Using the GLINT Continue message could speed things up in certain
*       cases.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bGlintFastFillPolygon(
    PDEV        *ppdev,
    LONG        cEdges,             // Includes close figure edge
    POINTFIX    *pptfxFirst,        // Ptr to first point
    ULONG       fgColor,            // Solid color fill
    ULONG       fgLogicOp,          // Logical Operation to perform
    ULONG       bgLogicOp,          // background logic op
    CLIPOBJ     *pco,               // Clip Object. 
    RBRUSH      *prb,
    POINTL      *pptlBrush )        // Pattern alignment
{
    POINTFIX    *pptfxLast;         // Points to the last point in the polygon array
    POINTFIX    *pptfxTop;          // Points to the top-most point in the polygon
    POINTFIX    *pptfxScan;         // Current edge pointer for finding pptfxTop
    LONG        cScanEdges;         // Number of edges scanned to find pptfxTop
                                    //  (doesn't include the closefigure edge)
    POINTFIX    *pnt[2];            // DDA terms and stuff
    POINTFIX    *npnt[2];           // DDA terms and stuff
    LONG        dx[2], dy[2], gdx[2];
    ULONG       orx, ory;           // all values ored, to eliminate complex polygons
    LONG        count;
    LONG        nClips;             // Number of clipping rectangles to render in
    CLIPENUM    *pClipRegion = (CLIPENUM *)(ppdev->pvTmpBuffer);
    RECTL       *pClipList;         // List of clip rects
    LONG        xOffFixed;
    ULONG       bgColor;
    BOOL        bTrivialClip, invalidatedFGBG = FALSE;
    BOOL        invalidatedScissor = FALSE;
    ULONG       config2D =  __CONFIG2D_FBWRITE;
    ULONG       renderMsg = __RENDER_TRAPEZOID_PRIMITIVE | 
                            __RENDER_FAST_FILL_ENABLE;
    LONG        nSpaces;
    GLINT_DECL;

    DISPDBG((DBGLVL, "bGlintFastFillPolygon: "
                     "Checking polygon for renderability by glint"));
    ASSERTDD(cEdges > 1, "Polygon with less than 2 edges");

    /////////////////////////////////////////////////////////////////
    // See if the polygon is 'non-complex'

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;
    orx = pptfxScan->x;
    ory = pptfxScan->y;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if( (pptfxScan + 1)->y > pptfxScan->y ) 
    {
        // Collect all downs:
        do 
        {
            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while( (pptfxScan + 1)->y >= pptfxScan->y );

        // Collect all ups:
        do 
        {
            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFillingCheck;
            }
        } while( (pptfxScan + 1)->y <= pptfxScan->y );

        // Collect all downs:
        pptfxTop = pptfxScan;

        do 
        {
            if( (pptfxScan + 1)->y > pptfxFirst->y )
                break;

            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while( (pptfxScan + 1)->y >= pptfxScan->y );

        DISPDBG((DBGLVL, "Reject: GLINT can't fill down-up-down polygon"));
        return FALSE;
        
    } 
    else 
    {
        // Collect all ups:
        do 
        {
            ory |= (++pptfxTop)->y;      // We increment this now because we
            orx |= pptfxTop->x;          //  want it to point to the very last
                                         //  point if we early out in the next
                                         //  statement...
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
            
        } while( (pptfxTop + 1)->y <= pptfxTop->y );

        // Collect all downs:
        pptfxScan = pptfxTop;
        do 
        {
            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
        } while( (pptfxScan + 1)->y >= pptfxScan->y );

        // Collect all ups:
        do 
        {
            if( (pptfxScan + 1)->y < pptfxFirst->y )
            {
                break;
            }

            ory |= (++pptfxScan)->y;
            orx |= pptfxScan->x;
            if( --cScanEdges == 0 )
            {
                goto SetUpForFilling;
            }
            
        } while( (pptfxScan + 1)->y <= pptfxScan->y );

        DISPDBG((DBGLVL, "Reject: GLINT can't fill up-down-up polygon"));
        return FALSE;
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far
             
    if( pptfxScan->y < pptfxTop->y )
    {
        pptfxTop = pptfxScan;
    }

SetUpForFilling:

    // can only use block fills for trivial clip so work it out here
    bTrivialClip = (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL);

    if( DO_SPANONLY_VERSION )
    {
        goto BreakIntoSpans;
    }

    if( (ory & 0xffffc00f) || (orx & 0xffff8000) ) 
    {
        ULONG   neg, posx, posy;

        // fractional Y must be done as spans
        if( ory & 0xf )
        {
            goto BreakIntoSpans;
        }

        // Run through all the vertices and check that none of them
        // have a negative component less than -256.
        neg = posx = posy = 0;
        for( pptfxScan = pptfxFirst; pptfxScan <= pptfxLast; pptfxScan++ ) 
        {
            if( pptfxScan->x < 0 )
            {
                neg |= -pptfxScan->x;
            }
            else
            {
                posx |= pptfxScan->x;
            }
            
            if( pptfxScan->y < 0 )
            {
                neg |= -pptfxScan->y;
            }
            else
            {
                posy |= pptfxScan->y;
            }
        }
  
        // We don't want to handle any polygon with a negative vertex
        // at <= -256 in either coordinate ???
        if( neg & 0xfffff000 ) 
        {
            DISPDBG((WRNLVL, "Coords out of range for fast fill"));
            return FALSE;
        }
    }

    // The code can handle the polygon now. Lets go ahead and render it! 

    // Compiler gets its register allocation wrong. This forces it to redo them
    GLINT_DECL_INIT;

    DISPDBG((DBGLVL, "bGlintFastFillPolygon: "
                     "Polygon is renderable. Go ahead and render"));

    // Work out offset to add to each of the coords downloaded to GLINT
    // To get correct results, we need to add on nearly one to each X
    // coordinate. 
    // Also add on offsets to bitmap (This might be an off screen bitmap)
    xOffFixed = INTtoFIXED(0) + NEARLY_ONE;

    // determine how many passes we require to draw all the clip rects
    if( bTrivialClip ) 
    {
        // Just draw, no clipping to perform.
        pClipList = NULL; // Indicate no clip list
        nClips = 1;
    } 
    else 
    {
        if( pco->iDComplexity == DC_RECT ) 
        {
            nClips = 1;
            pClipList = &pco->rclBounds;
        } 
        else 
        {
            // It may be slow to render the entire polygon for each clip 
            // rect, especially if the object is very complex. An arbitary 
            // limit of up to CLIP_LIMIT regions will be rendered by this 
            // function. Return false if more than CLIP_LIMIT regions.
            nClips = CLIPOBJ_cEnumStart(pco, 
                                        FALSE, 
                                        CT_RECTANGLES, 
                                        CD_ANY, 
                                        CLIP_LIMIT);
            
            if( nClips == -1 )
            {
                return FALSE; // More than CLIP_LIMIT.
            }

            // Put the regions into our clip buffer
            if( (CLIPOBJ_bEnum(pco, sizeof (CLIPENUM), (ULONG*)pClipRegion)) ||
                (pClipRegion->c != nClips) )
            {
                DISPDBG((DBGLVL, "bGlintFastFillPolygon: "
                                 "CLIPOBJ_bEnum inconsistency %d = %d", 
                                 pClipRegion->c, nClips));
            }
            
            pClipList = &(pClipRegion->arcl[0]);
        }

        config2D |= __CONFIG2D_USERSCISSOR;
    }

    SETUP_COLOUR_STUFF;

    WAIT_PXRX_DMA_TAGS( 11 );
    QUEUE_PXRX_DMA_TAG( __GlintTagdY, INTtoFIXED(1) );

    DISPDBG((DBGLVL, "Rendering Polygon. %d clipping rectangles", nClips));

    if( nClips && pClipList )
    {
        invalidatedScissor = TRUE;
    }

    // JME: check for 0 nClips //azn
    if( nClips-- ) 
    {
        while( 1 ) 
        {
            // Need to set up clip rect each pass 
            if( pClipList ) 
            {
                DISPDBG((DBGLVL, "Clip rect = (%d, %d -> %d, %d)", 
                                 pClipList->left, pClipList->top, 
                                 pClipList->right, pClipList->bottom));
                QUEUE_PXRX_DMA_TAG( __GlintTagScissorMinXY, 
                                            MAKEDWORD_XY(pClipList->left , 
                                                         pClipList->top   ) );
                QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 
                                            MAKEDWORD_XY(pClipList->right, 
                                                         pClipList->bottom) );
                pClipList++;
            }

            // Initialize left and right points (current) to top point.
            npnt[LEFT]  = pptfxTop;
            npnt[RIGHT] = pptfxTop;

            while( 1 ) 
            {
                // npnt[] is always the valid point to draw from
                do 
                {
                    pnt[LEFT] = npnt[LEFT];
                    npnt[LEFT] = pnt[LEFT] - 1;   

                    if (npnt[LEFT] < pptfxFirst)
                    {
                        npnt[LEFT] = pptfxLast;
                    }

                    // Special case of flat based polygon, need to break now 
                    // as polygon is finished
                    if (npnt[LEFT] == npnt[RIGHT]) 
                    {
                        goto FinishedPolygon;
                    }

                    DISPDBG((DBGLVL, "LEFT: pnt %P npnt %P FIRST %P LAST %P", 
                                     pnt[LEFT], npnt[LEFT], 
                                     pptfxFirst, pptfxLast));
                    DISPDBG((DBGLVL, "x 0x%04X y 0x%04X Next: x 0x%04X y 0x%04X", 
                                     pnt[LEFT]->x, pnt[LEFT]->y, 
                                     npnt[LEFT]->x, npnt[LEFT]->y));
                                     
                } while( pnt[LEFT]->y == npnt[LEFT]->y );
        
                do {
                    pnt[RIGHT] = npnt[RIGHT];
                    npnt[RIGHT] = pnt[RIGHT] + 1;     

                    if (npnt[RIGHT] > pptfxLast)
                    {
                        npnt[RIGHT] = pptfxFirst;
                    }

                    DISPDBG((DBGLVL, "RIGHT: pnt %P npnt %P FIRST %P LAST %P", 
                                     pnt[RIGHT], npnt[RIGHT], 
                                     pptfxFirst, pptfxLast));
                    DISPDBG((DBGLVL, "x 0x%04X y 0x%04X Next: x 0x%04X y 0x%04X", 
                                     pnt[RIGHT]->x, pnt[RIGHT]->y, 
                                     npnt[RIGHT]->x, npnt[RIGHT]->y));
                } while( pnt[RIGHT]->y == npnt[RIGHT]->y );
        
                // Start up new rectangle. Whenever we get to this code, both
                // points should have equal y values, and need to be restarted.
                DISPDBG((DBGLVL, "New: Top: (0x%04X, 0x%04X)->(0x%04X, 0x%04X)"
                                 "    Next: (0x%04X, 0x%04X)->(0x%04X, 0x%04X)",                          
                                 pnt[LEFT]->x, pnt[LEFT]->y, 
                                 pnt[RIGHT]->x, pnt[RIGHT]->y, 
                                 npnt[LEFT]->x, npnt[LEFT]->y, 
                                 npnt[RIGHT]->x, npnt[RIGHT]->y));

                QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    
                                        FIXtoFIXED(pnt[LEFT]->x) + xOffFixed );
                QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub,    
                                        FIXtoFIXED(pnt[RIGHT]->x) + xOffFixed);
                QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       
                                        FIXtoFIXED(pnt[RIGHT]->y) );

                // We have 2 15.4 coordinates. We need to divide them and 
                // change them into a 15.16 coordinate. We know the y 
                // coordinate is not fractional, so we do not loose 
                // precision by shifting right by 4
                dx[LEFT] = (npnt[LEFT]->x - pnt[LEFT]->x) << 12;
                dy[LEFT] = (npnt[LEFT]->y - pnt[LEFT]->y) >> 4;

                // Need to ensure we round delta down. 
                // divide rounds towards zero
                if( dx[LEFT] < 0 )
                {
                    dx[LEFT] -= dy[LEFT] - 1;
                }

                gdx[LEFT] = dx[LEFT] / dy[LEFT];
                
                QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    gdx[LEFT] );

                dx[RIGHT] = (npnt[RIGHT]->x - pnt[RIGHT]->x) << 12;
                dy[RIGHT] = (npnt[RIGHT]->y - pnt[RIGHT]->y) >> 4;

                // Need to ensure we round delta down. 
                // divide rounds towards zero
                if( dx[RIGHT] < 0 )
                {
                    dx[RIGHT] -= dy[RIGHT] - 1;
                }

                gdx[RIGHT] = dx[RIGHT] / dy[RIGHT];
                
                QUEUE_PXRX_DMA_TAG( __GlintTagdXSub, gdx[RIGHT] );

                // Work out number of scanlines to render
                if (npnt[LEFT]->y < npnt[RIGHT]->y)
                {
                    count = dy[LEFT];
                }
                else
                {
                    count = dy[RIGHT];
                }

                QUEUE_PXRX_DMA_TAG( __GlintTagCount, count );
                QUEUE_PXRX_DMA_TAG( __GlintTagRender, renderMsg );
                SEND_PXRX_DMA_BATCH;


                // With lots of luck, top trapezoid should be drawn now!
                // Repeatedly draw more trapezoids until points are equal
                // If y values are equal, then we can start again from
                // scratch. 

                while( (npnt[LEFT]    != npnt[RIGHT]) && 
                       (npnt[LEFT]->y != npnt[RIGHT]->y) ) 
                {
                    // Some continues are required for next rectangle
                    if( npnt[LEFT]->y < npnt[RIGHT]->y ) 
                    {
                        // We have reached npnt[LEFT]. npnt[RIGHT] is still ok
                        do 
                        {
                            pnt[LEFT] = npnt[LEFT];
                            npnt[LEFT] = pnt[LEFT] - 1;   

                            if (npnt[LEFT] < pptfxFirst)
                            {
                                npnt[LEFT] = pptfxLast;
                            }

                        } while( pnt[LEFT]->y == npnt[LEFT]->y );
                    
                        // We have a new npnt[LEFT] now.
                        DISPDBG((DBGLVL, "Dom: Top: x: %x y: %x "
                                         "    Next: x: %x y: %x x: %x y: %x", 
                                          pnt[LEFT]->x, pnt[LEFT]->y, 
                                          npnt[LEFT]->x, npnt[LEFT]->y, 
                                          npnt[RIGHT]->x, npnt[RIGHT]->y));

                        dx[LEFT] = (npnt[LEFT]->x - pnt[LEFT]->x) << 12;
                        dy[LEFT] = (npnt[LEFT]->y - pnt[LEFT]->y) >> 4;

                        // Need to ensure we round delta down. 
                        // divide rounds towards zero
                        if( dx[LEFT] < 0 )
                        {
                            dx[LEFT] -= dy[LEFT] - 1;
                        }

                        gdx[LEFT] = dx[LEFT] / dy[LEFT];

                        if( npnt[LEFT]->y < npnt[RIGHT]->y )
                        {
                            count = dy[LEFT];
                        }
                        else
                        {
                            count = (ABS(npnt[RIGHT]->y - pnt[LEFT]->y)) >> 4;
                        }

                        WAIT_PXRX_DMA_TAGS( 3 );
                        QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,        
                                        FIXtoFIXED(pnt[LEFT]->x) + xOffFixed );
                        QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,      gdx[LEFT] );
                        QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewDom, count );
                    } 
                    else 
                    {
                        // We have reached npnt[RIGHT]. npnt[LEFT] is still ok
                        do {
                            pnt[RIGHT] = npnt[RIGHT];
                            npnt[RIGHT] = pnt[RIGHT] + 1;     

                            if( npnt[RIGHT] > pptfxLast )
                            {
                                npnt[RIGHT] = pptfxFirst;
                            }

                        } while( pnt[RIGHT]->y == npnt[RIGHT]->y );

                        // We have a new npnt[RIGHT] now.
                        DISPDBG((DBGLVL, "Sub: Top: x: %x y: %x "
                                         "    Next: x: %x y: %x x: %x y: %x", 
                                         pnt[RIGHT]->x, pnt[RIGHT]->y, 
                                         npnt[LEFT]->x, npnt[LEFT]->y, 
                                         npnt[RIGHT]->x, npnt[RIGHT]->y));
        
                        dx[RIGHT] = (npnt[RIGHT]->x - pnt[RIGHT]->x) << 12;
                        dy[RIGHT] = (npnt[RIGHT]->y - pnt[RIGHT]->y) >> 4;

                        // Need to ensure we round delta down. 
                        // divide rounds towards zero
                        if( dx[RIGHT] < 0 )
                        {
                            dx[RIGHT] -= dy[RIGHT] - 1;
                        }

                        gdx[RIGHT] = dx[RIGHT] / dy[RIGHT];

                        if( npnt[RIGHT]->y < npnt[LEFT]->y )
                        {
                            count = dy[RIGHT];
                        }
                        else
                        {
                            count = (ABS(npnt[LEFT]->y - pnt[RIGHT]->y)) >> 4;
                        }

                        WAIT_PXRX_DMA_TAGS( 3 );
                        QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub,        
                                        FIXtoFIXED(pnt[RIGHT]->x) + xOffFixed );
                        QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,       gdx[RIGHT] );
                        QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub,   count );
                    }
                }

                // Repeatedly draw more trapezoids until points are equal
                // If y values are equal, then we can start again from
                // scratch. 
                if( npnt[LEFT] == npnt[RIGHT] )
                {
                    break;
                }
                
                WAIT_PXRX_DMA_TAGS( 7 ); // 7 entries needed to 
                                         // render first trapezoid
            }

    FinishedPolygon:

            if( !nClips-- )
            {
                break;
            }

            // entries needed to clip and render first trapezoid
            WAIT_PXRX_DMA_TAGS( 2 + 7 );
            
        } // while
    } // if

    DISPDBG((DBGLVL, "bGlintFastFillPolygon: returning TRUE"));

    // Need to send ContinueNewSub(0) to flush the framebuffer ??? //azn

    if( invalidatedFGBG ) 
    {
        WAIT_PXRX_DMA_DWORDS( 3 );
        QUEUE_PXRX_DMA_INDEX2( __GlintTagForegroundColor, 
                                        __GlintTagBackgroundColor );
        QUEUE_PXRX_DMA_DWORD( glintInfo->foregroundColour );
        QUEUE_PXRX_DMA_DWORD( glintInfo->backgroundColour );
    }

    if( (ppdev->cPelSize == GLINTDEPTH32) && invalidatedScissor ) 
    {
        WAIT_PXRX_DMA_TAGS( 1 );
        QUEUE_PXRX_DMA_TAG( __GlintTagScissorMaxXY, 0x7FFF7FFF );
    }

    SEND_PXRX_DMA_BATCH;

    return TRUE;

/******************************************************************************/

// This is the code to break the polygon into spans.
BreakIntoSpans:

    DISPDBG((DBGLVL, "Breaking into spans"));

    {
        LONG      yTrapezoid;   // Top scan for next trapezoid
        LONG      cyTrapezoid;  // Number of scans in current trapezoid
        POINTFIX* pptfxOld;     // Start point in current edge
        LONG      yStart;       // y-position of start point in current edge
        LONG      dM;           // Edge delta in FIX units in x direction
        LONG      dN;           // Edge delta in FIX units in y direction
        LONG      iEdge;
        LONG      lQuotient;
        LONG      lRemainder;
        LONG      i;
        EDGEDATA  aed[2];// DDA terms and stuff
        EDGEDATA* ped;
        LONG      tmpXl, tmpXr;
        DWORD     continueMessage = 0;

        // This span code cannot handle a clip list yet!
        if( !bTrivialClip )
        {
            return FALSE;
        }

        DISPDBG((DBGLVL, "Starting Spans Code"));

        /////////////////////////////////////////////////////////////////
        // Some Initialization

        yTrapezoid = (pptfxTop->y + 15) >> 4;

        // Make sure we initialize the DDAs appropriately:
        aed[LEFT].cy  = 0;
        aed[RIGHT].cy = 0;

        // For now, guess as to which is the left and which is the right edge:
        aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
        aed[RIGHT].dptfx = sizeof(POINTFIX);
        aed[LEFT].pptfx  = pptfxTop;
        aed[RIGHT].pptfx = pptfxTop;

        DISPDBG((DBGLVL, "bGlintFastFillPolygon: Polygon is renderable. "
                         "Go ahead and render"));

        // Work out offset to add to each of the coords downloaded to GLINT
        // To get correct results, we need to add on nearly one to each X
        // coordinate. 
        // Also add on offsets to bitmap (This might be an off screen bitmap)
        xOffFixed = INTtoFIXED(0);

        WAIT_PXRX_DMA_TAGS( 4 );
        QUEUE_PXRX_DMA_TAG( __GlintTagCount,    0 );
        QUEUE_PXRX_DMA_TAG( __GlintTagdXDom,    0 );
        QUEUE_PXRX_DMA_TAG( __GlintTagdXSub,    0);
        QUEUE_PXRX_DMA_TAG( __GlintTagdY,       INTtoFIXED(1));

        DISPDBG((DBGLVL, "Rendering Polygon"));

        nSpaces = 0;
NewTrapezoid:

        DISPDBG((DBGLVL, "New Trapezoid"));

        /////////////////////////////////////////////////////////////////
        // DDA initialization

        for( iEdge = 1; iEdge >= 0; iEdge-- ) 
        {
            ped = &aed[iEdge];
            if( ped->cy == 0 ) 
            {
                // Need a new DDA:
                do 
                {
                    cEdges--;
                    if( cEdges < 0 ) 
                    {
                        DISPDBG((DBGLVL, "bGlintFastFillPolygon: "
                                         "returning TRUE"));
                        return TRUE;
                    }

                    // Find the next left edge, accounting for wrapping:
                    pptfxOld = ped->pptfx;
                    ped->pptfx = (POINTFIX*)((BYTE*) ped->pptfx + ped->dptfx);

                    if( ped->pptfx < pptfxFirst )
                    {
                        ped->pptfx = pptfxLast;
                    }
                    else if( ped->pptfx > pptfxLast )
                    {
                        ped->pptfx = pptfxFirst;
                    }

                    // Have to find the edge that spans yTrapezoid:
                    ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                    // With fractional coordinate end points, we may get edges
                    // that don't cross any scans, in which case we try the
                    // next one:
                } while( ped->cy <= 0 );

                // 'pptfx' now points to the end point of the edge spanning
                // the scan 'yTrapezoid'.
                dN = ped->pptfx->y - pptfxOld->y;
                dM = ped->pptfx->x - pptfxOld->x;

                ASSERTDD(dN > 0, "Should be going down only");

                // Compute the DDA increment terms:
                if( dM < 0 ) 
                {
                    dM = -dM;
                    if( dM < dN ) 
                    {                        // Can't be '<='
                        ped->dx       = -1;
                        ped->lErrorUp = dN - dM;
                    } 
                    else 
                    {
                        QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                        ped->dx       = -lQuotient;        // - dM / dN
                        ped->lErrorUp = lRemainder;        // dM % dN
                        if( ped->lErrorUp > 0 ) 
                        {
                            ped->dx--;
                            ped->lErrorUp = dN - ped->lErrorUp;
                        }
                    }
                } 
                else 
                {
                    if( dM < dN ) 
                    {                        // Can't be '<='
                        ped->dx       = 0;
                        ped->lErrorUp = dM;
                    } 
                    else 
                    {
                        QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                        ped->dx       = lQuotient;        // dM / dN
                        ped->lErrorUp = lRemainder;        // dM % dN
                    }
                }

                ped->lErrorDown = dN; // DDA limit
                ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                      //  the ceiling, but subtract off dN so 
                                      //  that we can check the sign instead of 
                                      //  comparing to dN)

                ped->x = pptfxOld->x;
                yStart = pptfxOld->y;

                if( (yStart & 15) != 0 ) 
                {
                    // Advance to the next integer y coordinate
                    for( i = 16 - (yStart & 15); i != 0; i-- ) 
                    {
                        ped->x      += ped->dx;
                        ped->lError += ped->lErrorUp;
                        if( ped->lError >= 0 ) 
                        {
                            ped->lError -= ped->lErrorDown;
                            ped->x++;
                        }
                    }
                }

                if( (ped->x & 15) != 0 ) 
                {
                    ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                    ped->x += 15;    // We'll want the ceiling in just a bit...
                }

                // Chop off those fractional bits, convert to GLINT format
                // and add in the bitmap offset:
                ped->x = ped->x >> 4;
                ped->lError >>= 4;

                // Convert to GLINT format positions and deltas
                ped->x  = INTtoFIXED(ped->x) + xOffFixed;
                ped->dx = INTtoFIXED(ped->dx);
            }
        }

        cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // #scans in this trap
        aed[LEFT].cy  -= cyTrapezoid;
        aed[RIGHT].cy -= cyTrapezoid;
        yTrapezoid    += cyTrapezoid;                 // Top scan in next trap

        SETUP_COLOUR_STUFF;

        // If the left and right edges are vertical, simply output as
        // a rectangle:

        DISPDBG((DBGLVL, "Generate spans for glint"));

        do 
        {
            GetMoreFifoEntries( 4 );

            // Reset render position to the top of the trapezoid.
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom,    aed[RIGHT].x );
            QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub,    aed[LEFT].x );
            QUEUE_PXRX_DMA_TAG( __GlintTagStartY,       
                                    INTtoFIXED(yTrapezoid - cyTrapezoid) );
            QUEUE_PXRX_DMA_TAG( __GlintTagRender,       renderMsg );
            SEND_PXRX_DMA_BATCH;

            continueMessage = __GlintTagContinue;

            if( ((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
                ((aed[LEFT].dx       | aed[RIGHT].dx) == 0) &&
                (cyTrapezoid > 1) ) 
            {
                //////////////////////////////////////////////////////////////
                // Vertical-edge special case

                DISPDBG((DBGLVL, "Vertical Edge Special Case"));

                GetMoreFifoEntries( 1 );
                QUEUE_PXRX_DMA_TAG( continueMessage, cyTrapezoid );

                continue;
            }

            while( TRUE ) 
            {
                //////////////////////////////////////////////////////////////
                // Run the DDAs

                DISPDBG((DBGLVL, "Doing a span 0x%x to 0x%x, 0x%x scans left. "
                            "Continue %s",
                            aed[LEFT].x, aed[RIGHT].x, cyTrapezoid,
                            (continueMessage == __GlintTagContinueNewDom) ? "NewDom" :
                            ((continueMessage == __GlintTagContinue) ? "" : "NewSub")));

                GetMoreFifoEntries( 1 );
                QUEUE_PXRX_DMA_TAG( continueMessage, 1 );

                // We have finished this trapezoid. Go get the next one!

                // Advance the right wall:
                tmpXr = aed[RIGHT].x;
                aed[RIGHT].x      += aed[RIGHT].dx;
                aed[RIGHT].lError += aed[RIGHT].lErrorUp;

                if( aed[RIGHT].lError >= 0 ) 
                {
                    aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                    aed[RIGHT].x += INTtoFIXED(1);
                }

                // Advance the left wall:
                tmpXl = aed[LEFT].x;
                aed[LEFT].x      += aed[LEFT].dx;
                aed[LEFT].lError += aed[LEFT].lErrorUp;

                if( aed[LEFT].lError >= 0 ) 
                {
                    aed[LEFT].lError -= aed[LEFT].lErrorDown;
                    aed[LEFT].x += INTtoFIXED(1);
                }

                if( --cyTrapezoid == 0 )
                {
                    break;
                }

                // Setup the GLINT X registers if we have changed either end.
                if( tmpXr != aed[RIGHT].x ) 
                {
                    if( tmpXl != aed[LEFT].x ) 
                    {
                        GetMoreFifoEntries( 3 );

                        QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, aed[LEFT].x );
                        QUEUE_PXRX_DMA_TAG( __GlintTagContinueNewSub,   0 );
                    } 
                    else 
                    {
                        GetMoreFifoEntries( 1 );
                    }
                    QUEUE_PXRX_DMA_TAG( __GlintTagStartXDom, aed[RIGHT].x );
                    continueMessage = __GlintTagContinueNewDom;                
                } 
                else if( tmpXl != aed[LEFT].x ) 
                {
                    GetMoreFifoEntries( 1 );
                    QUEUE_PXRX_DMA_TAG( __GlintTagStartXSub, aed[LEFT].x );
                    continueMessage = __GlintTagContinueNewSub;
                }                
            }
        } while( 0 );

        DISPDBG((DBGLVL, "Generate spans for glint done"));
        goto NewTrapezoid;
    }

    if( invalidatedFGBG ) 
    {
        WAIT_PXRX_DMA_DWORDS( 3 );
        QUEUE_PXRX_DMA_INDEX2( __GlintTagForegroundColor, 
                                            __GlintTagBackgroundColor );
        QUEUE_PXRX_DMA_DWORD( glintInfo->foregroundColour );
        QUEUE_PXRX_DMA_DWORD( glintInfo->backgroundColour );
    }

    SEND_PXRX_DMA_BATCH;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\registry.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: registry.c
*
* Content: Routines to initialize the registry and lookup string values.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"

/******************************Public*Data*Struct**************************\
* BOOL bGlintQueryRegistryValueUlong
*
* Take a string and look up its value in the registry. We assume that the
* value fits into 4 bytes. Fill in the supplied DWORD pointer with the value.
*
* Returns:
*   TRUE if we found the string, FALSE if not. Note, if we failed to init
*   the registry the query funtion will simply fail and we act as though
*   the string was not defined.
*
\**************************************************************************/

BOOL
bGlintQueryRegistryValueUlong(PPDEV ppdev, LPWSTR valueStr, PULONG pData)
{
    ULONG ReturnedDataLength;
    ULONG inSize;
    ULONG outData;
    PWCHAR inStr;
    
    // get the string length including the NULL
    for (inSize = 2, inStr = valueStr; *inStr != 0; ++inStr, inSize += 2);

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_REGISTRY_DWORD,
                           valueStr,                        // input buffer
                           inSize,
                           &outData,                        // output buffer
                           sizeof(ULONG),
                           &ReturnedDataLength))
    {
        DISPDBG((WRNLVL, "bGlintQueryRegistryValueUlong failed"));
        return(FALSE);
    }
    
    *pData = outData;
    DISPDBG((DBGLVL, "bGlintQueryRegistryValueUlong "
                     "returning 0x%x (ReturnedDataLength = %d)",
                     *pData, ReturnedDataLength));
    return(TRUE);
}

//@@BEGIN_DDKSPLIT
#if 0
/******************************Public*Data*Struct**************************\
* BOOL bGlintRegistryRetrieveGammaLUT
*
* Look up the registry to reload the saved gamma LUT into memory.
*
* Returns:
*   TRUE if we found the string, FALSE if not. Note, if we failed to init
*   the registry the query funtion will simply fail and we act as though
*   the string was not defined.
*
\**************************************************************************/

BOOL
bGlintRegistryRetrieveGammaLUT(
    PPDEV ppdev,
    PVIDEO_CLUT pScreenClut
    )
{
    ULONG ReturnedDataLength;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT,
                           NULL,         // input buffer
                           0,
                           pScreenClut,  // output buffer
                           MAX_CLUT_SIZE,
                           &ReturnedDataLength))
    {
        DISPDBG((-1, "IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT failed"));
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Data*Struct**************************\
* BOOL bGlintRegistrySaveGammaLUT
*
* Save the gamma lut in the registry for later reloading.
*
* Returns:
*   TRUE if we found the string, FALSE if not. Note, if we failed to init
*   the registry the query funtion will simply fail and we act as though
*   the string was not defined.
*
\**************************************************************************/

BOOL
bGlintRegistrySaveGammaLUT(
    PPDEV ppdev,
    PVIDEO_CLUT pScreenClut
    )
{
    ULONG ReturnedDataLength;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_REG_SAVE_GAMMA_LUT,
                           pScreenClut,  // input buffer
                           MAX_CLUT_SIZE,
                           NULL,         // output buffer
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((-1, "IOCTL_VIDEO_REG_SAVE_GAMMA_LUT failed"));
        return(FALSE);
    }

    return(TRUE);
}

ULONG
GetOGLDriverVersion(PPDEV ppdev)
{
    return(2);
}
#endif
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\textout.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: textout.c
*
* Content: 
*
* glyph rendering module. Uses glyph caching for P3 and
* glyph expansion for older Glint series accelerators.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//@@BEGIN_DDKSPLIT
//
// There are three basic methods for drawing text with hardware
// acceleration:
//
// 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
//       (probably in off-screen memory), and text is drawn by
//       referring the hardware to the cached glyph locations.
//
// 2) Glyph expansion -- Each individual glyph is colour-expanded
//       directly to the screen from the monochrome glyph bitmap
//       supplied by GDI.
//
// 3) Buffer expansion -- The CPU is used to draw all the glyphs into
//       a 1bpp monochrome bitmap, and the hardware is then used
//       to colour-expand the result.
//
// The fastest method depends on a number of variables, such as the
// colour expansion speed, bus speed, CPU speed, average glyph size,
// and average string length.
//
// For the S3 with normal sized glyphs, I've found that caching the
// glyphs in off-screen memory is typically the slowest method.
// Buffer expansion is typically fastest on the slow ISA bus (or when
// memory-mapped I/O isn't available on the x86), and glyph expansion
// is best on fast buses such as VL and PCI.
//
// Glyph expansion is typically faster than buffer expansion for very
// large glyphs, even on the ISA bus, because less copying by the CPU
// needs to be done.  Unfortunately, large glyphs are pretty rare.
//
// An advantange of the buffer expansion method is that opaque text will
// never flash -- the other two methods typically need to draw the
// opaquing rectangle before laying down the glyphs, which may cause
// a flash if the raster is caught at the wrong time.
//
//@@END_DDKSPLIT

#include "precomp.h"
#include "pxrx.h"

//*********************************************************************************************
// FUNC: vPxRxClipSolid
// ARGS: ppdev (I) - pointer to physical device object
//       crcl (I) - number of rectangles
//       prcl (I) - array of rectangles
//       iColor (I) - the solid fill color
//       pco (I) - pointer to the clip region object
// RETN: void
//---------------------------------------------------------------------------------------------
// Fill a series of rectangles clipped by pco with a solid color. This function should only
// be called when the clipping operation is non-trivial
//*********************************************************************************************

VOID vPxRxClipSolid(PDEV* ppdev, LONG crcl, RECTL* prcl, ULONG iColor, CLIPOBJ* pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;
    GLINT_DECL;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL), "Expected a non-null clip object");

    rbc.iSolidColor = iColor;

    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            ppdev->pgfnFillSolid(ppdev, crcl, prcl, __GLINT_LOGICOP_COPY, 
                                                    __GLINT_LOGICOP_COPY, rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill
        iLastBottom = prcl[crcl - 1].bottom;

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        do  {

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    return; // Past last fill rectangle; nothing left to do
                }

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i--; prclTmp++)
                    {
                        // Intersect fill and clip rectangles
                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:
                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects
                    if (crclTmp)
                    {
                        ppdev->pgfnFillSolid(ppdev, crclTmp, &arclTmp[0],
                                              __GLINT_LOGICOP_COPY, __GLINT_LOGICOP_COPY, rbc, NULL);
                    }
                }
            }
        }  while(bMore);
    }
}

//*********************************************************************************************
// FUNC: bPxRxUncachedText
// ARGS: ppdev (I) - pointer to physical device object
//         pgp (I) - array of glyphs to render
//       cGlyph (I) - number of glyphs to render
//       ulCharInc (I) - fixed character spacing increment (0 if proportional font)
// RETN: TRUE if glyphs were rendered
//---------------------------------------------------------------------------------------------
// Renders an array of proportional or monospaced glyphs. This function requires RasterizerMode
// to be set-up to correctly byteswap and mirror bitmasks.
// NB. currently render to cxGlyphAligned rather than cxGlyph, this saves a lot of work on the
//     host but probably costs, on average, four bits per glyph row; as this is a fallback
//     routine I've not investigated whether this method is optimal.
//*********************************************************************************************

BOOL bPxRxUncachedText(PDEV* ppdev, GLYPHPOS* pgp, LONG cGlyph, ULONG ulCharInc)
{
    GLYPHBITS   *pgb;
    LONG        cxGlyph, cyGlyph, cxGlyphAligned;
    LONG        x, y;
    ULONG       *pulGlyph;
    LONG        cjGlyph;
    LONG        culGlyph;
    LONG        cjGlyphRem;
    LONG        cj;
    ULONG       ul;
    GLINT_DECL;

    DISPDBG((7, "bPxRxUncachedText: entered"));

    if (ulCharInc)
    {
        x = pgp->ptl.x + pgp->pgdf->pgb->ptlOrigin.x - ulCharInc;
        y = pgp->ptl.y + pgp->pgdf->pgb->ptlOrigin.y;
    }

    for ( ; --cGlyph >= 0; ++pgp)
    {
        pgb = pgp->pgdf->pgb;
        if (ulCharInc)
        {
            x += ulCharInc;
        }
        else
        {
            x = pgp->ptl.x + pgb->ptlOrigin.x;
            y = pgp->ptl.y + pgb->ptlOrigin.y;
        }

        cyGlyph = pgb->sizlBitmap.cy;
        cxGlyph = pgb->sizlBitmap.cx;
        cxGlyphAligned = ((cxGlyph + 7 ) & ~7);

        // Render2D turns on FastFillEnable which is incompatible with PackedBitMasks

        WAIT_PXRX_DMA_TAGS(4);

        QUEUE_PXRX_DMA_TAG( __GlintTagRectanglePosition, MAKEDWORD_XY(x, y));
        QUEUE_PXRX_DMA_TAG( __GlintTagRender2D,          __RENDER2D_INCX | __RENDER2D_INCY |
                                                         __RENDER2D_OP_SYNCBITMASK |
                                                         __RENDER2D_WIDTH(cxGlyphAligned) |
                                                         __RENDER2D_HEIGHT(0));
        QUEUE_PXRX_DMA_TAG(__GlintTagCount,              cyGlyph);
        QUEUE_PXRX_DMA_TAG(__GlintTagRender,             __RENDER_TRAPEZOID_PRIMITIVE |
                                                         __RENDER_SYNC_ON_BIT_MASK);

        pulGlyph   = (ULONG *)pgb->aj;
        cjGlyph    = (cxGlyphAligned >> 3) * cyGlyph;
        culGlyph   = cjGlyph >> 2;
        cjGlyphRem = cjGlyph & 3;

        ul = culGlyph + (cjGlyphRem != 0);
        WAIT_PXRX_DMA_DWORDS(ul + 1);
        QUEUE_PXRX_DMA_HOLD(__GlintTagBitMaskPattern, ul);

        for ( ; --culGlyph >= 0; ++pulGlyph)
        {
            QUEUE_PXRX_DMA_DWORD(*pulGlyph);
        }

        if (cjGlyphRem)
        {
            for (ul = cj = 0; cj < cjGlyphRem; ++cj, ++(BYTE *)pulGlyph)
            {
                ul |= ((ULONG)(*(BYTE *)pulGlyph)) << (cj << 3);
            }
            QUEUE_PXRX_DMA_DWORD(ul);
        }
    }

    // The rasterizer's set-up to expect a continue after each Render command (NB. but not Render2D, etc),
    // so it won't flush the text to the framebuffer unless we specifically tell it to

    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagContinueNewSub, 0);

    DISPDBG((7, "bPxRxUncachedText: exited"));
    return(TRUE);
}

//*********************************************************************************************
// FUNC: bPxRxUncachedClippedText
// ARGS: ppdev (I) - pointer to physical device object
//         pgp (I) - array of glyphs to render
//       cGlyph (I) - number of glyphs to render
//       ulCharInc (I) - fixed character spacing increment (0 if proportional font)
//       pco (I) - pointer to the clip region object
// RETN: TRUE if glyphs were rendered
//---------------------------------------------------------------------------------------------
// Renders an array of proportional or monospaced glyphs. This function requires RasterizerMode
// to be set-up to correctly byteswap and mirror bitmasks.
// NB. currently render to cxGlyphAligned rather than cxGlyph, this saves a lot of work on the
//     host but probably costs, on average, four bits per glyph row; as this is a fallback
//     routine I've not investigated whether this method is optimal.
//*********************************************************************************************

BOOL bPxRxUncachedClippedText(PDEV* ppdev, GLYPHPOS* pgp, LONG cGlyph, ULONG ulCharInc, CLIPOBJ *pco)
{
    GLYPHBITS   *pgb;
    LONG        cxGlyph, cyGlyph, cxGlyphAligned;
    LONG        x, y;
    ULONG       *pulGlyph;
    LONG        cjGlyph;
    LONG        culGlyph;
    LONG        cjGlyphRem;
    LONG        cj;
    ULONG       ul;
    LONG        cGlyphOriginal = 0;
    GLYPHPOS    *pgpOriginal = NULL;
    BOOL        bMore, invalidatedScissor = FALSE;
    CLIPENUM    ce;
    RECTL       *prclClip;
    BOOL        bClipSet;
    GLINT_DECL;

    DISPDBG((7, "bPxRxUncachedClippedText: entered"));

    if (pco->iDComplexity == DC_RECT)
    {
        bMore    = FALSE;
        ce.c     = 1;
        prclClip = &pco->rclBounds;

        goto SingleRectangle;
    }

    cGlyphOriginal  = cGlyph;
    pgpOriginal     = pgp;

    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
    do {
        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

        for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
        {
            cGlyph = cGlyphOriginal;
            pgp = pgpOriginal;

        SingleRectangle:
            bClipSet = FALSE;

            if (ulCharInc)
            {
                x = pgp->ptl.x + pgp->pgdf->pgb->ptlOrigin.x - ulCharInc;
                y = pgp->ptl.y + pgp->pgdf->pgb->ptlOrigin.y;
            }

            for ( ; --cGlyph >= 0; ++pgp)
            {
                pgb = pgp->pgdf->pgb;
                if(ulCharInc)
                {
                    x += ulCharInc;
                }
                else
                {
                    x = pgp->ptl.x + pgb->ptlOrigin.x;
                    y = pgp->ptl.y + pgb->ptlOrigin.y;
                }

                cyGlyph = pgb->sizlBitmap.cy;
                cxGlyph = pgb->sizlBitmap.cx;
                cxGlyphAligned = ((cxGlyph + 7 ) & ~7);

                if ((prclClip->right  > x)           && (prclClip->bottom > y) &&
                    (prclClip->left   < x + cxGlyph) && (prclClip->top    < y + cyGlyph))
                {
                    // Lazily set the hardware clipping:
                    if(!bClipSet)
                    {
                        WAIT_PXRX_DMA_TAGS(3);
                        QUEUE_PXRX_DMA_TAG(__GlintTagScissorMinXY, (prclClip->top << SCISSOR_YOFFSET) |
                                                                   (prclClip->left << SCISSOR_XOFFSET));
                        QUEUE_PXRX_DMA_TAG(__GlintTagScissorMaxXY, (prclClip->bottom << SCISSOR_YOFFSET) |
                                                                   (prclClip->right << SCISSOR_XOFFSET));
                        QUEUE_PXRX_DMA_TAG(__GlintTagScissorMode,  (USER_SCISSOR_ENABLE | SCREEN_SCISSOR_DEFAULT));
                        invalidatedScissor = TRUE;

                        bClipSet = TRUE;
                    }

                    // Render2D turns on FastFillEnable which is incompatible with PackedBitMasks

                    WAIT_PXRX_DMA_TAGS(4);
                    QUEUE_PXRX_DMA_TAG(__GlintTagRectanglePosition, MAKEDWORD_XY(x, y));
                    QUEUE_PXRX_DMA_TAG(__GlintTagRender2D,          __RENDER2D_INCX |
                                                                    __RENDER2D_INCY |
                                                                    __RENDER2D_OP_SYNCBITMASK |
                                                                    __RENDER2D_WIDTH(cxGlyphAligned) |
                                                                    __RENDER2D_HEIGHT(0));
                    QUEUE_PXRX_DMA_TAG(__GlintTagCount,             cyGlyph);
                    QUEUE_PXRX_DMA_TAG(__GlintTagRender,            __RENDER_TRAPEZOID_PRIMITIVE |
                                                                    __RENDER_SYNC_ON_BIT_MASK);

                    pulGlyph   = (ULONG *)pgb->aj;
                    cjGlyph    = (cxGlyphAligned >> 3) * cyGlyph;
                    culGlyph   = cjGlyph >> 2;
                    cjGlyphRem = cjGlyph & 3;

                    ul = culGlyph + (cjGlyphRem != 0);
                    WAIT_PXRX_DMA_DWORDS(ul + 1);
                    QUEUE_PXRX_DMA_HOLD(__GlintTagBitMaskPattern, ul);

                    for ( ; --culGlyph >= 0; ++pulGlyph)
                    {
                        QUEUE_PXRX_DMA_DWORD(*pulGlyph);
                    }

                    if (cjGlyphRem)
                    {
                        for (ul = cj = 0; cj < cjGlyphRem; ++cj, ++(BYTE *)pulGlyph)
                        {
                            ul |= ((ULONG)(*(BYTE *)pulGlyph)) << (cj << 3);
                        }
                        QUEUE_PXRX_DMA_DWORD(ul);
                    }
                }
            }
        }
    } while(bMore);

    // reset clipping

    if (invalidatedScissor)
    {
        glintInfo->config2D |= __CONFIG2D_USERSCISSOR;

        WAIT_PXRX_DMA_TAGS(1);
        QUEUE_PXRX_DMA_TAG(__GlintTagScissorMaxXY, 0x7FFF7FFF);
    }

    // The rasterizer's set-up to expect a continue after each Render command (NB. but not Render2D, etc),
    // so it won't flush the text to the framebuffer unless we specifically tell it to

    WAIT_PXRX_DMA_TAGS(1);
    QUEUE_PXRX_DMA_TAG(__GlintTagContinueNewSub, 0);

    DISPDBG((7, "bPxRxUncachedClippedText: exited"));
    return(TRUE);
}

//*********************************************************************************************
// FUNC: DrvTextOut
// ARGS: pso (I) - pointer to surface object to render to
//       pstro (I) - pointer to the string object to be rendered
//       pfo (I) - pointer to the font object
//       pco (I) - pointer to the clip region object
//       prclExtra (I) - If we had set GCAPS_HORIZSTRIKE, we would have to fill these extra
//                       rectangles (it is used  largely for underlines). It's not a big
//                       performance win (GDI will call our DrvBitBlt to draw these).
//       prclOpaque (I) - pointer to the opaque background rectangle
//       pboFore (I) - pointer to the foreground brush object
//       pboOpaque (I) - pointer to the brush for the opaque background rectangle
//       pptlBrush (I) - pointer to the brush origin, Always unused, unless 
//                       GCAPS_ARBRUSHOPAQUE set
//       mix (I) - should always be a COPY operation
// RETN: TRUE - pstro glyphs have been rendered
//---------------------------------------------------------------------------------------------
// GDI calls this function when it has strings it wants us to render: this function should be
// exported in 'enable.c'.
//*********************************************************************************************

BOOL DrvTextOut(SURFOBJ* pso, STROBJ* pstro, FONTOBJ* pfo, CLIPOBJ* pco, RECTL* prclExtra,
                RECTL* prclOpaque, BRUSHOBJ* pboFore, BRUSHOBJ* pboOpaque, POINTL* pptlBrush, 
                MIX mix)
{
    PDEV*           ppdev;
    LONG            xOff;
    DSURF*          pdsurf;
    OH*             poh;
    ULONG           renderBits;
    ULONG           ulColor;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    RECTL           rclOpaque;
    BOOL            bRet = TRUE;
    GLINT_DECL_VARS;

    pdsurf = (DSURF*) pso->dhsurf;
    ppdev  = (PDEV*) pso->dhpdev;

    REMOVE_SWPOINTER(pso);

    if (pdsurf->dt & DT_SCREEN)
    {
        GLINT_DECL_INIT;

        SETUP_PPDEV_OFFSETS(ppdev, pdsurf);
        xOff = ppdev->xOffset = pdsurf->poh->x;

        VALIDATE_DD_CONTEXT;

        DISPDBG((9, "DrvTextOut: ppdev = %p pso->dhsurf->dt == %d", ppdev, pdsurf->dt));

        // The DDI spec says we'll only ever get foreground and background mixes of R2_COPYPEN:

        ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

        if (glintInfo->WriteMask != 0xffffffff)
        {
            // the texture unit requires all 32bpp of pixel data, so if we've got the upper
            // 8 bits masked out for overlays we need to reenable these bits temporarily
            WAIT_PXRX_DMA_TAGS(1);
            glintInfo->WriteMask = 0xffffffff;
            QUEUE_PXRX_DMA_TAG(__GlintTagFBHardwareWriteMask, 0xffffffff);
        }

        iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        if (prclOpaque != NULL)
        {
            int x,y,cx,cy;
            RBRUSH_COLOR rbc;

            ////////////////////////////////////////////////////////////
            // Opaque Initialization
            ////////////////////////////////////////////////////////////

            if (iDComplexity == DC_TRIVIAL)
            {
        DrawOpaqueRect:
                rbc.iSolidColor = pboOpaque->iSolidColor;
                ppdev->pgfnFillSolid(ppdev, 1, prclOpaque, __GLINT_LOGICOP_COPY, __GLINT_LOGICOP_COPY, rbc, NULL);
            }
            else if (iDComplexity == DC_RECT)
            {
                DISPDBG((7, "DrvTextOut: drawing opaquing rect with rectangular clipping"));
                if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
                {
                    prclOpaque = &rclOpaque;
                    goto DrawOpaqueRect;
                }
            }
            else
            {
                // vPxRxClipSolid modifies the rect list we pass in but prclOpaque
                // is probably a GDI structure so don't change it. This is also
                // necessary for multi-headed drivers.
                RECTL   tmpOpaque = *prclOpaque;

                DISPDBG((7, "DrvTextOut: drawing opaquing rect with complex clipping"));

                vPxRxClipSolid(ppdev, 1, &tmpOpaque, pboOpaque->iSolidColor, pco);
            }
        }

        if (prclOpaque == NULL)
        {
            // opaque initialization would have ensured the registers were correctly 
            // set up for a solid fill, without it we'll need to perform our own
            // initialization.

            SET_WRITE_BUFFERS;
            WAIT_PXRX_DMA_TAGS(1);
            LOAD_CONFIG2D(__CONFIG2D_CONSTANTSRC | __CONFIG2D_FBWRITE);
        }

        ////////////////////////////////////////////////////////////
        // Transparent Initialization
        ////////////////////////////////////////////////////////////

        ulColor = pboFore->iSolidColor;
        WAIT_PXRX_DMA_TAGS(1);
        LOAD_FOREGROUNDCOLOUR( ulColor );

        STROBJ_vEnumStart(pstro);

        do {
            if (pstro->pgp != NULL)
            {
                // There's only the one batch of glyphs, so save ourselves a call:
                pgp         = pstro->pgp;
                cGlyph      = pstro->cGlyphs;
                bMoreGlyphs = FALSE;
            }
            else
            {
                // never get here in WinBench97 business graphics
                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
            }

            if (cGlyph > 0)
            {
                // fall back to uncached rendering

                if (iDComplexity == DC_TRIVIAL)
                {
                    bRet = bPxRxUncachedText(ppdev, pgp, cGlyph, pstro->ulCharInc);
                }
                else
                {
                    bRet = bPxRxUncachedClippedText(ppdev, pgp, cGlyph, pstro->ulCharInc, pco);
                }
            }
        } while (bMoreGlyphs && bRet);

        if(glintInfo->DefaultWriteMask != 0xffffffff)
        {
            WAIT_PXRX_DMA_TAGS(1);
            glintInfo->WriteMask = glintInfo->DefaultWriteMask;
            QUEUE_PXRX_DMA_TAG(__GlintTagFBHardwareWriteMask, glintInfo->DefaultWriteMask);
        }

        SEND_PXRX_DMA_QUERY;
    }
    else
    {
        // We're drawing to a DFB we've converted to a DIB, so just call GDI
        // to handle it:
        return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                        pboFore, pboOpaque, pptlBrush, mix));
    }

    DISPDBG((9, "DrvTextOut: exiting"));
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\bitmac2.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: bitmac2.h
*
* Content: Permedia3 macros to set bits in hw registers
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// The macros in this file are used from the 2D side to correctly shift values
// into the correct place in the register.  The values passed to these macros
// are in glintdef.h and pmdef.h, and p3rxdef.h

#ifndef __BITMAC2
#define __BITMAC2

// *******************************************************************
// Permedia Bit Field Macros

// FBReadMode 
#define PM_FBREADMODE_PARTIAL(a)                            (a << 0)
#define PM_FBREADMODE_READSOURCE(a)                         (a << 9)
#define PM_FBREADMODE_READDEST(a)                           (a << 10)
#define PM_FBREADMODE_DATATYPE(a)                           (a << 15)
#define PM_FBREADMODE_WINDOWORIGIN(a)                       (a << 16)
#define PM_FBREADMODE_TEXELINHIBIT(a)                       (a << 17)
#define PM_FBREADMODE_PATCHENABLE(a)                        (a << 18)
#define PM_FBREADMODE_PACKEDDATA(a)                         (a << 19)
#define PM_FBREADMODE_RELATIVEOFFSET(a)                     (a << 20)
#define PM_FBREADMODE_SCANLINEINTERVAL(a)                   (a << 23)
#define PM_FBREADMODE_PARTIAL3(a)                           (a << 25)
#define PM_FBREADMODE_PATCHMODE(a)                          (a << 25)
#define PM_FBREADMODE_SOURCEADDRESS(a)                      (a << 28)

// FBWriteMode
#define PM_FBWRITEMODE_ENABLE(a)                            (a << 0)
#define PM_FBWRITEMODE_UPLOADDATA(a)                        (a << 3)

// Texture Address mode
#define PM_TEXADDRESSMODE_ENABLE(a)                         (a << 0)
#define PM_TEXADDRESSMODE_PERSPECTIVE(a)                    (a << 1)

// Texture read mode
#define PM_TEXREADMODE_ENABLE(a)                            (a << 0)
#define PM_TEXREADMODE_SWRAP(a)                             (a << 1)
#define PM_TEXREADMODE_TWRAP(a)                             (a << 3)
#define PM_TEXREADMODE_WIDTH(a)                             (a << 9)
#define PM_TEXREADMODE_HEIGHT(a)                            (a << 13)
#define PM_TEXREADMODE_FILTER(a)                            (a << 17)
#define PM_TEXREADMODE_PACKEDDATA(a)                        (a << 24)

// TextureColorMode
#define PM_TEXCOLORMODE_ENABLE(a)                           (a << 0)
#define PM_TEXCOLORMODE_APPLICATIONMODE(a)                  (a << 1)
#define PM_TEXCOLORMODE_TEXTURETYPE(a)                      (a << 4)
#define PM_TEXCOLORMODE_KDDDA(a)                            (a << 5)
#define PM_TEXCOLORMODE_KSDDA(a)                            (a << 6)

// TextureDataFormat
#define PM_TEXDATAFORMAT_FORMAT(a)                          (a << 0)
#define PM_TEXDATAFORMAT_NOALPHABUFFER(a)                   (a << 4)
#define PM_TEXDATAFORMAT_COLORORDER(a)                      (a << 5)
#define PM_TEXDATAFORMAT_FORMATEXTENSION(a)                 (a << 6)
#define PM_TEXDATAFORMAT_ALPHAMAP(a)                        (a << 7)
#define PM_TEXDATAFORMAT_SPANFORMAT(a)                      (a << 9)

// PackedDataLimits
#define PM_PACKEDDATALIMITS_OFFSET(a)                       (a << 29)
#define PM_PACKEDDATALIMITS_XSTART(a)                       (a << 0)
#define PM_PACKEDDATALIMITS_XEND(a)                         (a << 16)

// Window Register
#define PM_WINDOW_FORCELBUPDATE(a)                          (a << 3)
#define PM_WINDOW_LBUPDATESOURCE(a)                         (a << 4)
#define PM_WINDOW_DISABLELBUPDATE(a)                        (a << 18)

// Colors
#define PM_BYTE_COLOR(a)                                    (a << 15);

// VideoPort Registers

// Video Signal Config
#define PM_VSCONFIG_UNITMODE(a)                             ((a) << 0)
#define PM_VSCONFIG_GPMODE_A(a)                             ((a) << 3)
#define PM_VSCONFIG_ROMPULSE(a)                             ((a) << 4)
// Stream A
#define PM_VSCONFIG_HREF_POL_A(a)                           ((a) << 9)
#define PM_VSCONFIG_VREF_POL_A(a)                           ((a) << 10)
#define PM_VSCONFIG_VACTIVE_POLA(a)                         ((a) << 11)
#define PM_VSCONFIG_USEFIELD_A(a)                           ((a) << 12)
#define PM_VSCONFIG_FIELD_POL_A(a)                          ((a) << 13)
#define PM_VSCONFIG_FIELD_EDGE_A(a)                         ((a) << 14)
#define PM_VSCONFIG_VACTIVE_VBI_A(a)                        ((a) << 15)
#define PM_VSCONFIG_INTERLACE_A(a)                          ((a) << 16)
#define PM_VSCONFIG_REVERSEDATA_A(a)                        ((a) << 17)
// Stream B
#define PM_VSCONFIG_HREF_POL_B(a)                           ((a) << 18)
#define PM_VSCONFIG_VREF_POL_B(a)                           ((a) << 19)
#define PM_VSCONFIG_VACTIVE_POLB(a)                         ((a) << 20)
#define PM_VSCONFIG_USEFIELD_B(a)                           ((a) << 21)
#define PM_VSCONFIG_FIELD_POL_B(a)                          ((a) << 22)
#define PM_VSCONFIG_FIELD_EDGE_B(a)                         ((a) << 23)
#define PM_VSCONFIG_VACTIVE_VBI_B(a)                        ((a) << 24)
#define PM_VSCONFIG_INTERLACE_B(a)                          ((a) << 25)
#define PM_VSCONFIG_COLORSPACE_B(a)                         ((a) << 26)
#define PM_VSCONFIG_REVERSEDATA_B(a)                        ((a) << 27)
#define PM_VSCONFIG_DOUBLEEDGE_B(a)                         ((a) << 28)

// Video Signal Status
// Macros for getting individual states
#define PM_GET_VSSTATUS_GPBUSTIMEOUT(a)           ((a & (1 << 0)) >> 0)
#define PM_GET_VSSTATUS_FIFOOVERFLOW_A(a)         ((a & (1 << 8)) >> 8)
#define PM_GET_VSSTATUS_FIELDONE0_A(a)            ((a & (1 << 9)) >> 9)
#define PM_GET_VSSTATUS_FIELDONE1_A(a)            ((a & (1 << 10)) >> 10)
#define PM_GET_VSSTATUS_FIELDONE2_A(a)            ((a & (1 << 11)) >> 11)
#define PM_GET_VSSTATUS_INVALIDINTERLACE_A(a)     ((a & (1 << 12)) >> 12)
#define PM_GET_VSSTATUS_FIFOUNDERFLOW_B(a)        ((a & (1 << 16)) >> 16)
#define PM_GET_VSSTATUS_FIELDONE0_B(a)            ((a & (1 << 17)) >> 17)
#define PM_GET_VSSTATUS_FIELDONE1_B(a)            ((a & (1 << 18)) >> 18)
#define PM_GET_VSSTATUS_FIELDONE2_B(a)            ((a & (1 << 19)) >> 19)
#define PM_GET_VSSTATUS_INVALIDINTERLACE_B(a)     ((a & (1 << 20)) >> 20)
// Macros for setting individual states
#define PM_SET_VSSTATUS_GPBUSTIMEOUT(a)                     (a << 0)
#define PM_SET_VSSTATUS_FIFOOVERFLOW_A(a)                   (a << 8)
#define PM_SET_VSSTATUS_FIFOUNDERFLOW_B(a)                  (a << 16)

// Serial Bus Control
// Get state
#define PM_GET_VSSERIALBUS_DATAIN(a)                ((a & (1 << 0)) >> 0)
#define PM_GET_VSSERIALBUS_CLKIN(a)                 ((a & (1 << 1)) >> 1)
#define PM_GET_VSSERIALBUS_DATAOUT(a)               ((a & (1 << 2)) >> 2)
#define PM_GET_VSSERIALBUS_CLKOUT(a)                ((a & (1 << 3)) >> 3)
#define PM_GET_VSSERIALBUS_LATCHEDDATA(a)           ((a & (1 << 4)) >> 4)
#define PM_GET_VSSERIALBUS_DATAVALID(a)             ((a & (1 << 5)) >> 5)
#define PM_GET_VSSERIALBUS_START(a)                 ((a & (1 << 6)) >> 6)
#define PM_GET_VSSERIALBUS_STOP(a)                  ((a & (1 << 7)) >> 7)
#define PM_GET_VSSERIALBUS_WAIT(a)                  ((a & (1 << 8)) >> 8)
// Set State
#define PM_SET_VSSERIALBUS_DATAOUT(a)                       (a << 2)
#define PM_SET_VSSERIALBUS_CLKOUT(a)                        (a << 3)
#define PM_SET_VSSERIALBUS_LATCHEDDATA(a)                   (a << 4)
#define PM_SET_VSSERIALBUS_DATAVALID(a)                     (a << 5)
#define PM_SET_VSSERIALBUS_START(a)                         (a << 6)
#define PM_SET_VSSERIALBUS_STOP(a)                          (a << 7)
#define PM_SET_VSSERIALBUS_WAIT(a)                          (a << 8)

// Video Stream A Control
#define PM_VSACONTROL_VIDEO(a)                              ((a) << 0)
#define PM_VSACONTROL_VBI(a)                                ((a) << 1)
#define PM_VSACONTROL_BUFFER(a)                             ((a) << 2)
#define PM_VSACONTROL_SCALEX(a)                             ((a) << 3)
#define PM_VSACONTROL_SCALEY(a)                             ((a) << 5)
#define PM_VSACONTROL_MIRRORX(a)                            ((a) << 7)
#define PM_VSACONTROL_MIRRORY(a)                            ((a) << 8)
#define PM_VSACONTROL_DISCARD(a)                            ((a) << 9)
#define PM_VSACONTROL_COMBINE(a)                            ((a) << 11)
#define PM_VSACONTROL_LOCKTOB(a)                            ((a) << 12)

// Video Stream B Control
#define PM_VSBCONTROL_VIDEO(a)                              ((a) << 0)
#define PM_VSBCONTROL_VBI(a)                                ((a) << 1)
#define PM_VSBCONTROL_BUFFER(a)                             ((a) << 2)
#define PM_VSBCONTROL_COMBINE(a)                            ((a) << 3)
#define PM_VSBCONTROL_FORMAT(a)                             ((a) << 4)
#define PM_VSBCONTROL_PIXELSIZE(a)                          ((a) << 9)
#define PM_VSBCONTROL_RGB(a)                                ((a) << 11)
#define PM_VSBCONTROL_GAMMA(a)                              ((a) << 12)
#define PM_VSBCONTROL_LOCKTOA(a)                            ((a) << 13)

// *******************************************************************
// Permedia3 Bit Field Macros

// Dither unit
#define P3RX_DITHERMODE_ENABLE(a)                           ((a) << 0)
#define P3RX_DITHERMODE_DITHERENABLE(a)                     ((a) << 1)
#define P3RX_DITHERMODE_COLORFORMAT(a)                      ((a) << 2)
#define P3RX_DITHERMODE_XOFFSET(a)                          ((a) << 6)
#define P3RX_DITHERMODE_YOFFSET(a)                          ((a) << 8)
#define P3RX_DITHERMODE_COLORORDER(a)                       ((a) << 10)
#define P3RX_DITHERMODE_ALPHADITHER(a)                      ((a) << 14)
#define P3RX_DITHERMODE_ROUNDINGMODE(a)                     ((a) << 15)

// Render2D
#define P3RX_RENDER2D_WIDTH(a)                              ((a) << 0)
#define P3RX_RENDER2D_OPERATION(a)                          ((a) << 12)
#define P3RX_RENDER2D_FBREADSOURCEENABLE(a)                 ((a) << 14)
#define P3RX_RENDER2D_SPANOPERATION(a)                      ((a) << 15)
#define P3RX_RENDER2D_HEIGHT(a)                             ((a) << 16)
#define P3RX_RENDER2D_INCREASINGX(a)                        ((a) << 28)
#define P3RX_RENDER2D_INCREASINGY(a)                        ((a) << 29)
#define P3RX_RENDER2D_AREASTIPPLEENABLE(a)                  ((a) << 30)
#define P3RX_RENDER2D_TEXTUREENABLE(a)                      ((a) << 31)

// RectanglePosition
#define P3RX_RECTANGLEPOSITION_X(a)                         ((a) << 0)
#define P3RX_RECTANGLEPOSITION_Y(a)                         ((a) << 16)

// Alpha blend unit.
#define P3RX_ALPHABLENDCOLORMODE_ENABLE(a)                  ((a) << 0)
#define P3RX_ALPHABLENDCOLORMODE_SRCBLEND(a)                ((a) << 1)
#define P3RX_ALPHABLENDCOLORMODE_DSTBLEND(a)                ((a) << 5)
#define P3RX_ALPHABLENDCOLORMODE_SRCTIMES2(a)               ((a) << 8)
#define P3RX_ALPHABLENDCOLORMODE_DSTTIMES2(a)               ((a) << 9)
#define P3RX_ALPHABLENDCOLORMODE_INVSRC(a)                  ((a) << 10)
#define P3RX_ALPHABLENDCOLORMODE_INVDST(a)                  ((a) << 11)
#define P3RX_ALPHABLENDCOLORMODE_COLORFORMAT(a)             ((a) << 12)
#define P3RX_ALPHABLENDCOLORMODE_COLORORDER(a)              ((a) << 16)
#define P3RX_ALPHABLENDCOLORMODE_COLORCONVERSION(a)         ((a) << 17)
#define P3RX_ALPHABLENDCOLORMODE_CONSTANTSRC(a)             ((a) << 18)
#define P3RX_ALPHABLENDCOLORMODE_CONSTANTDST(a)             ((a) << 19)
#define P3RX_ALPHABLENDCOLORMODE_OPERATION(a)               ((a) << 20)
#define P3RX_ALPHABLENDCOLORMODE_SWAPSD(a)                  ((a) << 24)

#define P3RX_ALPHABLENDALPHAMODE_ENABLE(a)                  ((a) << 0)
#define P3RX_ALPHABLENDALPHAMODE_SRCBLEND(a)                ((a) << 1)
#define P3RX_ALPHABLENDALPHAMODE_DSTBLEND(a)                ((a) << 5)
#define P3RX_ALPHABLENDALPHAMODE_SRCTIMES2(a)               ((a) << 8)
#define P3RX_ALPHABLENDALPHAMODE_DSTTIMES2(a)               ((a) << 9)
#define P3RX_ALPHABLENDALPHAMODE_INVSRC(a)                  ((a) << 10)
#define P3RX_ALPHABLENDALPHAMODE_INVDST(a)                  ((a) << 11)
#define P3RX_ALPHABLENDALPHAMODE_NOALPHABUFFER(a)           ((a) << 12)
#define P3RX_ALPHABLENDALPHAMODE_ALPHATYPE(a)               ((a) << 13)
#define P3RX_ALPHABLENDALPHAMODE_ALPHACONVERSION(a)         ((a) << 14)
#define P3RX_ALPHABLENDALPHAMODE_CONSTANTSRC(a)             ((a) << 15)
#define P3RX_ALPHABLENDALPHAMODE_CONSTANTDST(a)             ((a) << 16)
#define P3RX_ALPHABLENDALPHAMODE_OPERATION(a)               ((a) << 17)

#define P3RX_CHROMATESTMODE_ENABLE(a)                       ((a) << 0)
#define P3RX_CHROMATESTMODE_SOURCE(a)                       ((a) << 1)
#define P3RX_CHROMATESTMODE_PASSACTION(a)                   ((a) << 3)
#define P3RX_CHROMATESTMODE_FAILACTION(a)                   ((a) << 5)

// Framebuffer
// FBDestRead
#define P3RX_FBDESTREAD_READENABLE(a)                       ((a) << 0)
#define P3RX_FBDESTREAD_LAYOUT0(a)                          ((a) << 12)
#define P3RX_FBDESTREAD_LAYOUT1(a)                          ((a) << 14)
#define P3RX_FBDESTREAD_LAYOUT2(a)                          ((a) << 16)
#define P3RX_FBDESTREAD_LAYOUT3(a)                          ((a) << 18)

#define P3RX_FBDESTREAD_ENABLE0(a)                          ((a) << 8)
#define P3RX_FBDESTREAD_ENABLE1(a)                          ((a) << 9)
#define P3RX_FBDESTREAD_ENABLE2(a)                          ((a) << 10)
#define P3RX_FBDESTREAD_ENABLE3(a)                          ((a) << 11)

// FBWrite
#define P3RX_FBWRITEMODE_WRITEENABLE(a)                     ((a) << 0)
#define P3RX_FBWRITEMODE_RESERVED(a)                        ((a) << 1)
#define P3RX_FBWRITEMODE_REPLICATE(a)                       ((a) << 4)
#define P3RX_FBWRITEMODE_OPAQUESPAN(a)                      ((a) << 5)
#define P3RX_FBWRITEMODE_STRIPEPITCH(a)                     ((a) << 6)
#define P3RX_FBWRITEMODE_STRIPEHEIGHT(a)                    ((a) << 9)
#define P3RX_FBWRITEMODE_ENABLE0(a)                         ((a) << 12)
#define P3RX_FBWRITEMODE_ENABLE1(a)                         ((a) << 13)
#define P3RX_FBWRITEMODE_ENABLE2(a)                         ((a) << 14)
#define P3RX_FBWRITEMODE_ENABLE3(a)                         ((a) << 15)
#define P3RX_FBWRITEMODE_LAYOUT0(a)                         ((a) << 16)
#define P3RX_FBWRITEMODE_LAYOUT1(a)                         ((a) << 18)
#define P3RX_FBWRITEMODE_LAYOUT2(a)                         ((a) << 20)
#define P3RX_FBWRITEMODE_LAYOUT3(a)                         ((a) << 22)
#define P3RX_FBWRITEMODE_ORIGIN0(a)                         ((a) << 24)
#define P3RX_FBWRITEMODE_ORIGIN1(a)                         ((a) << 25)
#define P3RX_FBWRITEMODE_ORIGIN2(a)                         ((a) << 26)
#define P3RX_FBWRITEMODE_ORIGIN3(a)                         ((a) << 27)

// FBSourceRead
#define P3RX_FBSOURCEREAD_READENABLE(a)                     ((a) << 0)
#define P3RX_FBSOURCEREAD_PREFETCHENABLE(a)                 ((a) << 1)
#define P3RX_FBSOURCEREAD_STRIPEPITCH(a)                    ((a) << 2)
#define P3RX_FBSOURCEREAD_STRIPEHEIGHT(a)                   ((a) << 5)
#define P3RX_FBSOURCEREAD_LAYOUT(a)                         ((a) << 8)
#define P3RX_FBSOURCEREAD_ORIGIN(a)                         ((a) << 10)
#define P3RX_FBSOURCEREAD_BLOCKING(a)                       ((a) << 11)

// Render
#define P3RX_RENDER_AREASTIPPLEENABLE(a)                    ((a) << 0)
#define P3RX_RENDER_LINESTIPPLEENABLE(a)                    ((a) << 1)
#define P3RX_RENDER_RESETLINESTIPPLE(a)                     ((a) << 2)
#define P3RX_RENDER_FASTFILLENABLE(a)                       ((a) << 3)
#define P3RX_RENDER_PRIMITIVETYPE(a)                        ((a) << 6)
#define P3RX_RENDER_ANTIALIASENABLE(a)                      ((a) << 8)
#define P3RX_RENDER_ANTIALIASINGQUALITY(a)                  ((a) << 9)
#define P3RX_RENDER_USEPOINTTABLE(a)                        ((a) << 10)
#define P3RX_RENDER_SYNCONBITMASK(a)                        ((a) << 11)
#define P3RX_RENDER_SYNCONHOSTDATA(a)                       ((a) << 12)
#define P3RX_RENDER_TEXTUREENABLE(a)                        ((a) << 13)
#define P3RX_RENDER_FOGENABLE(a)                            ((a) << 14)
#define P3RX_RENDER_COVERAGEENABLE(a)                       ((a) << 15)
#define P3RX_RENDER_SUBPIXELCORRECTIONENABLE(a)             ((a) << 16)
#define P3RX_RENDER_SPANOPERATION(a)                        ((a) << 18)
#define P3RX_RENDER_DERR(a)                                 ((a) << 20)
#define P3RX_RENDER_FBSOURCEREADENABLE(a)                   ((a) << 27)

// TextureFilterMode - texture filter unit
#define P3RX_TEXFILTERMODE_ENABLE(a)                        ((a) << 0)
#define P3RX_TEXFILTERMODE_FORMAT0(a)                       ((a) << 1)
#define P3RX_TEXFILTERMODE_COLORORDER0(a)                   ((a) << 5)
#define P3RX_TEXFILTERMODE_ALPHAMAPENABLE0(a)               ((a) << 6)
#define P3RX_TEXFILTERMODE_ALPHAMAPSENSE0(a)                ((a) << 7)
#define P3RX_TEXFILTERMODE_COMBINECACHES(a)                 ((a) << 8)
#define P3RX_TEXFILTERMODE_FORMAT1(a)                       ((a) << 9)
#define P3RX_TEXFILTERMODE_COLORORDER1(a)                   ((a) << 13)
#define P3RX_TEXFILTERMODE_ALPHAMAPENABLE1(a)               ((a) << 14)
#define P3RX_TEXFILTERMODE_ALPHAMAPSENSE1(a)                ((a) << 15)
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERING(a)             ((a) << 16)
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT0(a)          ((a) << 17)
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT1(a)          ((a) << 20)
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT01(a)         ((a) << 23)
#define P3RX_TEXFILTERMODE_MULTITEXTURE(a)                  ((a) << 27)
#define P3RX_TEXFILTERMODE_FORCEALPHATOONE0(a)              ((a) << 28)
#define P3RX_TEXFILTERMODE_FORCEALPHATOONE1(a)              ((a) << 29)
#define P3RX_TEXFILTERMODE_SHIFT0(a)                        ((a) << 30)
#define P3RX_TEXFILTERMODE_SHIFT1(a)                        ((a) << 31)
// Shortcuts - both textures the same (i.e. combined)
#define P3RX_TEXFILTERMODE_FORMATBOTH(a)            \
    ( P3RX_TEXFILTERMODE_FORMAT0(a)            | P3RX_TEXFILTERMODE_FORMAT1(a) )
#define P3RX_TEXFILTERMODE_COLORORDERBOTH(a)        \
    ( P3RX_TEXFILTERMODE_COLORORDER0(a)        | P3RX_TEXFILTERMODE_COLORORDER1(a) )
#define P3RX_TEXFILTERMODE_ALPHAMAPENABLEBOTH(a)    \
    ( P3RX_TEXFILTERMODE_ALPHAMAPENABLE0(a)    | P3RX_TEXFILTERMODE_ALPHAMAPENABLE1(a) )
#define P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMITBOTH(a) \
    ( P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT0(a)    | P3RX_TEXFILTERMODE_ALPHAMAPFILTERLIMIT1(a) )
#define P3RX_TEXFILTERMODE_ALPHAMAPSENSEBOTH(a)     \
    ( P3RX_TEXFILTERMODE_ALPHAMAPSENSE0(a)    | P3RX_TEXFILTERMODE_ALPHAMAPSENSE1(a) )
#define P3RX_TEXFILTERMODE_FORCEALPHATOONEBOTH(a)   \
    ( P3RX_TEXFILTERMODE_FORCEALPHATOONE0(a)| P3RX_TEXFILTERMODE_FORCEALPHATOONE1(a) )
#define P3RX_TEXFILTERMODE_SHIFTBOTH(a)             \
    ( P3RX_TEXFILTERMODE_SHIFT0(a)            | P3RX_TEXFILTERMODE_SHIFT1(a) )

// Texture Coordinate Unit.
#define P3RX_TEXCOORDMODE_ENABLE(a)                         ((a) << 0)
#define P3RX_TEXCOORDMODE_WRAPS(a)                          ((a) << 1)
#define P3RX_TEXCOORDMODE_WRAPT(a)                          ((a) << 3)
#define P3RX_TEXCOORDMODE_OPERATION(a)                      ((a) << 5)
#define P3RX_TEXCOORDMODE_INHIBITDDAINIT(a)                 ((a) << 6)
#define P3RX_TEXCOORDMODE_ENABLELOD(a)                      ((a) << 7)
#define P3RX_TEXCOORDMODE_ENABLEDY(a)                       ((a) << 8)
#define P3RX_TEXCOORDMODE_WIDTH(a)                          ((a) << 9)
#define P3RX_TEXCOORDMODE_HEIGHT(a)                         ((a) << 13)
#define P3RX_TEXCOORDMODE_TEXTUREMAPTYPE(a)                 ((a) << 17)
#define P3RX_TEXCOORDMODE_WRAPS1(a)                         ((a) << 18)
#define P3RX_TEXCOORDMODE_WRAPT1(a)                         ((a) << 20)
#define P3RX_TEXCOORDMODE_DUPLICATECOORDS(a)                ((a) << 22)

// Alpha test unit.
#define P3RX_ANTIALIASMODE_ENABLE(a)                        ((a) << 0)
#define P3RX_ANTIALIASMODE_COLORMODE(a)                     ((a) << 1)
#define P3RX_ANTIALIASMODE_SCALECOLOR(a)                    ((a) << 2)

#define P3RX_ALPHATESTMODE_ENABLE(a)                        ((a) << 0)
#define P3RX_ALPHATESTMODE_COMPARE(a)                       ((a) << 1)
#define P3RX_ALPHATESTMODE_REFERENCE(a)                     ((a) << 4)

// Texture application unit.
#define P3RX_TEXAPPMODE_ENABLE(a)                           ((a) << 0)
#define P3RX_TEXAPPMODE_COLORA(a)                           ((a) << 1)
#define P3RX_TEXAPPMODE_COLORB(a)                           ((a) << 3)
#define P3RX_TEXAPPMODE_COLORI(a)                           ((a) << 5)
#define P3RX_TEXAPPMODE_COLORINVI(a)                        ((a) << 7)
#define P3RX_TEXAPPMODE_COLOROP(a)                          ((a) << 8)
#define P3RX_TEXAPPMODE_ALPHAA(a)                           ((a) << 11)
#define P3RX_TEXAPPMODE_ALPHAB(a)                           ((a) << 13)
#define P3RX_TEXAPPMODE_ALPHAI(a)                           ((a) << 15)
#define P3RX_TEXAPPMODE_ALPHAINVI(a)                        ((a) << 17)
#define P3RX_TEXAPPMODE_ALPHAOP(a)                          ((a) << 18)
#define P3RX_TEXAPPMODE_KDENABLE(a)                         ((a) << 21)
#define P3RX_TEXAPPMODE_KSENABLE(a)                         ((a) << 22)
#define P3RX_TEXAPPMODE_MOTIONCOMPENABLE(a)                 ((a) << 23)
// Short-cuts - passing xxxC to alpha channel equates to xxxA
#define P3RX_TEXAPPMODE_BOTHA(a)        \
            ( P3RX_TEXAPPMODE_COLORA(a)    | P3RX_TEXAPPMODE_ALPHAA(a) )
#define P3RX_TEXAPPMODE_BOTHB(a)        \
            ( P3RX_TEXAPPMODE_COLORB(a)    | P3RX_TEXAPPMODE_ALPHAB(a) )
#define P3RX_TEXAPPMODE_BOTHI(a)        \
            ( P3RX_TEXAPPMODE_COLORI(a)    | P3RX_TEXAPPMODE_ALPHAI(a) )
#define P3RX_TEXAPPMODE_BOTHINVI(a)     \
            ( P3RX_TEXAPPMODE_COLORINVI(a) | P3RX_TEXAPPMODE_ALPHAINVI(a) )
#define P3RX_TEXAPPMODE_BOTHOP(a)       \
            ( P3RX_TEXAPPMODE_COLOROP(a)   | P3RX_TEXAPPMODE_ALPHAOP(a) )

// Texture composite mode.
#define P3RX_TEXCOMPMODE_ENABLE(a)                          ((a) << 0)
// These are used for TextureComposite(Colour|Alpha)Mode(0|1)
// Use the P3RX_TEXAPP_* defines.
#define P3RX_TEXCOMPCAMODE01_ENABLE(a)                      ((a) << 0)
#define P3RX_TEXCOMPCAMODE01_ARG1(a)                        ((a) << 1)
#define P3RX_TEXCOMPCAMODE01_INVARG1(a)                     ((a) << 5)
#define P3RX_TEXCOMPCAMODE01_ARG2(a)                        ((a) << 6)
#define P3RX_TEXCOMPCAMODE01_INVARG2(a)                     ((a) << 10)
#define P3RX_TEXCOMPCAMODE01_I(a)                           ((a) << 11)
#define P3RX_TEXCOMPCAMODE01_INVI(a)                        ((a) << 14)
#define P3RX_TEXCOMPCAMODE01_A(a)                           ((a) << 15)
#define P3RX_TEXCOMPCAMODE01_B(a)                           ((a) << 16)
#define P3RX_TEXCOMPCAMODE01_OPERATION(a)                   ((a) << 17)
#define P3RX_TEXCOMPCAMODE01_SCALE(a)                       ((a) << 21)

// Texture index mode
#define P3RX_TEXINDEXMODE_ENABLE(a)                         ((a) << 0)
#define P3RX_TEXINDEXMODE_WIDTH(a)                          ((a) << 1)
#define P3RX_TEXINDEXMODE_HEIGHT(a)                         ((a) << 5)
#define P3RX_TEXINDEXMODE_BORDER(a)                         ((a) << 9)
#define P3RX_TEXINDEXMODE_WRAPU(a)                          ((a) << 10)
#define P3RX_TEXINDEXMODE_WRAPV(a)                          ((a) << 12)
#define P3RX_TEXINDEXMODE_MAPTYPE(a)                        ((a) << 14)
#define P3RX_TEXINDEXMODE_MAGFILTER(a)                      ((a) << 15)
#define P3RX_TEXINDEXMODE_MINFILTER(a)                      ((a) << 16)
#define P3RX_TEXINDEXMODE_TEX3DENABLE(a)                    ((a) << 19)
#define P3RX_TEXINDEXMODE_MIPMAPENABLE(a)                   ((a) << 20)
#define P3RX_TEXINDEXMODE_NEARESTBIAS(a)                    ((a) << 21)
#define P3RX_TEXINDEXMODE_LINEARBIAS(a)                     ((a) << 23)
#define P3RX_TEXINDEXMODE_SOURCETEXELENABLE(a)              ((a) << 25)

// Texture read unit.
#define P3RX_TEXREADMODE_ENABLE(a)                          ((a) << 0)
#define P3RX_TEXREADMODE_WIDTH(a)                           ((a) << 1)
#define P3RX_TEXREADMODE_HEIGHT(a)                          ((a) << 5)
#define P3RX_TEXREADMODE_TEXELSIZE(a)                       ((a) << 9)
#define P3RX_TEXREADMODE_TEXTURE3D(a)                       ((a) << 11)
#define P3RX_TEXREADMODE_COMBINECACHES(a)                   ((a) << 12)
#define P3RX_TEXREADMODE_MAPBASELEVEL(a)                    ((a) << 13)
#define P3RX_TEXREADMODE_MAPMAXLEVEL(a)                     ((a) << 17)
#define P3RX_TEXREADMODE_LOGICALTEXTURE(a)                  ((a) << 21)
#define P3RX_TEXREADMODE_ORIGIN(a)                          ((a) << 22)
#define P3RX_TEXREADMODE_TEXTURETYPE(a)                     ((a) << 23)
#define P3RX_TEXREADMODE_BYTESWAP(a)                        ((a) << 25)
#define P3RX_TEXREADMODE_MIRROR(a)                          ((a) << 28)
#define P3RX_TEXREADMODE_INVERT(a)                          ((a) << 29)
#define P3RX_TEXREADMODE_OPAQUESPAN(a)                      ((a) << 30)

#define P3RX_TEXMAPWIDTH_WIDTH(a)                           ((a) << 0)
#define P3RX_TEXMAPWIDTH_BORDER(a)                          ((a) << 12)
#define P3RX_TEXMAPWIDTH_LAYOUT(a)                          ((a) << 13)
#define P3RX_TEXMAPWIDTH_HOSTTEXTURE(a)                     ((a) << 15)

#define P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST0(a)             ((a) << 0)
#define P3RX_TEXCACHEREPLACEMODE_SCRATCHLINES0(a)           ((a) << 1)
#define P3RX_TEXCACHEREPLACEMODE_KEEPOLDEST1(a)             ((a) << 6)
#define P3RX_TEXCACHEREPLACEMODE_SCRATCHLINES1(a)           ((a) << 7)
#define P3RX_TEXCACHEREPLACEMODE_SHOWCACHEINFO(a)           ((a) << 12)

#define P3RX_TEXINVALIDATECACHE_BANK0(a)                    ((a) << 0)
#define P3RX_TEXINVALIDATECACHE_BANK1(a)                    ((a) << 1)
#define P3RX_TEXINVALIDATECACHE_TLB(a)                      ((a) << 2)

#define P3RX_INVALIDATECACHE(a, b)                                        \
do                                                                        \
{                                                                         \
    SEND_P3_DATA(InvalidateCache, P3RX_TEXINVALIDATECACHE_BANK0((a)) |    \
                                  P3RX_TEXINVALIDATECACHE_BANK1((a)) |    \
                                  P3RX_TEXINVALIDATECACHE_TLB((b)));      \
    SEND_P3_DATA(FogModeOr, 0);                                           \
    SEND_P3_DATA(TextureReadMode0Or, 0);                                  \
} while (0)

// Logical op unit
#define P3RX_LOGICALOPMODE_ENABLE(a)                        ((a) << 0)
#define P3RX_LOGICALOPMODE_LOGICOP(a)                       ((a) << 1)
#define P3RX_LOGICALOPMODE_USECONSTANTFBWRITEDATA(a)        ((a) << 5)
#define P3RX_LOGICALOPMODE_BACKGROUNDENABLE(a)              ((a) << 6)
#define P3RX_LOGICALOPMODE_BACKGROUNDLOGICALOP(a)           ((a) << 7)
#define P3RX_LOGICALOPMODE_USECONSTANTSOURCE(a)             ((a) << 11)
#define P3RX_LOGICALOPMODE_OPAQUESPAN(a)                    ((a) << 12)

// LUT
#define P3RX_LUTMODE_ENABLE(a)                              ((a) << 0)
#define P3RX_LUTMODE_INCOLORORDER(a)                        ((a) << 1)
#define P3RX_LUTMODE_LOADFORMAT(a)                          ((a) << 2)
#define P3RX_LUTMODE_LOADCOLORORDER(a)                      ((a) << 4)
#define P3RX_LUTMODE_FRAGMENTOP(a)                          ((a) << 5)
#define P3RX_LUTMODE_SPANOP(a)                              ((a) << 8)
#define P3RX_LUTMODE_MOTIONCOMP8BITS(a)                     ((a) << 11)
#define P3RX_LUTMODE_XOFFSET(a)                             ((a) << 12)
#define P3RX_LUTMODE_YOFFSET(a)                             ((a) << 15)
#define P3RX_LUTMODE_PATTERNBASE(a)                         ((a) << 18)
#define P3RX_LUTMODE_SPANCCXALIGN(a)                        ((a) << 26)
#define P3RX_LUTMODE_SPANVCXALIGN(a)                        ((a) << 27)

// YUV unit.
#define P3RX_YUVMODE_ENABLE(a)                              ((a) << 0)

// Color DDA Unit
#define P3RX_COLORDDA_ENABLE(a)                             ((a) << 0)
#define P3RX_COLORDDA_SHADING(a)                            ((a) << 1)

// Scissor
#define P3RX_SCISSORMODE_USER(a)                            ((a) << 0)
#define P3RX_SCISSORMODE_SCREEN(a)                          ((a) << 1)
#define P3RX_SCISSOR_X_Y(a, b)            ((b) << 16 | ((a) & 0xFFFF))

#endif // __BITMAC2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\sync.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: sync.c
*
* Content: DrvSynchronize
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "pxrx.h"

/******************************Public*Routine******************************\
* VOID DrvSynchronize
*
* Synchronize with the GLINT.
*
* Before letting GDI draw onto our screen DIBs we must synchronize with GLINT.
* We do this by hooking HOOK_SYNCHRONIZE when we create a DIV that points to
* the screen (or off-screen). GDI then calls DrvSynchronize() before trying
* to render to any of these screen DIBs. The advantage is that we can forget
* about doing SYNC_WITH_GLINT in the code and have GDI call DrvSynchronize
* at the appropriate moment.
*
\**************************************************************************/

VOID
DrvSynchronize(
DHPDEV  dhpdev,
RECTL   *prcl)
{
    PDEV*   ppdev = (PDEV*) dhpdev;
    GLINT_DECL;

    DISPDBG((DBGLVL, "DrvSynchronize called"));

    // These chips use cached syncs

    SYNC_IF_CORE_BUSY;
}

//@@BEGIN_DDKSPLIT
#if 0
#if USE_LD_GLINT_FIFO_FUNCTION

void loadGlintFIFOrelease( GlintDataPtr glintInfo, ULONG tag, ULONG data ) {
/**/
    TEMP_MACRO_VARS;

    LD_GLINT_FIFO_FREE( tag, data );
/*/
    static ULONG    fifoSpace = 0;
    ULONG           *dst;
    TEMP_MACRO_VARS;

    if( fifoSpace < 2 ) {
        GET_INPUT_FIFO_SPACE( fifoSpace );

        if ( GLINT_GAMMA_PRESENT ) {
            if( space > MAX_GAMMA_FIFO_ENTRIES )
                space = MAX_GAMMA_FIFO_ENTRIES;
        }
        else {
            if( space > MAX_P3_FIFO_ENTRIES )
                space = MAX_P3_FIFO_ENTRIES;
        }
    }

    dst = (ULONG *) glintInfo->regs.InFIFOInterface;
    MEMORY_BARRIER();
    WRITE_FAST_ULONG( dst, tag );
    dst++;
    MEMORY_BARRIER();
    WRITE_FAST_ULONG( dst, data );
/**/
}

void loadGlintFIFOdebug( GlintDataPtr glintInfo, ULONG tag, ULONG data ) {
    TEMP_MACRO_VARS;

    LD_GLINT_FIFO_DBG( tag, data )
}

#if DBG
LoadGlintFIFO   loadGlintFIFO = loadGlintFIFOdebug;
#else
LoadGlintFIFO   loadGlintFIFO = loadGlintFIFOrelease;
#endif   // DBG
#endif  // USE_LD_GLINT_FIFO_FUNCTION

#endif // 0
//@@END_DDKSPLIT

#if USE_SYNC_FUNCTION



void syncWithGlint( PPDEV ppdev, GlintDataPtr glintInfo ) 
{
    DWORD   gsync;
    ULONG   bmask;
    TEMP_MACRO_VARS;

    WAIT_DMA_COMPLETE;

    // Setting the pxrxDMA->bFlushRequired flag below to false ensures that 
    // the interrupt routine will not try to write to the chip. Without 
    // this check, the Vblank interrupt can attempt to flush outstanding 2D 
    // rendering by writing ContinueNewSub tag and data to the chip.
    // The problem with this is that the interrupt can occur between the 
    // writes of the tag and data in the code below, and if this happens,
    // the tag and data becomes out of step and typically results in a hang.
    //
    // Note that we have to set a MUTEX otherwise we still get hangs on a 
    // multi-processor system when an interrupt routine can be running 
    // simultaneously on another processor. The MUTEX avoids race conditions.
    
    GET_INTR_CMD_BLOCK_MUTEX(&glintInfo->pInterruptCommandBlock->General);
    glintInfo->pxrxDMA->bFlushRequired = FALSE ;

    WAIT_GLINT_FIFO(4);
    LD_GLINT_FIFO(__GlintTagFilterMode, 0x400);
    LD_GLINT_FIFO(__GlintTagSync, 0);
    LD_GLINT_FIFO(__GlintTagFilterMode, 0x0);
    
    do {
        WAIT_OUTPUT_FIFO_READY;
        READ_OUTPUT_FIFO(gsync);
        DISPDBG((DBGLVL, "SYNC: got 0x%x from output FIFO", gsync));
    } while (gsync != __GlintTagSync);
    
    glintInfo->bGlintCoreBusy = FALSE;
    RELEASE_INTR_CMD_BLOCK_MUTEX(&glintInfo->pInterruptCommandBlock->General);
}


void waitDMAcomplete( PPDEV ppdev, GlintDataPtr glintInfo ) 
{
    TEMP_MACRO_VARS;

    if (ppdev->currentCtxt == glintInfo->ddCtxtId)
    {
        SEND_PXRX_DMA_FORCE;
    }

    if (!(ppdev->g_GlintBoardStatus & GLINT_DMA_COMPLETE)) 
    {
        if (ppdev->g_GlintBoardStatus & GLINT_INTR_CONTEXT) 
        {
            // do any VBLANK wait, wait Q to empty and last DMA to complete
            PINTERRUPT_CONTROL_BLOCK pBlock = glintInfo->pInterruptCommandBlock;
            
            while (pBlock->Control & SUSPEND_DMA_TILL_VBLANK)
            {
                NULL;
            }
            
            while (pBlock->frontIndex != pBlock->backIndex)
            {
                NULL;
            }
        }
        
        if ((GET_DMA_COUNT(_temp_volatile_i)) > 0) 
        {
            do 
            {
                while (--_temp_volatile_i > 0)
                {
                    NULL;
                }
            } while ((GET_DMA_COUNT(_temp_volatile_i)) > 0);
        }
        
        ppdev->g_GlintBoardStatus |= GLINT_DMA_COMPLETE;
    }
}

#endif  // USE_SYNC_FUNCTION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\gdi\thunk.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: thunk.c
*
* Content:
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "glint.h"

#if DBG

// default these to FALSE
BOOL    bPuntCopyBits = FALSE;
BOOL    bPuntBitBlt = FALSE;
BOOL    bPuntTextOut = FALSE;
BOOL    bPuntStrokePath = FALSE;
BOOL    bPuntLineTo = FALSE;
BOOL    bPuntFillPath = FALSE;
BOOL    bPuntPaint = FALSE;

#endif //DBG

////////////////////////////////////////////////////////////////////////////

#if DBG || !SYNCHRONIZEACCESS_WORKS

// This entire module is only enabled for Checked builds, or when we
// have to explicitly synchronize bitmap access ourselves.

////////////////////////////////////////////////////////////////////////////
// By default, GDI does not synchronize drawing to device-bitmaps.  Since
// our hardware dictates that only one thread can access the accelerator
// at a time, we have to synchronize bitmap access.
//
// If we're running on Windows NT 3.1, we have to do it ourselves.
//
// If we're running on Windows NT 3.5 or later, we can ask GDI to do it
// by setting HOOK_SYNCHRONIZEACCESS when we associate a device-bitmap
// surface.

extern HSEMAPHORE g_cs;

#define SYNCH_ENTER() EngAcquireSemaphore(g_cs);
#define SYNCH_LEAVE() EngReleaseSemaphore(g_cs);

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)

BOOL inBitBlt = FALSE;

VOID DbgDisableDriver(VOID)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableDriver"));

    DrvDisableDriver();

    DISPDBG((6, "DrvDisableDriver done"));
    SYNCH_LEAVE();
}

DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "DrvEnablePDEV done"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "DrvCompletePDEV done"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "DrvDisable done"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "DrvEnableSurface done"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "DrvDisableSurface done"));
    SYNCH_LEAVE();
}

BOOL  DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL bRet;    
    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    bRet = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();

    return(bRet);
}

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, "DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "DrvGetModes done"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

#if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
#endif

    // We don't synchronise access to this routine. If the cursor is hardware
    // the move can be done at any time and if it is software GDI locks the
    // access for us.

    DISPDBG((15, "DrvMovePointer 0x%x 0x%x", x, y));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((16, "DrvMovePointer done"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();

#if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
#endif

    DISPDBG((5, "DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "DrvSetPointerShape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    DISPDBG((5, "DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "DrvDitherColor done"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "DrvSetPalette done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (psoSrc && psoSrc->iType != STYPE_BITMAP) ? (PPDEV)psoSrc->dhpdev : (PPDEV)psoDst->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntCopyBits)
        {
            SYNCH_ENTER();
            if(psoSrc->iType != STYPE_BITMAP)
            {
                DSURF *pdsurfSrc = (DSURF *)psoSrc->dhsurf;
                psoSrc = pdsurfSrc->pso;
            }
            if(psoDst->iType != STYPE_BITMAP)
            {
                DSURF *pdsurfDst = (DSURF *)psoDst->dhsurf;
                psoDst = pdsurfDst->pso;
            }
            u = EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG
    
    SYNCH_ENTER();

    DISPDBG((5, "DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "DrvCopyBits done"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (psoSrc && psoSrc->iType != STYPE_BITMAP) ? (PPDEV)psoSrc->dhpdev : (PPDEV)psoDst->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntBitBlt)
        {
            SYNCH_ENTER();
            if(psoSrc && psoSrc->iType != STYPE_BITMAP)
            {
                DSURF *pdsurfSrc = (DSURF *)psoSrc->dhsurf;
                psoSrc = pdsurfSrc->pso;
            }
            if(psoDst && psoDst->iType != STYPE_BITMAP)
            {
                DSURF *pdsurfDst = (DSURF *)psoDst->dhsurf;
                psoDst = pdsurfDst->pso;
            }
            u = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc, pptlMask, pbo, pptlBrush, rop4);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();

    DISPDBG((5, "DrvBitBlt: psoDst(%p) psoSrc(%p) psoMask(%p) pbo(%p) rop(%08x)", psoDst, psoSrc, psoMask, pbo, rop4));

    inBitBlt = TRUE;
    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);
    inBitBlt = FALSE;

    DISPDBG((6, "DrvBitBlt done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntTextOut)
        {
            SYNCH_ENTER();
            if(pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore, pboOpaque, pptlOrg, mix);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();

    DISPDBG((5, "DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "DrvTextOut done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntStrokePath)
        {
            SYNCH_ENTER();
            if(pso && pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, plineattrs, mix);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();
    DISPDBG((5, "DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "DrvStrokePath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgLineTo(
    SURFOBJ*   pso,
    CLIPOBJ*   pco,
    BRUSHOBJ*  pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL      *prclBounds,
    MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntLineTo)
        {
            SYNCH_ENTER();
            if(pso && pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngLineTo(pso, pco, pbo,    x1, y1, x2, y2, prclBounds, mix);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();
    DISPDBG((5, "DrvLineTo"));

    u = DrvLineTo(
                pso,
                pco,
                pbo,
                x1,
                y1,
                x2,
                y2,
                prclBounds,
                mix);

    DISPDBG((6, "DrvLineTo done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntFillPath)
        {
            SYNCH_ENTER();
            if(pso && pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngFillPath(pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();
    DISPDBG((5, "DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "DrvFillPath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);

        if(bPuntPaint)
        {
            SYNCH_ENTER();
            if(pso && pso->iType != STYPE_BITMAP)
            {
                DSURF *pdsurf = (DSURF *)pso->dhsurf;
                pso = pdsurf->pso;
            }
            u = EngPaint(pso, pco, pbo, pptlBrushOrg, mix);
            SYNCH_LEAVE();
            return(u);
        }
    }
    #endif //DBG

    SYNCH_ENTER();
    DISPDBG((5, "DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((6, "DrvPaint done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

//@@BEGIN_DDKSPLIT
    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    // I've seen this to be untrue at least once on a MIPS so ...
//@@END_DDKSPLIT

    if (!inBitBlt)
        SYNCH_ENTER();

    DISPDBG((5, "DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "DrvRealizeBrush done"));
    if (!inBitBlt)
        SYNCH_LEAVE();

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

//@@BEGIN_DDKSPLIT
#if 0
    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...
#endif
//@@END_DDKSPLIT

    SYNCH_ENTER();

    #if DBG
    {
        PPDEV ppdev = (PPDEV)dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
    #endif

    DISPDBG((5, "DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "DrvCreateDeviceBitmap done"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();

    #if DBG
    {
        PPDEV ppdev = ((DSURF *)dhsurf)->ppdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
    #endif

    DISPDBG((5, "DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "DrvDeleteDeviceBitmap done"));
    SYNCH_LEAVE();
}

//@@BEGIN_DDKSPLIT
#define DRV_STRETCH_SUPPORTED 0

#if DRV_STRETCH_SUPPORTED

#if DBG

#define STRETCH_COPY            0x00000000
#define STRETCH_DOWNLOAD        0x00000001

#define STRETCH_COLORONCOLOR    0x00000000
#define STRETCH_BLACKONWHITE    0x00000002
#define STRETCH_WHITEONBLACK    0x00000004

#define STRETCH_SOURCE_1BPP     0x00000000
#define STRETCH_SOURCE_4BPP     0x00000008
#define STRETCH_SOURCE_8BPP     0x00000010
#define STRETCH_SOURCE_16BPP    0x00000020
#define STRETCH_SOURCE_24BPP    0x00000040
#define STRETCH_SOURCE_32BPP    0x00000080

#define STRETCH_ONE2ONE_X       0x00000000
#define STRETCH_GROW_X          0x00000100
#define STRETCH_SHRINK_X        0x00000200

#define STRETCH_ONE2ONE_Y       0x00000000
#define STRETCH_GROW_Y          0x00000400
#define STRETCH_SHRINK_Y        0x00000800

ULONG aStretch[0x900];

#endif // DBG

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    #if SYNCHRONIZEACCESS_WORKS
    {
        // Our DrvStretchBlt routine calls back to EngStretchBlt, which
        // calls back to our DrvCopyBits routine -- so we have to be
        // re-entrant for synchronization...

        SYNCH_LEAVE();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

#if DBG
    {
        int i;
        SIZEL   sizlSrc;
        SIZEL   sizlDst;

        i  = (psoSrc->iType == STYPE_BITMAP) ? STRETCH_DOWNLOAD : 
                                               STRETCH_COPY;

        i |= (iMode == COLORONCOLOR) ? STRETCH_COLORONCOLOR : 
             (iMode == BLACKONWHITE) ? STRETCH_BLACKONWHITE : 
                                       STRETCH_WHITEONBLACK;

        i |= (psoSrc->iBitmapFormat == BMF_1BPP)  ? STRETCH_SOURCE_1BPP :
             (psoSrc->iBitmapFormat == BMF_4BPP)  ? STRETCH_SOURCE_4BPP :
             (psoSrc->iBitmapFormat == BMF_8BPP)  ? STRETCH_SOURCE_8BPP :
             (psoSrc->iBitmapFormat == BMF_16BPP) ? STRETCH_SOURCE_16BPP :
             (psoSrc->iBitmapFormat == BMF_24BPP) ? STRETCH_SOURCE_24BPP :
                                                    STRETCH_SOURCE_32BPP;

        sizlSrc.cx = prclSrc->right - prclSrc->left;
        if((int)sizlSrc.cx < 0)
            sizlSrc.cx = (ULONG)-(int)sizlSrc.cx;

        sizlSrc.cy = prclSrc->bottom - prclSrc->top;
        if((int)sizlSrc.cy < 0)
            sizlSrc.cy = (ULONG)-(int)sizlSrc.cy;

        sizlDst.cx = prclDst->right - prclDst->left;
        if((int)sizlDst.cx < 0)
            sizlDst.cx = (ULONG)-(int)sizlDst.cx;

        sizlDst.cy = prclDst->bottom - prclDst->top;
        if((int)sizlDst.cy < 0)
            sizlDst.cy = (ULONG)-(int)sizlDst.cy;


        i |= (sizlSrc.cx == sizlDst.cx) ? STRETCH_ONE2ONE_X :
             (sizlSrc.cx < sizlDst.cx)  ? STRETCH_GROW_X :
                                          STRETCH_SHRINK_X;

        i |= (sizlSrc.cy == sizlDst.cy) ? STRETCH_ONE2ONE_Y :
             (sizlSrc.cy < sizlDst.cy)  ? STRETCH_GROW_Y :
                                          STRETCH_SHRINK_Y;

        ++aStretch[i];
    }
#endif

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    #if SYNCHRONIZEACCESS_WORKS
    {
        SYNCH_ENTER();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}

#endif  // DRV_STRETCH_SUPPORTED
//@@END_DDKSPLIT

ULONG
DbgEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    ULONG   cjIn,
    VOID    *pvIn,
    ULONG   cjOut,
    VOID    *pvOut)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
    #endif

    DISPDBG((5, "DrvEscape"));

    u = DrvEscape(pso, iEsc, cjIn, pvIn, cjOut, pvOut);

    DISPDBG((6, "DrvEscape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG
DbgDrawEscape(
    SURFOBJ *pso,
    ULONG   iEsc,
    CLIPOBJ *pco,
    RECTL   *prcl,
    ULONG   cjIn,
    VOID    *pvIn)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();

    #if DBG
    {
        PPDEV ppdev = (PPDEV)pso->dhpdev;
        CHECK_MEMORY_VIEW(ppdev);
    }
    #endif

    DISPDBG((5, "DrvDrawEscape"));

    // Nothing to do....

    u = (ULONG)-1;

    DISPDBG((6, "DrvDrawEscape done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvResetPDEV"));

    bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);

    DISPDBG((6, "<< DrvResetPDEV"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgSynchronize(
DHPDEV  dhpdev,
RECTL   *prcl)
{
    DISPDBG((5, "DbgSynchronize"));

    //
    // don't do SYNCH_ENTER checks here as we will be called from within
    // an Eng routine that is called from within a Drv function.
    //

    DrvSynchronize(
                dhpdev,
                prcl);

    DISPDBG((6, "DbgSynchronize done"));
}

#if WNT_DDRAW

BOOL DbgGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          lpdwNumHeaps,
VIDEOMEMORY*    pvmList,
DWORD*          lpdwNumFourCC,
DWORD*          lpdwFourCC)
{
    BOOL b;

    DISPDBG((5, ">> DbgQueryDirectDrawInfo"));

    b = DrvGetDirectDrawInfo(dhpdev,
                             pHalInfo,
                             lpdwNumHeaps,
                             pvmList,
                             lpdwNumFourCC,
                             lpdwFourCC);

    DISPDBG((6, "<< DbgQueryDirectDrawInfo"));

    return(b);
}

BOOL DbgEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgEnableDirectDraw"));

    b = DrvEnableDirectDraw(dhpdev,
                            pCallBacks,
                            pSurfaceCallBacks,
                            pPaletteCallBacks);

    DISPDBG((6, "<< DbgEnableDirectDraw"));
    SYNCH_LEAVE();

    return(b);
}

VOID DbgDisableDirectDraw(
DHPDEV      dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDisableDirectDraw"));

    DrvDisableDirectDraw(dhpdev);

    DISPDBG((6, "<< DbgDisableDirectDraw"));
    SYNCH_LEAVE();
}
#endif // WNT_DDRAW

#if(_WIN32_WINNT >= 0x500)

BOOL DbgIcmSetDeviceGammaRamp(
DHPDEV     dhpdev,
ULONG      iFormat,
LPVOID     lpRamp)
{
    BOOL b;
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgIcmSetDeviceGammaRamp"));

    b = DrvIcmSetDeviceGammaRamp(dhpdev, iFormat, lpRamp);

    DISPDBG((6, "<< DbgIcmSetDeviceGammaRamp"));
    SYNCH_LEAVE();
    return(b);
}

BOOL DbgGradientFill(
SURFOBJ    *psoDest,
CLIPOBJ    *pco,
XLATEOBJ   *pxlo,
TRIVERTEX  *pVertex,
ULONG       nVertex,
PVOID       pMesh,
ULONG       nMesh,
RECTL      *prclExtents,
POINTL     *pptlDitherOrg,
ULONG       ulMode)
{
    BOOL b;
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgGradientFill"));

    b = DrvGradientFill(psoDest, pco, pxlo, pVertex, nVertex, pMesh, nMesh, prclExtents, pptlDitherOrg, ulMode);

    DISPDBG((6, "<< DbgGradientFill"));
    SYNCH_LEAVE();
    return(b);
}

BOOL DbgAlphaBlend(
SURFOBJ     *psoDest,
SURFOBJ     *psoSrc,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
RECTL       *prclDest,
RECTL       *prclSrc,
BLENDOBJ    *pBlendObj)
{
    BOOL b;
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgAlphaBlend"));

    b = DrvAlphaBlend(psoDest, psoSrc, pco, pxlo, prclDest, prclSrc, pBlendObj);

    DISPDBG((6, "<< DbgAlphaBlend"));
    SYNCH_LEAVE();
    return(b);
}

BOOL DbgTransparentBlt(
SURFOBJ     *psoDst,
SURFOBJ     *psoSrc,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
RECTL       *prclDst,
RECTL       *prclSrc,
ULONG        iTransColor,
ULONG        ulReserved)
{
    BOOL b;
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgTransparentBlt"));

    b = DrvTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, iTransColor, ulReserved);

    DISPDBG((6, "<< DbgTransparentBlt"));
    SYNCH_LEAVE();
    return(b);
}

VOID DbgNotify(
SURFOBJ     *pso,
ULONG        iType,
PVOID        pvData)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgNotify"));

    DrvNotify(pso, iType, pvData);

    DISPDBG((6, "<< DbgNotify"));
    SYNCH_LEAVE();
}
 
#endif // (_WIN32_WINNT >= 0x500)

#endif // DBG || !SYNCHRONIZEACCESS_WORKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\eatags.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           *   SAMPLE CODE   *
*                           *******************
*
* Module Name: EATags.h
*
* Content: Debugging support macros and structures
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2002 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define D3DCanCreateD3DBuffer_ID                1
#define D3DCreateD3DBuffer_ID                   2
#define D3DDestroyD3DBuffer_ID                  3
#define D3DLockD3DBuffer_ID                     4
#define D3DUnlockD3DBuffer_ID                   5
#define D3DContextCreate_ID                     6
#define D3DContextDestroy_ID                    7
#define _D3D_OP_Clear2_ID                       8
#define D3DDrawPrimitives2_P3_ID                9
#define D3DValidateDeviceP3_ID                  10
#define D3DGetDriverState_ID                    11
#define D3DCreateSurfaceEx_ID                   12
#define D3DDestroyDDLocal_ID                    13
#define _D3D_SU_SurfInternalSetDataRecursive_ID 14
#define DdMapMemory_ID                          15
#define DrvGetDirectDrawInfo_ID                 16
#define DdFlip_ID                               17
#define DdWaitForVerticalBlank_ID               18
#define DdLock_ID                               19
#define DdUnlock_ID                             20
#define DdGetScanLine_ID                        21
#define DdGetBltStatus_ID                       22
#define DdGetFlipStatus_ID                      23
#define DdGetDriverInfo_ID                      24
#define DdBlt_ID                                25
#define DdCanCreateSurface_ID                   26
#define DdCreateSurface_ID                      27
#define DdDestroySurface_ID                     28
#define DdSetColorKey_ID                        29
#define DdGetAvailDriverMemory_ID               30
#define DrvBitBlt_ID                            31
#define DrvCopyBits_ID                          32
#define DrvGradientFill_ID                      33
#define DrvTransparentBlt_ID                    34
#define DrvAlphaBlend_ID                        35
#define DrvRealizeBrush_ID                      36
#define DrvDitherColor_ID                       37
#define DrvResetPDEV_ID                         38
#define DrvEnablePDEV_ID                        39
#define DrvDisablePDEV_ID                       40
#define DrvCompletePDEV_ID                      41
#define DrvEnableSurface_ID                     42
#define DrvDisableSurface_ID                    43
#define DrvAssertMode_ID                        44
#define DrvGetModes_ID                          45
#define DrvEscape_ID                            46
#define DrvNotify_ID                            47
#define DrvFillPath_ID                          48
#define DrvCreateDeviceBitmap_ID                49
#define DrvDeleteDeviceBitmap_ID                50
#define DrvDeriveSurface_ID                     51
#define DrvLineTo_ID                            52
#define DrvPaint_ID                             53
#define DrvSetPalette_ID                        54
#define DrvIcmSetDeviceGammaRamp_ID             55
#define DrvMovePointer_ID                       56
#define DrvSetPointerShape_ID                   57
#define DrvStrokePath_ID                        58
#define DrvSynchronize_ID                       59
#define DrvTextOut_ID                           60

#define EA_TAG_ENABLE 0x80000000

#define MIN_EA_TAG 1
#define MAX_EA_TAG 60
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\driver.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: driver.h
*
* Content: Contains prototypes for the display driver.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define ENABLE_DXMANAGED_LINEAR_HEAP (_WIN32_WINNT >= 0x500 && WNT_DDRAW)

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

#define SYNCHRONIZEACCESS_WORKS 1

// Useful for visualizing the 2-d heap:

#define DEBUG_HEAP              0

typedef struct _PDEV PDEV;      // Handy forward declaration

#define ALLOC_TAG_DX(id)   MAKEFOURCC('P','3','D',#@ id)
#define ALLOC_TAG_GDI(id)  MAKEFOURCC('P','3','G',#@ id)

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"perm3dd"  // Name of the DLL in UNICODE

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     16384   // Size in bytes of 'pvTmpBuffer'.  Has to
                                    //   be at least enough to store an entire
                                    //   scan line (i.e. 8192 for 2048x????x32).

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */


//////////////////////////////////////////////////////////////////////
// Text stuff

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                          /* xlc, pxlc */

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:

#define SLOW_BRUSH_CACHE_DIM_X  8
#define SLOW_BRUSH_CACHE_DIM_Y  1   // Controls the number of brushes cached
                                    //   in off-screen memory, when we don't
                                    //   have the S3 hardware pattern support.
                                    //   We allocate 3 x 3 brushes, so we can
                                    //   cache a total of 9 brushes:
#define SLOW_BRUSH_COUNT        (SLOW_BRUSH_CACHE_DIM_X * SLOW_BRUSH_CACHE_DIM_Y)
#define SLOW_BRUSH_DIMENSION    40  // After alignment is taken care of,
                                    //   every off-screen brush cache entry
                                    //   will be 48 pels in both dimensions
#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    //   pattern, using the 8 extra for brush
                                    //   alignment

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

// For now assume that all brushes are 64 entries (8x8 @ 32bpp):
// At 16bpp we should be able to handle 8 brushes, no idea what happens at 8bpp!
#define MAX_P3_BRUSHES      4

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    ULONG       iUniq;            // our own unique brush ID
    FLONG       fl;             // Type flags
    DWORD       areaStippleMode;// area stipple mode if 1bpp.

/*** get rid of bTransparent later. We need it now so everything compiles OK ***/
    BOOL        bTransparent;   // TRUE if brush was realized for a transparent
                                //   blt (meaning colours are white and black),
                                //   FALSE if not (meaning it's already been
                                //   colour-expanded to the correct colours).
                                //   Value is undefined if the brush isn't
                                //   2 colour.
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    ULONG       patternBase;    // Position of brush in LUT (colour P3 only)
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    BRUSHENTRY* apbe;           // Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

// 2D display driver DMA buffer definitions
typedef struct DMABuffer
{
    LARGE_INTEGER   pphysStart;
    PULONG          pulStart;
    PULONG          pulEnd;
    PULONG          pulCurrent;
    ULONG           cb;
}
DMA_BUFFER;

#define DD_DMA_BUFFER_SIZE (ppdev->DMABuffer.cb)

#define QUERY_DD_DMA_FREE_ULONGS(c) \
    c = ((ULONG)(1 + ppdev->DMABuffer.pulEnd - ppdev->DMABuffer.pulCurrent))

#define QUERY_DD_DMA_FREE_TAGDATA_PAIRS(cFree) \
    QUERY_DD_DMA_FREE_ULONGS(cFree) >> 1

#define WRITE_DD_DMA_ULONG(ul) \
    *ppdev->DMABuffer.pulCurrent++ = ul

#define WRITE_DD_DMA_TAGDATA(Tag, Data) \
{ \
    WRITE_DD_DMA_ULONG(Tag); \
    WRITE_DD_DMA_ULONG(Data); \
}

#define DD_DMA_XFER_IN_PROGRESS (!(ppdev->g_GlintBoardStatus & GLINT_DMA_COMPLETE))

#define WAIT_DD_DMA_COMPLETE \
{ \
    WAIT_IMMEDIATE_DMA_COMPLETE; \
    ppdev->g_GlintBoardStatus |= GLINT_DMA_COMPLETE; \
    ppdev->DMABuffer.pulCurrent = ppdev->DMABuffer.pulStart; \
}

/////////////////////////////////////////////////////////////////////////
// Heap stuff

// forward declaration, rather than include the DX headers here
typedef struct tagLinearAllocatorInfo LinearAllocatorInfo, *pLinearAllocatorInfo;

typedef enum {
    OH_FREE = 0,        // The off-screen allocation is available for use
    OH_DISCARDABLE,     // The allocation is occupied by a discardable bitmap
                        //   that may be moved out of off-screen memory
    OH_PERMANENT,       // The allocation is occupied by a permanent bitmap
                        //   that cannot be moved out of off-screen memory
} OHSTATE;

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHSTATE  ohState;       // State of off-screen allocation
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    LONG     pixOffset;     // Offset in pixels to origin of bitmap
    LONG     lPixDelta;        // always == ppdev->cxMemory for rectangular bitmaps, otherwise == bitmap stride
    LONG     cxReserved;    // Dimensions of original reserved rectangle;
    LONG     cyReserved;    //   zero if rectangle is not 'reserved'
    OH*      pohNext;       // When OH_FREE or OH_RESERVE, points to the next
                            //   free node, in ascending cxcy value.  This is
                            //   kept as a circular doubly-linked list with a
                            //   sentinel at the end.
                            // When OH_DISCARDABLE, points to the next most
                            //   recently created allocation.  This is kept as
                            //   a circular doubly-linked list.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Rectangular heap: Adjacent allocation when in-use or available 
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
    VOID*    pvScan0;       // Points to start of first scan-line
    BOOL     bOffScreen;

    BOOL     bDXManaged;        // TRUE if this is linear DFB, FALSE if it's rectangular

#if (_WIN32_WINNT >= 0x500)
    LinearAllocatorInfo *pvmHeap;    // if (bLinear) this points to the heap from which the DFB was allocated
    FLATPTR     fpMem;                // if (bLinear) this pointers to the DFB bitmap in the heap
#endif
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    LONG     cxBounds;      // Largest possible bounding rectangle
    LONG     cyBounds;
    OH       ohFree;        // Head of the free list, containing those
                            //   rectangles in off-screen memory that are
                            //   available for use.  pohNext points to
                            //   hte smallest available rectangle, and pohPrev
                            //   points to the largest available rectangle,
                            //   sorted by cxcy.
    OH       ohDiscardable; // Head of the discardable list that contains all
                            //   bitmaps located in offscreen memory that
                            //   are eligible to be tossed out of the heap.
                            //   It is kept in order of creation: pohNext
                            //   points to the most recently created; pohPrev
                            //   points to the least recently created.
    OH       ohPermanent;   // List of permanently allocated rectangles
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations

    ULONG   DDrawOffscreenStart;

#if (_WIN32_WINNT >= 0x500)
    LinearAllocatorInfo *pvmLinearHeap;
    ULONG       cLinearHeaps;
#endif
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN     = 0x1,    // Surface is kept in screen memory
    DT_DIB        = 0x2,    // Surface is kept as a DIB
    DT_DIRECTDRAW = 0x4,    // Surface is derived from ddraw surface
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    BOOL      bOffScreen;   // DFB (off-screen) driver surface, not the on-screen surface
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap

    // If the bitmap is in the heap we can still keep a GDI accessible bitmap
    // for it because the screen is fully and linearly mapped. When we kick
    // the bitmap off the heap we delete this bitmap and create a real
    // memory bitmap. So when DT_SCREEN, we use both pointers. Hence not a
    // union. 0I'm not convinced it's valid to change the public entries in a
    // SURFOBJ to turn one surface into another (i.e. create a bitmap to point
    // to the screen and later change it to point to memory) so I'm not doing
    // it. Hence, we delete and recreate the screen bitmap surface when
    // changing between DT_SCREEN and DT_DIB. Remember when we move the DIB
    // back onto the screen it generally won't be in the same place so the
    // base pointer has to change.

    OH*         poh;    // If DT_SCREEN, points to off-screen heap node.
    SURFOBJ*    pso;    // If DT_SCREEN, points to GDI accessible surface for the bitmap
                        //      else if DT_DIB, points to locked GDI surface

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */


// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:
#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':
typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x00000001,   // Don't kick stuff out of off-
    FLOH_MAKE_PERMANENT     = 0x00000002,   // Allocate a permanent entry
    FLOH_RESERVE            = 0x00000004,   // Allocate an off-screen entry,
} FLOH;

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
VOID vEnable2DOffscreenMemory(PDEV *);
BOOL bDisable2DOffscreenMemory(PDEV *);

BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);
OH*  pohAllocate(PDEV*, POINTL*, LONG, LONG, FLOH);
VOID vSurfUsed(SURFOBJ*);
OH*  pohFree(PDEV*, OH*);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);

BOOL bCreateScreenDIBForOH(PDEV*, OH*, ULONG);
VOID vDeleteScreenDIBFromOH(OH *);

/////////////////////////////////////////////////////////////////////////
// Bank manager stuff

#define BANK_DATA_SIZE  80      // Number of bytes to allocate for the
                                //   miniport down-loaded bank code working
                                //   space

typedef struct _BANK
{
    // Private data:

    RECTL    rclDraw;           // Rectangle describing the remaining undrawn
                                //   portion of the drawing operation
    RECTL    rclSaveBounds;     // Saved from original CLIPOBJ for restoration
    BYTE     iSaveDComplexity;  // Saved from original CLIPOBJ for restoration
    BYTE     fjSaveOptions;     // Saved from original CLIPOBJ for restoration
    LONG     iBank;             // Current bank
    PDEV*    ppdev;             // Saved copy

    // Public data:

    SURFOBJ* pso;               // Surface wrapped around the bank.  Has to be
                                //   passed as the surface in any banked call-
                                //   back.
    CLIPOBJ* pco;               // Clip object that is the intersection of the
                                //   original clip object with the bounds of the
                                //   current bank.  Has to be passed as the clip
                                //   object in any banked call-back.

} BANK;                         /* bnk, pbnk */

typedef enum {
    BANK_OFF = 0,       // We've finished using the memory aperture
    BANK_ON,            // We're about to use the memory aperture
    BANK_DISABLE,       // We're about to enter full-screen; shut down banking
    BANK_ENABLE,        // We've exited full-screen; re-enable banking

} BANK_MODE;                    /* bankm, pbankm */

typedef VOID (FNBANKMAP)(VOID*, LONG);
typedef VOID (FNBANKSELECTMODE)(VOID*, BANK_MODE);
typedef VOID (FNBANKINITIALIZE)(VOID*, BOOL);
typedef BOOL (FNBANKCOMPUTE)(PDEV*, RECTL*, RECTL*, LONG*, LONG*);

VOID vBankStart(PDEV*, RECTL*, CLIPOBJ*, BANK*);
BOOL bBankEnum(BANK*);

FNBANKCOMPUTE bBankComputeNonPower2;
FNBANKCOMPUTE bBankComputePower2;

BOOL bEnableBanking(PDEV*);
VOID vDisableBanking(PDEV*);
VOID vAssertModeBanking(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

#define POINTER_DATA_SIZE       128     // Number of bytes to allocate for the
                                        //   miniport down-loaded pointer code
                                        //   working space
#define HW_INVISIBLE_OFFSET     2       // Offset from 'ppdev->yPointerBuffer'
                                        //   to the invisible pointer
#define HW_POINTER_DIMENSION    64      // Maximum dimension of default
                                        //   (built-in) hardware pointer
#define HW_POINTER_TOTAL_SIZE   1024    // Total size in bytes required
                                        //   to define the hardware pointer

typedef enum {
    PTR_HW_ACTIVE   = 1,        // The hardware pointer is active and visible
                                //   on screen
    PTR_SW_ACTIVE   = 2,        // The software pointer is active
} PTRFLAGS;

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// 64 x 64 Hardware Pointer Caching data structures

#define SMALL_POINTER_MEM (32 * 4 * 2)                // Bytes reqd for 32x32 cursor
#define LARGE_POINTER_MEM (SMALL_POINTER_MEM * 4)    // Bytes reqd for 64x64 cursor
#define SMALL_POINTER_MAX 4                         // No of cursors in cache

#define HWPTRCACHE_INVALIDENTRY (SMALL_POINTER_MAX + 1)    // Well-known value

// Pointer cache item data structure, there is one of these for every
// cached pointer
typedef struct {                            
    ULONG   ptrCacheTimeStamp;        // Timestamp used for LRU cache ageing
    ULONG   ptrCacheCX;                // width of cursor
    ULONG   ptrCacheCY;                // height of cursor
    LONG    ptrCacheLDelta;            // Line delta
} HWPointerCacheItemEntry;

// The complete cache looks like this
typedef struct {
    BYTE    ptrCacheIsLargePtr;        // TRUE if we have one 64x64 cursor, FALSE if we 
                                    // have multiple 32x32 cursors
    BYTE    ptrCacheInUseCount;        // The no. of cache items used
    ULONG   ptrCacheCurTimeStamp;    // The date stamp used for LRU stuff
    ULONG   ptrCacheData [LARGE_POINTER_MEM / 4];    // The cached pointer data
    HWPointerCacheItemEntry ptrCacheItemList [SMALL_POINTER_MAX];    // The cache item list
} HWPointerCache;

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette();
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

#if WNT_DDRAW
/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

// Sync with 2D driver
VOID vNTSyncWith2DDriver(PDEV *ppdev);

// Set up off-screen video memory for DirectDraw
BOOL bSetupOffscreenForDDraw (BOOL enableFlag, PDEV *ppdev, volatile ULONG ** VBlankAddress, volatile ULONG **bOverlayEnabled,
                              volatile ULONG **VBLANKUpdateOverlay, volatile ULONG **VBLANKUpdateOverlayWidth,
                              volatile ULONG **VBLANKUpdateOverlayHeight);

// Get framebuffer/Localbuffer info for DirectDraw
void GetFBLBInfoForDDraw (PDEV * ppdev, 
                          void ** fbPtr,            // Framebuffer pointer
                          void ** lbPtr,            // Localbuffer pointer
                          DWORD * fbSizeInBytes,    // Size of framebuffer
                          DWORD * lbSizeInBytes,    // Size of localbuffer
                          DWORD * fbOffsetInBytes,    // Offset to 1st 'free' byte in framebuffer
                          BOOL  * bSDRAM);            // TRUE if SDRAM (i.e. no h/w writemask)

// Get chip info for DirectDraw
void GetChipInfoForDDraw (PDEV* ppdev, 
                          DWORD* pdwChipID, 
                          DWORD* pdwChipRev, 
                          DWORD* pdwChipFamily, 
                          DWORD *pdwGammaRev);

LONG DDSendDMAData(PDEV* ppdev, ULONG PhysAddr, ULONG_PTR VirtAddr, LONG nDataEntries);
LONG DDGetFreeDMABuffer(DWORD *physAddr, ULONG_PTR *virtAddr, DWORD *bufferSize);
void DDFreeDMABuffer(void* dwPhysAddress);
LONG DDWaitDMAComplete(PDEV* ppdev);

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

BOOL _DD_DDE_bEnableDirectDraw(PDEV*);
VOID _DD_DDE_vDisableDirectDraw(PDEV*);
VOID _DD_DDE_vAssertModeDirectDraw(PDEV*, BOOL);
BOOL _DD_DDE_CreatePPDEV(PDEV* ppdev);
void _DD_DDE_DestroyPPDEV(PDEV* ppdev);
void _DD_DDE_ResetPPDEV(PDEV* ppdevOld, PDEV* ppdevNew);
VOID vAssertModeGlintExt(PDEV* ppdev, BOOL bEnable);

#endif // WNT_DDRAW

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes


typedef VOID (GFNCOPY)(PDEV*, RECTL*, LONG, DWORD, POINTL*, RECTL*);
typedef VOID (GFNFILL)(PDEV*, LONG, RECTL *, ULONG, ULONG, RBRUSH_COLOR,
                                                                    POINTL*);
typedef VOID (GFNXFER)(PDEV*, RECTL*, LONG, ULONG, ULONG, SURFOBJ*, POINTL*,
                                                        RECTL*, XLATEOBJ*);
typedef VOID (GFNMCPY)(PDEV*, RECTL*, LONG, SURFOBJ*, POINTL*, ULONG, ULONG,
                                                            POINTL*, RECTL*);
typedef BOOL (GFNPOLY)(PDEV*, LONG, POINTFIX*, ULONG, ULONG, DWORD, CLIPOBJ*,
                                                             RBRUSH*, POINTL*);
typedef BOOL (GFNLINE)(PDEV*, LONG, LONG, LONG, LONG);
typedef VOID (GFNPATR)(PDEV*, RBRUSH*, POINTL*);
typedef VOID (GFNMONO)(PDEV*, RBRUSH*, POINTL*);
typedef BOOL (GFNINIS)(PDEV*, ULONG, DWORD, RECTL*);
typedef VOID (GFNRSTS)(PDEV*);
typedef VOID (GFNREPN)(PDEV*, RECTL*, CLIPOBJ*);
typedef VOID (GFNUPLD)(PDEV*, LONG, RECTL*, SURFOBJ*, POINTL*, RECTL*);
typedef VOID (SWAPCSBUFL)(PDEV**, LONG);

typedef VOID (GFN3DEXCL)(PDEV *, BOOL);
typedef VOID (GFNCOPYD)(PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG);
typedef VOID (GFNXCOPYD)(PDEV *, SURFOBJ *, POINTL *, RECTL *, RECTL *, LONG, XLATEOBJ *);

#if (_WIN32_WINNT >= 0x500)
typedef BOOL (GFNGRADRECT)(PDEV *, TRIVERTEX *, ULONG, GRADIENT_RECT *, ULONG, ULONG, RECTL *, LONG);
typedef BOOL (GFNTRANSBLT)(PDEV *, RECTL *, POINTL *, ULONG, RECTL *, LONG);
typedef BOOL (GFNALPHABLT)(PDEV *, RECTL *, POINTL *, BLENDOBJ *, RECTL *, LONG);
#endif

typedef VOID (PTRENABLE)(PDEV *);
typedef VOID (PTRDISABLE)(PDEV *);
typedef BOOL (PTRSETSHAPE)(PDEV *, SURFOBJ *, SURFOBJ *, XLATEOBJ *, LONG, LONG, LONG, LONG);
typedef VOID (PTRMOVE)(PDEV *, LONG, LONG);
typedef VOID (PTRSHOW)(PDEV *, BOOL);

typedef struct _STRIP       STRIP;            // Actually in lines.h
typedef struct _LINESTATE   LINESTATE;        // Actually in lines.h
typedef VOID (* GAPFNstripFunc)(PDEV*, STRIP*, LINESTATE*);

// PXRX 2D DMA functions:
typedef struct _glint_data  *GlintDataPtr;    // Actually in Glint.h
typedef struct _PDEV        *PPDEV;            // Actually in Glint.h
typedef void    (* SendPXRXdma               )( PPDEV ppdev, GlintDataPtr glintInfo );
typedef void    (* SwitchPXRXdmaBuffer       )( PPDEV ppdev, GlintDataPtr glintInfo );
typedef void    (* WaitPXRXdmaCompletedBuffer)( PPDEV ppdev, GlintDataPtr glintInfo );


////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the GLINT miniport.  They
// come from the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the GLINT miniport's 'glint.h'!

typedef enum {
    // NT4 uses the DeviceSpecificAttributes field so the low word is available
    CAPS_ZOOM_X_BY2         = 0x00000001,   // Hardware has zoomed by 2 in X
    CAPS_ZOOM_Y_BY2         = 0x00000002,   // Hardware has zoomed by 2 in Y
    CAPS_SPARSE_SPACE       = 0x00000004,    // Framebuffer is sparsely mapped 
                                            // (don't allow direct access). The machine
                                            // is probably an Alpha.
    CAPS_QUEUED_DMA         = 0x00000008,   // DMA address/count via the FIFO
    CAPS_LOGICAL_DMA        = 0x00000010,   // DMA through logical address table
    CAPS_USE_AGP_DMA        = 0x00000020,   // AGP DMA can be used.
    CAPS_P3RD_POINTER       = 0x00000040,    // Use the 3Dlabs P3RD RAMDAC
    CAPS_STEREO             = 0x00000080,    // Stereo mode enabled.
    CAPS_SW_POINTER         = 0x00010000,   // No hardware pointer; use software
                                            //  simulation
    CAPS_GLYPH_EXPAND       = 0x00020000,   // Use glyph-expand method to draw
                                            //  text.
    CAPS_RGB525_POINTER     = 0x00040000,   // Use IBM RGB525 cursor
    CAPS_FAST_FILL_BUG      = 0x00080000,   // Chip fast fill bug exists
    CAPS_INTERRUPTS         = 0x00100000,   // interrupts available
    CAPS_DMA_AVAILABLE      = 0x00200000,   // DMA is supported
    CAPS_DISABLE_OVERLAY    = 0x00400000,   // Chip do not support overlay
    CAPS_8BPP_RGB           = 0x00800000,   // Use RGB in 8bpp mode
    CAPS_RGB640_POINTER     = 0x01000000,   // Use IBM RGB640 cursor
    CAPS_DUAL_GLINT         = 0x02000000,   // Dual board (currently dual TX or MX)
    CAPS_GLINT2_RAMDAC      = 0x04000000,   // Second of dual glint attached to the RAMDAC
    CAPS_ENHANCED_TX        = 0x08000000,   // TX is in enhanced mode
    CAPS_ACCEL_HW_PRESENT   = 0x10000000,   // Accel Graphics Hardware
    CAPS_TVP4020_POINTER    = 0x20000000,   // Use Permedia2 builtin pointer
    CAPS_SPLIT_FRAMEBUFFER  = 0x40000000,   // Dual-GLINT with a split framebuffer
    CAPS_P2RD_POINTER       = 0x80000000    // Use the 3Dlabs P2RD RAMDAC
} CAPS;

////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    // STAT_* indicates that the resource actually exists
    STAT_GLYPH_CACHE        = 0x00000001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x00000002,   // Brush cache successfully allocated
    STAT_DEV_BITMAPS        = 0x00000004,   // Device Bitmaps are allowed
    STAT_POINTER_CACHE      = 0x00000008,   // Software cursor support configured
    STAT_LINEAR_HEAP        = 0x00000010,    // Linear heap configured

    // ENABLE_* indicates whether resource is currently available
    ENABLE_GLYPH_CACHE      = 0x00010000,   // Glyph cache enabled
    ENABLE_BRUSH_CACHE      = 0x00020000,   // Brush cache enabled
    ENABLE_DEV_BITMAPS      = 0x00040000,   // Device Bitmaps enabled
    ENABLE_POINTER_CACHE    = 0x00080000,   // Software cursor support enabled
    ENABLE_LINEAR_HEAP      = 0x00100000,    // linear heap support is available

#if WNT_DDRAW
    STAT_DIRECTDRAW         = 0x80000000,   // DirectDraw is enabled
#endif  WNT_DDRAW
} STATUS;

// Texel LUT Cache types and additional cache info
typedef enum
{
    LUTCACHE_INVALID, LUTCACHE_XLATE, LUTCACHE_BRUSH
}
LUTCACHE;

typedef struct _glint_ctxt_table GlintCtxtTable;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    DWORD       cFlags;                    // The cache flags
    LONG        xOffset;
    LONG        DstPixelOrigin;         // pixel offset to the current destination DFB
    LONG        SrcPixelOrigin;         // pixel offset to the current source DFB
    ULONG       xyOffsetDst;            // x & y offset to the current destination DFB
    ULONG       xyOffsetSrc;            // x & y offset to the current source DFB
    LONG        DstPixelDelta;
    LONG        SrcPixelDelta;
    BOOL        bDstOffScreen;

    BYTE*       pjScreen;               // Points to base screen address
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                        //   (our current colour depth)
    CAPS        flCaps;                 // Capabilities flags
    STATUS      flStatus;               // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen
    DSURF*      pdsurfOffScreen;        // Our private DSURF for the back buffer

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDelta;                 // Distance from one scan to the next.
    ULONG       Vrefresh;                // Screen refresh frequency in Hz

    FLONG       flHooks;                // What we're hooking from GDI
    LONG        cjPelSize;              // Number of bytes per pel, according
                                        //   to GDI
    LONG        cPelSize;               // 0 if 8bpp, 1 if 16bpp, 2 if 32bpp
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    ULONG*      pulCtrlBase[3];         // Mapped control registers for this PDEV
                                        //   2 entries to support Dual-TX
                                        //   1 entry for dense alpha mapping
    ULONG*      pulRamdacBase;          // Mapped control registers for the RAMDAC
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    DMA_BUFFER  DMABuffer;                // DMA buffer used by the 2D driver 
                                        //   (currently this is the same buffer as
                                        //   the line buffer in glintInfo)

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       iPalUniq;                // P2 TexelLUT palette tracker
    ULONG       cPalLUTInvalidEntries;    // P2 TexelLUT invalidation tracker
    LUTCACHE    PalLUTType;                // P2 TexelLUT cached object type

    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    OH*         pohScreen;              // Off-screen heap structure for the
                                        //   visible screen
    ////////// Banking stuff:

    LONG        cjBank;                 // Size of a bank, in bytes
    LONG        cPower2ScansPerBank;    // Used by 'bBankComputePower2'
    LONG        cPower2BankSizeInBytes; // Used by 'bBankComputePower2'
    CLIPOBJ*    pcoBank;                // Clip object for banked call backs
    SURFOBJ*    psoBank;                // Surface object for banked call backs
    VOID*       pvBankData;             // Points to aulBankData[0]
    ULONG       aulBankData[BANK_DATA_SIZE / 4];
                                        // Private work area for downloaded
                                        //   miniport banking code

    FNBANKMAP*          pfnBankMap;
    FNBANKSELECTMODE*   pfnBankSelectMode;
    FNBANKCOMPUTE*      pfnBankCompute;

    ////////// Pointer stuff:

    BOOL        bPointerEnabled;

    LONG        xPointerHot;            // xHot of current hardware pointer
    LONG        yPointerHot;            // yHot of current hardware pointer

    LONG        yPointerBuffer;         // Start of off-screen pointer buffer
    LONG        dyPointerCurrent;       // y offset in buffer to current pointer
                                        //   (either 0 or 1)
    ULONG       ulHwGraphicsCursorModeRegister_45;
                                        // Default value for index 45
    PTRFLAGS    flPointer;              // Pointer state flags
    VOID*       pvPointerData;          // Points to ajPointerData[0]
    BYTE        ajPointerData[POINTER_DATA_SIZE];
                                        // Private work area for downloaded
                                        //   miniport pointer code
    ////////// Brush stuff:

    BOOL        bRealizeTransparent;    // Hint to DrvRealizeBrush for whether
                                        //   the brush should be realized as
                                        //   transparent or not
    LONG        cPatterns;              // Count of bitmap patterns created
    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    ULONG       iBrushCacheP3;          // Index for next LUT brush to be allocated
    BRUSHENTRY  abeMono;                // Keeps track of area stipple brush
    BRUSHENTRY  abeP3[MAX_P3_BRUSHES];  // Keeps track of LUT brushes
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    HBITMAP     ahbmPat[HS_DDI_MAX];    // Engine handles to standard patterns

    /////////// Image download scratch area
    OH          *pohImageDownloadArea;
    ULONG       cbImageDownloadArea;

        ////////// Hardware pointer cache stuff:

    HWPointerCache  HWPtrCache;         // The cache data structure itself
    LONG        HWPtrLastCursor;        // The index of the last cursor that we drew
    LONG        HWPtrPos_X;             // The last X position of the cursor
    LONG        HWPtrPos_Y;             // The last Y position of the cursor

    PVOID       glintInfo;              // info about the interface to GLINT
    LONG        currentCtxt;            // id of the context currently loaded
    GlintCtxtTable* pGContextTable;     // pointer to contexts table
    ULONG       g_GlintBoardStatus;     // indicate whether DMA has completed, 
                                        // the GLINT is synced etc

    LONG        FrameBufferLength;      // Length of framebuffer in bytes

    LONG        Disable2DCount;

    // pointers to low level routines
    GFNCOPY     *pgfnCopyBlt;
    GFNCOPY     *pgfnCopyBltNative; //azn unused
    GFNCOPY     *pgfnCopyBltCopyROP;
    GFNFILL     *pgfnFillSolid;
    GFNFILL     *pgfnFillPatMono;
    GFNFILL     *pgfnFillPatColor;
    GFNXFER     *pgfnXfer1bpp;
    GFNXFER     *pgfnXfer4bpp;
    GFNXFER     *pgfnXfer8bpp;
    GFNXFER     *pgfnXferImage;
    GFNXFER     *pgfnXferNative;    //azn unused
    GFNMCPY     *pgfnMaskCopyBlt;
    GFNPATR     *pgfnPatRealize;
    GFNMONO     *pgfnMonoOffset;
    GFNPOLY     *pgfnFillPolygon;
    GFNLINE     *pgfnDrawLine;
    GFNLINE     *pgfnIntegerLine;
    GFNLINE     *pgfnContinueLine;
    GFNINIS     *pgfnInitStrips;
    GFNRSTS     *pgfnResetStrips;
    GFNREPN     *pgfnRepNibbles;    //azn unused
    GFNUPLD     *pgfnUpload;
    GFNCOPYD    *pgfnCopyXferImage;
    GFNCOPYD    *pgfnCopyXfer16bpp; //azn unused
    GFNCOPYD    *pgfnCopyXfer24bpp;
    GFNXCOPYD   *pgfnCopyXfer8bppLge;
    GFNXCOPYD   *pgfnCopyXfer8bpp;
    GFNXCOPYD   *pgfnCopyXfer4bpp;

#if (_WIN32_WINNT >= 0x500)
    GFNGRADRECT     *pgfnGradientFillRect;
    GFNTRANSBLT     *pgfnTransparentBlt;
    GFNALPHABLT     *pgfnAlphaBlend;
#endif

    GAPFNstripFunc  *gapfnStrip;    // Line drawing functions

    // PXRX 2D stuff:
    SendPXRXdma                 sendPXRXdmaForce;        // Will not return until the DMA has been started
    SendPXRXdma                 sendPXRXdmaQuery;        // Will send if there is FIFO space
    SendPXRXdma                 sendPXRXdmaBatch;        // Will only batch the data up
    SwitchPXRXdmaBuffer         switchPXRXdmaBuffer;
    WaitPXRXdmaCompletedBuffer  waitPXRXdmaCompletedBuffer;

#if WNT_DDRAW
    void *      thunkData;                // Opaque pointer to DDRAWs global data
    LONG        DDContextID;            // DDRAW contextID
    LONG        DDContextRefCount;
    DWORD       oldIntEnableFlags;        // Interrupt enable flags when DDRAW started
#endif  //  WNT_DDRAW

} PDEV, *PPDEV;

// azn  -take out???
#define REMOVE_SWPOINTER(surface)

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG, ULONG, RBRUSH*);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

//
// Work out the pixel offset for a DFB. We calculate this for Y only. Because
// we have to support dual-screen on Permedia we need to subtract X from the
// rasterised coordinates to prevent the rasteriser X registers from overflow.
//
#define POH_SET_RECTANGULAR_PIXEL_OFFSET(ppdev, poh) \
{ \
    (poh)->pixOffset = 0; \
}

//
// Convert a pixel offset suitable for a render through the core into
// an offset that can be used to access the frame buffer directly.
// This is trivial when we don't have a Gamma Geo twin. We assume
// that the value is a whole number of scan lines.
//
#define RENDER_PIXOFFSET_TO_FB_PIXOFFSET(pixoff) (pixoff)

//////////////////////////////////////////////////////////////////////
// Cache flag manipulation


#define cFlagFBReadDefault          0x01        // Cache flag definitions
#define cFlagLogicalOpDisabled      0x02
#define cFlagConstantFBWrite        0x04
#define cFlagScreenToScreenCopy     0x08

//@@BEGIN_DDKSPLIT
#define VERIFY_SETFLAGS 0
#define VERIFY_CHECKFLAGS 0
#if DBG && (VERIFY_SETFLAGS || VERIFY_CHECKFLAGS)
    // The following Macros are debug versions. They aren't included in the normal
    // debug build because they do a sync and, hence, slow things down.
    #if VERIFY_CHECKFLAGS
         extern void __CheckFlags(PDEV *p, ULONG x);
        #define CHECK_CACHEFLAGS(p,x) (__CheckFlags(p, (ULONG)x), (p)->cFlags & (x))
    #else
        #define CHECK_CACHEFLAGS(p,x)((p)->cFlags & (x))    // Cache flag macros
    #endif //VERIFY_CHECKFLAGS

    #if VERIFY_SETFLAGS
        #define SET_CACHEFLAGS(p,x)    \
        {    \
            ULONG lop, fbr, cFlags = (p)->cFlags = (x);    \
            SYNC_WITH_GLINT;    \
            READ_GLINT_FIFO_REG (__GlintTagLogicalOpMode, lop);    \
            READ_GLINT_FIFO_REG (__GlintTagFBReadMode, fbr);    \
            READ_GLINT_FIFO_REG (__GlintTagLogicalOpMode, lop);    \
            ASSERTDD ((cFlags & cFlagFBReadDefault) == 0 || ((cFlags & cFlagFBReadDefault) && fbr == glintInfo->FBReadMode),    \
                      "SCF: Bad set fbread cache flag");    \
            /* ASSERTDD (((cFlags & cFlagFBReadDefault) == 0 && fbr != glintInfo->FBReadMode), */ \
            /*          "SCF: Bad clear fbread cache flag"); */    \
            ASSERTDD ((cFlags & cFlagLogicalOpDisabled) == 0 || ((cFlags & cFlagLogicalOpDisabled) && (lop & 0x1) == 0x0),    \
                      "SCF: Bad set logicop cache flag");    \
            /* ASSERTDD (((cFlags & cFlagLogicalOpDisabled) == 0 && (lop & 0x1)), */    \
            /*          "SCF: Bad clear logicop cache flag");    */    \
            ASSERTDD ((cFlags & cFlagConstantFBWrite) == 0 || ((cFlags & cFlagConstantFBWrite) && (lop & (1<<5))),    \
                      "SCF: Bad set const fbwrite cache flag");    \
            /* ASSERTDD (((cFlags & cFlagConstantFBWrite) == 0 && (lop & (1<<5)) == 0x0), */    \
            /*          "SCF: Bad clear const fbwrite cache flag"); */    \
        }
    #else
        #define SET_CACHEFLAGS(p,x)((p)->cFlags = (x))
    #endif //VERIFY_SETFLAGS
    #define ADD_CACHEFLAGS(p,x) ((p)->cFlags |= (x))
#else
// Non-debug version of the cacheflags macros
//@@END_DDKSPLIT
#define CHECK_CACHEFLAGS(p,x)((p)->cFlags & (x))    // Cache flag macros
#define SET_CACHEFLAGS(p,x)((p)->cFlags = (x))
#define ADD_CACHEFLAGS(p,x) ((p)->cFlags |= (x))
//@@BEGIN_DDKSPLIT
#endif  // DBG && 0
//@@END_DDKSPLIT

// These Dbg prototypes are thunks for debugging:

VOID    DbgDisableDriver(VOID); 
ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgLineTo(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, LONG, LONG, LONG,
                  LONG, RECTL*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgSynchronize(DHPDEV, RECTL*);
VOID    DbgDisableSurface(DHPDEV);
BOOL    DbgAssertMode(DHPDEV, BOOL);
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
ULONG   DbgDrawEscape(SURFOBJ *, ULONG, CLIPOBJ *, RECTL *, ULONG, VOID *);
ULONG   DbgEscape(SURFOBJ *, ULONG, ULONG, VOID *, ULONG, VOID *);
BOOL    DbgResetPDEV(DHPDEV, DHPDEV);


#if WNT_DDRAW
BOOL    DbgGetDirectDrawInfo(DHPDEV, DD_HALINFO*, DWORD*, VIDEOMEMORY*,
                             DWORD*, DWORD*);
BOOL    DbgEnableDirectDraw(DHPDEV, DD_CALLBACKS*, DD_SURFACECALLBACKS*,
                            DD_PALETTECALLBACKS*);
VOID    DbgDisableDirectDraw(DHPDEV);
#endif // WNT_DDRAW


#if (_WIN32_WINNT >= 0x500)
BOOL DbgIcmSetDeviceGammaRamp(DHPDEV dhpdev, ULONG iFormat, LPVOID lpRamp);
BOOL DbgGradientFill(SURFOBJ *, CLIPOBJ *, XLATEOBJ *, TRIVERTEX *, ULONG, PVOID, ULONG, RECTL *, 
                     POINTL *, ULONG);
BOOL DbgAlphaBlend(SURFOBJ *, SURFOBJ *, CLIPOBJ *, XLATEOBJ *, RECTL *, RECTL *, BLENDOBJ *);
BOOL DbgTransparentBlt(SURFOBJ *, SURFOBJ *, CLIPOBJ *, XLATEOBJ *, RECTL *, RECTL *, ULONG, ULONG);
VOID DbgNotify(IN SURFOBJ *, IN ULONG, IN PVOID);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\debug.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           *   SAMPLE CODE   *
*                           *******************
*
* Module Name: debug.h
*
* Content: Debugging support macros and structures
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __DEBUG_H
#define __DEBUG_H

//-----------------------------------------------------------------------------
//
// **************************** DISPDBG LEVELS ********************************
//
//-----------------------------------------------------------------------------

// Global warning levels. We can easily modify any source file to dump all of
// its debug messages by undef'ing and redefining this symbols.
#define DBGLVL 4
#define WRNLVL 2
#define ERRLVL 0

//-----------------------------------------------------------------------------
//
// ************************* DEBUG SUPPORT SWITCHES **************************
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
//                      FUNCTION ENTRY/EXIT TRACKING
//
// In order to activate function entry/exit tracking , you need to define 
// DBG_TRACK_FUNCS to 1, and (unfortunately) instrument your code so that it
// uses DBG_ENTRY and DBG_EXIT right after entry and right before exit from
// the functions you are interested in.
//
// DBG_EXIT can also be supplied a DWORD result which can be tracked in order
// to know the result of different calls (but the mechanism already tracks 
// function returns happening in different lines of code for you).
//
// After gathering results, Debug_Func_Report_And_Reset has to be called in 
// order to dump them into the remote debugger output. This is done in this 
// sample driver within the DrvEscape GDI callback and using the dispdbg.exe 
// program to send the right escape codes. You can modify this to suit your
// needs.
//
// After Debug_Func_Report_And_Reset is done reporting results, it will reset 
// all of its counters in order to retstart another cycle.
//
// Be aware that DEBUG_MAX_FUNC_COUNT and DEBUG_MAX_RETVALS govern how many
// function calls and function return results can be stored as a maximum. They
// may be adjusted too to suit your own needs. Any data that doesn't fit
// within those maximums will be thrown away.
//
//-----------------------------------------------------------------------------
#define DBG_TRACK_FUNCS 0

//-----------------------------------------------------------------------------
//
//                          CODE COVERAGE TRACKING
//
// In order to do code coverage tracking, you need to define DBG_TRACK_CODE to 1
// NO CODE INSTRUMENTATION IS NECESSARY!. This will track all if and while
// statements executed in the code and which branch (TRUE or FALSE) was taken,
// and how many times it was taken.
//
// Be aware that the below defined DBG_TRACK_CODE is just a default for all 
// files that include debug.h. If you want to exclude (or include) a file
// manually, you can define DBG_TRACK_CODE inside it just before including
// debug.h . You cannot activate/deactivate code tracking for individual
// functions or sections of code, just on a per-file basis.
//
// After gathering results, Debug_Code_Report_And_Reset has to be called in 
// order to dump them into the remote debugger output. This is done in this 
// sample driver within the DrvEscape GDI callback and using the dispdbg.exe 
// program to send the right escape codes. You can modify this to suit your
// needs.
//
// After Debug_Code_Report_And_Reset is done reporting results, it will reset 
// all of its counters in order to retstart another cycle.
//
// If DBG_TRACK_CODE_REPORT_PROBLEMS_ONLY is set to 1, only branch statements
// that are potential trouble makers (like if branches that might have been
// never taken or while bodies never entered into) will be reported. If set to
// 0, all gathered data will be dumped (this is quite a lot of data!)
//
// Be aware that DEBUG_MAX_CODE_COUNT governs how many statements (branches)
// can be stored as a maximum. It may be adjusted too to suit your own needs. 
// Any data that doesn't fit within the maximum will be thrown away.
//
//-----------------------------------------------------------------------------
#ifndef DBG_TRACK_CODE
#define DBG_TRACK_CODE  0
#define DBG_DEFAULT_TRACK_CODE DBG_TRACK_CODE
#endif

#if (DBG_DEFAULT_TRACK_CODE == DBG_TRACK_CODE)
#define DBG_TRACK_CODE_NON_DEFAULT 0
#else
// some source file is already using non-default code tracking!
#define DBG_TRACK_CODE_NON_DEFAULT 1
#endif

#define DBG_TRACK_CODE_REPORT_PROBLEMS_ONLY 0

//-----------------------------------------------------------------------------
// Escapes for reporting debugging results through 
// the remote debugger using dbgdisp.exe
//-----------------------------------------------------------------------------
#define ESCAPE_TRACK_FUNCTION_COVERAGE  1100
#define ESCAPE_TRACK_CODE_COVERAGE      1101
#define ESCAPE_TRACK_MEMORY_ALLOCATION  1102

#ifdef DBG_EA_TAGS
#define ESCAPE_EA_TAG 1103
#endif

//-----------------------------------------------------------------------------
//
// ****************** FUNCTION COVERAGE DEBUGGING SUPPORT ********************
//
//-----------------------------------------------------------------------------
#if (DBG_TRACK_FUNCS && DBG)
VOID Debug_Func_Entry(VOID *pFuncAddr,
                      char *pszFuncName, 
                      DWORD dwLine , 
                      char *pszFileName); 
                      
VOID Debug_Func_Exit(VOID *pFuncAddr,
                     DWORD dwRetVal,                       
                     DWORD dwLine);

VOID Debug_Func_Report_And_Reset(void);

            
#define DBG_ENTRY(pszFuncName)                      \
            Debug_Func_Entry((VOID *)pszFuncName,   \
                                    #pszFuncName,   \
                                    __LINE__ ,      \
                                    __FILE__ )
                                    
#define DBG_EXIT(pszFuncName,dwRetVal)              \
            Debug_Func_Exit((VOID *)pszFuncName,    \
                                   dwRetVal,        \
                                   __LINE__)
                                                                      
#define DBG_CB_ENTRY   DBG_ENTRY
#define DBG_CB_EXIT    DBG_EXIT
#else // DBG_TRACK_FUNCS
#define Debug_Func_Report_And_Reset()

#define DBG_ENTRY(pszFuncName)                                        \
        DISPDBG((DBGLVL,"Entering %s",#pszFuncName))
#define DBG_EXIT(pszFuncName,dwRetVal)                                \
        DISPDBG((DBGLVL,"Exiting  %s dwRetVal = %d",#pszFuncName,dwRetVal))

#ifdef DBG_EA_TAGS
extern DWORD g_dwTag;
#include "EATags.h"
#define DBG_CB_ENTRY(pszFuncName)                      \
{                                                      \
    if (g_dwTag == (EA_TAG_ENABLE | pszFuncName##_ID)) \
        while (1);                                     \
    DISPDBG((DBGLVL,"Entering %s",#pszFuncName));      \
}
#else // DBG_EA_TAGS
#define DBG_CB_ENTRY   DBG_ENTRY
#endif // DBG_EA_TAGS

#define DBG_CB_EXIT    DBG_EXIT

#endif // DBG_TRACK_FUNCS

//-----------------------------------------------------------------------------
//
// ******************** STATEMENT COVERAGE DEBUGGING SUPPORT ******************
//
//-----------------------------------------------------------------------------

#if (DBG_TRACK_CODE && _X86_ && DBG)

// Never change these values!
#define DBG_IF_CODE     1
#define DBG_WHILE_CODE  2
#define DBG_SWITCH_CODE 3
#define DBG_FOR_CODE    4

BOOL 
Debug_Code_Coverage(
    DWORD dwCodeType, 
    DWORD dwLine , 
    char *pszFileName,
    BOOL bCodeResult);

VOID Debug_Code_Report_And_Reset(void);

#define if(b) \
        if(Debug_Code_Coverage(DBG_IF_CODE,__LINE__,__FILE__,(BOOL)(b)))
#define while(b) \
        while(Debug_Code_Coverage(DBG_WHILE_CODE,__LINE__,__FILE__,(BOOL)(b)))
#define switch(val) \
        switch(Debug_Code_Coverage(DBG_SWITCH_CODE,__LINE__,__FILE__,(val)))

#endif // DBG_TRACK_CODE && _X86_

#if ((DBG_TRACK_CODE || DBG_TRACK_CODE_NON_DEFAULT) && _X86_ && DBG)
VOID Debug_Code_Report_And_Reset(void);
#else
#define Debug_Code_Report_And_Reset()
#endif

//-----------------------------------------------------------------------------
//
// ************************ MEMORY ALLOCATION SUPPORT *************************
//
//-----------------------------------------------------------------------------

#define ENGALLOCMEM(Flags, Size, Tag)  EngAllocMem(Flags, Size, Tag)
#define ENGFREEMEM(Pointer)            EngFreeMem(Pointer)


//-----------------------------------------------------------------------------
//
//  ******************** PUBLIC DATA STRUCTURE DUMPING ************************
//
//-----------------------------------------------------------------------------

extern char *pcSimpleCapsString(DWORD dwCaps);

#if DBG && defined(LPDDRAWI_DDRAWSURFACE_LCL)

extern void DumpD3DBlend(int Level, DWORD i );
extern void DumpD3DMatrix(int Level, D3DMATRIX* pMatrix);
extern void DumpD3DMaterial(int Level, D3DMATERIAL7* pMaterial);
extern void DumpD3DLight(int DebugLevel, D3DLIGHT7* pLight);
extern void DumpDDSurface(int Level, LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface);
extern void DumpDDSurfaceDesc(int DebugLevel, DDSURFACEDESC* pDesc);
extern void DumpDP2Flags( DWORD lvl, DWORD flags );

#define DBGDUMP_DDRAWSURFACE_LCL(a, b) DumpDDSurface(a, b);
#define DBGDUMP_DDSURFACEDESC(a, b)    DumpDDSurfaceDesc(a, b); 
#define DBGDUMP_D3DMATRIX(a, b)        DumpD3DMatrix(a, b);
#define DBGDUMP_D3DMATERIAL7(a, b)     DumpD3DMaterial(a, b);
#define DBGDUMP_D3DLIGHT7(a, b)        DumpD3DLight(a, b);
#define DBGDUMP_D3DBLEND(a, b)         DumpD3DBlend(a, b);
#define DBGDUMP_D3DDP2FLAGS(a, b)      DumpDP2Flags(a, b)

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else  // DBG

#define DBGDUMP_DDRAWSURFACE_LCL(a, b)
#define DBGDUMP_D3DMATRIX(a, b)
#define DBGDUMP_D3DMATERIAL7(a, b)
#define DBGDUMP_D3DLIGHT7(a, b)
#define DBGDUMP_DDSURFACEDESC(a, b)
#define DBGDUMP_D3DBLEND(a, b)
#define DBGDUMP_D3DDP2FLAGS(a, b)   

#endif // DBG

//-----------------------------------------------------------------------------
//
//  ********************** LOW LEVEL DEBUGGING SUPPORT ************************
//
//-----------------------------------------------------------------------------
#if DBG

extern LONG  P3R3DX_DebugLevel;

#ifdef WNT_DDRAW
extern VOID __cdecl DebugPrintNT(LONG DebugPrintLevel, PCHAR DebugMessage, ...);
#define DebugPrint DebugPrintNT
#else
extern VOID __cdecl DebugPrint(LONG DebugPrintLevel, PCHAR DebugMessage, ...);
#endif // WNT_DDRAW

#define DISPDBG(arg) DebugPrint arg

#if WNT_DDRAW
#define DebugRIP    EngDebugBreak
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#else
extern VOID DebugRIP();
#ifdef FULLDEBUG
// Use an int1 per ASSERT, so that we can zap them individually.
#define RIP(x) { DebugPrint(-1000, x); _asm int 1 }
#else
// If only on DEBUG, we don't want to break compiler optimisations.
#define RIP(x) { DebugPrint(-1000, x); DebugRIP();}
#endif // FULLDEBUG
#endif // WNT_DDRAW

#define ASSERTDD(x, y) if (0 == (x))  RIP (y) 

#define ASSERTDBG(x, y) do { if( !(x) ) { DebugPrint y; DebugBreak(); }; } while(0)

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else  // DBG

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define ASSERTDBG(x, y) do { ; } while(0)

#endif // DBG

// Makes a label that is only there in the debug build -
// very useful for putting instant named breakpoints at.
#if DBG
#define MAKE_DEBUG_LABEL(label_name)                                \
{                                                                   \
    goto label_name;                                                \
    label_name:                                                     \
    ;                                                               \
}
#else
#define MAKE_DEBUG_LABEL(label_name) NULL
#endif

//-----------------------------------------------------------------------------
//
//  ****************** HARDWARE DEPENDENT DEBUGGING SUPPORT *******************
//
//-----------------------------------------------------------------------------

#if DBG

extern BOOL g_bDetectedFIFOError;
extern BOOL CheckFIFOEntries(DWORD a);
extern void ColorArea(ULONG_PTR pBuffer, DWORD dwWidth, DWORD dwHeight, 
                      DWORD dwPitch, int iBitDepth, DWORD dwValue);
extern void CheckChipErrorFlags();
#ifndef WNT_DDRAW
typedef void *GlintDataPtr;
#endif
extern const char *getTagString(GlintDataPtr glintInfo,ULONG tag);
const char *p3r3TagString( ULONG tag );

#define CHECK_ERROR()   CheckChipErrorFlags()
#define COLORAREA(a, b, c, d, e, f) ColorArea(a, b, c, d, e, f);
#define CHECK_FIFO(a)                                    \
    if (CheckFIFOEntries(a))                             \
    {                                                    \
        DISPDBG((ERRLVL,"Out of FIFO/DMA space %s: %d",  \
                    __FILE__, __LINE__));                \
        DebugRIP();                                      \
    }
#define GET_TAG_STR(tag)    getTagString(glintInfo, tag)

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else  // DBG

#define CHECK_ERROR()
#define COLORAREA(a,b,c,d,e,f)
#define CHECK_FIFO(a)
#define GET_TAG_STR(tag)

#endif // DBG

#endif // __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\ereg.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: ereg.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifdef __EREG
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __EREG

#ifndef _MSDOS 
typedef unsigned long unsigned32;
typedef signed long signed32;
#else
typedef unsigned long unsigned32;
typedef signed long signed32;
#endif

#define TAGBITS         12
#define CONTEXTBITS     1
#define ADDRBITS        (32 - TAGBITS - CONTEXTBITS)

#define ENABLE_BLOCK    1
#define DISABLE_BLOCK   0

#define X_FIELD_MAX     0x7FFF      /* signed 16 bits */
#define Y_FIELD_MAX     X_FIELD_MAX

typedef unsigned32     _