]+1] = 0x0d;
    printf("LOADMOD %d\n",LoadModule(buf,&lmp));
}

void
spawntst()
{
    CHAR buf[256];
    int i;

    printf("name -> ");
    scanf("%s",buf);
    i = _spawnlp(_P_WAIT,buf,"-l",NULL);
}

void
badproctst()
{
    CHAR buf[256];
    DWORD dw;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    LOAD_MODULE_PARAMS lmp;
    CHAR Environment[256];
    CMDSHOW cs;

    printf("name -> ");
    scanf("%s",buf);

    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    SetLastError(0);
    CreateProcess(
        NULL,
        buf,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        "*",
        &StartupInfo,
        &ProcessInformation
        );
    printf("GLE %d\n",GetLastError());
}

void
copytst()
{
    CHAR src[256];
    CHAR dst[256];
    BOOL b;

    printf("src -> ");
    scanf("%s",src);
    printf("dst -> ");
    scanf("%s",dst);

    b = CopyFile(src,dst,FALSE);
}

void
fftst()
{
    CHAR buf[256];
    HANDLE fFile;
    WIN32_FIND_DATA FindFileData;
    BOOL b;

    printf("pattern -> ");
    scanf("%s",buf);

    fFile =  FindFirstFile(
                buf,
                &FindFileData
                );
    if ( fFile == INVALID_HANDLE_VALUE ){
        printf("findfirst %s failed %d\n",buf,GetLastError());
        return;
        }

    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData.dwFileAttributes,
            FindFileData.nFileSizeLow,
            FindFileData.cFileName
            );
        b = FindNextFile(fFile,&FindFileData);
        }
    FindClose(fFile);
}

void
oftst()
{
    OFSTRUCT OfStruct;
    HFILE rv;

    rv = OpenFile("",&OfStruct, OF_EXIST);
    printf("rv %d\n",rv);

    rv = OpenFile(NULL,&OfStruct, OF_EXIST);
    printf("rv %d\n",rv);

    rv = OpenFile(" ",&OfStruct, OF_EXIST);
    printf("rv %d\n",rv);
}

void
spath()
{

    char cbuff[512];

    SearchPath(
        "c:\\nt;c:\\xytty;c:\\nt\\system",
        "kernel32",
        ".dll",
        512,
        cbuff,
        NULL
        );
    printf("%s\n",cbuff);
}

void
muldivtst()
{
    int answer,number,numerator,denom,result;
    PERFINFO PerfInfo;
    ULONG Index;

    StartBenchMark("MulDiv)",
                   50000,
                   &PerfInfo);

    for(Index=0;Index<50000;Index++){
    //
    // answer = -24
    //
    number = -18;
    numerator = 96;
    denom = 72;
    answer = -24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = -24
    //
    number = 18;
    numerator = -96;
    denom = 72;
    answer = -24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = 24
    //
    number = -18;
    numerator = -96;
    denom = 72;
    answer = 24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = -24
    //
    number = -18;
    numerator = -96;
    denom = -72;
    answer = -24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = -24
    //
    number = -18;
    numerator = -96;
    denom = -72;
    answer = -24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = 24
    //
    number = 18;
    numerator = -96;
    denom = -72;
    answer = 24;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");


    //
    // answer = 2
    //
    number = 4;
    numerator = 2;
    denom = 5;
    answer = 2;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = 500
    //

    number = 100;
    numerator = 10;
    denom = 2;
    answer = 500;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=%ld %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    //
    // answer = 3b9aca00
    //

    number = 1000000;
    numerator = 1000000;
    denom = 1000;
    answer = 0x3b9aca00;
    result = MulDiv(number,numerator,denom);
    if ( answer != result ) printf("MulDiv(%ld,%ld,%ld)=0x%lx %s\n",number,numerator,denom,result,answer == result ? "SUCCESS" : "FAILED");

    }
    FinishBenchMark(&PerfInfo);

}

void
dname()
{
    UNICODE_STRING LinkName;
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    NTSTATUS Status;
    ULONG i;
    PWCHAR p;
    WCHAR DeviceNameBuffer[MAXIMUM_FILENAME_LENGTH];

    RtlInitUnicodeString(&LinkName,L"\\DosDevices\\A:");
    p = (PWCHAR)LinkName.Buffer;
    p = p+12;
    for(i=0;i<26;i++){
        *p = (WCHAR)'A'+i;

        InitializeObjectAttributes(
            &Obja,
            &LinkName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
        Status = NtOpenSymbolicLinkObject(
                    &LinkHandle,
                    SYMBOLIC_LINK_QUERY,
                    &Obja
                    );
        if (NT_SUCCESS( Status )) {

            //
            // Open succeeded, Now get the link value
            //

            DeviceName.Length = 0;
            DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
            DeviceName.Buffer = DeviceNameBuffer;

            Status = NtQuerySymbolicLinkObject(
                        LinkHandle,
                        &DeviceName,
                        NULL
                        );
            NtClose(LinkHandle);
            if ( NT_SUCCESS(Status) ) {
                printf("%wZ -> %wZ\n",&LinkName,&DeviceName);
                }
            }
        }

}

void
mfextst()
{
    MoveFileExW(L"C:\\tmp\\xx.xx", NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
}

CRITICAL_SECTION cs;

VOID
StartBounce(PVOID pThreadBlockInfo)
{
    EnterCriticalSection(&cs);
    Sleep(-1);
}

void
lockuptst()
{
    HANDLE hThread;
    DWORD id;

    InitializeCriticalSection(&cs);

    hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)StartBounce,
                    0,
                    0,
                    &id
                    );
    EnterCriticalSection(&cs);
    Sleep(-1);
}
void
getdisktst()
{
    BOOL b;
    DWORD spc,bps,fc,tc;

    b = GetDiskFreeSpace(NULL,&spc,&bps,&fc,&tc);
    printf("GetDiskFreeSpace NULL %s\n",b ? "WORKED" : "FAILED" );

    b = GetDiskFreeSpace("C:\\",&spc,&bps,&fc,&tc);
    printf("GetDiskFreeSpace C:\\ %s\n",b ? "WORKED" : "FAILED" );

    b = GetDiskFreeSpace("C:\\WINNT\\",&spc,&bps,&fc,&tc);
    printf("GetDiskFreeSpace C:\\winnt\\ %s\n",b ? "WORKED" : "FAILED" );
}

void
DoChoice(
    int Choice
    )
{
    NTSTATUS Status;
    LONG *p;

top:
    printf("exception test\n");
    printf("1 Access Violation(r)\n");
    printf("2 Access Violation(w)\n");
    printf("3 Array Bounds    \n");
    printf("4 Int Divide By Zero\n");
    printf("5 Software 0x77\n");
    printf("6 bigpath\n");
    printf("7 set default harderror\n");
    printf("8 proftests\n");
    printf("9 probetests\n");
    printf("10 notifytests\n");
    printf("11 openif\n");
    printf("12 null server\n");
    printf("13 path convert\n");
    printf("14 bogus ordinal\n");
    printf("15 winword openfile\n");
    printf("16 scroll test\n");
    printf("17 winword getdrivetype\n");
    printf("18 dorip\n");
    printf("19 Ofprompt\n");
    printf("20 rtldevn\n");
    printf("21 cptst\n");
    printf("22 oftst\n");
    printf("23 dname\n");
    printf("24 fftst\n");
    printf("25 copy\n");
    printf("26 badproc\n");
    printf("27 loadlib\n");
    printf("28 gettictst(0)\n");
    printf("29 latst\n");
    printf("30 gettictst(1)\n");
    printf("31 spath\n");
    printf("32 spawntst\n");
    printf("33 muldivtst\n");
    printf("34 mfextst\n");
    printf("35 lockuptst\n");
    printf("36 getdisktst\n");

    printf("Enter Choice --> ");
    scanf("%d",&Choice);
    printf("Good Choice... %d\n",Choice);

    switch ( Choice ) {
    case 1:
        SetErrorMode(SEM_NOGPFAULTERRORBOX);
        printf("Good Choice... %d\n",Choice);
        p = (int *)0xbaadadd0;
        Choice = *p;
        break;

    case 2:
        printf("Good Choice... %d\n",Choice);
        p = (int *)0xbaadadd0;
        *p = Choice;
        break;

    case 3:
        printf("Good Choice... %d\n",Choice);
        RtlRaiseStatus(STATUS_ARRAY_BOUNDS_EXCEEDED);
        break;

    case 4:
        printf("Good Choice... %d\n",Choice);
        Choice = Choice/izero;
        break;

    case 5:
        printf("Good Choice... %d\n",Choice);
        {
            UINT b;
            b = SetErrorMode(SEM_FAILCRITICALERRORS);
            xassert(b == 0);
            b = SetErrorMode(0);
            xassert(b == SEM_FAILCRITICALERRORS);
        }
        RtlRaiseStatus(0x77);
        break;

    case 6:
        printf("Good Choice... %d\n",Choice);
        {
            DWORD Bsize;
            DWORD Rsize;
            LPSTR Buff;
            LPSTR Ruff;
            DWORD Rvalue;
            LPSTR whocares;
            int i;

            printf("Enter Size --> ");
            scanf("%d",&Bsize);
            printf("Enter RSize --> ");
            scanf("%d",&Rsize);

            Buff = LocalAlloc(0,Bsize+1);
            xassert(Buff);
            Ruff = LocalAlloc(0,Bsize+1);
            xassert(Buff);
            RtlFillMemory(Buff,Bsize,'a');
            Buff[0]='c';
            Buff[1]=':';
            Buff[2]='\\';
            Buff[Bsize+1] = '\0';
            Rvalue = GetFullPathName(Buff,Rsize,Ruff,&whocares);
            i = strcmp(Buff,Ruff);
            printf("Bsize %d Rsize %d Rvalue %d i=%d \n",Bsize,Rsize,Rvalue,i);

        }
        break;

    case 7:
        printf("Good Choice... %d\n",Choice);
        Status = NtSetDefaultHardErrorPort(NULL);
        xassert(Status == STATUS_PRIVILEGE_NOT_HELD);
        break;
    case 8:
        printf("Good Choice... %d\n",Choice);
        proftst();
        break;
    case 9:
        printf("Good Choice... %d\n",Choice);
        probtst();
        break;

    case 10:
        printf("Good Choice... %d\n",Choice);
        notifytst();
        break;

    case 11:
        printf("Good Choice... %d\n",Choice);
        openiftst();
        break;

    case 12:
        printf("Good Choice... %d\n",Choice);
        NullServerSwitchTest();
        break;

    case 13:
        PathConvertTest();
        break;

    case 14:
        BogusOrdinalTest();
        break;

    case 15:
        WinWordOpenFileTest();
        break;

    case 16:
        ScrollTest();
        break;

    case 17:
        WinWordGetDriveTypeTest();
        break;
    case 18:
        NewRip(0,"Just a warning\n");
        NewRip(1,"We Are Hosed\n");
        break;

    case 19:
        Ofprompt();
        break;

    case 20:
        rtldevn();
        break;

    case 21:
        cptst();
        break;

    case 22:
        oftst();
        break;

    case 23:
        dname();
        break;

    case 24:
        fftst();
        break;

    case 25:
        copytst();
        break;

    case 26:
        badproctst();
        break;

    case 27:
        {
        HANDLE hmods,hmodc,hmodw;
        hmods = LoadLibrary("shell32");
        hmodc = LoadLibrary("cmd.exe");
        hmodw = LoadLibrary("winspool.drv");
        FreeLibrary(hmods);
        FreeLibrary(hmodc);
        FreeLibrary(hmodw);
        }
        break;

    case 28:
        gettictst(0);
        break;

    case 29:
        latst();
        break;

    case 30:
        gettictst(1);
        break;

    case 31:
        spath();
        break;

    case 32:
        spawntst();
        break;

    case 33:
        muldivtst();
        break;

    case 34:
        mfextst();
        break;

    case 35:
        lockuptst();
        break;

    case 36:
        getdisktst();
        break;

    default:
        printf( "Bad choice: %d\n", Choice );
        return;
    }

    return;
}

//#define NtCurrentTebAsm() {PTEB Teb;_asm{mov eax,fs:[0x24]};,Teb;}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    int Choice;
    char b[512];


  //  PTEB x;
  //
  //  x = NtCurrentTebAsm();

    GetDriveTypeW(L"A:\\");
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_HIGHEST);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_LOWEST));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_LOWEST);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_ABOVE_NORMAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_ABOVE_NORMAL);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_BELOW_NORMAL);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_NORMAL);

    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_IDLE));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_IDLE);
    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_TIME_CRITICAL);

    xassert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL));
    xassert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_NORMAL);

    xassert(!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST+1));
    xassert(GetThreadPriority(GetCurrentProcess()) == THREAD_PRIORITY_ERROR_RETURN);

    SetErrorMode(0);

    GetSystemDirectory(b,512);
    printf("%s\n",b);
    GetWindowsDirectory(b,512);
    printf("%s\n",b);
    printf("TEBSIZE %d\n",sizeof(TEB));
    Choice = GetModuleFileName(NULL,b,512);
    if ( strlen(b) != Choice ) {
        printf("BAD strlen(b) = %d Choice %d b= %s\n",strlen(b),Choice,b);
        }
    else {
        printf("OK strlen(b) = %d Choice %d b= %s\n",strlen(b),Choice,b);
        }
    if (argc > 1) {
        while (--argc) {
            DoChoice( atoi( *++argv ) );
            }
        }
    else {
        while (TRUE) {
            DoChoice( Choice );
            }
        }
    //GetUserNameW(b,1);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\updrsrc.cpp ===
/******************************************************************************

    PROGRAM: updres.c

    PURPOSE: Contains API Entry points and routines for updating resource
                sections in exe/dll

    FUNCTIONS:

        EndUpdateResource(HANDLE, BOOL)         - end update, write changes
        UpdateResource(HANDLE, LPSTR, LPSTR, WORD, PVOID)
                                                - update individual resource
        BeginUpdateResource(LPSTR)              - begin update

*******************************************************************************/

#include "basedll.h"
#pragma hdrstop

#include <updrsrc.h>
#include <strsafe.h>

char    *pchPad = "PADDINGXXPADDING";
char    *pchZero = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";

#define FREE_RES_ID( _Res_ )                             \
    if (IS_ID == (_Res_)->discriminant)                  \
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)(_Res_)) \


/****************************************************************************
**
** API entry points
**
****************************************************************************/


HANDLE
APIENTRY
BeginUpdateResourceW(
                    LPCWSTR pwch,
                    BOOL bDeleteExistingResources
                    )

/*++
    Routine Description
        Begins an update of resources.  Save away the name
        and current resources in a list, using EnumResourceXxx
        api set.

    Parameters:

        lpFileName - Supplies the name of the executable file that the
        resource specified by lpType/lpName/language will be updated
        in.  This file must be able to be opened for writing (ie, not
        currently executing, etc.)  The file may be fully qualified,
        or if not, the current directory is assumed.  It must be a
        valid Windows executable file.

        bDeleteExistingResources - if TRUE, existing resources are
        deleted, and only new resources will appear in the result.
        Otherwise, all resources in the input file will be in the
        output file unless specifically deleted or replaced.

    Return Value:

    NULL - The file specified was not able to be opened for writing.
    Either it was not an executable image, the executable image is
    already loaded, or the filename did not exist.  More information may
    be available via GetLastError api.

    HANDLE - A handle to be passed to the UpdateResource and
    EndUpdateResources function.
--*/

{
    HMODULE     hModule;
    PUPDATEDATA pUpdate;
    HANDLE      hUpdate;
    LPWSTR      pFileName;
    DWORD       attr;
    size_t      cchFileNameLen;
    HRESULT     hr;

    SetLastError(NO_ERROR);
    if (pwch == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    hUpdate = GlobalAlloc(GHND, sizeof(UPDATEDATA));
    if (hUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup;
    }
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup_hupdate;
    }

    hr = StringCchLengthW(pwch, STRSAFE_MAX_CCH, &cchFileNameLen);
    if (FAILED(hr)) {
        SetLastError(HRESULT_CODE(hr));
        goto cleanup_pupdate;
    }

    pUpdate->Status = NO_ERROR;
    pUpdate->hFileName = GlobalAlloc(GHND, (cchFileNameLen+1)*sizeof(WCHAR));
    if (pUpdate->hFileName == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup_pupdate;
    }
    pFileName = (LPWSTR)GlobalLock(pUpdate->hFileName);
    if (pFileName == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup_pfilename;
    }
    hr = StringCchCopyW(pFileName,
                        cchFileNameLen + 1,
                        pwch);

    GlobalUnlock(pUpdate->hFileName);

    if (FAILED(hr)) {
        SetLastError(HRESULT_CODE(hr));
        goto cleanup_pfilename;
    }

    attr = GetFileAttributesW(pFileName);
    if (attr == 0xffffffff) {
        goto cleanup_pfilename;
    } else if (attr & (FILE_ATTRIBUTE_READONLY |
                       FILE_ATTRIBUTE_SYSTEM |
                       FILE_ATTRIBUTE_HIDDEN |
                       FILE_ATTRIBUTE_DIRECTORY)) {
        SetLastError(ERROR_WRITE_PROTECT);
        goto cleanup_pfilename;
    }

    if (bDeleteExistingResources)
        ;
    else {
        hModule = LoadLibraryExW(pwch, NULL,LOAD_LIBRARY_AS_DATAFILE| DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL) {
            if (GetLastError() == NO_ERROR)
                SetLastError(ERROR_BAD_EXE_FORMAT);
            goto cleanup_pfilename;
        } else
            EnumResourceTypesW(hModule, (ENUMRESTYPEPROCW)EnumTypesFunc, (LONG_PTR)pUpdate);
        FreeLibrary(hModule);
    }

    if (pUpdate->Status != NO_ERROR) {
        // return code set by enum functions
        goto cleanup_pfilename;
    }
    GlobalUnlock(hUpdate);
    return hUpdate;

 cleanup_pfilename:
    GlobalFree(pUpdate->hFileName);

 cleanup_pupdate:
    GlobalUnlock(hUpdate);
    
 cleanup_hupdate:
    GlobalFree(hUpdate);

 cleanup:
    return NULL;
}



HANDLE
APIENTRY
BeginUpdateResourceA(
                    LPCSTR pch,
                    BOOL bDeleteExistingResources
                    )

/*++
    Routine Description

    ASCII entry point.  Convert filename to UNICODE and call
    the UNICODE entry point.

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString, pch);
    Status = RtlAnsiStringToUnicodeString(Unicode, &AnsiString, FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            //BaseSetLastNTError(Status);
            SetLastError(RtlNtStatusToDosError(Status));
        }
        return FALSE;
    }

    return BeginUpdateResourceW((LPCWSTR)Unicode->Buffer,bDeleteExistingResources);
}



BOOL
APIENTRY
UpdateResourceW(
               HANDLE      hUpdate,
               LPCWSTR     lpType,
               LPCWSTR     lpName,
               WORD        language,
               LPVOID      lpData,
               ULONG       cb
               )

/*++
    Routine Description
        This routine adds, deletes or modifies the input resource
        in the list initialized by BeginUpdateResource.  The modify
        case is simple, the add is easy, the delete is hard.
        The ASCII entry point converts inputs to UNICODE.

    Parameters:

        hUpdateFile - The handle returned by the BeginUpdateResources
        function.

        lpType - Points to a null-terminated character string that
        represents the type name of the resource to be updated or
        added.  May be an integer value passed to MAKEINTRESOURCE
        macro.  For predefined resource types, the lpType parameter
        should be one of the following values:

          RT_ACCELERATOR - Accelerator table
          RT_BITMAP - Bitmap resource
          RT_DIALOG - Dialog box
          RT_FONT - Font resource
          RT_FONTDIR - Font directory resource
          RT_MENU - Menu resource
          RT_RCDATA - User-defined resource (raw data)
          RT_VERSION - Version resource
          RT_ICON - Icon resource
          RT_CURSOR - Cursor resource



        lpName - Points to a null-terminated character string that
        represents the name of the resource to be updated or added.
        May be an integer value passed to MAKEINTRESOURCE macro.

        language - Is the word value that specifies the language of the
        resource to be updated.  A complete list of values is
        available in winnls.h.

        lpData - A pointer to the raw data to be inserted into the
        executable image's resource table and data.  If the data is
        one of the predefined types, it must be valid and properly
        aligned.  If lpData is NULL, the specified resource is to be
        deleted from the executable image.

        cb - count of bytes in the data.

    Return Value:

    TRUE - The resource specified was successfully replaced in, or added
    to, the specified executable image.

    FALSE/NULL - The resource specified was not successfully added to or
    updated in the executable image.  More information may be available
    via GetLastError api.
--*/


{
    PUPDATEDATA pUpdate;
    PSDATA      Type;
    PSDATA      Name;
    PVOID       lpCopy;
    LONG        fRet;

    SetLastError(0);
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        // GlobalLock set last error, nothing to unlock.
        return FALSE;
    }
    Name = AddStringOrID(lpName, pUpdate);
    if (Name == NULL) {
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    Type = AddStringOrID(lpType, pUpdate);
    if (Type == NULL) {
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        FREE_RES_ID(Name);
        FreeStrings(pUpdate);
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    if (cb == 0) {
        lpCopy = NULL;
    } else {
        lpCopy = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
        if (lpCopy == NULL) {
            pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
            FREE_RES_ID(Type);
            FREE_RES_ID(Name);
            FreeStrings(pUpdate);
            GlobalUnlock(hUpdate);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        RtlCopyMemory(lpCopy, lpData, cb);
    }
    fRet = AddResource(Type, Name, language, pUpdate, lpCopy, cb);
    if (fRet == NO_ERROR) {
        GlobalUnlock(hUpdate);
        return TRUE;
    } else {
        FreeData(pUpdate);
        GlobalUnlock(hUpdate);
        if (lpCopy != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, lpCopy);
        SetLastError(fRet);
        return FALSE;
    }
}



BOOL
APIENTRY
UpdateResourceA(
               HANDLE      hUpdate,
               LPCSTR      lpType,
               LPCSTR      lpName,
               WORD        language,
               LPVOID      lpData,
               ULONG       cb
               )
{
    LPCWSTR     lpwType;
    LPCWSTR     lpwName;
    INT         cch;
    UNICODE_STRING UnicodeType;
    UNICODE_STRING UnicodeName;
    STRING      string;
    BOOL        result;
    NTSTATUS    Status;

    RtlInitUnicodeString(&UnicodeType, NULL);
    RtlInitUnicodeString(&UnicodeName, NULL);

    __try {
        if ((ULONG_PTR)lpType >= LDR_RESOURCE_ID_NAME_MINVAL) {
            cch = strlen(lpType);
            string.Length = (USHORT)cch;
//          string.MaximumLength = (USHORT)cch + sizeof(CHAR); /* unnecessary */
            string.Buffer = (PCHAR)lpType;
            Status = RtlAnsiStringToUnicodeString(&UnicodeType, &string, TRUE);
            if (! NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                result = FALSE;
                __leave;
            }
            lpwType = (LPCWSTR)UnicodeType.Buffer;
        } else {
            lpwType = (LPCWSTR)lpType;
        }
        if ((ULONG_PTR)lpName >= LDR_RESOURCE_ID_NAME_MINVAL) {
            cch = strlen(lpName);
            string.Length = (USHORT)cch;
//          string.MaximumLength = (USHORT)cch + sizeof(CHAR); /* unnecessary */
            string.Buffer = (PCHAR)lpName;
            Status = RtlAnsiStringToUnicodeString(&UnicodeName, &string, TRUE);
            if (! NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                result = FALSE;
                __leave;
            }
            lpwName = (LPCWSTR)UnicodeName.Buffer;
        } else {
            lpwName = (LPCWSTR)lpName;
        }

        result = UpdateResourceW(hUpdate, lpwType, lpwName, language,
                                 lpData, cb);
    } __finally {
        RtlFreeUnicodeString(&UnicodeType);
        RtlFreeUnicodeString(&UnicodeName);
    }
    
    return result;
}


BOOL
APIENTRY
EndUpdateResourceW(
                  HANDLE      hUpdate,
                  BOOL        fDiscard
                  )

/*++
    Routine Description
        Finishes the UpdateResource action.  Copies the
        input file to a temporary, adds the resources left
        in the list (hUpdate) to the exe.

    Parameters:

        hUpdateFile - The handle returned by the BeginUpdateResources
        function.

        fDiscard - If TRUE, discards all the updates, frees all memory.

    Return Value:

    FALSE - The file specified was not able to be written.  More
    information may be available via GetLastError api.

    TRUE -  The accumulated resources specified by UpdateResource calls
    were written to the executable file specified by the hUpdateFile
    handle.
--*/

{
    LPWSTR      pFileName;
    PUPDATEDATA pUpdate;
    WCHAR       pTempFileName[MAX_PATH];
    LPWSTR      p;
    LONG        rc;
    DWORD       LastError = 0;
    HRESULT     hr;

    SetLastError(0);
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (fDiscard) {
        rc = NO_ERROR;
    } else {
        if (pUpdate == NULL) {
            return FALSE;
        }
        pFileName = (LPWSTR)GlobalLock(pUpdate->hFileName);
        if (pFileName != NULL) {
            hr = StringCchCopyExW(pTempFileName,
                                  RTL_NUMBER_OF(pTempFileName),
                                  pFileName,
                                  &p,
                                  NULL,
                                  0);
            if (FAILED(hr)) {
                rc = LastError = HRESULT_CODE(hr);
            } else {
                do {
                    p--;
                } while (*p != L'\\' && p >= pTempFileName);
                *(p+1) = 0;
                rc = GetTempFileNameW(pTempFileName, L"RCX", 0, pTempFileName);
                if (rc == 0) {
                    rc = GetTempPathW(MAX_PATH, pTempFileName);
                    if (rc == 0) {
                        pTempFileName[0] = L'.';
                        pTempFileName[1] = L'\\';
                        pTempFileName[2] = 0;
                    }
                    rc = GetTempFileNameW(pTempFileName, L"RCX", 0, pTempFileName);
                    if (rc == 0) {
                        rc = GetLastError();
                    } else {
                        rc = WriteResFile(hUpdate, pTempFileName);
                        if (rc == NO_ERROR) {
                            DeleteFileW(pFileName);
                            MoveFileW(pTempFileName, pFileName);
                        } else {
                            LastError = rc;
                            DeleteFileW(pTempFileName);
                        }
                    }
                } else {
                    rc = WriteResFile(hUpdate, pTempFileName);
                    if (rc == NO_ERROR) {
                        DeleteFileW(pFileName);
                        MoveFileW(pTempFileName, pFileName);
                    } else {
                        LastError = rc;
                        DeleteFileW(pTempFileName);
                    }
                }
            }
            GlobalUnlock(pUpdate->hFileName);
        }
        GlobalFree(pUpdate->hFileName);
    }

    if (pUpdate != NULL) {
        FreeData(pUpdate);
        GlobalUnlock(hUpdate);
    }
    GlobalFree(hUpdate);

    SetLastError(LastError);
    return rc?FALSE:TRUE;
}


BOOL
APIENTRY
EndUpdateResourceA(
                  HANDLE      hUpdate,
                  BOOL        fDiscard)
/*++
    Routine Description
        Ascii version - see above for description.
--*/
{
    return EndUpdateResourceW(hUpdate, fDiscard);
}


/**********************************************************************
**
**  End of API entry points.
**
**  Beginning of private entry points for worker routines to do the
**  real work.
**
***********************************************************************/


BOOL
EnumTypesFunc(
             HANDLE hModule,
             LPWSTR lpType,
             LPARAM lParam
             )
{

    EnumResourceNamesW((HINSTANCE)hModule, lpType, (ENUMRESNAMEPROCW)EnumNamesFunc, lParam);

    return TRUE;
}



BOOL
EnumNamesFunc(
             HANDLE hModule,
             LPWSTR lpType,
             LPWSTR lpName,
             LPARAM lParam
             )
{

    EnumResourceLanguagesW((HINSTANCE)hModule, lpType, lpName, (ENUMRESLANGPROCW)EnumLangsFunc, lParam);
    return TRUE;
}



BOOL
EnumLangsFunc(
             HANDLE hModule,
             LPWSTR lpType,
             LPWSTR lpName,
             WORD language,
             LPARAM lParam
             )
{
    HANDLE      hResInfo;
    LONG        fError;
    PSDATA      Type;
    PSDATA      Name;
    ULONG       cb;
    PVOID       lpData;
    HANDLE      hResource;
    PVOID       lpResource;

    hResInfo = FindResourceExW((HINSTANCE)hModule, lpType, lpName, language);
    if (hResInfo == NULL) {
        return FALSE;
    } else {
        Type = AddStringOrID(lpType, (PUPDATEDATA)lParam);
        if (Type == NULL) {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
        Name = AddStringOrID(lpName, (PUPDATEDATA)lParam);
        if (Name == NULL) {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            FREE_RES_ID(Type);
            return FALSE;
        }

        cb = SizeofResource((HINSTANCE)hModule, (HRSRC)hResInfo);
        if (cb == 0) {
            FREE_RES_ID(Type);
            FREE_RES_ID(Name);
            return FALSE;
        }
        lpData = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
        if (lpData == NULL) {
            FREE_RES_ID(Type);
            FREE_RES_ID(Name);
            return FALSE;
        }
        RtlZeroMemory(lpData, cb);

        hResource = LoadResource((HINSTANCE)hModule, (HRSRC)hResInfo);
        if (hResource == NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, lpData);
            FREE_RES_ID(Type);
            FREE_RES_ID(Name);
            return FALSE;
        }

        lpResource = (PVOID)LockResource(hResource);
        if (lpResource == NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, lpData);
            FREE_RES_ID(Type);
            FREE_RES_ID(Name);
            return FALSE;
        }

        RtlCopyMemory(lpData, lpResource, cb);
        (VOID)UnlockResource(hResource);
        (VOID)FreeResource(hResource);

        fError = AddResource(Type, Name, language, (PUPDATEDATA)lParam, lpData, cb);
        if (fError != NO_ERROR) {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }

    return TRUE;
}


VOID
FreeOne(
       PRESNAME pRes
       )
{
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes->OffsetToDataEntry);
    FREE_RES_ID(pRes->Name);
    FREE_RES_ID(pRes->Type);
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes);
}


VOID
FreeStrings(
        PUPDATEDATA pUpd
        )
{
    PSDATA      pstring, pStringTmp;

    pstring = pUpd->StringHead;
    while (pstring != NULL) {
        pStringTmp = pstring->uu.ss.pnext;
        if (pstring->discriminant == IS_STRING)
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring->szStr);
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
        pstring = pStringTmp;
    }

    return;
}


VOID
FreeData(
        PUPDATEDATA pUpd
        )
{
    PRESTYPE    pType;
    PRESNAME    pRes;

    for (pType=pUpd->ResTypeHeadID ; pUpd->ResTypeHeadID ; pType=pUpd->ResTypeHeadID) {
        pUpd->ResTypeHeadID = pUpd->ResTypeHeadID->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        FREE_RES_ID(pType->Type);
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pType);
    }

    for (pType=pUpd->ResTypeHeadName ; pUpd->ResTypeHeadName ; pType=pUpd->ResTypeHeadName) {
        pUpd->ResTypeHeadName = pUpd->ResTypeHeadName->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        // no FREE_RES_ID needed here.
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pType);
    }

    FreeStrings(pUpd);

    return;
}


/*+++

    Routines to register strings

---*/

//
//  Resources are DWORD aligned and may be in any order.
//

#define TABLE_ALIGN  4
#define DATA_ALIGN  4L



PSDATA
AddStringOrID(
             LPCWSTR     lp,
             PUPDATEDATA pupd
             )
{
    USHORT cb;
    PSDATA pstring;
    PPSDATA ppstring;

    if ((ULONG_PTR)lp < LDR_RESOURCE_ID_NAME_MINVAL) {
        //
        // an ID
        //
        pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(SDATA));
        if (pstring == NULL)
            return NULL;
        RtlZeroMemory((PVOID)pstring, sizeof(SDATA));
        pstring->discriminant = IS_ID;

        pstring->uu.Ordinal = (WORD)((ULONG_PTR)lp & 0x0000ffff);
    } else {
        //
        // a string
        //
        cb = wcslen(lp) + 1;
        ppstring = &pupd->StringHead;

        while ((pstring = *ppstring) != NULL) {
            if (!wcsncmp(pstring->szStr, lp, cb))
                break;
            ppstring = &(pstring->uu.ss.pnext);
        }

        if (!pstring) {

            //
            // allocate a new one
            //

            pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(),
                                              MAKE_TAG( RES_TAG ) | HEAP_ZERO_MEMORY,
                                              sizeof(SDATA)
                                             );
            if (pstring == NULL)
                return NULL;
            RtlZeroMemory((PVOID)pstring, sizeof(SDATA));

            pstring->szStr = (WCHAR*)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                                                     cb*sizeof(WCHAR));
            if (pstring->szStr == NULL) {
                RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
                return NULL;
            }
            pstring->discriminant = IS_STRING;
            pstring->OffsetToString = pupd->cbStringTable;

            pstring->cbData = sizeof(pstring->cbsz) + cb * sizeof(WCHAR);
            pstring->cbsz = cb - 1;     /* don't include zero terminator */
            RtlCopyMemory(pstring->szStr, lp, cb*sizeof(WCHAR));

            pupd->cbStringTable += pstring->cbData;

            pstring->uu.ss.pnext=NULL;
            *ppstring=pstring;
        }
    }

    return(pstring);
}
//
// add a resource into the resource directory hiearchy
//


LONG
AddResource(
           IN PSDATA Type,
           IN PSDATA Name,
           IN WORD Language,
           IN PUPDATEDATA pupd,
           IN PVOID lpData,
           IN ULONG cb
           )
{
    PRESTYPE  pType;
    PPRESTYPE ppType;
    PRESNAME  pName;
    PRESNAME  pNameM;
    PPRESNAME ppName = NULL;
    BOOL fTypeID=(Type->discriminant == IS_ID);
    BOOL fNameID=(Name->discriminant == IS_ID);
    BOOL fSame=FALSE;
    int iCompare;
    //
    // figure out which list to store it in
    //

    ppType = fTypeID ? &pupd->ResTypeHeadID : &pupd->ResTypeHeadName;

    //
    // Try to find the Type in the list
    //

    while ((pType=*ppType) != NULL) {
        if (pType->Type->uu.Ordinal == Type->uu.Ordinal) {
            ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
            break;
        }
        if (fTypeID) {
            if (Type->uu.Ordinal < pType->Type->uu.Ordinal)
                break;
        } else {
            if (wcscmp(Type->szStr, pType->Type->szStr) < 0)
                break;
        }
        ppType = &(pType->pnext);
    }

    //
    // Create a new type if needed
    //

    if (ppName == NULL) {
        pType = (PRESTYPE)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESTYPE));
        if (pType == NULL) {
            FREE_RES_ID(Type);
            FREE_RES_ID(Name);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlZeroMemory((PVOID)pType, sizeof(RESTYPE));
        if (fTypeID) {
            /* fix for bug 698940.  Duplicate the ID node since the rest of this function's
             * logic either attaches the passed node to pName->Type or frees it. */
            pType->Type = (PSDATA)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                          sizeof(SDATA));
            if (pType->Type == NULL) {
                FREE_RES_ID(Type);
                FREE_RES_ID(Name);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            RtlZeroMemory((PVOID)pType->Type, sizeof(SDATA));
            pType->Type->discriminant = IS_ID;
            pType->Type->uu.Ordinal = Type->uu.Ordinal;
        } else {
            pType->Type = Type;
        }
        pType->pnext = *ppType;
        *ppType = pType;
        ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
    }

    //
    // Find proper place for name
    //

    while ( (pName = *ppName) != NULL) {
        if (fNameID) {
            if (Name->uu.Ordinal == pName->Name->uu.Ordinal) {
                fSame = TRUE;
                break;
            }
            if (Name->uu.Ordinal < pName->Name->uu.Ordinal)
                break;
        } else {
            iCompare = wcscmp(Name->szStr, pName->Name->szStr );
            if (iCompare == 0) {
                fSame = TRUE;
                break;
            } else if (iCompare < 0) {
                break;
            }
        }
        ppName = &(pName->pnext);
    }

    //
    // check for delete/modify
    //

    if (fSame) {                                /* same name, new language */
        if (pName->NumberOfLanguages == 1) {    /* one language currently ? */
            if (Language == pName->LanguageId) {        /* REPLACE || DELETE */
                pName->DataSize = cb;
                FREE_RES_ID(Type);
                FREE_RES_ID(Name);
                if (lpData == NULL) {                   /* DELETE */
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }
                RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                pName->OffsetToDataEntry = (ULONG_PTR)lpData;
                return NO_ERROR;
            } else {
                if (lpData == NULL) {                   /* no data but new? */
                    FREE_RES_ID(Type);
                    FREE_RES_ID(Name);
                    return ERROR_INVALID_PARAMETER;     /* badness */
                }
                return InsertResourceIntoLangList(pupd, Type, Name, pType, pName, Language, fNameID, cb, lpData);
            }
        } else {                                  /* many languages currently */
            pNameM = pName;                     /* save head of lang list   */
            while ( (pName = *ppName) != NULL) {/* find insertion point     */
                if (!(fNameID ? pName->Name->uu.Ordinal == (*ppName)->Name->uu.Ordinal :
                      !wcscmp(pName->Name->uu.ss.sz, (*ppName)->Name->uu.ss.sz)) ||
                    Language <= pName->LanguageId)      /* here? */
                    break;                              /* yes   */
                ppName = &(pName->pnext);       /* traverse language list */
            }

            if (pName && Language == pName->LanguageId) { /* language found? */
                FREE_RES_ID(Type);
                FREE_RES_ID(Name);
                if (lpData == NULL) {                     /* DELETE          */
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }
                pName->DataSize = cb;                   /* REPLACE */
                RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                pName->OffsetToDataEntry = (ULONG_PTR)lpData;
                return NO_ERROR;
            } else {                                      /* add new language */
                return InsertResourceIntoLangList(pupd, Type, Name, pType, pNameM, Language, fNameID, cb, lpData);
            }
        }
    } else {                                      /* unique name */
        if (lpData == NULL) {                   /* can't delete new name */
            FREE_RES_ID(Type);
            FREE_RES_ID(Name);
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // add new name/language
    //

    if (!fSame) {
        if (fNameID)
            pType->NumberOfNamesID++;
        else
            pType->NumberOfNamesName++;
    }

    pName = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pName == NULL) {
        FREE_RES_ID(Type);
        FREE_RES_ID(Name);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID)pName, sizeof(RESNAME));
    pName->pnext = *ppName;
    *ppName = pName;
    pName->Name = Name;
    pName->Type = Type;
    pName->NumberOfLanguages = 1;
    pName->LanguageId = Language;
    pName->DataSize = cb;
    pName->OffsetToDataEntry = (ULONG_PTR)lpData;

    return NO_ERROR;
}


BOOL
DeleteResourceFromList(
                      PUPDATEDATA pUpd,
                      PRESTYPE pType,
                      PRESNAME pName,
                      INT Language,
                      INT fType,
                      INT fName
                      )
{
    PPRESTYPE   ppType;
    PPRESNAME   ppName;
    PRESNAME    pNameT;

    /* find previous type node */
    ppType = fType ? &pUpd->ResTypeHeadID : &pUpd->ResTypeHeadName;
    while (*ppType != pType) {
        ppType = &((*ppType)->pnext);
    }

    /* find previous name node */
    ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    pNameT = NULL;
    while (*ppName != pName) {
        if (pNameT == NULL) {           /* find first Name in lang list */
            if (fName) {
                if ((*ppName)->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
                    pNameT = *ppName;
                }
            } else {
                if (wcscmp((*ppName)->Name->szStr, pName->Name->szStr) == 0) {
                    pNameT = *ppName;
                }
            }
        }
        ppName = &((*ppName)->pnext);
    }

    if (pNameT) {
        pNameT->NumberOfLanguages--;

        if (pNameT->NumberOfLanguages == 0) {
            if (fName)
                pType->NumberOfNamesID -= 1;
            else
                pType->NumberOfNamesName -= 1;
        }
    }
    else
    {
            if (fName)
                pType->NumberOfNamesID -= 1;
            else
                pType->NumberOfNamesName -= 1;
    }

    *ppName = pName->pnext;             /* link to next */
    FreeOne(pName);

    if (!pType->NameHeadID && !pType->NameHeadName) 
    {              /* type list completely empty? */
        *ppType = pType->pnext;                 /* link to next */
        FREE_RES_ID(pType->Type);
        RtlFreeHeap(RtlProcessHeap(), 0, pType);        /* and free */
    }

    return NO_ERROR;
}

BOOL
InsertResourceIntoLangList(
                          PUPDATEDATA pUpd,
                          PSDATA Type,
                          PSDATA Name,
                          PRESTYPE pType,
                          PRESNAME pName,
                          INT Language,
                          INT fName,
                          INT cb,
                          PVOID lpData
                          )
{
    PRESNAME    pNameM;
    PRESNAME    pNameNew;
    PPRESNAME   ppName;

    pNameNew = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pNameNew == NULL) {
        FREE_RES_ID(Type);
        FREE_RES_ID(Name);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID)pNameNew, sizeof(RESNAME));
    pNameNew->Name = Name;
    pNameNew->Type = Type;
    pNameNew->LanguageId = (WORD)Language;
    pNameNew->DataSize = cb;
    pNameNew->OffsetToDataEntry = (ULONG_PTR)lpData;

    if (Language < pName->LanguageId) {         /* have to add to the front */
        pNameNew->NumberOfLanguages = pName->NumberOfLanguages + 1;
        pName->NumberOfLanguages = 1;

        ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
        /* don't have to look for NULL at end of list !!!                    */
        while (pName != *ppName) {              /* find insertion point        */
            ppName = &((*ppName)->pnext);       /* traverse language list    */
        }
        pNameNew->pnext = *ppName;              /* insert                    */
        *ppName = pNameNew;
    } else {
        pNameM = pName;
        pName->NumberOfLanguages += 1;
        while ( (pName != NULL) &&
                (fName ? Name->uu.Ordinal == pName->Name->uu.Ordinal :
                 !wcscmp(Name->uu.ss.sz, pName->Name->uu.ss.sz))) {                        /* find insertion point        */
            if (Language <= pName->LanguageId)      /* here?                    */
                break;                                /* yes                        */
            pNameM = pName;
            pName = pName->pnext;                    /* traverse language list    */
        }
        pName = pNameM->pnext;
        pNameM->pnext = pNameNew;
        pNameNew->pnext = pName;
    }
    return NO_ERROR;
}


/*
 * Utility routines
 */


ULONG
FilePos(int fh)
{

    return _llseek(fh, 0L, SEEK_CUR);
}



ULONG
MuMoveFilePos( INT fh, ULONG pos )
{
    return _llseek( fh, pos, SEEK_SET );
}



ULONG
MuWrite( INT fh, PVOID p, ULONG n )
{
    ULONG       n1;

    if ((n1 = _lwrite(fh, (const char *)p, n)) != n) {
        return n1;
    } else
        return 0;
}



ULONG
MuRead(INT fh, UCHAR*p, ULONG n )
{
    ULONG       n1;

    if ((n1 = _lread( fh, p, n )) != n) {
        return n1;
    } else
        return 0;
}



BOOL
MuCopy( INT srcfh, INT dstfh, ULONG nbytes )
{
    ULONG       n;
    ULONG       cb=0L;
    PUCHAR      pb;

    pb = (PUCHAR)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), BUFSIZE);
    if (pb == NULL)
        return 0;
    RtlZeroMemory((PVOID)pb, BUFSIZE);

    while (nbytes) {
        if (nbytes <= BUFSIZE)
            n = nbytes;
        else
            n = BUFSIZE;
        nbytes -= n;

        if (!MuRead( srcfh, pb, n )) {
            cb += n;
            MuWrite( dstfh, pb, n );
        } else {
            RtlFreeHeap(RtlProcessHeap(), 0, pb);
            return cb;
        }
    }
    RtlFreeHeap(RtlProcessHeap(), 0, pb);
    return cb;
}



VOID
SetResdata(
          PIMAGE_RESOURCE_DATA_ENTRY  pResData,
          ULONG                       offset,
          ULONG                       size)
{
    pResData->OffsetToData = offset;
    pResData->Size = size;
    pResData->CodePage = DEFAULT_CODEPAGE;
    pResData->Reserved = 0L;
}


__inline VOID
SetRestab(
         PIMAGE_RESOURCE_DIRECTORY   pRestab,
         LONG                        time,
         WORD                        cNamed,
         WORD                        cId)
{
    pRestab->Characteristics = 0L;
    pRestab->TimeDateStamp = time;
    pRestab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pRestab->MinorVersion = MINOR_RESOURCE_VERSION;
    pRestab->NumberOfNamedEntries = cNamed;
    pRestab->NumberOfIdEntries = cId;
}


PIMAGE_SECTION_HEADER
FindSection(
           PIMAGE_SECTION_HEADER       pObjBottom,
           PIMAGE_SECTION_HEADER       pObjTop,
           LPSTR pName
           )
{
    while (pObjBottom < pObjTop) {
        if (strcmp((const char *)&pObjBottom->Name[0], pName) == 0)
            return pObjBottom;
        pObjBottom++;
    }

    return NULL;
}


ULONG
AssignResourceToSection(
                       PRESNAME    *ppRes,         /* resource to assign */
                       ULONG       ExtraSectionOffset,     /* offset between .rsrc and .rsrc1 */
                       ULONG       Offset,         /* next available offset in section */
                       LONG        Size,           /* Maximum size of .rsrc */
                       PLONG       pSizeRsrc1
                       )
{
    ULONG       cb;

    /* Assign this res to this section */
    cb = ROUNDUP((*ppRes)->DataSize, CBLONG);
    if (Offset < ExtraSectionOffset && Offset + cb > (ULONG)Size) {
        *pSizeRsrc1 = Offset;
        Offset = ExtraSectionOffset;
        DPrintf((DebugBuf, "<<< Secondary resource section @%#08lx >>>\n", Offset));
    }
    (*ppRes)->OffsetToData = Offset;
    *ppRes = (*ppRes)->pnext;
    DPrintf((DebugBuf, "    --> %#08lx bytes at %#08lx\n", cb, Offset));
    return Offset + cb;
}

//
// Adjust debug directory table.
//
// The following code instantiates the PatchDebug function template twice.
// Once to generate code for 32-bit image headers and once to generate
// code for 64-bit image headers.
//

template
LONG
PatchDebug<IMAGE_NT_HEADERS32>(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER pDebugOld,
    PIMAGE_SECTION_HEADER pDebugNew,
    PIMAGE_SECTION_HEADER pDebugDirOld,
    PIMAGE_SECTION_HEADER pDebugDirNew,
    IMAGE_NT_HEADERS32 *pOld,
    IMAGE_NT_HEADERS32 *pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData
    );

template
LONG
PatchDebug<IMAGE_NT_HEADERS64>(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER pDebugOld,
    PIMAGE_SECTION_HEADER pDebugNew,
    PIMAGE_SECTION_HEADER pDebugDirOld,
    PIMAGE_SECTION_HEADER pDebugDirNew,
    IMAGE_NT_HEADERS64 *pOld,
    IMAGE_NT_HEADERS64 *pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData
    );

//
// Patch various RVAs in the specified file to compensate for extra
// section table entries.
//
// The following code instantiates the PatchRVAs function template twice.
// Once to generate code for 32-bit image headers and once to generate
// code for 64-bit image headers.
//

template
LONG
PatchRVAs<IMAGE_NT_HEADERS32>(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    IMAGE_NT_HEADERS32 *pNew,
    ULONG OldSize
    );

template
LONG
PatchRVAs<IMAGE_NT_HEADERS64>(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    IMAGE_NT_HEADERS64 *pNew,
    ULONG OldSize
    );

/***************************** Main Worker Function ***************************
* LONG PEWriteResFile
*
* This function writes the resources to the named executable file.
* It assumes that resources have no fixups (even any existing resources
* that it removes from the executable.)  It places all the resources into
* one or two sections. The resources are packed tightly into the section,
* being aligned on dword boundaries.  Each section is padded to a file
* sector size (no invalid or zero-filled pages), and each
* resource is padded to the afore-mentioned dword boundary.  This
* function uses the capabilities of the NT system to enable it to easily
* manipulate the data:  to wit, it assumes that the system can allocate
* any sized piece of data, in particular the section and resource tables.
* If it did not, it might have to deal with temporary files (the system
* may have to grow the swap file, but that's what the system is for.)
*
* Return values are:
*     TRUE  - file was written succesfully.
*     FALSE - file was not written succesfully.
*
* Effects:
*
* History:
* Thur Apr 27, 1989        by     Floyd Rogers      [floydr]
*   Created.
* 12/8/89   sanfords    Added multiple section support.
* 12/11/90  floydr      Modified for new (NT) Linear Exe format
* 1/18/92   vich        Modified for new (NT) Portable Exe format
* 5/8/92    bryant    General cleanup so resonexe can work with unicode
* 6/9/92    floydr    incorporate bryan's changes
* 6/15/92   floydr    debug section separate from debug table
* 9/25/92   floydr    account for .rsrc not being last-1
* 9/28/92   floydr    account for adding lots of resources by adding
*                     a second .rsrc section.
\****************************************************************************/

//
// The following code instantiates the PEWriteResource function template
// twice. Once to generate code for 32-bit image headers and once to
// generate code for 64-bit image headers.
//

template
LONG
PEWriteResource<IMAGE_NT_HEADERS32> (
    INT inpfh,
    INT outfh,
    ULONG cbOldexe,
    PUPDATEDATA pUpdate,
    IMAGE_NT_HEADERS32 *NtHeader
    );

template
LONG
PEWriteResource<IMAGE_NT_HEADERS64> (
    INT inpfh,
    INT outfh,
    ULONG cbOldexe,
    PUPDATEDATA pUpdate,
    IMAGE_NT_HEADERS64 *NtHeader
    );

LONG
PEWriteResFile(
    INT inpfh,
    INT outfh,
    ULONG cbOldexe,
    PUPDATEDATA pUpdate
    )

{

    IMAGE_NT_HEADERS32 Old;

    //
    // Position file to start of NT header and read the image header.
    //

    MuMoveFilePos(inpfh, cbOldexe);
    MuRead(inpfh, (PUCHAR)&Old, sizeof(IMAGE_NT_HEADERS32));

    //
    // If the file is not an NT image, then return an error.
    //

    if (Old.Signature != IMAGE_NT_SIGNATURE) {
        return ERROR_INVALID_EXE_SIGNATURE;
    }

    //
    // If the file is not an executable or a dll, then return an error.
    //

    if ((Old.FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0 &&
        (Old.FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {
        return ERROR_EXE_MARKED_INVALID;
    }

    //
    // Call the proper function dependent on the machine type.
    //

    if (Old.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return PEWriteResource(inpfh, outfh, cbOldexe, pUpdate, (IMAGE_NT_HEADERS64 *)&Old);
    } else if (Old.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return PEWriteResource(inpfh, outfh, cbOldexe, pUpdate, (IMAGE_NT_HEADERS32 *)&Old);
    } else {
        return ERROR_BAD_EXE_FORMAT;
    }
}

/***************************************************************************
 * WriteResSection
 *
 * This routine writes out the resources asked for into the current section.
 * It pads resources to dword (4-byte) boundaries.
 **************************************************************************/

PRESNAME
WriteResSection(
               PUPDATEDATA pUpdate,
               INT outfh,
               ULONG align,
               ULONG cbLeft,
               PRESNAME    pResSave
               )
{
    ULONG   cbB=0;            /* bytes in current section    */
    ULONG   cbT;            /* bytes in current section    */
    ULONG   size;
    PRESNAME    pRes;
    PRESTYPE    pType;
    BOOL        fName;
    PVOID       lpData;

    /* Output contents associated with each resource */
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
        pRes = pType->NameHeadName;
        fName = TRUE;
        loop1:
        for ( ; pRes ; pRes = pRes->pnext) {
            if (pResSave != NULL && pRes != pResSave)
                continue;
            pResSave = NULL;
#if DBG
            if (pType->Type->discriminant == IS_STRING) {
                DPrintf((DebugBuf, "    "));
                DPrintfu((pType->Type->szStr));
                DPrintfn((DebugBuf, "."));
            } else {
                DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
            }
            if (pRes->Name->discriminant == IS_STRING) {
                DPrintfu((pRes->Name->szStr));
            } else {
                DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
            }
#endif
            lpData = (PVOID)pRes->OffsetToDataEntry;
            DPrintfn((DebugBuf, "\n"));

            /* if there is room in the current section, write it there */
            size = pRes->DataSize;
            if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
                DPrintf((DebugBuf, "Writing resource: %#04lx bytes @%#08lx\n", size, FilePos(outfh)));
                MuWrite(outfh, lpData, size);
                /* pad resource     */
                cbT = REMAINDER(size, CBLONG);
#if DBG
                if (cbT != 0) {
                    DPrintf((DebugBuf, "Writing small pad: %#04lx bytes @%#08lx\n", cbT, FilePos(outfh)));
                }
#endif
                MuWrite(outfh, pchPad, cbT);    /* dword    */
                cbB += size + cbT;
                cbLeft -= size + cbT;       /* less left    */
                continue;       /* next resource    */
            } else {          /* will fill up section    */
                DPrintf((DebugBuf, "Done with .rsrc section\n"));
                goto write_pad;
            }
        }
        if (fName) {
            fName = FALSE;
            pRes = pType->NameHeadID;
            goto loop1;
        }
        pType = pType->pnext;
    }

    pType = pUpdate->ResTypeHeadID;
    while (pType) {
        pRes = pType->NameHeadName;
        fName = TRUE;
        loop2:
        for ( ; pRes ; pRes = pRes->pnext) {
            if (pResSave != NULL && pRes != pResSave)
                continue;
            pResSave = NULL;
#if DBG
            if (pType->Type->discriminant == IS_STRING) {
                DPrintf((DebugBuf, "    "));
                DPrintfu((pType->Type->szStr));
                DPrintfn((DebugBuf, "."));
            } else {
                DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
            }
            if (pRes->Name->discriminant == IS_STRING) {
                DPrintfu((pRes->Name->szStr));
            } else {
                DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
            }
#endif
            lpData = (PVOID)pRes->OffsetToDataEntry;
            DPrintfn((DebugBuf, "\n"));

            /* if there is room in the current section, write it there */
            size = pRes->DataSize;
            if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
                DPrintf((DebugBuf, "Writing resource: %#04lx bytes @%#08lx\n", size, FilePos(outfh)));
                MuWrite(outfh, lpData, size);
                /* pad resource     */
                cbT = REMAINDER(size, CBLONG);
#if DBG
                if (cbT != 0) {
                    DPrintf((DebugBuf, "Writing small pad: %#04lx bytes @%#08lx\n", cbT, FilePos(outfh)));
                }
#endif
                MuWrite(outfh, pchPad, cbT);    /* dword    */
                cbB += size + cbT;
                cbLeft -= size + cbT;       /* less left    */
                continue;       /* next resource    */
            } else {          /* will fill up section    */
                DPrintf((DebugBuf, "Done with .rsrc section\n"));
                goto write_pad;
            }
        }
        if (fName) {
            fName = FALSE;
            pRes = pType->NameHeadID;
            goto loop2;
        }
        pType = pType->pnext;
    }
    pRes = NULL;

    write_pad:
    /* pad to alignment boundary */
    cbB = FilePos(outfh);
    cbT = ROUNDUP(cbB, align);
    cbLeft = cbT - cbB;
    DPrintf((DebugBuf, "Writing file sector pad: %#04lx bytes @%#08lx\n", cbLeft, FilePos(outfh)));
    if (cbLeft != 0) {
        while (cbLeft >= cbPadMax) {
            MuWrite(outfh, pchPad, cbPadMax);
            cbLeft -= cbPadMax;
        }
        MuWrite(outfh, pchPad, cbLeft);
    }
    return pRes;
}



#if DBG

void
wchprintf(WCHAR*wch)
{
    UNICODE_STRING ustring;
    STRING      string;
    char        buf[257];
    ustring.MaximumLength = ustring.Length = wcslen(wch) * sizeof(WCHAR);
    ustring.Buffer = wch;

    string.Length = 0;
    string.MaximumLength = 256;
    string.Buffer = buf;

    RtlUnicodeStringToAnsiString(&string, &ustring, FALSE);
    buf[string.Length] = '\000';
    DPrintfn((DebugBuf, "%s", buf));
}
#endif


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteResFile() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/


LONG
WriteResFile(
            HANDLE      hUpdate,
            WCHAR       *pDstname)
{
    INT         inpfh;
    INT         outfh;
    ULONG       onewexe;
    IMAGE_DOS_HEADER    oldexe;
    PUPDATEDATA pUpdate;
    INT         rc;
    WCHAR       *pFilename;

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        return GetLastError();
    }
    pFilename = (WCHAR*)GlobalLock(pUpdate->hFileName);
    if (pFilename == NULL) {
        GlobalUnlock(hUpdate);
        return GetLastError();
    }

    /* open the original exe file */
    inpfh = HandleToUlong(CreateFileW(pFilename, GENERIC_READ,
                             0 /*exclusive access*/, NULL /* security attr */,
                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    GlobalUnlock(pUpdate->hFileName);
    if (inpfh == -1) {
        GlobalUnlock(hUpdate);
        return ERROR_OPEN_FAILED;
    }

    /* read the old format EXE header */
    rc = _lread(inpfh, (char*)&oldexe, sizeof(oldexe));
    if (rc != sizeof(oldexe)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_READ_FAULT;
    }

    /* make sure its really an EXE file */
    if (oldexe.e_magic != IMAGE_DOS_SIGNATURE) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_INVALID_EXE_SIGNATURE;
    }

    /* make sure theres a new EXE header floating around somewhere */
    if (!(onewexe = oldexe.e_lfanew)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_BAD_EXE_FORMAT;
    }

    outfh = HandleToUlong(CreateFileW(pDstname, GENERIC_READ|GENERIC_WRITE,
                             0 /*exclusive access*/, NULL /* security attr */,
                             CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL));

    if (outfh != -1) {
        rc = PEWriteResFile(inpfh, outfh, onewexe, pUpdate);
        _lclose(outfh);
    }
    _lclose(inpfh);
    GlobalUnlock(hUpdate);
    return rc;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\ustubs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ustubs.c

Abstract:

    Unicode stubs

Author:

    Mark Lucovsky (markl) 18-Apr-1991

Revision History:

--*/

#include "basedll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\updrsrc.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    updres.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define DPrintf(a)
#define DPrintfn(a)
#define DPrintfu(a)

#define cbPadMax    16L

#define	DEFAULT_CODEPAGE	1252
#define	MAJOR_RESOURCE_VERSION	4
#define	MINOR_RESOURCE_VERSION	0

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

#define	SEEK_SET	0
#define	SEEK_CUR	1
#define	SEEK_END	2
#define	MAXSTR		(256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef	WCHAR	*PWCHAR;

typedef struct MY_STRING {
	ULONG discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct MY_STRING *pnext;
		  ULONG  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  *sz;
		} ss;
		WORD     Ordinal;
	} uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz

typedef struct _RESNAME {
        struct _RESNAME *pnext;	// The first three fields should be the
        PSDATA Name;		// same in both res structures
        ULONG   OffsetToData;

        PSDATA	Type;
	ULONG	SectionNumber;
        ULONG	DataSize;
        ULONG_PTR   OffsetToDataEntry;
        USHORT  ResourceNumber;
        USHORT  NumberOfLanguages;
        WORD	LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
        struct _RESTYPE *pnext;	// The first three fields should be the
        PSDATA Type;		// same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;

typedef struct _UPDATEDATA {
        ULONG	cbStringTable;
        PSDATA	StringHead;
        PRESNAME	ResHead;
        PRESTYPE	ResTypeHeadID;
        PRESTYPE	ResTypeHeadName;
        LONG	Status;
        HANDLE	hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG		(sizeof(LONG))
#define BUFSIZE		(4L * 1024L)

/* functions for adding/deleting resources to update list */

LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG  cb
    );

PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    );

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fName,
    INT cb,
    PVOID lpData
    );

BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fType,
    INT	fName
    );

/* Prototypes for Enumeration done in BeginUpdateResource */

BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPWSTR lpType,
    LPARAM lParam
    );

BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPWSTR lpName,
    LPWSTR lpType,
    LPARAM lParam
    );

BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPWSTR lpType,
    LPWSTR lpName,
    WORD languages,
    LPARAM lParam
    );

/* Prototypes for genral worker functions in updres.c */

LONG
WriteResFile(
    IN HANDLE	hUpdate,
    IN WCHAR	*pDstname
    );

VOID
FreeStrings(
    PUPDATEDATA pUpd
    );

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME pResSave
    );

//
// Template for patch debug information function.
//

template<class NT_HEADER_TYPE>
LONG
PatchDebug(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER pDebugOld,
    PIMAGE_SECTION_HEADER pDebugNew,
    PIMAGE_SECTION_HEADER pDebugDirOld,
    PIMAGE_SECTION_HEADER pDebugDirNew,
    NT_HEADER_TYPE *pOld,
    NT_HEADER_TYPE *pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData
    )

{

    PIMAGE_DEBUG_DIRECTORY pDbgLast;
    PIMAGE_DEBUG_DIRECTORY pDbgSave;
    PIMAGE_DEBUG_DIRECTORY pDbg;
    ULONG       ib;
    ULONG       adjust;
    ULONG       ibNew;

    if (pDebugDirOld == NULL || pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size==0)
        return NO_ERROR;

    pDbgSave = pDbg = (PIMAGE_DEBUG_DIRECTORY)RtlAllocateHeap(
                                                             RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                                                             pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    if (pDbg == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    if (pDebugOld) {
        DPrintf((DebugBuf, "Patching dbg directory: @%#08lx ==> @%#08lx\n",
                 pDebugOld->PointerToRawData, pDebugNew->PointerToRawData));
    } else
        adjust = *pPointerToRawData;    /* passed in EOF of new file */

    ib = pOld->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress - pDebugDirOld->VirtualAddress;
    MuMoveFilePos(inpfh, pDebugDirOld->PointerToRawData+ib);
    pDbgLast = pDbg + (pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)/sizeof(IMAGE_DEBUG_DIRECTORY);
    MuRead(inpfh, (PUCHAR)pDbg, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

    if (pDebugOld == NULL) {
        /* find 1st entry - use for offset */
        DPrintf((DebugBuf, "Adjust: %#08lx\n",adjust));
        for (ibNew=0xffffffff ; pDbg<pDbgLast ; pDbg++)
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld &&
                pDbg->PointerToRawData < ibNew
               )
                ibNew = pDbg->PointerToRawData;

        if (ibNew != 0xffffffff)
            *pPointerToRawData = ibNew;
        else
            *pPointerToRawData = _llseek(inpfh, 0L, SEEK_END);
        for (pDbg=pDbgSave ; pDbg<pDbgLast ; pDbg++) {
            DPrintf((DebugBuf, "Old debug file offset: %#08lx\n",
                     pDbg->PointerToRawData));
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld)
                pDbg->PointerToRawData += adjust - ibNew;
            DPrintf((DebugBuf, "New debug file offset: %#08lx\n",
                     pDbg->PointerToRawData));
        }
    } else {
        for ( ; pDbg<pDbgLast ; pDbg++) {
            DPrintf((DebugBuf, "Old debug addr: %#08lx, file offset: %#08lx\n",
                     pDbg->AddressOfRawData,
                     pDbg->PointerToRawData));
            pDbg->AddressOfRawData += pDebugNew->VirtualAddress -
                                      pDebugOld->VirtualAddress;
            pDbg->PointerToRawData += pDebugNew->PointerToRawData -
                                      pDebugOld->PointerToRawData;
            DPrintf((DebugBuf, "New debug addr: %#08lx, file offset: %#08lx\n",
                     pDbg->AddressOfRawData,
                     pDbg->PointerToRawData));
        }
    }

    MuMoveFilePos(outfh, pDebugDirNew->PointerToRawData+ib);
    MuWrite(outfh, (PUCHAR)pDbgSave, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    RtlFreeHeap(RtlProcessHeap(), 0, pDbgSave);

    return NO_ERROR;
}

//
// Template for patch debug information function.
//

template<class NT_HEADER_TYPE>
LONG
PatchRVAs(
    int inpfh,
    int outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    NT_HEADER_TYPE *pNew,
    ULONG OldSize
    )

{
    ULONG hdrdelta;
    ULONG offset, rvaiat, offiat, iat;
    IMAGE_EXPORT_DIRECTORY Exp;
    IMAGE_IMPORT_DESCRIPTOR Imp;
    ULONG i, cmod, cimp;

    hdrdelta = pNew->OptionalHeader.SizeOfHeaders - OldSize;
    if (hdrdelta == 0) {
        return NO_ERROR;
    }

    //
    // Patch export section RVAs
    //

    DPrintf((DebugBuf, "Export offset=%08lx, hdrsize=%08lx\n",
             pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
             pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0) {
        DPrintf((DebugBuf, "No exports to patch\n"));
    } else if (offset >= pNew->OptionalHeader.SizeOfHeaders) {
        DPrintf((DebugBuf, "No exports in header to patch\n"));
    } else {
        MuMoveFilePos(inpfh, offset - hdrdelta);
        MuRead(inpfh, (PUCHAR) &Exp, sizeof(Exp));
        Exp.Name += hdrdelta;
        (ULONG)Exp.AddressOfFunctions += hdrdelta;
        (ULONG)Exp.AddressOfNames += hdrdelta;
        (ULONG)Exp.AddressOfNameOrdinals += hdrdelta;
        MuMoveFilePos(outfh, offset);
        MuWrite(outfh, (PUCHAR) &Exp, sizeof(Exp));
    }

    //
    // Patch import section RVAs
    //

    DPrintf((DebugBuf, "Import offset=%08lx, hdrsize=%08lx\n",
             pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
             pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) == 0) {
        DPrintf((DebugBuf, "No imports to patch\n"));
    } else if (offset >= pNew->OptionalHeader.SizeOfHeaders) {
        DPrintf((DebugBuf, "No imports in header to patch\n"));
    } else {
        for (cimp = cmod = 0; ; cmod++) {
            MuMoveFilePos(inpfh, offset + cmod * sizeof(Imp) - hdrdelta);
            MuRead(inpfh, (PUCHAR) &Imp, sizeof(Imp));
            if (Imp.FirstThunk == 0) {
                break;
            }
            Imp.Name += hdrdelta;
            MuMoveFilePos(outfh, offset + cmod * sizeof(Imp));
            MuWrite(outfh, (PUCHAR) &Imp, sizeof(Imp));

            rvaiat = (ULONG)Imp.FirstThunk;
            DPrintf((DebugBuf, "RVAIAT = %#08lx\n", (ULONG)rvaiat));
            for (i = 0; i < pNew->FileHeader.NumberOfSections; i++) {
                if (rvaiat >= po32[i].VirtualAddress &&
                    rvaiat < po32[i].VirtualAddress + po32[i].SizeOfRawData) {

                    offiat = rvaiat - po32[i].VirtualAddress + po32[i].PointerToRawData;
                    goto found;
                }
            }
            DPrintf((DebugBuf, "IAT not found\n"));
            return ERROR_INVALID_DATA;
            found:
            DPrintf((DebugBuf, "IAT offset: @%#08lx ==> @%#08lx\n",
                     offiat - pagedelta,
                     offiat));
            MuMoveFilePos(inpfh, offiat - pagedelta);
            MuMoveFilePos(outfh, offiat);
            for (;;) {
                MuRead(inpfh, (PUCHAR) &iat, sizeof(iat));
                if (iat == 0) {
                    break;
                }
                if ((iat & IMAGE_ORDINAL_FLAG) == 0) {  // if import by name
                    DPrintf((DebugBuf, "Patching IAT: %08lx + %04lx ==> %08lx\n",
                             iat,
                             hdrdelta,
                             iat + hdrdelta));
                    iat += hdrdelta;
                    cimp++;
                }
                MuWrite(outfh, (PUCHAR) &iat, sizeof(iat)); // Avoids seeking
            }
        }
        DPrintf((DebugBuf, "%u import module name RVAs patched\n", cmod));
        DPrintf((DebugBuf, "%u IAT name RVAs patched\n", cimp));
        if (cmod == 0) {
            DPrintf((DebugBuf, "No import modules to patch\n"));
        }
        if (cimp == 0) {
            DPrintf((DebugBuf, "No import name RVAs to patch\n"));
        }
    }

    return NO_ERROR;
}

//
// Template for write resource function.
//

template<class NT_HEADER_TYPE>
LONG
PEWriteResource(
    INT inpfh,
    INT outfh,
    ULONG cbOldexe,
    PUPDATEDATA pUpdate,
    NT_HEADER_TYPE *NtHeader
    )

{

    NT_HEADER_TYPE Old;         /* original header */
    NT_HEADER_TYPE New;         /* working header */
    PRESNAME    pRes;
    PRESNAME    pResSave;
    PRESTYPE    pType;
    ULONG       clock = 0;
    ULONG       cbName=0;       /* count of bytes in name strings */
    ULONG       cbType=0;       /* count of bytes in type strings */
    ULONG       cTypeStr=0;     /* count of strings */
    ULONG       cNameStr=0;     /* count of strings */
    LONG        cb;             /* temp byte count and file index */
    ULONG       cTypes = 0L;    /* count of resource types      */
    ULONG       cNames = 0L;    /* Count of names for multiple languages/name */
    ULONG       cRes = 0L;      /* count of resources      */
    ULONG       cbRestab;       /* count of resources      */
    LONG        cbNew = 0L;     /* general count */
    ULONG       ibObjTab;
    ULONG       ibObjTabEnd;
    ULONG       ibNewObjTabEnd;
    ULONG       ibSave;
    ULONG       adjust=0;
    LONG        VaAdjust=0;
    PIMAGE_SECTION_HEADER pObjtblOld,
    pObjtblNew = NULL,
    pObjDebug,
    pObjResourceOld,
    pObjResourceNew,
    pObjResourceOldX,
    pObjDebugDirOld,
    pObjDebugDirNew,
    pObjNew,
    pObjOld,
    pObjLast;
    PUCHAR      p;
    PIMAGE_RESOURCE_DIRECTORY   pResTab;
    PIMAGE_RESOURCE_DIRECTORY   pResTabN;
    PIMAGE_RESOURCE_DIRECTORY   pResTabL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirN;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirT;
    PIMAGE_RESOURCE_DATA_ENTRY  pResData;
    PUSHORT     pResStr;
    PUSHORT     pResStrEnd;
    PSDATA      pPreviousName;
    LONG        nObjResource=-1;
    LONG        nObjResourceX=-1;
    ULONG       cbResource;
    ULONG       ibMaxDbgOffsetOld;

    MuMoveFilePos(inpfh, cbOldexe);
    MuRead(inpfh, (PUCHAR)&Old, sizeof(NT_HEADER_TYPE));
    ibObjTab = cbOldexe + sizeof(NT_HEADER_TYPE);

    ibObjTabEnd = ibObjTab + Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    ibNewObjTabEnd = ibObjTabEnd;

    DPrintfn((DebugBuf, "\n"));

    /* New header is like old one.                  */
    RtlCopyMemory(&New, &Old, sizeof(NT_HEADER_TYPE));

    /* Read section table */
    pObjtblOld = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                                                        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    if (pObjtblOld == NULL) {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }

    RtlZeroMemory((PVOID)pObjtblOld, Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER));
    DPrintf((DebugBuf, "Old section table: %#08lx bytes at %#08lx(mem)\n",
             Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
             pObjtblOld));
    MuMoveFilePos(inpfh, ibObjTab);
    MuRead(inpfh, (PUCHAR)pObjtblOld,
           Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    pObjLast = pObjtblOld + Old.FileHeader.NumberOfSections;
    ibMaxDbgOffsetOld = 0;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
        if (pObjOld->PointerToRawData > ibMaxDbgOffsetOld) {
            ibMaxDbgOffsetOld = pObjOld->PointerToRawData + pObjOld->SizeOfRawData;
        }
    }
    DPrintf((DebugBuf, "Maximum debug offset in old file: %08x\n", ibMaxDbgOffsetOld ));

    /*
     * First, count up the resources.  We need this information
     * to discover how much room for header information to allocate
     * in the resource section.  cRes tells us how
     * many language directory entries/tables.  cNames and cTypes
     * is used for the respective tables and/or entries.  cbName totals
     * the bytes required to store the alpha names (including the leading
     * length word).  cNameStr counts these strings.
     */
    DPrintf((DebugBuf, "Beginning loop to count resources\n"));

    /* first, count those in the named type list */
    cbResource = 0;
    //DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
            //DPrintf((DebugBuf, "Resource type "));
            //DPrintfu((pType->Type->szStr));
            //DPrintfn((DebugBuf, "\n"));
            cTypes++;
            cTypeStr++;
            cbType += (pType->Type->cbsz + 1) * sizeof(WORD);

            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
            pRes = pType->NameHeadName;
            while (pRes) {
                //DPrintf((DebugBuf, "Resource "));
                //DPrintfu((pRes->Name->szStr));
                //DPrintfn((DebugBuf, "\n"));
                cRes++;
                if (pPreviousName == NULL || wcscmp(pPreviousName->szStr, pRes->Name->szStr) != 0) {
                    cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
                    cNameStr++;
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
            pRes = pType->NameHeadID;
            while (pRes) {
                //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
                cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }
        }
        pType = pType->pnext;
    }

    /* second, count those in the ID type list */
    //DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
            //DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
            cTypes++;
            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
            pRes = pType->NameHeadName;
            while (pRes) {
                //DPrintf((DebugBuf, "Resource "));
                //DPrintfu((pRes->Name->szStr));
                //DPrintfn((DebugBuf, "\n"));
                cRes++;
                if (pPreviousName == NULL || wcscmp(pPreviousName->szStr, pRes->Name->szStr) != 0) {
                    cNames++;
                    cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
                    cNameStr++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
            pRes = pType->NameHeadID;
            while (pRes) {
                //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
                cRes++;
                if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }
        }
        pType = pType->pnext;
    }
    cb = REMAINDER(cbName + cbType, CBLONG);

    /* Add up the number of bytes needed to store the directory.  There is
     * one type table with cTypes entries.  They point to cTypes name tables
     * that have a total of cNames entries.  Each of them points to a language
     * table and there are a total of cRes entries in all the language tables.
     * Finally, we have the space needed for the Directory string entries,
     * some extra padding to attain the desired alignment, and the space for
     * cRes data entry headers.
     */
    cbRestab =   sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* root dir (types) */
                 cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
                 cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* subdir2 (names) */
                 cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
                 cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* subdir3 (langs) */
                 cRes   * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
                 (cbName + cbType) +                             /* name/type strings */
                 cb +                                            /* padding */
                 cRes   * sizeof(IMAGE_RESOURCE_DATA_ENTRY);     /* data entries */

    cbResource += cbRestab;             /* add in the resource table */

    // Find any current resource sections

    pObjResourceOld = FindSection(pObjtblOld, pObjLast, ".rsrc");
    pObjResourceOldX = FindSection(pObjtblOld, pObjLast, ".rsrc1");
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if ((pObjResourceOld == NULL)) {
        cb = 0x7fffffff;                /* can fill forever */
    } else if (pObjResourceOld + 1 == pObjResourceOldX) {
        nObjResource = (ULONG)(pObjResourceOld - pObjtblOld);
        DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
        DPrintf((DebugBuf,"Merging old Resource extra section #%lu\n", nObjResource+2));
        cb = 0x7fffffff;                /* merge resource sections */
    } else if ((pObjResourceOld + 1) >= pObjLast) {
        nObjResource = (ULONG)(pObjResourceOld - pObjtblOld);
        cb = 0x7fffffff;        /* can fill forever (.rsrc is the last entry) */
    } else {
        nObjResource = (ULONG)(pObjResourceOld - pObjtblOld);
        DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
        if (pObjOld) {
            cb = (pObjResourceOld+1)->VirtualAddress - pObjResourceOld->VirtualAddress;
        } else {
            cb = 0x7fffffff;
        }
        if (cbRestab > (ULONG)cb) {
            DPrintf((DebugBuf, "Resource Table Too Large\n"));
            return ERROR_INVALID_DATA;
        }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */

    if (pObjResourceOld != NULL && cbResource > (ULONG)cb) {
        if (pObjOld == pObjResourceOld + 1) {
            DPrintf((DebugBuf, "Large resource section  pushes .reloc\n"));
            cb = 0x7fffffff;            /* can fill forever */
        } else if (pObjResourceOldX == NULL) {
            DPrintf((DebugBuf, "Too much resource data for old .rsrc section\n"));
            nObjResourceX = (ULONG)(pObjOld - pObjtblOld);
            adjust = pObjOld->VirtualAddress - pObjResourceOld->VirtualAddress;
        } else {          /* have already merged .rsrc & .rsrc1, if possible */
            DPrintf((DebugBuf, ".rsrc1 section not empty\n"));
            nObjResourceX = (ULONG)(pObjResourceOldX - pObjtblOld);
            adjust = pObjResourceOldX->VirtualAddress - pObjResourceOld ->VirtualAddress;
        }
    }

    /*
     * Walk the type lists and figure out where the Data entry header will
     * go.  Keep a running total of the size for each data element so we
     * can store this in the section header.
     */
    DPrintf((DebugBuf, "Beginning loop to assign resources to addresses\n"));

    /* first, those in the named type list */

    cbResource = cbRestab;      /* assign resource table to 1st rsrc section */
                                /* adjust == offset to .rsrc1 */
                                /* cb == size availble in .rsrc */
    cbNew = 0;                  /* count of bytes in second .rsrc */
    DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
            DPrintf((DebugBuf, "Resource type "));
            DPrintfu((pType->Type->szStr));
            DPrintfn((DebugBuf, "\n"));
            pRes = pType->NameHeadName;
            while (pRes) {
                DPrintf((DebugBuf, "Resource "));
                DPrintfu((pRes->Name->szStr));
                DPrintfn((DebugBuf, "\n"));
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
            pRes = pType->NameHeadID;
            while (pRes) {
                DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
        }
        pType = pType->pnext;
    }

    /* then, count those in the ID type list */

    DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
            DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
            pRes = pType->NameHeadName;
            while (pRes) {
                DPrintf((DebugBuf, "Resource "));
                DPrintfu((pRes->Name->szStr));
                DPrintfn((DebugBuf, "\n"));
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
            pRes = pType->NameHeadID;
            while (pRes) {
                DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
        }
        pType = pType->pnext;
    }
    /*
     * At this point:
     * cbResource has offset of first byte past the last resource.
     * cbNew has the count of bytes in the first resource section,
     * if there are two sections.
     */
    if (cbNew == 0)
        cbNew = cbResource;

    /*
     * Discover where the Debug info is (if any)?
     */
    pObjDebug = FindSection(pObjtblOld, pObjLast, ".debug");
    if (pObjDebug != NULL) {
        if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress  == 0) {
            DPrintf((DebugBuf, ".debug section but no debug directory\n"));
            return ERROR_INVALID_DATA;
        }
        if (pObjDebug != pObjLast-1) {
            DPrintf((DebugBuf, "debug section not last section in file\n"));
            return ERROR_INVALID_DATA;
        }
        DPrintf((DebugBuf, "Debug section: %#08lx bytes @%#08lx\n",
                 pObjDebug->SizeOfRawData,
                 pObjDebug->PointerToRawData));
    }
    pObjDebugDirOld = NULL;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
        if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress >= pObjOld->VirtualAddress &&
            Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress < pObjOld->VirtualAddress+pObjOld->SizeOfRawData) {
            pObjDebugDirOld = pObjOld;
            break;
        }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (nObjResource == -1) {           /* no old resource section */
        if (pObjOld != NULL)
            nObjResource = (ULONG)(pObjOld - pObjtblOld);
        else if (pObjDebug != NULL)
            nObjResource = (ULONG)(pObjDebug - pObjtblOld);
        else
            nObjResource = New.FileHeader.NumberOfSections;
        New.FileHeader.NumberOfSections++;
    }

    DPrintf((DebugBuf, "Resources assigned to section #%lu\n", nObjResource+1));
    if (nObjResourceX != -1) {
        if (pObjResourceOldX != NULL) {
            nObjResourceX = (ULONG)(pObjResourceOldX - pObjtblOld);
            New.FileHeader.NumberOfSections--;
        } else if (pObjOld != NULL)
            nObjResourceX = (ULONG)(pObjOld - pObjtblOld);
        else if (pObjDebug != NULL)
            nObjResourceX = (ULONG)(pObjDebug - pObjtblOld);
        else
            nObjResourceX = New.FileHeader.NumberOfSections;
        New.FileHeader.NumberOfSections++;
        DPrintf((DebugBuf, "Extra resources assigned to section #%lu\n", nObjResourceX+1));
    } else if (pObjResourceOldX != NULL) {        /* Was old .rsrc1 section? */
        DPrintf((DebugBuf, "Extra resource section deleted\n"));
        New.FileHeader.NumberOfSections--;      /* yes, delete it */
    }

    /*
     * If we had to add anything to the header (section table),
     * then we have to update the header size and rva's in the header.
     */
    adjust = (New.FileHeader.NumberOfSections - Old.FileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER);
    cb = Old.OptionalHeader.SizeOfHeaders -
         (Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER) +
          sizeof(NT_HEADER_TYPE) + cbOldexe );
    if (adjust > (ULONG)cb) {
        int i;

        adjust -= cb;
        DPrintf((DebugBuf, "Adjusting header RVAs by %#08lx\n", adjust));
        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++) {
            if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
                New.OptionalHeader.DataDirectory[i].VirtualAddress < New.OptionalHeader.SizeOfHeaders) {
                DPrintf((DebugBuf, "Adjusting unit[%s] RVA from %#08lx to %#08lx\n",
                         apszUnit[i],
                         New.OptionalHeader.DataDirectory[i].VirtualAddress,
                         New.OptionalHeader.DataDirectory[i].VirtualAddress + adjust));
                New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
            }
        }
        New.OptionalHeader.SizeOfHeaders += adjust;
    } else if (adjust > 0) {
        int i;

        //
        // Loop over DataDirectory entries and look for any entries that point to
        // information stored in the 'dead' space after the section table but before
        // the SizeOfHeaders length.
        //
        DPrintf((DebugBuf, "Checking header RVAs for 'dead' space usage\n"));
        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++) {
            if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
                New.OptionalHeader.DataDirectory[i].VirtualAddress < Old.OptionalHeader.SizeOfHeaders) {
                DPrintf((DebugBuf, "Adjusting unit[%s] RVA from %#08lx to %#08lx\n",
                         apszUnit[i],
                         New.OptionalHeader.DataDirectory[i].VirtualAddress,
                         New.OptionalHeader.DataDirectory[i].VirtualAddress + adjust));
                New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
            }
        }
    }
    ibNewObjTabEnd += adjust;

    /* Allocate storage for new section table                */
    cb = New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    pObjtblNew = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), (short)cb);
    if (pObjtblNew == NULL) {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblNew, cb);
    DPrintf((DebugBuf, "New section table: %#08lx bytes at %#08lx\n", cb, pObjtblNew));
    pObjResourceNew = pObjtblNew + nObjResource;

    /*
     * copy old section table to new
     */
    VaAdjust = 0;                 /* adjustment to virtual address */
    for (pObjOld=pObjtblOld,pObjNew=pObjtblNew ; pObjOld<pObjLast ; pObjOld++) {
        if (pObjOld == pObjResourceOldX) {
            if (nObjResourceX == -1) {
                // we have to move back all the other section.
                // the .rsrc1 is bigger than what we need
                // adjust must be a negative number
                if (pObjOld+1 < pObjLast) {
                    VaAdjust -= (pObjOld+1)->VirtualAddress - pObjOld->VirtualAddress;
                }
            }
            continue;
        } else if (pObjNew == pObjResourceNew) {
            DPrintf((DebugBuf, "Resource Section %i\n", nObjResource+1));
            cb = ROUNDUP(cbNew, New.OptionalHeader.FileAlignment);
            if (pObjResourceOld == NULL) {
                VaAdjust = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
                RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
                strcpy((char *)pObjNew->Name, ".rsrc");
                pObjNew->VirtualAddress = pObjOld->VirtualAddress;
                pObjNew->PointerToRawData = pObjOld->PointerToRawData;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA;
                pObjNew->SizeOfRawData = cb;
                pObjNew->Misc.VirtualSize = cbNew;
            } else {
                *pObjNew = *pObjOld;    /* copy obj table entry */
                pObjNew->SizeOfRawData = cb;
                pObjNew->Misc.VirtualSize = cbNew;
                if (pObjNew->SizeOfRawData == pObjOld->SizeOfRawData) {
                    VaAdjust = 0;
                } else {          /* Adjust VA accordingly */
                    VaAdjust += ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
                    if (pObjOld+1 < pObjLast) {
                        // if there are more entries after pObjOld, shift those back as well 
                        VaAdjust -= ((pObjOld+1)->VirtualAddress - pObjOld->VirtualAddress);
                    }
                }
            }
            pObjNew++;
            if (pObjResourceOld == NULL)
                goto rest_of_table;
        } else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {
            DPrintf((DebugBuf, "Additional Resource Section %i\n",
                     nObjResourceX+1));
            RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
            strcpy((char *)pObjNew->Name, ".rsrc1");
            /*
             * Before we copy the virtual address we have to move back the
             * .reloc * virtual address. Otherwise we will keep moving the
             * reloc VirtualAddress forward.
             * We will have to move back the address of .rsrc1
             */
            if (pObjResourceOldX == NULL) {
                // This is the first time we have a .rsrc1
                pObjNew->VirtualAddress = pObjOld->VirtualAddress;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA;
                VaAdjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                         pObjResourceNew->VirtualAddress - pObjNew->VirtualAddress;
                DPrintf((DebugBuf, "Added .rsrc1. VirtualAddress %lu\t adjust: %lu\n", pObjNew->VirtualAddress, VaAdjust ));
            } else {
                // we already have an .rsrc1 use the position of that and
                // calculate the new adjust
                pObjNew->VirtualAddress = pObjResourceOldX->VirtualAddress;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA;

                DPrintf((DebugBuf, ".rsrc1 Keep old position.\t\tVirtualAddress %lu\t", pObjNew->VirtualAddress ));
                // Check if we have enough room in the old .rsrc1
                // Include the full size of the section, data + roundup
                if (cbResource -
                    (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress) <=
                    pObjOld->VirtualAddress - pObjNew->VirtualAddress ) {
                    // we have to move back all the other section.
                    // the .rsrc1 is bigger than what we need
                    // adjust must be a negative number
                    // calc new adjust size
                    VaAdjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                             pObjResourceNew->VirtualAddress -
                             pObjOld->VirtualAddress;
                    DPrintf((DebugBuf, "adjust: %ld\tsmall: New %lu\tOld %lu\n", adjust,
                             cbResource -
                             (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
                             pObjOld->VirtualAddress - pObjNew->VirtualAddress));
                } else {
                    // we have to move the section again.
                    // The .rsrc1 is too small

                    VaAdjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                             pObjResourceNew->VirtualAddress -
                             pObjOld->VirtualAddress;
                    DPrintf((DebugBuf, "adjust: %lu\tsmall: New %lu\tOld %lu\n", VaAdjust,
                             cbResource -
                             (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
                             pObjOld->VirtualAddress - pObjNew->VirtualAddress));
                }
            }
            pObjNew++;
            goto rest_of_table;
        } else if (pObjNew < pObjResourceNew) {
            DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
                     pObjOld - pObjtblOld + 1, pObjNew));
            *pObjNew++ = *pObjOld;              /* copy obj table entry */
        } else {
            rest_of_table:
            DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
                     pObjOld - pObjtblOld + 1, pObjNew));
            DPrintf((DebugBuf, "adjusting VirtualAddress by %#08lx\n", VaAdjust));
            *pObjNew++ = *pObjOld;
            (pObjNew-1)->VirtualAddress += VaAdjust;
        }
    }


    pObjNew = pObjtblNew + New.FileHeader.NumberOfSections - 1;
    New.OptionalHeader.SizeOfImage = ROUNDUP(pObjNew->VirtualAddress +
                                             pObjNew->SizeOfRawData,
                                             New.OptionalHeader.SectionAlignment);

    /* allocate room to build the resource directory/tables in */
    pResTab = (PIMAGE_RESOURCE_DIRECTORY)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cbRestab);
    if (pResTab == NULL) {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }

    /* First, setup the "root" type directory table.  It will be followed by */
    /* Types directory entries.                                              */

    RtlZeroMemory((PVOID)pResTab, cbRestab);
    DPrintf((DebugBuf, "resource directory tables: %#08lx bytes at %#08lx(mem)\n", cbRestab, pResTab));
    p = (PUCHAR)pResTab;
    SetRestab(pResTab, clock, (USHORT)cTypeStr, (USHORT)(cTypes - cTypeStr));

    /* Calculate the start of the various parts of the resource table.  */
    /* We need the start of the Type/Name/Language directories as well  */
    /* as the start of the UNICODE strings and the actual data nodes.   */

    pResDirT = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTab + 1);

    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirT) +
                                                 cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirN) +
                                                 cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +
                                                 cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResData = (PIMAGE_RESOURCE_DATA_ENTRY)(((PUCHAR)pResDirL) +
                                            cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +
                                            cRes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResStr  = (PUSHORT)(((PUCHAR)pResData) +
                         cRes * sizeof(IMAGE_RESOURCE_DATA_ENTRY));

    pResStrEnd = (PUSHORT)(((PUCHAR)pResStr) + cbName + cbType);

    /*
     * Loop over type table, building the PE resource table.
     */

    /*
     * *****************************************************************
     * This code doesn't sort the table - the TYPEINFO and RESINFO    **
     * insertion code in rcp.c (AddResType and SaveResFile) do the    **
     * insertion by ordinal type and name, so we don't have to sort   **
     * it at this point.                                              **
     * *****************************************************************
     */
    DPrintf((DebugBuf, "building resource directory\n"));

    // First, add all the entries in the Types: Alpha list.

    DPrintf((DebugBuf, "Walk the type: Alpha list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
        DPrintf((DebugBuf, "resource type "));
        DPrintfu((pType->Type->szStr));
        DPrintfn((DebugBuf, "\n"));

        pResDirT->Name = (ULONG)((((PUCHAR)pResStr) - p) |
                                 IMAGE_RESOURCE_NAME_IS_STRING);
        pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
                                         IMAGE_RESOURCE_DATA_IS_DIRECTORY);
        pResDirT++;

        *pResStr = pType->Type->cbsz;
        wcsncpy((WCHAR*)(pResStr+1), pType->Type->szStr, pType->Type->cbsz);
        pResStr += pType->Type->cbsz + 1;

        pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
        SetRestab(pResTabN, clock, (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
        pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

        pRes = pType->NameHeadName;
        while (pRes) {
            DPrintf((DebugBuf, "resource "));
            DPrintfu((pRes->Name->szStr));
            DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL || wcscmp(pPreviousName->szStr,pRes->Name->szStr) != 0) {
                // Setup a new name directory

                pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
                                         IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                                                 IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry

                *pResStr = pRes->Name->cbsz;
                wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
                pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
                       pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
                       pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pPreviousName = NULL;

        pRes = pType->NameHeadID;
        while (pRes) {
            DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

                pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                                                 IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
                       pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
                       pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pType = pType->pnext;
    }

    //  Do the same thing, but this time, use the Types: ID list.

    DPrintf((DebugBuf, "Walk the type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType) {
        DPrintf((DebugBuf, "resource type %hu\n", pType->Type->uu.Ordinal));

        pResDirT->Name = (ULONG)pType->Type->uu.Ordinal;
        pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
                                         IMAGE_RESOURCE_DATA_IS_DIRECTORY);
        pResDirT++;

        pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
        SetRestab(pResTabN, clock, (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
        pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

        pRes = pType->NameHeadName;
        while (pRes) {
            DPrintf((DebugBuf, "resource "));
            DPrintfu((pRes->Name->szStr));
            DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL || wcscmp(pPreviousName->szStr,pRes->Name->szStr) != 0) {
                // Setup a new name directory

                pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
                                         IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                                                 IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry.

                *pResStr = pRes->Name->cbsz;
                wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
                pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
                       pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
                       pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pPreviousName = NULL;

        pRes = pType->NameHeadID;
        while (pRes) {
            DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

                pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                                                 IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
                       pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
                       pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pType = pType->pnext;
    }
    DPrintf((DebugBuf, "Zeroing %u bytes after strings at %#08lx(mem)\n",
             (pResStrEnd - pResStr) * sizeof(*pResStr), pResStr));
    while (pResStr < pResStrEnd) {
        *pResStr++ = 0;
    }

#if DBG
    {
        USHORT  j = 0;
        PUSHORT pus = (PUSHORT)pResTab;

        while (pus < (PUSHORT)pResData) {
            DPrintf((DebugBuf, "%04x\t%04x %04x %04x %04x %04x %04x %04x %04x\n",
                     j,
                     *pus,
                     *(pus + 1),
                     *(pus + 2),
                     *(pus + 3),
                     *(pus + 4),
                     *(pus + 5),
                     *(pus + 6),
                     *(pus + 7)));
            pus += 8;
            j += 16;
        }
    }
#endif /* DBG */

    /*
     * copy the Old exe header and stub, and allocate room for the PE header.
     */
    DPrintf((DebugBuf, "copying through PE header: %#08lx bytes @0x0\n",
             cbOldexe + sizeof(NT_HEADER_TYPE)));
    MuMoveFilePos(inpfh, 0L);
    MuCopy(inpfh, outfh, cbOldexe + sizeof(NT_HEADER_TYPE));

    /*
     * Copy rest of file header
     */
    DPrintf((DebugBuf, "skipping section table: %#08lx bytes @%#08lx\n",
             New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
             FilePos(outfh)));
    DPrintf((DebugBuf, "copying hdr data: %#08lx bytes @%#08lx ==> @%#08lx\n",
             Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd,
             ibObjTabEnd,
             ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
             Old.OptionalHeader.SizeOfHeaders));

    MuMoveFilePos(outfh, ibNewObjTabEnd + New.OptionalHeader.SizeOfHeaders -
                  Old.OptionalHeader.SizeOfHeaders);
    MuMoveFilePos(inpfh, ibObjTabEnd);
    MuCopy(inpfh, outfh, Old.OptionalHeader.SizeOfHeaders - ibNewObjTabEnd);

    /*
     * copy existing image sections
     */

    /* Align data sections on sector boundary           */
    cb = REMAINDER(New.OptionalHeader.SizeOfHeaders, New.OptionalHeader.FileAlignment);
    New.OptionalHeader.SizeOfHeaders += cb;
    DPrintf((DebugBuf, "padding header with %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
    while (cb >= cbPadMax) {
        MuWrite(outfh, pchZero, cbPadMax);
        cb -= cbPadMax;
    }
    MuWrite(outfh, pchZero, cb);

    cb = ROUNDUP(Old.OptionalHeader.SizeOfHeaders, Old.OptionalHeader.FileAlignment);
    MuMoveFilePos(inpfh, cb);

    /* copy one section at a time */
    New.OptionalHeader.SizeOfInitializedData = 0;
    for (pObjOld = pObjtblOld , pObjNew = pObjtblNew ;
        pObjOld < pObjLast ;
        pObjNew++) {
        if (pObjOld == pObjResourceOldX)
            pObjOld++;
        if (pObjNew == pObjResourceNew) {

            /* Write new resource section */
            DPrintf((DebugBuf, "Primary resource section %i to %#08lx\n", nObjResource+1, FilePos(outfh)));

            pObjNew->PointerToRawData = FilePos(outfh);
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = pObjResourceNew->VirtualAddress;
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = cbResource;
            ibSave = FilePos(outfh);
            DPrintf((DebugBuf, "writing resource header data: %#08lx bytes @%#08lx\n", cbRestab, ibSave));
            MuWrite(outfh, (PUCHAR)pResTab, cbRestab);

            pResSave = WriteResSection(pUpdate, outfh,
                                       New.OptionalHeader.FileAlignment,
                                       pObjResourceNew->SizeOfRawData-cbRestab,
                                       NULL);
            cb = FilePos(outfh);
            DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
                     cb - ibSave - cbRestab, ibSave + cbRestab));
            if (nObjResourceX == -1) {
                MuMoveFilePos(outfh, ibSave);
                DPrintf((DebugBuf,
                         "re-writing resource directory: %#08x bytes @%#08lx\n",
                         cbRestab, ibSave));
                MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
                MuMoveFilePos(outfh, cb);
                cb = FilePos(inpfh);
                MuMoveFilePos(inpfh, cb+pObjOld->SizeOfRawData);
            }
            New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            if (pObjResourceOld == NULL) {
                pObjNew++;
                goto next_section;
            } else
                pObjOld++;
        } else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {

            /* Write new resource section */
            DPrintf((DebugBuf, "Secondary resource section %i @%#08lx\n", nObjResourceX+1, FilePos(outfh)));

            pObjNew->PointerToRawData = FilePos(outfh);
            (void)WriteResSection(pUpdate, outfh,
                                  New.OptionalHeader.FileAlignment, 0xffffffff, pResSave);
            cb = FilePos(outfh);
            pObjNew->SizeOfRawData = cb - pObjNew->PointerToRawData;
            pObjNew->Misc.VirtualSize = pObjNew->SizeOfRawData;
            DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
                     pObjNew->SizeOfRawData, pObjNew->PointerToRawData));
            MuMoveFilePos(outfh, ibSave);
            DPrintf((DebugBuf,
                     "re-writing resource directory: %#08x bytes @%#08lx\n",
                     cbRestab, ibSave));
            MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
            MuMoveFilePos(outfh, cb);
            New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            pObjNew++;
            goto next_section;
        } else {
            if (pObjNew < pObjResourceNew &&
                pObjOld->PointerToRawData != 0 &&
                pObjOld->PointerToRawData != FilePos(outfh)) {
                MuMoveFilePos(outfh, pObjOld->PointerToRawData);
            }
            next_section:
            DPrintf((DebugBuf, "copying section %i @%#08lx\n", pObjNew-pObjtblNew+1, FilePos(outfh)));
            if (pObjOld->PointerToRawData != 0) {
                pObjNew->PointerToRawData = FilePos(outfh);
                MuMoveFilePos(inpfh, pObjOld->PointerToRawData);
                MuCopy(inpfh, outfh, pObjOld->SizeOfRawData);
            }
            if (pObjOld == pObjDebugDirOld) {
                pObjDebugDirNew = pObjNew;
            }
            if ((pObjNew->Characteristics&IMAGE_SCN_CNT_INITIALIZED_DATA) != 0)
                New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            pObjOld++;
        }
    }
    if (pObjResourceOldX != NULL)
        New.OptionalHeader.SizeOfInitializedData -= pObjResourceOldX->SizeOfRawData;


    /* Update the address of the relocation table */
    pObjNew = FindSection(pObjtblNew,
                          pObjtblNew+New.FileHeader.NumberOfSections,
                          ".reloc");
    if (pObjNew != NULL) {
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = pObjNew->VirtualAddress;
    }

    /*
     * Write new section table out.
     */
    DPrintf((DebugBuf, "Writing new section table: %#08x bytes @%#08lx\n",
             New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
             ibObjTab));
    MuMoveFilePos(outfh, ibObjTab);
    MuWrite(outfh, (PUCHAR)pObjtblNew, New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    /* Seek to end of output file and issue truncating write */

    adjust = _llseek(outfh, 0L, SEEK_END);
    MuWrite(outfh, NULL, 0);
    DPrintf((DebugBuf, "File size is: %#08lx\n", adjust));

    /* If a debug section, fix up the debug table */

    pObjNew = FindSection(pObjtblNew, pObjtblNew+New.FileHeader.NumberOfSections, ".debug");
    cb = PatchDebug(inpfh, outfh, pObjDebug, pObjNew, pObjDebugDirOld, pObjDebugDirNew,
                    &Old, &New, ibMaxDbgOffsetOld, &adjust);

    if (cb == NO_ERROR) {
        if (pObjResourceOld == NULL) {
            cb = (LONG)pObjResourceNew->SizeOfRawData;

        } else {
            cb = (LONG)pObjResourceOld->SizeOfRawData - (LONG)pObjResourceNew->SizeOfRawData;
        }

        cb = PatchRVAs(inpfh, outfh, pObjtblNew, cb, &New, Old.OptionalHeader.SizeOfHeaders);
    }

    /* copy NOTMAPPED debug info */

    if ((pObjDebugDirOld != NULL) &&
        (pObjDebug == NULL) &&
        (New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size != 0)) {

        ULONG ibt;

        ibSave = _llseek(inpfh, 0L, SEEK_END);  /* copy debug data */
        ibt = _llseek(outfh, 0L, SEEK_END);     /* to EOF */
        if (New.FileHeader.PointerToSymbolTable != 0) {
            New.FileHeader.PointerToSymbolTable += ibt - adjust;
        }

        MuMoveFilePos(inpfh, adjust);   /* returned by PatchDebug */
        DPrintf((DebugBuf, "Copying NOTMAPPED Debug Information, %#08lx bytes\n", ibSave-adjust));
        MuCopy(inpfh, outfh, ibSave-adjust);
    }

    //
    // Write updated PE header.
    //

    MuMoveFilePos(outfh, cbOldexe);
    MuWrite(outfh, (char*)&New, sizeof(NT_HEADER_TYPE));

    /* free up allocated memory */

    RtlFreeHeap(RtlProcessHeap(), 0, pObjtblOld);
    RtlFreeHeap(RtlProcessHeap(), 0, pResTab);

AbortExit:
    if (pObjtblNew) {
        RtlFreeHeap(RtlProcessHeap(), 0, pObjtblNew);
    }
    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\vdm.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdm.h

Abstract:

    This module contains MVDM related interface prototypes

Author:

    Sudeep Bharati (sudeepb) 04-Jan-1992

Revision History:

--*/


BOOL
BaseGetVdmConfigInfo(
    IN  LPCWSTR CommandLine,
    IN  ULONG  DosSeqId,
    IN  ULONG  BinaryType,
    IN  PUNICODE_STRING CmdLineString,
    OUT PULONG VdmSize
    );

ULONG
BaseIsDosApplication(
    IN PUNICODE_STRING PathName,
    IN NTSTATUS Status
    );

BOOL
BaseUpdateVDMEntry(
    IN ULONG UpdateIndex,
    IN OUT HANDLE *WaitHandle,
    IN ULONG IndexInfo,
    IN ULONG BinaryType
    );

NTSTATUS
BaseCheckVDM(
    IN   ULONG BinaryType,
    IN   PCWCH lpApplicationName,
    IN   PCWCH lpCommandLine,
    IN  PCWCH lpCurrentDirectory,
    IN   ANSI_STRING *pAnsiStringEnv,
    IN   PBASE_API_MSG m,
    IN OUT PULONG iTask,
    IN   DWORD dwCreationFlags,
    LPSTARTUPINFOW lpStartupInfo,
    IN HANDLE hUserToken
    );

VOID
BaseCloseStandardHandle(
    IN PVDMINFO pVDMInfo
    );

BOOL
BaseCheckForVDM(
    IN HANDLE hProcess,
    OUT LPDWORD lpExitCode
    );

BOOL
BaseCreateVDMEnvironment(
    LPWSTR  lpEnvironment,
    ANSI_STRING *pAStringEnv,
    UNICODE_STRING *pUStringEnv
    );
BOOL
BaseDestroyVDMEnvironment(
    ANSI_STRING *pAStringEnv,
    UNICODE_STRING *pUStringEnv
);

UINT
BaseGetEnvNameType_U(
    WCHAR   * Name,
    DWORD   NameLength
);


LPCWSTR
SkipPathTypeIndicator_U(
    LPCWSTR Path
    );

BOOL
FindLFNorSFN_U(
    LPWSTR  Path,
    LPWSTR* ppFirst,
    LPWSTR* ppLast,
    BOOL    FindLFN
    );
BOOL
IsShortName_U(
    LPCWSTR Name,
    int     Length
    );
BOOL
IsLongName_U(
    LPCWSTR Name,
    int     Length
    );

#define MAX_VDM_NESTING 8

#define DEFAULT_ENV_LENGTH 256

#define MAX_VDM_CFG_LINE   256

#define FULL_INFO_BUFFER_SIZE (sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_VDM_CFG_LINE)


#define WOW_ROOT \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\WOW"

#define CMDLINE    L"cmdline"
#define DOSSIZE    L"size"
#define WOWCMDLINE L"wowcmdline"
#define WOWSIZE    L"wowsize"

#define CHECKDOSCONSOLE 0
#define CHECKWOWCONSOLE 1
#define ASSUMENOCONSOLE 2


extern HANDLE  hVDM[];


#define STD_ENV_NAME_COUNT     5

// Define environment variables we need to convert their values to
// short path name in BaseCreateVdmEnvironment function.
#define ENV_NAME_PATH      L"PATH"
#define ENV_NAME_PATH_LEN  4

#define ENV_NAME_WINDIR    L"WINDIR"
#define ENV_NAME_WINDIR_LEN   6

#define ENV_NAME_SYSTEMROOT   L"SYSTEMROOT"
#define ENV_NAME_SYSTEMROOT_LEN 10

#define ENV_NAME_TEMP      L"TEMP"
#define ENV_NAME_TEMP_LEN  4

#define ENV_NAME_TMP    L"TMP"
#define ENV_NAME_TMP_LEN   3


// ENV_NAME_TYPE
#define ENV_NAME_TYPE_NO_PATH    1
#define ENV_NAME_TYPE_SINGLE_PATH   2
#define ENV_NAME_TYPE_MULTIPLE_PATH 3

typedef struct _ENV_INFO {
    UINT    NameType;
    UINT    NameLength;
    WCHAR   *Name;
} ENV_INFO, * PENV_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\volmount.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    volmount.c

Abstract:

    This file contains the implementation for the Volume Mount Point API.

Author:

    Norbert P. Kusters (norbertk) 22-Dec-1997

Revision History:

--*/

#include "basedll.h"
#include "initguid.h"
#include "mountmgr.h"

// NOTE, this structure is here because it was not defined in NTIOAPI.H.
// This should be taken out in the future.
// This is stolen from NTFS.H

typedef struct _REPARSE_INDEX_KEY {

    //
    //  The tag of the reparse point.
    //

    ULONG FileReparseTag;

    //
    //  The file record Id where the reparse point is set.
    //

    LARGE_INTEGER FileId;

} REPARSE_INDEX_KEY, *PREPARSE_INDEX_KEY;

HANDLE
WINAPI
FindFirstVolumeA(
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    )

{
    ANSI_STRING     ansiVolumeName;
    UNICODE_STRING  unicodeVolumeName;
    HANDLE          h;
    NTSTATUS        status;

    ansiVolumeName.Buffer = lpszVolumeName;
    ansiVolumeName.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeName.Buffer = NULL;
    unicodeVolumeName.MaximumLength = 0;

    try {

        unicodeVolumeName.MaximumLength = (ansiVolumeName.MaximumLength + 1)*
                                          sizeof(WCHAR);
        unicodeVolumeName.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeName.MaximumLength);
        if (!unicodeVolumeName.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            h = INVALID_HANDLE_VALUE;
            leave;
        }

        h = FindFirstVolumeW(unicodeVolumeName.Buffer, cchBufferLength);

        if (h != INVALID_HANDLE_VALUE) {

            RtlInitUnicodeString(&unicodeVolumeName, unicodeVolumeName.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeName,
                                                    &unicodeVolumeName, FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                h = INVALID_HANDLE_VALUE;
                leave;
            }

            ansiVolumeName.Buffer[ansiVolumeName.Length] = 0;
        }

    } finally {

        if (unicodeVolumeName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeName.Buffer);
        }
    }

    return h;
}

HANDLE
WINAPI
FindFirstVolumeW(
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine kicks off the enumeration of all volumes in the system.

Arguments:

    lpszVolumeName  - Returns the first volume name in the system.

    cchBufferLength - Supplies the size of the preceeding buffer.

Return Value:

    A valid handle or INVALID_HANDLE_VALUE.

--*/

{
    HANDLE                  h;
    MOUNTMGR_MOUNT_POINT    point;
    PMOUNTMGR_MOUNT_POINTS  points;
    BOOL                    b;
    DWORD                   bytes;

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return INVALID_HANDLE_VALUE;
    }

    RtlZeroMemory(&point, sizeof(point));

    points = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                             sizeof(MOUNTMGR_MOUNT_POINTS));
    if (!points) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return INVALID_HANDLE_VALUE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, &point, sizeof(point),
                        points, sizeof(MOUNTMGR_MOUNT_POINTS), &bytes, NULL);
    while (!b && GetLastError() == ERROR_MORE_DATA) {
        bytes = points->Size;
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        points = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), bytes);
        if (!points) {
            CloseHandle(h);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return INVALID_HANDLE_VALUE;
        }

        b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, &point,
                            sizeof(point), points, bytes, &bytes, NULL);
    }

    CloseHandle(h);

    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        return INVALID_HANDLE_VALUE;
    }

    b = FindNextVolumeW((HANDLE) points, lpszVolumeName, cchBufferLength);
    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        return INVALID_HANDLE_VALUE;
    }

    return (HANDLE) points;
}

BOOL
WINAPI
FindNextVolumeA(
    HANDLE hFindVolume,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    )

{
    ANSI_STRING     ansiVolumeName;
    UNICODE_STRING  unicodeVolumeName;
    BOOL            b;
    NTSTATUS        status;

    ansiVolumeName.Buffer = lpszVolumeName;
    ansiVolumeName.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeName.Buffer = NULL;
    unicodeVolumeName.MaximumLength = 0;

    try {

        unicodeVolumeName.MaximumLength = (ansiVolumeName.MaximumLength + 1)*
                                          sizeof(WCHAR);
        unicodeVolumeName.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeName.MaximumLength);
        if (!unicodeVolumeName.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            leave;
        }

        b = FindNextVolumeW(hFindVolume, unicodeVolumeName.Buffer,
                            cchBufferLength);

        if (b) {

            RtlInitUnicodeString(&unicodeVolumeName, unicodeVolumeName.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeName,
                                                    &unicodeVolumeName, FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                b = FALSE;
                leave;
            }

            ansiVolumeName.Buffer[ansiVolumeName.Length] = 0;
        }

    } finally {

        if (unicodeVolumeName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeName.Buffer);
        }
    }

    return b;
}

BOOL
WINAPI
FindNextVolumeW(
    HANDLE hFindVolume,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine continues the enumeration of all volumes in the system.

Arguments:

    hFindVolume     - Supplies the find volume handle.

    lpszVolumeName  - Returns the first volume name in the system.

    cchBufferLength - Supplies the size of the preceeding buffer.

Return Value:

    FALSE   - Failure.  The error code is returned in GetLastError().

    TRUE    - Success.

--*/

{
    PMOUNTMGR_MOUNT_POINTS  points = hFindVolume;
    DWORD                   i, j;
    PMOUNTMGR_MOUNT_POINT   point, point2;
    UNICODE_STRING          symName, symName2, devName, devName2;

    for (i = 0; i < points->NumberOfMountPoints; i++) {

        point = &points->MountPoints[i];
        if (!point->SymbolicLinkNameOffset) {
            continue;
        }

        symName.Length = symName.MaximumLength = point->SymbolicLinkNameLength;
        symName.Buffer = (PWSTR) ((PCHAR) points +
                                  point->SymbolicLinkNameOffset);

        if (!MOUNTMGR_IS_NT_VOLUME_NAME(&symName)) {
            point->SymbolicLinkNameOffset = 0;
            continue;
        }

        devName.Length = devName.MaximumLength = point->DeviceNameLength;
        devName.Buffer = (PWSTR) ((PCHAR) points +
                                  point->DeviceNameOffset);

        for (j = i + 1; j < points->NumberOfMountPoints; j++) {

            point2 = &points->MountPoints[j];
            if (!point2->SymbolicLinkNameOffset) {
                continue;
            }

            symName2.Length = symName2.MaximumLength =
                    point2->SymbolicLinkNameLength;
            symName2.Buffer = (PWSTR) ((PCHAR) points +
                                       point2->SymbolicLinkNameOffset);

            if (!MOUNTMGR_IS_NT_VOLUME_NAME(&symName2)) {
                point2->SymbolicLinkNameOffset = 0;
                continue;
            }

            devName2.Length = devName2.MaximumLength =
                    point2->DeviceNameLength;
            devName2.Buffer = (PWSTR) ((PCHAR) points +
                                       point2->DeviceNameOffset);

            if (RtlEqualUnicodeString(&devName, &devName2, TRUE)) {
                point2->SymbolicLinkNameOffset = 0;
            }
        }

        break;
    }

    if (i == points->NumberOfMountPoints) {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    if (cchBufferLength*sizeof(WCHAR) < point->SymbolicLinkNameLength +
        2*sizeof(WCHAR)) {

        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        return FALSE;
    }

    RtlCopyMemory(lpszVolumeName, (PCHAR) points +
                  point->SymbolicLinkNameOffset,
                  point->SymbolicLinkNameLength);
    lpszVolumeName[1] = '\\';
    lpszVolumeName[point->SymbolicLinkNameLength/sizeof(WCHAR)] = '\\';
    lpszVolumeName[point->SymbolicLinkNameLength/sizeof(WCHAR) + 1] = 0;

    point->SymbolicLinkNameOffset = 0;

    return TRUE;
}

BOOL
WINAPI
FindVolumeClose(
    HANDLE hFindVolume
    )

{
    RtlFreeHeap(RtlProcessHeap(), 0, hFindVolume);
    return TRUE;
}

HANDLE
WINAPI
FindFirstVolumeMountPointA(
    LPCSTR lpszRootPathName,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    )

{
    PUNICODE_STRING unicodeRootPathName;
    ANSI_STRING     ansiVolumeMountPoint;
    UNICODE_STRING  unicodeVolumeMountPoint;
    HANDLE          h;
    NTSTATUS        status;

    unicodeRootPathName =
            Basep8BitStringToStaticUnicodeString(lpszRootPathName);
    if (!unicodeRootPathName) {
        return INVALID_HANDLE_VALUE;
    }

    ansiVolumeMountPoint.Buffer = lpszVolumeMountPoint;
    ansiVolumeMountPoint.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeMountPoint.Buffer = NULL;
    unicodeVolumeMountPoint.MaximumLength = 0;

    try {

        unicodeVolumeMountPoint.MaximumLength =
                (ansiVolumeMountPoint.MaximumLength + 1)*sizeof(WCHAR);
        unicodeVolumeMountPoint.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeMountPoint.MaximumLength);
        if (!unicodeVolumeMountPoint.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return INVALID_HANDLE_VALUE;
        }

        h = FindFirstVolumeMountPointW(unicodeRootPathName->Buffer,
                                       unicodeVolumeMountPoint.Buffer,
                                       cchBufferLength);

        if (h != INVALID_HANDLE_VALUE) {

            RtlInitUnicodeString(&unicodeVolumeMountPoint,
                                 unicodeVolumeMountPoint.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeMountPoint,
                                                    &unicodeVolumeMountPoint,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                h = INVALID_HANDLE_VALUE;
                leave;
            }

            ansiVolumeMountPoint.Buffer[ansiVolumeMountPoint.Length] = 0;
        }

    } finally {

        if (unicodeVolumeMountPoint.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeMountPoint.Buffer);
        }
    }

    return h;
}

BOOL
FindNextVolumeMountPointHelper(
    HANDLE hFindVolumeMountPoint,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength,
    BOOL FirstTimeCalled
    )

/*++

Routine Description:

    This routine continues the enumeration of all volume mount point on the
    given volume.

Arguments:

    hFindVolumeMountPoint   - Supplies the handle for the enumeration.

    lpszVolumeMountPoint    - Returns the volume mount point.

    cchBufferLength         - Supplies the volume mount point buffer length.

    FirstTimeCalled         - Supplies whether or not this is being called
                                from FindFirst or from FindNext.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    REPARSE_INDEX_KEY                   reparseKey;
    UNICODE_STRING                      reparseName;
    NTSTATUS                            status;
    IO_STATUS_BLOCK                     ioStatus;
    FILE_REPARSE_POINT_INFORMATION      reparseInfo;
    UNICODE_STRING                      fileId;
    OBJECT_ATTRIBUTES                   oa;
    HANDLE                              h;
    PREPARSE_DATA_BUFFER                reparse;
    BOOL                                b;
    DWORD                               bytes;
    UNICODE_STRING                      mountName;
    DWORD                               nameInfoSize;
    PFILE_NAME_INFORMATION              nameInfo;

    for (;;) {

        if (FirstTimeCalled) {
            FirstTimeCalled = FALSE;
            RtlZeroMemory(&reparseKey, sizeof(reparseKey));
            reparseKey.FileReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
            reparseName.Length = reparseName.MaximumLength = sizeof(reparseKey);
            reparseName.Buffer = (PWCHAR) &reparseKey;
            status = NtQueryDirectoryFile(hFindVolumeMountPoint,
                                          NULL, NULL, NULL, &ioStatus,
                                          &reparseInfo, sizeof(reparseInfo),
                                          FileReparsePointInformation, TRUE,
                                          &reparseName, FALSE);
        } else {
            status = NtQueryDirectoryFile(hFindVolumeMountPoint,
                                          NULL, NULL, NULL, &ioStatus,
                                          &reparseInfo, sizeof(reparseInfo),
                                          FileReparsePointInformation, TRUE,
                                          NULL, FALSE);
        }

        if (!NT_SUCCESS(status)) {
            BaseSetLastNTError(status);
            return FALSE;
        }

        if (reparseInfo.Tag != IO_REPARSE_TAG_MOUNT_POINT) {
            SetLastError(ERROR_NO_MORE_FILES);
            return FALSE;
        }

        fileId.Length = sizeof(reparseInfo.FileReference);
        fileId.MaximumLength = fileId.Length;
        fileId.Buffer = (PWSTR) &reparseInfo.FileReference;

        InitializeObjectAttributes(&oa, &fileId, 0, hFindVolumeMountPoint,
                                   NULL);

        status = NtOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_OPEN_BY_FILE_ID | FILE_OPEN_REPARSE_POINT);
        if (!NT_SUCCESS(status)) {
            BaseSetLastNTError(status);
            return FALSE;
        }

        reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                  MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
        if (!reparse) {
            CloseHandle(h);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        b = DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                            MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &bytes, NULL);

        if (!b || reparse->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {
            RtlFreeHeap(RtlProcessHeap(), 0, reparse);
            CloseHandle(h);
            return FALSE;
        }

        mountName.Length = mountName.MaximumLength =
                reparse->MountPointReparseBuffer.SubstituteNameLength;
        mountName.Buffer = (PWSTR)
                ((PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                 reparse->MountPointReparseBuffer.SubstituteNameOffset);

        if (!MOUNTMGR_IS_NT_VOLUME_NAME_WB(&mountName)) {
            RtlFreeHeap(RtlProcessHeap(), 0, reparse);
            CloseHandle(h);
            continue;
        }

        RtlFreeHeap(RtlProcessHeap(), 0, reparse);

        nameInfoSize = FIELD_OFFSET(FILE_NAME_INFORMATION, FileName) +
                       (cchBufferLength - 1)*sizeof(WCHAR);
        nameInfo = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                   nameInfoSize);
        if (!nameInfo) {
            CloseHandle(h);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        status = NtQueryInformationFile(h, &ioStatus, nameInfo, nameInfoSize,
                                        FileNameInformation);
        if (!NT_SUCCESS(status)) {
            RtlFreeHeap(RtlProcessHeap(), 0, nameInfo);
            CloseHandle(h);
            BaseSetLastNTError(status);
            return FALSE;
        }

        RtlCopyMemory(lpszVolumeMountPoint, &nameInfo->FileName[1],
                      nameInfo->FileNameLength - sizeof(WCHAR));
        lpszVolumeMountPoint[nameInfo->FileNameLength/sizeof(WCHAR) - 1] = '\\';
        lpszVolumeMountPoint[nameInfo->FileNameLength/sizeof(WCHAR)] = 0;

        RtlFreeHeap(RtlProcessHeap(), 0, nameInfo);
        CloseHandle(h);
        break;
    }

    return TRUE;
}

HANDLE
WINAPI
FindFirstVolumeMountPointW(
    LPCWSTR lpszRootPathName,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine kicks off the enumeration of all volume mount point on the
    given volume.

Arguments:

    lpszRootPathName        - Supplies the root path name.

    lpszVolumeMountPoint    - Returns the volume mount point.

    cchBufferLength         - Supplies the volume mount point buffer length.

Return Value:

    A handle or INVALID_HANDLE_VALUE.

--*/

{
    UNICODE_STRING                  unicodeRootPathName;
    UNICODE_STRING                  reparseSuffix, reparseName;
    HANDLE                          h;
    BOOL                            b;
    NTSTATUS                        Status;
    ULONG                           TotalSize;

    Status = RtlInitUnicodeStringEx(&unicodeRootPathName, lpszRootPathName);
    if( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }

    if (unicodeRootPathName.Buffer[
        unicodeRootPathName.Length/sizeof(WCHAR) - 1] != '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return INVALID_HANDLE_VALUE;
    }

    RtlInitUnicodeString(&reparseSuffix,
                         L"$Extend\\$Reparse:$R:$INDEX_ALLOCATION");

    TotalSize = unicodeRootPathName.Length + reparseSuffix.Length + sizeof(WCHAR);
    if( TotalSize > MAXUSHORT ) {
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return INVALID_HANDLE_VALUE;
    }

    reparseName.MaximumLength = (USHORT)TotalSize;
    reparseName.Length = 0;
    reparseName.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                         reparseName.MaximumLength);
    if (!reparseName.Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return INVALID_HANDLE_VALUE;
    }

    RtlCopyUnicodeString(&reparseName, &unicodeRootPathName);
    RtlAppendUnicodeStringToString(&reparseName, &reparseSuffix);
    reparseName.Buffer[reparseName.Length/sizeof(WCHAR)] = 0;

    h = CreateFileW(reparseName.Buffer, GENERIC_READ, FILE_SHARE_READ, NULL,
                    OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS |
                    SECURITY_IMPERSONATION, NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, reparseName.Buffer);

    if (h == INVALID_HANDLE_VALUE) {
        return INVALID_HANDLE_VALUE;
    }

    b = FindNextVolumeMountPointHelper(h, lpszVolumeMountPoint,
                                       cchBufferLength, TRUE);
    if (!b) {
        CloseHandle(h);
        return INVALID_HANDLE_VALUE;
    }

    return h;
}

BOOL
WINAPI
FindNextVolumeMountPointA(
    HANDLE hFindVolumeMountPoint,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    )

{
    ANSI_STRING     ansiVolumeMountPoint;
    UNICODE_STRING  unicodeVolumeMountPoint;
    BOOL            b;
    NTSTATUS        status;

    ansiVolumeMountPoint.Buffer = lpszVolumeMountPoint;
    ansiVolumeMountPoint.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeMountPoint.Buffer = NULL;
    unicodeVolumeMountPoint.MaximumLength = 0;

    try {

        unicodeVolumeMountPoint.MaximumLength =
                (ansiVolumeMountPoint.MaximumLength + 1)*sizeof(WCHAR);
        unicodeVolumeMountPoint.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeMountPoint.MaximumLength);
        if (!unicodeVolumeMountPoint.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            leave;
        }

        b = FindNextVolumeMountPointW(hFindVolumeMountPoint,
                                      unicodeVolumeMountPoint.Buffer,
                                      cchBufferLength);

        if (b) {

            RtlInitUnicodeString(&unicodeVolumeMountPoint,
                                 unicodeVolumeMountPoint.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeMountPoint,
                                                    &unicodeVolumeMountPoint,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                b = FALSE;
                leave;
            }

            ansiVolumeMountPoint.Buffer[ansiVolumeMountPoint.Length] = 0;
        }

    } finally {

        if (unicodeVolumeMountPoint.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeMountPoint.Buffer);
        }
    }

    return b;
}

BOOL
IsThisAVolumeName(
    LPCWSTR     Name,
    PBOOLEAN    IsVolume
    )

/*++

Routine Description:

    This routine takes the given NT name and determines whether or not
    the name points to a volume.

Arguments:

    Name        - Supplies the name.

    IsVolume    - Returns whether or not the given name is a volume.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING          name;
    PMOUNTMGR_MOUNT_POINT   point;
    MOUNTMGR_MOUNT_POINTS   points;
    HANDLE                  h;
    BOOL                    b;
    DWORD                   bytes;

    RtlInitUnicodeString(&name, Name);
    if (name.Buffer[name.Length/sizeof(WCHAR) - 1] == '\\') {
        name.Length -= sizeof(WCHAR);
    }
    point = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                            name.Length + sizeof(MOUNTMGR_MOUNT_POINT));
    if (!point) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    point->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->DeviceNameLength = name.Length;
    RtlCopyMemory((PCHAR) point + point->DeviceNameOffset, name.Buffer,
                  point->DeviceNameLength);

    if (name.Length >= 4 && name.Buffer[1] == '\\') {
        ((PWSTR) ((PCHAR) point + point->DeviceNameOffset))[1] = '?';
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0, FILE_SHARE_READ |
                    FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, point);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, point,
                        name.Length + sizeof(MOUNTMGR_MOUNT_POINT),
                        &points, sizeof(MOUNTMGR_MOUNT_POINTS), &bytes, NULL);
    if (b) {
        if (points.NumberOfMountPoints) {
            *IsVolume = TRUE;
        } else {
            *IsVolume = FALSE;
        }
    } else {
        if (GetLastError() == ERROR_MORE_DATA) {
            *IsVolume = TRUE;
        } else {
            *IsVolume = FALSE;
        }
    }

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, point);

    return TRUE;
}

BOOL
WINAPI
FindNextVolumeMountPointW(
    HANDLE hFindVolumeMountPoint,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine continues the enumeration of all volume mount point on the
    given volume.

Arguments:

    hFindVolumeMountPoint   - Supplies the handle for the enumeration.

    lpszVolumeMountPoint    - Returns the volume mount point.

    cchBufferLength         - Supplies the volume mount point buffer length.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    return FindNextVolumeMountPointHelper(hFindVolumeMountPoint,
                                          lpszVolumeMountPoint,
                                          cchBufferLength, FALSE);
}

BOOL
WINAPI
FindVolumeMountPointClose(
    HANDLE hFindVolumeMountPoint
    )

{
    return CloseHandle(hFindVolumeMountPoint);
}

BOOL
WINAPI
GetVolumeNameForVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    )

{
    PUNICODE_STRING unicodeVolumeMountPoint;
    ANSI_STRING     ansiVolumeName;
    UNICODE_STRING  unicodeVolumeName;
    BOOL            b;
    NTSTATUS        status;

    unicodeVolumeMountPoint =
            Basep8BitStringToStaticUnicodeString(lpszVolumeMountPoint);
    if (!unicodeVolumeMountPoint) {
        return FALSE;
    }

    ansiVolumeName.Buffer = lpszVolumeName;
    ansiVolumeName.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumeName.Buffer = NULL;
    unicodeVolumeName.MaximumLength = 0;

    try {

        unicodeVolumeName.MaximumLength =
                (ansiVolumeName.MaximumLength + 1)*sizeof(WCHAR);
        unicodeVolumeName.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumeName.MaximumLength);
        if (!unicodeVolumeName.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            leave;
        }

        b = GetVolumeNameForVolumeMountPointW(unicodeVolumeMountPoint->Buffer,
                                              unicodeVolumeName.Buffer,
                                              cchBufferLength);

        if (b) {

            RtlInitUnicodeString(&unicodeVolumeName,
                                 unicodeVolumeName.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumeName,
                                                    &unicodeVolumeName,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                b = FALSE;
                leave;
            }

            ansiVolumeName.Buffer[ansiVolumeName.Length] = 0;
        }

    } finally {

        if (unicodeVolumeName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumeName.Buffer);
        }
    }

    return b;
}

BOOL
GetVolumeNameForRoot(
    LPCWSTR DeviceName,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine queries the volume name for the given NT device name.

Arguments:

    DeviceName      - Supplies a DOS device name terminated by a '\'.

    lpszVolumeName  - Returns the volume name pointed to by the DOS
                        device name.

    cchBufferLength - Supplies the size of the preceeding buffer.

Return Value:

    FALSE   - Failure.  The error code is returned in GetLastError().

    TRUE    - Success.

--*/

{
    NTSTATUS                status;
    UNICODE_STRING          devicePath, symName;
    OBJECT_ATTRIBUTES       oa;
    HANDLE                  h;
    IO_STATUS_BLOCK         ioStatus;
    WCHAR                   buffer[MAX_PATH];
    PMOUNTDEV_NAME          name;
    BOOL                    b;
    DWORD                   bytes, i;
    PMOUNTMGR_MOUNT_POINT   point;
    PMOUNTMGR_MOUNT_POINTS  points;

    if (GetDriveTypeW(DeviceName) == DRIVE_REMOTE) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    if (!RtlDosPathNameToNtPathName_U(DeviceName, &devicePath, NULL, NULL)) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    if (devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 1] == '\\') {
        devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 1] = 0;
        devicePath.Length -= sizeof(WCHAR);
    }

    if (devicePath.Length >= 2*sizeof(WCHAR) &&
        devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 1] == ':') {

        devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 2] = (WCHAR)
            toupper(devicePath.Buffer[devicePath.Length/sizeof(WCHAR) - 2]);
    }

    InitializeObjectAttributes(&oa, &devicePath, OBJ_CASE_INSENSITIVE,
                               NULL, NULL);

    status = NtOpenFile(&h, FILE_READ_ATTRIBUTES | SYNCHRONIZE, &oa,
                        &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (!NT_SUCCESS(status)) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        SetLastError(RtlNtStatusToDosError(status));
        return FALSE;
    }

    name = (PMOUNTDEV_NAME) buffer;
    b = DeviceIoControl(h, IOCTL_MOUNTDEV_QUERY_DEVICE_NAME, NULL, 0, name,
                        MAX_PATH*sizeof(WCHAR), &bytes, NULL);
    NtClose(h);

    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        return FALSE;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);

    devicePath.Length = name->NameLength;
    devicePath.MaximumLength = devicePath.Length + sizeof(WCHAR);

    devicePath.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                        MAKE_TAG(TMP_TAG),
                                        devicePath.MaximumLength);
    if (!devicePath.Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlCopyMemory(devicePath.Buffer, name->Name, name->NameLength);
    devicePath.Buffer[devicePath.Length/sizeof(WCHAR)] = 0;

    point = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                            devicePath.Length + sizeof(MOUNTMGR_MOUNT_POINT));
    if (!point) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlZeroMemory(point, sizeof(MOUNTMGR_MOUNT_POINT));
    point->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    point->DeviceNameLength = devicePath.Length;
    RtlCopyMemory((PCHAR) point + point->DeviceNameOffset,
                  devicePath.Buffer, point->DeviceNameLength);

    RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);

    points = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                             sizeof(MOUNTMGR_MOUNT_POINTS));
    if (!points) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RtlFreeHeap(RtlProcessHeap(), 0, point);
        return FALSE;
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        RtlFreeHeap(RtlProcessHeap(), 0, point);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, point,
                        devicePath.Length + sizeof(MOUNTMGR_MOUNT_POINT),
                        points, sizeof(MOUNTMGR_MOUNT_POINTS), &bytes, NULL);
    while (!b && GetLastError() == ERROR_MORE_DATA) {
        bytes = points->Size;
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        points = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), bytes);
        if (!points) {
            CloseHandle(h);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            RtlFreeHeap(RtlProcessHeap(), 0, point);
            return FALSE;
        }

        b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_POINTS, point,
                            devicePath.Length + sizeof(MOUNTMGR_MOUNT_POINT),
                            points, bytes, &bytes, NULL);
    }

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, point);

    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for (i = 0; i < points->NumberOfMountPoints; i++) {

        symName.Length = symName.MaximumLength =
                points->MountPoints[i].SymbolicLinkNameLength;
        symName.Buffer = (PWSTR) ((PCHAR) points +
                         points->MountPoints[i].SymbolicLinkNameOffset);

        if (MOUNTMGR_IS_NT_VOLUME_NAME(&symName)) {
            break;
        }
    }

    if (i == points->NumberOfMountPoints) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (cchBufferLength*sizeof(WCHAR) < symName.Length + 2*sizeof(WCHAR)) {
        RtlFreeHeap(RtlProcessHeap(), 0, points);
        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        return FALSE;
    }

    RtlCopyMemory(lpszVolumeName, symName.Buffer, symName.Length);
    lpszVolumeName[1] = '\\';
    lpszVolumeName[symName.Length/sizeof(WCHAR)] = '\\';
    lpszVolumeName[symName.Length/sizeof(WCHAR) + 1] = 0;

    RtlFreeHeap(RtlProcessHeap(), 0, points);

    return TRUE;
}

BOOL
BasepGetVolumeNameFromReparsePoint(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength,
    PBOOL ResultOfOpen
    )

{
    HANDLE                  h;
    PREPARSE_DATA_BUFFER    reparse;
    BOOL                    b;
    DWORD                   bytes;
    UNICODE_STRING          mountName;
    WCHAR                   c;

    h = CreateFileW(lpszVolumeMountPoint, 0, FILE_SHARE_READ |
                    FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OPEN_REPARSE_POINT |
                    FILE_FLAG_BACKUP_SEMANTICS, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        if (ResultOfOpen) {
            *ResultOfOpen = FALSE;
        }
        if (lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return FALSE;
    }

    if (ResultOfOpen) {
        *ResultOfOpen = TRUE;
    }

    reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                              MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        if (lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return FALSE;
    }

    b = DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                        MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &bytes, NULL);
    CloseHandle(h);

    if (!b || reparse->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {
        RtlFreeHeap(RtlProcessHeap(), 0, reparse);
        if (lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return FALSE;
    }

    if (cchBufferLength*sizeof(WCHAR) <
        reparse->MountPointReparseBuffer.SubstituteNameLength + sizeof(WCHAR)) {

        RtlFreeHeap(RtlProcessHeap(), 0, reparse);
        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        if (lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return FALSE;
    }

    RtlCopyMemory(lpszVolumeName,
                  (PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                  reparse->MountPointReparseBuffer.SubstituteNameOffset,
                  reparse->MountPointReparseBuffer.SubstituteNameLength);

    c = lpszVolumeName[1];
    lpszVolumeName[1] = '\\';
    lpszVolumeName[reparse->MountPointReparseBuffer.SubstituteNameLength/
                   sizeof(WCHAR)] = 0;

    mountName.Length = mountName.MaximumLength =
            reparse->MountPointReparseBuffer.SubstituteNameLength;
    mountName.Buffer = lpszVolumeName;

    RtlFreeHeap(RtlProcessHeap(), 0, reparse);

    if (!MOUNTMGR_IS_DOS_VOLUME_NAME_WB(&mountName)) {
        /*
        ** Note that we deliberately choose to NOT zero the first character
        ** of the returned buffer. The call from GetVolumePathNameW() is able 
        ** to handle the case where we found a directory junction instead of
        ** a mountpoint. The other caller GetVolumeNameForVolumeMountPointW() 
        ** zaps the first char in the event of failure.
        */
        lpszVolumeName[1] = c;
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}

BOOL
BasepGetVolumeNameForVolumeMountPoint(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength,
    PBOOL ResultOfOpen
    )

/*++

Routine Description:

    This routine returns the volume name for a given volume mount point.

Arguments:

    lpszVolumeMountPoint    - Supplies the volume mount point.

    lpszVolumeName          - Returns the volume name.

    cchBufferLength         - Supplies the size of the volume name buffer.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING  unicodeVolumeMountPoint;
    BOOL            b;

    if (ResultOfOpen) {
        *ResultOfOpen = TRUE;
    }

    RtlInitUnicodeString(&unicodeVolumeMountPoint, lpszVolumeMountPoint);
    if (unicodeVolumeMountPoint.Buffer[
        unicodeVolumeMountPoint.Length/sizeof(WCHAR) - 1] != '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        if (lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return FALSE;
    }

    if (unicodeVolumeMountPoint.Length == 6 &&
        unicodeVolumeMountPoint.Buffer[1] == ':') {

        b = GetVolumeNameForRoot(lpszVolumeMountPoint, lpszVolumeName,
                                 cchBufferLength);
        if (!b && lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return b;
    }

    if (unicodeVolumeMountPoint.Length == 14 &&
        unicodeVolumeMountPoint.Buffer[0] == '\\' &&
        unicodeVolumeMountPoint.Buffer[1] == '\\' &&
        (unicodeVolumeMountPoint.Buffer[2] == '.' ||
         unicodeVolumeMountPoint.Buffer[2] == '?') &&
        unicodeVolumeMountPoint.Buffer[3] == '\\' &&
        unicodeVolumeMountPoint.Buffer[5] == ':') {

        b = GetVolumeNameForRoot(lpszVolumeMountPoint + 4,
                                 lpszVolumeName, cchBufferLength);
        if (!b && lpszVolumeName && cchBufferLength >= 1) {
            *lpszVolumeName = 0;
        }
        return b;
    }

    if (GetVolumeNameForRoot(lpszVolumeMountPoint, lpszVolumeName,
                             cchBufferLength)) {

        return TRUE;
    }

    b = BasepGetVolumeNameFromReparsePoint(lpszVolumeMountPoint,
                                           lpszVolumeName, cchBufferLength,
                                           ResultOfOpen);

    return b;
}

BOOL
WINAPI
GetVolumeNameForVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine returns the volume name for a given volume mount point.

Arguments:

    lpszVolumeMountPoint    - Supplies the volume mount point.

    lpszVolumeName          - Returns the volume name.

    cchBufferLength         - Supplies the size of the volume name buffer.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    BOOL    b = BasepGetVolumeNameForVolumeMountPoint(lpszVolumeMountPoint,
                                                      lpszVolumeName,
                                                      cchBufferLength, NULL);

    if (!b && lpszVolumeName && cchBufferLength >= 1) {
        *lpszVolumeName = 0;
    }

    return b;
}

BOOL
WINAPI
SetVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPCSTR lpszVolumeName
    )

{
    PUNICODE_STRING unicodeVolumeMountPoint;
    UNICODE_STRING  unicodeVolumeName;
    BOOL            b;

    unicodeVolumeMountPoint = Basep8BitStringToStaticUnicodeString(
                              lpszVolumeMountPoint);
    if (!unicodeVolumeMountPoint) {
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString(&unicodeVolumeName,
                                               lpszVolumeName)) {
        return FALSE;
    }

    b = SetVolumeMountPointW(unicodeVolumeMountPoint->Buffer,
                             unicodeVolumeName.Buffer);

    RtlFreeUnicodeString(&unicodeVolumeName);

    return b;
}

BOOL
SetVolumeNameForRoot(
    LPCWSTR DeviceName,
    LPCWSTR lpszVolumeName
    )

/*++

Routine Description:

    This routine sets the volume name for the given DOS device name.

Arguments:

    DeviceName      - Supplies a DOS device name terminated by a '\'.

    lpszVolumeName  - Supplies the volume name that the DOS device name
                        will point to.

Return Value:

    FALSE   - Failure.  The error code is returned in GetLastError().

    TRUE    - Success.

--*/

{
    UNICODE_STRING                  devicePath, volumeName;
    DWORD                           inputLength;
    PMOUNTMGR_CREATE_POINT_INPUT    input;
    HANDLE                          h;
    BOOL                            b;
    DWORD                           bytes;

    devicePath.Length = 28;
    devicePath.MaximumLength = devicePath.Length + sizeof(WCHAR);
    devicePath.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                        devicePath.MaximumLength);
    if (!devicePath.Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    RtlCopyMemory(devicePath.Buffer, L"\\DosDevices\\", 24);

    devicePath.Buffer[12] = (WCHAR)toupper(DeviceName[0]);
    devicePath.Buffer[13] = ':';
    devicePath.Buffer[14] = 0;

    RtlInitUnicodeString(&volumeName, lpszVolumeName);
    volumeName.Length -= sizeof(WCHAR);

    inputLength = sizeof(MOUNTMGR_CREATE_POINT_INPUT) + devicePath.Length +
                  volumeName.Length;
    input = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), inputLength);
    if (!input) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    input->SymbolicLinkNameLength = devicePath.Length;
    input->DeviceNameOffset = input->SymbolicLinkNameOffset +
                              input->SymbolicLinkNameLength;
    input->DeviceNameLength = volumeName.Length;
    RtlCopyMemory((PCHAR) input + input->SymbolicLinkNameOffset,
                  devicePath.Buffer, input->SymbolicLinkNameLength);
    RtlCopyMemory((PCHAR) input + input->DeviceNameOffset, volumeName.Buffer,
                  input->DeviceNameLength);
    ((PWSTR) ((PCHAR) input + input->DeviceNameOffset))[1] = '?';

    RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, input);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_CREATE_POINT, input, inputLength,
                        NULL, 0, &bytes, NULL);

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, input);

    return b;
}

VOID
NotifyMountMgr(
    LPCWSTR lpszVolumeMountPoint,
    LPCWSTR lpszVolumeName,
    BOOL IsPointCreated
    )

/*++

Routine Description:

    This routine notifies the mount mgr that a volume mount point was
    created or deleted so that the mount mgr can update the remote database on
    the volume where the mount point was created or deleted.

Arguments:

    lpszVolumeMountPoint    - Supplies the directory where the volume mount
                                point resides.

    lpszVolumeName          - Supplies the volume name.

    IsPointCreated          - Supplies wheter or not the point was created or
                                deleted.

Return Value:

    None.

--*/

{
    UNICODE_STRING                  unicodeSourceVolumeName;
    UNICODE_STRING                  unicodeTargetVolumeName;
    DWORD                           inputSize;
    PMOUNTMGR_VOLUME_MOUNT_POINT    input;
    HANDLE                          h;
    DWORD                           ioControl, bytes;

    if (!RtlDosPathNameToNtPathName_U(lpszVolumeMountPoint,
                                      &unicodeSourceVolumeName, NULL, NULL)) {

        return;
    }

    RtlInitUnicodeString(&unicodeTargetVolumeName, lpszVolumeName);
    unicodeSourceVolumeName.Length -= sizeof(WCHAR);
    unicodeTargetVolumeName.Length -= sizeof(WCHAR);

    inputSize = sizeof(MOUNTMGR_VOLUME_MOUNT_POINT) +
                unicodeSourceVolumeName.Length +
                unicodeTargetVolumeName.Length;
    input = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), inputSize);
    if (!input) {
        RtlFreeHeap(RtlProcessHeap(), 0, unicodeSourceVolumeName.Buffer);
        return;
    }

    input->SourceVolumeNameOffset = sizeof(MOUNTMGR_VOLUME_MOUNT_POINT);
    input->SourceVolumeNameLength = unicodeSourceVolumeName.Length;
    input->TargetVolumeNameOffset = input->SourceVolumeNameOffset +
                                    input->SourceVolumeNameLength;
    input->TargetVolumeNameLength = unicodeTargetVolumeName.Length;

    RtlCopyMemory((PCHAR) input + input->SourceVolumeNameOffset,
                  unicodeSourceVolumeName.Buffer,
                  input->SourceVolumeNameLength);

    RtlCopyMemory((PCHAR) input + input->TargetVolumeNameOffset,
                  unicodeTargetVolumeName.Buffer,
                  input->TargetVolumeNameLength);

    ((PWSTR) ((PCHAR) input + input->TargetVolumeNameOffset))[1] = '?';

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, input);
        RtlFreeHeap(RtlProcessHeap(), 0, unicodeSourceVolumeName.Buffer);
        return;
    }

    if (IsPointCreated) {
        ioControl = IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED;
    } else {
        ioControl = IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED;
    }

    DeviceIoControl(h, ioControl, input, inputSize, NULL, 0, &bytes, NULL);

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, input);
    RtlFreeHeap(RtlProcessHeap(), 0, unicodeSourceVolumeName.Buffer);
}

BOOL
WINAPI
SetVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPCWSTR lpszVolumeName
    )

/*++

Routine Description:

    This routine sets a mount point on the given directory pointed to by
    'VolumeMountPoint' which points to the volume given by 'VolumeName'.
    In the case when 'VolumeMountPoint' is of the form "D:\", the drive
    letter for the given volume is set to 'D:'.

Arguments:

    lpszVolumeMountPoint    - Supplies the directory where the volume mount
                                point will reside.

    lpszVolumeName          - Supplies the volume name.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING          unicodeVolumeMountPoint;
    UNICODE_STRING          unicodeVolumeName;
    BOOLEAN                 isVolume;
    BOOL                    b;
    WCHAR                   volumeMountPointVolumePrefix[MAX_PATH];
    HANDLE                  h;
    PREPARSE_DATA_BUFFER    reparse;
    DWORD                   bytes;

    if (GetVolumeNameForVolumeMountPointW(lpszVolumeMountPoint,
                                          volumeMountPointVolumePrefix,
                                          MAX_PATH) ||
        GetLastError() == ERROR_FILENAME_EXCED_RANGE) {

        SetLastError(ERROR_DIR_NOT_EMPTY);
        return FALSE;
    }

    RtlInitUnicodeString(&unicodeVolumeMountPoint, lpszVolumeMountPoint);
    RtlInitUnicodeString(&unicodeVolumeName, lpszVolumeName);

    if (unicodeVolumeMountPoint.Length == 0 ||
        unicodeVolumeName.Length == 0) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (unicodeVolumeMountPoint.Buffer[
        unicodeVolumeMountPoint.Length/sizeof(WCHAR) - 1] != '\\' ||
        unicodeVolumeName.Buffer[
        unicodeVolumeName.Length/sizeof(WCHAR) - 1] != '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
    }

    if (!MOUNTMGR_IS_DOS_VOLUME_NAME_WB(&unicodeVolumeName)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!IsThisAVolumeName(lpszVolumeName, &isVolume)) {
        return FALSE;
    }
    if (!isVolume) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (unicodeVolumeMountPoint.Length == 6 &&
        unicodeVolumeMountPoint.Buffer[1] == ':') {

        return SetVolumeNameForRoot(lpszVolumeMountPoint, lpszVolumeName);
    }

    if (unicodeVolumeMountPoint.Length == 14 &&
        unicodeVolumeMountPoint.Buffer[0] == '\\' &&
        unicodeVolumeMountPoint.Buffer[1] == '\\' &&
        (unicodeVolumeMountPoint.Buffer[2] == '.' ||
         unicodeVolumeMountPoint.Buffer[2] == '?') &&
        unicodeVolumeMountPoint.Buffer[3] == '\\' &&
        unicodeVolumeMountPoint.Buffer[5] == ':') {

        return SetVolumeNameForRoot(lpszVolumeMountPoint + 4, lpszVolumeName);
    }

    if (GetDriveTypeW(lpszVolumeMountPoint) != DRIVE_FIXED) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    CloseHandle(h);

    h = CreateFileW(lpszVolumeMountPoint, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OPEN_REPARSE_POINT |
                    FILE_FLAG_BACKUP_SEMANTICS, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                              MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    reparse->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    reparse->ReparseDataLength = (USHORT) (FIELD_OFFSET(REPARSE_DATA_BUFFER,
                                              MountPointReparseBuffer.PathBuffer) -
                                 REPARSE_DATA_BUFFER_HEADER_SIZE +
                                 unicodeVolumeName.Length + 2*sizeof(WCHAR));
    reparse->Reserved = 0;
    reparse->MountPointReparseBuffer.SubstituteNameOffset = 0;
    reparse->MountPointReparseBuffer.SubstituteNameLength = unicodeVolumeName.Length;
    reparse->MountPointReparseBuffer.PrintNameOffset =
            reparse->MountPointReparseBuffer.SubstituteNameLength +
            sizeof(WCHAR);
    reparse->MountPointReparseBuffer.PrintNameLength = 0;

    CopyMemory(reparse->MountPointReparseBuffer.PathBuffer,
               unicodeVolumeName.Buffer,
               reparse->MountPointReparseBuffer.SubstituteNameLength);

    reparse->MountPointReparseBuffer.PathBuffer[1] = '?';
    reparse->MountPointReparseBuffer.PathBuffer[
            unicodeVolumeName.Length/sizeof(WCHAR)] = 0;
    reparse->MountPointReparseBuffer.PathBuffer[
            unicodeVolumeName.Length/sizeof(WCHAR) + 1] = 0;

    b = DeviceIoControl(h, FSCTL_SET_REPARSE_POINT, reparse,
                        REPARSE_DATA_BUFFER_HEADER_SIZE +
                        reparse->ReparseDataLength, NULL, 0, &bytes, NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, reparse);
    CloseHandle(h);

    if (b) {
        NotifyMountMgr(lpszVolumeMountPoint, lpszVolumeName, TRUE);
    }

    return b;
}

BOOL
WINAPI
DeleteVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint
    )

{
    PUNICODE_STRING unicodeVolumeMountPoint;
    BOOL            b;

    unicodeVolumeMountPoint = Basep8BitStringToStaticUnicodeString(
                              lpszVolumeMountPoint);
    if (!unicodeVolumeMountPoint) {
        return FALSE;
    }

    b = DeleteVolumeMountPointW(unicodeVolumeMountPoint->Buffer);

    return b;
}

BOOL
DeleteVolumeNameForRoot(
    LPCWSTR DeviceName
    )

/*++

Routine Description:

    This routine deletes the given DOS device name.

Arguments:

    DeviceName  - Supplies a DOS device name terminated by a '\'.

Return Value:

    FALSE   - Failure.  The error code is returned in GetLastError().

    TRUE    - Success.

--*/

{
    UNICODE_STRING          devicePath;
    DWORD                   inputLength;
    PMOUNTMGR_MOUNT_POINT   input;
    DWORD                   outputLength;
    PMOUNTMGR_MOUNT_POINTS  output;
    HANDLE                  h;
    BOOL                    b;
    DWORD                   bytes;

    devicePath.Length = 28;
    devicePath.MaximumLength = devicePath.Length + sizeof(WCHAR);
    devicePath.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                        devicePath.MaximumLength);
    if (!devicePath.Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    RtlCopyMemory(devicePath.Buffer, L"\\DosDevices\\", 24);

    devicePath.Buffer[12] = (WCHAR)toupper(DeviceName[0]);
    devicePath.Buffer[13] = ':';
    devicePath.Buffer[14] = 0;

    inputLength = sizeof(MOUNTMGR_MOUNT_POINT) + devicePath.Length;
    input = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), inputLength);
    if (!input) {
        RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlZeroMemory(input, sizeof(MOUNTMGR_MOUNT_POINT));
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input->SymbolicLinkNameLength = devicePath.Length;
    RtlCopyMemory((PCHAR) input + input->SymbolicLinkNameOffset,
                  devicePath.Buffer, input->SymbolicLinkNameLength);

    RtlFreeHeap(RtlProcessHeap(), 0, devicePath.Buffer);

    outputLength = sizeof(MOUNTMGR_MOUNT_POINTS) + 3*MAX_PATH*sizeof(WCHAR);
    output = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                             outputLength);
    if (!output) {
        RtlFreeHeap(RtlProcessHeap(), 0, input);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, output);
        RtlFreeHeap(RtlProcessHeap(), 0, input);
        return FALSE;
    }

    b = DeviceIoControl(h, IOCTL_MOUNTMGR_DELETE_POINTS, input, inputLength,
                        output, outputLength, &bytes, NULL);

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, output);
    RtlFreeHeap(RtlProcessHeap(), 0, input);

    return b;
}

BOOL
WINAPI
DeleteVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint
    )

/*++

Routine Description:

    This routine removes the NTFS junction point from the given directory
    or remove the drive letter symbolic link pointing to the given volume.

Arguments:

    lpszVolumeMountPoint    - Supplies the volume mount piont.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING          unicodeVolumeMountPoint;
    HANDLE                  h;
    PREPARSE_DATA_BUFFER    reparse;
    BOOL                    b;
    DWORD                   bytes;
    UNICODE_STRING          substituteName;

    RtlInitUnicodeString(&unicodeVolumeMountPoint, lpszVolumeMountPoint);

    if (unicodeVolumeMountPoint.Buffer[
        unicodeVolumeMountPoint.Length/sizeof(WCHAR) - 1] != '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
    }

    if (unicodeVolumeMountPoint.Length == 6 &&
        unicodeVolumeMountPoint.Buffer[1] == ':') {

        return DeleteVolumeNameForRoot(lpszVolumeMountPoint);
    }

    if (unicodeVolumeMountPoint.Length == 14 &&
        unicodeVolumeMountPoint.Buffer[0] == '\\' &&
        unicodeVolumeMountPoint.Buffer[1] == '\\' &&
        (unicodeVolumeMountPoint.Buffer[2] == '.' ||
         unicodeVolumeMountPoint.Buffer[2] == '?') &&
        unicodeVolumeMountPoint.Buffer[3] == '\\' &&
        unicodeVolumeMountPoint.Buffer[5] == ':') {

        return DeleteVolumeNameForRoot(lpszVolumeMountPoint + 4);
    }

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    CloseHandle(h);

    h = CreateFileW(lpszVolumeMountPoint, GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                    FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                    INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                              MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    b = DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                        MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &bytes, NULL);

    if (!b || reparse->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {
        RtlFreeHeap(RtlProcessHeap(), 0, reparse);
        CloseHandle(h);
        return FALSE;
    }

    substituteName.MaximumLength = substituteName.Length =
            reparse->MountPointReparseBuffer.SubstituteNameLength;
    substituteName.Buffer = (PWSTR)
            ((PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
             reparse->MountPointReparseBuffer.SubstituteNameOffset);

    if (!MOUNTMGR_IS_NT_VOLUME_NAME_WB(&substituteName)) {
        RtlFreeHeap(RtlProcessHeap(), 0, reparse);
        CloseHandle(h);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    reparse->ReparseDataLength = 0;

    b = DeviceIoControl(h, FSCTL_DELETE_REPARSE_POINT, reparse,
                        REPARSE_DATA_BUFFER_HEADER_SIZE, NULL, 0, &bytes,
                        NULL);

    CloseHandle(h);

    if (b) {
        substituteName.Buffer[1] = '\\';
        substituteName.Buffer[substituteName.Length/sizeof(WCHAR)] = 0;
        NotifyMountMgr(lpszVolumeMountPoint, substituteName.Buffer,
                       FALSE);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, reparse);

    return b;
}

BOOL
WINAPI
GetVolumePathNameA(
    LPCSTR lpszFileName,
    LPSTR lpszVolumePathName,
    DWORD cchBufferLength
    )

{
    PUNICODE_STRING unicodeFileName;
    ANSI_STRING     ansiVolumePathName;
    UNICODE_STRING  unicodeVolumePathName;
    BOOL            b;
    NTSTATUS        status;

    unicodeFileName = Basep8BitStringToStaticUnicodeString(lpszFileName);
    if (!unicodeFileName) {
        return FALSE;
    }

    ansiVolumePathName.Buffer = lpszVolumePathName;
    ansiVolumePathName.MaximumLength = (USHORT) (cchBufferLength - 1);
    unicodeVolumePathName.Buffer = NULL;
    unicodeVolumePathName.MaximumLength = 0;

    try {

        unicodeVolumePathName.MaximumLength =
                (ansiVolumePathName.MaximumLength + 1)*sizeof(WCHAR);
        unicodeVolumePathName.Buffer =
                RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                unicodeVolumePathName.MaximumLength);
        if (!unicodeVolumePathName.Buffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            leave;
        }

        b = GetVolumePathNameW(unicodeFileName->Buffer,
                               unicodeVolumePathName.Buffer,
                               cchBufferLength);

        if (b) {

            RtlInitUnicodeString(&unicodeVolumePathName,
                                 unicodeVolumePathName.Buffer);

            status = BasepUnicodeStringTo8BitString(&ansiVolumePathName,
                                                    &unicodeVolumePathName,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                b = FALSE;
                leave;
            }

            ansiVolumePathName.Buffer[ansiVolumePathName.Length] = 0;
        }

    } finally {

        if (unicodeVolumePathName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumePathName.Buffer);
        }
    }

    return b;
}

BOOL
WINAPI
GetVolumePathNameW(
    LPCWSTR lpszFileName,
    LPWSTR lpszVolumePathName,
    DWORD cchBufferLength
    )

/*++

Routine Description:

    This routine will return a full path whose prefix is the longest prefix
    that represents a volume.

Arguments:

    lpszFileName        - Supplies the file name.

    lpszVolumePathName  - Returns the volume path name.

    cchBufferLength     - Supplies the volume path name buffer length.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    DWORD           fullPathLength;
    PWSTR           fullPath, p;
    WCHAR           c;
    UNICODE_STRING  name, dosName, prefix;
    BOOL            b, resultOfOpen;
    PWSTR           volumeName;
    DWORD           i;
    WCHAR           driveLetterPath[10];

    fullPathLength = GetFullPathNameW(lpszFileName, 0, NULL, NULL);
    if (!fullPathLength) {
        return FALSE;
    }
    fullPathLength += 10;

    fullPath = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                               fullPathLength*sizeof(WCHAR));
    if (!fullPath) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (!GetFullPathNameW(lpszFileName, fullPathLength, fullPath, &p)) {
        RtlFreeHeap(RtlProcessHeap(), 0, fullPath);
        return FALSE;
    }

    RtlInitUnicodeString(&name, fullPath);

    //
    // Append a trailing backslash to start the search.
    //

    if (name.Buffer[(name.Length/sizeof(WCHAR)) - 1] != '\\') {
        name.Length += sizeof(WCHAR);
        name.Buffer[(name.Length/sizeof(WCHAR)) - 1] = '\\';
        name.Buffer[name.Length/sizeof(WCHAR)] = 0;
    }

    volumeName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!volumeName) {
        RtlFreeHeap(RtlProcessHeap(), 0, fullPath);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    p = NULL;
    c = 0;

    for (;;) {

        b = BasepGetVolumeNameForVolumeMountPoint(
                name.Buffer, volumeName, MAXIMUM_REPARSE_DATA_BUFFER_SIZE/
                sizeof(WCHAR), &resultOfOpen);
        if (b) {
            break;
        }

        if (!resultOfOpen && GetLastError() == ERROR_ACCESS_DENIED) {
            resultOfOpen = TRUE;
        }

        if (*volumeName) {
            if (fullPath[0] == '\\' && fullPath[1] == '\\') {
                goto DontDoJunctionRecursionOverNetwork;
            }

            if (fullPath[1] == ':') {
                driveLetterPath[0] = fullPath[0];
                driveLetterPath[1] = ':';
                driveLetterPath[2] = '\\';
                driveLetterPath[3] = 0;
                if (GetDriveType((LPCSTR) driveLetterPath) == DRIVE_REMOTE) {
                    goto DontDoJunctionRecursionOverNetwork;
                }
            }

            RtlFreeHeap(RtlProcessHeap(), 0, fullPath);

            if (volumeName[0] == '\\' && volumeName[1] == '?' &&
                volumeName[2] == '?' && volumeName[3] == '\\') {

                if (volumeName[4] && volumeName[5] == ':') {
                    RtlInitUnicodeString(&name, volumeName);
                    MoveMemory(volumeName, volumeName + 4,
                               name.Length - 3*sizeof(WCHAR));
                } else {
                    volumeName[1] = '\\';
                }

                b = GetVolumePathNameW(volumeName, lpszVolumePathName,
                                       cchBufferLength);

            } else {

                RtlInitUnicodeString(&name, volumeName);
                RtlInitUnicodeString(&prefix, L"\\\\?\\GLOBALROOT");
                dosName.Length = name.Length + prefix.Length;
                dosName.MaximumLength = dosName.Length + sizeof(WCHAR);
                dosName.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                                 MAKE_TAG(TMP_TAG),
                                                 dosName.MaximumLength);
                if (!dosName.Buffer) {
                    RtlFreeHeap(RtlProcessHeap(), 0, volumeName);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }

                CopyMemory(dosName.Buffer, prefix.Buffer, prefix.Length);
                CopyMemory((PCHAR) dosName.Buffer + prefix.Length,
                           name.Buffer, name.Length);
                dosName.Buffer[dosName.Length/sizeof(WCHAR)] = 0;

                b = GetVolumePathNameW(dosName.Buffer, lpszVolumePathName,
                                       cchBufferLength);

                RtlFreeHeap(RtlProcessHeap(), 0, dosName.Buffer);
            }

            RtlFreeHeap(RtlProcessHeap(), 0, volumeName);

            return b;
        }

DontDoJunctionRecursionOverNetwork:

        if (!resultOfOpen && p) {
            *p = c;
            RtlInitUnicodeString(&name, fullPath);
            break;
        }

        if (name.Length <= sizeof(WCHAR)) {
            break;
        }

        for (i = name.Length/sizeof(WCHAR) - 2; i > 0; i--) {
            if (name.Buffer[i] == '\\') {
                break;
            }
        }
        if (!i) {
            break;
        }

        if (resultOfOpen) {
            p = &name.Buffer[i + 1];
            c = *p;
            *p = 0;
        } else {
            name.Buffer[i + 1] = 0;
        }

        RtlInitUnicodeString(&name, fullPath);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, volumeName);

    if (!resultOfOpen && !p) {
        RtlFreeHeap(RtlProcessHeap(), 0, fullPath);
        return FALSE;
    }

    if (cchBufferLength*sizeof(WCHAR) < name.Length + sizeof(WCHAR)) {
        RtlFreeHeap(RtlProcessHeap(), 0, fullPath);
        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        return FALSE;
    }

    RtlCopyMemory(lpszVolumePathName, name.Buffer, name.Length);
    lpszVolumePathName[name.Length/sizeof(WCHAR)] = 0;
    RtlFreeHeap(RtlProcessHeap(), 0, fullPath);

    return TRUE;
}

BOOL
GetVolumePathNamesForVolumeNameA(
    LPCSTR lpszVolumeName,
    LPSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    )

{
    PUNICODE_STRING unicodeVolumeName;
    ANSI_STRING     ansiVolumePathNames;
    UNICODE_STRING  unicodeVolumePathNames;
    BOOL            b;
    NTSTATUS        status;
    DWORD           len;

    unicodeVolumeName = Basep8BitStringToStaticUnicodeString(lpszVolumeName);
    if (!unicodeVolumeName) {
        return FALSE;
    }

    ansiVolumePathNames.Buffer = lpszVolumePathNames;
    ansiVolumePathNames.MaximumLength = (USHORT) cchBufferLength;
    unicodeVolumePathNames.Buffer = NULL;
    unicodeVolumePathNames.MaximumLength = 0;

    try {

        unicodeVolumePathNames.MaximumLength =
                ansiVolumePathNames.MaximumLength*sizeof(WCHAR);
        if (unicodeVolumePathNames.MaximumLength) {
            unicodeVolumePathNames.Buffer =
                    RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                    unicodeVolumePathNames.MaximumLength);
            if (!unicodeVolumePathNames.Buffer) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                b = FALSE;
                leave;
            }
        } else {
            unicodeVolumePathNames.Buffer = NULL;
        }

        b = GetVolumePathNamesForVolumeNameW(unicodeVolumeName->Buffer,
                                             unicodeVolumePathNames.Buffer,
                                             cchBufferLength, &len);

        if (b || GetLastError() == ERROR_MORE_DATA) {

            if (b) {
                unicodeVolumePathNames.Length = (USHORT) len*sizeof(WCHAR);
            } else {
                unicodeVolumePathNames.Length = (USHORT)
                        cchBufferLength*sizeof(WCHAR);
            }

            status = BasepUnicodeStringTo8BitString(&ansiVolumePathNames,
                                                    &unicodeVolumePathNames,
                                                    FALSE);
            if (!NT_SUCCESS(status)) {
                BaseSetLastNTError(status);
                b = FALSE;
                leave;
            }

            if (lpcchReturnLength) {
                if (b) {
                    *lpcchReturnLength = ansiVolumePathNames.Length;
                } else {
                    // Give an upper bound for the ANSI length since we
                    // don't actually know it.
                    *lpcchReturnLength = 2*len;
                }
            }
        }

    } finally {

        if (unicodeVolumePathNames.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, unicodeVolumePathNames.Buffer);
        }
    }

    return b;
}

BOOL
GetVolumePathNamesForVolumeNameW(
    LPCWSTR lpszVolumeName,
    LPWSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    )

/*++

Routine Description:

    This routine returns a Multi-Sz list of volume path names for the
    given volume name.  The returned 'lpcchReturnLength' will include the
    extra tailing null characteristic of a Multi-Sz unless ERROR_MORE_DATA
    is returned in which case the list returned is as long as possible
    and may contain a part of a volume path.

Arguments:

    lpszVolumeName      - Supplies the volume name.

    lpszVolumePathNames - Returns the volume path names.

    cchBufferLength     - Supplies the size of the return buffer.

    lpcchReturnLength   - Returns the number of characters copied back to the
                            return buffer on success or the total number
                            of characters necessary for the buffer on
                            ERROR_MORE_DATA.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    UNICODE_STRING          unicodeVolumeName;
    PMOUNTMGR_TARGET_NAME   targetName;
    HANDLE                  h;
    BOOL                    b;
    DWORD                   bytes, len, i, j, n;
    PMOUNTMGR_VOLUME_PATHS  volumePaths;

    RtlInitUnicodeString(&unicodeVolumeName, lpszVolumeName);
    if (unicodeVolumeName.Buffer[unicodeVolumeName.Length/sizeof(WCHAR) - 1] !=
        '\\') {

        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
    }

    if (!MOUNTMGR_IS_DOS_VOLUME_NAME_WB(&unicodeVolumeName)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    targetName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                 MAX_PATH*sizeof(WCHAR));
    if (!targetName) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    ZeroMemory(targetName, MAX_PATH*sizeof(WCHAR));
    targetName->DeviceNameLength = unicodeVolumeName.Length - sizeof(WCHAR);
    RtlCopyMemory(targetName->DeviceName, lpszVolumeName,
                  targetName->DeviceNameLength);
    targetName->DeviceName[1] = '?';

    h = CreateFileW(MOUNTMGR_DOS_DEVICE_NAME, 0, FILE_SHARE_READ |
                    FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        RtlFreeHeap(RtlProcessHeap(), 0, targetName);
        return FALSE;
    }

    len = sizeof(MOUNTMGR_VOLUME_PATHS);
    volumePaths = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), len);
    if (!volumePaths) {
        CloseHandle(h);
        RtlFreeHeap(RtlProcessHeap(), 0, targetName);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    for (;;) {

        b = DeviceIoControl(h, IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS,
                            targetName, MAX_PATH*sizeof(WCHAR), volumePaths,
                            len, &bytes, NULL);
        if (b) {
            break;
        }

        if (GetLastError() != ERROR_MORE_DATA) {
            RtlFreeHeap(RtlProcessHeap(), 0, volumePaths);
            RtlFreeHeap(RtlProcessHeap(), 0, targetName);
            return FALSE;
        }

        len = sizeof(MOUNTMGR_VOLUME_PATHS) + volumePaths->MultiSzLength;
        RtlFreeHeap(RtlProcessHeap(), 0, volumePaths);
        volumePaths = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                      len);
        if (!volumePaths) {
            CloseHandle(h);
            RtlFreeHeap(RtlProcessHeap(), 0, targetName);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    CloseHandle(h);
    RtlFreeHeap(RtlProcessHeap(), 0, targetName);

    n = 0;
    for (i = 0, j = 0; i < cchBufferLength &&
         j < volumePaths->MultiSzLength/sizeof(WCHAR) - 1; i++, j++) {

        if (!volumePaths->MultiSz[j]) {
            n++;
            lpszVolumePathNames[i++] = '\\';
            if (i == cchBufferLength) {
                break;
            }
        }

        lpszVolumePathNames[i] = volumePaths->MultiSz[j];
    }

    for (; j < volumePaths->MultiSzLength/sizeof(WCHAR) - 1; j++) {
        if (!volumePaths->MultiSz[j]) {
            n++;
        }
    }

    if (i < cchBufferLength) {
        b = TRUE;
        lpszVolumePathNames[i++] = 0;
        if (lpcchReturnLength) {
            *lpcchReturnLength = i;
        }
    } else {
        b = FALSE;
        SetLastError(ERROR_MORE_DATA);
        if (lpcchReturnLength) {
            *lpcchReturnLength = volumePaths->MultiSzLength/sizeof(WCHAR) + n;
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, volumePaths);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\w98stubs.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:


Abstract:

    Stubs for Win98 api's.  Actual implementation is unimportant
    since the functions are only used to generate the implib.

Author:

    Bryan Tuttle (bryant) 5-Aug-1998

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

DWORD
GetHandleContext(HANDLE handle)
{
    KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, "Unsupported API - kernel32!GetHandleContext() called\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL
SetHandleContext(HANDLE handle, DWORD context)
{
    KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, "Unsupported API - kernel32!SetHandleContext() called\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

HANDLE
CreateSocketHandle(void)
{
    KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL, "Unsupported API - kernel32!CreateSocketHandle() called\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\webblade.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    webblade.c

Abstract:

    This module contains the main routine and 
    helper routines to enforce software restrictions 
    for the Web Blade SKU.
    
    exe's whose hash values test positive w.r.t 
    the hardcoded hash array in webblade.h will
    be disallowed from executing.

Author:

    Vishnu Patankar (VishnuP) 01-May-2001

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include "webbladep.h"
#include "webbladehashesp.h"

#define WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, HexNibbleMask)  ((bLeastSignificantNibble) ? (HexNibbleMask) : ((HexNibbleMask) << 4))

BYTE    WebBladeDisallowedHashes[][WEB_BLADE_MAX_HASH_SIZE*2+1] = {
    WEBBLADE_SORTED_ASCENDING_HASHES
    };

#define WEB_BLADE_NUM_HASHES sizeof(WebBladeDisallowedHashes)/(WEB_BLADE_MAX_HASH_SIZE * 2 + 1)

NTSTATUS
BasepCheckWebBladeHashes(
        IN HANDLE hFile
        )
/*++

Routine Description:

    This routine computes the web blade hash for the candidate file
    and checks for membership in the hardcoded WebBladeDisallowedHashes[].

    If the hash is present, the code should not be allowed to execute.
    
Arguments:

    hFile - the file handle of the exe file to check for allow/disallow.

Return Value:

    NTSTATUS - if disallowed, this is STATUS_ACCESS_DENIED else 
               it is the internal status of other APIs

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    BYTE        FileHashValue[WEB_BLADE_MAX_HASH_SIZE];
    DWORD       dwIndex;
    
    static BOOL bConvertReadableHashToByteHash = TRUE;
    
    // 
    // Optimization: Half of the same array is used since the CHARs can 
    // be compressed 2:1 into actual hash'ish BYTES (e.g. two readable 
    // CHARS "0E" is actually one BYTE 00001110) i.e. each 32 CHAR hash 
    // becomes a 16 BYTE hash
    //
    
    if (bConvertReadableHashToByteHash) {
        
        for (dwIndex = 0; 
            dwIndex < WEB_BLADE_NUM_HASHES;
            dwIndex++) {

            Status = WebBladepConvertStringizedHashToHash( WebBladeDisallowedHashes[dwIndex] );

            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
        }

        //
        // This conversion should be done only once per process (otherwise we 
        // would be doing a fixed point computation)
        //

        
        bConvertReadableHashToByteHash = FALSE;
    }

    //
    // Compute the limited hash 
    //

#define ITH_REVISION_1  1

    Status = RtlComputeImportTableHash( hFile, FileHashValue, ITH_REVISION_1 );

    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    //
    // Check for membership of the computed hash in the sorted disallowed hash array
    // Use binary search for O (log n) complexity
    //

    if ( bsearch (FileHashValue,
                  WebBladeDisallowedHashes,                      
                  WEB_BLADE_NUM_HASHES,                      
                  WEB_BLADE_MAX_HASH_SIZE * 2 + 1,                     
                  pfnWebBladeHashCompare
                 )) {

        //
        // FileHashValue tested positive for membership in WebBladeDisallowedHashes[][]
        //

        Status = STATUS_ACCESS_DENIED;

    }

ExitHandler:

    return Status;
}

int
__cdecl pfnWebBladeHashCompare(
    const BYTE    *WebBladeFirstHash,
    const BYTE    *WebBladeSecondHash
    )
/*++

Routine Description:

    This routine byte-lexically compares two WebBladeHashes.
    Essentially, it wraps memcmp.

Arguments:

    WebBladeHashFirst - the first web blade hash
    
    WebBladeHashSecond - the second web blade hash

Return Value:

    0 if equal, 
    -ve if WebBladeHashFirst < WebBladeHashSecond
    +ve if WebBladeHashFirst > WebBladeHashSecond

--*/
{

    return memcmp(WebBladeFirstHash, WebBladeSecondHash, WEB_BLADE_MAX_HASH_SIZE);

}

NTSTATUS WebBladepConvertStringizedHashToHash(                   
    IN OUT   PCHAR    pStringizedHash                   
    )
/*++

Routine Description:

    This routine converts a readable 32 CHAR hash into a 16 BYTE hash.
    As an optimization, the conversion is done in-place.
    
    Optimization: Half of the same array is used since the CHARs can 
    be compressed 2:1 into actual hash'ish BYTES (e.g. two readable 
    CHARS "0E" is actually one BYTE 00001110) i.e. each 32 CHAR hash 
    becomes a 16 BYTE hash
    
    One byte is assembled by looking at two characters.    

Arguments:

    pStringizedHash - Pointer to the beginning of a 32 CHAR (in) 16 BYTE (out) hash.

Return Value:
    
    STATUS_SUCCESS if the hash value was computed, else the error in 
    hash computation (if any)

--*/
{

    DWORD   dwHashIndex = 0;
    DWORD   dwStringIndex = 0;
    BYTE    OneByte = 0;
    BOOL    bLeastSignificantNibble = FALSE;
    NTSTATUS   Status = STATUS_SUCCESS;
    
    if (pStringizedHash == NULL) {

        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    
    }

    for (dwStringIndex=0; dwStringIndex < WEB_BLADE_MAX_HASH_SIZE * 2; dwStringIndex++ ) {

        switch (pStringizedHash[dwStringIndex]) {
        case '0': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x0);
            break;
        case '1': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x1);
            break;
        case '2': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x2);
            break;
        case '3': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x3);
            break;
        case '4': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x4);
            break;
        case '5': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x5);
            break;
        case '6': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x6);
            break;
        case '7': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x7);
            break;
        case '8': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x8);
            break;
        case '9': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0x9);
            break;
        case 'a': 
        case 'A': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0xa);
            break;
        case 'b': 
        case 'B': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0xb);
            break;
        case 'c': 
        case 'C': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0xc);
            break;
        case 'd': 
        case 'D': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0xd);
            break;
        case 'e': 
        case 'E': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0xe);
            break;
        case 'f': 
        case 'F': 
            OneByte |= WEB_BLADEP_EXTRACT_NIBBLE(bLeastSignificantNibble, 0xf);
            break;
        default:
            ASSERT(FALSE);
            Status = STATUS_INVALID_PARAMETER;
            goto ExitHandler;
        }

        if (bLeastSignificantNibble) {
            pStringizedHash[dwHashIndex++] = OneByte;
            OneByte = 0;
        }
        
        bLeastSignificantNibble = !bLeastSignificantNibble;    
    }


ExitHandler:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\webbladehashesp.h ===
#define WEBBLADE_SORTED_ASCENDING_HASHES \
"100E21B73D12F2DDB6BB420D86312EFB",\
"114F67521EF3029779B668EF5C6D0ECB",\
"23958380A336D0C78DCC91766D4A31F9",\
"2423E477380AA5DBF7CE4FAA7357BF5D",\
"2DE3A39E51AF953F5EB3E0C28E6B70AE",\
"32FBA2CDB93AC6D5910EA13AF9F74D3E",\
"3BEC6722FCA7D2A1369F01A7670601BD",\
"4C5E819BE7E2B6ABB993E15BA7ABA682",\
"4F5ABC32B7B68E4762CC46992FEF49B7",\
"52C16911A5499519E3FD354D4C4BBDC0",\
"55A3EF7DAEB4F671687F8313920671E2",\
"5ED7F6AC9C5CCEB9773988365864CD8F",\
"6C787A650FCA08849125E7B841BAAB1F",\
"730AABB58998E9A510C8DF36FB2FCCAE",\
"8362A288A04F0E78FDB3B495B4732A1A",\
"83FAB2996F9E11068508ACE100EF7678",\
"A187BE740C2FE93CF550CF74FED4A88B",\
"A4B7D648A4227C4D31D06CC4C11ED0E3",\
"A7306C0DF3336DC10476F24AA0A089C5",\
"E26417DF7AA56059894CA6F451D679DC"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\vdm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdm.c

Abstract:

    This module implements Win32 APIs for VDMs

Author:

    Sudeepb Bharati (sudeepb) 04-Sep-1991

Revision History:

--*/

#include "basedll.h"
#include "apcompat.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#pragma hdrstop

BOOL
APIENTRY
GetBinaryTypeA(
    IN  LPCSTR   lpApplicationName,
    OUT LPDWORD  lpBinaryType
    )

/*++

Routine Description: ANSI version of GetBinaryTypeW.
    This API returns the binary type of lpApplicationName.

Arguments:
    lpApplicationName - Full pathname of the binary
    lpBinaryType - pointer where binary type will be returned.

Return Value:
    TRUE - if SUCCESS; lpBinaryType has following
                SCS_64BIT_BINARY    - Win64 Binary
                SCS_32BIT_BINARY    - Win32 Binary
                SCS_DOS_BINARY      - DOS Binary
                SCS_WOW_BINARY      - Windows 3.X Binary
                SCS_PIF_BINARY      - PIF file
                SCS_POSIX_BINARY    - POSIX Binary
                SCS_OS216_BINARY    - OS/2 Binary
    FALSE - if file not found or of unknown type. More info with GetLastError
--*/
{
    NTSTATUS Status;
    PUNICODE_STRING CommandLine;
    ANSI_STRING AnsiString;
    UNICODE_STRING DynamicCommandLine;
    BOOLEAN bReturn = FALSE;

    CommandLine = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpApplicationName);
    if ( (ULONG)AnsiString.Length<<1 < (ULONG)NtCurrentTeb()->StaticUnicodeString.MaximumLength ) {
        DynamicCommandLine.Buffer = NULL;
        Status = RtlAnsiStringToUnicodeString(CommandLine,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = RtlAnsiStringToUnicodeString(&DynamicCommandLine,&AnsiString,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }

    bReturn = (BOOLEAN)GetBinaryTypeW(
             DynamicCommandLine.Buffer ? DynamicCommandLine.Buffer : CommandLine->Buffer,
             lpBinaryType);

    RtlFreeUnicodeString(&DynamicCommandLine);

    return((BOOL)bReturn);

}


BOOL
WINAPI
GetBinaryTypeW(
    IN  LPCWSTR  lpApplicationName,
    OUT LPDWORD  lpBinaryType
    )

/*++

Routine Description: Unicode version.
    This API returns the binary type of lpApplicationName.

Arguments:
    lpApplicationName - Full pathname of the binary
    lpBinaryType - pointer where binary type will be returned.

Return Value:
    TRUE - if SUCCESS; lpBinaryType has following
                SCS_64BIT_BINARY    - Win64 Binary
                SCS_32BIT_BINARY    - Win32 Binary
                SCS_DOS_BINARY      - DOS Binary
                SCS_WOW_BINARY      - Windows 3.X Binary
                SCS_PIF_BINARY      - PIF file
                SCS_POSIX_BINARY    - POSIX Binary
                SCS_OS216_BINARY    - OS/2 Binary
    FALSE - if file not found or of unknown type. More info with GetLastError
--*/

{
    NTSTATUS Status;
    UNICODE_STRING PathName;
    RTL_RELATIVE_NAME_U RelativeName;
    BOOLEAN TranslationStatus;
    OBJECT_ATTRIBUTES Obja;
    PVOID FreeBuffer = NULL;
    HANDLE FileHandle, SectionHandle=NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    LONG fBinaryType = SCS_THIS_PLATFORM_BINARY;
    BOOLEAN bReturn = FALSE;
    SECTION_IMAGE_INFORMATION ImageInformation;


    try {
        //
        // Translate to an NT name.
        //

        TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                                // DynamicCommandLine.Buffer ? DynamicCommandLine.Buffer : CommandLine->Buffer,
                                lpApplicationName,
                                &PathName,
                                NULL,
                                &RelativeName
                                );

        if ( !TranslationStatus ) {
            BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
            goto GBTtryexit;
            }

        FreeBuffer = PathName.Buffer;

        if ( RelativeName.RelativeName.Length ) {
            PathName = RelativeName.RelativeName;
            }
        else {
            RelativeName.ContainingDirectory = NULL;
            }

        InitializeObjectAttributes(
            &Obja,
            &PathName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );

        //
        // Open the file for execute access
        //

        Status = NtOpenFile(
                    &FileHandle,
                    SYNCHRONIZE | FILE_EXECUTE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                    );

        RtlReleaseRelativeName(&RelativeName);

        if (!NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            goto GBTtryexit;
            }

        //
        // Create a section object backed by the file
        //

        Status = NtCreateSection(
                    &SectionHandle,
                    SECTION_ALL_ACCESS,
                    NULL,
                    NULL,
                    PAGE_EXECUTE,
                    SEC_IMAGE,
                    FileHandle
                    );
        NtClose(FileHandle);

        if (!NT_SUCCESS(Status) ) {

            SectionHandle = NULL;

            switch (Status) {
                case STATUS_INVALID_IMAGE_NE_FORMAT:
#if defined(i386) && defined(OS2_SUPPORT_ENABLED)
                    fBinaryType = SCS_OS216_BINARY;
                    break;
#endif

                case STATUS_INVALID_IMAGE_PROTECT:
                    fBinaryType = SCS_DOS_BINARY;
                    break;

                case STATUS_INVALID_IMAGE_WIN_16:
                    fBinaryType = SCS_WOW_BINARY;
                    break;

                case STATUS_INVALID_IMAGE_NOT_MZ:
                    fBinaryType = BaseIsDosApplication(&PathName, Status);
                    if (!fBinaryType){
                        BaseSetLastNTError(Status);
                        goto GBTtryexit;
                    }
                    fBinaryType = (fBinaryType  == BINARY_TYPE_DOS_PIF) ?
                                  SCS_PIF_BINARY : SCS_DOS_BINARY;
                    break;

                case STATUS_INVALID_IMAGE_WIN_32:
                    fBinaryType = SCS_32BIT_BINARY;
                    break;

                case STATUS_INVALID_IMAGE_WIN_64:
                    fBinaryType = SCS_64BIT_BINARY;
                    break;

                default:
                    BaseSetLastNTError(Status);
                    goto GBTtryexit;
                }
            }
        else {
            //
            // Query the section
            //

            Status = NtQuerySection(
                        SectionHandle,
                        SectionImageInformation,
                        &ImageInformation,
                        sizeof( ImageInformation ),
                        NULL
                        );

            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError(Status);
                goto GBTtryexit;
            }

            if (ImageInformation.ImageCharacteristics & IMAGE_FILE_DLL) {
                SetLastError(ERROR_BAD_EXE_FORMAT);
                goto GBTtryexit;
            }

            if (ImageInformation.Machine !=
                    RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress)->FileHeader.Machine) {

#ifdef MIPS
                if ( ImageInformation.Machine == IMAGE_FILE_MACHINE_R3000 ||
                     ImageInformation.Machine == IMAGE_FILE_MACHINE_R4000 ) {
                    ;
                }
                else {
                    SetLastError(ERROR_BAD_EXE_FORMAT);
                    goto GBTtryexit;
                }
#else
        switch ( ImageInformation.Machine ) {
        case IMAGE_FILE_MACHINE_I386:
          fBinaryType = SCS_32BIT_BINARY;
          break;

#if defined(BUILD_WOW6432)
        //
        // GetBinaryType (64-bit image) from an application running on win64
        // will fall to here since the 64-bit kernel allows creation of 32-bit/64-bit
        // image sections.
        //
        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AMD64:
            fBinaryType = SCS_64BIT_BINARY;
            break;
#endif

        default:
          SetLastError(ERROR_BAD_EXE_FORMAT);
          goto GBTtryexit;
        }
#endif // MIPS
            }
        else if ( ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_GUI &&
                ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_CUI ) {


                if ( ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_POSIX_CUI ) {
                    fBinaryType = SCS_POSIX_BINARY;
                }
            }


        }

        *lpBinaryType = fBinaryType;

        bReturn = TRUE;

GBTtryexit:;
        }
    finally {

        if (SectionHandle)
            NtClose(SectionHandle);

        if (FreeBuffer)
            RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
    return bReturn;
}


VOID
APIENTRY
VDMOperationStarted
(
    BOOL    IsWowCaller
    )

/*++

Routine Description:
    This routine is used by MVDM to tell base that it has hooked
    ctrl-c handler with console. If the cmd window is killed
    before VDM could hook ctrl-c, then we wont get a chance to
    cleanup our data structures. The absence of this call tells
    base that it has to clean up the resources next time a
    call is made to create a VDM.

Arguments:
    IsWowCaller - TRUE if the caller is WOWVDM

Return Value:

    None
--*/

{
    BaseUpdateVDMEntry(UPDATE_VDM_HOOKED_CTRLC,
                       NULL,
                       0,
                       IsWowCaller);
    return;
}


BOOL
APIENTRY
GetNextVDMCommand(
    PVDMINFO lpVDMInfo
    )

/*++

Routine Description:
    This routine is used by MVDM to get a new command to execute. The
    VDM is blocked untill a DOS/WOW binary is encountered.


Arguments:
    lpVDMInfo - pointer to VDMINFO where new DOS command and other
                enviornment information is returned.

    if lpVDMInfo is NULL, then the caller is
    asking whether its the first VDM in the system.

Return Value:

    TRUE - The operation was successful. lpVDMInfo is filled in.

    FALSE/NULL - The operation failed.

--*/

{

    NTSTATUS Status, Status2;
    BASE_API_MSG m;
    PBASE_GET_NEXT_VDM_COMMAND_MSG a = &m.u.GetNextVDMCommand;
    PBASE_EXIT_VDM_MSG c = &m.u.ExitVDM;
    PBASE_IS_FIRST_VDM_MSG d = &m.u.IsFirstVDM;
    PBASE_SET_REENTER_COUNT_MSG e = &m.u.SetReenterCount;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    ULONG Len,nPointers;
    USHORT VDMStateSave;

    if (lpVDMInfo->VDMState &
        (ASKING_FOR_WOWPROCLIST | ASKING_FOR_WOWTASKLIST | ASKING_TO_ADD_WOWTASK))
    {
        RtlZeroMemory(a,sizeof(BASE_GET_NEXT_VDM_COMMAND_MSG));
        a->iTask = lpVDMInfo->iTask;
        a->EnvLen = lpVDMInfo->EnviornmentSize;
        a->Reserved = lpVDMInfo->Reserved;
        a->VDMState = lpVDMInfo->VDMState;
        CaptureBuffer = NULL;

        if (lpVDMInfo->Enviornment) {
            Len= (lpVDMInfo->EnviornmentSize) ?
                     ROUND_UP(lpVDMInfo->EnviornmentSize, 4) : 4;
            CaptureBuffer = CsrAllocateCaptureBuffer(1, Len);
            if (CaptureBuffer == NULL) {
               BaseSetLastNTError( STATUS_NO_MEMORY );
               return FALSE;
               }
            CsrAllocateMessagePointer( CaptureBuffer,
                               lpVDMInfo->EnviornmentSize,
                               (PVOID *)&a->Env
                             );
            RtlMoveMemory(a->Env,
                          lpVDMInfo->Enviornment,
                          lpVDMInfo->EnviornmentSize);

            }
        Status = CsrClientCallServer(
                     (PCSR_API_MSG)&m,
                      CaptureBuffer,
                      CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                           BasepGetNextVDMCommand
                                         ),
                      sizeof( *a )
                      );
        if (NT_SUCCESS(Status)) {
            Status = (NTSTATUS)m.ReturnValue;
            }
        if(!NT_SUCCESS(Status)) {
           if(CaptureBuffer) {
              CsrFreeCaptureBuffer( CaptureBuffer );
              }
           BaseSetLastNTError(Status);
           return FALSE;
           }

        //
        // Copy back info from the server side
        //
        try{
           if (lpVDMInfo->Enviornment){
               RtlMoveMemory(lpVDMInfo->Enviornment,
                             a->Env,
                             lpVDMInfo->EnviornmentSize);
               }
            }
        except ( EXCEPTION_EXECUTE_HANDLER ) {
           BaseSetLastNTError(GetExceptionCode());
           CsrFreeCaptureBuffer( CaptureBuffer );
           return FALSE;
        }
        lpVDMInfo->iTask = a->iTask;
        lpVDMInfo->EnviornmentSize = a->EnvLen;


        if(CaptureBuffer) {
           CsrFreeCaptureBuffer( CaptureBuffer );
           }
        return TRUE;
        }

    // Special case to query the first VDM In the system.
    if(lpVDMInfo == NULL){
        Status = CsrClientCallServer(
                          (PCSR_API_MSG)&m,
                          NULL,
                          CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                              BasepIsFirstVDM
                                              ),
                          sizeof( *d )
                          );

        if (NT_SUCCESS(Status)) {
            return(d->FirstVDM);
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }

    // Special case to increment/decrement the re-enterancy count

    if (lpVDMInfo->VDMState == INCREMENT_REENTER_COUNT ||
        lpVDMInfo->VDMState == DECREMENT_REENTER_COUNT) {

        e->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;
        e->fIncDec = lpVDMInfo->VDMState;
        Status = CsrClientCallServer(
                        (PCSR_API_MSG)&m,
                        NULL,
                        CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                             BasepSetReenterCount
                                           ),
                        sizeof( *e )
                       );
        if (NT_SUCCESS(Status)) {
            return TRUE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
    }

    VDMStateSave = lpVDMInfo->VDMState;

    // console handle is always passed on in this case
    // wow is differentiated by a parameter a->VDMState
    // a->VDMState & ASKING_FOR_WOW_BINARY indicates wow

    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    if (lpVDMInfo->VDMState & ASKING_FOR_PIF) {
       a->iTask = lpVDMInfo->iTask;
    }
    else {
       a->iTask = 0;
    }

    a->AppLen = lpVDMInfo->AppLen;
    a->PifLen = lpVDMInfo->PifLen;
    a->CmdLen = lpVDMInfo->CmdSize;
    a->EnvLen = lpVDMInfo->EnviornmentSize;
    a->ExitCode = lpVDMInfo->ErrorCode;
    a->VDMState = VDMStateSave;
    a->WaitObjectForVDM = 0;
    a->DesktopLen = lpVDMInfo->DesktopLen;
    a->TitleLen = lpVDMInfo->TitleLen;
    a->ReservedLen = lpVDMInfo->ReservedLen;
    a->CurDirectoryLen = lpVDMInfo->CurDirectoryLen;

    // Find the total space for capture buffer

      // startup info
    Len = ROUND_UP(sizeof(STARTUPINFOA),4);
    nPointers = 1;

    if (lpVDMInfo->CmdSize) {
        Len += ROUND_UP(a->CmdLen,4);
        nPointers++;
        }

    if (lpVDMInfo->AppLen) {
        Len +=ROUND_UP(a->AppLen,4);
        nPointers++;
        }

    if (lpVDMInfo->PifLen) {
        Len +=ROUND_UP(a->PifLen,4);
        nPointers++;
        }

    if (lpVDMInfo->Enviornment) {
        nPointers++;
        Len+= (lpVDMInfo->EnviornmentSize) ?
                     ROUND_UP(lpVDMInfo->EnviornmentSize, 4) : 4;
        }

    if (lpVDMInfo->CurDirectoryLen == 0)
        a->CurDirectory = NULL;
    else{
        Len += ROUND_UP(lpVDMInfo->CurDirectoryLen,4);
        nPointers++;
        }

    if (lpVDMInfo->DesktopLen == 0)
        a->Desktop = NULL;
    else {
        Len += ROUND_UP(lpVDMInfo->DesktopLen,4);
        nPointers++;
        }

    if (lpVDMInfo->TitleLen == 0)
        a->Title = NULL;
    else {
        Len += ROUND_UP(lpVDMInfo->TitleLen,4);
        nPointers++;
        }

    if (lpVDMInfo->ReservedLen == 0)
        a->Reserved = NULL;
    else {
        Len += ROUND_UP(lpVDMInfo->ReservedLen,4);
        nPointers++;
        }

    CaptureBuffer = CsrAllocateCaptureBuffer(nPointers, Len);
    if (CaptureBuffer == NULL) {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return FALSE;
        }

    if (lpVDMInfo->CmdLine) {
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->CmdSize,
                                   (PVOID *)&a->CmdLine
                                 );
        }
    else {
        a->CmdLine = NULL;
        }


    if (lpVDMInfo->AppLen) {
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->AppLen,
                                   (PVOID *)&a->AppName
                                 );
        }
    else {
        a->AppName = NULL;
        }

    if (lpVDMInfo->PifLen) {
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->PifLen,
                                   (PVOID *)&a->PifFile
                                 );
        }
    else {
        a->PifFile = NULL;
        }


    if (lpVDMInfo->EnviornmentSize) {
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->EnviornmentSize,
                                   (PVOID *)&a->Env
                                 );
        }
    else {
        a->Env = NULL;
        }

    if (lpVDMInfo->CurDirectoryLen)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->CurDirectoryLen,
                                   (PVOID *)&a->CurDirectory
                                 );
    else
        a->CurDirectory = NULL;


    CsrAllocateMessagePointer( CaptureBuffer,
                               sizeof(STARTUPINFOA),
                               (PVOID *)&a->StartupInfo
                             );

    if (lpVDMInfo->DesktopLen)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->DesktopLen,
                                   (PVOID *)&a->Desktop
                                 );
    else
        a->Desktop = NULL;

    if (lpVDMInfo->TitleLen)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->TitleLen,
                                   (PVOID *)&a->Title
                                 );
    else
        a->Title = NULL;

    if (lpVDMInfo->ReservedLen)
        CsrAllocateMessagePointer( CaptureBuffer,
                                   lpVDMInfo->ReservedLen,
                                   (PVOID *)&a->Reserved
                                 );
    else
        a->Reserved = NULL;

retry:
    Status = CsrClientCallServer(
                        (PCSR_API_MSG)&m,
                        CaptureBuffer,
                        CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                            BasepGetNextVDMCommand
                                           ),
                        sizeof( *a )
                        );

    if (a->WaitObjectForVDM) {
        Status2 = NtWaitForSingleObject(a->WaitObjectForVDM,FALSE,NULL);
        if (Status2 != STATUS_SUCCESS){
            CsrFreeCaptureBuffer(CaptureBuffer);
            BaseSetLastNTError(Status2);
            return FALSE;
            }
        else {
            a->VDMState |= ASKING_FOR_SECOND_TIME;
            a->ExitCode = 0;
            goto retry;
            }
        }

    if (NT_SUCCESS(Status)) {
        Status = (NTSTATUS)m.ReturnValue;
        }


    if (!NT_SUCCESS( Status )) {
        if (Status == STATUS_INVALID_PARAMETER) {
            //This means one of the buffer size is less than required.
            lpVDMInfo->CmdSize = a->CmdLen;
            lpVDMInfo->AppLen = a->AppLen;
            lpVDMInfo->PifLen = a->PifLen;
            lpVDMInfo->EnviornmentSize = a->EnvLen;
            lpVDMInfo->CurDirectoryLen = a->CurDirectoryLen;
            lpVDMInfo->DesktopLen      = a->DesktopLen;
            lpVDMInfo->TitleLen        = a->TitleLen;
            lpVDMInfo->ReservedLen     = a->ReservedLen;
            }
        else {
            lpVDMInfo->CmdSize = 0;
            lpVDMInfo->AppLen = 0;
            lpVDMInfo->PifLen = 0;
            lpVDMInfo->EnviornmentSize = 0;
            lpVDMInfo->CurDirectoryLen = 0;
            lpVDMInfo->DesktopLen      = 0;
            lpVDMInfo->TitleLen        = 0;
            lpVDMInfo->ReservedLen     = 0;
            }
        CsrFreeCaptureBuffer( CaptureBuffer );
        BaseSetLastNTError(Status);
        return FALSE;
    }


    try {

        if (lpVDMInfo->CmdSize)
            RtlMoveMemory(lpVDMInfo->CmdLine,
                          a->CmdLine,
                          a->CmdLen);


        if (lpVDMInfo->AppLen)
            RtlMoveMemory(lpVDMInfo->AppName,
                          a->AppName,
                          a->AppLen);

        if (lpVDMInfo->PifLen)
            RtlMoveMemory(lpVDMInfo->PifFile,
                          a->PifFile,
                          a->PifLen);


        if (lpVDMInfo->Enviornment)
            RtlMoveMemory(lpVDMInfo->Enviornment,
                          a->Env,
                          a->EnvLen);


        if (lpVDMInfo->CurDirectoryLen)
            RtlMoveMemory(lpVDMInfo->CurDirectory,
                          a->CurDirectory,
                          a->CurDirectoryLen);

        if (a->VDMState & STARTUP_INFO_RETURNED)
            RtlMoveMemory(&lpVDMInfo->StartupInfo,
                          a->StartupInfo,
                          sizeof(STARTUPINFOA));

        if (lpVDMInfo->DesktopLen){
            RtlMoveMemory(lpVDMInfo->Desktop,
                          a->Desktop,
                          a->DesktopLen);
            lpVDMInfo->StartupInfo.lpDesktop = lpVDMInfo->Desktop;
        }


        if (lpVDMInfo->TitleLen){
            RtlMoveMemory(lpVDMInfo->Title,
                          a->Title,
                          a->TitleLen);
            lpVDMInfo->StartupInfo.lpTitle = lpVDMInfo->Title;
        }

        if (lpVDMInfo->ReservedLen){
            RtlMoveMemory(lpVDMInfo->Reserved,
                          a->Reserved,
                          a->ReservedLen);
            lpVDMInfo->StartupInfo.lpReserved = lpVDMInfo->Reserved;
        }

        lpVDMInfo->CmdSize = a->CmdLen;
        lpVDMInfo->AppLen = a->AppLen;
        lpVDMInfo->PifLen = a->PifLen;
        lpVDMInfo->EnviornmentSize = a->EnvLen;
        if (a->VDMState & STARTUP_INFO_RETURNED)
            lpVDMInfo->VDMState = STARTUP_INFO_RETURNED;
        else
            lpVDMInfo->VDMState = 0;
        lpVDMInfo->CurDrive = a->CurrentDrive;
        lpVDMInfo->StdIn  = a->StdIn;
        lpVDMInfo->StdOut = a->StdOut;
        lpVDMInfo->StdErr = a->StdErr;
        lpVDMInfo->iTask = a->iTask;
        lpVDMInfo->CodePage = a->CodePage;
        lpVDMInfo->CurDirectoryLen = a->CurDirectoryLen;
        lpVDMInfo->DesktopLen = a->DesktopLen;
        lpVDMInfo->TitleLen = a->TitleLen;
        lpVDMInfo->ReservedLen = a->ReservedLen;
        lpVDMInfo->dwCreationFlags = a->dwCreationFlags;
        lpVDMInfo->fComingFromBat = a->fComingFromBat;

        CsrFreeCaptureBuffer( CaptureBuffer );
        return TRUE;
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        BaseSetLastNTError(GetExceptionCode());
        CsrFreeCaptureBuffer( CaptureBuffer );
        return FALSE;
        }
}

VOID
APIENTRY
ExitVDM(
    BOOL IsWowCaller,
    ULONG iWowTask
    )

/*++

Routine Description:
    This routine is used by MVDM to exit.


Arguments:
    IsWowCaller - TRUE if the caller is WOWVDM.
                  FALSE if the caller is DOSVDM
                  This parameter is obsolete as basesrv knows about the kind
                  of vdm that is calling us


    iWowTask - if IsWowCaller == FALSE then Dont Care
             - if IsWowCaller == TRUE && iWowTask != -1 kill iWowTask task
             - if IsWowCaller == TRUE && iWowTask == -1 kill all wow task

Return Value:
    None

--*/

{

    NTSTATUS Status;
    BASE_API_MSG m;
    PBASE_EXIT_VDM_MSG c = &m.u.ExitVDM;

    c->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    if (IsWowCaller) {
       c->iWowTask = iWowTask;
    }
    else {
       c->iWowTask = 0;
    }

    // this parameter means
    c->WaitObjectForVDM =0;

    Status = CsrClientCallServer(
                      (PCSR_API_MSG)&m,
                      NULL,
                      CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                           BasepExitVDM
                                         ),
                      sizeof( *c )
                      );
    if (NT_SUCCESS(Status) && c->WaitObjectForVDM) {
        NtClose (c->WaitObjectForVDM);
        }

    return;
}

/*++

Routine Description:
    Set new VDM current directories

Arguments:
    cchCurDir - length of buffer in bytes
    lpszCurDir - buffer to return the current director of NTVDM

Return Value:
    TRUE if function succeed
    FALSE if function failed, GetLastError() has the error code
--*/


BOOL
APIENTRY
SetVDMCurrentDirectories(
    IN ULONG  cchCurDirs,
    IN LPSTR  lpszzCurDirs
    )
{
    NTSTATUS Status;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    BASE_API_MSG m;
    PBASE_GET_SET_VDM_CUR_DIRS_MSG a = &m.u.GetSetVDMCurDirs;

    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;
    // caller must have a valid console(WOW will fail)
    if (a->ConsoleHandle == (HANDLE) -1) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }
    if (cchCurDirs && lpszzCurDirs) {
        // get capture buffer, one pointer in the message

        CaptureBuffer = CsrAllocateCaptureBuffer(1, cchCurDirs);
        if (CaptureBuffer == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            return FALSE;
            }

        CsrAllocateMessagePointer( CaptureBuffer,
                                   cchCurDirs,
                                   (PVOID *)&a->lpszzCurDirs
                                   );

        a->cchCurDirs = cchCurDirs;
        try {
            RtlMoveMemory(a->lpszzCurDirs, lpszzCurDirs, cchCurDirs);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            BaseSetLastNTError(GetExceptionCode());
            CsrFreeCaptureBuffer(CaptureBuffer);
            return FALSE;
        }
        Status = CsrClientCallServer(
                            (PCSR_API_MSG)&m,
                            CaptureBuffer,
                            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                BasepSetVDMCurDirs
                                                ),
                            sizeof( *a )
                            );
        CsrFreeCaptureBuffer(CaptureBuffer);

        if (!NT_SUCCESS(Status) || !NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }
    return TRUE;
}




/*++

Routine Description:
    To return current directory of NTVDM.
    This allows the parent process(CMD.EXE in most cases) to keep track the
    current directory after each VDM execution.
    NOTE: this function doesn't apply to wow

Arguments:
    cchCurDir - length of buffer in bytes
    lpszCurDir - buffer to return the current director of NTVDM

    Note: We don't require the process id to the running VDM because
          current directories are global to every VDMs under a single NTVDM
          control -- each console handle has its own current directories
Return Value:
    ULONG - (1). number of bytes written to the given buffer if succeed
            (2). lentgh of the current directory including NULL
                 if the provided buffer is not large enough
            (3). 0  then GetLastError() has the error code
--*/


ULONG
APIENTRY
GetVDMCurrentDirectories(
    IN ULONG  cchCurDirs,
    IN LPSTR  lpszzCurDirs
    )
{
    NTSTATUS Status;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    BASE_API_MSG m;
    PBASE_GET_SET_VDM_CUR_DIRS_MSG a = &m.u.GetSetVDMCurDirs;


    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;
    if (a->ConsoleHandle == (HANDLE) -1) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return 0L;
    }
    if (cchCurDirs && lpszzCurDirs) {
        CaptureBuffer = CsrAllocateCaptureBuffer(1, cchCurDirs);
        if (CaptureBuffer == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            return FALSE;
            }

        CsrAllocateMessagePointer( CaptureBuffer,
                                   cchCurDirs,
                                   (PVOID *)&a->lpszzCurDirs
                                   );

        a->cchCurDirs = cchCurDirs;
    }
    else {
        a->cchCurDirs = 0;
        a->lpszzCurDirs = NULL;
        CaptureBuffer = NULL;
    }

    m.ReturnValue = 0xffffffff;

    Status = CsrClientCallServer(
                         (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                             BasepGetVDMCurDirs
                                             ),
                         sizeof( *a )
                         );

    if (m.ReturnValue == 0xffffffff) {
        a->cchCurDirs = 0;
        }

    if (NT_SUCCESS(Status)) {
        Status = m.ReturnValue;
        }

    if (NT_SUCCESS(Status)) {

        try {
            RtlMoveMemory(lpszzCurDirs, a->lpszzCurDirs, a->cchCurDirs);
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            a->cchCurDirs = 0;
            }
        }
    else {
        BaseSetLastNTError(Status);
        }

    if (CaptureBuffer) {
        CsrFreeCaptureBuffer(CaptureBuffer);
        }

    return a->cchCurDirs;
}


VOID
APIENTRY
CmdBatNotification(
    IN  ULONG   fBeginEnd
    )

/*++

Routine Description:
    This API lets base know about .bat processing from cmd. This is
    required by VDM, so that it can decided correctly when to  put
    command.com prompt on TSRs. If the command came from .bat file
    then VDM should'nt put its prompt. This is important for
    ventura publisher and civilization apps.

Arguments:
    fBeginEnd - CMD_BAT_OPERATION_STARTING  -> .BAT processing is starting
                CMD_BAT_OPERATION_TERMINATING -> .BAT processing is ending

Return Value:
    None
--*/

{
#if defined(BUILD_WOW6432)

    // 32-bit cmd.exe calls this in WOW64, but there is no VDM support, so
    // no need for a WOW64 thunk for it.
    UNREFERENCED_PARAMETER(fBeginEnd);

#else
    BASE_API_MSG m;
    PBASE_BAT_NOTIFICATION_MSG a = &m.u.BatNotification;

    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    if (a->ConsoleHandle == (HANDLE) -1)
        return;

    a->fBeginEnd = fBeginEnd;

    CsrClientCallServer((PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                             BasepBatNotification
                                             ),
                         sizeof( *a )
                         );
#endif
    return;
}


NTSTATUS
APIENTRY
RegisterWowExec(
    IN  HANDLE   hwndWowExec
    )

/*++

Routine Description:
    This API gives basesrv the window handle for the shared WowExec so
    it can send WM_WOWEXECSTARTAPP messages to WowExec.  This
    saves having a thread in WOW dedicated to GetNextVDMCommand.

Arguments:
    hwndWowExec - Win32 window handle for WowExec in shared WOW VDM.
                  Separate WOW VDMs don't register their WowExec handle
                  because they never get commands from base.
                  NULL is passed to de-register any given wowexec

Return Value:
   If hwndWowExec != NULL then returns success if wow had been registered successfully
   if hwndWowExec == NULL then returns success if no tasks are pending to be executed
--*/

{
    BASE_API_MSG m;
    PBASE_REGISTER_WOWEXEC_MSG a = &m.u.RegisterWowExec;
    NTSTATUS Status;

    a->hwndWowExec   = hwndWowExec;
    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    Status = CsrClientCallServer((PCSR_API_MSG)&m,
                                  NULL,
                                  CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                      BasepRegisterWowExec
                                                      ),
                                  sizeof( *a )
                                 );
    return Status;
}


/*++

Routine Description:
    This routine is used to close standard IO handles before returning to the
    caller


Arguments:
    pVDMInfo - VDM Info record containing stdio handles

Return Value:
    None

--*/
VOID
BaseCloseStandardHandle(
    IN PVDMINFO pVDMInfo
    )
{
    if (pVDMInfo->StdIn)
        NtClose (pVDMInfo->StdIn);

    if (pVDMInfo->StdOut)
        NtClose (pVDMInfo->StdOut);

    if (pVDMInfo->StdErr)
        NtClose (pVDMInfo->StdErr);

    pVDMInfo->StdIn  = 0;
    pVDMInfo->StdOut = 0;
    pVDMInfo->StdErr = 0;
}

NTSTATUS BaseGetVdmLuid(
    HANDLE Token,
    PLUID pluidCaller
    )
{
    PTOKEN_STATISTICS pStats;
    ULONG BytesRequired;
    NTSTATUS Status;

    /*
     * Get the session id of the caller.
     */
    Status = NtQueryInformationToken(
                 Token,                     // Handle
                 TokenStatistics,           // TokenInformationClass
                 NULL,                      // TokenInformation
                 0,                         // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        return Status;
        }

    //
    // Allocate space for the user info
    //

    pStats = (PTOKEN_STATISTICS)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ), BytesRequired);
    if (pStats == NULL) {
        return Status;
        }

    //
    // Read in the user info
    //

    Status = NtQueryInformationToken(
                 Token,             // Handle
                 TokenStatistics,       // TokenInformationClass
                 pStats,                // TokenInformation
                 BytesRequired,         // TokenInformationLength
                 &BytesRequired         // ReturnLength
                 );

    if (NT_SUCCESS(Status)) {
        if (pluidCaller != NULL)
             *pluidCaller = pStats->AuthenticationId;
        }

    RtlFreeHeap(RtlProcessHeap(), 0, pStats);

    return Status;
}


NTSTATUS
BaseCheckVDMp(
    IN  ULONG BinaryType,
    IN  PCWCH lpApplicationName,
    IN  PCWCH lpCommandLine,
    IN  PCWCH lpCurrentDirectory,
    IN  ANSI_STRING *pAnsiStringEnv,
    IN  PBASE_API_MSG m,
    IN OUT PULONG iTask,
    IN  DWORD dwCreationFlags,
    LPSTARTUPINFOW lpStartupInfo,
    IN  HANDLE hUserToken
    )
/*++

Routine Description:

    This routine calls the windows server to find out if the VDM for the
    current session is already present. If so, a new process is'nt created
    instead the DOS binary is dispatched to the existing VDM. Otherwise,
    a new VDM process is created. This routine also passes the app name
    and command line to the server in DOS int21/0ah style which is later
    passed by the server to the VDM.

Arguments:

    BinaryType - DOS/WOW binary
    lpApplicationName -- pointer to the full path name of the executable.
    lpCommandLine -- command line
    lpCurrentDirectory - Current directory
    lpEnvironment,     - Envirinment strings
    m - pointer to the base api message.
    iTask - taskid for win16 apps, and no-console dos apps
    dwCreationFlags - creation flags as passed to createprocess
    lpStartupInfo =- pointer to startupinfo as passed to createprocess


Return Value:

    OEM vs. ANSI:
    The command line, Application Name, title are converted to OEM strings,
    suitable for the VDM. All other strings are returned as ANSI.

    returns nt status code of the last operation
    STATUS_ACCESS_DENIED -- Operation failed (desktop access denied)
    STATUS_SUCCESS       -- Operation sucseeded

--*/
{

    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PPEB Peb;
    PBASE_CHECKVDM_MSG b= (PBASE_CHECKVDM_MSG)&m->u.CheckVDM;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    ANSI_STRING AnsiStringCurrentDir,AnsiStringDesktop;
    ANSI_STRING AnsiStringReserved, AnsiStringPif;
    OEM_STRING OemStringCmd, OemStringAppName, OemStringTitle;
    UNICODE_STRING UnicodeString;
    PCHAR pch, Buffer = NULL;
    ULONG Len;
    ULONG bufPointers;
    LPWSTR wsBuffer;
    LPWSTR wsAppName;
    LPWSTR wsPifName;
    LPWSTR wsCmdLine;
    LPWSTR wsPif=L".pif";
    LPWSTR wsSharedWowPif=L"wowexec.pif";
    PWCHAR pwch;
    BOOLEAN bNewConsole;
    DWORD   dw, dwTotal, Length;
    WCHAR   wchBuffer[MAX_PATH + 1];
    ULONG BinarySubType;
    LPWSTR lpAllocatedReserved = NULL;
    DWORD   HandleFlags;
    LUID    VdmUserLuid;

    // does a trivial test of the environment
    if (!ARGUMENT_PRESENT(pAnsiStringEnv) ||
        pAnsiStringEnv->Length > MAXIMUM_VDM_ENVIORNMENT) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
        }

    wsCmdLine = wsAppName = NULL;
    OemStringCmd.Buffer = NULL;
    OemStringAppName.Buffer = NULL;
    AnsiStringCurrentDir.Buffer = NULL;
    AnsiStringDesktop.Buffer = NULL;
    AnsiStringPif.Buffer = NULL;
    OemStringTitle.Buffer = NULL;
    AnsiStringReserved.Buffer = NULL;
    wsBuffer = NULL;
    wsPifName = NULL;

    BinarySubType = BinaryType & BINARY_SUBTYPE_MASK;
    BinaryType = BinaryType & ~BINARY_SUBTYPE_MASK;
    bNewConsole = !NtCurrentPeb()->ProcessParameters->ConsoleHandle ||
                  (dwCreationFlags & CREATE_NEW_CONSOLE);

    try {

        if (BinaryType == BINARY_TYPE_DOS) {

            Peb = NtCurrentPeb();
            if (lpStartupInfo && lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) {
                b->StdIn = lpStartupInfo->hStdInput;
                b->StdOut = lpStartupInfo->hStdOutput;
                b->StdErr = lpStartupInfo->hStdError;

                }
            else {
                b->StdIn = Peb->ProcessParameters->StandardInput;
                b->StdOut = Peb->ProcessParameters->StandardOutput;
                b->StdErr = Peb->ProcessParameters->StandardError;

                //
                // Verify that the standard handles ntvdm process will inherit
                // from the calling process are real handles. They are not
                // handles if the calling process was created with
                // STARTF_USEHOTKEY | STARTF_HASSHELLDATA.
                // Note that CreateProcess clears STARTF_USESTANDHANDLES
                // if either STARTF_USEHOTKEY or STARTF_HASSHELLDATA is set.
                //
                if (Peb->ProcessParameters->WindowFlags &
                    (STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {

                    if (b->StdIn && !CONSOLE_HANDLE(b->StdIn) &&
                        !GetHandleInformation(b->StdIn, &HandleFlags))
                        b->StdIn = 0;
                    if (b->StdOut && !CONSOLE_HANDLE(b->StdOut) &&
                        !GetHandleInformation(b->StdOut, &HandleFlags)) {
                        if (b->StdErr == b->StdOut)
                            b->StdErr = 0;
                        b->StdOut = 0;
                        }
                    if (b->StdErr && b->StdErr != b->StdOut &&
                        !CONSOLE_HANDLE(b->StdErr) &&
                        !GetHandleInformation(b->StdErr, &HandleFlags))
                        b->StdErr = 0;
                    }
                }
            if (CONSOLE_HANDLE((b->StdIn)))
                b->StdIn = 0;

            if (CONSOLE_HANDLE((b->StdOut)))
                b->StdOut = 0;

            if (CONSOLE_HANDLE((b->StdErr)))
                b->StdErr = 0;
            }


        if (BinaryType == BINARY_TYPE_SEPWOW) {
            bNewConsole = TRUE;
            }

        //
        // Convert Unicode Application Name to Oem short name
        //
             // skiping leading white space
        while(*lpApplicationName == (WCHAR)' ' || *lpApplicationName == (WCHAR)'\t' ) {
              lpApplicationName++;
              }

             // space for short AppName
        Len = wcslen(lpApplicationName);
        dwTotal = Len + 1 + MAX_PATH;
        wsAppName =  RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG(VDM_TAG),
                                    dwTotal * sizeof(WCHAR)
                                    );
        if (wsAppName == NULL) {
            Status = STATUS_NO_MEMORY;
            goto BCVTryExit;
            }

        dw = GetShortPathNameW(lpApplicationName, wsAppName, dwTotal);
        // If getting the short name is impossible, stop right here.
        // We can not execute a 16bits biranry if we can not find
        // its appropriate short name alias. Sorry HPFS, Sorry NFS

        if (0 == dw || dw > dwTotal) {
            Status = STATUS_OBJECT_PATH_INVALID;
            goto BCVTryExit;
            }

        RtlInitUnicodeString(&UnicodeString, wsAppName);
        Status = RtlUnicodeStringToOemString(&OemStringAppName,
                                             &UnicodeString,
                                             TRUE
                                             );
        if (!NT_SUCCESS(Status) ){
            goto BCVTryExit;
            }


        //
        // Find len of basename excluding extension,
        // for CommandTail max len check.
        //
        dw = OemStringAppName.Length;
        pch = OemStringAppName.Buffer;
        Length = 1;        // start at one for space between cmdname & cmdtail
        while (dw-- && *pch != '.') {
            if (*pch == '\\') {
                Length = 1;
                }
            else {
                Length++;
                }
            pch++;
            }


        //
        // Find the beg of the command tail to pass as the CmdLine
        //

        Len = wcslen(lpApplicationName);

        if (L'"' == lpCommandLine[0]) {

            //
            // Application name is quoted, skip the quoted text
            // to get command tail.
            //

            pwch = (LPWSTR)&lpCommandLine[1];
            while (*pwch && L'"' != *pwch++) {
                ;
            }

        } else if (Len <= wcslen(lpCommandLine) &&
            0 == _wcsnicmp(lpApplicationName, lpCommandLine, Len)) {

            //
            // Application path is also on the command line, skip past
            // that to reach the command tail instead of looking for
            // the first white space.
            //

            pwch = (LPWSTR)lpCommandLine + Len;

        } else {

            //
            // We assume first token is exename (argv[0]).
            //

            pwch = (LPWSTR)lpCommandLine;

               // skip leading white characters
            while (*pwch != UNICODE_NULL &&
                   (*pwch == (WCHAR) ' ' || *pwch == (WCHAR) '\t')) {
                pwch++;
                }

               // skip first token
            if (*pwch == (WCHAR) '\"') {    // quotes as delimiter
                pwch++;
                while (*pwch && *pwch++ != '\"') {
                      ;
                      }
                }
            else {                         // white space as delimiter
                while (*pwch && *pwch != ' ' && *pwch != '\t') {
                       pwch++;
                       }
                }
        }

        //
        // pwch points past the application name, now skip any trailing
        // whitespace.
        //

        while (*pwch && (L' ' == *pwch || L'\t' == *pwch)) {
            pwch++;
        }

        wsCmdLine = pwch;
        dw = wcslen(wsCmdLine);

        // convert to oem
        UnicodeString.Length = (USHORT)(dw * sizeof(WCHAR));
        UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);
        UnicodeString.Buffer = wsCmdLine;
        Status = RtlUnicodeStringToOemString(
                    &OemStringCmd,
                    &UnicodeString,
                    TRUE);

        if (!NT_SUCCESS(Status) ){
            goto BCVTryExit;
            }

        //
        // check len of command line for dos compatibility
        //
        if (OemStringCmd.Length >= MAXIMUM_VDM_COMMAND_LENGTH - Length) {
            Status = STATUS_INVALID_PARAMETER;
            goto BCVTryExit;
            }


        //
        // Search for matching pif file. Search order is AppName dir,
        // followed by win32 default search path. For the shared wow, pif
        // is wowexec.pif if it exists.
        //
        wsBuffer = RtlAllocateHeap(RtlProcessHeap(),MAKE_TAG( VDM_TAG ),MAX_PATH*sizeof(WCHAR));
        if (!wsBuffer) {
            Status = STATUS_NO_MEMORY;
            goto BCVTryExit;
            }

        wsPifName = RtlAllocateHeap(RtlProcessHeap(),MAKE_TAG( VDM_TAG ),MAX_PATH*sizeof(WCHAR));
        if (!wsPifName) {
            Status = STATUS_NO_MEMORY;
            goto BCVTryExit;
            }

        if (BinaryType == BINARY_TYPE_WIN16) {
            wcscpy(wsBuffer, wsSharedWowPif);
            Len = 0;
            }
        else {
            // dos application path should be less than MAX_PATH
            if(Len >= MAX_PATH) {
                Status = STATUS_INVALID_PARAMETER;
                goto BCVTryExit;
               }

            // start with fully qualified app name
            wcscpy(wsBuffer, lpApplicationName);

             // strip extension if any
            pwch = wcsrchr(wsBuffer, (WCHAR)'.');
            // dos application must have an extention

            if (pwch == NULL || wsBuffer - pwch + MAX_PATH < sizeof(wsPif)/sizeof(WCHAR)) {
                 Status = STATUS_INVALID_PARAMETER;
                 goto BCVTryExit;
                }
            wcscpy(pwch, wsPif);

            Len = GetFileAttributesW(wsBuffer);
            if (Len == (DWORD)(-1) || (Len & FILE_ATTRIBUTE_DIRECTORY)) {
                Len = 0;
                }
            else {
                Len = wcslen(wsBuffer) + 1;
                wcsncpy(wsPifName, wsBuffer, Len);
                }
            }

        if (!Len)  {  // try basename

               // find beg of basename
            pwch = wcsrchr(wsBuffer, (WCHAR)'\\');
            if (!pwch ) {
                 pwch = wcsrchr(wsBuffer, (WCHAR)':');
                 }

               // move basename to beg of wsBuffer
            if (pwch++) {
                 while (*pwch != UNICODE_NULL &&
                        *pwch != (WCHAR)' '   && *pwch != (WCHAR)'\t' )
                       {
                        wsBuffer[Len++] = *pwch++;
                        }
                 wsBuffer[Len] = UNICODE_NULL;
                 }

            if (Len)  {
                Len = SearchPathW(
                            NULL,
                            wsBuffer,
                            wsPif,              // L".pif"
                            MAX_PATH,
                            wsPifName,
                            NULL
                            );
                if (Len >= MAX_PATH) {
                    Status = STATUS_NO_MEMORY;
                    goto BCVTryExit;
                    }
                }
            }

        if (!Len)
            *wsPifName = UNICODE_NULL;



        if (!ARGUMENT_PRESENT( lpCurrentDirectory )) {
#pragma prefast(suppress: 209, "RtlGetCurrentDirectory_U takes a byte count")

            dw = RtlGetCurrentDirectory_U(sizeof (wchBuffer), wchBuffer);

            wchBuffer[dw / sizeof(WCHAR)] = UNICODE_NULL;
            dw = GetShortPathNameW(wchBuffer,
                                   wchBuffer,
                                   sizeof(wchBuffer) / sizeof(WCHAR)
                                   );
            if (dw > sizeof(wchBuffer) / sizeof(WCHAR))
                goto BCVTryExit;

            else if (dw == 0) {
                RtlInitUnicodeString(&UnicodeString, wchBuffer);
                dw = UnicodeString.Length / sizeof(WCHAR);
                }
            else {
                UnicodeString.Length = (USHORT)(dw * sizeof(WCHAR));
                UnicodeString.Buffer = wchBuffer;
                UnicodeString.MaximumLength = (USHORT)sizeof(wchBuffer);
                }
            // DOS limit of 64 includes the final NULL but not the leading
            // drive and slash. So here we should be checking the ansi length
            // of current directory + 1 (for NULL) - 3 (for c:\).
            if ( dw - 2 <= MAXIMUM_VDM_CURRENT_DIR ) {
                Status = RtlUnicodeStringToAnsiString(
                                                      &AnsiStringCurrentDir,
                                                      &UnicodeString,
                                                      TRUE
                                                     );
                }
            else {
                Status = STATUS_INVALID_PARAMETER;
                }

            if ( !NT_SUCCESS(Status) ) {
                goto BCVTryExit;
                }
            }
        else {

            // first get a full path name
            dw = GetFullPathNameW(lpCurrentDirectory,
                                   sizeof(wchBuffer) / sizeof(WCHAR),
                                   wchBuffer,
                                   NULL);
            if (0 != dw && dw <= sizeof(wchBuffer) / sizeof(WCHAR)) {
               dw = GetShortPathNameW(wchBuffer,
                                      wchBuffer,
                                      sizeof(wchBuffer) / sizeof(WCHAR));
            }
            if (dw > sizeof(wchBuffer) / sizeof(WCHAR))
                goto BCVTryExit;

            if (dw != 0) {
                UnicodeString.Buffer = wchBuffer;
                UnicodeString.Length = (USHORT)(dw * sizeof(WCHAR));
                UnicodeString.MaximumLength = sizeof(wchBuffer);
                }
            else
                RtlInitUnicodeString(&UnicodeString, lpCurrentDirectory);

            Status = RtlUnicodeStringToAnsiString(
                &AnsiStringCurrentDir,
                &UnicodeString,
                TRUE);

            if ( !NT_SUCCESS(Status) ){
                goto BCVTryExit;
               }

            // DOS limit of 64 includes the final NULL but not the leading
            // drive and slash. So here we should be checking the ansi length
            // of current directory + 1 (for NULL) - 3 (for c:\).
            if((AnsiStringCurrentDir.Length - 2) > MAXIMUM_VDM_CURRENT_DIR) {
                Status = STATUS_INVALID_PARAMETER;
                goto BCVTryExit;
                }
            }

        // NT allows applications to use UNC name as their current directory.
        // while NTVDM can't do that. We will end up a weird drive number
        // like '\' - 'a') here ????????????????????????????????
        //
        // Place Current Drive
        if(AnsiStringCurrentDir.Buffer[0] <= 'Z')
            b->CurDrive = AnsiStringCurrentDir.Buffer[0] - 'A';
        else
            b->CurDrive = AnsiStringCurrentDir.Buffer[0] - 'a';

        //
        // Hotkey info in NT traditionally is specified in the
        // startupinfo.lpReserved field, but Win95 added a
        // duplicate mechanism.  If the Win95 method was used,
        // map it to the NT method here so the rest of the
        // VDM code only has to deal with one method.
        //
        // If the caller was specified a hotkey
        // in lpReserved as well as using STARTF_USEHOTKEY,
        // the STARTF_USEHOTKEY hotkey will take precedence.
        //

        if (lpStartupInfo && lpStartupInfo->dwFlags & STARTF_USEHOTKEY) {

            DWORD cbAlloc = sizeof(WCHAR) *
                            (20 +                            // "hotkey.4294967295 " (MAXULONG)
                             (lpStartupInfo->lpReserved      // length of prev lpReserved
                              ? wcslen(lpStartupInfo->lpReserved)
                              : 0
                             ) +
                             1                               // NULL terminator
                            );


            lpAllocatedReserved = RtlAllocateHeap(RtlProcessHeap(),
                                                  MAKE_TAG( VDM_TAG ),
                                                  cbAlloc
                                                 );
            if (lpAllocatedReserved) {

                swprintf(lpAllocatedReserved,
                         L"hotkey.%u %s",
                         HandleToUlong(lpStartupInfo->hStdInput),
                         lpStartupInfo->lpReserved ? lpStartupInfo->lpReserved : L""
                         );

                lpStartupInfo->dwFlags &= ~STARTF_USEHOTKEY;
                lpStartupInfo->hStdInput = 0;
                lpStartupInfo->lpReserved = lpAllocatedReserved;

            }

        }


        //
        // Allocate Capture Buffer
        //
        //
        bufPointers = 2;  // CmdLine, AppName

        //
        // CmdLine for capture buffer, 3 for 0xd,0xa and NULL
        //
        Len = ROUND_UP((OemStringCmd.Length + 3),4);

        // AppName, 1 for NULL
        Len += ROUND_UP((OemStringAppName.Length + 1),4);

        // Env
        if (pAnsiStringEnv->Length) {
            bufPointers++;
            Len += ROUND_UP(pAnsiStringEnv->Length, 4);
            }

        // CurrentDir
        if (AnsiStringCurrentDir.Length){
            bufPointers++;
            Len += ROUND_UP((AnsiStringCurrentDir.Length +1),4); // 1 for NULL
            }


        // pif file name, 1 for NULL
        if (wsPifName && *wsPifName != UNICODE_NULL) {
            bufPointers++;
            RtlInitUnicodeString(&UnicodeString,wsPifName);
            Status = RtlUnicodeStringToAnsiString(&AnsiStringPif,
                                                  &UnicodeString,
                                                  TRUE
                                                  );
            if ( !NT_SUCCESS(Status) ){
                goto BCVTryExit;
                }

            Len += ROUND_UP((AnsiStringPif.Length+1),4);
            }

        //
        // startupinfo space
        //
        if (lpStartupInfo) {
            Len += ROUND_UP(sizeof(STARTUPINFOA),4);
            bufPointers++;
            if (lpStartupInfo->lpDesktop) {
                bufPointers++;
                RtlInitUnicodeString(&UnicodeString,lpStartupInfo->lpDesktop);
                Status = RtlUnicodeStringToAnsiString(
                            &AnsiStringDesktop,
                            &UnicodeString,
                            TRUE);

                if ( !NT_SUCCESS(Status) ){
                    goto BCVTryExit;
                    }
                Len += ROUND_UP((AnsiStringDesktop.Length+1),4);
                }

            if (lpStartupInfo->lpTitle) {
                bufPointers++;
                RtlInitUnicodeString(&UnicodeString,lpStartupInfo->lpTitle);
                Status = RtlUnicodeStringToOemString(
                            &OemStringTitle,
                            &UnicodeString,
                            TRUE);

                if ( !NT_SUCCESS(Status) ){
                    goto BCVTryExit;
                    }
                Len += ROUND_UP((OemStringTitle.Length+1),4);
                }

            if (lpStartupInfo->lpReserved) {
                bufPointers++;
                RtlInitUnicodeString(&UnicodeString,lpStartupInfo->lpReserved);
                Status = RtlUnicodeStringToAnsiString(
                            &AnsiStringReserved,
                            &UnicodeString,
                            TRUE);

                if ( !NT_SUCCESS(Status) ){
                    goto BCVTryExit;
                    }
                Len += ROUND_UP((AnsiStringReserved.Length+1),4);
                }
            }

        //
        // luid space
        //
        // Allocate UserLuid pointer
        if(hUserToken) {
           bufPointers++;

           if (!NT_SUCCESS(BaseGetVdmLuid(hUserToken,&VdmUserLuid))) {
               Status = STATUS_INVALID_PARAMETER;
               goto BCVTryExit;
               }
           Len += ROUND_UP(sizeof(LUID),4);
           }


        // capture message buffer
        CaptureBuffer = CsrAllocateCaptureBuffer(bufPointers, Len);
        if (CaptureBuffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto BCVTryExit;
            }

        // Allocate CmdLine pointer
        CsrAllocateMessagePointer( CaptureBuffer,
                                   ROUND_UP((OemStringCmd.Length + 3),4),
                                   (PVOID *)&b->CmdLine
                                 );

        // Copy Command Line
        RtlMoveMemory (b->CmdLine, OemStringCmd.Buffer, OemStringCmd.Length);
        b->CmdLine[OemStringCmd.Length] = 0xd;
        b->CmdLine[OemStringCmd.Length+1] = 0xa;
        b->CmdLine[OemStringCmd.Length+2] = 0;
        b->CmdLen = (USHORT)(OemStringCmd.Length + 3);

        // Allocate AppName pointer
        CsrAllocateMessagePointer( CaptureBuffer,
                                   ROUND_UP((OemStringAppName.Length + 1),4),
                                   (PVOID *)&b->AppName
                                 );

        // Copy AppName
        RtlMoveMemory (b->AppName,
                       OemStringAppName.Buffer,
                       OemStringAppName.Length
                       );
        b->AppName[OemStringAppName.Length] = 0;
        b->AppLen = OemStringAppName.Length + 1;




        // Allocate PifFile pointer, Copy PifFile name
        if(AnsiStringPif.Buffer) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((AnsiStringPif.Length + 1),4),
                                       (PVOID *)&b->PifFile
                                     );

            RtlMoveMemory(b->PifFile,
                          AnsiStringPif.Buffer,
                          AnsiStringPif.Length);

            b->PifFile[AnsiStringPif.Length] = 0;
            b->PifLen = AnsiStringPif.Length + 1;

            }
        else {
            b->PifLen = 0;
            b->PifFile = NULL;
            }



        // Allocate Env pointer, Copy Env strings
        if(pAnsiStringEnv->Length) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((pAnsiStringEnv->Length),4),
                                       (PVOID *)&b->Env
                                     );

            RtlMoveMemory(b->Env,
                          pAnsiStringEnv->Buffer,
                          pAnsiStringEnv->Length);

            b->EnvLen = pAnsiStringEnv->Length;

            }
        else {
            b->EnvLen = 0;
            b->Env = NULL;
            }


        if(AnsiStringCurrentDir.Length) {
            // Allocate Curdir pointer
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((AnsiStringCurrentDir.Length + 1),4),
                                       (PVOID *)&b->CurDirectory
                                       );
            // copy cur directory
            RtlMoveMemory (b->CurDirectory,
                           AnsiStringCurrentDir.Buffer,
                           AnsiStringCurrentDir.Length+1);

            b->CurDirectoryLen = AnsiStringCurrentDir.Length+1;
            }
        else {
            b->CurDirectory = NULL;
            b->CurDirectoryLen = 0;
            }

        // Allocate startupinfo pointer
        if (lpStartupInfo) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP(sizeof(STARTUPINFOA),4),
                                       (PVOID *)&b->StartupInfo
                                     );
            // Copy startupinfo
            b->StartupInfo->dwX  =  lpStartupInfo->dwX;
            b->StartupInfo->dwY  =  lpStartupInfo->dwY;
            b->StartupInfo->dwXSize      =  lpStartupInfo->dwXSize;
            b->StartupInfo->dwYSize      =  lpStartupInfo->dwYSize;
            b->StartupInfo->dwXCountChars=      lpStartupInfo->dwXCountChars;
            b->StartupInfo->dwYCountChars=      lpStartupInfo->dwYCountChars;
            b->StartupInfo->dwFillAttribute=lpStartupInfo->dwFillAttribute;
            b->StartupInfo->dwFlags      =  lpStartupInfo->dwFlags;
            b->StartupInfo->wShowWindow =       lpStartupInfo->wShowWindow;
            b->StartupInfo->cb           =  sizeof(STARTUPINFOA);
            }
        else {
            b->StartupInfo = NULL;
            }

        // Allocate pointer for Desktop info if needed
        if (AnsiStringDesktop.Buffer) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((AnsiStringDesktop.Length + 1),4),
                                       (PVOID *)&b->Desktop
                                     );
            // Copy desktop string
            RtlMoveMemory (b->Desktop,
                           AnsiStringDesktop.Buffer,
                           AnsiStringDesktop.Length+1);
            b->DesktopLen =AnsiStringDesktop.Length+1;
            }
        else {
            b->Desktop = NULL;
            b->DesktopLen =0;
            }

        // Allocate pointer for Title info if needed
        if (OemStringTitle.Buffer) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((OemStringTitle.Length + 1),4),
                                       (PVOID *)&b->Title
                                     );
            // Copy title string
            RtlMoveMemory (b->Title,
                           OemStringTitle.Buffer,
                           OemStringTitle.Length+1);
            b->TitleLen = OemStringTitle.Length+1;
            }
        else {
            b->Title = NULL;
            b->TitleLen = 0;
            }

        // Allocate pointer for Reserved field if needed
        if (AnsiStringReserved.Buffer) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP((AnsiStringReserved.Length + 1),4),
                                       (PVOID *)&b->Reserved
                                     );
            // Copy reserved string
            RtlMoveMemory (b->Reserved,
                           AnsiStringReserved.Buffer,
                           AnsiStringReserved.Length+1);
            b->ReservedLen = AnsiStringReserved.Length+1;
            }
        else {
            b->Reserved = NULL;
            b->ReservedLen = 0;
            }

        // Allocate UserLuid pointer
        if(hUserToken) {
            CsrAllocateMessagePointer( CaptureBuffer,
                                       ROUND_UP(sizeof(LUID),4),
                                       (PVOID *)&b->UserLuid
                                     );
            RtlCopyLuid(b->UserLuid,&VdmUserLuid);
            }
        else {
            b->UserLuid = NULL;
            }


        // VadimB: this code is of no consequence to our marvelous new
        // architecture for tracking shared wows.
        // Reason: the checkvdm command is executed within the context of
        // a parent process thus at this point ConsoleHandle is of any
        // interest only to DOS apps.

        if (BinaryType == BINARY_TYPE_WIN16)
            b->ConsoleHandle = (HANDLE)-1;
        else if (bNewConsole)
            b->ConsoleHandle = 0;
        else
            b->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

        b->VDMState = FALSE;
        b->BinaryType = BinaryType;
        b->CodePage = (ULONG) GetConsoleCP ();
        b->dwCreationFlags = dwCreationFlags;

        Status = CsrClientCallServer(
                          (PCSR_API_MSG)m,
                          CaptureBuffer,
                          CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                               BasepCheckVDM
                                             ),
                          sizeof( *b )
                          );

        // if desktop access is denied, then we try again with the
        // current default desktop
        //

        if ((STATUS_ACCESS_DENIED == Status) && (0 == b->DesktopLen)) {
            CsrFreeCaptureBuffer(CaptureBuffer);
            goto BCVTryExit;
           }


        CsrFreeCaptureBuffer(CaptureBuffer);

        if (!NT_SUCCESS(Status) || !NT_SUCCESS((NTSTATUS)m->ReturnValue)) {
            Status = (NTSTATUS)m->ReturnValue;
            goto BCVTryExit;
        }


        // VadimB: This iTask could be :
        //   (*) If not wow task - then dos task id (items below are not
        //       relevant for this case)
        //   (*) Shared wow exists and ready - this is a wow task id
        //       that is unique across all the shared wows

        *iTask = b->iTask;
        Status = STATUS_SUCCESS;

BCVTryExit:;
        }

    finally {
        if(Buffer != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Buffer);

        if(wsBuffer != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)wsBuffer);

        if(wsPifName != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)wsPifName);

        if(OemStringCmd.Buffer != NULL)
            RtlFreeOemString(&OemStringCmd);

        if(OemStringAppName.Buffer != NULL)
            RtlFreeOemString(&OemStringAppName);

        if(AnsiStringPif.Buffer != NULL)
           RtlFreeAnsiString(&AnsiStringPif);

        if(AnsiStringCurrentDir.Buffer != NULL)
            RtlFreeAnsiString(&AnsiStringCurrentDir);

        if(AnsiStringDesktop.Buffer != NULL)
            RtlFreeAnsiString(&AnsiStringDesktop);

        if(OemStringTitle.Buffer != NULL)
            RtlFreeAnsiString(&OemStringTitle);

        if(AnsiStringReserved.Buffer != NULL)
            RtlFreeAnsiString(&AnsiStringReserved);

        if (wsAppName != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, wsAppName);

        if (lpAllocatedReserved != NULL)
            RtlFreeHeap(RtlProcessHeap(), 0, lpAllocatedReserved);

        }

    return Status;
}


/*
   jarbats
   Some apps send startupinfo with bad desktop name
   as a result, basecheckvdm will fail with because
   access to the desktop can't be obtained
   in that case we attempt again with the parents desktop

*/


NTSTATUS
BaseCheckVDM(
    IN  ULONG BinaryType,
    IN  PCWCH lpApplicationName,
    IN  PCWCH lpCommandLine,
    IN  PCWCH lpCurrentDirectory,
    IN  ANSI_STRING *pAnsiStringEnv,
    IN  PBASE_API_MSG m,
    IN OUT PULONG iTask,
    IN  DWORD dwCreationFlags,
    LPSTARTUPINFOW lpStartupInfo,
    IN HANDLE hUserToken
    ) {

   NTSTATUS Status;
   LPWSTR lpDesktopOld;

   Status = BaseCheckVDMp(
                         BinaryType,
                         lpApplicationName,
                         lpCommandLine,
                         lpCurrentDirectory,
                         pAnsiStringEnv,
                         m,
                         iTask,
                         dwCreationFlags,
                         lpStartupInfo,
                         hUserToken
                        );

   if ( Status == STATUS_ACCESS_DENIED ) {

        lpDesktopOld = lpStartupInfo->lpDesktop;

        lpStartupInfo->lpDesktop =
                 (LPWSTR)((PRTL_USER_PROCESS_PARAMETERS)NtCurrentPeb()->
                     ProcessParameters)->DesktopInfo.Buffer;

        Status = BaseCheckVDMp(
                              BinaryType,
                              lpApplicationName,
                              lpCommandLine,
                              lpCurrentDirectory,
                              pAnsiStringEnv,
                              m,
                              iTask,
                              dwCreationFlags,
                              lpStartupInfo,
                              hUserToken
                             );

        if (!NT_SUCCESS(Status)) {
            lpStartupInfo->lpDesktop = lpDesktopOld;
        }
   } else if (Status == STATUS_VDM_DISALLOWED) {
       UNICODE_STRING UnicodeString;
       ULONG_PTR ErrorParameters[2];
       ULONG ErrorResponse;

       RtlInitUnicodeString(&UnicodeString, lpApplicationName);
       ErrorParameters[0] = (ULONG_PTR)&UnicodeString;
       NtRaiseHardError(
         STATUS_VDM_DISALLOWED,
         1,                // 1 parameter
         1,                // ParameterStringMask
         ErrorParameters,
         OptionOk,
         &ErrorResponse
         );
   }

   return Status;
}


BOOL
BaseUpdateVDMEntry(
    IN ULONG UpdateIndex,
    IN OUT HANDLE *WaitHandle,
    IN ULONG IndexInfo,
    IN ULONG BinaryType
    )
{
    NTSTATUS Status;
    BASE_API_MSG m;
    PBASE_UPDATE_VDM_ENTRY_MSG c = &m.u.UpdateVDMEntry;

    switch (UpdateIndex) {
        case UPDATE_VDM_UNDO_CREATION:
            c->iTask = HandleToUlong(*WaitHandle);
            c->VDMCreationState = (USHORT)IndexInfo;
            break;
        case UPDATE_VDM_PROCESS_HANDLE:
            c->VDMProcessHandle = *WaitHandle;  // Actually this is VDM handle
            c->iTask = IndexInfo;
            break;
        }

    // VadimB: this ConsoleHandle is of no consequence to the
    // shared wow tracking mechanism

    if(BinaryType == BINARY_TYPE_WIN16)
        c->ConsoleHandle = (HANDLE)-1;
    else if (c->iTask)
        c->ConsoleHandle = 0;
    else
        c->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;

    c->EntryIndex = (WORD)UpdateIndex;
    c->BinaryType = BinaryType;


    Status = CsrClientCallServer(
                      (PCSR_API_MSG)&m,
                      NULL,
                      CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                           BasepUpdateVDMEntry
                                         ),
                      sizeof( *c )
                      );

    if (!NT_SUCCESS(Status) || !NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
        BaseSetLastNTError((NTSTATUS)m.ReturnValue);
        return FALSE;
        }

    switch (UpdateIndex) {
        case UPDATE_VDM_UNDO_CREATION:
            break;
        case UPDATE_VDM_PROCESS_HANDLE:
            *WaitHandle = c->WaitObjectForParent;
            break;
    }
    return TRUE;
}




ULONG
BaseIsDosApplication(
    IN PUNICODE_STRING PathName,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    Determines if app is a ".com" or a ".pif" type of app
    by looking at the extension, and the Status from NtCreateSection
    for PAGE_EXECUTE.

Arguments:

    PathName    -- Supplies a pointer to the path string
    Status      -- Status code from CreateSection call
    bNewConsole -- Pif can exec only from a new console

Return Value:

    file is a com\pif dos application
    SCS_DOS_BINARY - ".com", may also be a .exe extension
    SCS_PIF_BINARY - ".pif"


    0 -- file is not a dos application, may be a .bat or .cmd file

--*/
{
    UNICODE_STRING String;

         // check for .com extension
    String.Length = BaseDotComSuffixName.Length;
    String.Buffer = &(PathName->Buffer[(PathName->Length - String.Length) /
                    sizeof(WCHAR)]);

    if (RtlEqualUnicodeString(&String, &BaseDotComSuffixName, TRUE))
        return BINARY_TYPE_DOS_COM;


        // check for .pif extension
    String.Length = BaseDotPifSuffixName.Length;
    String.Buffer = &(PathName->Buffer[(PathName->Length - String.Length) /
                    sizeof(WCHAR)]);

    if (RtlEqualUnicodeString(&String, &BaseDotPifSuffixName, TRUE))
        return BINARY_TYPE_DOS_PIF;


        // check for .exe extension
    String.Length = BaseDotExeSuffixName.Length;
    String.Buffer = &(PathName->Buffer[(PathName->Length - String.Length) /
        sizeof(WCHAR)]);

    if (RtlEqualUnicodeString(&String, &BaseDotExeSuffixName, TRUE))
        return BINARY_TYPE_DOS_EXE;

    return 0;
}



BOOL
BaseGetVdmConfigInfo(
    IN  LPCWSTR CommandLine,
    IN  ULONG   DosSeqId,
    IN  ULONG   BinaryType,
    IN  PUNICODE_STRING CmdLineString,
    IN OUT PULONG VdmSize
    )
/*++

Routine Description:

    This routine locates the VDM configuration information for Wow vdms in
    the system configuration file.  It also reconstructs the commandline so
    that we can start the VDM.  The new command line is composed from the
    information in the configuration file + the old command line.

Arguments:

    CommandLine -- pointer to a string pointer that is used to pass the
        command line string

    DosSeqId - new console session id. This parameter is also valid for
               shared wow as it is passed to ntvdm as -i parameter. Another
               parameter to identify shared wow is passed to ntvdm as
               '-ws' where 'w' stands for wow app, 's' stands for separate
               In response to this 's' parameter ntvdm launches a
               separate wow (one-time shot). By default, ntvdm starts a shared
               wow.

    VdmSize --entry:
              return: the size in bytes of the VDM to be created

    BinaryType - dos, sharedwow, sepwow


Return Value:

    TRUE -- VDM configuration information was available
    FALSE -- VDM configuration information was not available

Notes:

--*/
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    PCH   pDst;
    WCHAR CmdLine[2*MAX_PATH];
    WCHAR szSystemDirectory[MAX_PATH];
    DWORD dwLen;

    CmdLineString->Buffer = NULL;
    *VdmSize = 16L*1024L*1024L;

    dwLen = GetSystemDirectoryW(szSystemDirectory,MAX_PATH);
    if(!dwLen || dwLen >= MAX_PATH) {
       SetLastError(ERROR_INVALID_NAME);
       return FALSE;
    }

    if (DosSeqId) {
#pragma prefast(suppress:53, the buffer is big enough (PREfast bug 775))
        _snwprintf(CmdLine,
                 sizeof(CmdLine)/sizeof(WCHAR),
                 L"\"%s\\ntvdm.exe\" -i%lx %s%c",
                 szSystemDirectory,
                 DosSeqId,
                 BinaryType != BINARY_TYPE_DOS? L"-w":L"",
                 BinaryType == BINARY_TYPE_SEPWOW? L's':L' '
                 );
        }
    else {
#pragma prefast(suppress:53, the buffer is big enough (PREfast bug 775))
        _snwprintf(CmdLine,
                 sizeof(CmdLine)/sizeof(WCHAR),
                 L"\"%s\\ntvdm.exe\"  %s%c",
                 szSystemDirectory,
                 BinaryType != BINARY_TYPE_DOS? L"-w":L"",
                 BinaryType == BINARY_TYPE_SEPWOW? L's':L'\0'
                 );
    }

    return RtlCreateUnicodeString(CmdLineString, CmdLine);
}


BOOL
BaseCheckForVDM(
    IN HANDLE hProcess,
    OUT LPDWORD lpExitCode
    )
{
    NTSTATUS Status;
    EVENT_BASIC_INFORMATION ebi;
    BASE_API_MSG m;
    PBASE_GET_VDM_EXIT_CODE_MSG a = &m.u.GetVDMExitCode;

    Status = NtQueryEvent (
                hProcess,
                EventBasicInformation,
                &ebi,
                sizeof(ebi),
                NULL);

    if(!NT_SUCCESS(Status)) {
        return FALSE;
    }

    a->ConsoleHandle = NtCurrentPeb()->ProcessParameters->ConsoleHandle;
    a->hParent = hProcess;
    Status = CsrClientCallServer(
                      (PCSR_API_MSG)&m,
                      NULL,
                      CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                      BasepGetVDMExitCode),
                      sizeof( *a )
                      );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    *lpExitCode = (DWORD)a->ExitCode;

    return TRUE;
}




DWORD
APIENTRY
GetShortPathNameA(
    IN  LPCSTR  lpszLongPath,
    IN  LPSTR   lpShortPath,
    IN  DWORD   cchBuffer
    )
{
    UNICODE_STRING  UString, UStringRet;
    ANSI_STRING     AString;
    NTSTATUS        Status;
    WCHAR           TempPathW[MAX_PATH];
    LPWSTR          lpShortPathW = NULL;
    DWORD           ReturnValue;
    DWORD           ReturnValueW;

    if (lpszLongPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
        }
    // We have to initialize it before the "try" statement
    AString.Buffer = NULL;
    UString.Buffer = NULL;

    ReturnValue = 0;
    ReturnValueW = 0;

    try {
        if (!Basep8BitStringToDynamicUnicodeString(&UString, lpszLongPath )) {
            goto gspTryExit;
            }

        // we have to get the real converted path in order to find out
        // the required length. An UNICODE char does not necessarily convert
        // to one ANSI char(A DBCS is basically TWO ANSI char!!!!!).
        // First, we use the buffer allocated from the stack. If the buffer
        // is too small, we then allocate it from heap.
        // A check of (lpShortPathW && TempPathW != lpShortPathW) will reveal
        // if we have allocated a buffer from heap and need to release it.
        lpShortPathW = TempPathW;
        ReturnValueW = GetShortPathNameW(UString.Buffer, lpShortPathW, sizeof(TempPathW) / sizeof(WCHAR));
        if (ReturnValueW >= sizeof(TempPathW) / sizeof(WCHAR))
            {
            // the stack-based buffer is too small. Allocate a new buffer
            // from heap.
            lpShortPathW = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                        ReturnValueW * sizeof(WCHAR)
                                        );
            if (lpShortPathW) {
                ReturnValueW = GetShortPathNameW(UString.Buffer, lpShortPathW, ReturnValueW);
                }
            else {
                ReturnValueW = 0;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                }
            }

        if (ReturnValueW)
            {
            // we are here because we have something interesting left to do.
            // Convert the UNICODE path name to ANSI(or OEM).
            UString.MaximumLength = (USHORT)((ReturnValueW + 1) * sizeof(WCHAR));
            UStringRet.Buffer = lpShortPathW;
            UStringRet.Length = (USHORT)(ReturnValueW * sizeof(WCHAR));
            Status = BasepUnicodeStringTo8BitString(&AString,
                                                    &UStringRet,
                                                    TRUE
                                                    );

            if (!NT_SUCCESS(Status))
                {
                BaseSetLastNTError(Status);
                ReturnValue=0;
                goto gspTryExit;
                }
            // now AString.Length contains the size of the converted path
            // name. If the caller provides enough buffer, copy the
            // path name.
            ReturnValue = AString.Length;
            if (ARGUMENT_PRESENT(lpShortPath) && cchBuffer > ReturnValue)
                {
                RtlMoveMemory(lpShortPath, AString.Buffer, ReturnValue);
                // terminate the string with NULL char
                lpShortPath[ReturnValue] = '\0';
                }
            else
                {
                // either the caller does not provide a buffer or
                // the provided buffer is too small return the required size,
                // including the terminated null char
                ReturnValue++;
                }
            }
gspTryExit:;
        }

    finally {
            if (UString.Buffer)
                RtlFreeUnicodeString(&UString);
            if (AString.Buffer)
                RtlFreeAnsiString(&AString);
            if (lpShortPathW && lpShortPathW != TempPathW)
                RtlFreeHeap(RtlProcessHeap(), 0, lpShortPathW);
        }
    return ReturnValue;
}
/****
GetShortPathName

Description:
    This function converts the given path name to its short form if
     needed. The conversion  may not be necessary and in that case,
     this function simply copies down the given name to the return buffer.
    The caller can have the return buffer set equal to the given path name
     address.

Parameters:
    lpszLongPath -  Points to a NULL terminated string.
    lpszShortPath - Buffer address to return the short name.
    cchBuffer - Buffer size in char of lpszShortPath.

Return Value
    If the GetShortPathName function succeeds, the return value is the length,
    in characters, of the string copied to lpszShortPath,
    not including the terminating
    null character.

    If the lpszShortPath is too small, the return value is
    the size of the buffer, in
    characters, required to hold the path.

    If the function fails, the return value is zero. To get
    extended error information, use
    the GetLastError function.

Remarks:
    The "short name" can be longer than its "long name". lpszLongPath doesn't
    have to be a fully qualified path name or a long path name.

****/

DWORD
APIENTRY
GetShortPathNameW(
    IN  LPCWSTR lpszLongPath,
    IN  LPWSTR  lpszShortPath,
    IN  DWORD   cchBuffer
    )
{

    LPCWSTR         pcs;
    LPWSTR          pSrcCopy, pSrc, pFirst, pLast, pDst;
    WCHAR           wch;
    HANDLE          FindHandle;
    WIN32_FIND_DATAW        FindData;
    LPWSTR          Buffer;
    DWORD           ReturnLen=0, Length;
    UINT PrevErrorMode;
    if (!ARGUMENT_PRESENT(lpszLongPath)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
        }

    //
    // override the error mode since we will be touching the media.
    // This is to prevent file system's pop-up when the given path does not
    // exist or the media is not available.
    // we are doing this because we can not depend on the caller's current
    // error mode. NOTE: the old error mode must be restored.
    PrevErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    try {
        Buffer = NULL;
        pSrcCopy = NULL;
        // first, make sure the given path exist
        if (0xFFFFFFFF == GetFileAttributesW(lpszLongPath))
        {
            //
            // (bjm - 3/17/99)
            // This behavior (failing if the file does not exist) is new (to NT) with NT 5.
            // (It's the Win9x behavior.)
            // Give an exception to Norton AntiVirus Uninstall.
            // If we fail this call, there will be a registry value left behind in VDD that'll cause
            // undeserved ugly messages for a user.  Norton AV Uninstall counts on NT 4 behavior
            // which did not care if the file existed to do this conversion.  This was changed in
            // NT 5.0 to match Win9x behavior.
            //
            if ( !NtCurrentPeb() || !APPCOMPATFLAG(KACF_OLDGETSHORTPATHNAME) )
            {
                // last error has been set by GetFileAttributes
                ReturnLen = 0;
                goto gsnTryExit;
            }
        }

        pcs = SkipPathTypeIndicator_U(lpszLongPath);
        if (!pcs || *pcs == UNICODE_NULL || !FindLFNorSFN_U((LPWSTR)pcs, &pFirst, &pLast, TRUE))
            {
            // nothing to convert, copy down the source string
            // to the buffer if necessary

            ReturnLen = wcslen(lpszLongPath);
            if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath))
                {
                if (lpszShortPath != lpszLongPath)
                    RtlMoveMemory(lpszShortPath, lpszLongPath,
                                  (ReturnLen + 1) * sizeof(WCHAR)
                                  );
                }
            else {
                // the caller does not provide enough buffer, return
                // necessary string length plus the terminated null char
                ReturnLen++;
                }
            goto gsnTryExit;
            }

        // conversions  are necessary, make a local copy of the string
        // because we have to party on it.

        ASSERT(!pSrcCopy);

        // get the source string length
        Length  = wcslen(lpszLongPath) + 1;

        pSrcCopy = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                   Length * sizeof(WCHAR)
                                   );
        if (!pSrcCopy) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto gsnTryExit;
            }
        wcsncpy(pSrcCopy, lpszLongPath, Length);
        // pFirst points to the first char of the very first LFN in the path
        // pLast points to the char right after the last char of the very
        // first LFN in the path. *pLast could be UNICODE_NULL
        pFirst = pSrcCopy + (pFirst - lpszLongPath);
        pLast = pSrcCopy  + (pLast - lpszLongPath);
        //
        // We allow lpszShortPath be overlapped with lpszLongPath so
        // allocate a local buffer.

        pDst = lpszShortPath;
        if (cchBuffer > 0 && ARGUMENT_PRESENT(lpszShortPath) &&
            (lpszShortPath >= lpszLongPath &&lpszShortPath < lpszLongPath + Length ||
             lpszShortPath < lpszLongPath && lpszShortPath + cchBuffer >= lpszLongPath))
            {
            ASSERT(!Buffer);

            Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                           cchBuffer * sizeof(WCHAR));
            if (!Buffer){
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto gsnTryExit;
            }
            pDst = Buffer;
        }

        pSrc = pSrcCopy;

        ReturnLen = 0;
        do {
            // there are three pointers involve in the conversion loop:
            // pSrc, pFirst and pLast. Their relationship
            // is:
            //
            // "c:\long~1.1\\foo.bar\\long~2.2\\bar"
            //  ^          ^          ^       ^
            //  |          |          |       |
            //  |          pSrc       pFirst  pLast
            //  pSrcCopy
            //
            // pSrcCopy always points to the very first char of the entire
            // path.
            //
            // chars between pSrc(included) and pFirst(not included)
            // do not need conversion so we simply copy them.
            // chars between pFirst(included) and pLast(not included)
            // need conversion.
            //
            Length = (ULONG)(pFirst - pSrc);
            if (Length) {
                ReturnLen += Length;
                if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath)) {
                    RtlMoveMemory(pDst, pSrc, Length * sizeof(WCHAR));
                    pDst += Length;
                    }
                }
            wch = *pLast;
            *pLast = UNICODE_NULL;
            FindHandle = FindFirstFileW(pSrcCopy, &FindData);
            *pLast = wch;
            if (INVALID_HANDLE_VALUE != FindHandle) {
                FindClose(FindHandle);
                // if no short name could be found, copy the original name.
                // the origian name starts with pFirst(included) and ends
                // with pLast(excluded).
                if (!(Length = wcslen(FindData.cAlternateFileName)))
                    Length = (ULONG)(pLast - pFirst);
                else
                    pFirst = FindData.cAlternateFileName;
                ReturnLen += Length;
                if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath))
                    {
                    RtlMoveMemory(pDst, pFirst, Length * sizeof(WCHAR));
                    pDst += Length;
                    }
                 }
            else {
                // part of the path does not exist, fail the function
                //
                ReturnLen = 0;
                break;
                }
            // move to next path name
            pSrc = pLast;
            if (*pLast == UNICODE_NULL)
                break;
            }while (FindLFNorSFN_U(pSrc, &pFirst, &pLast, TRUE));

        // if ReturnLen == 0, we fail somewhere inside while loop.
        if (ReturnLen) {
            // (*pSrc == UNICODE_NULL) means the last pathname is a LFN which
            // has been dealt with. otherwise, the substring pointed by
            // pSrc is a legal short path name and we have to copy it
            //Length could be zero
            Length = wcslen(pSrc);
            ReturnLen += Length;
            if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath))
                {
                //include the terminated null char
                RtlMoveMemory(pDst, pSrc, (Length + 1)* sizeof(WCHAR));
                if (Buffer)
                    RtlMoveMemory(lpszShortPath, Buffer, (ReturnLen + 1) * sizeof(WCHAR));
                }
            else
                // not enough buffer, the return value counts the terminated NULL
                ReturnLen++;
            }
gsnTryExit:;
        }
    finally {
         if (Buffer)
            RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
         if (pSrcCopy)
            RtlFreeHeap(RtlProcessHeap(), 0, pSrcCopy);

         // restore the error mode
         SetErrorMode(PrevErrorMode);
        }

    return ReturnLen;
}

/**
   function to create VDM environment for the new executable.
   Input:   lpEnvironmen = optinal environment strings prototype in UNICODE.
                           If it is NULL, this function use the environment
                           block attached to the process
            pAStringEnv  = pointer to a ANSI_STRING to receive the
                           new environment strings.
            pUStringEnv  = pointer to a UNICODE_STRING to receive the
                           new environment strings.
    Output: FALSE if the creattion failed.
            TRUE  creation successful, pAStringEnv has been setup.

    This function was provided so that BaseCheckVdm can have correct
    environment(includes the newly create NTVDM process). This was done
    because before command.com gets the next command, users can have
    tons of things specified in config.sys and autoexec.bat which
    may rely on current directory of each drive.
**/
BOOL BaseCreateVDMEnvironment(
    PWCHAR lpEnvironment,
    ANSI_STRING * pAStringEnv,
    UNICODE_STRING  *pUStringEnv
    )
{
    WCHAR  *pEnv, *pDst, *EnvStrings=NULL,* pTmp, *pNewEnv=NULL;
    DWORD   cchEnv, dw, Length, dwRemain;
    NTSTATUS    Status;
    UINT        NameType;
    BOOL        bRet = FALSE;
    SIZE_T      EnvSize;

    if (!ARGUMENT_PRESENT(pAStringEnv) || !ARGUMENT_PRESENT(pUStringEnv)){
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    try {
        // the environment strings are shared by every thread of the same
        // process. Since we have no idea of what the caller process
        // is, we have to grab the entire environment to our local buffer in one
        // shot then we can walk through the strings.
        // Note that if another thread makes call to RtlSetEnvironmentVariable
        // then we are out of sync. It is a problem of process structure and
        // I don't want to think about it now.
        // The funny thing is that we have to assume the environment
        // is a block of strings(otherwise, how can we do it?)t, nothing more and
        // nothing less. If someday and somebody dares to change it, he will be
        // the one to blame. If the caller(CreateProcess)
        // provides the environment, we assume it is safe to walk through it.
        //

        if (lpEnvironment == NULL) {
            // create a new environment and inherit the current process env
            Status = RtlCreateEnvironment(TRUE, (PVOID *)&EnvStrings);
            if (!NT_SUCCESS(Status))
                goto bveTryExit;
            }
        else
            EnvStrings = lpEnvironment;

        if (EnvStrings == NULL) {
            SetLastError(ERROR_BAD_ENVIRONMENT);
            goto bveTryExit;
            }
        // figure out how long the environment is
        // why can Rtl just provides such a function for us?
        //
        cchEnv = 0;
        pEnv = EnvStrings;
        // environment is double-null terminated
        while (!(*pEnv++ == UNICODE_NULL && *pEnv == UNICODE_NULL))
            cchEnv++;
        // count the last two NULLs
        cchEnv += 2;
        // we don't want to change the original environment, so
        // make a local buffer for it.
        EnvSize = (cchEnv + MAX_PATH) * sizeof(WCHAR);
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pNewEnv,
                                          0,
                                          &EnvSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS(Status) ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            pNewEnv = NULL;
            goto bveTryExit;
            }
        // give the last two for null
        dwRemain = MAX_PATH - 2;
        // now walk through the environment string
        pEnv = EnvStrings;
        // the new environmet will be
        pDst = pNewEnv;
        while (*pEnv != UNICODE_NULL) {
            // current directory environment has the form as:
            // "=d:=d:\pathname" where d: is the drive designator.
            if (pEnv[0] == L'=')
                {
                if ((pEnv[1] >= L'A' && pEnv[1] <= L'Z' || pEnv[1] >= L'a' && pEnv[1] <= L'z') &&
                     pEnv[2] == L':' && pEnv[3] == L'=' && wcslen(pEnv) >= 7)
                    {
                    // hack hack!!!!
                    // if the path points to the root directory,
                    // bypass the conversion. Dos or Wow keeps current directory
                    // for every valid drive. If we do the conversion for
                    // every current directory, it could take several
                    // seconds on removable drives, especially, on
                    // floppy drives.
                    if (pEnv[7] == UNICODE_NULL &&
                        (pEnv[6] == L'\\' || pEnv[6] == L'/') &&
                        pEnv[5] == L':' &&
                        (pEnv[4] >= L'A' && pEnv[4] <= L'Z' ||
                         pEnv[4] >= L'a' && pEnv[4] <= L'z'))
                        {
                        NameType = ENV_NAME_TYPE_NO_PATH;
                        }
                    else
                        {
                        // copy "=N:=", where N is the drive letter
                        *pDst++ = *pEnv++;*pDst++ = *pEnv++;
                        *pDst++ = *pEnv++;*pDst++ = *pEnv++;
                        NameType = ENV_NAME_TYPE_SINGLE_PATH;
                        }
                    }
                else {
                    // a weird environment was detected.
                    // treat it as no path
                    NameType = ENV_NAME_TYPE_NO_PATH;
                    }
                }
            else {
                pTmp = pEnv;
                // copy down the name and the '='
                while (*pEnv != UNICODE_NULL && (*pDst++ = *pEnv++) != L'=')
                    ;
                NameType = BaseGetEnvNameType_U(pTmp, (DWORD)(pEnv - pTmp) - 1);
                }

            if (NameType == ENV_NAME_TYPE_NO_PATH) {
                while ((*pDst++ = *pEnv++) != UNICODE_NULL)
                    ;
                }
            else if (NameType == ENV_NAME_TYPE_SINGLE_PATH) {
                    Length = wcslen(pEnv) + 1;
                    dw = GetShortPathNameW(pEnv, pDst, Length + dwRemain);
                    // if the conversion failed, we simply pass down the original
                    // one no matter what the reason is. This is done because we
                    // are doing the environment strings.
                    if (dw == 0 || dw >= Length + dwRemain){
                        RtlMoveMemory(pDst, pEnv, Length * sizeof(WCHAR));
                        dw = Length - 1;
                        }
                    pDst += dw + 1;
                    pEnv += Length;
                    if (dw > Length)
                        dwRemain -= dw - Length;
                    }
                 else {
                    // multiple path name found.
                    // the character ';' is used for seperator
                     pTmp = pEnv;
                     while(*pEnv != UNICODE_NULL) {
                        if (*pEnv == L';') {
                            // length not include the ';'
                            Length = (DWORD)(pEnv - pTmp);
                            if (Length > 0) {
                                *pEnv = UNICODE_NULL;
                                dw = GetShortPathNameW(pTmp, pDst, Length + 1 + dwRemain);
                                // again, if the conversion failed, use the original one
                                if (dw == 0 || dw > Length + dwRemain) {
                                    RtlMoveMemory(pDst, pTmp, Length * sizeof(WCHAR));
                                    dw = Length;
                                    }
                                pDst += dw;
                                *pDst++ = *pEnv++ = L';';
                                if (dw > Length)
                                    dwRemain -= dw - Length;
                                }
                             // skip all consecutive ';'
                             while (*pEnv == L';')
                                *pDst++ = *pEnv++;
                             pTmp = pEnv;
                             }
                        else
                            pEnv++;
                        }
                    // convert the last one
                    if ((Length = (DWORD)(pEnv - pTmp)) != 0) {
                        dw = GetShortPathNameW(pTmp, pDst, Length+1 + dwRemain);
                        if (dw == 0 || dw > Length) {
                            RtlMoveMemory(pDst, pTmp, Length * sizeof(WCHAR));
                            dw = Length;
                            }
                        pDst += dw;
                        if (dw > Length)
                            dwRemain -= dw - Length;
                        }
                    *pDst++ = *pEnv++;
                    }
            }
        *pDst++ = UNICODE_NULL;
        cchEnv = (ULONG)((ULONG_PTR)pDst - (ULONG_PTR)pNewEnv);
        pUStringEnv->MaximumLength = pUStringEnv->Length = (USHORT)cchEnv;
        pUStringEnv->Buffer = pNewEnv;
        Status = RtlUnicodeStringToAnsiString(pAStringEnv,
                                              pUStringEnv,
                                              TRUE
                                              );

        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
        } else {
            pNewEnv = NULL;
            bRet = TRUE;
        }
bveTryExit:;
        }
    finally {
        if (lpEnvironment == NULL && EnvStrings != NULL) {
            RtlDestroyEnvironment(EnvStrings);
        }
        if (pNewEnv != NULL) {
            pUStringEnv->Length = pUStringEnv->MaximumLength = 0;
            pUStringEnv->Buffer = NULL;
            pAStringEnv->Length = pAStringEnv->MaximumLength = 0;
            pAStringEnv->Buffer = NULL;
            EnvSize = 0;
            Status = NtFreeVirtualMemory (NtCurrentProcess(),
                                          &pNewEnv,
                                          &EnvSize,
                                          MEM_RELEASE);
            ASSERT (NT_SUCCESS (Status));
        }
    }
    return bRet;
}
/**
    Destroy the environment block created by BaseCreateVDMEnvironment
    Input: ANSI_STRING * pAnsiStringVDMEnv
                      Environment block in ANSI, should be freed via
                      RtlFreeAnsiString
           UNICODE_STRING * pUnicodeStringEnv
                      Environment block in UNICODE. The Buffer should
                      be freed with RtlFreeHeap.
    Output: should always be TRUE.

**/

BOOL
BaseDestroyVDMEnvironment(
    ANSI_STRING *pAStringEnv,
    UNICODE_STRING *pUStringEnv
    )
{
    if (pAStringEnv->Buffer)
        RtlFreeAnsiString(pAStringEnv);
    if (pUStringEnv->Buffer) {
        NTSTATUS Status;
        SIZE_T RegionSize;

        //
        // Free the specified environment variable block.
        //

        RegionSize = 0;
        Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                      &pUStringEnv->Buffer,
                                      &RegionSize,
                                      MEM_RELEASE
                                    );
    }
    return TRUE;

}

/**
    This function returns the name type of the given environment variable name
    The name type has three possibilities. Each one represents if the
    given name can have pathnames as its value.
     ENV_NAME_TYPE_NO_PATH:   no pathname can be its value
     ENV_NAME_TYPE_SINGLE_PATH: single pathname
     ENV_NAME_MULTIPLE_PATH: multiple path


    SIDE NOTE:
        Currently, nt can not installed on a long path and it seems
        that systemroot and windir are never be in long path.

**/
UINT
BaseGetEnvNameType_U(WCHAR * Name, DWORD NameLength)
{


// so far we only take care of five predefined names:
// PATH
// WINDIR and
// SYSTEMROOT.
// TEMP
// TMP
//
static ENV_INFO     EnvInfoTable[STD_ENV_NAME_COUNT] = {
    {ENV_NAME_TYPE_MULTIPLE_PATH, ENV_NAME_PATH_LEN, ENV_NAME_PATH},
    {ENV_NAME_TYPE_SINGLE_PATH, ENV_NAME_WINDIR_LEN, ENV_NAME_WINDIR},
    {ENV_NAME_TYPE_SINGLE_PATH, ENV_NAME_SYSTEMROOT_LEN, ENV_NAME_SYSTEMROOT},
    {ENV_NAME_TYPE_MULTIPLE_PATH, ENV_NAME_TEMP_LEN, ENV_NAME_TEMP},
    {ENV_NAME_TYPE_MULTIPLE_PATH, ENV_NAME_TMP_LEN, ENV_NAME_TMP}
    };



   UINT NameType;
   int  i;


    NameType = ENV_NAME_TYPE_NO_PATH;
    for (i = 0; i < STD_ENV_NAME_COUNT; i++) {
        if (EnvInfoTable[i].NameLength == NameLength &&
            !_wcsnicmp(EnvInfoTable[i].Name, Name, NameLength)) {
            NameType = EnvInfoTable[i].NameType;
            break;
            }
        }
    return NameType;
}


DWORD
APIENTRY
GetLongPathNameA(
    IN  LPCSTR  lpszShortPath,
    IN  LPSTR   lpLongPath,
    IN  DWORD   cchBuffer
    )
{
    UNICODE_STRING  UString, UStringRet;
    ANSI_STRING     AString;
    NTSTATUS        Status;
    LPWSTR          lpLongPathW = NULL;
    WCHAR           TempPathW[MAX_PATH];
    DWORD           ReturnValue, ReturnValueW;


    if (lpszShortPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
        }

    AString.Buffer = NULL;
    UString.Buffer = NULL;

    ReturnValue = 0;
    ReturnValueW = 0;

    try {
        if (!Basep8BitStringToDynamicUnicodeString(&UString, lpszShortPath )) {
            goto glpTryExit;
            }

        // we have to get the real converted path in order to find out
        // the required length. An UNICODE char does not necessarily convert
        // to one ANSI char(A DBCS is basically TWO ANSI char!!!!!).
        // First, we use the buffer allocated from the stack. If the buffer
        // is too small, we then allocate it from heap.
        // A check of (lpLongPathW && TempPathW != lpLongPathW) will reveal
        // if we have allocated a buffer from heap and need to release it.
        lpLongPathW = TempPathW;
        ReturnValueW = GetLongPathNameW(UString.Buffer, lpLongPathW, sizeof(TempPathW) / sizeof(WCHAR));
        if (ReturnValueW >= sizeof(TempPathW) / sizeof(WCHAR))
            {
            // the stack-based buffer is too small. Allocate a new buffer
            // from heap.
            lpLongPathW = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                        ReturnValueW * sizeof(WCHAR)
                                        );
            if (lpLongPathW) {
                ReturnValueW = GetLongPathNameW(UString.Buffer, lpLongPathW, ReturnValueW);
                }
            else {
                ReturnValueW = 0;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                }
            }

        if (ReturnValueW)
            {
            // we are here because we have something interesting left to do.
            // Convert the UNICODE path name to ANSI(or OEM).
            UString.MaximumLength = (USHORT)((ReturnValueW + 1) * sizeof(WCHAR));
            UStringRet.Buffer = lpLongPathW;
            UStringRet.Length = (USHORT)(ReturnValueW * sizeof(WCHAR));
            Status = BasepUnicodeStringTo8BitString(&AString,
                                                    &UStringRet,
                                                    TRUE
                                                    );

            if (!NT_SUCCESS(Status))
                {
                BaseSetLastNTError(Status);
                ReturnValue=0;
                goto glpTryExit;
                }
            // now AString.Length contains the size of the converted path
            // name. If the caller provides enough buffer, copy the
            // path name.
            ReturnValue = AString.Length;
            if (ARGUMENT_PRESENT(lpLongPath) && cchBuffer > ReturnValue)
                {
                RtlMoveMemory(lpLongPath, AString.Buffer, ReturnValue);
                // terminate the buffer with NULL char.
                lpLongPath[ReturnValue] = '\0';
                }
            else
                {
                // either the caller does not provide a buffer or
                // the provided buffer is too small, return the required size,
                // including the terminated null char.
                ReturnValue++;
                }
            }
glpTryExit:;
        }

    finally {
            if (UString.Buffer)
                RtlFreeUnicodeString(&UString);
            if (AString.Buffer)
                RtlFreeAnsiString(&AString);
            if (lpLongPathW && lpLongPathW != TempPathW)
                RtlFreeHeap(RtlProcessHeap(), 0, lpLongPathW);
        }
    return ReturnValue;
}

DWORD
APIENTRY
GetLongPathNameW(
    IN  LPCWSTR lpszShortPath,
    IN  LPWSTR  lpszLongPath,
    IN  DWORD   cchBuffer
)
{

    LPCWSTR pcs;
    DWORD ReturnLen, Length;
    LPWSTR pSrc, pSrcCopy, pFirst, pLast, Buffer, pDst;
    WCHAR   wch;
    HANDLE          FindHandle;
    WIN32_FIND_DATAW        FindData;
    UINT PrevErrorMode;

    if (!ARGUMENT_PRESENT(lpszShortPath)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
        }
    //
    // override the error mode since we will be touching the media.
    // This is to prevent file system's pop-up when the given path does not
    // exist or the media is not available.
    // we are doing this because we can not depend on the caller's current
    // error mode. NOTE: the old error mode must be restored.
    PrevErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    try {

        Buffer = NULL;
        pSrcCopy = NULL;
        // first make sure the given path exist.
        //
        if (0xFFFFFFFF == GetFileAttributesW(lpszShortPath))
        {
            // last error has been set by GetFileAttributes
            ReturnLen = 0;
            goto glnTryExit;
        }
        pcs = SkipPathTypeIndicator_U(lpszShortPath);
        if (!pcs || *pcs == UNICODE_NULL || !FindLFNorSFN_U((LPWSTR)pcs, &pFirst, &pLast, FALSE))
            {
            // The path is ok and does not need conversion at all.
            // Check if we need to do copy
            ReturnLen = wcslen(lpszShortPath);
            if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszLongPath))
                {
                if (lpszLongPath != lpszShortPath)
                    RtlMoveMemory(lpszLongPath, lpszShortPath,
                                      (ReturnLen + 1)* sizeof(WCHAR)
                                      );
                }
            else {
                // No buffer or buffer too small, the return size
                // has to count the terminated NULL char
                ReturnLen++;
                }
            goto glnTryExit;
            }


        // conversions  are necessary, make a local copy of the string
        // because we have to party on it.

        ASSERT(!pSrcCopy);

        Length = wcslen(lpszShortPath) + 1;
        pSrcCopy = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                   Length * sizeof(WCHAR)
                                   );
        if (!pSrcCopy) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto glnTryExit;
            }
        RtlMoveMemory(pSrcCopy, lpszShortPath, Length * sizeof(WCHAR));
        // pFirst points to the first char of the very first SFN in the path
        // pLast points to the char right after the last char of the very
        // first SFN in the path. *pLast could be UNICODE_NULL
        pFirst = pSrcCopy + (pFirst - lpszShortPath);
        pLast = pSrcCopy + (pLast - lpszShortPath);
        //
        // We allow lpszShortPath be overlapped with lpszLongPath so
        // allocate a local buffer if necessary:
        // (1) the caller does provide a legitimate buffer and
        // (2) the buffer overlaps with lpszShortName

        pDst = lpszLongPath;
        if (cchBuffer && ARGUMENT_PRESENT(lpszLongPath) &&
            (lpszLongPath >= lpszShortPath && lpszLongPath < lpszShortPath + Length ||
             lpszLongPath < lpszShortPath && lpszLongPath + cchBuffer >= lpszShortPath))
            {
            ASSERT(!Buffer);

            Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                           cchBuffer * sizeof(WCHAR));
            if (!Buffer){
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto glnTryExit;
                }
            pDst = Buffer;
            }

        pSrc = pSrcCopy;
        ReturnLen = 0;
        do {
            // there are three pointers involve in the conversion loop:
            // pSrc, pFirst and pLast. Their relationship
            // is:
            //
            // "c:\long~1.1\\foo.bar\\long~2.2\\bar"
            //  ^          ^          ^       ^
            //  |          |          |       |
            //  |          pSrc       pFirst  pLast
            //  pSrcCopy
            //
            // pSrcCopy always points to the very first char of the entire
            // path.
            //
            // chars between pSrc(included) and pFirst(not included)
            // do not need conversion so we simply copy them.
            // chars between pFirst(included) and pLast(not included)
            // need conversion.
            //
            Length = (ULONG)(pFirst - pSrc);
            ReturnLen += Length;
            if (Length && cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszShortPath))
                {
                RtlMoveMemory(pDst, pSrc, Length * sizeof(WCHAR));
                pDst += Length;
                }
            // now try to convert the name, chars between pFirst and (pLast - 1)
            wch = *pLast;
            *pLast = UNICODE_NULL;
            FindHandle = FindFirstFileW(pSrcCopy, &FindData);
            *pLast = wch;
            if (FindHandle != INVALID_HANDLE_VALUE){
                FindClose(FindHandle);
                // if no long name, copy the original name
                // starts with pFirst(included) and ends with pLast(excluded)
                if (!(Length = wcslen(FindData.cFileName)))
                    Length = (ULONG)(pLast - pFirst);
                else
                    pFirst = FindData.cFileName;
                ReturnLen += Length;
                if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszLongPath))
                    {
                    RtlMoveMemory(pDst, pFirst, Length * sizeof(WCHAR));
                    pDst += Length;
                    }
                }
            else {
                // invalid path, reset the length, mark the error and
                // bail out of the loop. We will be copying the source
                // to destination later.
                //
                ReturnLen = 0;
                break;
                }
            pSrc = pLast;
            if (*pSrc == UNICODE_NULL)
                break;
            } while (FindLFNorSFN_U(pSrc, &pFirst, &pLast, FALSE));

        if (ReturnLen) {
            //copy the rest of the path from pSrc. This may only contain
            //a single NULL char
            Length = wcslen(pSrc);
            ReturnLen += Length;
            if (cchBuffer > ReturnLen && ARGUMENT_PRESENT(lpszLongPath))
                {
                RtlMoveMemory(pDst, pSrc, (Length + 1) * sizeof(WCHAR));
                if (Buffer)
                    RtlMoveMemory(lpszLongPath, Buffer, (ReturnLen + 1) * sizeof(WCHAR));
                }
            else
                ReturnLen++;
            }

glnTryExit:
        ;
        }
        finally {
            if (pSrcCopy)
                RtlFreeHeap(RtlProcessHeap(), 0, pSrcCopy);
            if (Buffer)
                RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
            }

    // restore error mode.
    SetErrorMode(PrevErrorMode);
    return ReturnLen;
}

/**
    Search for SFN(Short File Name) or LFN(Long File Name) in the
    given path depends on FindLFN.

    Input: LPWSTR Path
                The given path name. Does not have to be fully qualified.
                However, path type separaters are not allowed.
           LPWSTR* ppFirst
                To return the pointer points to the first char
                of the name found.
           LPWSTR* ppLast
                To return the pointer points the char right after
                the last char of the name found.
           BOOL FindLFN
                TRUE to search for LFN, otherwise, search for SFN

    Output:
            TRUE
                if the target file name type is found, ppFirst and
                ppLast are filled with pointers.
            FALSE
                if the target file name type not found.

    Remark: "\\." and "\\.." are special cases. When encountered, they
            are ignored and the function continue to search


**/
BOOL
FindLFNorSFN_U(
    LPWSTR  Path,
    LPWSTR* ppFirst,
    LPWSTR* ppLast,
    BOOL    FindLFN
    )
{
    LPWSTR pFirst, pLast;
    BOOL TargetFound;

    ASSERT(Path);

    pFirst = Path;

    TargetFound = FALSE;

    while(TRUE) {
        //skip over leading path separator
        // it is legal to have multiple path separators in between
        // name such as "foobar\\\\\\multiplepathchar"
        while (*pFirst != UNICODE_NULL  && (*pFirst == L'\\' || *pFirst == L'/'))
            pFirst++;
        if (*pFirst == UNICODE_NULL)
            break;
        pLast = pFirst + 1;
        while (*pLast != UNICODE_NULL && *pLast != L'\\' && *pLast != L'/')
            pLast++;
        if (FindLFN)
            TargetFound = !IsShortName_U(pFirst, (int)(pLast - pFirst));
        else
            TargetFound = !IsLongName_U(pFirst, (int)(pLast - pFirst));
        if (TargetFound) {
            if(ppFirst && ppLast) {
                *ppFirst = pFirst;
                // pLast point to the last char of the path/file name
                *ppLast = pLast;
                }
            break;
            }
        if (*pLast == UNICODE_NULL)
            break;
        pFirst = pLast + 1;
        }
    return TargetFound;
}
LPCWSTR
SkipPathTypeIndicator_U(
    LPCWSTR Path
    )
{
    RTL_PATH_TYPE   RtlPathType;
    LPCWSTR         pFirst;
    DWORD           Count;

    RtlPathType = RtlDetermineDosPathNameType_U(Path);
    switch (RtlPathType) {
        // form: "\\server_name\share_name\rest_of_the_path"
        case RtlPathTypeUncAbsolute:
        case RtlPathTypeLocalDevice:
            pFirst = Path + 2;
            Count = 2;
            // guard for UNICODE_NULL is necessary because
            // RtlDetermineDosPathNameType_U doesn't really
            // verify an UNC name.
            while (Count && *pFirst != UNICODE_NULL) {
                if (*pFirst == L'\\' || *pFirst == L'/')
                    Count--;
                pFirst++;
                }
            break;

        // form: "\\."
        case RtlPathTypeRootLocalDevice:
            pFirst = NULL;
            break;

        // form: "D:\rest_of_the_path"
        case RtlPathTypeDriveAbsolute:
            pFirst = Path + 3;
            break;

        // form: "D:rest_of_the_path"
        case RtlPathTypeDriveRelative:
            pFirst = Path + 2;
            break;

        // form: "\rest_of_the_path"
        case RtlPathTypeRooted:
            pFirst = Path + 1;
            break;

        // form: "rest_of_the_path"
        case RtlPathTypeRelative:
            pFirst = Path;
            break;

        default:
            pFirst = NULL;
            break;
        }
    return pFirst;
}

/**
    This function determines if the given name is a valid short name.
    This function only does "obvious" testing since there are not precise
    ways to cover all the file systems(each file system has its own
    file name domain(for example, FAT allows all extended chars and space char
    while NTFS **may** not).
    The main purpose is to help the caller decide if a long to short name
    conversion is necessary. When in doubt, this function simply tells the
    caller that the given name is NOT a short name so that caller would
    do whatever it takes to convert the name.
    This function applies strict rules in deciding if the given name
    is a valid short name. For example, a name containing any extended chars
    is treated as invalid; a name with embedded space chars is also treated
    as invalid.
    A name is a valid short name if ALL the following conditions are met:
    (1). total length <= 13.
    (2). 0 < base name length <= 8.
    (3). extention name length <= 3.
    (4). only one '.' is allowed and must not be the first char.
    (5). every char must be legal defined by the IllegalMask array.

    null path, "." and ".." are treated valid.

    Input: LPCWSTR Name -  points to the name to be checked. It does not
                           have to be NULL terminated.

           int Length - Length of the name, not including teminated NULL char.

    output: TRUE - if the given name is a short file name.
            FALSE - if the given name is not a short file name
**/

// bit set -> char is illegal
DWORD   IllegalMask[] =

{
    // code 0x00 - 0x1F --> all illegal
    0xFFFFFFFF,
    // code 0x20 - 0x3f --> 0x20,0x22,0x2A-0x2C,0x2F and 0x3A-0x3F are illegal
    0xFC009C05,
    // code 0x40 - 0x5F --> 0x5B-0x5D are illegal
    0x38000000,
    // code 0x60 - 0x7F --> 0x7C is illegal
    0x10000000
};

BOOL
IsShortName_U(
    LPCWSTR Name,
    int     Length
    )
{
    int Index;
    BOOL ExtensionFound;
    DWORD      dwStatus;
    UNICODE_STRING UnicodeName;
    ANSI_STRING AnsiString;
    UCHAR      AnsiBuffer[MAX_PATH];
    UCHAR      Char;

    ASSERT(Name);

    // total length must less than 13(8.3 = 8 + 1 + 3 = 12)
    if (Length > 12)
        return FALSE;
    //  "" or "." or ".."
    if (!Length)
        return TRUE;
    if (L'.' == *Name)
    {
        // "." or ".."
        if (1 == Length || (2 == Length && L'.' == Name[1]))
            return TRUE;
        else
            // '.' can not be the first char(base name length is 0)
            return FALSE;
    }

    UnicodeName.Buffer = (LPWSTR)Name;
    UnicodeName.Length =
    UnicodeName.MaximumLength = (USHORT)(Length * sizeof(WCHAR));

    AnsiString.Buffer = AnsiBuffer;
    AnsiString.Length = 0;
    AnsiString.MaximumLength = MAX_PATH; // make a dangerous assumption

    dwStatus = BasepUnicodeStringTo8BitString(&AnsiString,
                                              &UnicodeName,
                                              FALSE);
    if (! NT_SUCCESS(dwStatus)) {
         return(FALSE);
    }

    // all trivial cases are tested, now we have to walk through the name
    ExtensionFound = FALSE;
    for (Index = 0; Index < AnsiString.Length; Index++)
    {
        Char = AnsiString.Buffer[Index];

        // Skip over and Dbcs characters
        if (IsDBCSLeadByte(Char)) {
            //
            //  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte
            //     is in the dbcs leading byte range, it's error ( Index == 7 ). If the
            //     length of base part is more than 8 ( Index > 7 ), it's definitely error.
            //
            //  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading
            //     byte range, it's error
            //
            if ((!ExtensionFound && (Index >= 7)) ||
                (Index == AnsiString.Length - 1)) {
                return FALSE;
            }
            Index += 1;
            continue;
        }

        // make sure the char is legal
        if (Char > 0x7F || IllegalMask[Char / 32] & (1 << (Char % 32)))
            return FALSE;

        if ('.' == Char)
        {
            // (1) can have only one '.'
            // (2) can not have more than 3 chars following.
            if (ExtensionFound || Length - (Index + 1) > 3)
            {
                return FALSE;
            }
            ExtensionFound = TRUE;
        }
        // base length > 8 chars
        if (Index >= 8 && !ExtensionFound)
            return FALSE;
    }
    return TRUE;

}

/**
    This function determines if the given name is a valid long name.
    This function only does "obvious" testing since there are not precise
    ways to cover all the file systems(each file system has its own
    file name domain(for example, FAT allows all extended chars and space char
    while NTFS **may** not)
    This function helps the caller to determine if a short to long name
    conversion is necessary. When in doubt, this function simply tells the
    caller that the given name is NOT a long name so that caller would
    do whatever it takes to convert the name.
    A name is a valid long name if one of the following conditions is met:
    (1). total length >= 13.
    (2). 0 == base name length ||  base name length > 8.
    (3). extention name length > 3.
    (4). '.' is the first char.
    (5). muitlple '.'


    null path, "." and ".." are treat as valid long name.

    Input: LPCWSTR Name -  points to the name to be checked. It does not
                           have to be NULL terminated.

           int Length - Length of the name, not including teminated NULL char.

    output: TRUE - if the given name is a long file name.
            FALSE - if the given name is not a long file name
**/


BOOL
IsLongName_U(
    LPCWSTR Name,
    int Length
    )
{
    int Index;
    BOOL ExtensionFound;
    // (1) NULL path
    // (2) total length > 12
    // (3) . is the first char (cover "." and "..")
    if (!Length || Length > 12 || L'.' == *Name)
        return TRUE;
    ExtensionFound = FALSE;
    for (Index = 0; Index < Length; Index++)
    {
        if (L'.' == Name[Index])
        {
            // multiple . or extension longer than 3
            if (ExtensionFound || Length - (Index + 1) > 3)
                return TRUE;
            ExtensionFound = TRUE;
        }
        // base length longer than 8
        if (Index >= 8 && !ExtensionFound)
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\winlinks.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    winlink.c

Abstract:

    This module implements Win32 CreateHardLink

Author:

    Felipe Cabrera (cabrera) 28-Feb-1997

Revision History:

--*/

#include "basedll.h"

BOOL
APIENTRY
CreateHardLinkA(
    LPCSTR lpLinkName,
    LPCSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    ANSI thunk to CreateHardLinkW

--*/

{
    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodeExistingFileName;
    BOOL ReturnValue;

    Unicode = Basep8BitStringToStaticUnicodeString( lpLinkName );
    if (Unicode == NULL) {
        return FALSE;
    }
    
    if ( ARGUMENT_PRESENT(lpExistingFileName) ) {
        if (!Basep8BitStringToDynamicUnicodeString( &UnicodeExistingFileName, lpExistingFileName )) {
            return FALSE;
            }
        }
    else {
        UnicodeExistingFileName.Buffer = NULL;
        }

    ReturnValue = CreateHardLinkW((LPCWSTR)Unicode->Buffer, (LPCWSTR)UnicodeExistingFileName.Buffer, lpSecurityAttributes);

    RtlFreeUnicodeString(&UnicodeExistingFileName);

    return ReturnValue;
}


BOOL
APIENTRY
CreateHardLinkW(
    LPCWSTR lpLinkName,
    LPCWSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A file can be made to be a hard link to an existing file.
    The existing file can be a reparse point or not.

Arguments:

    lpLinkName - Supplies the name of a file that is to be to be made a hard link. As
        this is to be a new hard link, there should be no file or directory present
        with this name.

    lpExistingFileName - Supplies the name of an existing file that is the target for
        the hard link.
        
    lpSecurityAttributes - this is currently not used

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    UNICODE_STRING OldFileName;
    UNICODE_STRING NewFileName;
    PVOID FreeBuffer;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_LINK_INFORMATION NewName = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOLEAN ReturnValue = FALSE;

    //
    // Check to see that both names are present.
    //

    if ( !ARGUMENT_PRESENT(lpLinkName) ||
         !ARGUMENT_PRESENT(lpExistingFileName) ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    OldFileName.Buffer = NULL;
    NewFileName.Buffer = NULL;

    try {
        
        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpExistingFileName,
                                &OldFileName,
                                NULL,
                                NULL
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            __leave;
        }

        //
        // Initialize the object name.
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &OldFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        //
        // Account the inheritance of the security descriptor. Note: this argument has no effect currently
        //

        if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
            ObjectAttributes.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        }

        //
        // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior.
        // Thus, the hard link is established to the local entity, be it a reparse
        // point or not.
        //

        Status = NtOpenFile(
                     &FileHandle,
                     FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                     &ObjectAttributes,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_FLAG_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT
                     );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            __leave;
        }

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpLinkName,
                                &NewFileName,
                                NULL,
                                NULL
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            __leave;
        }

        NewName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), NewFileName.Length+sizeof(*NewName));

        if ( NewName == NULL ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        RtlMoveMemory(NewName->FileName, NewFileName.Buffer, NewFileName.Length);
        NewName->ReplaceIfExists = FALSE;
        NewName->RootDirectory = NULL;
        NewName->FileNameLength = NewFileName.Length;

        Status = NtSetInformationFile(
                     FileHandle,
                     &IoStatusBlock,
                     NewName,
                     NewFileName.Length+sizeof(*NewName),
                     FileLinkInformation
                     );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            __leave;
        }
            
        ReturnValue = TRUE;
    
    } finally {

        //
        // Cleanup allocate memory and handles
        //  

        if (NewName != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, NewName);
        }

        if (FileHandle != INVALID_HANDLE_VALUE) {
            NtClose( FileHandle );
        }

        if (NewFileName.Buffer != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, NewFileName.Buffer);
        }
        
        if (OldFileName.Buffer != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, OldFileName.Buffer);
        }
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\webbladep.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    webblade.h

Abstract:

    This module contains hash values for executable files 
    that are disallowed in the Web Blade SKU.
    
    It is envisoned that the array holding these hash values
    will be updated and kernel32.dll recompiled at the time 
    of a new product release. Hence the enforcement of an
    updated list of hashes.
    
    IMPORTANT: Please keep the array in sorted order since 
    the hash detection routines assume this property when 
    searching for a particular hash value in this array.
    
    Also, please update the Revision History to keep track of
    new hashes added/deleted for various releases/products.

Author:

    Vishnu Patankar (vishnup) 01-May-2001

Revision History:


--*/

#ifndef _WEBBLADE_
#define _WEBBLADE_

#include <base.h>
#include <search.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <string.h>

//
// MD5 hashes are of size 16 bytes
//

#define WEB_BLADE_MAX_HASH_SIZE 16


NTSTATUS WebBladepConvertStringizedHashToHash(
    IN OUT   PCHAR    pStringizedHash
    );

int
__cdecl pfnWebBladeHashCompare(
    const BYTE    *WebBladeFirstHash,
    const BYTE    *WebBladeSecondHash
    );


NTSTATUS
BasepCheckWebBladeHashes(
        IN HANDLE hFile
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\xx.c ===
#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    OutputDebugString("Thread Started\n");
    while(1);
}

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE Thread;
    DWORD ThreadId;
    DWORD st;

    Thread = CreateThread(NULL,0L,TestThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);

    Sleep(3000);
    OutputDebugString("Out of Sleep\n");

    TerminateThread(Thread,1);

    st = WaitForSingleObject(Thread,-1);
    assert(st == 0);

    assert(GetExitCodeThread(Thread,&st));
    assert(st = 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\winlzexp.c ===
/*
** winlzexp.c - Windows LZExpand library routines for manipulating compressed
**              files.
**
** Author:  DavidDi
*/


/*
** Notes:
** -----
**
** The LZInit() function returns either DOS handles or LZFile struct
** identifiers of some kind, depending upon how it is called.  The LZ
** functions LZSeek(), LZRead(), and LZClose() needed some way to
** differentiate between DOS file handles and the LZFile struct identifiers.
** As the functions stand now, they use DOS file handles as themselves, and
** table offsets as LZFile identifiers.  The table offsets are incremented by
** some base value, LZ_TABLE_BIAS, in order to push their values past all
** possible DOS file handle values.  The table offsets (- LZ_TABLE_BIAS) are
** used as indices in rghLZFileTable[] to retrieve a global handle to an
** LZFile struct.  The table of global handles is allocated statically from
** the DLL's data segment.  The LZFile struct's are allocated from global
** heap space and are moveable.  This scheme might also be implemented as a
** linked list of global handles.
**
** Now the resulting benefit from this scheme is that DOS file handles and
** LZFile struct identifiers can be differentiated, since DOS file handles
** are always < LZ_TABLE_BIAS, and LZFile struct identifiers are always
** >= LZ_TABLE_BIAS.  This dichotomy may be used in macros, like the sample
** ones provided in lzexpand.h, to select the appropriate function to call
** (e.g., LZSeek() or _llseek()) in order to avoid the overhead of an extra
** function call for uncompressed files.  LZSeek(), LZRead(), and LZClose()
** are, however, "smart" enough to figure out whether they are dealing with
** DOS file handles or table offsets, and take action appropriately.  As an
** extreme example, LZOpenFile(), LZSeek(), LZRead, and LZClose() can be used
** as replacements for OpenFile(), _llseek(), _lread(), and _lclose.  In this
** case, the program using the DLL functions could call them without ever
** caring whether the files it was reading were LZ compressed or not.
*/


/* WIN32 MODS

**  Since the above is a DOS only hack, I have to change the logic for
** for the 0-255 file handle deal'o.  The original code, tests greater than
** LZ_TABLE_BIAS for file structures.  What I will do, is convert file handles
** returned from OpenFile, to a range 0-255.  Once the test is complete, I'll
** use the file handle as an offset into a 255 element array, which will
** contain the WIN32 file handle.  So there will be an additional array
** fhWin32File[255], which will be allocated sequencially starting at 0.
** Unfortunately, this means everywhere the file handle is used, must be converted
*/

// Headers
///////////
#include <basedll.h>
#define LZA_DLL
#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"
#include "lzcommon.h"

#include "lzpriv.h"
#include "wchar.h"

#if DEBUG
#include "stdio.h"
#endif

// Globals
///////////

// table of handles to LZFile structs
HANDLE rghLZFileTable[MAX_LZFILES] = {0};

// next free entry in rghLZFileTable[]
static INT iNextLZFileEntry = 0;

HFILE fhWin32File[MAX_LZFILES] = {0};

/*
** int  APIENTRY LZInit(int hWin32File);
**
** Sets up LZFile struct for a file that has already been opened by
** OpenFile().
**
** Arguments:  hWin32File - source DOS file handle
**
** Returns:    int - LZFile struct table offset or DOS file handle if
**                   successful.  One of the LZERROR_ codes if unsuccessful.
**
** Globals:    iNextLZFile entry advanced, or returned to beginning from end.
*/
INT  APIENTRY LZInit(INT hWin32File)
{
   HANDLE hLZFile;            // handle to new LZFile struct
   LZFile *lpLZ;          // pointer to new LZFile struct
   FH FHComp;                 // header info structure from input file
   BOOL bHdr;                 // holds GetHdr() return value
   INT iTableIndex,           // holds rghLZFileTable[] slot to be filled by
                              //    new LZFile struct handle
       iStartEntry;           // original value of iNextLZFileEntry

   LONG cblInSize = 0;
   INT nRet;

   // Did the read succeed?
   if ((bHdr = GetHdr((FH *)&FHComp, hWin32File, &cblInSize)) != TRUE
       && cblInSize >= (LONG)HEADER_LEN) {

      return(LZERROR_BADINHANDLE);
   }

   // Check for uncompressed input file.
   if (bHdr != TRUE || IsCompressed(& FHComp) != TRUE)
   {
      // This is an uncompressed file - rewind it.
      if (FSEEK(hWin32File, 0L, SEEK_SET) != 0L) {
         return(LZERROR_BADINHANDLE);
      }
      else {
         // And return DOS file handle.
        return(ConvertWin32FHToDos(hWin32File));
     }
   }

   // Check compression algorithm used.
   if (RecognizeCompAlg(FHComp.byteAlgorithm) != TRUE) {
      return(LZERROR_UNKNOWNALG);
   }

   // Find next free rghLZFileTable[] entry.  N.b., we depend upon LZClose()
   // to free unused entries up.
   RtlEnterCriticalSection(&BaseLZSemTable);

   iStartEntry = iNextLZFileEntry;

   while (rghLZFileTable[iNextLZFileEntry] != NULL)
   {
      if (++iNextLZFileEntry >= MAX_LZFILES)
         // Return to beginning of table.
         iNextLZFileEntry = 0;

      if (iNextLZFileEntry == iStartEntry) {
         // We've gone full circle through rghLZFileTable[].
         // It's full, so bail out.
         nRet = LZERROR_GLOBALLOC;
         goto LZInitExit;
      }
   }

   // Keep track of the rghLZFileTable() slot to be filled by a handle to the
   // new LZFile struct.
   iTableIndex = iNextLZFileEntry;

   // Allocate global storage for the new LZFile struct, initializing all
   // fields to 0.

   hLZFile = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, (DWORD)sizeof(LZFile));
   if (!hLZFile) {

      nRet = LZERROR_GLOBALLOC;
      goto LZInitExit;
   }

   // Lock that baby up.
   if ((lpLZ = (LZFile *)GlobalLock(hLZFile)) == NULL)
   {
      GlobalFree(hLZFile);

      nRet =LZERROR_GLOBLOCK;
      goto LZInitExit;
   }

   // Initialize the new LZFile struct's general information fields.
   lpLZ->dosh = hWin32File;
   lpLZ->byteAlgorithm = FHComp.byteAlgorithm;
   lpLZ->wFlags = 0;
   lpLZ->cbulUncompSize = FHComp.cbulUncompSize;
   lpLZ->cbulCompSize = FHComp.cbulCompSize;
   lpLZ->lCurSeekPos = 0L;

   // LZRead/LZSeeks expansion data is kept on a per file basis
   lpLZ->pLZI = NULL;

   // Enter new handle in table of handles.
   rghLZFileTable[iTableIndex] = hLZFile;

   /* WIN32 NOTE, dont need convert below, as forces a non file handle
    * to the API.
    */

   GlobalUnlock(hLZFile);

   // Advance to next free entry.
   if (++iNextLZFileEntry >= MAX_LZFILES)
      iNextLZFileEntry = 0;

   nRet = LZ_TABLE_BIAS + iTableIndex;

LZInitExit:

   RtlLeaveCriticalSection(&BaseLZSemTable);

   // Return rghLZFileTable[] offset of the new LZFile struct's handle's
   // entry + the table bias.
   return(nRet);
}


/*
** int  APIENTRY GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer);
**
** Looks in the header of a compressed file to find its original expanded
** name.
**
** Arguments:  lpszSource - name of input file
**             lpszBuffer - pointer to a buffer that will be filled in with
**                          the expanded name of the compressed source file
**
** Returns:    int - TRUE if successful.  One of the LZERROR_ codes if
**                   unsuccessful.
**
** Globals:    none
*/
INT  APIENTRY GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer)
{
   INT doshSource,         // source DOS file handle
       bHdr;               // holds GetHdr() return value
   FH FHComp;              // header info structure from input file
   OFSTRUCT ofOpenBuf;     // source struct for OpenFile() call
   LONG cblInSize = 0;

   // Try to open the source file.
   if ((doshSource = (HFILE)MOpenFile(lpszSource, (LPOFSTRUCT)(& ofOpenBuf), OF_READ))
       == -1)
      return(LZERROR_BADVALUE);

   // Get the compressed file header.
   if ((bHdr = GetHdr((FH *)&FHComp, doshSource, &cblInSize)) != TRUE
       && cblInSize >= (LONG)HEADER_LEN)
   {
      FCLOSE(doshSource);
      return(LZERROR_BADVALUE);
   }

   // Close source file.
   FCLOSE(doshSource);

   // Return expanded name same as source name for uncompressed files.
   STRCPY(lpszBuffer, lpszSource);

   // Check for compressed input file.
   if (bHdr == TRUE && IsCompressed(& FHComp) == TRUE)
      MakeExpandedName(lpszBuffer, FHComp.byteExtensionChar);

   return(TRUE);
}

/*
** int  APIENTRY GetExpandedNameW(LPSTR lpszSource, LPSTR lpszBuffer);
**
** Wide Character version of GetExpandedName.  Converts the filename to
** the ANSI Character set and calls the ANSI version.
**
*/
INT  APIENTRY GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer)
{
    UNICODE_STRING TempW;
    ANSI_STRING TempA;
    NTSTATUS Status;
    NTSTATUS StatusR;
    CHAR szBuffer[MAX_PATH + 2];


    TempW.Buffer = lpszSource;
    TempW.Length = wcslen(lpszSource)*sizeof(WCHAR);
    TempW.MaximumLength = TempW.Length + sizeof(WCHAR);

    TempA.Buffer = szBuffer;
    TempA.MaximumLength = MAX_PATH;
    StatusR = RtlUnicodeStringToAnsiString(&TempA, &TempW, FALSE);
    if (!NT_SUCCESS(StatusR))
        return LZERROR_GLOBALLOC;

    Status = GetExpandedNameA(szBuffer, (LPSTR)lpszBuffer);

    if (Status != -1) {
        szBuffer[MAX_PATH] = ANSI_NULL;
        lstrcpyn(szBuffer, (LPSTR)lpszBuffer, sizeof(szBuffer));
        if (szBuffer[MAX_PATH]) {
            return LZERROR_BADVALUE;
        }
        TempA.Length = (USHORT) strlen(szBuffer);
        TempA.MaximumLength = TempA.Length+sizeof(CHAR);

        TempW.Buffer = lpszBuffer;
        TempW.MaximumLength = MAX_PATH;
        StatusR = RtlAnsiStringToUnicodeString(&TempW, &TempA, FALSE);
        if (!NT_SUCCESS(StatusR))
            return LZERROR_GLOBALLOC;
    }

    return Status;
}


//
// INT  LZCreateFileW(LPCWSTR lpFileName, DWORD fdwAccess)
//
// Opens a file (using CreateFile) and sets up an LZFile struct for
// expanding it.
//
// Arguments:  lpFileName  - name of input file
//             fdwAccess   - CreateFile access type - (e.g. GENERIC_READ)
//             fdwShareMode - Share mode  - (e.g. FILE_SHARE_READ)
//             fdwCreate - Action to be taken - (e.g. OPEN_EXISTING)
//
// Returns:    INT - LZFile struct table offset or WIN32 file HANDLE if
//             successful.  One of the LZERROR_ codes if unsuccessful.
//
INT
LZCreateFileW(
    LPWSTR lpFileName,
    DWORD fdwAccess,
    DWORD fdwShareMode,
    DWORD fdwCreate,
    LPWSTR lpCompressedName)
{
    HANDLE hWin32;           // WIN32 file HANDLE returned from CreateFileW()
    INT lzh;                 // LZ File struct ID returned from LZInit()
    static WCHAR pszCompName[MAX_PATH + 2]; // buffer for compressed name

    pszCompName[MAX_PATH] = UNICODE_NULL;
    lstrcpynW((LPWSTR)pszCompName, lpFileName,
              sizeof(pszCompName) / sizeof(WCHAR));
    if (pszCompName[MAX_PATH]) {
        return LZERROR_BADVALUE;
    }

    // Just for Vlad, only try to open the compressed version of the original
    // file name if we can't find the original file.  All other errors get
    // returned immediately.

    hWin32 = CreateFileW(pszCompName, fdwAccess, fdwShareMode, NULL, fdwCreate,
        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hWin32 == INVALID_HANDLE_VALUE) {
        DWORD dwErr = GetLastError();

        if (dwErr == ERROR_FILE_NOT_FOUND) {

            // Let's try to open the file of the corresponding compressed name.
            MakeCompressedNameW((LPWSTR)pszCompName);

            hWin32 = CreateFileW(pszCompName, fdwAccess, fdwShareMode,
                NULL, fdwCreate, FILE_ATTRIBUTE_NORMAL, NULL);
        }
    }

     // Error opening file?
     if (hWin32 == INVALID_HANDLE_VALUE) {
        return(LZERROR_BADINHANDLE);
     }

    // Don't call LZinit() on files opened in other read only mode

    if (fdwCreate != OPEN_EXISTING) {
       lzh = ConvertWin32FHToDos((HFILE)((DWORD_PTR)hWin32));
       if (lzh == LZERROR_GLOBALLOC) {
          CloseHandle(hWin32);
       }

       return(lzh);
    }

    // File has been opened with read-only action - call LZInit() to detect
    // whether or not it's an LZ file, and to create structures for expansion
    // if it is an LZ file.
    lzh = LZInit((INT)((DWORD_PTR)hWin32));

    // Close DOS file handle if LZInit() is unsuccessful.
    if (lzh < 0)
       CloseHandle(hWin32);

    // Pass real file name to caller
    //
    // we believe the caller have enough buffer.
    //
    if( lpCompressedName != NULL )
        lstrcpyW(lpCompressedName,pszCompName);

    // Return LZ struct ID or LZERROR_ code.
    return(lzh);
}


/*
** int  APIENTRY LZOpenFileA(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuf,
**                           WORD wStyle);
**
** Opens a file and sets up an LZFile struct for expanding it.
**
** Arguments:  lpFileName  - name of input file
**             lpReOpenBuf - pointer to LPOFSTRUCT to be used by OpenFile()
**             wStyle      - OpenFile() action to take
**
** Returns:    int - LZFile struct table offset or DOS file handle if
**                   successful.  One of the LZERROR_ codes if unsuccessful.
**
** Globals:    none
*/
INT APIENTRY LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
{
   INT dosh,                     // DOS file handle returned from OpenFile()
       lzh;                      // LZ File struct ID returned from LZInit()
   CHAR pszCompName[MAX_PATH + 2]; // buffer for compressed name

   pszCompName[MAX_PATH] = UNICODE_NULL;
   lstrcpyn((LPSTR)pszCompName, lpFileName, sizeof(pszCompName));
   if (pszCompName[MAX_PATH]) {
       return LZERROR_BADVALUE;
   }

   // Just for Vlad, only try to open the compressed version of the original
   // file name if we can't find the original file.  All other errors get
   // returned immediately.

   if ((dosh = OpenFile(pszCompName, lpReOpenBuf, wStyle)) == -1 &&
       lpReOpenBuf->nErrCode == DEE_FILENOTFOUND)
   {
      // Let's try to open the file of the corresponding compressed name.
      MakeCompressedName(pszCompName);

      dosh = (HFILE) MOpenFile((LPSTR)pszCompName, lpReOpenBuf, wStyle);
   }

   // Error opening file?
   if (dosh == -1)
      return(LZERROR_BADINHANDLE);

   // Don't call LZinit() on files opened in other than O_RDONLY mode.
   // Ignore the SHARE bits.
   if ((wStyle & STYLE_MASK) != OF_READ) {
      lzh = ConvertWin32FHToDos(dosh);
      if (lzh == LZERROR_GLOBALLOC) {
         FCLOSE(dosh);
      }
      return(lzh);
   }

   // File has been opened with OF_READ style - call LZInit() to detect
   // whether or not it's an LZ file, and to create structures for expansion
   // if it is an LZ file.
   lzh = LZInit(dosh);

   // Close DOS file handle if LZInit() is unsuccessful.
   if (lzh < 0)
      FCLOSE(dosh);

   // Return LZ struct ID or LZERROR_ code.
   return(lzh);
}

/*
** int  APIENTRY LZOpenFileW(LPCWSTR lpFileName, LPOFSTRUCT lpReOpenBuf,
**                           WORD wStyle);
**
** Wide Character version of LZOpenFile.  Converts the filename to
** the ANSI Character set and calls the ANSI version.
**
*/
INT APIENTRY LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
{
    UNICODE_STRING FileName;
    ANSI_STRING AnsiString;
    NTSTATUS StatusR;
    CHAR szFileName[MAX_PATH];


    FileName.Buffer = lpFileName;
    FileName.Length = wcslen(lpFileName)*sizeof(WCHAR);
    FileName.MaximumLength = FileName.Length + sizeof(WCHAR);

    AnsiString.Buffer = szFileName;
    AnsiString.MaximumLength = MAX_PATH;
    StatusR = RtlUnicodeStringToAnsiString(&AnsiString, &FileName, FALSE);
    if (!NT_SUCCESS(StatusR))
        return LZERROR_GLOBALLOC;

    return(LZOpenFileA(szFileName, lpReOpenBuf, wStyle));
}



/*
** LONG  APIENTRY LZSeek(int oLZFile, long lSeekTo, int nMode);
**
** Works like _llseek(), but in the expanded image of a compressed file,
** without expanding the compressed file to disk.
**
** Arguments:  oLZFile - source LZFile struct identifier or DOS file handle
**             lSeekTo - number of bytes past nMode target to seek
**             nMode   - seek mode as in _llseek()
**
** Returns:    LONG - Offset of the seek target if successful.  One of the
**                    LZERROR_ codes if unsuccessful.
**
** Globals:    none
*/
LONG APIENTRY
LZSeek(
   INT oLZFile,
   LONG lSeekTo,
   INT nMode)
{
   HANDLE hSourceStruct;      // handle to LZFile struct
   LZFile *lpLZ;          // pointer to LZFile struct
   LONG lExpSeekTarget;       // target seek offset

   // Check input LZFile struct indentifier / DOS file handle.
   if (oLZFile < 0 || oLZFile >= LZ_TABLE_BIAS + MAX_LZFILES)
      return(LZERROR_BADINHANDLE);

   // We were passed a regular DOS file handle, so just do an _llseek() on it.
   if (oLZFile < LZ_TABLE_BIAS)
      return(FSEEK(ConvertDosFHToWin32(oLZFile), lSeekTo, nMode));

   // We're dealing with a compressed file.  Get the associated LZFile struct.
   hSourceStruct = rghLZFileTable[oLZFile - LZ_TABLE_BIAS];

   if ((lpLZ = (LZFile *)GlobalLock(hSourceStruct)) == NULL)
      return(LZERROR_GLOBLOCK);

   // Figure out what our seek target is.
   if (nMode == SEEK_SET)
      lExpSeekTarget = 0L;
   else if (nMode == SEEK_CUR)
      lExpSeekTarget = lpLZ->lCurSeekPos;
   else if (nMode == SEEK_END)
      lExpSeekTarget = (LONG)lpLZ->cbulUncompSize;
   else
   {
      GlobalUnlock(hSourceStruct);
      return(LZERROR_BADVALUE);
   }

   // Add bias.
   lExpSeekTarget += lSeekTo;

   // Make sure the desired expanded file position is in the expanded file
   // bounds.  It's only an error to seek before the beginning of the file;
   // it's not an error to seek after the end of the file, as in _llseek().
   if (lExpSeekTarget < 0L)
   {
      GlobalUnlock(hSourceStruct);
      return(LZERROR_BADVALUE);
   }

   // Seek target is ok.  Set the file pointer for the expanded file image.
   lpLZ->lCurSeekPos = lExpSeekTarget;

   GlobalUnlock(hSourceStruct);

   // Return the offset of the seek target.
   return(lExpSeekTarget);
}


/*
** int  APIENTRY LZRead(int oLZFile, LPSTR lpBuf, int nCount);
**
** Works like _lread(), but in the expanded image of a compressed file,
** without expanding the compressed file to disk.
**
** Arguments:  oLZFile - source LZFile struct identifier or DOS file handle
**             lpBuf   - pointer to destination buffer for bytes read
**             nCount  - number of bytes to read
**
** Returns:    int - Number of bytes copied to destination buffer if
**                   successful.  One of the LZERROR_ codes if unsuccessful.
**
** Globals:    none
*/
INT  APIENTRY LZRead(INT oLZFile, LPSTR lpBuf, INT nCount)
{
   INT f;
   HANDLE hSourceStruct;      // handle to LZFile struct
   LZFile *lpLZ;          // pointer to LZFile struct

   INT cbWritten = 0,         // total number of bytes copied to
                              //    destination buffer
       cbCopied,              // number of bytes copied to destination
                              // buffer during each read iteration
       iCurReadPos,           // current read offset in expanded buffer
       nNumExpBufBytes;       // number of bytes in expanded data buffer
   LONG lNextDecodeTarget,    // expanded file image read target for decoding
        lStartCopyOffset,     // expanded file buffer offset where we should
                              //    start copying to destination buffer (cast
                              //    to iCurReadPos when this start position
                              //    is actually in the buffer)
        lNextExpEndOffset;    // expanded file offset of the start of the
                              //    next desired block of expanded data
   BOOL bRestartDecoding;     // flag indicating whether or not decoding
                              //    needs to be restarted, set to TRUE when
                              //    the current seek position is smaller than
                              //    the offset of the beginning of the
                              //    expanded file buffer
   BYTE *lpbyteBuf;           // byte pointer version of lpBuf

   LONG lExpBufStart;
   LONG lExpBufEnd;

   PLZINFO pLZI;

   // Check input LZFile struct indentifier / DOS file handle.
   if (oLZFile < 0 || oLZFile >= LZ_TABLE_BIAS + MAX_LZFILES)
      return(LZERROR_BADINHANDLE);

   // Can't read a negative number of bytes.
   if (nCount < 0)
      return(LZERROR_BADVALUE);

   // We were passed a regular DOS file handle, so just do an _lread() on it.
   if (oLZFile < LZ_TABLE_BIAS)
      return(FREAD(ConvertDosFHToWin32(oLZFile), lpBuf, nCount));

   // We're dealing with a compressed file.  Get the associated LZFile struct.
   hSourceStruct = rghLZFileTable[oLZFile - LZ_TABLE_BIAS];

   if ((lpLZ = (LZFile *)GlobalLock(hSourceStruct)) == NULL)
      return(LZERROR_GLOBLOCK);

   if (!(pLZI = lpLZ->pLZI)) {
      // Initialize buffers
      lpLZ->pLZI = InitGlobalBuffers(EXP_BUF_LEN, MAX_RING_BUF_LEN, IN_BUF_LEN + 1);

      if (!(pLZI = lpLZ->pLZI)) {
         GlobalUnlock(hSourceStruct);
         return(LZERROR_GLOBALLOC);
      }

      ResetBuffers();
   }

   lExpBufStart = pLZI->cblOutSize - (LONG)(pLZI->pbyteOutBuf - pLZI->rgbyteOutBuf);
   lExpBufEnd = (LONG)(pLZI->pbyteOutBufEnd - pLZI->rgbyteOutBuf);

   // Do we need to restart decoding?
   if (! (lpLZ->wFlags & LZF_INITIALIZED))
   {
      lpLZ->wFlags |= LZF_INITIALIZED;
      bRestartDecoding = TRUE;
   }
   else if (lpLZ->lCurSeekPos < lExpBufStart)
      bRestartDecoding = TRUE;
   else
      bRestartDecoding = FALSE;

   // Set up byte pointer version of lpBuf.
   lpbyteBuf = lpBuf;

   // Copy bytes until buffer is filled or EOF in expanded file image is
   // reached.
   while (nCount > 0 && lpLZ->lCurSeekPos < (LONG)lpLZ->cbulUncompSize)
   {
      /* How many expanded data bytes are in the expanded data buffer?
       * (pbyteOutBuf points AFTER the last valid byte in rgbyteOutBuf[].)
       */
      nNumExpBufBytes = (INT)(pLZI->pbyteOutBuf - pLZI->rgbyteOutBuf);

      /* Is the start of the desired expanded data currently in the bounds of
       * the expanded data buffer?
       */
      lStartCopyOffset = lpLZ->lCurSeekPos - lExpBufStart;
      if (lStartCopyOffset < lExpBufEnd)
         /* It's ok to set iCurReadPos to a negative value here, since we
          * will only use expanded data from the expanded data buffer if
          * iCurReadPos is non-negative.
          */
         iCurReadPos = (INT)lStartCopyOffset;
      else
         iCurReadPos = -1;

      /* Now, if iCurReadPos > 0, some of the expanded data in the expanded
       * data buffer should be copied to the caller's buffer.  If not, we
       * need to continue expanding or restart expanding.
       */
      if (iCurReadPos >= 0)
      {
         /* Copy available expanded data from expanded data buffer. */
         for (cbCopied = 0;
              iCurReadPos < nNumExpBufBytes && nCount > 0;
              cbCopied++, nCount--)
            *lpbyteBuf++ = pLZI->rgbyteOutBuf[iCurReadPos++];

         // Update expanded file pointer.
         lpLZ->lCurSeekPos += (LONG)cbCopied;

         // Keep track of bytes written to buffer.
         cbWritten += cbCopied;
      }

      /* Expand more data, restarting the expansion process first if
       * necessary.
       */
      if (nCount > 0 && lpLZ->lCurSeekPos < (LONG)lpLZ->cbulUncompSize)
      {
         /* If we get here, we've copied all the available expanded data out
          * of rgbyteOutBuf[], through pbyteOutBuf, and we need to expand
          * more data.
          */

         /* Where is the end of the next desired expanded data block? */
         if (bRestartDecoding)
         {
            /* Seek back to start of target data, allowing for buffer
             * overflow.
             */
            lNextExpEndOffset = lpLZ->lCurSeekPos - MAX_OVERRUN;

            /* Don't try to read before offset 0! */
            if (lNextExpEndOffset < 0)
               lNextExpEndOffset = 0;
         }
         else
            /* Continue decoding. */
            lNextExpEndOffset = lExpBufStart
                                + (LONG)nNumExpBufBytes
                                + lExpBufEnd
                                - MAX_OVERRUN;

         /* How much farther should we expand?  The target decoding offset
          * should be the smallest expanded file offset of the following:
          *
          *    1) the last byte in the largest expanded data block that will
          *       safely fit in the expanded data buffer, while guaranteeing
          *       that the start of this block is also in the expanded data
          *       buffer
          *    2) the last requested expanded data byte
          *    3) the last byte in the expanded file
          */
         lNextDecodeTarget = MIN(lNextExpEndOffset,
                                 MIN(lpLZ->lCurSeekPos + (LONG)nCount,
                                     (LONG)lpLZ->cbulUncompSize - 1L));

         // Reset expanded data buffer to empty state.
         pLZI->pbyteOutBuf = pLZI->rgbyteOutBuf;

         // Refill rgbyteOutBuf[] with expanded data.
         switch (lpLZ->byteAlgorithm)
         {
            case ALG_FIRST:
               f = LZDecode(lpLZ->dosh, NO_DOSH, lNextDecodeTarget,
                  bRestartDecoding, TRUE, pLZI);
               break;

            default:
               f = LZERROR_UNKNOWNALG;
               break;
         }

         // Did the decoding go ok?
         if (f != TRUE)
         {
            // Uh oh.  Something went wrong.
            GlobalUnlock(hSourceStruct);
            return(f);
         }

         /* Now how many expanded data bytes are in the expanded data buffer?
          * (pbyteOutBuf points AFTER the last valid byte in rgbyteOutBuf[].)
          */
#if DEBUG
         printf("pbyteOutBuf: 0x%x,  rgbyteOutBuf: 0x%x \n", pLZI->pbyteOutBuf, pLZI->rgbyteOutBuf);
#endif

         nNumExpBufBytes = (INT)(pLZI->pbyteOutBuf - pLZI->rgbyteOutBuf);

         /* Check to make sure we actually read some bytes. */
         if (nNumExpBufBytes <= 0)
         {
            GlobalUnlock(hSourceStruct);
            return(LZERROR_READ);
         }

         /* What is the offset of the start of the expanded data buffer in
          * the expanded file image?
          */
         lExpBufStart = pLZI->cblOutSize - (LONG)nNumExpBufBytes;

         /* Did LZDecode() satisfy the read request, or did the compressed
          * file end prematurely?
          */
         if (pLZI->cblOutSize < lNextDecodeTarget)
         {
            /* Oh oh.  lNextDecodeTarget cannot exceed the expanded file
             * bounds, so the compressed file must have ended prematurely.
             */
            GlobalUnlock(hSourceStruct);
            return(LZERROR_READ);
         }

         // Reset flag so we continue decoding where we left off.
         bRestartDecoding = FALSE;
      }
   }

   GlobalUnlock(hSourceStruct);

   // Return number of bytes copied to destination buffer.
   return(cbWritten);
}

//
// VOID  LZCloseFile(INT oLZFile);
//
// Close a file and free the associated LZFile struct.
//
// Arguments:  oLZFile - source LZFile struct identifier or WIN32 file handle
//
// Returns:    VOID
//
// Globals:    rghLZFileTable[] entry cleared.
//

VOID
LZCloseFile(
    INT oLZFile)
{
   HANDLE hSourceStruct;      // handle to LZFile struct
   LZFile *lpLZ;          // pointer to LZFile struct

   // Check input LZFile struct indentifier / DOS file handle.
   if (oLZFile < 0 || oLZFile >= LZ_TABLE_BIAS + MAX_LZFILES)
      return;

   // We were passed a regular DOS file handle, so just close it.
   if (oLZFile < LZ_TABLE_BIAS) {
      CloseHandle((HANDLE)IntToPtr(ConvertDosFHToWin32(oLZFile)));
      // also need to clean out the file array entry
      fhWin32File[oLZFile] = 0;

      return;
   }

   // We're dealing with a compressed file.  Get the associated LZFile struct.
   hSourceStruct = rghLZFileTable[oLZFile - LZ_TABLE_BIAS];

   // Clear rghLZFIleTable[] entry.
   rghLZFileTable[oLZFile - LZ_TABLE_BIAS] = NULL;

   // Close the file and free the associated LZFile struct.
   if ((lpLZ = (LZFile *)GlobalLock(hSourceStruct)) != NULL)
   {
      CloseHandle((HANDLE)IntToPtr(lpLZ->dosh));

      if (lpLZ->pLZI) {
         FreeGlobalBuffers(lpLZ->pLZI);
      }

      GlobalUnlock(hSourceStruct);

      GlobalFree(hSourceStruct);

   }

   return;
}


/*
** VOID  APIENTRY LZClose(int oLZFile);
**
** Close a file and free the associated LZFile struct.
**
** Arguments:  oLZFile - source LZFile struct identifier or DOS file handle
**
** Returns:    VOID
**
** Globals:    rghLZFileTable[] entry cleared.
*/
VOID  APIENTRY LZClose(INT oLZFile)
{
   HANDLE hSourceStruct;      // handle to LZFile struct
   LZFile *lpLZ;          // pointer to LZFile struct

   // Check input LZFile struct indentifier / DOS file handle.
   if (oLZFile < 0 || oLZFile >= LZ_TABLE_BIAS + MAX_LZFILES)
      return;

   // We were passed a regular DOS file handle, so just close it.
   if (oLZFile < LZ_TABLE_BIAS)
   {
      FCLOSE(ConvertDosFHToWin32(oLZFile));
      /* also need to clean out the file array entry */
      fhWin32File[oLZFile] = 0;

      return;
   }

   // We're dealing with a compressed file.  Get the associated LZFile struct.
   hSourceStruct = rghLZFileTable[oLZFile - LZ_TABLE_BIAS];

   // Clear rghLZFIleTable[] entry.
   rghLZFileTable[oLZFile - LZ_TABLE_BIAS] = NULL;

   // Close the file and free the associated LZFile struct.
   if ((lpLZ = (LZFile *)GlobalLock(hSourceStruct)) != NULL)
   {
      FCLOSE(lpLZ->dosh);

      if (lpLZ->pLZI) {
         FreeGlobalBuffers(lpLZ->pLZI);
      }

      GlobalUnlock(hSourceStruct);

      GlobalFree(hSourceStruct);

   }

   return;
}


/* WIN32 MODS   */

INT ConvertWin32FHToDos(HFILE DoshSource)
{
    INT x;

    /* here we are given an NT file handle, need save this into
     * fhWin32File[], test for overflow, also need see
     * if there is a free slot in the array */

    /* If error, return greater than MAX_LZFILES */

    RtlEnterCriticalSection(&BaseLZSemTable);

    /* walk array, looking for a free slot (free slot = 0) */
    for(x = 0; x < MAX_LZFILES; x++){
        if(fhWin32File[x] == 0)
            break;
    }
    if(x < MAX_LZFILES){
       /* no overflow, save into array*/
       fhWin32File[x] = DoshSource;
    }
    else{
       x = LZERROR_GLOBALLOC;
    }

    RtlLeaveCriticalSection(&BaseLZSemTable);

    return(x);

}


HFILE ConvertDosFHToWin32(INT DoshSource)
{

    /* here, we are given the pseudo Dos File Handle, need convert to
     * real file handle, for use by API.
     */

    if (DoshSource >= MAX_LZFILES || DoshSource < 0 ||
        fhWin32File[DoshSource] == 0) {
        return (HFILE)DoshSource;
    }
    else{
        return(fhWin32File[DoshSource]);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\winperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winperf.c

Abstract:

    Test program for checking performance of Win32 API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "basedll.h"

//
// Define local types.
//
#define EVENT_PAIR_ITERATIONS               20000
#define NULL_API_ITERATIONS                 10000
#define DOMAIN_LOCK_ITERATIONS              40000
#define CRITICAL_SECTION_LOCK_ITERATIONS    80000
#define MUTEX_LOCK_ITERATIONS               20000

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    );
VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    );


VOID
GetTickCountTest(
    VOID
    );

VOID
EventPairTest (
    VOID
    );

VOID
QuickLpcTest (
    VOID
    );

VOID
SlowLpcTest (
    VOID
    );

VOID
DomainLockTest (
    VOID
    );

VOID
CriticalSectionLockTest (
    VOID
    );

VOID
MutexLockTest (
    VOID
    );


DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    (VOID)argc;
    (VOID)argv;
    (VOID)envp;

    GetTickCountTest();
    EventPairTest();
    QuickLpcTest();
    SlowLpcTest();
    DomainLockTest();
    CriticalSectionLockTest();
    MutexLockTest();
    ExitProcess(0);
}

HANDLE EventPair;

VOID
EventPairClient(
    LPVOID ThreadParameter
    )
{
    NTSTATUS Status;

    //
    // Client does a NtSetLowWaitHighEventPair
    //

    do {
        Status = NtSetLowWaitHighEventPair(EventPair);
        }
    while (NT_SUCCESS(Status));

    ExitThread((DWORD)Status);
}


VOID
EventPairTest (
    VOID
    )

{
    ULONG Index;
    PERFINFO PerfInfo;
    HANDLE Thread;
    DWORD tid;

    ASSERT(NT_SUCCESS(NtCreateEventPair(&EventPair,EVENT_PAIR_ALL_ACCESS,NULL)));
    Thread = CreateThread(NULL,0L,EventPairClient,(LPVOID)99,0,&tid);

    Index = EVENT_PAIR_ITERATIONS;
    StartBenchMark("Event Pair Benchmark",
                   EVENT_PAIR_ITERATIONS, &PerfInfo);

    NtWaitLowEventPair(EventPair);
    while (Index--) {
        NtSetHighWaitLowEventPair(EventPair);
        }
    FinishBenchMark(&PerfInfo);

    NtAlertThread(Thread);
    CloseHandle(Thread);
    CloseHandle(EventPair);
    return;
}

VOID
GetTickCountTest (
    VOID
    )

{
    ULONG Index;
    PERFINFO PerfInfo;
    HANDLE Thread;

    Index = EVENT_PAIR_ITERATIONS;
    StartBenchMark("Get Tick Count Benchmark",
                   EVENT_PAIR_ITERATIONS, &PerfInfo);
    while (Index--) {
        GetTickCount();
        }
    FinishBenchMark(&PerfInfo);

    return;
}

VOID
QuickLpcTest (
    VOID
    )
{

    ULONG Index;
    PERFINFO PerfInfo;
    PCSR_NULLAPICALL_MSG Msg;
    QLPC_ACTION Action;


    CsrClientThreadConnect();

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Quick Lpc Benchmark (no data)",
                   NULL_API_ITERATIONS, &PerfInfo);
    while (Index--) {
        Msg = (PCSR_NULLAPICALL_MSG)
              CsrClientPushMessage( CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                         BasepNullApiCall
                                                       ),
                                    sizeof( CSR_NULLAPICALL_MSG )
                                  );
        Msg->CountArguments = 0;
	ASSERT( CsrClientSendMessage( (PVOID) Msg, &Action ) == 0 );
        CsrClientPopMessage( (PVOID) Msg );
        }

    FinishBenchMark(&PerfInfo);

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Quick Lpc Benchmark (40 bytes of data)",
                   NULL_API_ITERATIONS, &PerfInfo);

    while (Index--) {
        Msg = (PCSR_NULLAPICALL_MSG)
              CsrClientPushMessage( CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                         BasepNullApiCall
                                                       ),
                                    sizeof( CSR_NULLAPICALL_MSG )
                                  );
        Msg->CountArguments = -10;
        Msg->FastArguments[ 0 ] = 0;
        Msg->FastArguments[ 1 ] = 1;
        Msg->FastArguments[ 2 ] = 2;
        Msg->FastArguments[ 3 ] = 3;
        Msg->FastArguments[ 4 ] = 4;
        Msg->FastArguments[ 5 ] = 5;
        Msg->FastArguments[ 6 ] = 6;
        Msg->FastArguments[ 7 ] = 7;
        Msg->FastArguments[ 8 ] = 8;
        Msg->FastArguments[ 9 ] = 9;

	ASSERT( CsrClientSendMessage( (PVOID) Msg, &Action ) == 10 );
        CsrClientPopMessage( (PVOID) Msg );
        }
    FinishBenchMark(&PerfInfo);

    return;
}

ULONG
BaseNullApiCall(
    IN LONG CountArguments,
    IN PCHAR *Arguments OPTIONAL
    );

ULONG NullApiImmediateArguments[] = {
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9
};

PCHAR NullApiTextArguments[] = {
    "123456789012345678901234567890",
    "123456789012345678901234567890",
    "123456789012345678901234567890123456789012345678901234567890",
    NULL
};


VOID
SlowLpcTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Normal Lpc Benchmark (no data)",
                   NULL_API_ITERATIONS, &PerfInfo);
    while (Index--) {
        BaseNullApiCall( 0, (PCHAR *)NULL );
        }
    FinishBenchMark(&PerfInfo);

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Normal Lpc Benchmark (64 bytes of immediate data)",
                   NULL_API_ITERATIONS, &PerfInfo);
    while (Index--) {
        BaseNullApiCall( -10, (PCHAR *)NullApiImmediateArguments );
        }
    FinishBenchMark(&PerfInfo);

    Index = NULL_API_ITERATIONS;
    StartBenchMark("Normal Lpc Benchmark (124 bytes of data)",
                   NULL_API_ITERATIONS, &PerfInfo);
    while (Index--) {
        BaseNullApiCall( 3, NullApiTextArguments );
        }
    FinishBenchMark(&PerfInfo);

    return;
}

VOID
DomainLockTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Domain Lock Benchmark",
                   DOMAIN_LOCK_ITERATIONS, &PerfInfo);

    for (Index = 0; Index < DOMAIN_LOCK_ITERATIONS; Index += 1) {
        NtLockDisplayGroup(0);
        NtUnlockDisplayGroup(0);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}

VOID
CriticalSectionLockTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;
    CRITICAL_SECTION Crit;

    InitializeCriticalSection(&Crit);

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Critical Section Benchmark",
                   CRITICAL_SECTION_LOCK_ITERATIONS, &PerfInfo);

    //
    // Repeatedly call a short system service.
    //

    for (Index = 0; Index < CRITICAL_SECTION_LOCK_ITERATIONS; Index += 1) {
        EnterCriticalSection(&Crit);
        LeaveCriticalSection(&Crit);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}


VOID
MutexLockTest (
    VOID
    )

{

    ULONG Index;
    PERFINFO PerfInfo;
    HANDLE Mutex;

    Mutex = CreateMutex(NULL,FALSE,NULL);

    //
    // Announce start of benchmark and capture performance parmeters.
    //

    StartBenchMark("Mutex Benchmark",
                   MUTEX_LOCK_ITERATIONS, &PerfInfo);

    //
    // Repeatedly call a short system service.
    //

    for (Index = 0; Index < MUTEX_LOCK_ITERATIONS; Index += 1) {
        WaitForSingleObject(Mutex,-1);
        ReleaseMutex(Mutex);
    }

    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
    return;
}

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    LARGE_INTEGER Duration;
    ULONG Length;
    ULONG Performance;

    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Duration = RtlLargeIntegerSubtract(PerfInfo->StopTime, PerfInfo->StartTime);
    Length = Duration.LowPart / 10000;
    DbgPrint("        Test time in milliseconds %d\n", Length);
    DbgPrint("        Number of iterations      %d\n", PerfInfo->Iterations);
    Performance = PerfInfo->Iterations * 1000 / Length;
    DbgPrint("        Iterations per second     %d\n", Performance);
    DbgPrint("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    //
    // Announce start of test and the number of iterations.
    //

    DbgPrint("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\wmbnch.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>
#include <process.h>

#define WAIT_MULTIPLE_ITERATIONS 10000
HANDLE WaitHandles[64];

//
// Define local types.
//

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    ULONG ContextSwitches;
    ULONG FirstLevelFills;
    ULONG SecondLevelFills;
    ULONG SystemCalls;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    ULONG ContextSwitches;
    LARGE_INTEGER Duration;
    ULONG FirstLevelFills;
    ULONG Length;
    ULONG Performance;
    ULONG SecondLevelFills;
    NTSTATUS Status;
    ULONG SystemCalls;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;


    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    Duration = RtlLargeIntegerSubtract(PerfInfo->StopTime, PerfInfo->StartTime);
    Length = Duration.LowPart / 10000;
    printf("        Test time in milliseconds %d\n", Length);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Length;
    printf("        Iterations per second     %d\n", Performance);

    ContextSwitches = SystemInfo.ContextSwitches - PerfInfo->ContextSwitches;
    FirstLevelFills = SystemInfo.FirstLevelTbFills - PerfInfo->FirstLevelFills;
    SecondLevelFills = SystemInfo.SecondLevelTbFills - PerfInfo->SecondLevelFills;
    SystemCalls = SystemInfo.SystemCalls - PerfInfo->SystemCalls;
    printf("        First Level TB Fills      %d\n", FirstLevelFills);
    printf("        Second Level TB Fills     %d\n", SecondLevelFills);
    printf("        Total Context Switches    %d\n", ContextSwitches);
    printf("        Number of System Calls    %d\n", SystemCalls);

    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    NTSTATUS Status;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    PerfInfo->ContextSwitches = SystemInfo.ContextSwitches;
    PerfInfo->FirstLevelFills = SystemInfo.FirstLevelTbFills;
    PerfInfo->SecondLevelFills = SystemInfo.SecondLevelTbFills;
    PerfInfo->SystemCalls = SystemInfo.SystemCalls;
    return;
}


VOID
WaitMultipleTest()
{
    PERFINFO PerfInfo;
    int i;

    StartBenchMark(
        "Wait Single Object",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForSingleObject(WaitHandles[0],INFINITE);   // Wait Single Object
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 1 Object",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(1,WaitHandles,FALSE,INFINITE);   // Wait Any, 1 Object
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 8 Objects",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(8,WaitHandles,FALSE,INFINITE);   // Wait Any, 8 Objects
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 16 Objects",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(16,WaitHandles,FALSE,INFINITE);   // Wait Any, 16 Objects
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 32 Objects",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(32,WaitHandles,FALSE,INFINITE);   // Wait Any, 32 Objects
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "Wait Multiple Test 64 Objects",
        WAIT_MULTIPLE_ITERATIONS,
        &PerfInfo
        );

    for ( i=0;i<WAIT_MULTIPLE_ITERATIONS;i++) {
        WaitForMultipleObjects(64,WaitHandles,FALSE,INFINITE);   // Wait Any, 64 Objects
        }

    FinishBenchMark(&PerfInfo);
}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    int i;

    for(i=0;i<64;i++){
        WaitHandles[i] = CreateEvent(NULL,TRUE,TRUE,NULL);
        }
    WaitMultipleTest();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\char\fibtst.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

LPVOID Fibers[4];

VOID
FiberRoutine(
    LPVOID lpParameter
    )
{
    DWORD FiberId;

    FiberId = (DWORD)GetFiberData();

    printf("Init: In Fiber %d, %x Param %d\n",FiberId,GetCurrentFiber(),lpParameter);

    while(1) {
        printf("In Fiber %d %d\n",FiberId,(DWORD)GetFiberData() );
        Sleep(10);
        if ( FiberId == 3 ) {
            SwitchToFiber(Fibers[0]);
            }
        else {
            SwitchToFiber(Fibers[FiberId+1]);
            }
        }
}

int _cdecl main(void)
{
    DWORD IdealProcessor;

    IdealProcessor = SetThreadIdealProcessor(GetCurrentThread(),MAXIMUM_PROCESSORS);
    printf("IdealProcessor %d\n",IdealProcessor);


    Fibers[0] = ConvertThreadToFiber((LPVOID)0);
    Fibers[1] = CreateFiber(0,FiberRoutine,(LPVOID)1);
    Fibers[2] = CreateFiber(0,FiberRoutine,(LPVOID)2);
    Fibers[3] = CreateFiber(0,FiberRoutine,(LPVOID)3);

    FiberRoutine((LPVOID)99);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\char\bm.c ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

#define FIBER_COUNT 50000000
#define FIVEK   5000
#define TENK    10000
#define ONEHUNK 100000
#define ONEMIL  1000000
#define MEMORY_TEST 200000000

VOID
_fastcall
MemToReg (
    IN ULONG Count,
    IN PULONG Address
    );

VOID
_fastcall
RegToMem (
    IN ULONG Count,
    IN PULONG Address
    );

typedef struct _FLS_VALUE {
    DWORD Value1;
    DWORD Value2;
} FLS_VALUE, *PFLS_VALUE;

//
// Define local types.
//

typedef struct _PERFINFO {
    DWORD StartTime;
    DWORD StopTime;
    LPSTR Title;
    DWORD Iterations;
} PERFINFO, *PPERFINFO;

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    DWORD ContextSwitches;
    DWORD Duration;
    DWORD Performance;


    //
    // Print results and announce end of test.
    //

    PerfInfo->StopTime = GetTickCount();

    Duration = PerfInfo->StopTime - PerfInfo->StartTime;
    printf("        Test time in milliseconds %d\n", Duration);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = (DWORD)((ULONG64)PerfInfo->Iterations * 1000 / Duration);
    printf("        Iterations per second     %d\n", Performance);


    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN DWORD Iterations,
    IN PPERFINFO PerfInfo
    )

{

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    PerfInfo->StartTime = GetTickCount();
    return;
}

VOID
VqTest(
    VOID
    )

{

    PERFINFO PerfInfo;
    int i;
    PVOID Pv;
    DWORD dw;
    MEMORY_BASIC_INFORMATION BasicInfo;

    //
    // Reserve 64k and commit one page
    //
    Pv = VirtualAlloc(NULL,65536,MEM_RESERVE,PAGE_READWRITE);
    if ( !Pv ) {
        printf("Virtual Alloc(a) Failed %d\n",GetLastError());
        ExitProcess(1);
        }
    Pv = VirtualAlloc(Pv,4096,MEM_COMMIT,PAGE_READWRITE);
    if ( !Pv ) {
        printf("Virtual Alloc(b) Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS);

    StartBenchMark(
        "Virtual Query Test",
        5*ONEHUNK,
        &PerfInfo
        );

    for ( i=0;i<5*ONEHUNK;i++) {
        dw = VirtualQuery(Pv,&BasicInfo,sizeof(BasicInfo));
        }

    FinishBenchMark(&PerfInfo);

    SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
}

VOID
MulDivTest(
    VOID
    )

{

    PERFINFO PerfInfo;
    int i;

    SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS);

    StartBenchMark(
        "MulDiv(4,2,5) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(4,2,5);
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "MulDiv(-4,2,5) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(-4,2,5);
        }

    FinishBenchMark(&PerfInfo);


    StartBenchMark(
        "MulDiv(4,-2,5) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(4,-2,5);
        }

    FinishBenchMark(&PerfInfo);


    StartBenchMark(
        "MulDiv(-4,-2,5) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(-4,-2,5);
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "MulDiv(0x10,0x400,0) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(0x10,0x400,0);
        }

    FinishBenchMark(&PerfInfo);


    StartBenchMark(
        "MulDiv(0x10,0x40000000,2) Test",
        5*ONEMIL,
        &PerfInfo
        );

    for ( i=0;i<5*ONEMIL;i++) {
        MulDiv(0x10,0x40000000,2);
        }

    FinishBenchMark(&PerfInfo);

    SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
}

VOID
GfaTest(
    LPSTR Str
    )

{

    PERFINFO PerfInfo;
    int i;

    StartBenchMark(
        "GetFileAttributes Test",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {
        GetFileAttributes(Str);
        }

    FinishBenchMark(&PerfInfo);
}

VOID
GmhTest(
    VOID
    )

{

    PERFINFO PerfInfo;
    int i;

    StartBenchMark(
        "GetModuleHandle Test",
        ONEHUNK,
        &PerfInfo
        );

    for ( i=0;i<ONEHUNK;i++) {
        GetModuleHandle("kernel32.dll");
        }

    FinishBenchMark(&PerfInfo);
}

LPVOID Fibers[2];
FLS_VALUE FlsValue1;
FLS_VALUE FlsValue2;

VOID
SwitchToFiber0 (
    VOID
    )

{
    SwitchToFiber(Fibers[0]);
    return;
}

VOID
FiberRoutine1(
    LPVOID lpParameter
    )
{

    PCHAR Name;
    PFLS_VALUE Value;

    Value = GetFiberData();
    if (FlsSetValue(Value->Value1, (PVOID)Value->Value1) == FALSE) {
        printf("fiber 1 - set index %d failed\n", Value->Value1);
    }

    if (FlsSetValue(Value->Value2, (PVOID)Value->Value2) == FALSE) {
        printf("fiber 1 - set index %d failed\n", Value->Value2);
    }

    Name = strtok("fiber 1", ":");
    printf("%s starting loop\n", Name);
    for(;;) {
        if (FlsGetValue(Value->Value1) != (PVOID)Value->Value1) {
            printf("fiber 1 - get value at index % d return wrong value %d\n",
                   Value->Value1,
                   FlsGetValue(Value->Value1));
        }

        if (FlsGetValue(Value->Value2) != (PVOID)Value->Value2) {
            printf("fiber 1 - get value at index % d return wrong value %d\n",
                   Value->Value2,
                   FlsGetValue(Value->Value2));
        }

        SwitchToFiber0();
    }
}

VOID
SwitchToFiber1 (
    VOID
    )

{
    SwitchToFiber(Fibers[1]);
    return;
}

VOID
FiberRoutine0(
    LPVOID lpParameter
    )

{

    PFLS_VALUE Value;
    PERFINFO PerfInfo;
    int i;
    PCHAR Name;

    StartBenchMark(
        "Fiber Switch Test",
        FIBER_COUNT,
        &PerfInfo
        );

    Value = GetFiberData();
    if (FlsSetValue(Value->Value1, (PVOID)Value->Value1) == FALSE) {
        printf("fiber 0 - set index %d failed\n", Value->Value1);
    }

    if (FlsSetValue(Value->Value2, (PVOID)Value->Value2) == FALSE) {
        printf("fiber 0 - set index %d failed\n", Value->Value2);
    }

    Name = strtok("Fiber 0", ":");
    printf("%s starting loop\n", Name);
    for ( i = 0; i < FIBER_COUNT; i++) {
        if (FlsGetValue(Value->Value1) != (PVOID)Value->Value1) {
            printf("fiber 0 - get value at index % d return wrong value %d\n",
                   Value->Value1,
                   FlsGetValue(Value->Value1));
        }

        if (FlsGetValue(Value->Value2) != (PVOID)Value->Value2) {
            printf("fiber 0 - get value at index % d return wrong value %d\n",
                   Value->Value2,
                   FlsGetValue(Value->Value2));
        }

        SwitchToFiber1();
    }

    FinishBenchMark(&PerfInfo);
}

VOID
WINAPI
FibCallback (
    PVOID Data
    )

{

    if (((DWORD)Data != 0) &&
        ((DWORD)Data != FlsValue1.Value1) &&
        ((DWORD)Data != FlsValue1.Value2) &&
        ((DWORD)Data != FlsValue2.Value1) &&
        ((DWORD)Data != FlsValue2.Value2)) {
        printf("callback routine incorrectly called for data %d\n", (DWORD)Data);
    }

    return;
}

VOID
FibTst(
    DWORD Flags
    )

{


    Fibers[0] = ConvertThreadToFiberEx((LPVOID)&FlsValue1, Flags);
    Fibers[1] = CreateFiberEx(0, 0, Flags, FiberRoutine1, (LPVOID)&FlsValue2);

    FlsValue1.Value1 = FlsAlloc(&FibCallback);
    FlsValue1.Value2 = FlsAlloc(&FibCallback);

    FlsValue2.Value1 = FlsAlloc(&FibCallback);
    FlsValue2.Value2 = FlsAlloc(&FibCallback);

    FiberRoutine0((LPVOID)1);
    if (ConvertFiberToThread() == FALSE) {
        printf("fiber convertion to thread failed\n");
    }

    DeleteFiber(Fibers[1]);
    if (FlsFree(FlsValue1.Value1) == FALSE) {
        printf("thread 0 unable to free index %d\n", FlsValue1.Value1);
    }

    if (FlsFree(FlsValue1.Value2) == FALSE) {
        printf("thread 0 unable to free index %d\n", FlsValue1.Value2);
    }

    if (FlsFree(FlsValue2.Value1) == FALSE) {
        printf("thread 0 unable to free index %d\n", FlsValue2.Value1);
    }

    if (FlsFree(FlsValue2.Value2) == FALSE) {
        printf("thread 0 unable to free index %d\n", FlsValue2.Value2);
    }

    return;
}

VOID
MemoryTest (
    VOID
    )

{

    PULONG Address;
    CHAR Buffer[512];
    ULONG Count;
    PERFINFO PerfInfo;

    //
    // Memory to register - aligned.
    //

    Address = (PULONG)(((ULONG)(&Buffer[128]) + 3) & ~3);
    StartBenchMark("Memory To Register Aligned Test",
                   MEMORY_TEST,
                   &PerfInfo);

    MemToReg(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Memory to register - unaligned within cache line
    //

    Address = (PULONG)((((ULONG)(&Buffer[256]) + 127) & ~127) + 1);
    StartBenchMark("Memory To Register Unaligned Within Cache Line Test",
                   MEMORY_TEST,
                   &PerfInfo);

    MemToReg(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Memory to register - unaligned across cache line
    //

    Address = (PULONG)((((ULONG)(&Buffer[256]) + 127) & ~127) - 1);
    StartBenchMark("Memory To Register Unaligned Across Cache Line Test",
                   MEMORY_TEST / 2,
                   &PerfInfo);

    MemToReg(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Register to memory - aligned.
    //

    Address = (PULONG)(((ULONG)(&Buffer[256]) + 3) & ~3);
    StartBenchMark("Register To Memory Aligned Test",
                   MEMORY_TEST,
                   &PerfInfo);

    RegToMem(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Register to Memory - unaligned within cache line
    //

    Address = (PULONG)((((ULONG)(&Buffer[256]) + 127) & ~127) + 1);
    StartBenchMark("Register To Memory Unaligned Within Cache Line Test",
                   MEMORY_TEST,
                   &PerfInfo);

    RegToMem(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    //
    // Register to Memory - unaligned across cache line
    //

    Address = (PULONG)((((ULONG)(&Buffer[256]) + 127) & ~127) - 1);
    StartBenchMark("Register To Memory Unaligned Across Cache Line Test",
                   MEMORY_TEST / 2,
                   &PerfInfo);

    RegToMem(MEMORY_TEST, Address);
    FinishBenchMark(&PerfInfo);

    return;
}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

//    VqTest();
//    MulDivTest();
//    GmhTest();
//    if ( argc > 1 ) {
//        GfaTest(argv[1]);
//        }

    FibTst(0);
    FibTst(FIBER_FLAG_FLOAT_SWITCH);


//    MemoryTest();
    ExitThread(0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\amd64\context.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains the platform specific context management routines.

Author:

    David N. Cutler (davec) 8-Jul-2000

--*/

#include "basedll.h"

//
// CALLFRAME represents the layout of the stack upon entry to a function,
// including home locations for the first four parameters.
//

typedef struct _CALL_FRAME {
    PVOID ReturnAddress;
    PVOID Param1Home;
    PVOID Param2Home;
    PVOID Param3Home;
    PVOID Param4Home;
} CALL_FRAME, *PCALL_FRAME;

C_ASSERT((sizeof(CALL_FRAME) % 16) == 8);


VOID
BaseInitializeContext (
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL,
    IN BASE_CONTEXT_TYPE ContextType
    )

/*++

Routine Description:

    This function initializes a context structure for use is an subsequent
    call to create a thread.

Arguments:

    Context - Supplies a pointer to context record to be initialized.

    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

    NewThread - Supplies a flag that specifies that this is a new thread,
        fiber, or process.

Return Value:

    None.

--*/

{
    PCALL_FRAME CallFrame;

    //
    // Initialize the context record so the thread will start execution
    // in the proper routine.
    //

    RtlZeroMemory((PVOID)Context, sizeof(CONTEXT));
    Context->ContextFlags = CONTEXT_FULL;

    //
    // Allocate a dummy call frame on the top the specified stack.
    //
    // N.B. No initialization of this stack can be performed since it may
    //      lie in another process address space.
    //

    CallFrame = (PCALL_FRAME)InitialSp - 1;
    Context->Rsp = (ULONG64)CallFrame;

    //
    // Initialize the start up parameters.
    //

    Context->Rcx = (ULONG64)InitialPc;
    Context->Rdx = (ULONG64)Parameter;

    //
    // Initialize the floating control/status.
    //

    Context->MxCsr = INITIAL_MXCSR;

    //
    // Initialize the starting address dependent on the type of startup.
    //

    if (ContextType == BaseContextTypeProcess) {
        Context->Rip = (ULONG64)BaseProcessStart;

    } else if (ContextType == BaseContextTypeThread ) {
        Context->Rip = (ULONG64)BaseThreadStart;

    } else {

        //
        // BaseFiberStart will be invoked via a return from SwitchToFiber().
        // Push the return address here.
        //

        Context->Rsp -= sizeof(PVOID);
        *((PVOID *)Context->Rsp) = BaseFiberStart;
    }

    return;
}

VOID
BaseFiberStart (
    VOID
    )

/*++

Routine Description:

    This function starts a fiber by calling the thread start up routine with
    the proper parameters.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PFIBER Fiber;

    Fiber = GetCurrentFiber();
    BaseThreadStart((LPTHREAD_START_ROUTINE)Fiber->FiberContext.Rcx,
                    (LPVOID)Fiber->FiberContext.Rdx);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\amd64\fiber.asm ===
title  "Fiber Switch"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   fiber.asm
;
; Abstract:
;
;   This module implements the platform specific fiber swtich code.
;
; Author:
;
;   David N. Cutler (davec) 7-Jul-2000
;
;--

include ksamd64.inc

;++
;
; VOID
; SwitchToFiber(
;     PFIBER NewFiber
;     )
;
; Routine Description:
;
;   This function saves the state of the current fiber and switches to the
;   specified fiber.
;
; Arguments:
;
;   NewFiber (rcx) - Supplies the address of the new fiber.
;
; Return Value:
;
;   None
;
;--

        LEAF_ENTRY SwitchToFiber, _TEXT$00

        mov     rdx, gs:[TeSelf]        ; get TEB address
        mov     rax, TeFiberData[rdx]   ; get current fiber address

;
; Set new deallocation stack and fiber data in TEB.
;

        mov     r8, FbDeallocationStack[rcx] ; set deallocation stack address
        mov     TeDeallocationStack[rdx], r8 ;
        mov     TeFiberData[rdx], rcx   ; set new fiber address

;
; Save stack limit and fiber local storage data address.
;

        mov     r8, TeStackLimit[rdx]   ; save current stack limit
        mov     FbStackLimit[rax], r8   ;
        mov     r8, TeFlsData[rdx]      ; save fiber local storage data address
        mov     FbFlsData[rax], r8      ;

;
; Save the nonvolitile state of the current fiber.
;

        lea     r8, FbFiberContext[rax] ; get fiber context record address
        mov     CxRbx[r8], rbx          ; save nonvolatile integer registers
        mov     CxRbp[r8], rbp          ;
        mov     CxRsi[r8], rsi          ;
        mov     CxRdi[r8], rdi          ;
        mov     CxR12[r8], r12          ;
        mov     CxR13[r8], r13          ;
        mov     CxR14[r8], r14          ;
        mov     CxR15[r8], r15          ;
        movq    CxXmm6[r8], xmm6        ; save nonvolatile floating registers
        movq    CxXmm7[r8], xmm7        ;
        movq    CxXmm8[r8], xmm8        ;
        movq    CxXmm9[r8], xmm9        ;
        movq    CxXmm10[r8], xmm10      ;
        movq    CxXmm11[r8], xmm11      ;
        movq    CxXmm12[r8], xmm12      ;
        movq    CxXmm13[r8], xmm13      ;
        movq    CxXmm14[r8], xmm14      ;
        movq    CxXmm15[r8], xmm15      ;
        stmxcsr CxMxCsr[r8]             ; save floating control and status
        mov     r9, [rsp]               ; save return address
        mov     CxRip[r8], r9           ;
        mov     CxRsp[r8], rsp          ; save stack pointer

;
; Restore the new fiber stack base, stack limit, and fiber local storage data
; address.
;

        mov     r8, FbStackBase[rcx]    ; restore stack base
        mov     TeStackBase[rdx], r8    ;
        mov     r8, FbStackLimit[rcx]   ; restore stack limit
        mov     TeStackLimit[rdx], r8   ;
        mov     r8, FbFlsData[rcx]      ; restore fiber local storage data address
        mov     TeFlsData[rdx], r8      ;

;
; Restore nonvolitile state of the new fiber.
;

        lea     r8, FbFiberContext[rcx] ; get fiber context address
        mov     rbx, CxRbx[r8]          ; restore nonvolatile integer registers
        mov     rbp, CxRbp[r8]          ;
        mov     rsi, CxRsi[r8]          ;
        mov     rdi, CxRdi[r8]          ;
        mov     r12, CxR12[r8]          ;
        mov     r13, CxR13[r8]          ;
        mov     r14, CxR14[r8]          ;
        mov     r15, CxR15[r8]          ;
        movq    xmm6, CxXmm6[r8]        ; restore nonvolatile floating registers
        movq    xmm7, CxXmm7[r8]        ;
        movq    xmm8, CxXmm8[r8]        ;
        movq    xmm9, CxXmm9[r8]        ;
        movq    xmm10, CxXmm10[r8]      ;
        movq    xmm11, CxXmm11[r8]      ;
        movq    xmm12, CxXmm12[r8]      ;
        movq    xmm13, CxXmm13[r8]      ;
        movq    xmm14, CxXmm14[r8]      ;
        movq    xmm15, CxXmm15[r8]      ;
        ldmxcsr CxMxCsr[r8]             ; restore floating control and status
        mov     rsp, CxRsp[r8]          ; restore stack pointer
        ret                             ;

        LEAF_END SwitchToFiber, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\char\smpscale.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

BOOL fShowScaling;

#define MAX_THREADS 32


//
// - hStartOfRace is a manual reset event that is signalled when
//   all of the threads are supposed to cut loose and begin working
//
// - hEndOfRace is a manual reset event that is signalled once the end time
//   has been retrieved and it is ok for the threads to exit
//

HANDLE hStartOfRace;
HANDLE hEndOfRace;


//
// - ThreadReadyDoneEvents are an array of autoclearing events. The threads
//   initially signal these events once they have reached their start routines
//   and are ready to being processing. Once they are done processing, they
//   signal thier event to indicate that they are done processing.
//
// - ThreadHandles are an array of thread handles to the worker threads. The
//   main thread waits on these to know when all of the threads have exited.
//

HANDLE ThreadReadyDoneEvents[MAX_THREADS];
HANDLE ThreadHandles[MAX_THREADS];

DWORD WorkerThread(PVOID ThreadIndex);
DWORD ThreadId;
DWORD StartTicks, EndTicks;
HANDLE IoHandle;

#define SIXTY_FOUR_K    (64*1024)
#define SIXTEEN_K       (16*1024)
unsigned int InitialBuffer[SIXTY_FOUR_K/sizeof(unsigned int)];
#define NUMBER_OF_WRITES ((1024*1024*8)/SIXTY_FOUR_K)
#define BUFFER_MAX  (64*1024)
#define FILE_SIZE ((1024*1024*8)-BUFFER_MAX)

/*
// Each thread has a THREAD_WORK structure. This contains the address
// of the cells that this thread is responsible for, and the number of
// cells it is supposed to process.
*/

typedef struct _THREAD_WORK {
    unsigned long *CellVector;
    int NumberOfCells;
    int RecalcResult;
    BOOL GlobalMode;
} THREAD_WORK, *PTHREAD_WORK;

unsigned int GlobalData[MAX_THREADS];
THREAD_WORK ThreadWork[MAX_THREADS];
#define ONE_MB      (1024*1024)

unsigned long Mb = 16;
unsigned long ExpectedRecalcValue;
unsigned long ActualRecalcValue;
unsigned long ContentionValue;
int fGlobalMode;
int WorkIndex;
int BufferSize;
unsigned long *CellVector;



DWORD
DoAnInteration(
    int NumberOfThreads,
    BOOL GlobalMode
    )
{
    int i;
    int fShowUsage;
    char c, *p, *whocares;
    int NumberOfDwords;
    int CNumberOfDwords;
    int DwordsPerThread;
    char *Answer;
    unsigned long x;

    fGlobalMode = 0;

    BufferSize = 1024;

    hStartOfRace = CreateEvent(NULL,TRUE,FALSE,NULL);
    hEndOfRace = CreateEvent(NULL,TRUE,FALSE,NULL);

    if ( !hStartOfRace || !hEndOfRace ) {
        fprintf(stderr,"SMPSCALE Race Event Creation Failed\n");
        ExitProcess(1);
        }


    /*
    // Prepare the ready done events. These are auto clearing events
    */

    for(i=0; i<NumberOfThreads; i++ ) {
        ThreadReadyDoneEvents[i] = CreateEvent(NULL,FALSE,FALSE,NULL);
        if ( !ThreadReadyDoneEvents[i] ) {
            fprintf(stderr,"SMPSCALE Ready Done Event Creation Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        }

    NumberOfDwords = (Mb*ONE_MB) / sizeof(unsigned long);
    CNumberOfDwords = NumberOfDwords;
    DwordsPerThread = NumberOfDwords / NumberOfThreads;

    /*
    // Initialize the Cell Vector
    */

    for(i=0, ExpectedRecalcValue=0; i<NumberOfDwords; i++ ){
        ExpectedRecalcValue += i;
        CellVector[i] = i;
        }

    /*
    // Partition the work to the worker threads
    */

    for(i=0; i<NumberOfThreads; i++ ){
        ThreadWork[i].CellVector = &CellVector[i*DwordsPerThread];
        ThreadWork[i].NumberOfCells = DwordsPerThread;
        NumberOfDwords -= DwordsPerThread;

        /*
        // If we have a remainder, give the remaining work to the last thread
        */

        if ( NumberOfDwords < DwordsPerThread ) {
            ThreadWork[i].NumberOfCells += NumberOfDwords;
            }
        }

    /*
    // Create the worker threads
    */

    for(i=0; i<NumberOfThreads; i++ ) {
        ThreadWork[i].RecalcResult = 0;
        ThreadWork[i].GlobalMode = GlobalMode;
        GlobalData[i] = 0;

        ThreadHandles[i] = CreateThread(
                                NULL,
                                0,
                                WorkerThread,
                                (PVOID)i,
                                0,
                                &ThreadId
                                );
        if ( !ThreadHandles[i] ) {
            fprintf(stderr,"SMPSCALE Worker Thread Creation Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        CloseHandle(ThreadHandles[i]);

        }

    /*
    // All of the worker threads will signal thier ready done event
    // when they are idle and ready to proceed. Once all events have been
    // set, then setting the hStartOfRaceEvent will begin the recalc
    */

    i = WaitForMultipleObjects(
            NumberOfThreads,
            ThreadReadyDoneEvents,
            TRUE,
            INFINITE
            );

    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"SMPSCALE Wait for threads to stabalize Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    /*
    // Everthing is set to begin the recalc operation
    */

    StartTicks = GetTickCount();
    if ( !SetEvent(hStartOfRace) ) {
        fprintf(stderr,"SMPSCALE SetEvent(hStartOfRace) Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    /*
    // Now just wait for the recalc to complete
    */

    i = WaitForMultipleObjects(
            NumberOfThreads,
            ThreadReadyDoneEvents,
            TRUE,
            INFINITE
            );

    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"SMPSCALE Wait for threads to complete Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    /*
    // Now pick up the individual recalc values
    */

    for(i=0, ActualRecalcValue = 0; i<NumberOfThreads; i++ ){
        ActualRecalcValue += ThreadWork[i].RecalcResult;
        }

    EndTicks = GetTickCount();

    if ( ActualRecalcValue != ExpectedRecalcValue ) {
        fprintf(stderr,"SMPSCALE Recalc Failuer !\n");
        ExitProcess(1);
        }

    return (EndTicks - StartTicks);
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD Time,GlobalModeTime;
    DWORD BaseLine;
    DWORD i;
    SYSTEM_INFO SystemInfo;

    /*
    // Allocate and initialize the CellVector
    */

    if ( argc > 1 ) {
        fShowScaling = TRUE;
        }
    else {
        fShowScaling = FALSE;
        }

    CellVector = (PDWORD)VirtualAlloc(NULL,Mb*ONE_MB,MEM_COMMIT,PAGE_READWRITE);
    if ( !CellVector ) {
        fprintf(stderr,"SMPSCALE Cell Vector Allocation Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    BaseLine = DoAnInteration(1,FALSE);
    i = 0;
    while(i++<10) {
        Time = DoAnInteration(1,FALSE);
        if ( Time == BaseLine ) {
            break;
            }
        if ( abs(Time-BaseLine) < 2 ) {
            break;
            }
        BaseLine = Time;
        }

    GetSystemInfo(&SystemInfo);

    fprintf(stdout,"%d Processor System. Single Processor BaseLine %dms\n\n",
        SystemInfo.dwNumberOfProcessors,
        BaseLine
        );

    if ( !fShowScaling ) {
            fprintf(stdout,"              Time             Time with Cache Sloshing\n");
            }

    for ( i=0;i<SystemInfo.dwNumberOfProcessors;i++) {
        Time = DoAnInteration(i+1,FALSE);
        GlobalModeTime = DoAnInteration(i+1,TRUE);

        if ( fShowScaling ) {
            if ( i > 0 ) {
                fprintf(stdout,"%1d Processors %4dms (%3d%%)   %4dms (%3d%%) (with cache contention)\n",
                    i+1,Time,((BaseLine*100)/Time-100),GlobalModeTime,((BaseLine*100)/GlobalModeTime-100)
                    );
                }
            else {
                fprintf(stdout,"%1d Processors %4dms          %4dms        (with cache contention)\n",
                    i+1,Time,GlobalModeTime
                    );
                }
            }
        else {
            fprintf(stdout,"%1d Processors %4dms        vs          %4dms\n",
                i+1,Time,GlobalModeTime
                );
            }
        }

    ExitProcess(2);
}


/*
// The worker threads perform the recalc operation on their
// assigned cells. They begin by setting their ready done event
// to indicate that they are ready to begin the recalc. Then they
// wait until the hStartOfRace event is signaled. Once this occurs, they
// do their part of the recalc and when done they signal their ready done
// event and then wait on the hEndOfRaceEvent
*/

DWORD
WorkerThread(
    PVOID ThreadIndex
    )
{

    unsigned long Me;
    unsigned long *MyCellVectorBase;
    unsigned long *CurrentCellVector;
    unsigned long MyRecalcValue;
    unsigned long MyNumberOfCells;
    unsigned long i,j;
    int GlobalMode;
    HANDLE hEvent;
    BOOL b;

    Me = (unsigned long)ThreadIndex;
    MyRecalcValue = 0;
    MyCellVectorBase = ThreadWork[Me].CellVector;
    MyNumberOfCells = ThreadWork[Me].NumberOfCells;
    GlobalMode = ThreadWork[Me].GlobalMode;

    /*
    // Signal that I am ready to go
    */

    if ( !SetEvent(ThreadReadyDoneEvents[Me]) ) {
        fprintf(stderr,"SMPSCALE (1) SetEvent(ThreadReadyDoneEvent[%d]) Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    /*
    // Wait for the master to release us to do the recalc
    */

    i = WaitForSingleObject(hStartOfRace,INFINITE);
    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"SMPSCALE Thread %d Wait for start of recalc Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    /*
    // perform the recalc operation
    */

    for (i=0, CurrentCellVector = MyCellVectorBase,j=0; i<MyNumberOfCells; i++ ) {
        if (GlobalMode){
            GlobalData[Me] += *CurrentCellVector++;
            }
        else {
            MyRecalcValue += *CurrentCellVector++;
            }
        }
    if (GlobalMode){
        MyRecalcValue = GlobalData[Me];
        }
    ThreadWork[Me].RecalcResult = MyRecalcValue;

    /*
    // Signal that I am done and then wait for further instructions
    */

    if ( !SetEvent(ThreadReadyDoneEvents[Me]) ) {
        fprintf(stderr,"SMPSCALE (2) SetEvent(ThreadReadyDoneEvent[%d]) Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    i = WaitForSingleObject(hEndOfRace,INFINITE);
    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"SMPSCALE Thread %d Wait for end of recalc Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    return MyRecalcValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\char\tspin.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

HANDLE ThreadHandles[32];

DWORD
WorkerThread(
    PVOID ThreadIndex
    )
{

    DWORD Processor;
    BOOL DoSleep;

    Processor = (DWORD)ThreadIndex;
    if ( Processor > 100 ) {
        DoSleep = TRUE;
        Processor -= 100;
        }
    else {
        DoSleep = FALSE;
        }
    SetThreadAffinityMask(GetCurrentThread(),1 << Processor);
    for(;;){
        if ( Processor & 1 ) {
            SetThreadPriority(ThreadHandles[Processor-1],THREAD_PRIORITY_ABOVE_NORMAL);
            SetThreadPriority(ThreadHandles[Processor-1],THREAD_PRIORITY_NORMAL);
            }
        else {
            if ( DoSleep ) {
                Sleep(0);
                }
            }
        }
    return 0;
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD i;
    SYSTEM_INFO SystemInfo;
    DWORD ThreadId;
    HANDLE hThread;

    GetSystemInfo(&SystemInfo);
    if ( SystemInfo.dwNumberOfProcessors >= 3 ) {

        for ( i=0;i<SystemInfo.dwNumberOfProcessors;i++) {

            ThreadHandles[i] = CreateThread(
                                NULL,
                                0,
                                WorkerThread,
                                (PVOID)(i),
                                0,
                                &ThreadId
                                );

            if ( !ThreadHandles[i] ) {
                fprintf(stdout,"CreateThread failed %d\n",GetLastError());
                ExitProcess(1);
                }
            }

        for ( i=0;i<SystemInfo.dwNumberOfProcessors;i++) {
            if ( (i & 1) == 0 ) {

                hThread = CreateThread(
                            NULL,
                            0,
                            WorkerThread,
                            (PVOID)(100+i),
                            0,
                            &ThreadId
                            );

                if ( !ThreadHandles[i] ) {
                    fprintf(stdout,"CreateThread failed %d\n",GetLastError());
                    ExitProcess(1);
                    }
                CloseHandle(hThread);
                }
            }
        Sleep(60000);
        }
    ExitProcess(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\char\tlst.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>


_declspec(thread)   DWORD Id;


VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;

    Id = GetCurrentThreadId();

    printf("    TEST THREAD Id = %d vs %d\n",Id,GetCurrentThreadId());

    Sleep(1000);

    printf("    TEST THREAD Id = %d vs %d\n",Id,GetCurrentThreadId());

    ExitThread(0);
}













int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    HANDLE Thread;
    DWORD ThreadId;
    int i;

    Id = GetCurrentThreadId();

    printf("MAIN THREAD Id = %d vs %d\n",Id,GetCurrentThreadId());

    for(i=0;i<10;i++) {
        Thread = CreateThread(NULL,0L,(PVOID)TestThread,(LPVOID)99,0,&ThreadId);

        if ( !Thread ) {
            printf("Thread creation failed %d\n",GetLastError());
            }
        WaitForSingleObject(Thread,INFINITE);
        CloseHandle(Thread);

        printf("\nMAIN THREAD Id = %d vs %d\n",Id,GetCurrentThreadId());
        }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\char\lastress.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

typedef DWORD ERESOURCE;

#include "\nt\private\ntos\inc\heap.h"

#define ITERATIONS 1000
#define SIZES 10

DWORD Sizes[SIZES] = {
                      100,
                      10,
                      128,
                      256,
                      256,
                      100,
                      32,
                      64,
                      64,
                      100
                     };

VOID
LaThread(PVOID h)
{
    int i,j;
    PVOID p;

    WaitForSingleObject((HANDLE)h,INFINITE);

    for(i=0;i<ITERATIONS;i++){
        for(j=0;j<SIZES;j++) {
            if ( j & 1 ) {
                p = LocalAlloc(LMEM_FIXED,Sizes[j]);
                }
            else {
                p = LocalAlloc(LMEM_ZEROINIT,Sizes[j]);
                }
            if ( p ) {
                LocalFree(p);
                }
            else {
                printf("Alloc In Thread Failed\n");
                ExitProcess(1);
                }
            }
        }
}

VOID
StartTest(
    DWORD SpinCount,
    DWORD ThreadCount
    )
{
    PHANDLE Threads,p;
    HANDLE hStartEvent;
    DWORD Id;
    DWORD i;
    PHEAP ProcessHeap;
    PRTL_CRITICAL_SECTION HeapLock;
    DWORD Start,End;

    ProcessHeap = (PHEAP)NtCurrentPeb()->ProcessHeap;
    HeapLock = &ProcessHeap->LockVariable->Lock.CriticalSection;
    if ( HeapLock ) {
        HeapLock->DebugInfo->ContentionCount = 0;
        if ( SpinCount != 0xffffffff) {
            HeapLock->SpinCount = SpinCount;
            }
        }
    hStartEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if ( !hStartEvent ) {
        printf("CreateEvent Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    if ( ThreadCount < 2 ) {
        ThreadCount = 2;
        }
    if ( ThreadCount > 64 ) {
        ThreadCount = 64;
        }

    Threads = LocalAlloc(LMEM_ZEROINIT,sizeof(HANDLE)*ThreadCount);
    if ( !Threads ) {
        printf("Alloc Threads Failed\n");
        ExitProcess(1);
        }
    for(i=0,p=Threads;i<ThreadCount;i++,p++){

        *p = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)LaThread,
                (PVOID)hStartEvent,
                0,
                &Id
                );

        if ( !*p ) {
            printf("CreateThread Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        }
    Start = GetTickCount();
    SetEvent(hStartEvent);

    if ( WaitForMultipleObjects(ThreadCount,Threads,TRUE,INFINITE) == WAIT_FAILED ) {
        printf("WaitMultiple Failed %d\n",GetLastError());
        ExitProcess(1);
        }
    End = GetTickCount();

    for(i=0,p=Threads;i<ThreadCount;i++,p++){
        CloseHandle(*p);
        }
    CloseHandle(hStartEvent);

    if ( !HeapLock ) {
        HeapLock = &ProcessHeap->LockVariable->Lock.CriticalSection;
        if ( !HeapLock ) {
            printf("No Heap Lock found\n");
            ExitProcess(1);
            }
        }
    printf("Heap Contention Threads %2d SpinCount %5d -> Contention %7d TickCount %d\n",ThreadCount,SpinCount,HeapLock->DebugInfo->ContentionCount,End-Start);

}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    StartTest(0xffffffff,2);
    StartTest(0,2);
    StartTest(1000,2);
    StartTest(3000,2);
    StartTest(4000,2);
    StartTest(5000,2);
    StartTest(10000,2);

    printf("\n");

    StartTest(0,4);
    StartTest(1000,4);
    StartTest(3000,4);
    StartTest(4000,4);
    StartTest(5000,4);
    StartTest(10000,4);

    printf("\n");

    StartTest(0,5);
    StartTest(1000,5);
    StartTest(3000,5);
    StartTest(4000,5);
    StartTest(5000,5);
    StartTest(10000,5);

    printf("\n");

    StartTest(0,6);
    StartTest(1000,6);
    StartTest(3000,6);
    StartTest(4000,6);
    StartTest(5000,6);
    StartTest(10000,6);

    printf("\n");

    StartTest(0,8);
    StartTest(1000,8);
    StartTest(3000,8);
    StartTest(4000,8);
    StartTest(5000,8);
    StartTest(10000,8);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\char\i386\move.asm ===
title  "Move Test"
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   move.asm
;
; Abstract:
;
;   This module implements code to test x86 move instruction timing.
;
; Author:
;
;   Mark Lucovsky (markl) 28-Sep-1990
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        subttl  "Move To register"
;++
;
; VOID
; FASTCALL
; RegToMem (
;     IN ULONG Count,
;     IN PULONG Address
;     )
;
; Routine Description:
;
;   This function performs a move dword to register in a loop such that the
;   loop overhead is negligible.
;
; Arguments:
;
;   Count (ecx) - Supplies the iteration count.
;
;   Address (edx) - Supplies the source address.
;
; Return Value:
;
;   None.
;
;--

cPublicFastCall RegToMem, 2

RTM10:  mov     [edx], eax              ; repeat move 32 times in a loop
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        mov     [edx], eax              ;
        dec     ecx                     ;
        jnz     RTM10                   ;
        fstRET  RegToMem

        fstENDP RegToMem

        subttl  "Move To register"
;++
;
; VOID
; FASTCALL
; MemToReg (
;     IN ULONG Count,
;     IN PULONG Address
;     )
;
; Routine Description:
;
;   This function performs a move dword to register in a loop such that the
;   loop overhead is negligible.
;
; Arguments:
;
;   Count (ecx) - Supplies the iteration count.
;
;   Address (edx) - Supplies the source address.
;
; Return Value:
;
;   None.
;
;--

cPublicFastCall MemToReg, 2

MTR10:  mov     eax, [edx]              ; repeat move 32 times in a loop
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        mov     eax, [edx]              ;
        dec     ecx                     ;
        jnz     MTR10                   ;
        fstRET  MemToReg

        fstENDP MemToReg

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\intrlk\intrlk.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    intrlk.c

Abstract:

    This module contains code to test the generation of code for interlocked
    intrinsics.

Author:

    David N. Cutler (davec) 15-Feb-2001

Environment:

    User mode.

Revision History:

    None.

--*/

#include <ntos.h>

//
// Main program.
//

void
test (
    void
    )

{

    LONG Var1;
    LONG Cmp1;
    LONG64 Var2;
    LONG64 Cmp2;
    PVOID Ptr1;
    PVOID Ptr2;

    Cmp1 = InterlockedAnd(&Var1, 4);
    InterlockedAnd(&Cmp1, 4);

    Cmp1 = InterlockedOr(&Var1, 8);
    InterlockedOr(&Cmp1, 8);

    Cmp1 = InterlockedXor(&Var1, 16);
    InterlockedXor(&Cmp1, 16);

    Cmp2 = InterlockedAnd64(&Var2, 4);
    InterlockedAnd64(&Cmp2, 4);

    Cmp2 = InterlockedOr64(&Var2, 8);
    InterlockedOr64(&Cmp2, 8);

    Cmp2 = InterlockedXor64(&Var2, 16);
    InterlockedXor64(&Cmp2, 16);

    Cmp1 = InterlockedIncrement(&Var1);
    InterlockedIncrement(&Cmp1);

    Cmp1 = InterlockedDecrement(&Var1);
    InterlockedDecrement(&Cmp1);

    Cmp2 = InterlockedIncrement64(&Var2);
    InterlockedIncrement64(&Cmp2);

    Cmp2 = InterlockedDecrement64(&Var2);
    InterlockedDecrement64(&Var2);

    Cmp1 = InterlockedExchange(&Var1, 4);
    InterlockedExchange(&Cmp1, 8);

    Cmp2 = InterlockedExchange64(&Var2, 4);
    InterlockedExchange64(&Cmp2, 8);

    Cmp1 = InterlockedExchangeAdd(&Var1, 4);
    InterlockedExchangeAdd(&Cmp1, 8);

    Cmp2 = InterlockedExchangeAdd64(&Var2, 4);
    InterlockedExchangeAdd64(&Cmp2, 8);

    Cmp1 = InterlockedCompareExchange(&Var1, 4, Cmp1);
    InterlockedCompareExchange(&Cmp1, 8, Var1);

    Cmp2 = InterlockedCompareExchange64(&Var2, 4, Cmp2);
    InterlockedCompareExchange64(&Cmp2, 8, Var2);

    Ptr1 = InterlockedExchangePointer(&Ptr2, (PVOID)4);
    InterlockedExchangePointer(&Ptr1, Ptr2);

    Ptr1 = InterlockedCompareExchangePointer(&Ptr2, (PVOID)4, Ptr1);
    InterlockedCompareExchangePointer(&Ptr2, (PVOID)8, Ptr1);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\nbqueue\nbtest.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    nbtest.c

Abstract:

    This module contains code to stress test the nonblocking queue functions.

Author:

    David N. Cutler (davec) 19-May-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"
#include "windef.h"
#include "winbase.h"

//
// Define progress limit report value.
//

#define PROGRESS_LIMIT 1000000

ULONG Iteration = 0;
LONG Progress = 0;

//
// Define processor yield for hyperthreaded systems.
//

#if defined(_X86_)

#define YieldProcessor() __asm {rep nop}

#else

#define YieldProcessor()

#endif

//
// Define locals constants.
//

#define TABLE_SIZE 2
#define THREAD_NUMBER 2

//
// Define external prototypes.
//

typedef struct _NBQUEUE_BLOCK {
    ULONG64 Next;
    ULONG64 Data;
} NBQUEUE_BLOCK, *PNBQUEUE_BLOCK;

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    );

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    );

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    );

//
// Define local routine prototypes.
//

NTSTATUS
MyCreateThread (
    OUT PHANDLE Handle,
    IN PUSER_THREAD_START_ROUTINE StartRoutine,
    PVOID Context

    );

VOID
StressNBQueueEven (
    VOID
    );

VOID
StressNBQueueOdd (
    VOID
    );

NTSTATUS
ThreadMain (
    IN PVOID Context
    );

//
// Define static storage.
//

HANDLE Thread1Handle;
HANDLE Thread2Handle;

//
// Define nonblocking queues
//

PVOID ClrQueue;
PVOID SetQueue;

SLIST_HEADER SListHead;

LONG Table[TABLE_SIZE];

volatile ULONG StartSignal = 0;
ULONG StopSignal = 0;

//
// Begin test code.
//

int
__cdecl
main(
    int argc,
    char *argv[]
    )

{

    ULONG Index;
    PSLIST_ENTRY Entry;
    NTSTATUS Status;

    //
    // Initialize the SLIST headers and insert TABLE_SIZE + 2 entries.
    //

    RtlInitializeSListHead(&SListHead);
    for (Index = 0; Index < (TABLE_SIZE + 2); Index += 1) {
        Entry = (PSLIST_ENTRY)malloc(sizeof(NBQUEUE_BLOCK));
        if (Entry == NULL) {
            printf("unable to allocate SLIST entry\n");
            return 0;
        }

        InterlockedPushEntrySList(&SListHead, Entry);
    }

    //
    // Initialize the clear entry nonblocking queue elements.
    //

    ClrQueue = ExInitializeNBQueueHead(&SListHead);
    if (ClrQueue == NULL) {
        printf("unable to initialize clr nonblock queue\n");
        return 0;
    }

    for (Index = 0; Index < (TABLE_SIZE / 2); Index += 1) {
        if (ExInsertTailNBQueue(ClrQueue, Index) == FALSE) {
            printf("unable to insert in clear nonblocking queue\n");
            return 0;
        }

        Table[Index] = 0;
    }

    //
    // Initialize the set entry nonblocking queue elements.
    //

    SetQueue = ExInitializeNBQueueHead(&SListHead);
    if (SetQueue == NULL) {
        printf("unable to initialize set nonblock queue\n");
        return 0;
    }

    for (Index = (TABLE_SIZE / 2); Index < TABLE_SIZE; Index += 1) {
        if (ExInsertTailNBQueue(SetQueue, Index) == FALSE) {
            printf("unable to insert in set nonblocking queue\n");
            return 0;
        }

        Table[Index] = 1;
    }

    //
    // Create and start second thread.
    //

    Status = MyCreateThread(&Thread1Handle,
                            ThreadMain,
                            (PVOID)1);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to create thread during initialization\n");
        return 0;

    } else {
        StartSignal = 1;
        StressNBQueueEven();
    }

    return 0;
}

VOID
StressNBQueueEven (
    VOID
    )

{

    ULONG64 Value;

    do {
        do {

            //
            // Attempt to remove an entry from the clear queue.
            //
            // Entries in this list should be clear in the table array.
            //
    
            if (ExRemoveHeadNBQueue(ClrQueue, &Value) != FALSE) {
                if ((ULONG)Value > 63) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }

                if (InterlockedExchange(&Table[(ULONG)Value], 1) != 0) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
                if (ExInsertTailNBQueue(SetQueue, (ULONG)Value) == FALSE) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
            } else {
                break;
            }
    
            if (InterlockedIncrement(&Progress) > PROGRESS_LIMIT) {
                InterlockedExchange(&Progress, 0);
                Iteration += 1;
                printf("progress report iteration %d\n", Iteration);
            }
    
            YieldProcessor();
        } while (TRUE);

        do {
    
            //
            // Attempt to remove an entry from the set queue.
            //
            // Entries in this list should be set in the table array.
            //
    
            if (ExRemoveHeadNBQueue(SetQueue, &Value) != FALSE) {
                if ((ULONG)Value > 63) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }

                if (InterlockedExchange(&Table[(ULONG)Value], 0) != 1) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
                if (ExInsertTailNBQueue(ClrQueue, (ULONG)Value) == FALSE) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
            } else {
                break;
            }
    
            if (InterlockedIncrement(&Progress) > PROGRESS_LIMIT) {
                InterlockedExchange(&Progress, 0);
                Iteration += 1;
                printf("progress report iteration %d\n", Iteration);
            }
    
            YieldProcessor();
        } while (TRUE);

    } while (TRUE);

    return;
}

VOID
StressNBQueueOdd (
    VOID
    )

{

    ULONG64 Value;

    do {
        do {
    
            //
            // Attempt to remove an entry from the set queue.
            //
            // Entries in this list should be set in the table array.
            //
    
            if (ExRemoveHeadNBQueue(SetQueue, &Value) != FALSE) {
                if ((ULONG)Value > 63) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }

                if (InterlockedExchange(&Table[(ULONG)Value], 0) != 1) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
        
                if (ExInsertTailNBQueue(ClrQueue, (ULONG)Value) == FALSE) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
            } else {
                break;
            }

            InterlockedIncrement(&Progress);
            YieldProcessor();
        } while (TRUE);

        do {
    
            //
            // Attempt to remove an entry from the clear queue.
            //
            // Entries in this list should be clear in the table array.
            //
    
            if (ExRemoveHeadNBQueue(ClrQueue, &Value) != FALSE) {
                if ((ULONG)Value > 63) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }

                if (InterlockedExchange(&Table[(ULONG)Value], 1) != 0) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
                if (ExInsertTailNBQueue(SetQueue, (ULONG)Value) == FALSE) {
                    StopSignal = 1;
                    DbgBreakPoint();
                }
    
            } else {
                break;
            }
    
            InterlockedIncrement(&Progress);
            YieldProcessor();
        } while (TRUE);

    } while (TRUE);

    return;
}

NTSTATUS
ThreadMain (
    IN PVOID Context
    )

{

    //
    // Wait until start signal is given.
    //

    do {
    } while (StartSignal == 0);

    StressNBQueueOdd();
    return STATUS_SUCCESS;
}

NTSTATUS
MyCreateThread (
    OUT PHANDLE Handle,
    IN PUSER_THREAD_START_ROUTINE StartRoutine,
    PVOID Context
    )

{

    NTSTATUS Status;

    //
    // Create a thread and start its execution.
    //

    Status = RtlCreateUserThread(NtCurrentProcess(),
                                 NULL,
                                 FALSE,
                                 0,
                                 0,
                                 0,
                                 StartRoutine,
                                 Context,
                                 Handle,
                                 NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\nt\hrderr.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    ULONG ErrorParameters[2];
    ULONG ErrorResponse;
    UNICODE_STRING PathName;

    RtlInitUnicodeString(&PathName,L"\\\\??\\O:\\AUTORUN.EXE");
    ErrorResponse = ResponseOk;
    ErrorParameters[0] = (ULONG)&PathName;

    NtRaiseHardError( STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE,
                      1,
                      1,
                      ErrorParameters,
                      OptionOk,
                      &ErrorResponse
                    );

    RtlInitUnicodeString(&PathName,L"\\\\??\\O:\\autorun.exe");
    ErrorResponse = ResponseOk;
    ErrorParameters[0] = (ULONG)&PathName;

    NtRaiseHardError( STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE,
                      1,
                      1,
                      ErrorParameters,
                      OptionOk,
                      &ErrorResponse
                    );
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\nt\ntbm.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>


#define ONEK    1000
#define FIVEK   5000
#define TENK    10000
#define ONEHUNK 100000
#define ONEMIL  1000000


//
// Define local types.
//

typedef struct _PERFINFO {
    DWORD StartTime;
    DWORD StopTime;
    LPSTR Title;
    DWORD Iterations;
} PERFINFO, *PPERFINFO;

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    DWORD ContextSwitches;
    DWORD Duration;
    DWORD Performance;


    //
    // Print results and announce end of test.
    //

    PerfInfo->StopTime = GetTickCount();

    Duration = PerfInfo->StopTime - PerfInfo->StartTime;
    printf("        Test time in milliseconds %d\n", Duration);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Duration;
    printf("        Iterations per second     %d\n", Performance);


    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN DWORD Iterations,
    IN PPERFINFO PerfInfo
    )

{

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    PerfInfo->StartTime = GetTickCount();
    return;
}

HANDLE
APIENTRY
FastFindOpenDir(
    LPCWSTR lpFileName
    )

{

    HANDLE hFindFile;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    UNICODE_STRING UnicodeInput;
    BOOLEAN EndsInDot;

    RtlInitUnicodeString(&UnicodeInput,lpFileName);

    //
    // Bogus code to workaround ~* problem
    //

    if ( UnicodeInput.Buffer[(UnicodeInput.Length>>1)-1] == (WCHAR)'.' ) {
        EndsInDot = TRUE;
        }
    else {
        EndsInDot = FALSE;
        }


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &PathName,
                            &FileName.Buffer,
                            NULL
                            );

    if ( !TranslationStatus ) {
        return NULL;
        }

    FreeBuffer = PathName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(
                &hFindFile,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( !NT_SUCCESS(Status) ) {
        return NULL;
        }
    return hFindFile;
}

BOOL
FastFind(
    HANDLE hFindFile,
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID FreeBuffer;
    UNICODE_STRING UnicodeInput;
    BOOLEAN EndsInDot;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    CHAR Buffer[MAX_PATH*2 + sizeof(FILE_BOTH_DIR_INFORMATION)];

    RtlInitUnicodeString(&FileName,lpFileName);
    DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION)Buffer;

    Status = NtQueryDirectoryFile(
                hFindFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                DirectoryInfo,
                sizeof(Buffer),
                FileBothDirectoryInformation,
                TRUE,
                &FileName,
                TRUE
                );

    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
        }

    //
    // Attributes are composed of the attributes returned by NT.
    //

    lpFindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
    lpFindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
    lpFindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
    lpFindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
    lpFindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
    lpFindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

    RtlMoveMemory( lpFindFileData->cFileName,
                   DirectoryInfo->FileName,
                   DirectoryInfo->FileNameLength );

    lpFindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

    RtlMoveMemory( lpFindFileData->cAlternateFileName,
                   DirectoryInfo->ShortName,
                   DirectoryInfo->ShortNameLength );

    lpFindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

    return TRUE;
}


VOID
FastFindTest(
    VOID

    )
{
    PERFINFO PerfInfo;
    int i;
    HANDLE hFind;
    WIN32_FIND_DATAW FindFileData;
    BOOL b;


    hFind = FastFindOpenDir(L"d:\\testdir\\client1\\bench");

    if ( !hFind ) {
        printf("Failed\n");
        return;
        }

    StartBenchMark(
        "FastFind Test",
        ONEK,
        &PerfInfo
        );

    for ( i=0;i<5*ONEK;i++) {

        //
        // do 5 calls 3 work, 2 don't
        //

        b = FastFind(hFind,L"a",&FindFileData);
        if ( !b ) {
            printf("Test Failure a\n");
            ExitProcess(0);
            }
        b = FastFind(hFind,L"ab",&FindFileData);
        if ( b ) {
            printf("Test Failure ab\n");
            ExitProcess(0);
            }
        b = FastFind(hFind,L"abc",&FindFileData);
        if ( !b ) {
            printf("Test Failure abc\n");
            ExitProcess(0);
            }
        b = FastFind(hFind,L"da",&FindFileData);
        if ( b ) {
            printf("Test Failure da\n");
            ExitProcess(0);
            }
        b = FastFind(hFind,L"dxxa",&FindFileData);
        if ( !b ) {
            printf("Test Failure dxxa\n");
            ExitProcess(0);
            }
        }

    FinishBenchMark(&PerfInfo);
}

VOID
FindFirstTest(
    VOID

    )
{
    PERFINFO PerfInfo;
    int i;
    HANDLE hFind;
    WIN32_FIND_DATAW FindFileData;
    BOOL b;


    StartBenchMark(
        "Stock FindFirst Test",
        ONEK,
        &PerfInfo
        );

    for ( i=0;i<5*ONEK;i++) {

        //
        // do 5 calls 3 work, 2 don't
        //

        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\a",&FindFileData);
        if ( hFind == INVALID_HANDLE_VALUE ) {
            printf("Test Failure a\n");
            ExitProcess(0);
            }
        FindClose(hFind);

        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\ab",&FindFileData);
        if ( hFind != INVALID_HANDLE_VALUE ) {
            printf("Test Failure ab\n");
            ExitProcess(0);
            }

        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\abc",&FindFileData);
        if ( hFind == INVALID_HANDLE_VALUE ) {
            printf("Test Failure abc\n");
            ExitProcess(0);
            }
        FindClose(hFind);


        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\da",&FindFileData);
        if ( hFind != INVALID_HANDLE_VALUE ) {
            printf("Test Failure da\n");
            ExitProcess(0);
            }


        hFind = FindFirstFileW(L"d:\\testdir\\client1\\bench\\dxxa",&FindFileData);
        if ( hFind == INVALID_HANDLE_VALUE ) {
            printf("Test Failure dxxa\n");
            ExitProcess(0);
            }
        FindClose(hFind);

        }

    FinishBenchMark(&PerfInfo);
}

VOID
APIENTRY
CreateOpenDirObja(
    LPCWSTR lpFileName,
    POBJECT_ATTRIBUTES Obja,
    PUNICODE_STRING PathName,
    LPCWSTR DirName
    )

{

    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    HANDLE hDir;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(DirName) ) {


        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                DirName,
                                PathName,
                                &FileName.Buffer,
                                NULL
                                );

        if ( TranslationStatus ) {


            //
            // Open the directory for list access
            //

            InitializeObjectAttributes(
                Obja,
                PathName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

            Status = NtOpenFile(
                        &hDir,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                        );

            if ( !NT_SUCCESS(Status) ) {
                printf("Open faild %x\n",Status);
                ExitProcess(1);
                }
            }

        }
    else {
        hDir = NULL;
        }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            PathName,
                            &FileName.Buffer,
                            NULL
                            );

    if ( !TranslationStatus ) {
        return;
        }

    if ( hDir ) {
        PathName->Buffer = PathName->Buffer + 15;
        PathName->Length -= 30;
        PathName->MaximumLength -= 30;
        }

    FreeBuffer = PathName->Buffer;

    InitializeObjectAttributes(
        Obja,
        PathName,
        OBJ_CASE_INSENSITIVE,
        hDir,
        NULL
        );
}

VOID
APIENTRY
OpenCloseDir(
    POBJECT_ATTRIBUTES Obja
    )

{

    HANDLE hDir;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(
                &hDir,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( !NT_SUCCESS(Status) ) {
        printf("Open faild %x\n",Status);
        ExitProcess(1);
        }
    NtClose(hDir);
}

VOID
OpenDirTest(
    VOID

    )
{
    PERFINFO PerfInfo;
    int i;
    HANDLE hDir;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING PathName;
    FILE_BASIC_INFORMATION BasicInfo;

#if 0
    CreateOpenDirObja(
        L"d:\\testdir\\client1\\bench",
        &Obja,
        &PathName,
        NULL
        );

    StartBenchMark(
        "Open Dir NTFS d:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        OpenCloseDir(&Obja);
        }

    FinishBenchMark(&PerfInfo);

    StartBenchMark(
        "NtQueryAttributes Dir NTFS d:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        NtQueryAttributesFile( &Obja, &BasicInfo );

        }

    FinishBenchMark(&PerfInfo);


    CreateOpenDirObja(
        L"c:\\testdir\\client1\\bench",
        &Obja,
        &PathName,
        NULL
        );

    StartBenchMark(
        "Open Dir FAT c:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        OpenCloseDir(&Obja);
        }

    FinishBenchMark(&PerfInfo);
#endif

    CreateOpenDirObja(
        L"d:\\testdir\\client1\\bench",
        &Obja,
        &PathName,
        L"d:\\"
        );

    StartBenchMark(
        "VOL Rel Open Dir NTFS d:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        OpenCloseDir(&Obja);
        }

    FinishBenchMark(&PerfInfo);


    CreateOpenDirObja(
        L"c:\\testdir\\client1\\bench",
        &Obja,
        &PathName,
        L"c:\\"
        );

    StartBenchMark(
        "Vol Rel Open Dir FAT c:\\testdir\\client1\\bench",
        FIVEK,
        &PerfInfo
        );

    for ( i=0;i<FIVEK;i++) {

        OpenCloseDir(&Obja);
        }

    FinishBenchMark(&PerfInfo);
}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    DWORD CryptoKey;
    PDWORD p;

    printf("sixeof teb %x\n",sizeof(TEB));

    CryptoKey = USER_SHARED_DATA->CryptoExponent;

    printf("Key %x\n",CryptoKey);

    p = &(USER_SHARED_DATA->CryptoExponent);
    *p = 1;

    //OpenDirTest();
    //FastFindTest();
    //FindFirstTest();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\nbqueue\i386\intrlk.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    slist.asm
;
; Abstract:
;
;    This module implements functions to support interlocked S-List
;    operations.
;
; Author:
;
;    David N. Cutler (davec) 13-Mar-1996
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; LONG64
; FASTCALL
; xInterlockedCompareExchange64 (
;    IN OUT PLONG64 Destination,
;    IN PLONG64 Exchange,
;    IN PLONG64 Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall xInterlockedCompareExchange64, 3

cPublicFpo 0,2

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  xInterlockedCompareExchange64

fstENDP xInterlockedCompareExchange64

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\nbqueue\nbqueue.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nbqueue.c

Abstract:

   This module implements non-blocking fifo queue.

Author:

    David N. Cutler (davec) 24-Apr-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"
#include "malloc.h"

VOID
DbgBreakPoint (
    VOID
    );
extern ULONG StopSignal;

//
// Define non-blocking interlocked queue functions.
//
// A non-blocking queue is a singly link list of queue entries with a
// head pointer and a tail pointer. The head and tail pointers use
// sequenced pointers as do next links in the entries themselves. The
// queueing discipline is FIFO. New entries are inserted at the tail
// of the list and current entries are removed from the front of the
// list.
//
// Non-blocking queues require a descriptor for each entry in the queue.
// A descriptor consists of a sequenced next pointer and a PVOID data
// value. Descriptors for a queue must be preallocated and inserted in
// an SLIST before calling the function to initialize a non-blocking
// queue header. The SLIST should have as many entries as required for
// the respective queue.
//

typedef struct _NBQUEUE_BLOCK {
    ULONG64 Next;
    ULONG64 Data;
} NBQUEUE_BLOCK, *PNBQUEUE_BLOCK;

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    );

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    );

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    );

#if defined(_X86_)

#define InterlockedCompareExchange64(Destination, Exchange, Comperand) \
    xInterlockedCompareExchange64(Destination, &(Exchange), &(Comperand))

LONG64
__fastcall
xInterlockedCompareExchange64 (
    IN OUT LONG64 volatile * Destination,
    IN PLONG64 Exchange,
    IN PLONG64 Comparand
    );

#elif defined(_IA64_)

#define InterlockedCompareExchange64 _InterlockedCompareExchange64

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

#pragma intrinsic(_InterlockedCompareExchange64)

#endif

//
// Define queue pointer structure - this is platform target specific.
//

#if defined(_AMD64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 48;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_X86_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG Count;
        LONG Node;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_IA64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 45;
        LONG64 Region : 3;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;


#else

#error "no target architecture"

#endif

//
// Define queue node struture.
//

typedef struct _NBQUEUE_NODE {
    NBQUEUE_POINTER Next;
    ULONG64 Value;
} NBQUEUE_NODE, *PNBQUEUE_NODE;

//
// Define inline functions to pack and unpack pointers in the platform
// specific non-blocking queue pointer structure.
//

#if defined(_AMD64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)((LONG64)(Entry->Node));
}

#elif defined(_X86_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)(Entry->Node);
}

#elif defined(_IA64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    Entry->Region = (LONG64)Node >> 61;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{

    LONG64 Value;

    Value = Entry->Node & 0x1fffffffffffffff;
    Value |= Entry->Region << 61;
    return (PVOID)(Value);
}

#else

#error "no target architecture"

#endif

//
// Define queue descriptor structure.
//

typedef struct _NBQUEUE_HEADER {
    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Tail;
    PSLIST_HEADER SlistHead;
} NBQUEUE_HEADER, *PNBQUEUE_HEADER;

typedef struct _NBQUEUE_LOG {
    ULONG_PTR Type;
    PNBQUEUE_HEADER Queue;
    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Tail;
    NBQUEUE_POINTER Next;
    ULONG_PTR Value;
    PNBQUEUE_NODE Node;
    PVOID *Address;
    ULONG_PTR Fill;
} NBQUEUE_LOG, *PNBQUEUE_LOG;

#define NBQUEUE_LOG_SIZE 64

NBQUEUE_LOG NbLog[NBQUEUE_LOG_SIZE + 1];

ULONG xLogIndex = -1;

#define LogInsertData(_queue_, _head_, _tail_, _next_) { \
    if (StopSignal != 0) {                               \
        LogIndex = NBQUEUE_LOG_SIZE;                     \
    } else {                                             \
        LogIndex = InterlockedIncrement(&xLogIndex) & (NBQUEUE_LOG_SIZE - 1); \
    }                                                    \
    NbLog[LogIndex].Type = 0;                            \
    NbLog[LogIndex].Queue = _queue_;                     \
    NbLog[LogIndex].Head.Data = (_head_);                \
    NbLog[LogIndex].Tail.Data = (_tail_);                \
    NbLog[LogIndex].Next.Data = (_next_);                \
}

#define LogRemoveData(_queue_, _head_, _tail_, _next_) { \
    if (StopSignal != 0) {                               \
        LogIndex = NBQUEUE_LOG_SIZE;                     \
    } else {                                             \
        LogIndex = InterlockedIncrement(&xLogIndex) & (NBQUEUE_LOG_SIZE - 1); \
    }                                                    \
    NbLog[LogIndex].Type = 1;                            \
    NbLog[LogIndex].Queue = _queue_;                     \
    NbLog[LogIndex].Head.Data = (_head_);                \
    NbLog[LogIndex].Tail.Data = (_tail_);                \
    NbLog[LogIndex].Next.Data = (_next_);                \
}

#pragma alloc_text(PAGE, ExInitializeNBQueueHead)

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    )

/*++

Routine Description:

    This function initializes a non-blocking queue header.

    N.B. It is assumed that the specified SLIST has been populated with
         non-blocking queue nodes prior to calling this routine.

Arguments:

    SlistHead - Supplies a pointer to an SLIST header.

Return Value:

    If the non-blocking queue is successfully initialized, then the
    address of the queue header is returned as the function value.
    Otherwise, NULL is returned as the function value.

--*/

{

    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;

    //
    // Attempt to allocate the queue header. If the allocation fails, then
    // return NULL.
    //

    QueueHead = (PNBQUEUE_HEADER)malloc(sizeof(NBQUEUE_HEADER));
    if (QueueHead == NULL) {
        return NULL;
    }

    //
    // Attempt to allocate a queue node from the specified SLIST. If a node
    // can be allocated, then initialize the non-blocking queue header and
    // return the address of the queue header. Otherwise, free the queue
    // header and return NULL.
    //

    QueueHead->SlistHead = SlistHead;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);

    if (QueueNode != NULL) {

        //
        // Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = 0;

        //
        // Initialize the head and tail pointers in the queue header.
        //

        PackNBQPointer(&QueueHead->Head, QueueNode);
        QueueHead->Head.Count = 0;
        PackNBQPointer(&QueueHead->Tail, QueueNode);
        QueueHead->Tail.Count = 0;
        return QueueHead;

    } else {
        free(QueueHead);
        return NULL;
    }
}

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    )

/*++

Routine Description:

    This function inserts the specific data value at the tail of the
    specified non-blocking queue.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to an opaque data value.

Return Value:

    If the specified opaque data value is successfully inserted at the tail
    of the specified non-blocking queue, then a value of TRUE is returned as
    the function value. Otherwise, a value of FALSE is returned.

    N.B. FALSE is returned if a queue node cannot be allocated from the
         associated SLIST.

--*/

{

    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Insert;
    ULONG LogIndex;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // Attempt to allocate a queue node from the SLIST associated with
    // the specified non-blocking queue. If a node can be allocated, then
    // the node is inserted at the tail of the specified non-blocking
    // queue, and TRUE is returned as the function value. Otherwise, FALSE
    // is returned.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);

    if (QueueNode != NULL) {

        //
        //  Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = Value;

        //
        // The following loop is executed until the specified entry can
        // be safely inserted at the tail of the specified non-blocking
        // queue.
        //

        do {

            //
            // Read the tail queue pointer and the next queue pointer of
            // the tail queue pointer making sure the two pointers are
            // coherent.
            //

            Head.Data = *((volatile LONG64 *)(&QueueHead->Head.Data));
            Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
            TailNode = UnpackNBQPointer(&Tail);
            Next.Data = *((volatile LONG64 *)(&TailNode->Next.Data));
            LogInsertData(QueueHead, Head.Data, Tail.Data, Next.Data);
            NbLog[LogIndex].Address = &Header;

            QueueNode->Next.Count = Tail.Count + 1;
            if (Tail.Data == *((volatile LONG64 *)(&QueueHead->Tail.Data))) {

                //
                // If the tail is pointing to the last node in the list,
                // then attempt to insert the new node at the end of the
                // list. Otherwise, the tail is not pointing to the last
                // node in the list and an attempt is made to move the
                // tail pointer to the next node.
                //

                NextNode = UnpackNBQPointer(&Next);
                if (NextNode == NULL) {
                    PackNBQPointer(&Insert, QueueNode);
                    Insert.Count = Next.Count + 1;
                    if (InterlockedCompareExchange64(&TailNode->Next.Data,
                                                     Insert.Data,
                                                     Next.Data) == Next.Data) {

                        NbLog[LogIndex].Value = (ULONG)Value;
                        NbLog[LogIndex].Node = QueueNode;
                        break;

                    } else {
                        NbLog[LogIndex].Value = 0xffffffff;
                        NbLog[LogIndex].Node = QueueNode;
                    }

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    if (InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                     Insert.Data,
                                                     Tail.Data) == Tail.Data) {

                        NbLog[LogIndex].Value = 0xffffff00;
                        NbLog[LogIndex].Node = QueueNode;

                    } else {
                        NbLog[LogIndex].Value = 0xffff0000;
                        NbLog[LogIndex].Node = QueueNode;
                    }
                }

            } else {
                NbLog[LogIndex].Value = 0x000000ff;
                NbLog[LogIndex].Node = QueueNode;
            }

        } while (TRUE);

        //
        // Attempt to move the tail to the new tail node.
        //


        LogInsertData(QueueHead, Head.Data, Tail.Data, Next.Data);
        NbLog[LogIndex].Address = &Header;
        PackNBQPointer(&Insert, QueueNode);
        Insert.Count = Tail.Count + 1;
        if (InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                         Insert.Data,
                                         Tail.Data) == Tail.Data) {

            NbLog[LogIndex].Value = 0x0000ffff;
            NbLog[LogIndex].Node = QueueNode;

        } else {
            NbLog[LogIndex].Value = 0x00ffffff;
            NbLog[LogIndex].Node = QueueNode;
        }

        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    )

/*++

Routine Description:

    This function removes a queue entry from the head of the specified
    non-blocking queue and returns the associated data value.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to a variable that receives the queue
        element value.

Return Value:

    If an entry is removed from the specified non-blocking queue, then
    TRUE is returned as the function value. Otherwise, FALSE is returned.

--*/

{

    NBQUEUE_POINTER Head;
    PNBQUEUE_NODE HeadNode;
    NBQUEUE_POINTER Insert;
    ULONG LogIndex;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // The following loop is executed until an entry can be removed from
    // the specified non-blocking queue or until it can be determined that
    // the queue is empty.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;

    do {

        //
        // Read the head queue pointer, the tail queue pointer, and the
        // next queue pointer of the head queue pointer making sure the
        // three pointers are coherent.
        //

        Head.Data = *((volatile LONG64 *)(&QueueHead->Head.Data));
        Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
        HeadNode = UnpackNBQPointer(&Head);
        Next.Data = *((volatile LONG64 *)(&HeadNode->Next.Data));
        LogRemoveData(QueueHead, Head.Data, Tail.Data, Next.Data);
        NbLog[LogIndex].Address = &Header;

        if (Head.Data == *((volatile LONG64 *)(&QueueHead->Head.Data))) {

            //
            // If the queue header node is equal to the queue tail node,
            // then either the queue is empty or the tail pointer is falling
            // behind. Otherwise, there is an entry in the queue that can
            // be removed.
            //

            NextNode = UnpackNBQPointer(&Next);
            TailNode = UnpackNBQPointer(&Tail);
            if (HeadNode == TailNode) {

                //
                // If the next node of head pointer is NULL, then the queue
                // is empty. Otherwise, attempt to move the tail forward.
                //

                if (NextNode == NULL) {
                    NbLog[LogIndex].Value = 0xffffffff;
                    NbLog[LogIndex].Node = NULL;
                    *Value = 0xffffffff;
                    return FALSE;

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    if (InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                 Insert.Data,
                                                 Tail.Data) == Tail.Data) {

                        NbLog[LogIndex].Value = 0xffffff00;
                        NbLog[LogIndex].Node = NULL;

                    } else {
                        NbLog[LogIndex].Value = 0xffff0000;
                        NbLog[LogIndex].Node = NULL;
                    }
                }

            } else {

                //
                // Attempt to remove the first entry at the head of the queue.
                //

                *Value = ((ULONG64)LogIndex << 32) | NextNode->Value;
                PackNBQPointer(&Insert, NextNode);
                Insert.Count = Head.Count + 1;
                if (InterlockedCompareExchange64(&QueueHead->Head.Data,
                                                 Insert.Data,
                                                 Head.Data) == Head.Data) {

                    NbLog[LogIndex].Value = (ULONG)*Value;
                    NbLog[LogIndex].Node = NextNode;
                    break;

                } else {
                    NbLog[LogIndex].Value = 0x00ffffff;
                    NbLog[LogIndex].Node = NextNode;
                }
            }

        } else {
            NbLog[LogIndex].Value = 0x0000ffff;
            NbLog[LogIndex].Node = NULL;
        }

    } while (TRUE);

    //
    // Free the node that was removed for the list by inserting the node
    // in the associated SLIST.
    //

    InterlockedPushEntrySList(QueueHead->SlistHead,
                              (PSLIST_ENTRY)HeadNode);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\single\single.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slisttest.c

Abstract:

    This module implements a program which tests the interlocked SLIST
    functions exported from kernel32.dll. Since these functions are
    implemented in Win2000 and are just being exposed to windows programs
    this program is not an exhaustive test. Rather it just tests whether
    the interfaces exposed correctly.

Author:

    David N. Cutler (davec) 10-Jan-2000

Environment:

    User mode.

Revision History:

    None.

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include "d:\ntroot\base\ntos\inc\intrlk.h"

#pragma intrinsic(__readgsdword)

//
// Define structure that will be used in SLIST.
//

typedef struct _PROGRAM_ITEM {

    //
    // Normally a SINGLE_LIST_ENTRY is the first member of the program
    // item structure, but it can be any member as long as the address
    // of the containing structure is computed correctly.
    //

    SINGLE_LIST_ENTRY ItemEntry;

    //
    // Additional members in the structure would be used for data
    // associated with whatever the program item represents. Here
    // the only use is for a signature that will be used for the
    // test.
    //

    ULONG Signature;
} PROGRAM_ITEM, *PPROGRAM_ITEM;

void
foo (
    IN UCHAR *pjSrc,
    IN UCHAR *pjDst
    )

{

    *(ULONG64 UNALIGNED *)pjDst = *(volatile ULONG64 *)pjSrc;
}

//
// Main program.
//

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )

{

    ULONG Count;
    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY LastEntry;
    SINGLE_LIST_ENTRY ListHead;
    PPROGRAM_ITEM ProgramItem;

    ListHead.Next = NULL;
    LastEntry = NULL;
    for (Count = 1; Count < 100; Count += 1) {
        ProgramItem = (PPROGRAM_ITEM)malloc(sizeof(*ProgramItem));
        ProgramItem->Signature = Count;
        FirstEntry = InterlockedPushEntrySingleList(&ListHead,
                                                    &ProgramItem->ItemEntry);

        if (FirstEntry != LastEntry) {
            printf("wrong old first entry\n");
        }

        LastEntry = &ProgramItem->ItemEntry;
//        Count = _byteswap_ulong(Count);
        Count = __readgsdword(Count);
    }

    for (Count = 99; Count > 0; Count -= 1) {
        FirstEntry = InterlockedPopEntrySingleList(&ListHead);
        ProgramItem = CONTAINING_RECORD(FirstEntry, PROGRAM_ITEM, ItemEntry);
        if (ProgramItem->Signature != Count) {
            printf("wring entry removed\n");
        }
    }

    if (ListHead.Next != NULL) {
        printf("list not empty\n");
    }

    printf("program ran successfully\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\slist\slist1.c ===
#include <stdio.h>
#include <stdlib.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

HANDLE rpipe, wpipe;
ULONG buf[1];
IO_STATUS_BLOCK iosb;


VOID
Save (
    ULONG Count)
{
    DWORD i;
    NTSTATUS status;
    DWORD retlen;

    for (i = 0; i < Count; i++) {
        status = NtFsControlFile (wpipe,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &iosb,
                                  FSCTL_PIPE_INTERNAL_WRITE,
                                  buf, sizeof (buf),
                                  NULL, 0);
        if (!NT_SUCCESS (status)) {
            printf ("NtFsControlFile failed %X\n", status);
            ExitProcess (1);
        }
    }

}
VOID
Restore (
    ULONG Count)
{
    IO_STATUS_BLOCK iosb;
    DWORD i;
    NTSTATUS status;
    DWORD retlen;

    for (i = 0; i < Count; i++) {
        if (!ReadFile (rpipe, buf, sizeof (buf), &retlen, NULL)) {
            printf ("ReadFileEx failed %d\n", GetLastError ());
            ExitProcess (1);
        }
    }

}
VOID
Invert (
    ULONG Count)
{
    Save (Count);
    Restore (Count);
}

DWORD
WINAPI
Thrash (LPVOID arg)
{
    IO_STATUS_BLOCK iosb;
    ULONG i;
    HANDLE Handle1, Handle2, Handle3;

    if (!arg) {
        SetThreadAffinityMask (GetCurrentThread (), 1);
        while (1) {

            NtQueryEaFile (NULL,
                           &iosb,
                           NULL,
                           0,
                           FALSE,
                           &buf,
                           sizeof (buf),
                           NULL,
                           FALSE);
        }
    } else {
        while (1) {

            SetThreadAffinityMask (GetCurrentThread (), 1);
            Save (1);
            Sleep (0);
            SetThreadAffinityMask (GetCurrentThread (), 2);

            NtSuspendThread ((HANDLE) arg, NULL);

            SetThreadAffinityMask (GetCurrentThread (), 1);

            Invert (2);


            for (i = 0; i < 256-2; i++) {
                NtQueryEaFile (NULL,
                               &iosb,
                               NULL,
                               0,
                               FALSE,
                               &buf,
                               sizeof (buf),
                               NULL,
                               FALSE);
            }

            NtResumeThread ((HANDLE) arg, NULL);
            Sleep (0);
            Restore (1);
            SetThreadAffinityMask (GetCurrentThread (), 2);
        }
    }
    return 0;
}


int __cdecl main ()
{
    ULONG i;
    HANDLE thread1;
    DWORD id;
    DWORD mode;
    OVERLAPPED ovl={0};

    wpipe = CreateNamedPipe ("\\\\.\\pipe\\testpipe",
                             PIPE_ACCESS_DUPLEX|FILE_FLAG_OVERLAPPED,
                             PIPE_TYPE_MESSAGE|PIPE_READMODE_MESSAGE|PIPE_WAIT,
                             1,
                             100,
                             100,
                             100000,
                             NULL);
    if (wpipe == INVALID_HANDLE_VALUE) {
        printf ("CreateNamedPipe failed %d\n", GetLastError ());
        ExitProcess (1);
    }
    if (!ConnectNamedPipe (wpipe, &ovl)) {
        if (GetLastError () != ERROR_IO_PENDING) {
            printf ("ConnectNamedPipe failed %d\n", GetLastError ());
            ExitProcess (1);
        }
    }

    rpipe = CreateFile ("\\\\.\\pipe\\testpipe",
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED,
                        NULL);
    if (rpipe == INVALID_HANDLE_VALUE) {
        printf ("CreateFile failed %d\n", GetLastError ());
        ExitProcess (1);
    }
    mode = PIPE_READMODE_MESSAGE|PIPE_WAIT;
    if (!SetNamedPipeHandleState (rpipe, &mode, NULL, NULL)) {
        printf ("SetNamedPipeHandleState failed %d\n", GetLastError ());
        ExitProcess (1);
    }

    thread1 = CreateThread (NULL, 0, Thrash, NULL, 0, &id);
    if (!thread1) {
       printf ("CreateThread failed %d\n", GetLastError ());
       exit (EXIT_FAILURE);
    }

    Thrash (thread1);
    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\slist\amd64\tf.asm ===
TITLE  "Trap Frame Test Program"
;++
;
; Copyright (c) 2001 Microsoft Corporation
;
; Module Name:
;
;    tf.asm
;
; Abstract:
;
;    This is a test program that generates a trap frame with and without an
;    error code.
;
; Author:
;
;    David N. Cutler (davec) 11-Feb-2001
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

        LEAF_ENTRY KiInitiateUserApc, _TEXT$00

        retq                            ;

        LEAF_END KiInitiateUserApc, _TEXT$00

        subttl  "Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; ExceptionHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PDISPATCHER_CONTEXT DispatcherContext
;    )
;
; Routine Description:
;
;   This routine is an exception handler for the trap frame below with a
;   handler.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to  the dispatcher context
;       record.
;
; Return Value:
;
;   The exception disposition.
;
;--

        LEAF_ENTRY ExceptionHandler, _TEXT$00

        mov     eax, EXCEPTION_CONTINUE_SEARCH ; assume continue search
        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; test for unwind
        jnz     short Eh10              ; if nz, unwind in progress
        mov     eax, EXCEPTION_CONTINUE_EXECUTION ; set to continue execution
Eh10:   ret                             ; return

        LEAF_END ExceptionHandler, _TEXT$00

        subttl  "Frame Without Error Code - With Handler"
;++
;
; VOID
; FrameNoCode (
;     VOID
;     );
;
; Routine Description:
;
;   This routine generates a trap frame without an error, but with a handler.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY FrameNoCode, _TEXT$00, ExceptionHandler

        GENERATE_TRAP_FRAME             ; generate trap frame

        RESTORE_TRAP_STATE <Volatile>   ; restore trap state

        NESTED_END FrameNoCode, _TEXT$00

        subttl  "Frame With Code - Without Handler"
;++
;
; VOID
; FrameWithCode (
;     VOID
;     );
;
; Routine Description:
;
;   This routine generates a trap frame with an error code.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY FrameWithCode, _TEXT$00

        GENERATE_TRAP_FRAME code        ; generate trap frame

        RESTORE_TRAP_STATE <Service>    ; restore trap state

        NESTED_END FrameWithCode, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\throw\throw.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    throw.cpp

Abstract:

    This module implements a program which tests C++ EH.

Author:

    David N. Cutler (davec) 25-Jun-2001

Environment:

    User mode.

Revision History:

    None.

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

VOID
func (
    ULONG N
    )

{
    if (N != 0) {
        throw N;
    }

    return;
}

//
// Main program.
//

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )

{
    try {
        func(5);
        printf("resuming, should never happen\n");

    } catch(ULONG) {
        printf("caught ULONG exception\n");

    } catch(CHAR *) {
        printf("caught CHAR * exception\n");

    } catch(...) {
        printf("caught typeless exception\n");
    }

    printf("terminating after try block\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\slist\sl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    slisttest.c

Abstract:

    This module implements a program which tests the interlocked SLIST
    functions exported from kernel32.dll. Since these functions are
    implemented in Win2000 and are just being exposed to windows programs
    this program is not an exhaustive test. Rather it just tests whether
    the interfaces exposed correctly.

Author:

    David N. Cutler (davec) 10-Jan-2000

Environment:

    User mode.

Revision History:

    None.

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

//
// Define structure that will be used in SLIST.
//

typedef struct _PROGRAM_ITEM {

    //
    // Normally a SINGLE_LIST_ENTRY is the first member of the program
    // item structure, but it can be any member as long as the address
    // of the containing structure is computed correctly.
    //

    SINGLE_LIST_ENTRY ItemEntry;

    //
    // Additional members in the structure would be used for data
    // associated with whatever the program item represents. Here
    // the only use is for a signature that will be used for the
    // test.
    //

    ULONG Signature;
} PROGRAM_ITEM, *PPROGRAM_ITEM;

VOID
FrameNoCode (
    VOID
    );

VOID
FrameWithCode (
    VOID
    );

int
Bar (
    PULONG Switch
    )

{
    *Switch /= 3;
    return (*Switch & 1);
}

int
Foo (
    PULONG Switch
    )
{

    *Switch += 1;
    return (*Switch & 1);
}

//
// Main program.
//

int __cdecl
main(
    ULONG *Buffer1,
    ULONG *Buffer2,
    ULONG Length
    )

{

    ULONG Count = 1;
    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY ListEntry;
    SLIST_HEADER ListHead;
    PPROGRAM_ITEM ProgramItem;

    memmove(Buffer1, Buffer2, Length);
    memcpy(Buffer1, Buffer2, Length);
    memset(Buffer1, 0, Length);
    InitializeSListHead(&ListHead);
    Foo(&Count);
    try {
        ProgramItem = (PPROGRAM_ITEM)malloc(sizeof(*ProgramItem));
        ProgramItem->Signature = Count;
        FirstEntry = InterlockedPushEntrySList(&ListHead,
                                               &ProgramItem->ItemEntry);

        if (FirstEntry != NULL) {
            leave;
        }

        try {
            ListEntry = InterlockedPopEntrySList(&ListHead);
            ProgramItem = CONTAINING_RECORD(ListEntry, PROGRAM_ITEM, ItemEntry);
            if (ProgramItem->Signature != Count) {
                leave;
            }

            free((PCHAR)ProgramItem);

        } finally {
            if (AbnormalTermination()) {
                Foo(&Count);
            }
        }

        Bar(&Count);

    } except (Bar(&Count)) {
        Foo(&Count);
    }

    FrameNoCode();
    FrameWithCode();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\bt\tick\tick.c ===
/*

Copyright (c) 2000  Microsoft Corporation

File name:

    sched.c
   
Author:
    
    adrmarin  Fri Jul 19 17:41:07 2002

*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

unsigned int
foo4 (
    IN unsigned int Value,
    IN int Shift
    )

{
    return RotateRight32(RotateLeft32(Value, Shift), Shift);
}

unsigned __int64
foo5 (
    IN unsigned __int64 Value,
    IN int Shift
    )

{
    return RotateRight64(RotateLeft64(Value, Shift), Shift);
}

unsigned int
foo6 (
    IN unsigned int Value,
    IN int Shift
    )

{
    return RotateLeft32(Value, Shift);
}

unsigned __int64
foo7 (
    IN unsigned __int64 Value,
    IN int Shift
    )

{
    return RotateRight64(Value, Shift);
}

ULARGE_INTEGER TickCount;

#if 0

//
// This is an example of the current NtGetTickCount64 algorithm with a
// tick count multiplier of 5,0.
//

FORCEINLINE
ULONGLONG
GetTickCount64 (
    VOID
    )

{

    return ((UInt32x32To64(TickCount.LowPart, 0x5000000) >> 24)
            + UInt32x32To64(TickCount.HighPart << 8, 0x5000000));
}

#else

//
// This is an example of the the correct NtGetTickCount64 algorithm
// with a tick count multiplier of 5,0.
//

FORCEINLINE
ULONGLONG
GetTickCount64 (
    VOID
    )

{

    return ((UInt32x32To64(TickCount.LowPart, 0x5000000) >> 24)
            + (UInt32x32To64(TickCount.HighPart, 0x5000000) << 8));
}

#endif

int
__cdecl
main (
    int argc,
    char ** argv
    )

{

    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;

    SystemTime.LowPart = 0xe2578350;
    SystemTime.HighPart = 0x01c4b107;
    RtlTimeToTimeFields(&SystemTime, &TimeFields);
    printf("year   = %d\nmonth  = %d\nday    = %d\nhour   = %d\nminute = %d\nsecond = %d\n",
           TimeFields.Year,
           TimeFields.Month,
           TimeFields.Day,
           TimeFields.Hour,
           TimeFields.Minute,
           TimeFields.Second);

    SystemTime.LowPart = 0x805e3a5c;
    SystemTime.HighPart = 0x01c25d95;
    RtlTimeToTimeFields(&SystemTime, &TimeFields);
    printf("year   = %d\nmonth  = %d\nday    = %d\nhour   = %d\nminute = %d\nsecond = %d\n",
           TimeFields.Year,
           TimeFields.Month,
           TimeFields.Day,
           TimeFields.Hour,
           TimeFields.Minute,
           TimeFields.Second);


/*
    ULARGE_INTEGER Iteration;
    ULARGE_INTEGER Milliseconds;


    Iteration.QuadPart = 0xffffffffffffffffUI64 / 10000000000;
    Milliseconds.QuadPart = 0;
    TickCount.QuadPart = 0;
    do {
        if (GetTickCount64() != Milliseconds.QuadPart) {
            printf("mismatch at tick count = %08lx%08lx, milliseconds = %08lx%08lx\n",
                   TickCount.HighPart,
                   TickCount.LowPart,
                   Milliseconds.HighPart,
                   Milliseconds.LowPart);
        }

        Iteration.QuadPart -= 1;
        Milliseconds.QuadPart += (5 * 10000000000UI64);
        TickCount.QuadPart += 10000000000;
    } while (Iteration.QuadPart != 0);

*/

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\i386\critsect.asm ===
title   "Critical Section Support"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     critsect.asm
;
;  Abstract:
;
;     This module implements functions to support user mode interlocked operations.
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;  Revision History:
;
;
;   WARNING!!!!!!!!!! Some of this code is duplicated in
;   ntos\dll\i386\critsect.asm
;
;   Some day we should put it in a .inc file that both include.
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_DATA   SEGMENT DWORD PUBLIC 'DATA'
    public _BasepLockPrefixTable
_BasepLockPrefixTable    label dword
        dd offset FLAT:Lock1
        dd offset FLAT:Lock2
        dd offset FLAT:Lock3
        dd offset FLAT:Lock4
        dd offset FLAT:Lock5
        dd 0
_DATA   ENDS


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


Addend      equ     [esp + 4]
FlagMask    equ     0c0000000H
FlagShift   equ     24
FlagSelect  equ     30

        page , 132
        subttl  "InterlockedIncrement"

;++
;
; LONG
; InterlockedIncrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of one to the addend variable.
;
;    No checking is done for overflow.
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       incremented by one.
;
; Return Value:
;
;   (eax) - the incremented value.
;
;--

cPublicProc _InterlockedIncrement,1
cPublicFpo 1,0
        mov     ecx,Addend              ; get pointer to addend variable
        mov     eax,1                   ; set increment value
Lock1:
   lock xadd    [ecx],eax               ; interlocked increment
        inc     eax                     ; adjust return value
        stdRET _InterlockedIncrement    ;

stdENDP _InterlockedIncrement

        page , 132
        subttl  "InterlockedDecrment"
;++
;
; LONG
; InterlockedDecrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of -1 to the addend variable.
;
;    No checking is done for overflow
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       decremented by one.
;
; Return Value:
;
;   (eax) - The decremented value.
;
;--

cPublicProc _InterlockedDecrement,1
cPublicFpo 1,0

        mov     ecx,Addend              ; get pointer to addend variable
        mov     eax,-1                  ; set decrement value
Lock2:
   lock xadd    [ecx],eax               ; interlocked decrement
        dec     eax                     ; adjust return value
        stdRET _InterlockedDecrement    ;

stdENDP _InterlockedDecrement

        page , 132
        subttl  "Interlocked Exchange"
;++
;
; LONG
; InterlockedExchange(
;    IN OUT LPLONG Target,
;    IN LONG Value
;    )
;
; Routine Description:
;
;    This function atomically exchanges the Target and Value, returning
;    the prior contents of Target
;
; Arguments:
;
;    Target - Address of LONG to exchange
;    Value  - New value of LONG
;
; Return Value:
;
;    (eax) - The prior value of target.
;--

cPublicProc _InterlockedExchange, 2
cPublicFpo 2,0

        mov     ecx, [esp+4]                ; (ecx) = Target
        mov     edx, [esp+8]                ; (edx) = Value
        mov     eax, [ecx]                  ; get comperand value
Ixchg:
Lock5:
   lock cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
        stdRET  _InterlockedExchange

stdENDP _InterlockedExchange

        page , 132
        subttl  "Interlocked Compare Exchange"
;++
;
;   PVOID
;   InterlockedCompareExchange (
;       IN OUT PVOID *Destination,
;       IN PVOID Exchange,
;       IN PVOID Comperand
;       )
;
;   Routine Description:
;
;    This function performs an interlocked compare of the destination
;    value with the comperand value. If the destination value is equal
;    to the comperand value, then the exchange value is stored in the
;    destination. Otherwise, no operation is performed.
;
; Arguments:
;
;    Destination - Supplies a pointer to destination value.
;
;    Exchange - Supplies the exchange value.
;
;    Comperand - Supplies the comperand value.
;
; Return Value:
;
;    (eax) - The initial destination value.
;
;--

cPublicProc _InterlockedCompareExchange, 3
cPublicFpo 3,0

        mov     ecx, [esp + 4]          ; get destination address
        mov     edx, [esp + 8]          ; get exchange value
        mov     eax, [esp + 12]         ; get comperand value
Lock3:
   lock cmpxchg [ecx], edx              ; compare and exchange

        stdRET  _InterlockedCompareExchange

stdENDP _InterlockedCompareExchange

        page , 132
        subttl  "Interlocked Exchange Add"
;++
;
;   LONG
;   InterlockedExchangeAdd (
;       IN OUT PLONG Addend,
;       IN LONG Increment
;       )
;
;   Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;    Increment - Supplies the increment value to be added to the
;       addend variable.
;
; Return Value:
;
;    (eax) - The initial value of the addend.
;
;--

cPublicProc _InterlockedExchangeAdd, 2
cPublicFpo 2,0

        mov     ecx, [esp + 4]          ; get addend address
        mov     eax, [esp + 8]          ; get increment value
Lock4:
   lock xadd    [ecx], eax              ; exchange add

        stdRET  _InterlockedExchangeAdd

stdENDP _InterlockedExchangeAdd

        page , 132
        subttl  "Multiply and Divide"
;++
;
; LONG
; MulDiv(
;    IN LONG nNumber,
;    IN LONG nNumerator,
;    IN LONG nDenominator
;    )
;
; Routine Description:
;
;    This function multiples two 32-bit numbers forming a 64-bit product.
;    The 64-bit product is rounded and then divided by a 32-bit divisor
;    yielding a 32-bit result.
;
; Arguments:
;
;    nNumber - Supllies the multiplier.
;
;    nNumerator - Supplies the multiplicand.
;
;    nDenominator - Supplies the divisor.
;
; Return Value:
;
;    If the divisor is zero or an overflow occurs, then a value of -1 is
;    returned as the function value. Otherwise, the rounded quotient is
;    returned as the funtion value.
;
;--

nNumber      equ [esp + 4]
nNumerator   equ [esp + 8]
nDenominator equ DWORD PTR [esp + 12]

cPublicProc _MulDiv, 3
cPublicFpo 3,0
        mov     eax, nNumber            ; get multiplier absolute value
        or      eax, eax                ;
        js      short MD32_First        ; if s, multiplier is negative

;
; The multiplier is positive.
;

        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      MD32_Second             ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      MD32_Third              ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error        ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error        ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error:
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is negative.
;

MD32_First:                             ;
        neg     eax                     ; negate multiplier
        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      short MD32_First10      ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First20      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative and the multiplicand is negative.
;

MD32_First10:                           ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First30      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error10:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv


;
; The multiplier is negative, the multiplicand is positive, and the
; divisor is negative.
;

MD32_First20:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative, the multiplier is negative, and the divisor
; is negative.
;

MD32_First30:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive and the multiplicand is negative.
;

MD32_Second:                            ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_Second10     ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; check for overflow
        jg      short MD32_error20      ; if g, overlfow has occured

        stdRET  _MulDiv

MD32_error20:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is negative, and the divisor
; is negative.
;

MD32_Second10:                          ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is positive, the divisor
; is negative.
;

MD32_Third:                             ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error20      ; if g, overflow has occured

        stdRET  _MulDiv

stdENDP _MulDiv

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\i386\context.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains the context management routines for
    Win32

Author:

    Mark Lucovsky (markl) 28-Sep-1990

Revision History:

--*/

#include "basedll.h"

#ifdef _X86_
extern PVOID BasepLockPrefixTable;
extern PVOID __safe_se_handler_table[]; /* base of safe handler entry table */
extern BYTE  __safe_se_handler_count;   /* absolute symbol whose address is
                                           the count of table entries */

//
// Specify address of kernel32 lock prefixes
//
IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    sizeof(_load_config_used),                              // Reserved
    0,                              // Reserved
    0,                              // Reserved
    0,                              // Reserved
    0,                              // GlobalFlagsClear
    0,                              // GlobalFlagsSet
    0,                              // CriticalSectionTimeout (milliseconds)
    0,                              // DeCommitFreeBlockThreshold
    0,                              // DeCommitTotalFreeThreshold
    (ULONG) &BasepLockPrefixTable,  // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0,            // Reserved
    0,                              // & security_cookie
    (ULONG)__safe_se_handler_table,
    (ULONG)&__safe_se_handler_count
};
#endif

VOID
BaseInitializeContext(
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL,
    IN BASE_CONTEXT_TYPE ContextType
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

    NewThread - Supplies a flag that specifies that this is a new
        thread, or a new process.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{

    ULONG ContextFlags;

    Context->Eax = (ULONG)InitialPc;
    Context->Ebx = (ULONG)Parameter;

    Context->SegGs = 0;
    Context->SegFs = KGDT_R3_TEB;
    Context->SegEs = KGDT_R3_DATA;
    Context->SegDs = KGDT_R3_DATA;
    Context->SegSs = KGDT_R3_DATA;
    Context->SegCs = KGDT_R3_CODE;

    //
    // Save context flags and set context flags to full.
    //

    ContextFlags = Context->ContextFlags;
    Context->ContextFlags = CONTEXT_FULL;

    //
    // Start the thread at IOPL=3.
    //

    Context->EFlags = 0x3000;

    //
    // Always start the thread at the thread start thunk.
    //

    Context->Esp = (ULONG) InitialSp - sizeof(PVOID);
    if ( ContextType == BaseContextTypeThread ) {
        Context->Eip = (ULONG) BaseThreadStartThunk;

    } else if ( ContextType == BaseContextTypeFiber ) {
        Context->Esp -= sizeof(PVOID);
        *(PULONG)Context->Esp = (ULONG) BaseFiberStart;
        Context->ContextFlags |= ContextFlags;

        //
        // If context switching of the floating state is specified, then
        // initialize the floating context.
        //

        if (ContextFlags == CONTEXT_FLOATING_POINT) {
            Context->FloatSave.ControlWord = 0x27f;
            Context->FloatSave.StatusWord = 0;
            Context->FloatSave.TagWord = 0xffff;
            Context->FloatSave.ErrorOffset = 0;
            Context->FloatSave.ErrorSelector = 0;
            Context->FloatSave.DataOffset = 0;
            Context->FloatSave.DataSelector = 0;
            if (USER_SHARED_DATA->ProcessorFeatures[PF_XMMI_INSTRUCTIONS_AVAILABLE] != FALSE) {
                Context->Dr6 = 0x1f80;
            }
        }

    } else {
        Context->Eip = (ULONG) BaseProcessStartThunk;
    }

    return;
}

VOID
BaseFiberStart(
    VOID
    )

/*++

Routine Description:

    This function is called to start a Win32 fiber. Its purpose
    is to call BaseThreadStart, getting the necessary arguments
    from the fiber context record.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFIBER Fiber;

    Fiber = GetCurrentFiber();
    BaseThreadStart( (LPTHREAD_START_ROUTINE)Fiber->FiberContext.Eax,
                     (LPVOID)Fiber->FiberContext.Ebx );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\daytona\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\wow6432\makefile.inc ===
!INCLUDE ..\makefile.inc

$(O)\services.tab: services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\usrstubs.$(ASM_SUFFIX): $(O)\services.tab $(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) $(TARGET_BRACES) -s $(TARGET_DIRECTORY) $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\ia64\thunk.s ===
//++
//
// Module Name:
//
//    thunk.s
//
// Abstract:
//
//   This module implements all Win32 thunks. This includes the
///   first level thread starter...
//
// Author:
//
//   12-Oct-1995
//
// Revision History:
//
//--

#include "ksia64.h"
        .file    "thunk.s"


//++
//
// VOID
// BaseThreadStartThunk(
//    IN PTHREAD_START_ROUTINE StartRoutine,
//    IN PVOID ThreadParameter
//    )
//
// Routine Description:
//
//    This function calls to the portable thread starter after moving
//    its arguments from registers to the argument registers.
//
// Arguments:
//
//    s1 - StartRoutine
//    s2 - ThreadParameter
//
// Return Value:
//
//    Never Returns
//
//--

        PublicFunction(BaseThreadStart)

        LEAF_ENTRY(BaseThreadStartThunk)
        LEAF_SETUP(0,0,2,0)

        mov        out0=s1
        mov        out1=s2
        br.many    BaseThreadStart
        ;;

        //
        // never come back here
        //

        LEAF_EXIT(BaseThreadStartThunk)


//++
//
// VOID
// BaseProcessStartThunk(
//    IN PTHREAD_START_ROUTINE StartRoutine,
//    IN PVOID ThreadParameter
//    )
//
// Routine Description:
//
//    This function calls to the portable thread starter after moving
//    its arguments from registers to the argument registers.
//
// Arguments:
//
//    s1 - StartRoutine
//    s2 - ThreadParameter
//
// Return Value:
//
//    Never Returns
//
//--

        PublicFunction(BaseProcessStart)

        LEAF_ENTRY(BaseProcessStartThunk)

        alloc   t22 = ar.pfs, 0, 0, 1, 0

        mov     out0=s1
        br      BaseProcessStart                          // jump process wrapper.
        ;;

        LEAF_EXIT(BaseProcessStartThunk)



//++
//
// VOID
// SwitchToFiber(
//    PFIBER NewFiber
//    )
//
// Routine Description:
//
//    This function saves the state of the current fiber and switches
//    to the new fiber.
//
// Arguments:
//
//    NewFiber (a0) - Supplies the address of the new fiber.
//
// Return Value:
//
//    None
//
//--

        LEAF_ENTRY(SwitchToFiber)


        // local register aliases

        rOldFb = t21
        rOldCx = t20
        rNewFb = t19
        rNewCx = t18
        rA0    = t17

        dest1  = t10
        dest2  = t11
        dest4  = t12
        dest5  = t13

        //
        // set up pointers to old and new fiber and context records
        //

        add          rNewFb = zero, a0
        add          rNewCx = FbFiberContext, a0
        add          t0 = TeFiberData, teb
        ;;

        ld8          t1 = [t0]
        mov          rA0 = a0
        ;;

        add          rOldFb = 0, t1
        add          rOldCx = FbFiberContext, t1
        ;;

        //
        // step 1
        // save current state in to old fiber's fiber and context rec
        //

        //
        // save fiber exception list and stack info
        //

        flushrs
        add          dest1 = TeExceptionList, teb      // TEB
        add          dest2 = FbExceptionList, rOldFb    // Old fiber

        //
        // also save RSE stack info
        //

        add          dest4 = TeBStoreLimit, teb
        add          dest5 = FbBStoreLimit, rOldFb
        ;;

        ld8          t0 = [dest1], TeStackLimit - TeExceptionList
        ld8          t1 = [dest4], TeFlsData - TeBStoreLimit
        ;;
        st8          [dest2] = t0, FbStackLimit - FbExceptionList
        st8          [dest5] = t1, FbFlsData - FbBStoreLimit
        ;;

        ld8          t0 = [dest1]
        ld8          t1 = [dest4]        
        ;;
        st8          [dest2] = t0
        st8          [dest5] = t1        

        //
        // spill low non-volatile fp registers 0-3, 5-19
        //

        add          dest1 = CxFltS0, rOldCx
        add          dest2 = CxFltS1, rOldCx
        ;;

        mov          t2 = ar.fpsr                         //FPSR
        mov          t3 = ar28                            //FSR
        mov          t4 = ar29                            //FIR
        mov          t5 = ar30                            //FDR

        stf.spill    [dest1] = fs0, CxFltS2 - CxFltS0
        stf.spill    [dest2] = fs1, CxFltS3 - CxFltS1
        ;;

        stf.spill    [dest1] = fs2, CxFltS4 - CxFltS2
        stf.spill    [dest2] = fs3, CxFltS5 - CxFltS3
        ;;

        stf.spill    [dest1] = fs4, CxFltS6 - CxFltS4
        stf.spill    [dest2] = fs5, CxFltS7 - CxFltS5
        ;;

        stf.spill    [dest1] = fs6, CxFltS8 - CxFltS6
        stf.spill    [dest2] = fs7, CxFltS9 - CxFltS7
        ;;

        stf.spill    [dest1] = fs8, CxFltS10 - CxFltS8
        stf.spill    [dest2] = fs9, CxFltS11 - CxFltS9
        ;;

        stf.spill    [dest1] = fs10, CxFltS12 - CxFltS10
        stf.spill    [dest2] = fs11, CxFltS13 - CxFltS11
        ;;

        stf.spill    [dest1] = fs12, CxFltS14 - CxFltS12
        stf.spill    [dest2] = fs13, CxFltS15 - CxFltS13
        ;;

        stf.spill    [dest1] = fs14, CxFltS16 - CxFltS14
        stf.spill    [dest2] = fs15, CxFltS17 - CxFltS15
        ;;

        stf.spill    [dest1] = fs16, CxFltS18 - CxFltS16
        stf.spill    [dest2] = fs17, CxFltS19 - CxFltS17
        ;;

        stf.spill    [dest1] = fs18
        stf.spill    [dest2] = fs19

        //
        // fp status registers
        //

        add          dest1 = CxStFPSR,  rOldCx
        add          dest2 = CxStFSR,  rOldCx
        ;;

        st8          [dest1] = t2
        ;;

        st8          [dest2] = t3, CxStFDR - CxStFSR
        add          dest1 = CxStFIR, rOldCx
        ;;

        st8          [dest1] = t4
        ;;

        st8          [dest2] = t5

        //
        // save old unat before starting the spills
        //

        mov          t6 = ar.unat
        add          dest4 = CxApUNAT, rOldCx
        ;;

        st8          [dest4] = t6
        mov          ar.unat = zero
        ;;

        // ordering ? should not start spilling before unat is saved

        // save sp and preserved int registers

        add          dest4 = CxIntS0, rOldCx
        add          dest5 = CxIntSp, rOldCx
        ;;

        .mem.offset 0,0
        st8.spill    [dest5] = sp, CxIntS1 - CxIntSp
        .mem.offset 8,0
        st8.spill    [dest4] = s0, CxIntS2 - CxIntS0
        ;;

        .mem.offset 0,0
        st8.spill    [dest5] = s1, CxIntS3 - CxIntS1
        .mem.offset 8,0
        st8.spill    [dest4] = s2
        ;;

        st8.spill    [dest5] = s3

        // save predicates

        add          dest4 = CxPreds, rOldCx
        add          dest5 = CxBrRp, rOldCx

        mov          t7 = pr
        ;;
        st8          [dest4] = t7, CxBrS0 - CxPreds

        // save preserved branch registers

        mov          t8 = brp
        ;;

        st8          [dest5] = t8, CxBrS1 - CxBrRp
        mov          t9 = bs0

        ;;
        st8          [dest4] = t9, CxBrS2 - CxBrS0

        mov          t1 = bs1
        ;;
        st8          [dest5] = t1, CxBrS3 - CxBrS1

        mov          t2 = bs2
        ;;
        st8          [dest4] = t2, CxBrS4 - CxBrS2

        mov          t3 = bs3
        ;;
        st8          [dest5] = t3

        mov          t4 = bs4
        ;;
        st8          [dest4] = t4

        // save other applicatin registers
        //

        mov          t6 = ar.lc
        add          dest4 = CxApLC, rOldCx
        add          dest5 = CxApEC, rOldCx
        ;;

        st8          [dest4] = t6, CxRsPFS - CxApLC
        mov          t7 = ar.ec
        ;;

        st8          [dest5] = t7, CxRsRSC - CxApEC

        //
        // save RSE stuff
        //
        mov        t8 = ar.pfs
        ;;

        st8        [dest4] = t8
        mov        t9 = ar.rsc
        ;;

        st8        [dest5] = t9
        dep        t9 = 0, t9, RSC_MODE, 2                  // put in lazy mode
        ;;
        mov        ar.rsc = t9

        //
        // since we do not use locals, we don't need cover..
        // cover
        // ;;

        ;;
        dep        t9 = 0, t9, RSC_LOADRS, RSC_LOADRS_LEN  // invalidate all
        ;;
        mov        ar.rsc = t9
        ;;
        loadrs

        add        dest1 = CxRsRNAT, rOldCx
        add        dest2 = CxRsBSP, rOldCx
        ;;

        mov        t1 = ar.bsp
        ;;
        st8        [dest2] = t1

        mov        t2 = ar.rnat
        ;;
        st8        [dest1] = t2


        // save all spilled NaT bits in in IntNats

        add        dest1 = CxIntNats, rOldCx
        mov        t3 = ar.unat
        ;;
        st8        [dest1] = t3


        //
        // step 2
        // setup the state for new fiber from new context/fiber record
        //

        // restore exception list and stack info fist
        //
        add          dest1 = TeExceptionList, teb
        add          dest2 = FbExceptionList, rNewFb
        add          dest4 = TeBStoreLimit, teb
        add          dest5 = FbBStoreLimit, rNewFb
        ;;

        ld8          t0 = [dest2], FbStackBase - FbExceptionList
        ld8          t2 = [dest5], FbDeallocationBStore - FbBStoreLimit
        ;;
        st8          [dest1] = t0, TeStackBase - TeExceptionList
        st8          [dest4] = t2, TeDeallocationBStore - TeBStoreLimit
        ;;

        ld8          t0 = [dest2], FbStackLimit - FbStackBase
        ld8          t2 = [dest5], FbFlsData - FbDeallocationBStore
        ;;
        st8          [dest1] = t0, TeStackLimit - TeStackBase
        st8          [dest4] = t2, TeFlsData - TeDeallocationBStore
        ;;

        ld8          t0 = [dest2]
        ld8          t1 = [dest5]

        ;;
        st8          [dest1] = t0
        st8          [dest4] = t1
        add          dest5 = FbDeallocationStack, rNewFb
        add          dest4 = TeDeallocationStack, teb
        add          dest1 = TeFiberData, teb

        ;;

        ld8          t3 = [dest5]

        //
        // set the fiber pointer in teb to point to new fiber
        //

        st8          [dest1] = rA0
        add          dest2 = CxRsBSP, rNewCx
        ;;


        st8          [dest4] = t3
        ld8          t2 = [dest2], CxRsRNAT - CxRsBSP
        add          dest1 = CxRsRSC, rNewCx
        ;;

        ;;
        mov          ar.bspstore = t2
        invala

        ld8          t3 = [dest2]
        ;;
        mov          ar.rnat = t3

        ld8          t4 = [dest1]
        ;;
        mov          ar.rsc = t4

        add          dest4 = CxRsPFS, rNewCx
        ;;
        ld8          t5 = [dest4]
        ;;
        mov          ar.pfs = t5


        // restore floating point registers

        add          dest1 = CxFltS0, rNewCx
        add          dest2 = CxFltS1, rNewCx
        ;;

        ldf.fill     fs0 = [dest1], CxFltS2 - CxFltS0
        ldf.fill     fs1 = [dest2] , CxFltS3 - CxFltS1
        ;;

        ldf.fill     fs2 = [dest1], CxFltS4 - CxFltS2
        ldf.fill     fs3 = [dest2], CxFltS5 - CxFltS3
        ;;

        ldf.fill     fs4 = [dest1], CxFltS6 - CxFltS4
        ldf.fill     fs5 = [dest2], CxFltS7 - CxFltS5
        ;;

        ldf.fill     fs6 = [dest1], CxFltS8 - CxFltS6
        ldf.fill     fs7 = [dest2], CxFltS9 - CxFltS7
        ;;

        ldf.fill     fs8 = [dest1], CxFltS10 - CxFltS8
        ldf.fill     fs9 = [dest2], CxFltS11 - CxFltS9
        ;;

        ldf.fill     fs10 = [dest1], CxFltS12 - CxFltS10
        ldf.fill     fs11 = [dest2], CxFltS13 - CxFltS11
        ;;

        ldf.fill     fs12 = [dest1], CxFltS14 - CxFltS12
        ldf.fill     fs13 = [dest2], CxFltS15 - CxFltS13
        ;;

        ldf.fill     fs14 = [dest1], CxFltS16 - CxFltS14
        ldf.fill     fs15 = [dest2], CxFltS17 - CxFltS15
        ;;

        ldf.fill     fs16 = [dest1], CxFltS18 - CxFltS16
        ldf.fill     fs17 = [dest2], CxFltS19 - CxFltS17
        ;;

        ldf.fill     fs18 = [dest1]
        ldf.fill     fs19 = [dest2]

        add          dest1 = CxStFPSR, rNewCx
        add          dest2 = CxStFSR, rNewCx
        ;;

        ld8          t2 = [dest1]                         //FPSR
        ;;
        mov          ar.fpsr = t2

        ld8          t3 = [dest2], CxStFDR - CxStFSR
        add          dest1 = CxStFIR, rNewCx
        ;;
        mov          ar28 = t3                            //FSR

        ld8          t4 = [dest1]
        ;;
        mov          ar29 = t4                            //FIR

        ld8          t5 = [dest2]
        ;;
        mov          ar30 = t5                            //FDR

        //
        // restore ar.unat first, so that fills will restore the
        // nat bits correctly
        //
        add          dest4 = CxIntNats, rNewCx
        ;;
        ld8          t6 = [dest4]
        ;;
        mov          ar.unat = t6

        // now start filling the preserved integer registers
        //
        add          dest4 = CxIntS0, rNewCx
        add          dest5 = CxIntSp, rNewCx
        ;;


        ld8.fill     sp = [dest5], CxIntS1 - CxIntSp

        // save preserved integer registers

        ld8.fill     s0 = [dest4], CxIntS2 - CxIntS0
        ;;
        ld8.fill     s1 = [dest5], CxIntS3 - CxIntS1

        ld8.fill     s2 = [dest4]
        ;;
        ld8.fill     s3 = [dest5]

        // restore predicates and branch registers

        add          dest4 = CxPreds, rNewCx
        add          dest5 = CxBrRp, rNewCx
        ;;

        ld8          t7 = [dest4], CxBrS0 - CxPreds
        ;;
        mov          pr = t7

        ld8          t8 = [dest5], CxBrS1 - CxBrRp
        ;;
        mov          brp = t8

        ld8          t9 = [dest4], CxBrS2 - CxBrS0
        ;;
        mov          bs0 = t9

        ld8          t1 = [dest5], CxBrS3 - CxBrS1
        ;;
        mov          bs1 = t1

        ld8          t2 = [dest4], CxBrS4 - CxBrS2
        ;;
        mov          bs2 = t2

        ld8          t3 = [dest5]
        ;;
        mov          bs3 = t3

        ld8          t4 = [dest4]
        ;;
        mov          bs4 = t4


        // restore other applicatin registers
        //
        add          dest4 = CxApLC, rNewCx
        add          dest5 = CxApEC, rNewCx
        ;;

        ld8          t6 = [dest4]
        ;;
        mov          ar.lc = t6

        ld8          t7 = [dest5]
        ;;
        mov          ar.ec = t7


        // finally restore the unat register
        //
        add          dest4 = CxApUNAT, rNewCx
        ;;
        ld8          t5 = [dest4]
        ;;
        mov          ar.unat = t5

        br.ret.sptk brp

        //
        // this will execute BaseFiberStart if we are switching to
        // the new fiber for the first time. otherwise, it will
        // return back to new fiber.
        //

        LEAF_EXIT(SwitchToFiber)


#if 0
        LEAF_ENTRY(GenericIACall)
        LEAF_SETUP(1,95,0,0)

//
// Load iA state for iVE. Since working with flat 32 in NT,
// much of the state is a constant (per Freds document)
//
        mov rBase   = teb               // Get TEB pointer

// load up selector register constants, we dont care about GS
        mov rES = _DataSelector
        mov rSS = _DataSelector
        mov rDS = _DataSelector
        mov rGS = _DataSelector
        mov rCS = _CodeSelector
        mov rFS = _FsSelector
        mov rLDT    = _LdtSelector
//
//  Setup pointer to iA32 Resources relative to TEB
//
        mov r23 = rIA32Rsrc
        add rIA32Ptr = rBase, r23

        ld8    rGDTD   = [rIA32Ptr], 8      //  load LDT Descriptor registers
        ld8    rLDTD   = [rIA32Ptr], 8      //  GDT Descriptor is 8 bytes after
        ld8    rFSD    = [rIA32Ptr]         //  FSDescriptor is 8 bytes after
//
//  Eflag should not be touched by stub routines...
//

//
// Since CSD and SSD are in AR registers and since they are saved
// on context switches, dont need to reload them...
//
//
//  DSD and ESD are the same as SSD, and we dont care about GSD
//
        mov rESD    =   rSSD
        mov rDSD    =   rSSD
        mov rGSD    =   rSSD

//
// push the return address on the memory stack
//
//
// As we never return, just push NULL...
//
//
// Stack always points to a valid value, so decrement before putting on
// return address
//
        adds    sp = -4, sp
        st4     [sp] = r0

        ARGPTR (in0)
        sxt4   r23 = in0
        mov b7 = r23

        br.ia.sptk   b7

//
// Return addresses and stuff would go here, but we never return
//

        LEAF_EXIT(GenericIACall)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\ia64\context.c ===
/*++

Module Name:

    context.c

Abstract:

    This module contains the context management routines for
    Win32

Author:


Revision History:

--*/

#include "basedll.h"

#include "kxia64.h"

VOID
BaseInitializeContext(
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL,
    IN BASE_CONTEXT_TYPE ContextType
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

    NewThread - Supplies a flag that specifies that this is a new
        thread, or a new process.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{
    ULONG ArgumentsCount;
    //
    // Initialize the Context 
    //
    RtlZeroMemory((PVOID)Context, sizeof(CONTEXT));

    Context->StFPSR = USER_FPSR_INITIAL;
    Context->StIPSR = USER_PSR_INITIAL;
    Context->RsBSP = Context->IntSp = (ULONG_PTR)InitialSp;
    Context->IntSp -= STACK_SCRATCH_AREA; // scratch area as per convention
    Context->IntS1 = (ULONG_PTR)InitialPc;
    Context->IntS2 = (ULONG_PTR)Parameter;

    //
    // Enable RSE engine
    //

    Context->RsRSC = (RSC_MODE_EA<<RSC_MODE)
                   | (RSC_BE_LITTLE<<RSC_BE)
                   | (0x3<<RSC_PL);

    if ( ContextType == BaseContextTypeThread ) {
        Context->IntS0 = Context->StIIP = (ULONG_PTR)BaseThreadStartThunk;
        }
    else if ( ContextType == BaseContextTypeFiber ) {
        Context->IntS0 = Context->StIIP = (ULONG_PTR)BaseFiberStart;
        //
        // set up the return pointer here..
        // when SwitchToFiber restores context and calls return, 
        // the contorl goes to this routine
        //
        Context->BrRp = *((ULONGLONG *)((PUCHAR)BaseFiberStart));

        //
        // set up sof = 96 in pfs. This will be used to set up CFM for above
        // routine
        //  
        Context->RsPFS = 0x60;

        }
    else {
        Context->IntS0 = Context->StIIP = (ULONG_PTR)(LONG_PTR)BaseProcessStartThunk;
        }

    Context->RsPFS |= MASK_IA64(PFS_PPL, 3i64);
    Context->ContextFlags = CONTEXT_CONTROL| CONTEXT_INTEGER;

    Context->Eflag = 0x3000i64;
}

VOID
BaseFiberStart(
    VOID
    )

/*++

Routine Description:

    This function is called to start a Win32 fiber. Its purpose
    is to call BaseThreadStart, getting the necessary arguments
    from the fiber context record.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PFIBER Fiber;

    Fiber = GetCurrentFiber();
    BaseThreadStart( (LPTHREAD_START_ROUTINE)Fiber->FiberContext.IntS1,
                     (LPVOID)Fiber->FiberContext.IntS2 );
}


VOID
BaseProcessStartupIA64(
   IN PTHREAD_START_ROUTINE StartRoutine,
   IN PVOID ThreadParameter
   )

/*++

Routine Description:

   This function calls to the portable thread starter after moving
   its arguments from registers to the argument registers.

Arguments:

   StartRoutine - User Target start program counter
   ThreadParameter 

Return Value:

   Never Returns

--*/
{
   (StartRoutine)(ThreadParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\i386\thunk.asm ===
title  "Thunks"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    thunk.asm
;
; Abstract:
;
;   This module implements all Win32 thunks. This includes the
;   first level thread starter...
;
; Author:
;
;   Mark Lucovsky (markl) 28-Sep-1990
;
; Revision History:
;
;--
.586p
        .xlist
include ks386.inc
include callconv.inc
        .list
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

_BasepTickCountMultiplier    dd  0d1b71759H

_DATA ENDS


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "BaseThreadStartThunk"
;++
;
; VOID
; BaseThreadStartThunk(
;    IN PTHREAD_START_ROUTINE StartRoutine,
;    IN PVOID ThreadParameter
;    )
;
; Routine Description:
;
;    This function calls to the portable thread starter after moving
;    its arguments from registers to the stack.
;
; Arguments:
;
;    EAX - StartRoutine
;    EBX - ThreadParameter
;
; Return Value:
;
;    Never Returns
;
;--

        EXTRNP  _BaseThreadStart,2
cPublicProc _BaseThreadStartThunk,2

        xor     ebp,ebp
        push    ebx
        push    eax
        push    0
        jmp     _BaseThreadStart@8

stdENDP _BaseThreadStartThunk

;++
;
; VOID
; BaseProcessStartThunk(
;     IN LPVOID lpProcessStartAddress,
;     IN LPVOID lpParameter
;     );
;
; Routine Description:
;
;    This function calls the process starter after moving
;    its arguments from registers to the stack.
;
; Arguments:
;
;    EAX - StartRoutine
;    EBX - ProcessParameter
;
; Return Value:
;
;    Never Returns
;
;--

        EXTRNP  _BaseProcessStart,1
cPublicProc _BaseProcessStartThunk,2

        xor     ebp,ebp
        push    eax
        push    0
        jmp     _BaseProcessStart@4

stdENDP _BaseProcessStartThunk

;++
;
; VOID
; SwitchToFiber(
;    PFIBER NewFiber
;    )
;
; Routine Description:
;
;    This function saves the state of the current fiber and switches
;    to the new fiber.
;
; Arguments:
;
;    NewFiber (TOS+4) - Supplies the address of the new fiber.
;
; Return Value:
;
;    None
;
;--

LDMXCSR macro
        db      0Fh, 0AEh, 051h, 028h  ; ldmxcsr FbFiberContext+CsDr6[eax]
        endm

STMXCSR macro
        db      0Fh, 0AEh, 058h, 028h  ; stmxcsr FbFiberContext+CsDr6[eax]
        endm

FLOAT_SAVE equ FbFiberContext + CsFloatSave

SAVE_FLOATING equ CONTEXT_FULL or CONTEXT_FLOATING_POINT

XMMI_AVAILABLE equ UsProcessorFeatures + PF_XMMI_INSTRUCTIONS_AVAILABLE

cPublicProc _SwitchToFiber,1

;
; Save current fiber context.
;

        mov     edx, fs:[PcTeb]         ; get TEB address
        mov     eax, [edx]+TeFiberData  ; get current fiber address

;
; Save nonvolatile integer registers.
;

        mov     [eax]+FbFiberContext+CsEbx, ebx ;
        mov     [eax]+FbFiberContext+CsEdi, edi ;
        mov     [eax]+FbFiberContext+CsEsi, esi ;
        mov     [eax]+FbFiberContext+CsEbp, ebp ;

;
; Save floating state if specified.
;

        cmp     dword ptr [eax]+FbFiberContext+CsContextFlags, SAVE_FLOATING ; check for save
        jne     short STF10             ; if ne, no floating environment switched
        fstsw   [eax]+FLOAT_SAVE+FpStatusWord ; save status word
        fnstcw  [eax]+FLOAT_SAVE+FpControlWord ; save control word
        cmp     byte ptr ds:[MM_SHARED_USER_DATA_VA+XMMI_AVAILABLE], 1 ; check for XMMI support
        jne     short STF10             ; if ne, XMMI not supported

        STMXCSR                         ; stmxcsr [eax]+FbFiberContext+CsDr6  

;
; Save stack pointer and fiber local storage data structure address.
;

STF10:  mov     [eax]+FbFiberContext+CsEsp, esp ; save stack pointer
        mov     ecx, [edx]+TeFlsData    ;
        mov     [eax]+FbFlsData, ecx    ; 

;
; Save exception list and stack limit.
;

        mov     ecx, [edx]+TeExceptionList ;
        mov     ebx, [edx]+TeStackLimit ;
        mov     [eax]+FbExceptionList, ecx ;
        mov     [eax]+FbStackLimit, ebx ;

;
; Restore new fiber context.
;

        mov     ecx, [esp]+4            ; get new fiber address
        mov     [edx]+TeFiberData, ecx  ; set fiber address

;
; Restore exception list, stack base, stack limit, and deallocation stack.
;

        mov     esi, [ecx]+FbExceptionList ;
        mov     ebx, [ecx]+FbStackBase  ;
        mov     [edx]+TeExceptionList, esi ;
        mov     [edx]+TeStackBase, ebx  ;

        mov     esi, [ecx]+FbStackLimit ;
        mov     ebx, [ecx]+FbDeallocationStack ;
        mov     [edx]+TeStackLimit, esi ;
        mov     [edx]+TeDeallocationStack, ebx ;

;
; Restore floating state if specified.
;

        cmp     dword ptr [ecx]+FbFiberContext+CsContextFlags, SAVE_FLOATING ; check for save
        jne     short STF40             ; if ne, no floating environment switched

;
; If the old floating control and status words are equal to the new control
; and status words, then there is no need to load any legacy floating state.
;

        mov     ebx, [eax]+FLOAT_SAVE+FpStatusWord ; get previous status word
        cmp     bx, [ecx]+FLOAT_SAVE+FpStatusWord ; check if status words equal
        jne     short STF20             ; if ne, status words not equal
        mov     ebx, [eax]+FLOAT_SAVE+FpControlWord ; get previous control word
        cmp     bx, [ecx]+FLOAT_SAVE+FpControlWord ; check if control words equal
        je      short STF30             ; if e, control words equal
STF20:  mov     word ptr [ecx]+FLOAT_SAVE+FpTagWord, 0ffffh ; set tag word
        fldenv  [ecx]+FLOAT_SAVE        ; restore floating environment
STF30:  cmp     byte ptr ds:[MM_SHARED_USER_DATA_VA+XMMI_AVAILABLE], 1 ; check for XMMI support
        jne     short STF40             ; if ne, XMMI not supported

        LDMXCSR                         ; ldmxcsr [eax]+FbFiberContext+CsDr6

;
; Restore nonvolitile integer registers.
;

STF40:  mov     edi, [ecx]+FbFiberContext+CsEdi ;
        mov     esi, [ecx]+FbFiberContext+CsEsi ;
        mov     ebp, [ecx]+FbFiberContext+CsEbp ;
        mov     ebx, [ecx]+FbFiberContext+CsEbx ;

;
; Restore stack address and fiber local storage data structure address.
;

        mov     eax, [ecx]+FbFlsData    ;
        mov     [edx]+TeFlsData, eax    ;
        mov     esp, [ecx]+FbFiberContext+CsEsp ;
        stdRET  _SwitchToFiber

stdENDP _SwitchToFiber

;++
;
; VOID
; LdrpCallInitRoutine(
;    IN PDLL_INIT_ROUTINE InitRoutine,
;    IN PVOID DllHandle,
;    IN ULONG Reason,
;    IN PCONTEXT Context OPTIONAL
;    )
;
; Routine Description:
;
;    This function calls an x86 DLL init routine.  It is robust
;    against DLLs that don't preserve EBX or fail to clean up
;    enough stack.
;
;    The only register that the DLL init routine cannot trash is ESI.
;
; Arguments:
;
;    InitRoutine - Address of init routine to call
;
;    DllHandle - Handle of DLL to call
;
;    Reason - one of the DLL_PROCESS_... or DLL_THREAD... values
;
;    Context - context pointer or NULL
;
; Return Value:
;
;    FALSE if the init routine fails, TRUE for success.
;
;--

cPublicProc __ResourceCallEnumLangRoutine , 6

EnumRoutine     equ [ebp + 8]
ModuleHandle    equ [ebp + 12]
LpType          equ [ebp + 16]
LpName          equ [ebp + 20]
WLanguage       equ [ebp + 24]
LParam          equ [ebp + 28]

stdENDP __ResourceCallEnumLangRoutine
        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    LParam
        push    WLanguage
	push    LpName
	push    LpType
	push    ModuleHandle
        call    EnumRoutine
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  __ResourceCallEnumLangRoutine

cPublicProc __ResourceCallEnumNameRoutine , 5

EnumRoutine     equ [ebp + 8]
ModuleHandle    equ [ebp + 12]
LpType          equ [ebp + 16]
LpName          equ [ebp + 20]
LParam          equ [ebp + 24]

stdENDP __ResourceCallEnumNameRoutine
        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    LParam
	push    LpName
	push    LpType
	push    ModuleHandle
        call    EnumRoutine
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  __ResourceCallEnumNameRoutine
	
cPublicProc __ResourceCallEnumTypeRoutine , 4

EnumRoutine     equ [ebp + 8]
ModuleHandle    equ [ebp + 12]
LpType          equ [ebp + 16]
LParam          equ [ebp + 20]

stdENDP __ResourceCallEnumTypeRoutine
        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    LParam
	push    LpType
	push    ModuleHandle
        call    EnumRoutine
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  __ResourceCallEnumTypeRoutine

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\fusion_all.inc ===
FUSION_LIB_DEST = $(FUSION_ALL_LIB_DEST)
C_DEFINES = $(C_DEFINES) -DFUSION_ALL -DFUSION_ENABLE_UNWRAPPED_NEW=1 -DFUSION_ENABLE_UNWRAPPED_DELETE=1
FUSION_INC_PATH=$(FUSION_ALL_INC_PATH)
FUSION_BUILD_TYPE_PREFIX=
FUSION_DIRECTDB_INC_DEST=$(FUSION_ALL_DIRECTDB_INC_DEST)
USE_RTTI=1
FUSION_LIB_PATH = $(FUSION_ALL_LIB_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\fusion.inc ===
MSC_WARNING_LEVEL = /W4 /WX
!undef USE_MSVCRT
!undef USE_NTDLL
!undef USE_LIBCMT
!undef NO_NTDLL
USE_NOLIBS=1
USE_NATIVE_EH=1

!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES)
!else
C_DEFINES = $(C_DEFINES) -DDEBUG
!endif

C_DEFINES = $(C_DEFINES) -DFUSION_REDEFINE_ASSERT=1

# Put this in independent of USE_MSVCRT, etc. to make it
# easier to switch among them.
C_DEFINES = $(C_DEFINES) -D_MT=1

#
# Set private include paths
#

INCLUDES        = \
    $(WINDOWS_INC_PATH);\
    $(BASE_INC_PATH);\
    $(SDK_INC_PATH);\
    $(NET_INC_PATH);\
    $(INCLUDES)

FUSION_PATH = $(BASEDIR)\base\win32\fusion

PROJECT_COMPILER_WARNINGS = -FI$(FUSION_PATH)\fusionwarnings.h

FUSION_ALL_INC_PATH = $(FUSION_PATH)\inc
FUSION_WIN_INC_PATH = $(FUSION_PATH)\inc\win
FUSION_WIN2000_INC_PATH = $(FUSION_PATH)\inc\win2000

!if "$(FUSION_BUILD_TYPE)" == ""
!error FUSION_BUILD_TYPE not defined
!endif

FUSION_WIN_LIB_DEST = $(FUSION_PATH)\winobj\$(_OBJ_DIR)
FUSION_WIN_LIB_PATH = $(FUSION_WIN_LIB_DEST)\*
FUSION_WIN2000_LIB_DEST = $(FUSION_PATH)\w2kobj\$(_OBJ_DIR)
FUSION_WIN2000_LIB_PATH = $(FUSION_WIN2000_LIB_DEST)\*
FUSION_ALL_LIB_DEST = $(FUSION_PATH)\$(_OBJ_DIR)
FUSION_ALL_LIB_PATH = $(FUSION_ALL_LIB_DEST)\*

!include fusion_$(FUSION_BUILD_TYPE).inc

!ifdef USE_PERFTAGS
C_DEFINES = $(C_DEFINES) -DPERFTAGS
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\fusionwarnings.h ===
// C4100: 'identifier' : unreferenced formal parameter
#pragma warning(disable: 4100)

// C4201: nonstandard extension used: nameless struct/union
#pragma warning(disable: 4201)

// C4706: assignment within conditional expression
#pragma warning(disable: 4706)

// C4211: nonstandard extension used: redefined extern to static
#pragma warning(disable: 4211)

// C4702: unreachable code
// This one is useful/interesting but having it enabled breaks do { foo(); bar(); goto Exit; } while (0) macros.
#pragma warning(disable: 4702)

// C4505: unreferenced local function has been removed
#pragma warning(disable: 4505)

// C4663: C++ language change: to explicitly specialize class template 'foo' use the following syntax:
#pragma warning(disable: 4663)

// C4127: conditional expression is constant
// makes ASSERT() macros useless.
#pragma warning(disable: 4127)

// C4189: local variable is initialized but not referenced
// makes macros that define things like __pteb = NtCurrentTeb() generate warnings/errors
#pragma warning(disable: 4189)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\fusion_win.inc ===
FUSION_LIB_DEST = $(FUSION_WIN_LIB_DEST)
C_DEFINES = $(C_DEFINES) -DFUSION_WIN=1
C_DEFINES = $(C_DEFINES) -DFUSION_NO_WRAPPERS=1 -DFUSION_ENABLE_UNWRAPPED_NEW=1 -DFUSION_ENABLE_UNWRAPPED_DELETE=1
FUSION_BUILD_TYPE_PREFIX=win
FUSION_INC_PATH=$(FUSION_ALL_INC_PATH);$(FUSION_WIN_INC_PATH)
!undef USE_RTTI
FUSION_LIB_PATH = $(FUSION_WIN_LIB_PATH)
!if !defined(FUSION_BUILD_LEAF_DIRECTORY)
FUSION_BUILD_LEAF_DIRECTORY=whistler
!endif
FUSION_SLIST_LIB=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\buffer\ntrtlbuffer2p.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntrtlbuffer2p.h

Abstract:

Author:

    Jay Krell (JayKrell) January 2002

Environment:

Revision History:

--*/

#define RtlpGetAllocatedBufferSize2(b) \
    (RtlpAssertBuffer2Consistency((b)), 
    ((PPRIVATE_RTL_BUFFER2)(b))->AllocatedSize)

#define RtlpGetRequestedBufferSize2(b) \
    (RtlpAssertBuffer2Consistency((b)), 
    ((PPRIVATE_RTL_BUFFER2)(b))->RequestedSize)

#define RtlpGetBuffer2(b) \
    (RtlpAssertBuffer2Consistency((b)), 
    ((PPRIVATE_RTL_BUFFER2)(b))->Buffer)

typedef struct _PRIVATE_RTL_BUFFER2 {
    PVOID           Buffer;
    PVOID           StaticBuffer;
    SIZE_T          AllocatedSize;
    SIZE_T          RequestedSize;
    SIZE_T          StaticBufferSize;
    struct _RTL_BUFFER2_CLASS * Class;
} PRIVATE_RTL_BUFFER2, *PPRIVATE_RTL_BUFFER2;

#if DBG
VOID
FASTCALL
RtlpAssertBuffer2Consistency(
    PPRIVATE_RTL_BUFFER2 Buffer
    );
#else
#define RtlpAssertBuffer2Consistency(x) /* nothing */
#endif

#define NT_STYLE 1

#if NT_STYLE

typedef NTSTATUS RETURN_TYPE;
#define Ret Status
#define ORIGINATE_INVALID_PARAMETER() do { Status = STATUS_INVALID_PARAMETER; goto Exit; } while(0)
#define FN_PROLOG() NTSTATUS Status
#define FN_EPILOG() Status = STATUS_SUCCESS; goto Exit; Exit: return Status
#define MY_FAILED(x) (!NT_SUCCESS(x))
#define MY_SUCCESS(x) (NT_SUCCESS(x))

#elif WIN32_STYLE

typedef BOOL RETURN_TYPE;
#define Ret Success
void SetLastError_ERROR_INVALID_PARAMETER() { SetLastError(ERROR_INVALID_PARAMETER); }
#define ORIGINATE_INVALID_PARAMETER() do { SetLastError_ERROR_INVALID_PARAMETER(); goto Exit; } while(0)
#define FN_PROLOG() BOOL Success = FALSE
#define FN_EPILOG() Succes = TRUE; goto Exit; Exit: return Success
#define MY_FAILED(x)  (!(x))
#define MY_SUCCESS(x) (x)

#endif

#define CHECK_PARAMETER(expr) do { if (!(expr)) { ORIGINATE_INVALID_PARAMETER(); } while(0)

PVOID
FASTCALL
RtlpFindNonNullInPointerArray(
    PVOID * PointerArray,
    SIZE_T  SizeOfArray
    );

NTSTATUS
FASTCALL
RtlpValidateBuffer2Class(
    PPRIVATE_RTL_BUFFER2 Class
    );

VOID
FASTCALL
RtlpBuffer2ClassFree(
    PRTL_BUFFER2_CLASS Class,
    PVOID p
    );

BOOL
FASTCALL
RtlpBuffer2ClassCanReallocate(
    PRTL_BUFFER2_CLASS Class
    );

PVOID
FASTCALL
RtlpBuffer2ClassAllocate(
    PRTL_BUFFER2_CLASS Class,
    SIZE_T             Size
    );

VOID
FASTCALL
RtlpBuffer2ClassError(
    PRTL_BUFFER2_CLASS Class
    );

RETURN_TYPE
NTAPI
RtlpInitBuffer2(
    PPRIVATE_RTL_BUFFER2 Buffer,
    struct _RTL_BUFFER_CLASS * Class,
    PVOID        StaticBuffer,
    SIZE_T       StaticBufferSize
    );

VOID
FASTCALL
RtlpFreeBuffer2(
    PPRIVATE_RTL_BUFFER2 Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\buffer\ntrtlbuffer2.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntrtlbuffer2.c

Abstract:

Author:

    Jay Krell (JayKrell) January 2002

Environment:

Revision History:

--*/

#include "ntrtlbuffer2.h"
#include "ntrtlbuffer2p.h"

#if DBG
VOID
FASTCALL
RtlpAssertBuffer2Consistency(
    PPRIVATE_RTL_BUFFER2 Buffer
    )
{
    ASSERT(Buffer->AllocatedSize >= Buffer->RequestedSize);
    if (Buffer->Buffer == Buffer->StaticBuffer) {
        ASSERT(Buffer->AllocatedSize == Buffer->StaticBufferSize);
    }
}

PVOID
FASTCALL
RtlpFindNonNullInPointerArray(
    PVOID * PointerArray,
    SIZE_T  SizeOfArray
    )
{
    SIZE_T i;
    PVOID p;

    p = NULL;
    for ( i = 0 ; i != SizeOfArray ; ++i )
    {
        p = PointerArray[i];
        if (p != NULL)
        {
            break;
        }
    }
    return p;
}

NTSTATUS
FASTCALL
RtlpValidateBuffer2Class(
    PPRIVATE_RTL_BUFFER2 Class
    )
{
    FN_PROLOG();
    PVOID Allocate[5] = { NULL, NULL, NULL, NULL, NULL };
    PVOID Free[2] = { NULL, NULL };
    PRTL_BUFFER2_CLASS_UALLOCATOR u;
    PVOID HeapHandle;
    BOOL NeedHeapHandle;
    BOOL Failed;

    CHECK_PARAMETER(Buffer != NULL);

    Failed = FALSE;
    NeedHeapHandle = FALSE;
    u = &Class->uAllocator;

    switch (Class->AllocatorType)
    {
    default:
        DbgPrint("%s: bad Class->AllocatorType.\n", __FUNCTION__);
        Allocate[0] = (PVOID)1;
        Free[0] = (PVOID)1;
        Failed = TRUE;
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_STRING_CALLBACKS:
        Allocate[0] = u->NtrtlStringRoutines.Allocate; 
        Free[0] = u->NtrtlStringRoutines.Free;
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_POOL_CALLBACKS:
#if defined(_EX_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTOSP_) || defined(_WDM_) || defined(_NTHAL_)
        Allocate[0] = u->NtkernelPool.Allocate;
        Allocate[1] = u->NtkernelPool.AllocateWithQuota;
        Allocate[2] = u->NtkernelPool.AllocateWithTag;
        Allocate[3] = u->NtkernelPool.AllocateWithQuotaTag;
        Allocate[4] = u->NtkernelPool.AllocateWithTagPriority;
        Free[0] = u->NtkernelPool.Free;
        Free[1] = u->NtkernelPool.FreeWithTag;

#else
        DbgPrint("%s: You need to compile this code with more headers.\n", __FUNCTION__);
        ORIGINATE_INVALID_PARAMETER();
#endif
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_HEAP_CALLBACKS:
        Allocate[0] = u->NtrtlHeap.Allocate; 
        Free[0] = u->NtrtlHeap.Free;
        NeadHeapHandle = TRUE;
        HeapHandle = u->NtrtlHeap.HeapHandle;
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_HEAP_CALLBACKS:
        Allocate[0] = u->Win32Heap.Allocate; 
        Free[0] = u->Win32Heap.Free;
        NeadHeapHandle = TRUE;
        HeapHandle = u->Win32Heap.HeapHandle;
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_CRT_CALLBACKS:
        Allocate[0] = u->Crt.malloc;
        Free[0] = u->Crt.free;
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_IMALLOC:
        Allocate[0] = u->Malloc 
        Free[0] = u->Malloc;
        break;
    }

    if (NeedHeapHandle && HeapHandle == NULL)
    {
        DbgPrint("%s: NeadHeapHandle && HeapHandle == NULL\n", __FUNCTION__);
        Failed = TRUE;
    }
    // ensure we have an allocate and a free routine
    if (RtlpFindNonNullInPointerArray(Allocate, RTL_NUMBER_OF(Allocate)) == NULL)
    {
        DbgPrint("%s: missing allocate routine\n", __FUNCTION__);
        Failed = TRUE;
    }
    // ensure we have an allocate and a free routine
    if (RtlpFindNonNullInPointerArray(Free, RTL_NUMBER_OF(Free)) == NULL)
    {
        DbgPrint("%s: missing free routine\n", __FUNCTION__);
        Failed = TRUE;
    }

    if (Failed)
    {
        goto Exit;
    }

    FN_EPILOG();
}

VOID
FASTCALL
RtlpBuffer2ClassFree(
    PRTL_BUFFER2_CLASS Class,
    PVOID p
    )
{
    PRTL_BUFFER2_CLASS_UALLOCATOR u;

    if (p == NULL) {
        goto Exit;
    }

    u = &Class->uAllocator;
    switch (Class->AllocatorType)
    {
    default:
        DbgPrint("%s: bad Class->AllocatorType.\n", __FUNCTION__);
        ORIGINATE_INVALID_PARAMETER();
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_STRING_CALLBACKS:
        (*u->NtrtlStringRoutines.Free)(
            p);
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_POOL_CALLBACKS:
#if defined(_EX_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTOSP_) || defined(_WDM_) || defined(_NTHAL_)
        ASSERT(u->NtkernelPool.FreeWithTag != NULL || u->NtkernelPool.Free != NULL);
        if (u->NtkernelPool.FreeWithTag != NULL)
        {
            (*u->NtkernelPool.FreeWithTag)(p, u->NtkernelPool.Tag);
        }
        else if (u->NtkernelPool.Free != NULL)
        {
            (*u->NtkernelPool.Free)(p);
        }
#else
        DbgPrint("%s: You need to compile this code with more headers.\n", __FUNCTION__);
        ORIGINATE_INVALID_PARAMETER();
#endif
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_HEAP_CALLBACKS:
        (*u->NtrtlHeap.Free)(
            u->NtrtlHeap.HeapHandle,
            0,
            p);
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_HEAP_CALLBACKS:
        (*u->Win32Heap.Free)(
            u->Win32Heap.HeapHandle,
            0,
            p);
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_CRT_CALLBACKS:
        (*u->Crt.Free)(
            p);
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_IMALLOC:
        break;
    }

Exit:
    return;
}

BOOL
FASTCALL
RtlpBuffer2ClassCanReallocate(
    PRTL_BUFFER2_CLASS Class
    )
{
    PVOID * pp;
    PRTL_BUFFER2_CLASS_UALLOCATOR u;

    u = &Class->uAllocator;

    switch (Class->AllocatorType)
    {
    default:
        ASSERT(FALSE);
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_STRING_CALLBACKS:
    case RTL_BUFFER2_CLASS_ALLOCATOR_POOL_CALLBACKS:
        pp = NULL; // FALSE
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_HEAP_CALLBACKS:
        pp = (PVOID*)&u->NtrtlHeap.Reallocate;
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_HEAP_CALLBACKS:
        pp = (PVOID*)&u->Win32Heap.Reallocate;
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_CRT_CALLBACKS:
        pp = (PVOID*)&u->Crt.Reallocate;
        break;

    case RTL_BUFFER2_CLASS_ALLOCATOR_IMALLOC:
        pp = (PVOID*)&pp; // TRUE
        break;
    }
    return (pp != NULL && *pp != NULL);
}


RETURN_TYPE
NTAPI
RtlEnsureBufferSizeEx2(
    PRTL_BUFFER2 Buffer,
    SIZE_T Size
    OUT PVOID * p OPTIONAL
    )
{
    FN_PROLOG();

    CHECK_PARAMETER(Buffer != NULL);
    if (p != NULL) {
        *p = NULL;
    }

    Ret = RtlEnsureBufferSize2(Buffer, Size);
    if (MY_FAILED(Ret)) {
        goto Exit;
    }
    if (p != NULL) {
        *p = RtlpGetBuffer2(Buffer);
    }

    FN_EPILOG();
}

PVOID
FASTCALL
RtlpBuffer2ClassAllocate(
    PRTL_BUFFER2_CLASS Class,
    SIZE_T             Size
    )
{
    PVOID p;

    switch (p
    p = NULL;
Exit:
    return p;
}

VOID
FASTCALL
RtlpBuffer2ClassError(
    PRTL_BUFFER2_CLASS Class
    )
{
}

RETURN_TYPE
NTAPI
RtlpInitBuffer2(
    PPRIVATE_RTL_BUFFER2 Buffer,
    struct _RTL_BUFFER_CLASS * Class,
    PVOID        StaticBuffer,
    SIZE_T       StaticBufferSize
    )
{
    FN_PROLOG();

    Ret = RtlpValidateBuffer2Class(Class);
    if (MY_FAILED(Ret)) {
        goto Exit;
    }
    if (StaticBufferSize != 0 && StaticBuffer == NULL) {
        //
        // This could mean do an initial allocation.
        //
        // Status = RtlpBuffer2ClassAllocate(Class, StaticBufferSize, &StaticBuffer);
        // if (!NT_SUCCESS(Status)) {
        //   goto Exit;
        // }
        //
        ORIGINATE_INVALID_PARAMETER();
    }
    Buffer->Buffer = StaticBuffer;
    Buffer->StaticBuffer = StaticBuffer;
    Buffer->StaticBufferSize = StaticBufferSize;
    Buffer->AllocatedSize = StaticBufferSize;
    Buffer->RequestedSize = 0;
    Buffer->Class = Class;

    RtlpAssertBuffer2Consistency(Buffer);

    FN_EPILOG();
}

RETURN_TYPE
NTAPI
RtlInitBuffer2(
    PRTL_BUFFER2 OpaqueBuffer,
    struct _RTL_BUFFER_CLASS * Class,
    PVOID        StaticBuffer,
    SIZE_T       StaticBufferSize
    )
{
    return RtlpInitBuffer2((PPRIVATE_RTL_BUFFER2)OpaqueBuffer, Class, StaticBuffer, StaticBufferSize);
}

VOID
FASTCALL
RtlpFreeBuffer2(
    PPRIVATE_RTL_BUFFER2 Buffer
    )
{
    FN_PROLOG();
    PRIVATE_RTL_BUFFER2 Local;

    RtlpAssertBuffer2Consistency(Buffer);

    Local.StaticBuffer = Buffer->StaticBuffer;
    Local.Buffer = Buffer->Buffer;
    Local.Class = Buffer->Class;

    if (Local.Buffer != Local.StaticBuffer) {
        RtlpBuffer2ClassFree(Local.Class, Local.Buffer);
    }
    Ret = RtlpInitBuffer2(Buffer, Local.Class, Local.StaticBuffer, Buffer->StaticBufferSize);
    ASSERT(MY_SUCCESS(Ret));
}

VOID
FASTCALL
RtlFreeBuffer2(
    PRTL_BUFFER2 OpaqueBuffer
    )
{
    RtlpFreeBuffer2((PPRIVATE_RTL_BUFFER2)OpaqueBuffer);
}

SIZE_T
FASTCALL
RtlGetAllocatedBufferSize2(
    PRTL_BUFFER2 Buffer,
    )
{
    ASSERT(Buffer != NULL);
    return RtlpGetAllocatedBufferSize2(Buffer);
}

SIZE_T
FASTCALL
RtlGetRequestedBufferSize2(
    PRTL_BUFFER2 Buffer,
    OUT PSIZE_T Size
    )
{
    ASSERT(Buffer != NULL);
    return RtlpGetRequestedBufferSize2(Buffer);
}

PVOID
FASTCALL
RtlGetBuffer2(
    PRTL_BUFFER2 Buffer
    )
{
    ASSERT(Buffer != NULL);
    return RtlpGetBuffer2(Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\fusion_win2000.inc ===
FUSION_LIB_DEST = $(FUSION_WIN2000_LIB_DEST)
C_DEFINES = $(C_DEFINES) -DFUSION_WIN2000=1
C_DEFINES = $(C_DEFINES) -DFUSION_NO_WRAPPERS=1 -DFUSION_ENABLE_UNWRAPPED_NEW=1 -DFUSION_ENABLE_UNWRAPPED_DELETE=1
FUSION_BUILD_TYPE_PREFIX=w2k
FUSION_INC_PATH=$(FUSION_ALL_INC_PATH);$(FUSION_WIN2000_INC_PATH)
!undef USE_RTTI
FUSION_LIB_PATH = $(FUSION_WIN2000_LIB_PATH)
!if !defined(FUSION_BUILD_LEAF_DIRECTORY)
FUSION_BUILD_LEAF_DIRECTORY=win2000
!endif
FUSION_SLIST_LIB=$(BASE_LIB_PATH)\ntslist.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\buffer\ntrtlbuffer3.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntrtlbuffer3.c

Abstract:

Author:

    Jay Krell (JayKrell) January 2002

Environment:

Revision History:

--*/

#include "ntrtlbuffer3.h"

typedef struct _REVEAL_RTL_BYTE_BUFFER3 {
    PREVEAL_RTL_BYTE_BUFFER3 Self; // for heap allocated "mini dynamic"
    PVOID   Buffer;
    SIZE_T  RequestedSize;
    SIZE_T  AllocatedSize;
    PVOID   StaticBuffer;
    SIZE_T  StaticBufferSize;
    PCRTL_BUFFER3_ALLOCATOR Traits;
    PVOID   TraitsContext;
} REVEAL_RTL_BYTE_BUFFER3, *PREVEAL_RTL_BYTE_BUFFER3;
typedef const REVEAL_RTL_BYTE_BUFFER3 * PCREVEAL_RTL_BYTE_BUFFER3;

PREVEAL_RTL_BYTE_BUFFER3
RtlpRevealByteBuffer3(
    PRTL_BYTE_BUFFER3 OpaqueBuffer
    )
{
    return ((PREVEAL_RTL_BYTE_BUFFER3)OpaqueBuffer)->Self;
}

RTL_BUFFER3_RETURN
FASTCALL
RtlInitByteBuffer3(
    ULONG               Flags,
    SIZE_T              SizeofBuffer,
    PRTL_BYTE_BUFFER3   Buffer,
    SIZE_T              SizeofStaticBuffer,
    PBYTE               StaticBuffer,
    SIZE_T                  SizeofTraits,
    PCRTL_BUFFER3_ALLOCATOR Traits,
    PVOID                   TraitsContext
    )
{
    RTL_BUFFER3_RETURN Ret;
    PREVEAL_RTL_BYTE_BUFFER3 Revealed;
    BOOL NewStaticWithMiniDynamic;

    if (SizeofBuffer < sizeof(*Buffer))
    {
        if (SizeofBuffer < (sizeof(ULONG_PTR)))
        {
            goto InvalidParameter;
        }
        if (Traits == NULL)
        {
            goto InvalidParameter;
        }
        if (!RTL_CONTAINS_FIELD(Traits, SizeofTraits, CanAllocate))
        {
            goto InvalidParameter;
        }
        if (!RTL_CONTAINS_FIELD(Traits, SizeofTraits, Allocate))
        {
            goto InvalidParameter;
        }
        if (!Traits->CanAllocate(TraitsContext))
        {
            goto InvalidParameter;
        }
        NewStaticWithMiniDynamic = (StaticBuffer == NULL && SizeofStaticBuffer != 0);
        RevealedSize = sizeof(*Revealed;
        if (NewStaticWithMiniDynamic)
        {
            RevealedSize += SizeofStaticBuffer;
        }
        Revealed = (PREVEAL_RTL_BYTE_BUFFER3)Traits->Allocate(TraitsContext, RevealedSize);
        if (Revealed == NULL)
        {
            if (NewStaticWithMiniDynamic)
            {
                NewStaticWithMiniDynamic = FALSE;
                Revealed = (PREVEAL_RTL_BYTE_BUFFER3)Traits->Allocate(TraitsContext, sizeof(*Revealed));
            }
            if (Revealed == NULL)
            {
                goto CallbackError;
            }
        }
        if (NewStaticWithMiniDynamic)
        {
            StaticBuffer = (PBYTE)(Revealed + 1);
        }
    }
    else
    {
        Revealed = (PREVEAL_RTL_BYTE_BUFFER3)Buffer;
    }
    ((PREVEAL_RTL_BYTE_BUFFER3)OpaqueBuffer)->Self = Revealed;
    Revealed->StaticBuffer = StaticBuffer;
    Revealed->StaticBufferSize = SizeofStaticBuffer;
    Revealed->RequestedSize = 0;
    Revealed->AllocatedSize = SizeofStaticBuffer;
    Revealed->Buffer = StaticBuffer;
    Revealed->Traits = Traits;
    Revealed->TraitsContext = TraitsContext;

    Ret = RTL_BUFFER3_SUCCESS;
Exit:
    return Ret;

InvalidParameter:
    Ret = RTL_BUFFER3_INVALID_PARAMETER;
    goto Exit;
CallbackError:
    Ret = RTL_BUFFER3_CALLBACK_ERROR;
    goto Exit;
}

BOOL FASTCALL RtlBuffer3Allocator_CanAllocate_False(PVOID VoidContext) { return FALSE; }
BOOL FASTCALL RtlBuffer3Allocator_CanAllocate_True(PVOID VoidContext) { return TRUE; }
BOOL FASTCALL RtlBuffer3Allocator_CanReallocate_False(PVOID VoidContext) { return FALSE; }
BOOL FASTCALL RtlBuffer3Allocator_CanReallocate_True(PVOID VoidContext) { return TRUE; }

#if defined(_WINBASE_)

#define RtlpBuffer3Allocator_Win32HeapGetHeap(c) \
    (((c) != NULL && (c)->UsePrivateHeap) ? (c)->PrivateHeap : GetProcessHeap())

#define RtlpBuffer3Allocator_Win32HeapGetError(c) \
    (((c) != NULL && (c)->UsePrivateError) ? (c)->PrivateOutOfMemoryError : ERROR_NO_MEMORY)

#define RtlpBuffer3Allocator_Win32HeapGetFlags(c) \
    (((c) != NULL) ? (c)->HeapFlags : 0)

#define RtlpBuffer3Allocator_Win32HeapSetLastError(c) \
    (((c) == NULL || (c)->DoNotSetLastError) ? ((void)0) : SetLastError(RtlpBuffer3Allocator_Win32HeapGetError(c)))

PVOID FASTCALL RtlBuffer3Allocator_Win32HeapAllocate(PVOID VoidContext, SIZE_T NumberOfBytes)
{
    PVOID p;
    PRTL_BUFFER3_ALLOCATOR_WIN32HEAP Context = (PRTL_BUFFER3_ALLOCATOR_WIN32HEAP)VoidContext;

    p = HeapAlloc(RtlpBuffer3Allocator_Win32HeapGetHeap(Context), RtlpBuffer3Allocator_Win32HeapGetFlags(Context), NumberOfBytes);
    if (p == NULL)
        RtlpBuffer3Allocator_Win32HeapSetLastError(Context);
    return p;
}

VOID FASTCALL RtlBuffer3Allocator_Win32HeapFree(PVOID VoidContext, PVOID Pointer);
{
    PVOID p;
    PRTL_BUFFER3_ALLOCATOR_WIN32HEAP Context = (PRTL_BUFFER3_ALLOCATOR_WIN32HEAP)VoidContext;

    HeapFree(RtlpBuffer3Allocator_Win32HeapGetHeap(Context), RtlpBuffer3Allocator_Win32HeapGetFlags(Context), Pointer);
}

PVOID FASTCALL RtlBuffer3Allocator_Win32HeapReallocate(PVOID VoidContext, PVOID OldPointer, SIZE_T NewSize)
{
    PVOID p;
    PRTL_BUFFER3_ALLOCATOR_WIN32HEAP Context = (PRTL_BUFFER3_ALLOCATOR_WIN32HEAP)VoidContext;

    p = HeapReAlloc(RtlpBuffer3Allocator_Win32HeapGetHeap(Context), RtlpBuffer3Allocator_Win32HeapGetFlags(Context), OldPointer, NewSize);
    if (p == NULL)
        RtlpBuffer3Allocator_Win32HeapSetLastError(Context);
    return p;
}

#endif

#if defined(_NTRTL_) || defined(_NTURTL_)

#if RTLBUFFER3_KERNELMODE

#define RtlpBuffer3Allocator_NtHeapGetHeap(c) \
    (ASSERT((c) != NULL), ASSERT((c)->UsePrivateHeap), ASSERT((c)->PrivateHeap != NULL), (c)->PrivateHeap)

#define RtlpBuffer3Allocator_NtHeapGetFlags(c) \
    (ASSERT((c) != NULL), (c)->HeapFlags)

#else

#define RtlpBuffer3Allocator_NtHeapGetHeap(c) \
    (((c) != NULL && (c)->UsePrivateHeap) ? (c)->PrivateHeap : RtlProcessHeap())

#define RtlpBuffer3Allocator_NtHeapGetFlags(c) \
    (((c) != NULL) ? (c)->HeapFlags : 0)

#endif

PVOID FASTCALL RtlBuffer3Allocator_NtHeapAllocate(PVOID VoidContext, SIZE_T NumberOfBytes)
{
    PVOID p;
    PRTL_BUFFER3_ALLOCATOR_WIN32HEAP Context = (PRTL_BUFFER3_ALLOCATOR_WIN32HEAP)VoidContext;

    p = RtlAllocateHeap(RtlpBuffer3Allocator_NtHeapGetHeap(Context), RtlpBuffer3Allocator_NtHeapGetFlags(Context), NumberOfBytes);

    return p;
}

VOID FASTCALL RtlBuffer3Allocator_NtHeapFree(PVOID VoidContext, PVOID Pointer);
{
    PVOID p;
    PRTL_BUFFER3_ALLOCATOR_WIN32HEAP Context = (PRTL_BUFFER3_ALLOCATOR_WIN32HEAP)VoidContext;

    RtlFreeHeap(RtlpBuffer3Allocator_NtHeapGetHeap(Context), RtlpBuffer3Allocator_NtHeapGetFlags(Context), Pointer);
}

PVOID FASTCALL RtlBuffer3Allocator_NtHeapReallocate(PVOID VoidContext, PVOID OldPointer, SIZE_T NewSize)
{
#if RTLBUFFER3_KERNELMODE || !defined(_NTURTL_)
    return NULL;
#else
    PVOID p;
    PRTL_BUFFER3_ALLOCATOR_WIN32HEAP Context = (PRTL_BUFFER3_ALLOCATOR_WIN32HEAP)VoidContext;

    p = RtlReAllocateHeap(RtlpBuffer3Allocator_NtHeapGetHeap(Context), RtlpBuffer3Allocator_NtHeapGetFlags(Context), OldPointer, NewSize);

    return p;
#endif
}

#endif

SIZE_T FASTCALL * RtlBuffer3Allocator_FixedAllocationSize(PVOID VoidContext, SIZE_T CurrentAllocatedSize, SIZE_T RequiredSize)
{
    return CurrentAllocatedSize;
}

SIZE_T FASTCALL * RtlBuffer3Allocator_DoublingAllocationSize(PVOID VoidContext, SIZE_T CurrentAllocatedSize, SIZE_T RequiredSize)
{
    CurrentAllocatedSize += CurrentAllocatedSize;
    return (RequiredSize >= CurrentAllocatedSize) ? RequiredSize : CurrentAllocatedSize;
}

SIZE_T FASTCALL * RtlBuffer3Allocator_MinimumAlocationSize(PVOID VoidContext, SIZE_T CurrentAllocatedSize, SIZE_T RequiredSize)
{
    return RequiredSize;
}

//
// RtlAllocateStringRoutine is not exported outside of ntoskrnl.exe and ntdll.dll.
// RtlFreeStringRoutine is exported directly enough via RtlFreeUnicodeString.
//
// see base\ntdll\ldrinit.c and base\ntos\ex\pool.c for the definitions
// of RtlAllocateStringRoutine and RtlFreeStringRoutine.
//

VOID FASTCALL RtlBuffer3Allocator_NtStringFree(PVOID VoidContext, PVOID Pointer)
{
    UNICODE_STRING UnicodeString;

    UnicodeString.Buffer = (PWSTR)Pointer;
    RtlFreeUnicodeString(&UnicodeString);
}

#if RTLBUFFER3_NTKERNEL || RTLBUFFER3_NTDLL

PVOID FASTCALL RtlBuffer3Allocator_NtStringAllocate(PVOID VoidContext, SIZE_T NumberOfBytes)
{
    return (*RtlAllocateStringRoutine)(NumberOfBytes);
}

#elif RTLBUFFER3_USERMODE

PVOID FASTCALL RtlBuffer3Allocator_NtStringAllocate(PVOID VoidContext, SIZE_T NumberOfBytes)
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, NumberOfBytes);
}

#elif RTLBUFFER3_KERNELMODE

PVOID FASTCALL RtlBuffer3Allocator_NtStringAllocate(PVOID VoidContext, SIZE_T NumberOfBytes)
{
#undef ExAllocatePoolWithTag
    return ExAllocatePoolWithTag(PagedPool,NumberOfBytes,'grtS');
}

#endif

#if RTLBUFFER3_KERNELMODE && (defined(_EX_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTOSP_) || defined(_WDM_) || defined(_NTHAL_))

#define RtlpBuffer3Allocator_NtkernelPool_GetWhichFunction(c) \
    (((c) != NULL) ? (c)->WhichFunction : RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL)

#define RtlpBuffer3Allocator_NtkernelPool_GetTag(c) \
    (((c) != NULL) ? (c)->Tag : 0)

#define RtlpBuffer3Allocator_NtkernelPool_GetType(c) \
    (((c) != NULL) ? (c)->Type : NonPagedPool)

#define RtlpBuffer3Allocator_NtkernelPool_GetPriority(c) \
    (((c) != NULL) ? (c)->Priority : NormalPoolPriority)

#undef ExAllocatePoolWithTag
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#undef ExAllocatePoolWithQuotaTag
#undef ExFreePool
#undef ExFreePoolWithTag

PVOID FASTCALL RtlBuffer3Allocator_NtkernelPoolAllocate(PVOID VoidContext, SIZE_T NumberOfBytes)
{
    PVOID p;
    PRTL_BUFFER3_ALLOCATOR_WIN32HEAP Context = (PRTL_BUFFER3_ALLOCATOR_WIN32HEAP)VoidContext;

    switch (RtlpBuffer3Allocator_NtkernelPool_GetWhichFunction(Context))
    {
    default:
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL:
        p = ExAllocatePool(
                RtlpBuffer3Allocator_NtkernelPool_GetType(Context),
                NumberOfBytes
                );
        break;
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_TAG:
        p = ExAllocatePoolWithTag(
                RtlpBuffer3Allocator_NtkernelPool_GetType(Context),
                NumberOfBytes,
                RtlpBuffer3Allocator_NtkernelPool_GetTag(Context)
                );
        break;
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_QUOTA:
        p = ExAllocatePoolWithQuota(
                RtlpBuffer3Allocator_NtkernelPool_GetType(Context),
                NumberOfBytes
                );
        break;
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_QUOTA_TAG:
        p = ExAllocatePoolWithQuotaTag(
                RtlpBuffer3Allocator_NtkernelPool_GetType(Context),
                NumberOfBytes,
                RtlpBuffer3Allocator_NtkernelPool_GetTag(Context)
                );
        break;
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_TAG_PRIORITY:
        p = ExAllocatePoolWithTagPriority(
                RtlpBuffer3Allocator_NtkernelPool_GetType(Context),
                NumberOfBytes,
                RtlpBuffer3Allocator_NtkernelPool_GetTag(Context),
                RtlpBuffer3Allocator_NtkernelPool_GetPriority(Context)
                );
        break;
    }
    return p;
}

VOID FASTCALL RtlBuffer3Allocator_NtKernelPoolFree(PVOID VoidContext, PVOID Pointer)
{
    PRTL_BUFFER3_ALLOCATOR_WIN32HEAP Context;
    //
    // ExFreePool/ExAllocatePoolWithTag, pretty unique among allocators, does not accept NULL.
    //
    if (Pointer == NULL)
        return;

    Context = (PRTL_BUFFER3_ALLOCATOR_WIN32HEAP)VoidContext;

    switch (RtlpBuffer3Allocator_NtkernelPool_GetWhichFunction(Context))
    {
    default:
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL:
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_QUOTA:
        ExFreePool(Pointer);
        break;
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_TAG:
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_QUOTA_TAG:
    case RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_TAG_PRIORITY:
        ExAllocatePoolWithTag(Pointer);
        break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\cgen\cgenhdr.h ===
// Copyright (c) Microsoft Corporation

#include <stddef.h>
#if MICROSOFT_INTERNAL
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#else
#include "windows.h"
#undef C_ASSERT
#define C_ASSERT(x) /* nothing */
#include "ole2.h"
#include "commctrl.h"
#include "imagehlp.h"
#include "setupapi.h"
#include "wincrypt.h"
#include "winver.h"
#endif

#ifdef SORTPP_PASS
//Restore IN, OUT
#ifdef IN
#undef IN
#endif

#ifdef OUT
#undef OUT
#endif

#define IN __in
#define OUT __out
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\buffer\ntrtlbuffer3.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntrtlbuffer3.h

Abstract:

Author:

    Jay Krell (JayKrell) January 2002

Environment:

Revision History:

--*/
#if _MSC_VER > 1000
#pragma once
#endif

//
// RTLBUFFER3_USERMODE -- usermode, not necessarily linked into ntdll.dll
// RTLBUFFER3_KERNELMODE -- kernelmode, not necessarily linked into ntoskrnl.exe
// RTLBUFFER3_NTDLL -- usermode, linked into ntdll.dll
// RTLBUFFER3_NTKERNEL -- kernelmode, linked into ntoskrnl.exe
// (if ntdll.dll and ntoskrnl.exe would only export the publically declared string routines...)
//
// RTLBUFFER3_BOOT -- TBD
//
#if defined(_NTDLLBUILD_)
#define RTLBUFFER3_NTDLL    1
#define RTLBUFFER3_USERMODE 1
#endif
#if defined(NTOS_KERNEL_RUNTIME)
#define RTLBUFFER3_NTKERNEL   1
#define RTLBUFFER3_KERNELMODE 1
#endif

#if defined(RTLBUFFER3_USERMODE) && !defined(RTLBUFFER3_KERNELMODE)
#define RTLBUFFER3_KERNELMODE (!RTLBUFFER3_USERMODE)
#endif
#if !defined(RTLBUFFER3_USERMODE) && defined(RTLBUFFER3_KERNELMODE)
#define RTLBUFFER3_USERMODE (!RTLBUFFER3_KERNELMODE)
#endif
#if !defined(RTLBUFFER3_NTDLL)
#define RTLBUFFER3_NTDLL 0
#endif
#if !defined(RTLBUFFER3_NTKERNEL)
#define RTLBUFFER3_NTKERNEL 0
#endif

#if RTLBUFFER3_NTKERNEL && RTLBUFFER3_NTDLL
#error 1
#endif
#if RTLBUFFER3_NTKERNEL && RTLBUFFER3_USERMODE
#error 2
#endif
#if RTLBUFFER3_KERNELMODE && RTLBUFFER3_NTDLL
#error 3
#endif
#if RTLBUFFER3_KERNELMODE && RTLBUFFER3_USERMODE
#error 4

#ifdef __cplusplus
extern "C" {
#endif

#include "nt.h"
#include "ntrtl.h"
#if RTLBUFFER3_USERMODE
#include "nturtl.h"
#include "windows.h"
#endif

//
// This costs an extra heap allocation.
//
typedef struct _RTL_MINI_DYNAMIC_BYTE_BUFFER3 {
    ULONG_PTR O_p_a_q_u_e[1];
} RTL_MINI_DYNAMIC_BYTE_BUFFER3, *PRTL_MINI_DYNAMIC_BYTE_BUFFER3;
typedef const RTL_MINI_DYNAMIC_BYTE_BUFFER3 * PCRTL_MINI_DYNAMIC_BYTE_BUFFER3;

typedef struct _RTL_BYTE_BUFFER3 {
    ULONG_PTR O_p_a_q_u_e[9];
} RTL_BYTE_BUFFER3, *PRTL_BYTE_BUFFER3;
typedef const RTL_BYTE_BUFFER3 * PCRTL_BYTE_BUFFER3;

typedef struct _RTL_BUFFER3_ALLOCATOR {
    BOOL  (FASTCALL * CanAllocate)(PVOID Context); // eg: false for FixedSizeAllocator
    PVOID (FASTCALL * Allocate)(PVOID Context, SIZE_T NumberOfBytes);
     VOID (FASTCALL * Free)(PVOID Context, PVOID Pointer);
    BOOL  (FASTCALL * CanReallocate)(PVOID Context); // eg: false for NtkernelPoolAllocator
    PVOID (FASTCALL * Reallocate)(PVOID Context, PVOID OldPointer, SIZE_T NewSize);
    SIZE_T (FASTCALL * GetAllocationSize)(PVOID Context, SIZE_T CurrentAllocatedSize, SIZE_T RequiredSize);
} RTL_BUFFER3_ALLOCATOR, *PRTL_BUFFER3_ALLOCATOR;
typedef const RTL_BUFFER3_ALLOCATOR *PCRTL_BUFFER3_ALLOCATOR;

typedef enum _RTL_BUFFER3_RETURN {
    RTL_BUFFER3_SUCCESS           = 0,
    RTL_BUFFER3_INVALID_PARAMETER = 1,
    RTL_BUFFER3_INTERNAL_ERROR    = 2,
    RTL_BUFFER3_CALLBACK_ERROR    = 3
} RTL_BUFFER3_RETURN;


//
// These are only "hints" for debugging, and to
// establish "causality" from the macro calls.
//
#define RTL_INIT_BYTE_BUFFER3_FLAGS_PREALLOCATED 0x80000000
#define RTL_INIT_BYTE_BUFFER3_FLAGS_FIXED_SIZE   0x40000000
#define RTL_INIT_BYTE_BUFFER3_FLAGS_DYNAMIC      0x20000000

RTL_BUFFER3_RETURN
FASTCALL
RtlInitByteBuffer3(
    ULONG               Flags,
    PRTL_BYTE_BUFFER3   Buffer,
    SIZE_T              SizeofBufferForBinaryCompatibilityPurposes,
    PBYTE               StaticBuffer,
    SIZE_T              StaticBufferSize,
    PCRTL_BUFFER3_ALLOCATOR Allocator,
    PVOID                   AllocatorContext
    );

#define RTL_PREALLOCATED_BYTE_BUFFER3(n) \
    struct {
        RTL_BYTE_BUFFER3 Buffer; \
        BYTE        StaticBuffer[n]; \
    }

#define RtlInitPreallocatedByteBuffer3(flags, buf, a, ac) \
    (RtlInitByteBuffer3((flags) | RTL_INIT_BYTE_BUFFER3_FLAGS_PREALLOCATED, &(buf)->Buffer, sizeof(&(buf)->Buffer), (buf)->StaticBuffer, sizeof((buf)->StaticBuffer), (a), (ac)))

#define RtlInitFixedSizeByteBuffer3(flags, buf, statbuf, statbufsiz) \
    (RtlInitByteBuffer3((flags) | RTL_INIT_BYTE_BUFFER3_FLAGS_FIXED_SIZE, (buf), sizeof(*(buf)), (statbuf), (statbufsiz), NULL, NULL))

#define RtlInitDynamicByteBuffer3(flags), buf, a, ac) \
    (RtlInitByteBuffer3((flags) | RTL_INIT_BYTE_BUFFER3_FLAGS_DYNAMIC, (buf), sizeof(buf), NULL, 0, (a), (ac)))

PVOID
FASTCALL
RtlByteBuffer3GetBuffer(
    PRTL_BYTE_BUFFER3 Buffer
    );

//
// There is both a "requested" size and an "allocated" size.
// requested <= allocated.
// This returns requested. Allocated is not available.
//
SIZE_T
FASTCALL
RtlByteBuffer3GetSize(
    PRTL_BYTE_BUFFER3 Buffer
    );

RTL_BUFFER3_RETURN
FASTCALL
RtlByteBuffer3EnsureSize(
    PRTL_BYTE_BUFFER3 Buffer,
    SIZE_T       Size,
    OUT PVOID *  OutBuffer OPTIONAL
    );

RTL_BUFFER3_RETURN
FASTCALL
RtlByteBuffer3AppendBuffer(
    PRTL_BYTE_BUFFER3  ToBuffer,
    PCRTL_BYTE_BUFFER3 FromBuffer,
    );

RTL_BUFFER3_RETURN
FASTCALL
RtlByteBuffer3PrependBuffer(
    PRTL_BYTE_BUFFER3  ToBuffer,
    PCRTL_BYTE_BUFFER3 FromBuffer,
    );

RTL_BUFFER3_RETURN
FASTCALL
RtlByteBuffer3InsertBuffer(
    PRTL_BYTE_BUFFER3   ToBuffer,
    PCRTL_BYTE_BUFFER3  FromBuffer,
    SIZE_T              Offset
    );

RTL_BUFFER3_RETURN
FASTCALL
RtlByteBuffer3CopyBuffer(
    PRTL_BYTE_BUFFER3  ToBuffer,
    PCRTL_BYTE_BUFFER3 FromBuffer,
    );

VOID
FASTCALL
RtlByteBuffer3TakeRemainingStaticBuffer(
    PRTL_BYTE_BUFFER3  Buffer,
    OUT PBYTE *        RemainingStaticBuffer,
    OUT SIZE_T *       RemainingStaticBufferSize
    );

RTL_BUFFER3_RETURN
FASTCALL
RtlFreeByteBuffer3(
    PRTL_BYTE_BUFFER3  Buffer
    );

BOOL FASTCALL RtlBuffer3Allocator_CanAllocate_False(PVOID Context);
BOOL FASTCALL RtlBuffer3Allocator_CanAllocate_True(PVOID Context);
BOOL FASTCALL RtlBuffer3Allocator_CanReallocate_False(PVOID Context);
BOOL FASTCALL RtlBuffer3Allocator_CanRellocate_True(PVOID Context);

//
// can be left as all zeros, or even a NULL context
//   defaults: heap=GetProcessHeap(), flags=0, SetLastError(ERROR_NO_MEMORY)
//
typedef struct _RTL_BUFFER3_ALLOCATOR_WIN32HEAP {
    BOOL    UsePrivateHeap;
    BOOL    DoNotSetLastError;
    BOOL    UsePrivateError;
    HANDLE  PrivateHeap;
    DWORD   HeapFlags;
    DWORD   PrivateOutOfMemoryError;
} RTL_BUFFER3_ALLOCATOR_WIN32HEAP, *PRTL_BUFFER3_ALLOCATOR_WIN32HEAP;
typedef const RTL_BUFFER3_ALLOCATOR_WIN32HEAP * PCRTL_BUFFER3_ALLOCATOR_WIN32HEAP;

PVOID FASTCALL RtlBuffer3Allocator_Win32HeapAllocate(PVOID VoidContext, SIZE_T NumberOfBytes);
 VOID FASTCALL RtlBuffer3Allocator_Win32HeapFree(PVOID VoidContext, PVOID Pointer);
PVOID FASTCALL RtlBuffer3Allocator_Win32HeapReallocate(PVOID Context, PVOID OldPointer, SIZE_T NewSize);

SIZE_T FASTCALL RtlBuffer3Allocator_FixedAllocationSize(PVOID Context, SIZE_T CurrentAllocatedSize, SIZE_T RequiredSize);
SIZE_T FASTCALL RtlBuffer3Allocator_DoublingAllocationSize(PVOID Context, SIZE_T CurrentAllocatedSize, SIZE_T RequiredSize);
SIZE_T FASTCALL RtlBuffer3Allocator_MinimumAlocationSize(PVOID Context, SIZE_T CurrentAllocatedSize, SIZE_T RequiredSize);

#define RtlBuffer3Allocator_Win32Heap \
    RtlBuffer3_Allocator_CanAllocate_True, \
    RtlBuffer3Allocator_Win32HeapAllocate, \
    RtlBuffer3Allocator_Win32HeapFree, \
    RtlBuffer3_Allocator_CanReallocate_True, \
    RtlBuffer3Allocator_Win32HeapReallocate \
    /* user specifies allocationsize */


//
// works in kernelmode and usermode, but kernelmode cannot realloc or use process heap
// context optional in usermode
//   defaults: heap=RtlProcessHeap(), flags=0
//
typedef struct _RTL_BUFFER3_ALLOCATOR_NTHEAP {
    BOOL    UsePrivateHeap; /* Must be true in kernelmode. */
    HANDLE  PrivateHeap;
    ULONG   HeapFlags;
} RTL_BUFFER3_ALLOCATOR_NTHEAP, *PRTL_BUFFER3_ALLOCATOR_NTHEAP;
typedef const RTL_BUFFER3_ALLOCATOR_NTHEAP * PCRTL_BUFFER3_ALLOCATOR_NTHEAP;

PVOID FASTCALL RtlBuffer3Allocator_NtHeapHeapAllocate(PVOID VoidContext, SIZE_T NumberOfBytes);
 VOID FASTCALL RtlBuffer3Allocator_NtHeapFree(PVOID VoidContext, PVOID Pointer);
PVOID FASTCALL RtlBuffer3Allocator_NtHeapReallocate(PVOID Context, PVOID OldPointer, SIZE_T NewSize);

#define RtlBuffer3Allocator_NtHeapKernelMode \
    RtlBuffer3_Allocator_CanAllocate_True, \
    RtlBuffer3Allocator_NtHeapAllocate, \
    RtlBuffer3Allocator_NtHeapFree, \
    RtlBuffer3_Allocator_CanReallocate_False, \
    NULL \
    /* user specifies allocationsize */

#define RtlBuffer3Allocator_NtHeapUserMode \
    RtlBuffer3_Allocator_CanAllocate_True, \
    RtlBuffer3Allocator_NtHeapAllocate, \
    RtlBuffer3Allocator_NtHeapFree, \
    RtlBuffer3_Allocator_CanReallocate_True, \
    RtlBuffer3Allocator_NtHeapReallocate \
    /* user specifies allocationsize */

#if defined(RTLBUFFER3_KERNELMODE)
#define RtlBuffer3Allocator_NtHeap RtlBuffer3Allocator_NtHeapKernelMode
#else
#define RtlBuffer3Allocator_NtHeap RtlBuffer3Allocator_NtHeapUserMode
#endif

//
// works in kernelmode and usermode
// no context
// realloc in usermode could be provided
//
PVOID FASTCALL RtlBuffer3Allocator_NtStringAllocate(PVOID VoidContext, SIZE_T NumberOfBytes);
 VOID FASTCALL RtlBuffer3Allocator_NtStringFree(PVOID VoidContext, PVOID Pointer);
//PVOID FASTCALL RtlBuffer3Allocator_NtStringReallocate(PVOID Context, PVOID OldPointer, SIZE_T NewSize);

#define RtlBuffer3Allocator_NtStringRoutines \
    RtlBuffer3_Allocator_CanAllocate_True, \
    RtlBuffer3Allocator_NtStringAllocate, \
    RtlBuffer3Allocator_NtStringFree, \
    RtlBuffer3_Allocator_CanReallocate_False, \
    NULL \
    /* user specifies allocationsize */

//
// no context
//
PVOID FASTCALL RtlBuffer3Allocator_CrtMalloc(PVOID VoidContext, SIZE_T NumberOfBytes);
 VOID FASTCALL RtlBuffer3Allocator_CrtFree(PVOID VoidContext, PVOID Pointer);
PVOID FASTCALL RtlBuffer3Allocator_CrtReallocate(PVOID Context, PVOID OldPointer, SIZE_T NewSize);

#define RtlBuffer3Allocator_CrtMallocFree \
    RtlBuffer3_Allocator_CanAllocate_True, \
    RtlBuffer3Allocator_CrtMalloc, \
    RtlBuffer3Allocator_CrtFree, \
    RtlBuffer3_Allocator_CanReallocate_True, \
    RtlBuffer3Allocator_CrtReallocate \
    /* user specifies allocationsize */

//
// no context
// no realloc
//
PVOID FASTCALL RtlBuffer3Allocator_OperatorNew(PVOID VoidContext, SIZE_T NumberOfBytes);
 VOID FASTCALL RtlBuffer3Allocator_OperatorDelete(PVOID VoidContext, PVOID Pointer);

#define RtlBuffer3Allocator_OperatorNewDelete \
    RtlBuffer3_Allocator_CanAllocate_True, \
    RtlBuffer3Allocator_OperatorNew, \
    RtlBuffer3Allocator_OperatorDelete, \
    RtlBuffer3_Allocator_CanReallocate_False, \
    NULL \
    /* user specifies allocationsize */

//
//
// context optional
//   defaults are: tag=0, type=nonpaged, priority=normal
// no realloc
// kernelmode only
//
#if defined(_EX_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTOSP_) || defined(_WDM_) || defined(_NTHAL_)

typedef enum _RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE {
    RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL,
    RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_TAG,
    RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_QUOTA,
    RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_QUOTA_TAG,
    RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE_EX_ALLOCATE_POOL_WITH_TAG_PRIORITY,
} RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE;

typedef struct _RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL {
    RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL_ALLOCATE WhichFunction;
    ULONG            Tag;
    POOL_TYPE        Type;
    EX_POOL_PRIORITY Priority;
} RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL, *PRTL_BUFFER3_ALLOCATOR_NTKERNELPOOL;
typedef const RTL_BUFFER3_ALLOCATOR_NTKERNELPOOL * PCRTL_BUFFER3_ALLOCATOR_NTKERNELPOOL;

#endif

PVOID FASTCALL RtlBuffer3Allocator_NtkernelPoolAllocate(PVOID VoidContext, SIZE_T NumberOfBytes);
 VOID FASTCALL RtlBuffer3Allocator_NtKernelPoolFree(PVOID VoidContext, PVOID Pointer);

#define RtlBuffer3Allocator_NtkernelPool \
    RtlBuffer3Allocator_CanAllocate_True, \
    RtlBuffer3Allocator_NtkernelPoolAllocate, \
    RtlBuffer3Allocator_NtKernelPoolFree, \
    RtlBuffer3Allocator_CanReallocate_False, \
    NULL \
    /* user specifies allocationsize */

/* TBD
NtkernelTextmodeSetup
NtbootLoader
*/

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\buffer\ntrtlbuffer3cpp.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntrtlbuffer3cpp.cpp

Abstract:

Author:

    Jay Krell (JayKrell) January 2002

Environment:

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#if defined(NTOS_KERNEL_RUNTIME)
#else
#include "nturtl.h"
#include "windows.h"
#endif
#include "ntrtlbuffer3.h"

#if defined(__cplusplus)
PVOID __fastcall RtlBuffer3Allocator_OperatorNew(PVOID VoidContext, SIZE_T NumberOfBytes)
{
#if defined(new)
#undef new
#endif
    return operator new(NumberOfBytes);
}

VOID __fastcall RtlBuffer3Allocator_OperatorDelete(PVOID VoidContext, PVOID Pointer)
{
    operator delete(Pointer);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\buffer\ntrtlbuffer2.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntrtlbuffer2.h

Abstract:

Author:

    Jay Krell (JayKrell) January 2002

Environment:

Revision History:

--*/

#ifndef _NTRTL_BUFFER2_
#define _NTRTL_BUFFER2_

#if _MSC_VER >= 1100
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4514)
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#endif
#endif

//
// Don't use NTSYSAPI directly so you can more easily
// statically link to these functions, independently
// of how you link to the rest of ntdll.
//
#if !defined(RTL_BUFFER2_API)
#define RTL_BUFFER2_API NTSYSAPI
#endif

typedef struct _RTL_BUFFER2 {
    PVOID  O_p_a_q_u_e[8];
} RTL_BUFFER2, *PRTL_BUFFER2;
typedef const RTL_BUFFER2 * PCRTL_BUFFER2;

#define RTL_BUFFER2_WITH_STATIC_BUFFER(nbytes) \
    struct { \
        RTL_BUFFER2 Buffer; \
        BYTE        StaticBuffer[nbytes]; \
    }

//
// this then begs for all the nt/win32 flavors..
//
#define RtlInitBuffer2WithStaticBuffer(b, c) \
    RtlInitBuffer2((b), (c), (b)->StaticBuffer, sizeof((b)->StaticBuffer))

RTL_BUFFER2_API
NTSTATUS
NTAPI
RtlInitBuffer2(
    PRTL_BUFFER2 Buffer,
    struct _RTL_BUFFER_CLASS * Class,
    PVOID        StaticBuffer,
    SIZE_T       StaticBufferSize
    );

RTL_BUFFER2_API
VOID
FASTCALL
RtlFreeBuffer2(
    PRTL_BUFFER2 Buffer
    );

RTL_BUFFER2_API
NTSTATUS
FASTCALL
RtlEnsureBufferSize2(
    PRTL_BUFFER2 Buffer,
    SIZE_T Size
    );

RTL_BUFFER2_API
NTSTATUS
NTAPI
RtlEnsureBufferSizeEx2(
    PRTL_BUFFER2 Buffer,
    SIZE_T Size
    OUT PVOID * p
    );

RTL_BUFFER2_API
SIZE_T
FASTCALL
RtlGetAllocatedBufferSize2(
    PRTL_BUFFER2 Buffer
    );

RTL_BUFFER2_API
SIZE_T
FASTCALL
RtlGetRequestedBufferSize2(
    PRTL_BUFFER2 Buffer
    );

RTL_BUFFER2_API
PVOID
FASTCALL
RtlGetBuffer2(
    PRTL_BUFFER2 Buffer
    );


/*NOT IMPLEMENTED*/#define RTL_BUFFER2_CLASS_FLAGS_IS_ARRAY                    (0x00000001)
/*NOT IMPLEMENTED*/#define RTL_BUFFER2_CLASS_FLAGS_IS_NUL_TERMINATED_STRING    (0x00000002)
/*CONSIDER*/#define RTL_BUFFER2_CLASS_FLAGS_IS_FREE_PRESERVE_LAST_ERROR (0x00000004)

//
// string routines is the recommended default, and works in usermode and kernelmode
// in usermode, it actually is equivalent to RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_PROCESS_HEAP
//
#define RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_STRING_CALLBACKS  (0x00000001)
#define RTL_BUFFER2_CLASS_ALLOCATOR_IMALLOC                 (0x00000002)
#define RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_HEAP_CALLBACKS    (0x00000004)
#define RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_HEAP_CALLBACKS    (0x00000008)
#define RTL_BUFFER2_CLASS_ALLOCATOR_CRT_CALLBACKS           (0x00000010)
#define RTL_BUFFER2_CLASS_ALLOCATOR_POOL_CALLBACKS          (0x00000020)

//
// doubling is the recommended default
//
#define RTL_BUFFER2_CLASS_ALLOCATE_SIZE_DOUBLING          (0x00000001)
#define RTL_BUFFER2_CLASS_ALLOCATE_SIZE_ONLY_NEEDED       (0x00000002)
#define RTL_BUFFER2_CLASS_ALLOCATE_SIZE_FACTOR            (0x00000004)
#define RTL_BUFFER2_CLASS_ALLOCATE_SIZE_CALLBACK          (0x00000008)

#define RTL_BUFFER2_CLASS_ERROR_NULL                            (0x00000001)
#define RTL_BUFFER2_CLASS_ERROR_NULL_SETLASTWIN32ERROR_CALLBACK (0x00000002)
#define RTL_BUFFER2_CLASS_ERROR_NULL_CALLBACK                   (0x00000004)
#define RTL_BUFFER2_CLASS_ERROR_WIN32_RAISEEXCEPTION_CALLBACK   (0x00000008)
#define RTL_BUFFER2_CLASS_ERROR_NTRTL_RAISESTATUS_CALLBACK      (0x00000010)

struct IMallocVtbl;
typedef struct IMallocVtbl IMallocVtbl;

#if defined(interface)
interface IMalloc;
typedef interface IMalloc IMalloc;
#else
struct IMalloc;
typedef struct IMalloc IMalloc;
#endif

//
// ntrtlbuffer2 has almost no static dependencies
// most linkage is via callbacks provided by the client
// the callbacks are meant to be link compatible with several
// widely available libraries, like ntoskrnl.exe, ntdll.dll, kernel32.dll, msvcrt.dll
// working in the boot environment is TBD
//

#define RtlBuffer2InitCommon(c) do { \
    (c)->ClassSize = sizeof(*(c)); \
    (c)->AllocationSizeType = RTL_BUFFER2_CLASS_ALLOCATE_SIZE_DOUBLING; /* may be superceded by client */ \
    (c)->ErrorType = RTL_BUFFER2_CLASS_ERROR_NULL; /* may be superceded by client */ \
 } while(0)

#define RtlBuffer2InitWin32(c) do { \
    RtlBuffer2InitCommon(c); \
    (c)->AllocatorType = RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_HEAP_CALLBACKS; \
    (c)->uAllocator.Win32Heap.HeapHandle = GetProcessHeap(); /* may be superceded by client */ \
    (c)->uAllocator.Win32Heap.Allocate = HeapAlloc; \
    (c)->uAllocator.Win32Heap.Reallocate = HeapReAlloc; \
    (c)->uAllocator.Win32Heap.Free = HeapFree; \
 } while(0)

#define RtlBuffer2InitCommonNrtlHeap() do { \
    RtlBuffer2InitCommon(c); \
    (c)->AllocatorType = RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_HEAP_CALLBACKS; \
    (c)->uAllocator.NtrtlHeap.Allocate = RtlAllocateHeap; \
    (c)->uAllocator.NtrtlHeap.Free = RtlFreeHeap; \
 } while(0)

#define RtlBuffer2InitUsermodeNrtlHeap() do { \
    RtlBuffer2InitCommonNrtl(c); \
    (c)->uAllocator.NtrtlHeap.HeapHandle = RtlProcessHeap(); \
    (c)->uAllocator.NtrtlHeap.Reallocate = RtlReAllocateHeap; \
 } while(0)

#define RtlBuffer2InitNtdllHeap(c) RtlBuffer2InitUsermodeNrtlHeap(c)

#define RtlBuffer2InitKernelmodeNtrtlheap(c) do { \
    RtlBuffer2InitCommonNrtl(c); \
    (c)->uAllocator.NtrtlHeap.HeapHandle = NULL; /* must be superceded by client */ \
 } while(0)

#define RtlBuffer2InitKernelmodeNtrtlStringRoutines(c) do { \
    RtlBuffer2InitCommon(c); \
    (c)->AllocatorType = RTL_BUFFER2_CLASS_ALLOCATOR_NTRTL_STRING_CALLBACKS; \
    (c)->uAllocator.NtrtlStringRoutines.Allocate = RtlAllocateStringRoutine; \
    (c)->uAllocator.NtrtlStringRoutines.Free = RtlFreeStringRoutine; \
 } while(0)

#define RtlBuffer2InitCommonNtpool() do { \
    RtlBuffer2InitCommon(c); \
    (c)->AllocatorType = RTL_BUFFER2_CLASS_ALLOCATOR_POOL_CALLBACKS; \
    (c)->uAllocator.Pool.Tag = 0; /* may be superceded by client */ \
    (c)->uAllocator.Pool.Priority = 0; /* may be superceded by client */ \
    (c)->uAllocator.Pool.Type = 0; /* may be superceded by client */ \
 } while(0)

#ifndef POOL_TAGGING

#define RtlBuffer2InitNtpool() do { \
    RtlBuffer2InitCommonNtpool(c); \
    (c)->uAllocator.Pool.Allocate = ExAllocatePool; \
    (c)->uAllocator.Pool.Free = ExFreePool; \
    (c)->uAllocator.Pool.ExAllocatePoolWithQuota = ExAllocatePoolWithQuota;
 } while(0)

#else

#define RtlBuffer2InitNtpool() do { \
    RtlBuffer2InitCommonNtpool(c); \
    (c)->uAllocator.Pool.AllocateWithTag = ExAllocatePoolWithTag; \
    (c)->uAllocator.Pool.FreeWithTag = ExFreePoolWithTag; \
    (c)->uAllocator.Pool.ExAllocatePoolWithQuotaTag = ExAllocatePoolWithQuotaTag;
 } while(0)

#endif

#define RtlBuffer2InitCrt() do { \
    RtlBuffer2InitCommon(c); \
    (c)->AllocatorType = RTL_BUFFER2_CLASS_ALLOCATOR_WIN32_CRT_CALLBACKS; \
    (c)->uAllocator.Crt.Allocate = malloc; \
    (c)->uAllocator.Crt.Reallocate = realloc; \
    (c)->uAllocator.Crt.Free = free; \
 } while(0)

#define RtlBuffer2InitIMalloc(c, im) do { \
    RtlBuffer2InitCommon(c); \
    (c)->AllocatorType = RTL_BUFFER2_CLASS_ALLOCATOR_IMALLOC; \
    (c)->uAllocator.Malloc = (im); \
 } while(0)

typedef struct _RTL_BUFFER2_CLASS_NTRTL_HEAP {
    PVOID HeapHandle;
    PVOID   (NTAPI * Allocate)(PVOID Heap, ULONG Flags, SIZE_T Size);
    BOOLEAN (NTAPI * Free)(PVOID Heap, ULONG Flags, LPVOID p);
    // realloc can be null, like in kernelmode
    PVOID   (NTAPI * Reallocate)(PVOID Heap, ULONG Flags, PVOID p, SIZE_T Size);
} RTL_BUFFER2_CLASS_NTRTL_HEAP, *PRTL_BUFFER2_CLASS_NTRTL_HEAP;

typedef struct _RTL_BUFFER2_CLASS_NTKERNEL_LESS_TYPED_POOL {
    ULONG   Tag;
    ULONG   Type;
    ULONG   Priority;
    PVOID (NTAPI * Allocate)(IN ULONG PoolType, IN SIZE_T NumberOfBytes);
    PVOID (NTAPI * AllocateWithQuota)(IN ULONG PoolType, IN SIZE_T NumberOfBytes);
    PVOID (NTAPI * AllocateWithTag)(IN ULONG PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag);
    PVOID (NTAPI * AllocateWithQuotaTag)(IN ULONG PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag);
    PVOID (NTAPI * AllocateWithTagPriority)(IN ULONG PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag, IN ULONG Priority);
    VOID  (NTAPI * Free)(PVOID p);
    VOID  (NTAPI * FreeWithTag)(PVOID p, ULONG Tag);
} RTL_BUFFER2_CLASS_NTKERNEL_LESS_TYPED_POOL, *PRTL_BUFFER2_CLASS_NTKERNEL_LESS_TYPED_POOL;

#if defined(_EX_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTOSP_) || defined(_WDM_) || defined(_NTHAL_)
typedef struct _RTL_BUFFER2_CLASS_NTKERNEL_POOL {
    ULONG            Tag;
    POOL_TYPE        Type;
    EX_POOL_PRIORITY Priority;
    //
    // fill in whichever pointers you want, like, whichever isn't a macro..
    //
    PVOID (NTAPI * Allocate)(IN POOL_TYPE PoolType, IN SIZE_T NumberOfBytes);
    PVOID (NTAPI * AllocateWithQuota)(IN POOL_TYPE PoolType, IN SIZE_T NumberOfBytes);
    PVOID (NTAPI * AllocateWithTag)(IN POOL_TYPE PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag);
    PVOID (NTAPI * AllocateWithQuotaTag)(IN POOL_TYPE PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag);
    PVOID (NTAPI * AllocateWithTagPriority)(IN POOL_TYPE PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag, IN EX_POOL_PRIORITY Priority);
    VOID  (NTAPI * Free)(PVOID p);
    VOID  (NTAPI * FreeWithTag)(PVOID p, ULONG Tag);
} RTL_BUFFER2_CLASS_NTKERNEL_POOL, *PRTL_BUFFER2_CLASS_NTKERNEL_POOL;
#else
typedef RTL_BUFFER2_CLASS_NTKERNEL_LESS_TYPED_POOL RTL_BUFFER2_CLASS_NTKERNEL_POOL;
typedef PRTL_BUFFER2_CLASS_NTKERNEL_LESS_TYPED_POOL PRTL_BUFFER2_CLASS_NTKERNEL_POOL;
#endif

typedef struct _RTL_BUFFER2_CLASS_WIN32_HEAP {
    HANDLE HeapHandle;
    LPVOID (WINAPI * Allocate)(HANDLE Heap, DWORD Flags, SIZE_T Size);
    BOOL   (WINAPI * Free)(HANDLE Heap, DWORD Flags, LPVOID p);
    PVOID  (WINAPI * Reallocate)(HANDLE Heap, DWORD Flags, LPVOID p, SIZE_T Size);
} RTL_BUFFER2_CLASS_WIN32_HEAP, *PRTL_BUFFER2_CLASS_WIN32_HEAP;

typedef struct _RTL_BUFFER2_CLASS_CRT {
    void * (__cdecl * Alloc)(size_t);
    void   (__cdecl * Free)(void *);
    void * (__cdecl * Reallocate)(void *, size_t);
} RTL_BUFFER2_CLASS_CRT, *PRTL_BUFFER2_CLASS_CRT;

typedef struct _RTL_BUFFER2_CLASS_NTRTL_STRING_ROUTINES {
    PVOID (NTAPI * Allocate) (SIZE_T NumberOfBytes);
    VOID (NTAPI * Free) (PVOID Buffer);
} RTL_BUFFER2_CLASS_NTRTL_STRING_ROUTINES, *PRTL_BUFFER2_CLASS_NTRTL_STRING_ROUTINES;

#if defined(RTL_BUFFER2_CLASS_DEFAULT_IS_NTRTL_HEAP)
#define RTL_BUFFER2_CLASS_UALLOCATOR_FIRST RTL_BUFFER2_CLASS_NTRTL_HEAP First;
#define RTL_BUFFER2_CLASS_UALLOCATOR_STATIC_INIT { }
..
.. constness falls apart on the point of getting the process heap..
.. should be "design" more around the const non const axis wrt 
.. readonly memory, or only wrt when init calls are made?
..
#endif

typedef union _RTL_BUFFER2_CLASS_UALLOCATOR {
#if defined(RTL_BUFFER2_CLASS_UALLOCATOR_FIRST)
// This is intended to be an aid to static and/or const static initialization.
    RTL_BUFFER2_CLASS_UALLOCATOR_FIRST
#endif
    IMalloc *                               Malloc;
    RTL_BUFFER2_CLASS_NTRTL_HEAP            NtrtlHeap;
    RTL_BUFFER2_CLASS_NTKERNEL_POOL         NtkernelPool;
    RTL_BUFFER2_CLASS_NTKERNEL_LESS_TYPED_POOL  NtkernelLessTypedPool;
    RTL_BUFFER2_CLASS_WIN32_HEAP            Win32Heap;
    RTL_BUFFER2_CLASS_CRT                   Crt;
    RTL_BUFFER2_CLASS_NTRTL_STRING_ROUTINES NtrtlStringRoutines;
    PVOID                                   Pad[8];
} RTL_BUFFER2_CLASS_UALLOCATOR, *PRTL_BUFFER2_CLASS_UALLOCATOR;
typedef const RTL_BUFFER2_CLASS_UALLOCATOR * PCRTL_BUFFER2_CLASS_UALLOCATOR;

#ifndef SORTPP_PASS
C_ASSERT(sizeof(RTL_BUFFER2_CLASS_NTKERNEL_LESS_TYPED_POOL) >= sizeof(RTL_BUFFER2_CLASS_NTKERNEL_POOL));
C_ASSERT(RTL_FIELD_SIZE(RTL_BUFFER2_CLASS_UALLOCATOR, Pad) > sizeof(RTL_BUFFER2_CLASS_UALLOCATOR));
#endif

typedef struct _RTL_BUFFER2_CLASS {
    ULONG     ClassSize;
    ULONG     Flags;
    ULONG     ArrayElementSize;
    ULONG     AllocatorType;
    RTL_BUFFER2_CLASS_UALLOCATOR uAllocator;
    ULONG AllocationSizeType;
    union {
        struct {
            SIZE_T Multiply;
            SIZE_T Divide;
        } Factor;
        struct {
            PVOID Context;
            SIZE_T (__stdcall * GetRecommendedAllocationSize)(
                PVOID  Context,
                SIZE_T CurrentAllocationSize,
                SIZE_T RequiredAllocationSize
                );
        } Callback;
    } uAllocationSize;
    ULONG ErrorType;
    union {
        struct {
            // This could use fleshing out..like PVOID Context, PCSTR File, ULONG Line,
            // SIZE_T Size, etc..
            VOID (__stdcall * OutOfMemory)(VOID);
        } Callbacks;
        struct {
            VOID (NTAPI * RaiseStatus)(NTSTATUS Status);
            NTSTATUS OutOfMemoryStatus;
        } RtlRaise;
        struct {
            VOID (WINAPI * RaiseException)(DWORD ExceptionCode, DWORD ExceptionFlags, DWORD NumberOfArguments, CONST ULONG_PTR * Arguments);
            DWORD OutOfMemoryExceptionCode;
        } Win32Raise;
    } uError;
    /* CONSIDER
    struct {
        DWORD (WINAPI * GetLastErrorCallback)(VOID);
        VOID  (WINAPI * SetLastErrorCallback)(DWORD Error);
    } FreePreserveLastError;
    */
} RTL_BUFFER2_CLASS, *RTL_BUFFER2_CLASS;

#endif


#ifdef __cplusplus
}       // extern "C"
#endif

#if defined (_MSC_VER) && ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
#endif
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\cgen\winbld.c ===
// Copyright Microsoft Corporation
//
// This file is used to verify that winincs.c can be successfully compiled
// by the x86 C compiler.  Do do that, we must undefine __in and __out
#define __in
#define __out
#pragma warning(disable:4049)
#include "winincs.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\cgen\makefile.inc ===
# Copyright (c) Microsoft Corporation
!INCLUDE $(NTMAKEENV)\makefile.plt

FUSION_CGEN_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS) -DSORTPP_PASS -DGUID_DEFINED

!if "$(FUSION_CGEN_DEBUG_THUNKGEN)" == "1"
SORTPP_FLAGS=$(SORTPP_FLAGS) -l
!else
SORTPP_FLAGS=$(SORTPP_FLAGS)
!endif

CXX_COMPILER_NAME=$(CXX_COMPILER_NAME) $(FUSION_CGEN_COMPILER_FLAGS) -noHRESULT -DIN=__in -DOUT=__out

$(O)\winincs2.pp: $(O)\winincs.pp

$(O)\winincs.pp: winincs.cpp cgenhdr.h
    $(CXX_COMPILER_NAME) -DMICROSOFT_INTERNAL=0 /C @<<$(O)\cl.rsp /E /FC winincs.cpp >$(O)\winincs2.pp
$(FUSION_CGEN_COMPILER_FLAGS: =
)
<<NOKEEP
    idlclean.exe $(O)\winincs2.pp $(O)\winincs2.cpp
    $(CXX_COMPILER_NAME) -DMICROSOFT_INTERNAL=0 @<<cl.rsp /E /FC $(O)\winincs2.cpp >$(O)\winincs.pp
$(FUSION_CGEN_COMPILER_FLAGS: =
)
<<NOKEEP

$(O)\winincs2_private.pp: $(O)\winincs_private.pp

$(O)\winincs_private.pp: winincs.cpp cgenhdr.h
    $(CXX_COMPILER_NAME) -DMICROSOFT_INTERNAL=1 /C @<<$(O)\cl.rsp /E /FC winincs.cpp >$(O)\winincs2_private.pp
$(FUSION_CGEN_COMPILER_FLAGS: =
)
<<NOKEEP
    idlclean.exe $(O)\winincs2_private.pp $(O)\winincs2_private.cpp
    $(CXX_COMPILER_NAME) -DMICROSOFT_INTERNAL=1 @<<cl.rsp /E /FC $(O)\winincs2_private.cpp >$(O)\winincs_private.pp
$(FUSION_CGEN_COMPILER_FLAGS: =
)
<<NOKEEP

#
# Use 2 for C++, like for REFGUID, but there are problems with using C++...
#
#$(PPMFILE): $(O)\winincs2.pp
#   fusion_sortpp.exe $(SORTPP_FLAGS) -m$(PPMFILE) $(O)\winincs2.pp
#
$(PPMFILE): $(O)\winincs.pp
   fusion_sortpp.exe $(SORTPP_FLAGS) -m$@ $(O)\winincs.pp

$(PPMFILE_PRIVATE): $(O)\winincs_private.pp
   fusion_sortpp.exe $(SORTPP_FLAGS) -m$@ $(O)\winincs_private.pp

#thunks: (PPMFILE)
#
#cleanfiles:
#    -del $(O)\winincs.pp
#    -del $(O)\winincs2.pp
#    -del $(PPMFILE)
#
#clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\debugexts\actctxstack.cpp ===
#include "windows.h"
#define KDEXT_64BIT
#include "wdbgexts.h"
#include "stdlib.h"
#include "stdio.h"
#include "fusiondbgext.h"

DECLARE_API( actctxstack )
{
    try
    {

    ULONG64 ulTebAddress = 0;
    ULONG ulStackFlags = 0;
    ULONG64 ulTopOfRtlFrameList = 0;
    ULONG ulNextCookie = 0;

    GetTebAddress( &ulTebAddress );

    GetFieldValue( ulTebAddress, "nt!TEB", "ActivationContextStack.Flags", ulStackFlags );
    GetFieldValue( ulTebAddress, "nt!TEB", "ActivationContextStack.ActiveFrame", ulTopOfRtlFrameList );
    GetFieldValue( ulTebAddress, "nt!TEB", "ActivationContextStack.NextCookieSequenceNumber", ulNextCookie );

    dprintf(
        "Current activation stack information in TEB %p:\n"
        "   Flags               : 0x%08lx\n"
        "   ActiveFrame         : 0x%p\n"
        "   NextCookieSequence  : 0x%08lx\n",
        ulTebAddress,
        ulStackFlags,
        ulTopOfRtlFrameList,
        ulNextCookie);

    DumpActCtxStackFullStack( ulTopOfRtlFrameList );

    }
    catch (const COutOfMemory &)
    {
        dprintf("Out of memory\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\debugexts\actctxdump.cpp ===
#include "windows.h"
#define KDEXT_64BIT
#include "dbghelp.h"
#include "wdbgexts.h"
#include "stdlib.h"
#include "stdio.h"
#include "sxstypes.h"
#include "fusiondbgext.h"



DECLARE_API(actctxdata)
{
    try
    {

        ULONG64 ActCtxData = 0;

        if (*args)
        {
            ActCtxData = GetExpression(args);
        }
        else
        {
            if (!GetActiveActivationContextData(&ActCtxData))
            {
                dprintf("Unable to find activation context data for this process at the moment.\n");
                return;
            }
        }

        DumpActCtxData(NULL, ActCtxData, 0xFFFFFFFF);

    }
    catch (const COutOfMemory &)
    {
        dprintf("Out of memory\n");
    }
}

DECLARE_API(actctx)
{
    try
    {

        //
        // This finds the currently-active PACTIVATION_CONTEXT for the thread, or
        // dumps the one indicated as a parameter
        //

        ULONG64 ActiveActCtx = 0;

        if (*args)
        {
            ActiveActCtx = GetExpression(args);
        }
        else
        {
            ULONG64 ulTebAddress;
            ULONG64 ulActiveStackFrame;
            GetTebAddress(&ulTebAddress);

            GetFieldValue(ulTebAddress, "nt!TEB", "ActivationContextStack.ActiveFrame", ulActiveStackFrame);
            if (!ulActiveStackFrame)
            {
                dprintf("There is no current activation context stack frame.  Try !actctxdata instead.\n");
                return;
            }

            GetFieldValue(ulActiveStackFrame, "nt!RTL_ACTIVATION_CONTEXT_STACK_FRAME", "ActivationContext", ActiveActCtx);
            if (!ActiveActCtx)
            {
                dprintf("The activation context stack frame at %p doesn't point to a valid activation context object.\n", ActiveActCtx);
                return;
            }
        }

        DumpActCtx(ActiveActCtx, 0xFFFF);


    }
    catch (const COutOfMemory &)
    {
        dprintf("Out of memory\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\debugexts\dllmain.cpp ===
#include "windows.h"
#include "wdbgexts.h"
#include <ntverp.h>
#include <dbghelp.h>

EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG SavedMajorVersion;
ULONG SavedMinorVersion;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Routine called by debugger after load
//
VOID
CheckVersion(
    VOID
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\cgen\winincs.cpp ===
// Copyright (c) Microsoft Corporation
#include "cgenhdr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\debugexts\dumpers.cpp ===
#include "initguid.h"
#include "windows.h"
#include "sxstypes.h"
#define KDEXT_64BIT
#include "wdbgexts.h"
#include "fusiondbgext.h"
#include "sxsapi.h"
#include "stdlib.h"
#include "stdio.h"
#include "cguid.h"

extern const IID GUID_NULL = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
#define PRINTABLE(_ch) (isprint((_ch)) ? (_ch) : '.')

class CSimpleBaseString
{
protected:
    PWSTR m_pwszBuffer;
    ULONG m_ulBufferSize;
    ULONG m_ulCch;

    CSimpleBaseString( PWSTR buff, ULONG ulBaseCch )
        : m_pwszBuffer(buff), m_ulBufferSize(ulBaseCch), m_ulCch(0)
    {
        m_pwszBuffer[0] = UNICODE_NULL;
    }

 public:

    virtual ~CSimpleBaseString() { };
    virtual void EnsureSize( ULONG ulCch ) = 0;

    void AssignFill( WCHAR ch, ULONG ulCch )
    {
        EnsureSize( ulCch + 1);
        PWSTR pws = m_pwszBuffer;
        while ( ulCch-- )
            *pws++ = ch;
        *pws = UNICODE_NULL;
    }

    void Format( PCWSTR pcwszFormat, ... )
    {
        va_list val;
        va_start(val, pcwszFormat);
        FormatVa(pcwszFormat, val);
        va_end(val);
    }

    void FormatVa( PCWSTR pcwszFormat, va_list val )
    {
        ULONG ulCch = _vscwprintf(pcwszFormat, val);
        EnsureSize(ulCch+1);
        m_ulCch = _vsnwprintf(this->m_pwszBuffer, m_ulBufferSize, pcwszFormat, val);
        m_pwszBuffer[ulCch] = UNICODE_NULL;
    }

    void Clear()
    {
        m_pwszBuffer[0] = UNICODE_NULL;
        m_ulCch = 0;
    }

    void Left( ULONG ulCch )
    {
        if ( ulCch < m_ulCch )
        {
            m_pwszBuffer[ulCch] = UNICODE_NULL;
            m_ulCch = ulCch;
        }
    }

    operator PCWSTR() const { return m_pwszBuffer; }
    operator PWSTR() { return m_pwszBuffer; }

    void Append(const UNICODE_STRING *pus) { Append(pus->Buffer, pus->Length / sizeof(WCHAR)); }
    void Append(const CSimpleBaseString &other) {
        
        if (this != &other)
        {
            Append(other, other.Cch());
        }
        //
        // Duplicating strings?
        //
        else
        {
            const ULONG ulcch = Cch();
            EnsureSize((ulcch * 2) + 1);
            wcsncpy(m_pwszBuffer + Cch(), m_pwszBuffer, ulcch);
            m_pwszBuffer[ulcch * 2] = UNICODE_NULL;
        }
    }

    void Append( PCWSTR pcwsz ) { Append( pcwsz, ::wcslen(pcwsz) ); }
    void Append( PCWSTR pcwsz, ULONG ulCch ) {
        EnsureSize( ulCch + Cch() + 1);
        wcsncat(m_pwszBuffer, pcwsz, ulCch);
        m_pwszBuffer[m_ulCch += ulCch] = UNICODE_NULL;
    }

    void Assign(const CSimpleBaseString &other) {
        if (this != &other)
        {
            Assign(other, other.Cch());
        }
    }
    void Assign(PCWSTR pcwsz) { Assign( pcwsz, ::wcslen(pcwsz) ); }
    void Assign(PCWSTR pcwsz, ULONG ulCch) {
        EnsureSize(ulCch + 1);
        wcsncpy(m_pwszBuffer, pcwsz, ulCch);
        m_pwszBuffer[m_ulCch = ulCch] = UNICODE_NULL;
    }

    ULONG Cch() const { return m_ulCch; }    
};

template<int nChars = 256>
class CSimpleInlineString : public CSimpleBaseString
{
protected:
    WCHAR m_wchInlineBuffer[nChars];

    CSimpleInlineString( const CSimpleInlineString& );
    CSimpleInlineString& operator=( const CSimpleInlineString& );
    
public:
    CSimpleInlineString() : CSimpleBaseString(m_wchInlineBuffer, nChars) {
    }
    
    ~CSimpleInlineString()
    {
        Clear();
    }

    void EnsureSize(ULONG ulCch)
    {
        if ( m_ulBufferSize < ulCch )
        {
            PWSTR pwszNew = new WCHAR[ulCch];
            if (pwszNew == NULL)
                ThrowOutOfMemory();
            wcscpy(pwszNew, m_pwszBuffer);
            if ( m_pwszBuffer != m_wchInlineBuffer )
                delete[] m_pwszBuffer;
            m_pwszBuffer = pwszNew;
            m_ulBufferSize = ulCch;
        }
    }

};

typedef CSimpleInlineString<256> CSimpleString;
typedef CSimpleInlineString<64> CSmallSimpleString;

class CStringPrefixer
{
    CSimpleBaseString &m_str;
    ULONG m_ulStartingCch;
    ULONG m_adds;
    
public:
    CStringPrefixer( CSimpleBaseString &src ) : m_str(src), m_adds(0) {
        m_ulStartingCch = m_str.Cch();
    }
    ~CStringPrefixer() { m_str.Left(m_ulStartingCch); };

    void Add() { m_str.Append(L"   ", 3); m_adds++; }
    void Remove() { if ( m_adds > 0 ) { m_str.Left(m_str.Cch() - 3); m_adds--; } }
};

VOID
FormatThreadingModel( ULONG ulModel, CSimpleBaseString& buff )
{
    #define STRING_AND_LENGTH(x) (x), (NUMBER_OF(x) - 1)
    
    const static struct
    {
        ULONG ThreadingModel;
        WCHAR String[10];
        ULONG Cch;
    } gs_rgTMMap[] =
    {
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT, STRING_AND_LENGTH(L"Apartment") },
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE, STRING_AND_LENGTH(L"Free") },
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE, STRING_AND_LENGTH(L"Single") },
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH, STRING_AND_LENGTH(L"Both") },
        { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL, STRING_AND_LENGTH(L"Neutral") },
    };

    SIZE_T c;
    for ( c = 0; c < NUMBER_OF(gs_rgTMMap); c++ )
    {
        if ( gs_rgTMMap[c].ThreadingModel == ulModel )
            buff.Assign(gs_rgTMMap[c].String, gs_rgTMMap[c].Cch);
    }

    if ( c == NUMBER_OF(gs_rgTMMap) ) buff.Assign(L"");
    
}

VOID
FormatGUID( const GUID& rcGuid, CSimpleBaseString& buff )
{
    buff.Format(
        L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
        rcGuid.Data1, 
        rcGuid.Data2, 
        rcGuid.Data3, 
        rcGuid.Data4[0], 
        rcGuid.Data4[1], 
        rcGuid.Data4[2], 
        rcGuid.Data4[3], 
        rcGuid.Data4[4], 
        rcGuid.Data4[5], 
        rcGuid.Data4[6], 
        rcGuid.Data4[7]);
}

VOID
FormatFileTime( LARGE_INTEGER ft, CSimpleBaseString& buff )
{
}

VOID
PrintBlob( PVOID pvBlob, SIZE_T cbBlob, PCWSTR prefix )
{
    CSimpleString buffTotal, buffSingle;
    DWORD Offset = 0;
    PBYTE pbBlob = (PBYTE)pvBlob;

    while ( cbBlob >= 16 )
    {
        buffSingle.Format(
            L"%ls%08lx: %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x "
            L"(%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c)\n",
            prefix,
            Offset,
            pbBlob[0], pbBlob[1], pbBlob[2], pbBlob[3], pbBlob[4], pbBlob[5], pbBlob[6], pbBlob[7], 
            pbBlob[8], pbBlob[9], pbBlob[0xa], pbBlob[0xb], pbBlob[0xc], pbBlob[0xd], pbBlob[0xe], pbBlob[0xf],
            PRINTABLE(pbBlob[0]), PRINTABLE(pbBlob[1]), PRINTABLE(pbBlob[2]), PRINTABLE(pbBlob[3]), PRINTABLE(pbBlob[4]), PRINTABLE(pbBlob[5]), PRINTABLE(pbBlob[6]), PRINTABLE(pbBlob[7]), 
            PRINTABLE(pbBlob[8]), PRINTABLE(pbBlob[9]), PRINTABLE(pbBlob[0xa]), PRINTABLE(pbBlob[0xb]), PRINTABLE(pbBlob[0xc]), PRINTABLE(pbBlob[0xd]), PRINTABLE(pbBlob[0xe]), PRINTABLE(pbBlob[0xf]));
        buffTotal.Append(buffSingle);
        pbBlob += 16;
        cbBlob -= 16;
        Offset += 16;
    }

    if ( cbBlob != 0 )
    {
        CSmallSimpleString left, right;
        WCHAR rgTemp2[16]; // arbitrary big enough size
        bool First = true;
        ULONG i;
        BYTE *pb = pbBlob;

        // init output buffers
        left.Format(L"%ls%08lx:", prefix, Offset);
        right.Assign(L" (",2);

        for (i=0; i<16; i++)
        {
            if (cbBlob > 0)
            {
                // left
                ::_snwprintf(rgTemp2, NUMBER_OF(rgTemp2), L"%ls%02x", First ? L" " : L"-", pb[i]);
                rgTemp2[NUMBER_OF(rgTemp2) - 1] = L'\0';

                First = false;
                left.Append(rgTemp2);

                // right
                ::_snwprintf(rgTemp2, NUMBER_OF(rgTemp2), L"%c", PRINTABLE(pb[i]));
                rgTemp2[NUMBER_OF(rgTemp2) - 1] = L'\0';

                right.Append(rgTemp2);

                cbBlob--;
            }
            else
            {
                left.Append(L"   ", 3);
            }
        }

        right.Append(L")\n");
        buffTotal.Append(left, left.Cch());
        buffTotal.Append(right, right.Cch());
    }

    dprintf("%ls", static_cast<PCWSTR>(buffTotal));
    
}

void
OutputString( PCWSTR pcwszFormat, ... )
{
    va_list val;
    CSimpleString ssFormatted;

    va_start(val, pcwszFormat);
    ssFormatted.FormatVa(pcwszFormat, val);
    dprintf("%ls", static_cast<PCWSTR>(ssFormatted));
    va_end(val);
}

#define PRINTABLE(_ch) (isprint((_ch)) ? (_ch) : '.')

#if defined(FUSION_WIN) || defined(FUSION_WIN2000)
#define wnsprintfW _snwprintf
#define wnsprintfA _snprintf
#endif

typedef struct _FUSION_FLAG_FORMAT_MAP_ENTRY
{
    DWORD m_dwFlagMask;
    PCWSTR m_pszString;
    ULONG m_cchString;
    PCWSTR m_pszShortString;
    ULONG m_cchShortString;
    DWORD m_dwFlagsToTurnOff; // enables more generic flags first in map hiding more specific combinations later
} FUSION_FLAG_FORMAT_MAP_ENTRY, *PFUSION_FLAG_FORMAT_MAP_ENTRY;
typedef struct _FUSION_FLAG_FORMAT_MAP_ENTRY FUSION_FLAG_FORMAT_MAP_ENTRY, *PFUSION_FLAG_FORMAT_MAP_ENTRY;
typedef const FUSION_FLAG_FORMAT_MAP_ENTRY *PCFUSION_FLAG_FORMAT_MAP_ENTRY;


#define DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(_x, _ss) { _x, L ## #_x, NUMBER_OF(L ## #_x) - 1, L ## _ss, NUMBER_OF(_ss) - 1, _x },


BOOL
FusionpFormatFlags(
    DWORD dwFlagsToFormat,
    bool fUseLongNames,
    SIZE_T cMapEntries,
    PCFUSION_FLAG_FORMAT_MAP_ENTRY prgMapEntries,
    CSimpleBaseString &pwszString
    )
{
    SIZE_T i;
    BOOL fSuccess = FALSE;

    pwszString.Clear();
    
    for (i=0; i<cMapEntries; i++)
    {
        // What the heck does a flag mask of 0 mean?
        if ((prgMapEntries[i].m_dwFlagMask != 0) &&
            ((dwFlagsToFormat & prgMapEntries[i].m_dwFlagMask) == prgMapEntries[i].m_dwFlagMask))
        {
            // we have a winner...
            if ( pwszString.Cch() )
            {
                if (fUseLongNames) {
                    pwszString.Append(L" | ", 3);
                } else {
                    pwszString.Append(L", ", 2);
                }
            }

            if (fUseLongNames) {
                pwszString.Append(prgMapEntries[i].m_pszString, prgMapEntries[i].m_cchString);
            } else {
                pwszString.Append(prgMapEntries[i].m_pszShortString, prgMapEntries[i].m_cchShortString);
            }

            if (prgMapEntries[i].m_dwFlagsToTurnOff != 0)
                dwFlagsToFormat &= ~(prgMapEntries[i].m_dwFlagsToTurnOff);
            else
                dwFlagsToFormat &= ~(prgMapEntries[i].m_dwFlagMask);
        }
    }

    if (dwFlagsToFormat != 0)
    {
        CSimpleInlineString<20> Formatter;
        Formatter.Format(L"0x%08lx", dwFlagsToFormat);
        if ( pwszString.Cch() == 0 ) 
            pwszString.Append(L", ", 2);
        pwszString.Append(Formatter);
    }

    // if we didn't write anything; at least say that.
    if ( pwszString.Cch() == 0 )
    {
        pwszString.Assign(L"<none>", 6);
    }

    fSuccess = TRUE;
    return fSuccess;
}

/*
Declaration of dumpers are moved from the relatively public sxsp.h
to here to contain their use.

These functions should be preceded by FusionpDbgWouldPrintAtFilterLevel calls
and surrounded by __try/__except(EXCEPTION_EXECUTE_HANDLER)

These function can consume a lot of stack, and time, when their output
ultimately doesn't go anywhere, and they overflow the small commited stack
in csrss under stress.
*/

VOID
DbgExtPrintActivationContextDataTocEntry(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataTocSections(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    const GUID *ExtensionGuid,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataTocSection(
    bool fFull,
    PVOID Section,
    SIZE_T Length,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataExtendedTocHeader(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataExtendedTocEntry(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataExtendedTocSections(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintClrSurrogateTable(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );



VOID
DbgExtPrintActivationContextDataExtendedTocEntrySections(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextStringSection(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextGuidSection(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextBinarySection(
    bool fFull,
    PVOID Data,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintAssemblyInformation(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintDllRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintWindowClassRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintComServerRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintComProgIdRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintComInterfaceRedirection(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    );

VOID
DbgExtPrintActivationContextDataAssemblyRoster(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
DbgExtPrintActivationContextDataTocHeader(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    );

VOID
pDbgPrintActivationContextData(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Data,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);

    if (fFull)
    {
        CSmallSimpleString ssOutput;

        ssOutput.Format(
            L"%lsActivation Context Data %p\n"
            L"%ls   Magic = 0x%08lx (%lu)\n"
            L"%ls   HeaderSize = %d (0x%lx)\n"
            L"%ls   FormatVersion = %d\n",
            PLP, Data,
            PLP, Data->Magic, Data->Magic,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->FormatVersion);
        OutputString(L"%ls", static_cast<PCWSTR>(ssOutput));

        ssOutput.Format(
            L"%ls   TotalSize = %d (0x%lx)\n"
            L"%ls   DefaultTocOffset = %d (0x%lx) (-> %p)\n"
            L"%ls   ExtendedTocOffset = %d (0x%lx) (-> %p)\n",
            PLP, Data->TotalSize, Data->TotalSize,
            PLP, Data->DefaultTocOffset, Data->DefaultTocOffset, (Data->DefaultTocOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            PLP, Data->ExtendedTocOffset, Data->ExtendedTocOffset, (Data->ExtendedTocOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->ExtendedTocOffset));
        OutputString(L"%ls", static_cast<PCWSTR>(ssOutput));

        ssOutput.Format(
            L"%ls   AssemblyRosterOffset = %d (0x%lx) (-> %p)\n",
            PLP, Data->AssemblyRosterOffset, Data->AssemblyRosterOffset, (Data->AssemblyRosterOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset));
        OutputString(L"%ls", static_cast<PCWSTR>(ssOutput));
        
    }
    else
    {
        // !fFull
        OutputString(
            L"%lsActivation Context Data %p (brief output)\n",
            PLP, Data);
    }

    Prefixer.Add();

    if (Data->AssemblyRosterOffset != 0)
        ::DbgExtPrintActivationContextDataAssemblyRoster(
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset),
            rbuffPLP);

    if (Data->DefaultTocOffset != 0)
        ::DbgExtPrintActivationContextDataTocHeader(
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            rbuffPLP);

    if (Data->ExtendedTocOffset != 0)
        ::DbgExtPrintActivationContextDataExtendedTocHeader(
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((ULONG_PTR) Data) + Data->ExtendedTocOffset),
            rbuffPLP);

    // That's it for the header information.  Now start dumping the sections...
    if (Data->DefaultTocOffset != 0)
        ::DbgExtPrintActivationContextDataTocSections(
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            NULL,
            rbuffPLP);

    if (Data->ExtendedTocOffset != 0)
        ::DbgExtPrintActivationContextDataExtendedTocSections(
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((ULONG_PTR) Data) + Data->ExtendedTocOffset),
            rbuffPLP);
}

VOID
DbgExtPrintActivationContextData(
    BOOL fFull,
    PCACTIVATION_CONTEXT_DATA Data,
    PCWSTR rbuffPLP
    )
{
    CSimpleInlineString<256> rbuffPrefix;
    rbuffPrefix.Assign(rbuffPLP);
    pDbgPrintActivationContextData( !!fFull, Data, rbuffPrefix);
}

VOID
DbgExtPrintActivationContextDataAssemblyRoster(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER Data,
    CSimpleBaseString &rbuffPLP
    )
{
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY Entry;
    CSmallSimpleString buffFlags;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemblyInformation = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgAssemblyRosterEntryFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID, "Invalid")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT, "Root")
    };

    PCWSTR PLP = rbuffPLP;

    if (fFull)
        OutputString(
            L"%lsACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER %p\n"
            L"%ls   HeaderSize = %lu (0x%lx)\n"
            L"%ls   EntryCount = %lu (0x%lx)\n"
            L"%ls   FirstEntryOffset = %ld (0x%lx)\n",
            PLP, Data,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->EntryCount, Data->EntryCount,
            PLP, Data->FirstEntryOffset, Data->FirstEntryOffset);
    else
        OutputString(
            L"%lsAssembly Roster (%lu assemblies)\n"
            L"%lsIndex | Assembly Name (Flags)\n",
            PLP, Data->EntryCount - 1,
            PLP);

    for (i=0; i<Data->EntryCount; i++)
    {
        Entry = ((PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset)) + i;

        UNICODE_STRING s;

        if (Entry->AssemblyNameOffset != 0)
        {
            s.Length = (USHORT) Entry->AssemblyNameLength;
            s.MaximumLength = s.Length;
            s.Buffer = (PWSTR) (((ULONG_PTR) Base) + Entry->AssemblyNameOffset);
        }
        else
        {
            s.Length = 0;
            s.MaximumLength = 0;
            s.Buffer = NULL;
        }

        ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgAssemblyRosterEntryFlags), s_rgAssemblyRosterEntryFlags, buffFlags);

        if (Entry->AssemblyInformationOffset != NULL)
            AssemblyInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) (((ULONG_PTR) Base) + Entry->AssemblyInformationOffset);
        else
            AssemblyInformation = NULL;

        if (fFull)
        {
            OutputString(
                L"%ls   ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY %p [#%d]\n"
                L"%ls      Flags = 0x%08lx (%ls)\n"
                L"%ls      PseudoKey = %lu\n",
                PLP, Entry, i,
                PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags),
                PLP, Entry->PseudoKey);

            OutputString(
                L"%ls      AssemblyNameOffset = %lu (0x%lx) \"%wZ\"\n"
                L"%ls      AssemblyNameLength = %lu (0x%lx) \n"
                L"%ls      AssemblyInformationOffset = %lu (0x%lx) (-> %p)\n"
                L"%ls      AssemblyInformationLength = %lu (0x%lx)\n",
                PLP, Entry->AssemblyNameOffset, Entry->AssemblyNameOffset, &s,
                PLP, Entry->AssemblyNameLength, Entry->AssemblyNameLength,
                PLP, Entry->AssemblyInformationOffset, Entry->AssemblyInformationOffset, AssemblyInformation,
                PLP, Entry->AssemblyInformationLength, Entry->AssemblyInformationLength);
        }
        else
        {
            if (i != 0)
                OutputString(
                    L"%ls%5lu | %wZ (%ls)\n",
                    PLP, i, &s, static_cast<PCWSTR>(buffFlags));
        }
    }
}

VOID
DbgExtPrintActivationContextDataTocHeader(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallSimpleString buffFlags;
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY FirstEntry = NULL;

    if (PLP == NULL)
        PLP = L"";

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE, "Dense")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER, "Inorder")
    };

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgFlags), s_rgFlags, buffFlags);

    if (Data->FirstEntryOffset != 0)
        FirstEntry = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);

    if (fFull)
    {
        OutputString(
            L"%lsACTIVATION_CONTEXT_DATA_TOC_HEADER %p\n"
            L"%ls   HeaderSize = %d (0x%lx)\n"
            L"%ls   EntryCount = %d\n"
            L"%ls   FirstEntryOffset = %d (0x%lx) (-> %p)\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Data,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->EntryCount,
            PLP, Data->FirstEntryOffset, Data->FirstEntryOffset, FirstEntry,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));
    }

    if (FirstEntry != NULL)
    {
        CStringPrefixer prefixer(rbuffPLP);

        prefixer.Add();
        for (i=0; i<Data->EntryCount; i++)
            ::DbgExtPrintActivationContextDataTocEntry( fFull, Base, &FirstEntry[i], rbuffPLP);
    }

}

VOID
DbgExtPrintActivationContextDataTocSections(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    const GUID *ExtensionGuid,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);

    if (Data->FirstEntryOffset != 0)
    {
        PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entries = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
        ULONG i;

        for (i=0; i<Data->EntryCount; i++)
        {
            if (Entries[i].Offset != 0)
            {
                PVOID Section = (PVOID) (((ULONG_PTR) Base) + Entries[i].Offset);
                CSmallSimpleString buffSectionId;
                PCSTR pszSectionName = "<untranslatable>";

                if (ExtensionGuid != NULL)
                {
                    CSimpleInlineString<20> Formatter;

                    FormatGUID(*ExtensionGuid, buffSectionId);
                    buffSectionId.Append(L".", 1);
                    Formatter.Format(L"%u", Entries[i].Id);
                    buffSectionId.Append(Formatter);
                }
                else
                {
                    CSimpleString Formatter;

#define MAP_ENTRY(_x, _y) case _x: if (fFull) pszSectionName = #_x; else pszSectionName = _y; break;

                    switch (Entries[i].Id)
                    {
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "Assembly Information")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "DLL Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "Window Class Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION, "COM Server Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION, "COM Interface Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION, "COM Type Library Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, "COM ProgId Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE, "Win32 Global Object Name Redirection")
                    }

                    if (pszSectionName != NULL)
                        Formatter.Format(L"%u (%ls)", Entries[i].Id, pszSectionName);
                    else
                        Formatter.Format(L"%u", Entries[i].Id);

                    buffSectionId.Append(Formatter);
                }

                ::DbgExtPrintActivationContextDataTocSection(
                    fFull,
                    Section,
                    Entries[i].Length,
                    ExtensionGuid,
                    Entries[i].Id,
                    pszSectionName,
                    rbuffPLP);
            }
        }
    }
}

VOID
DbgExtPrintActivationContextDataTocSection(
    bool fFull,
    PVOID Section,
    SIZE_T Length,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    )
{
    if ((Length > sizeof(ULONG)) && (*((ULONG *) Section) == ACTIVATION_CONTEXT_STRING_SECTION_MAGIC))
        ::DbgExtPrintActivationContextStringSection(
            fFull,
            (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) Section,
            ExtensionGuid,
            SectionId,
            SectionName,
            rbuffPLP);
    else if ((Length > sizeof(ULONG)) && (*((ULONG *) Section) == ACTIVATION_CONTEXT_GUID_SECTION_MAGIC))
    {
        ::DbgExtPrintActivationContextGuidSection(
            fFull,
            (PCACTIVATION_CONTEXT_GUID_SECTION_HEADER) Section,
            ExtensionGuid,
            SectionId,
            SectionName,
            rbuffPLP);
    }
    else if (SectionId != 0)
    {
        ::DbgExtPrintActivationContextBinarySection(
            fFull,
            Section,
            Length,
            rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextDataTocEntry(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    )
{
    PVOID SectionData = NULL;
    PCSTR pszFormat = "<untranslated format>";
    PCWSTR PLP = rbuffPLP;

    if (!fFull)
        return;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->Offset != 0)
        SectionData = (PVOID) (((ULONG_PTR) Base) + Entry->Offset);

#define MAP_FORMAT(_x, _sn) \
case _x: \
    if (fFull) \
        pszFormat = #_x; \
    else \
        pszFormat = _sn; \
    break;

    switch (Entry->Format)
    {
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN, "user defined");
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE, "string table");
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE, "guid table");
    }

    if (fFull)
    {
        OutputString(
            L"%lsACTIVATION_CONTEXT_DATA_TOC_ENTRY %p\n"
            L"%ls   Id = %u\n"
            L"%ls   Offset = %lu (0x%lx) (-> %p)\n"
            L"%ls   Length = %lu (0x%lx)\n"
            L"%ls   Format = %lu (%s)\n",
            PLP, Entry,
            PLP, Entry->Id,
            PLP, Entry->Offset, Entry->Offset, SectionData,
            PLP, Entry->Length, Entry->Length,
            PLP, Entry->Format, pszFormat);
    }
    else
    {
        PCSTR pszName = "<No name associated with id>";

        switch (Entry->Id)
        {
        case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION: pszName = "Assembly Information"; break;
        case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION: pszName = "Dll Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION: pszName = "Window Class Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION: pszName = "COM Server Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION: pszName = "COM Interface Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION: pszName = "COM Type Library Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION: pszName = "COM ProgId Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE: pszName = "Win32 Global Object Name Redirection"; break;
        case ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES: pszName = "CLR Surrogate Redirection"; break;
        }

        OutputString(
            L"%ls%7lu | %s (%s)\n",
            PLP, Entry->Id, pszName, pszFormat);
    }

}

VOID
DbgExtPrintActivationContextDataExtendedTocHeader(
    
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry = NULL;
    ULONG i;

    if (PLP == NULL)
        PLP = L"";

    if (Data->FirstEntryOffset != NULL)
    {
        Prefixer.Add();
        Entry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
    }

    PLP = rbuffPLP;
    OutputString(
        L"%lsACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER %p\n"
        L"%ls   HeaderSize = %d\n"
        L"%ls   EntryCount = %d\n"
        L"%ls   FirstEntryOffset = %d (->%p)\n"
        L"%ls   Flags = 0x%08lx\n",
        PLP, Data,
        PLP, Data->HeaderSize,
        PLP, Data->EntryCount,
        PLP, Data->FirstEntryOffset, Entry,
        PLP, Data->Flags);


    if (Entry != NULL)
    {
        for (i=0; i<Data->EntryCount; i++)
            ::DbgExtPrintActivationContextDataExtendedTocEntry(
                fFull,
                Base,
                &Entry[i],
                rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextDataExtendedTocEntry(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);
    CSmallSimpleString buffFormattedGUID;
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = NULL;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->TocOffset != 0)
    {
        Prefixer.Add();
        Toc = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Base) + Entry->TocOffset);
        PLP = rbuffPLP;
    }

    FormatGUID(Entry->ExtensionGuid, buffFormattedGUID);

    OutputString(
        L"%lsACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY %p\n"
        L"%ls   ExtensionGuid = %ls\n"
        L"%ls   TocOffset = %d (-> %p)\n"
        L"%ls   Length = %d\n",
        PLP, Entry,
        PLP, static_cast<PCWSTR>(buffFormattedGUID),
        PLP, Entry->Length);

    if (Toc != NULL)
        ::DbgExtPrintActivationContextDataTocHeader( fFull, Base, Toc, rbuffPLP);
}

VOID
DbgExtPrintActivationContextDataExtendedTocSections(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer prefixer(rbuffPLP);
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry = NULL;
    ULONG i;

    if (PLP == NULL)
        PLP = L"";

    if (Data->FirstEntryOffset != NULL)
    {
        prefixer.Add();
        Entry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
        PLP = rbuffPLP;
    }

    if (Entry != NULL)
    {
        for (i=0; i<Data->EntryCount; i++)
            ::DbgExtPrintActivationContextDataExtendedTocEntrySections(
                fFull,
                Base,
                &Entry[i],
                rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextDataExtendedTocEntrySections(
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = NULL;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->TocOffset != 0)
    {
        Prefixer.Add();
        PLP = rbuffPLP;
        Toc = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Base) + Entry->TocOffset);
    }

    if (Toc != NULL)
    {
        CSmallSimpleString buffFormattedGUID;

        FormatGUID(Entry->ExtensionGuid, buffFormattedGUID);
        OutputString(
            L"%lsSections for extension GUID %ls (Extended TOC entry %p)\n",
            PLP, static_cast<PCWSTR>(buffFormattedGUID), Entry);

        ::DbgExtPrintActivationContextDataTocSections( fFull, Base, Toc, &Entry->ExtensionGuid, rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextBinarySection(
    bool fFull,
    PVOID Data,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);

    if (PLP == NULL)
        PLP = L"";

    OutputString(
        L"%lsBinary section %p (%d bytes)\n",
        PLP, Data, Length);

    if (Length != 0)
    {
        Prefixer.Add();
        PrintBlob( Data, Length, rbuffPLP);
    }
}

VOID
DbgExtPrintActivationContextStringSection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CStringPrefixer Prefixer(rbuffPLP);
    CSmallSimpleString buffBriefOutput;
    CSmallSimpleString buffFlags;
    ULONG cchBriefOutputKey = 3;

    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE SearchStructure = NULL;
    PVOID UserData = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgStringSectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE, "Case Insensitive")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER, "In PseudoKey Order")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Data->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY) (((ULONG_PTR) Data) + Data->ElementListOffset);

    if (Data->SearchStructureOffset != 0)
        SearchStructure = (PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE) (((ULONG_PTR) Data) + Data->SearchStructureOffset);

    if (Data->UserDataOffset != 0)
        UserData = (PVOID) (((ULONG_PTR) Data) + Data->UserDataOffset);

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgStringSectionFlags), s_rgStringSectionFlags, buffFlags);

    if (fFull)
    {
        OutputString(
            L"%lsACTIVATION_CONTEXT_STRING_SECTION_HEADER %p\n"
            L"%ls   Magic = 0x%08lx\n"
            L"%ls   HeaderSize = %lu (0x%lx)\n"
            L"%ls   FormatVersion = %lu\n"
            L"%ls   DataFormatVersion = %u\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Data,
            PLP, Data->Magic,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->FormatVersion,
            PLP, Data->DataFormatVersion,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));

        OutputString(
            L"%ls   ElementCount = %lu\n"
            L"%ls   ElementListOffset = %lu (0x%lx) (-> %p)\n"
            L"%ls   HashAlgorithm = %lu\n"
            L"%ls   SearchStructureOffset = %lu (0x%lx) (-> %p)\n"
            L"%ls   UserDataOffset = %lu (0x%lx) (-> %p)\n"
            L"%ls   UserDataSize = %lu (0x%lx)\n",
            PLP, Data->ElementCount,
            PLP, Data->ElementListOffset, Data->ElementListOffset, ElementList,
            PLP, Data->HashAlgorithm,
            PLP, Data->SearchStructureOffset, Data->SearchStructureOffset, SearchStructure,
            PLP, Data->UserDataOffset, Data->UserDataOffset, UserData,
            PLP, Data->UserDataSize, Data->UserDataSize);

        if (UserData != NULL)
        {
            OutputString(
                L"%ls   User data at %p (%d bytes)\n",
                PLP, UserData, Data->UserDataSize);
            Prefixer.Add();
            PLP = rbuffPLP;
            PrintBlob( UserData, Data->UserDataSize, rbuffPLP);
        }
    }
    else
    {
        // let's figure out the brief output key size
        cchBriefOutputKey = 3;

        if (ElementList != NULL)
        {
            ULONG i;

            for (i=0; i<Data->ElementCount; i++)
            {
                ULONG cch = ElementList[i].KeyLength / sizeof(WCHAR);

                if (cch > cchBriefOutputKey)
                    cchBriefOutputKey = cch;
            }
        }

        if (cchBriefOutputKey > 64)
            cchBriefOutputKey = 64;

        // Abuse the brief output buffer temporarily...
        buffBriefOutput.Assign(L"Key................................................................", // 64 dots
            cchBriefOutputKey);

        OutputString(
            L"%ls%s string section (%lu entr%s; Flags: %ls)\n"
            L"%ls   %ls | Value\n",
            PLP, SectionName, Data->ElementCount, Data->ElementCount == 1 ? "y" : "ies", static_cast<PCWSTR>(buffFlags),
            PLP, static_cast<PCWSTR>(buffBriefOutput));
    }

    if (fFull && (SearchStructure != NULL))
    {
        PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET BucketTable = NULL;

        if (SearchStructure->BucketTableOffset != 0)
            BucketTable = (PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET) (((ULONG_PTR) Data) + SearchStructure->BucketTableOffset);

        OutputString(
            L"%ls   ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE %p\n"
            L"%ls      BucketTableEntryCount = %u\n"
            L"%ls      BucketTableOffset = %d (-> %p)\n",
            PLP, SearchStructure,
            PLP, SearchStructure->BucketTableEntryCount,
            PLP, SearchStructure->BucketTableOffset, BucketTable);

        if (BucketTable != NULL)
        {
            ULONG i;

            for (i=0; i<SearchStructure->BucketTableEntryCount; i++)
            {
                PLONG Entries = NULL;

                if (BucketTable[i].ChainOffset != 0)
                    Entries = (PLONG) (((ULONG_PTR) Data) + BucketTable[i].ChainOffset);

                OutputString(
                    
                    L"%ls      ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET %p\n"
                    L"%ls         ChainCount = %u\n"
                    L"%ls         ChainOffset = %d (-> %p)\n",
                    PLP, &BucketTable[i],
                    PLP, BucketTable[i].ChainCount,
                    PLP, BucketTable[i].ChainOffset, Entries);

                if (Entries != NULL)
                {
                    ULONG j;

                    for (j=0; j<BucketTable[i].ChainCount; j++)
                    {
                        PVOID Entry = NULL;

                        if (Entries[j] != 0)
                            Entry = (PVOID) (((ULONG_PTR) Data) + Entries[j]);

                        OutputString(
                            
                            L"%ls         Chain[%d] = %d (-> %p)\n",
                            PLP, j, Entries[j], Entry);
                    }
                }
            }
        }
    }

    if (ElementList != NULL)
    {
        ULONG i;

        for (i=0; i<Data->ElementCount; i++)
        {
            UNICODE_STRING s;
            PVOID EntryData = NULL;

            s.Length = static_cast<USHORT>(ElementList[i].KeyLength);
            s.MaximumLength = s.Length;
            s.Buffer = (PWSTR) (((ULONG_PTR) Data) + ElementList[i].KeyOffset);

            if (ElementList[i].Offset != 0)
                EntryData = (PVOID) (((ULONG_PTR) Data) + ElementList[i].Offset);

            if (fFull)
            {
                OutputString(
                    
                    L"%ls   ACTIVATION_CONTEXT_STRING_SECTION_ENTRY #%d - %p\n"
                    L"%ls      AssemblyRosterIndex = %u\n"
                    L"%ls      PseudoKey = %u\n",
                    PLP, i, &ElementList[i],
                    PLP, ElementList[i].AssemblyRosterIndex,
                    PLP, ElementList[i].PseudoKey);

                OutputString(
                    
                    L"%ls      String = \"%wZ\"\n"
                    L"%ls      Offset = %d (-> %p)\n"
                    L"%ls      Length = %u\n",
                    PLP, &s,
                    PLP, ElementList[i].Offset, EntryData,
                    PLP, ElementList[i].Length);
            }
            else
            {
                // Abuse the flags buffer so we can truncate the name as necessary...
                ULONG cchKey = s.Length / sizeof(WCHAR);
                PCWSTR pszKey = s.Buffer;

                if (cchKey > cchBriefOutputKey)
                {
                    pszKey += (cchKey - cchBriefOutputKey);
                    cchKey = cchBriefOutputKey;
                }

                buffFlags.AssignFill(L' ', (cchBriefOutputKey - cchKey));
                buffFlags.Append(pszKey, cchKey);

                buffBriefOutput.EnsureSize(rbuffPLP.Cch() + 3 + cchBriefOutputKey + 4);

                buffBriefOutput.Format(
                    L"%s   %s | ",
                    PLP, static_cast<PCWSTR>(buffFlags));
            }

            if (EntryData != NULL)
            {

                if (ExtensionGuid == NULL)
                {
                    CStringPrefixer Prefixer2(rbuffPLP);
                    Prefixer2.Add();
                    Prefixer2.Add();

                    switch (SectionId)
                    {
                    default:
                        if (fFull)
                            PrintBlob( EntryData, ElementList[i].Length, rbuffPLP);
                        else
                            buffBriefOutput.Append(
                                L"<untranslatable value>",
                                22);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION:
                        ::DbgExtPrintAssemblyInformation( fFull, Data, (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION:
                        ::DbgExtPrintDllRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION:
                        ::DbgExtPrintWindowClassRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION:
                        ::DbgExtPrintComProgIdRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;
                    }

                }
            }

            if (!fFull)
                OutputString( L"%ls\n", static_cast<PCWSTR>(buffBriefOutput));
        }
    }
}

VOID
DbgExtPrintActivationContextGuidSection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CSimpleBaseString &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    ULONG cchPLP = rbuffPLP.Cch();
    CSmallSimpleString buffFlags;
    CSmallSimpleString buffBriefOutput;

    PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE SearchStructure = NULL;
    PVOID UserData = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgGuidSectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER, "Inorder")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Data->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY) (((ULONG_PTR) Data) + Data->ElementListOffset);

    if (Data->SearchStructureOffset != 0)
        SearchStructure = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE) (((ULONG_PTR) Data) + Data->SearchStructureOffset);

    if (Data->UserDataOffset != 0)
        UserData = (PVOID) (((ULONG_PTR) Data) + Data->UserDataOffset);

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgGuidSectionFlags), s_rgGuidSectionFlags, buffFlags);

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_GUID_SECTION_HEADER %p\n"
            L"%ls   Magic = 0x%08lx\n"
            L"%ls   HeaderSize = %u\n"
            L"%ls   FormatVersion = %u\n"
            L"%ls   DataFormatVersion = %u\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Data,
            PLP, Data->Magic,
            PLP, Data->HeaderSize,
            PLP, Data->FormatVersion,
            PLP, Data->DataFormatVersion,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));

        OutputString(
            
            L"%ls   ElementCount = %u\n"
            L"%ls   ElementListOffset = %d (-> %p)\n"
            L"%ls   SearchStructureOffset = %d (-> %p)\n"
            L"%ls   UserDataOffset = %d (-> %p)\n"
            L"%ls   UserDataSize = %u\n",
            PLP, Data->ElementCount,
            PLP, Data->ElementListOffset, ElementList,
            PLP, Data->SearchStructureOffset, SearchStructure,
            PLP, Data->UserDataOffset, UserData,
            PLP, Data->UserDataSize);

        if (UserData != NULL)
        {
            CStringPrefixer Prefixer(rbuffPLP);

            OutputString(
                L"%ls   User data at %p (%d bytes)\n",
                PLP, UserData, Data->UserDataSize);

            Prefixer.Add();
            PrintBlob( UserData, Data->UserDataSize, rbuffPLP);
            PLP = rbuffPLP;
        }
    }
    else
    {
        OutputString(
            
            L"%ls%s guid section (%lu entr%s; Flags: %ls)\n"
            L"%ls   Key................................... | Value\n",
            PLP, SectionName, Data->ElementCount, Data->ElementCount == 1 ? "y" : "ies", static_cast<PCWSTR>(buffFlags),
            PLP);
    }

    if (fFull && (SearchStructure != NULL))
    {
        PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET BucketTable = NULL;

        if (SearchStructure->BucketTableOffset != 0)
            BucketTable = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET) (((ULONG_PTR) Data) + SearchStructure->BucketTableOffset);

        PLP = rbuffPLP;
        OutputString(
            
            L"%ls   ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE %p\n"
            L"%ls      BucketTableEntryCount = %u\n"
            L"%ls      BucketTableOffset = %d (-> %p)\n",
            PLP, SearchStructure,
            PLP, SearchStructure->BucketTableEntryCount,
            PLP, SearchStructure->BucketTableOffset, BucketTable);

        if (BucketTable != NULL)
        {
            ULONG i;

            for (i=0; i<SearchStructure->BucketTableEntryCount; i++)
            {
                PLONG Entries = NULL;

                if (BucketTable[i].ChainOffset != 0)
                    Entries = (PLONG) (((ULONG_PTR) Data) + BucketTable[i].ChainOffset);

                OutputString(
                    
                    L"%ls      ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET %p\n"
                    L"%ls         ChainCount = %u\n"
                    L"%ls         ChainOffset = %d (-> %p)\n",
                    PLP, &BucketTable[i],
                    PLP, BucketTable[i].ChainCount,
                    PLP, BucketTable[i].ChainOffset, Entries);

                if (Entries != NULL)
                {
                    ULONG j;

                    for (j=0; j<BucketTable[i].ChainCount; j++)
                    {
                        PVOID Entry = NULL;

                        if (Entries[j] != 0)
                            Entry = (PVOID) (((ULONG_PTR) Data) + Entries[j]);

                        OutputString(
                            
                            L"%ls         Chain[%d] = %d (-> %p)\n",
                            PLP, j, Entries[j], Entry);
                    }
                }
            }
        }
    }

    if (ElementList != NULL)
    {
        ULONG i;
        CSmallSimpleString buffFormattedGuid;

        for (i=0; i<Data->ElementCount; i++)
        {
            PVOID EntryData = NULL;

            FormatGUID(ElementList[i].Guid, buffFormattedGuid);

            if (ElementList[i].Offset != 0)
                EntryData = (PVOID) (((ULONG_PTR) Data) + ElementList[i].Offset);

            if (fFull)
            {
                OutputString(
                    
                    L"%ls   ACTIVATION_CONTEXT_GUID_SECTION_ENTRY #%d - %p\n"
                    L"%ls      Guid = %ls\n"
                    L"%ls      AssemblyRosterIndex = %u\n",
                    PLP, i, &ElementList[i],
                    PLP, static_cast<PCWSTR>(buffFormattedGuid),
                    PLP, ElementList[i].AssemblyRosterIndex);

                OutputString(
                    
                    L"%ls      Offset = %d (-> %p)\n"
                    L"%ls      Length = %u\n",
                    PLP, ElementList[i].Offset, EntryData,
                    PLP, ElementList[i].Length);
            }
            else
            {
                buffBriefOutput.EnsureSize(cchPLP + 3 + 38 + 4);
                buffBriefOutput.Format(L"%s   %38s | ", PLP, static_cast<PCWSTR>(buffFormattedGuid));
            }

            if (EntryData != NULL)
            {
                if (ExtensionGuid == NULL)
                {
                    CStringPrefixer prefixer(rbuffPLP);
                    prefixer.Add();
                    prefixer.Add();

                    switch (SectionId)
                    {
                    default:
                        PrintBlob( EntryData, ElementList[i].Length, rbuffPLP);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION:
                        ::DbgExtPrintComServerRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION:
                        ::DbgExtPrintComInterfaceRedirection( fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES:
                        ::DbgExtPrintClrSurrogateTable(fFull, Data, (PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE)EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;
                    }

                }
            }

            if (!fFull)
                OutputString( L"%ls\n", static_cast<PCWSTR>(buffBriefOutput));
        }
    }
}

VOID
DbgExtPrintAssemblyInformation(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    UNICODE_STRING s2, s3, s5, strIdentity;
    CSmallSimpleString buffManifestLastWriteTime;
    CSmallSimpleString buffPolicyLastWriteTime;
    CSmallSimpleString buffFlags;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgAssemblyInformationFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY, "Root Assembly")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED, "Policy Applied")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED, "Assembly Policy Applied")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED, "Root Policy Applied")
    };

    if (PLP == NULL)
        PLP = L"";

#define GET_STRING(_var, _elem) \
    if (Entry-> _elem ## Length != 0) \
    { \
        (_var).Length = (_var).MaximumLength = static_cast<USHORT>(Entry-> _elem ## Length); \
        (_var).Buffer = reinterpret_cast<PWSTR>(((LONG_PTR) Header) + Entry-> _elem ## Offset); \
    } \
    else \
    { \
        (_var).Length = (_var).MaximumLength = 0; \
        (_var).Buffer = NULL; \
        }

    GET_STRING(s2, ManifestPath);
    GET_STRING(s3, PolicyPath);
    GET_STRING(s5, AssemblyDirectoryName);

#undef GET_STRING

    // prepare data for print

    FormatFileTime(Entry->ManifestLastWriteTime, buffManifestLastWriteTime);
    FormatFileTime(Entry->PolicyLastWriteTime, buffPolicyLastWriteTime);

    FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgAssemblyInformationFlags), s_rgAssemblyInformationFlags, buffFlags);

    if (Entry->EncodedAssemblyIdentityOffset != 0)
    {
        strIdentity.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->EncodedAssemblyIdentityOffset);
        strIdentity.Length = static_cast<USHORT>(Entry->EncodedAssemblyIdentityLength);
        strIdentity.MaximumLength = static_cast<USHORT>(Entry->EncodedAssemblyIdentityLength);
    }
    else
    {
        strIdentity.Buffer = NULL;
        strIdentity.Length = 0;
        strIdentity.MaximumLength = 0;
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION %p\n"
            L"%ls   Size = %lu\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags));

        OutputString(
            
            L"%ls   EncodedIdentity = %wZ\n",
            PLP, &strIdentity);

        OutputString(
            
            L"%ls   ManifestPathType = %lu\n"
            L"%ls   ManifestPath = \"%wZ\"\n",
            PLP, Entry->ManifestPathType,
            PLP, &s2);

        OutputString(
            
            L"%ls   ManifestLastWriteTime = %ls\n",
            PLP, static_cast<PCWSTR>(buffManifestLastWriteTime));

        OutputString(
            
            L"%ls   PolicyPathType = %lu\n"
            L"%ls   PolicyPath = \"%wZ\"\n"
            L"%ls   PolicyLastWriteTime = %ls\n",
            PLP, Entry->PolicyPathType,
            PLP, &s3,
            PLP, static_cast<PCWSTR>(buffPolicyLastWriteTime));

        OutputString(
            
            L"%ls   MetadataSatelliteRosterIndex = %lu\n"
            L"%ls   ManifestVersionMajor = %u\n"
            L"%ls   ManifestVersionMinor = %u\n",
            PLP, Entry->MetadataSatelliteRosterIndex,
            PLP, Entry->ManifestVersionMajor,
            PLP, Entry->ManifestVersionMinor);

        OutputString(
            
            L"%ls   AssemblyDirectoryName = \"%wZ\"\n",
            PLP, &s5);
    }
    else
    {
        // abuse buffManifestLastWriteTime
        buffManifestLastWriteTime.EnsureSize(((strIdentity.Length + s2.Length) / sizeof(WCHAR)) + 4);
        buffManifestLastWriteTime.Format(L"%wZ \"%wZ\"", &strIdentity, &s2);
        rbuffBriefOutput.Append(buffManifestLastWriteTime);
    }
}

VOID
DbgExtPrintDllRedirection(    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT PathSegments = NULL;
    CSmallSimpleString buffFlags;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgDllRedirectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME, "Includes Base Name")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT, "Omits Assembly Root")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND, "Req. EnvVar Expansion")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Entry->PathSegmentOffset != 0)
        PathSegments = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT) (((ULONG_PTR) Header) + Entry->PathSegmentOffset);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgDllRedirectionFlags), s_rgDllRedirectionFlags, buffFlags);

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_DLL_REDIRECTION %p\n"
            L"%ls   Size = %u\n"
            L"%ls   Flags = 0x%08lx (%ls)\n"
            L"%ls   TotalPathLength = %u (%u chars)\n"
            L"%ls   PathSegmentCount = %u\n"
            L"%ls   PathSegmentOffset = %d (-> %p)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags),
            PLP, Entry->TotalPathLength, Entry->TotalPathLength / sizeof(WCHAR),
            PLP, Entry->PathSegmentCount,
            PLP, Entry->PathSegmentOffset, PathSegments);
    }
    else
        rbuffBriefOutput.Append(L"\"", 1);

    if (PathSegments != NULL)
    {
        ULONG i;

        for (i=0; i<Entry->PathSegmentCount; i++)
        {
            PCWSTR pwch = NULL;
            UNICODE_STRING s;

            if (PathSegments[i].Offset != 0)
            {
                pwch = (PCWSTR) (((ULONG_PTR) Header) + PathSegments[i].Offset);

                s.MaximumLength = static_cast<USHORT>(PathSegments[i].Length);
                s.Length = static_cast<USHORT>(PathSegments[i].Length);
                s.Buffer = (PWSTR) pwch;
            }
            else
            {
                s.MaximumLength = 0;
                s.Length = 0;
                s.Buffer = NULL;
            }

            if (fFull)
            {
                OutputString(
                    
                    L"%ls   ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT #%d - %p\n"
                    L"%ls      Length = %u (%u chars)\n"
                    L"%ls      Offset = %d (-> %p)\n"
                    L"%ls         \"%wZ\"\n",
                    PLP, i, &PathSegments[i],
                    PLP, PathSegments[i].Length, PathSegments[i].Length / sizeof(WCHAR),
                    PLP, PathSegments[i].Offset, pwch,
                    PLP, &s);
            }
            else
            {
                rbuffBriefOutput.Append(s.Buffer, s.Length / sizeof(WCHAR));
            }
        }
    }

    if (!fFull)
    {
        rbuffBriefOutput.Append(L"\" (Flags: ", 10);
        rbuffBriefOutput.Append(buffFlags);
        rbuffBriefOutput.Append(L")", 1);
    }
}

VOID
DbgExtPrintWindowClassRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    UNICODE_STRING s1 = { 0 }, s2 = { 0 };
    CSmallSimpleString buffFlags;


    if (PLP == NULL)
        PLP = L"";

    ::FusionpFormatFlags(
        Entry->Flags,
        fFull,
        0, NULL,
        buffFlags);

    if (Entry->VersionSpecificClassNameOffset != 0)
    {
        s1.Length = static_cast<USHORT>(Entry->VersionSpecificClassNameLength);
        s1.MaximumLength = s1.Length;
        s1.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->VersionSpecificClassNameOffset);
    }

    if (Entry->DllNameOffset != 0)
    {
        s2.Length = static_cast<USHORT>(Entry->DllNameLength);
        s2.MaximumLength = s2.Length;
        s2.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->DllNameOffset);
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION %p\n"
            L"%ls   Size = %u\n"
            L"%ls   Flags = 0x%08lx\n"
            L"%ls   VersionSpecificClassNameLength = %u (%u chars)\n"
            L"%ls   VersionSpecificClassNameOffset = %d (-> %p)\n"
            L"%ls      \"%wZ\"\n"
            L"%ls   DllNameLength = %u (%u chars)\n"
            L"%ls   DllNameOffset = %d (-> %p)\n"
            L"%ls      \"%wZ\"\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->VersionSpecificClassNameLength, Entry->VersionSpecificClassNameLength / sizeof(WCHAR),
            PLP, Entry->VersionSpecificClassNameOffset, s1.Buffer,
            PLP, &s1,
            PLP, Entry->DllNameLength, Entry->DllNameLength / sizeof(WCHAR),
            PLP, Entry->DllNameOffset, s2.Buffer,
            PLP, &s2);
    }
    else
    {
        rbuffBriefOutput.Append(s1.Buffer, s1.Length / sizeof(WCHAR));
        rbuffBriefOutput.Append(L" in ", 4);
        rbuffBriefOutput.Append(s2.Buffer, s2.Length / sizeof(WCHAR));
        rbuffBriefOutput.Append(L" (Flags: ", 9);
        rbuffBriefOutput.Append(buffFlags);
        rbuffBriefOutput.Append(L")", 1);
    }
}

VOID
DbgExtPrintComServerRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallSimpleString buffConfiguredClsid;
    CSmallSimpleString buffImplementedClsid;
    CSmallSimpleString buffReferenceClsid;
    CSmallSimpleString buffTypeLibraryId;
    CSmallSimpleString buffThreadingModel;
    UNICODE_STRING s = { 0 };
    UNICODE_STRING progid = { 0 };

    if (PLP == NULL)
        PLP = L"";

    FormatGUID(Entry->ReferenceClsid, buffReferenceClsid);
    FormatGUID(Entry->ConfiguredClsid, buffConfiguredClsid);
    FormatGUID(Entry->ImplementedClsid, buffImplementedClsid);

    if (Entry->TypeLibraryId == GUID_NULL)
        buffTypeLibraryId.Assign(L"<none>", 6);
    else
        FormatGUID(Entry->TypeLibraryId, buffTypeLibraryId);

    FormatThreadingModel(Entry->ThreadingModel, buffThreadingModel);

    if (Entry->ModuleOffset != 0)
    {
        s.Length = static_cast<USHORT>(Entry->ModuleLength);
        s.MaximumLength = s.Length;
        s.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->ModuleOffset);
    }

    if (Entry->ProgIdOffset != 0)
    {
        progid.Length = static_cast<USHORT>(Entry->ProgIdLength);
        progid.MaximumLength = progid.Length;
        progid.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->ProgIdOffset);
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION %p\n"
            L"%ls   Size = %u\n"
            L"%ls   Flags = 0x%08lx\n"
            L"%ls   ThreadingModel = %u (%ls)\n"
            L"%ls   ReferenceClsid = %ls\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->ThreadingModel, static_cast<PCWSTR>(buffThreadingModel),
            PLP, static_cast<PCWSTR>(buffReferenceClsid));

        OutputString(
            
            L"%ls   ConfiguredClsid = %ls\n"
            L"%ls   ImplementedClsid = %ls\n"
            L"%ls   TypeLibraryId = %ls\n"
            L"%ls   ModuleLength = %u (%u chars)\n"
            L"%ls   ModuleOffset = %d (-> %p)\n"
            L"%ls      \"%wZ\"\n",
            PLP, static_cast<PCWSTR>(buffConfiguredClsid),
            PLP, static_cast<PCWSTR>(buffImplementedClsid),
            PLP, static_cast<PCWSTR>(buffTypeLibraryId),
            PLP, Entry->ModuleLength, Entry->ModuleLength / sizeof(WCHAR),
            PLP, Entry->ModuleOffset, s.Buffer,
            PLP, &s);


        OutputString(
            
            L"%ls   ProgIdLength = %lu\n"
            L"%ls   ProgIdOffset = %ld (-> %p)\n"
            L"%ls      \"%wZ\"\n",
            PLP, Entry->ProgIdLength,
            PLP, Entry->ProgIdOffset, progid.Buffer,
            PLP, &progid);
    }
    else
    {
        rbuffBriefOutput.Append(buffConfiguredClsid);

        rbuffBriefOutput.Append(L" ", 1);
        rbuffBriefOutput.Append(s.Buffer, s.Length / sizeof(WCHAR));
        if (progid.Length != 0)
        {
            rbuffBriefOutput.Append(L" progid: ", 9);
            rbuffBriefOutput.Append(progid.Buffer, progid.Length / sizeof(WCHAR));
        }
    }

}

VOID
DbgExtPrintComProgIdRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
//    CSmallSimpleString buffFlags;
    CSmallSimpleString buffClsid;
    const GUID *pcguid = NULL;

    if (Entry->ConfiguredClsidOffset != 0)
    {
        pcguid = (const GUID *) (((ULONG_PTR) Header) + Entry->ConfiguredClsidOffset);
        FormatGUID(*pcguid, buffClsid);
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION %p\n"
            L"%ls   Size = %lu (0x%lx)\n"
            L"%ls   Flags = 0x%08lx\n"
            L"%ls   ConfiguredClsidOffset = %lu (-> %p)\n"
            L"%ls      %ls\n",
            PLP, Entry,
            PLP, Entry->Size, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->ConfiguredClsidOffset, pcguid,
            PLP, static_cast<PCWSTR>(buffClsid));
    }
    else
    {
        rbuffBriefOutput.Append(buffClsid);
    }
}

VOID
DbgExtPrintComInterfaceRedirection(
    
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallSimpleString buffProxyStubClsid32;
    CSmallSimpleString buffBaseInterface;
    CSmallSimpleString buffFlags;
    CSmallSimpleString buffTypeLibraryId;
    UNICODE_STRING s = { 0 };

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgComInterfaceFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID, "NumMethods Valid")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID, "BaseInterface Valid")
    };

    if (PLP == NULL)
        PLP = L"";

    FormatGUID(Entry->ProxyStubClsid32, buffProxyStubClsid32);
    FormatGUID(Entry->BaseInterface, buffBaseInterface);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgComInterfaceFlags), s_rgComInterfaceFlags, buffFlags);

    if (Entry->TypeLibraryId == GUID_NULL)
        buffTypeLibraryId.Assign(L"<none>", 6);
    else
        FormatGUID(Entry->TypeLibraryId, buffTypeLibraryId);

    if (Entry->NameOffset != 0)
    {
        s.Length = static_cast<USHORT>(Entry->NameLength);
        s.MaximumLength = s.Length;
        s.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->NameOffset);
    }

    if (fFull)
    {
        OutputString(
            
            L"%lsACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION %p\n"
            L"%ls   Size = %lu\n"
            L"%ls   Flags = 0x%08lx (%ls)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags));

        OutputString(
            
            L"%ls   ProxyStubClsid32 = %ls\n"
            L"%ls   NumMethods = %lu\n"
            L"%ls   TypeLibraryId = %ls\n",
            PLP, static_cast<PCWSTR>(buffProxyStubClsid32),
            PLP, Entry->NumMethods,
            PLP, static_cast<PCWSTR>(buffTypeLibraryId));

        OutputString(
            
            L"%ls   BaseInterface = %ls\n"
            L"%ls   NameLength = %lu (%u chars)\n"
            L"%ls   NameOffset = %lu (-> %p)\n",
            PLP, static_cast<PCWSTR>(buffBaseInterface),
            PLP, Entry->NameLength, (Entry->NameLength / sizeof(WCHAR)),
            PLP, Entry->NameOffset, s.Buffer);

        OutputString(
            
            L"%ls      \"%wZ\"\n",
            PLP, &s);
    }
    else
    {
        rbuffBriefOutput.Append(buffProxyStubClsid32);
        rbuffBriefOutput.Append(L" ", 1);
        rbuffBriefOutput.Append(s.Buffer, s.Length / sizeof(WCHAR));
    }
}

#ifndef RTL_CONSTANT_STRING
#define RTL_CONSTANT_STRING(x) { NUMBER_OF(x) - 1, NUMBER_OF(x) - 1, x }
#endif

VOID
DbgExtPrintClrSurrogateTable(
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE Entry,
    SIZE_T Length,
    CSimpleBaseString &rbuffPLP,
    CSimpleBaseString &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSimpleInlineString<> buffGuid;
    UNICODE_STRING RuntimeVersion = RTL_CONSTANT_STRING(L"<No runtime version>");
    UNICODE_STRING TypeName = RTL_CONSTANT_STRING(L"<No type name>");

    if (PLP == NULL)
        PLP = L"";

    FormatGUID(Entry->SurrogateIdent, buffGuid);

    if (Entry->VersionOffset != 0)
    {
        RuntimeVersion.MaximumLength = RuntimeVersion.Length = static_cast<USHORT>(Entry->VersionLength);
        RuntimeVersion.Buffer = (PWSTR)(((ULONG_PTR)Entry) + Entry->VersionOffset);
    }

    if (Entry->TypeNameOffset != 0)
    {
        TypeName.MaximumLength = TypeName.Length = static_cast<USHORT>(Entry->TypeNameLength);
        TypeName.Buffer = (PWSTR)(((ULONG_PTR)Entry) + Entry->TypeNameOffset);
    }

    if (fFull)
    {
        OutputString(
            L"%SACTIVATION_CONTEXT_DATA_NDP_INTEROP %p\n"
            L"%S   Size = %u\n"
            L"%S   Flags = 0x%08lx\n"
            L"%S   SurrogateIdent = %S\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, static_cast<PCWSTR>(buffGuid));

        OutputString(
            L"%S   AssemblyName [Offset %u (-> %p), Length %u] = \"%wZ\"\n"
            L"%S   RuntimeVersion [Offset %u (-> %p), Length %u] = \"%wZ\"\n",
            PLP, Entry->TypeNameOffset, TypeName.Buffer, Entry->TypeNameLength, &TypeName,
            PLP, Entry->VersionOffset, RuntimeVersion.Buffer, Entry->VersionLength, &RuntimeVersion
            );
    }
    else
    {
        rbuffBriefOutput.Append(buffGuid);
        rbuffBriefOutput.Append(L" runtime: '", NUMBER_OF(L" runtime: '")-1);
        rbuffBriefOutput.Append(&RuntimeVersion);
        rbuffBriefOutput.Append(L"' typename: '", NUMBER_OF(L"' typename: '")-1);
        rbuffBriefOutput.Append(&TypeName);
        rbuffBriefOutput.Append(L"'", 1);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\debugexts\dumputils.cpp ===
#include "windows.h"
#include "sxstypes.h"
#define KDEXT_64BIT
#include "wdbgexts.h"
#include "fusiondbgext.h"

#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION     (0x00000001)
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE               (0x00000002)
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST                (0x00000004)
#define RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED              (0x00000008)

BOOL
DumpActivationContextStackFrame(
    PCSTR pcsLineHeader,
    ULONG64 ulStackFrameAddress,
    ULONG ulDepth,
    DWORD dwFlags
    )
{

    ULONG64 ulPreviousPtr = 0;
    ULONG64 ulActivationContextPointer = 0;
    ULONG ulFrameFlags = 0;

    if (!pcsLineHeader) pcsLineHeader = "";

    GetFieldValue(ulStackFrameAddress, "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME", "Previous", ulPreviousPtr);
    GetFieldValue(ulStackFrameAddress, "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME", "ActivationContext", ulActivationContextPointer);
    GetFieldValue(ulStackFrameAddress, "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME", "Flags", ulFrameFlags);

    dprintf(
        "%sActivation stack frame @ 0x%p (depth %ld):\n"
        "%s   Previous            : 0x%p\n"
        "%s   ActivationContext   : 0x%p\n"
        "%s   Flags               : 0x%08lx ",
        pcsLineHeader, ulStackFrameAddress, ulDepth,
        pcsLineHeader, ulPreviousPtr,
        pcsLineHeader, ulActivationContextPointer,
        pcsLineHeader, ulFrameFlags);

    if (ulFrameFlags != 0)
    {
        dprintf("(");
        if (ulFrameFlags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_RELEASE_ON_DEACTIVATION)
            dprintf("ReleaseOnDeactivate ");

        if (ulFrameFlags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_NO_DEACTIVATE)
            dprintf("NoDeactivate ");

        if (ulFrameFlags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_ON_FREE_LIST)
            dprintf("OnFreeList");


        if (ulFrameFlags & RTL_ACTIVATION_CONTEXT_STACK_FRAME_FLAG_HEAP_ALLOCATED)
            dprintf("HeapAllocated ");

        dprintf(")");
    }
    dprintf ("\n");

    return 0;

}


BOOL
DumpActCtxStackFullStack(
    ULONG64 ulFirstStackFramePointer
    )
{
    ULONG ulDepth = 0;
    ULONG64 ulStackFramePtr = ulFirstStackFramePointer;

    while (ulStackFramePtr)
    {
        DumpActivationContextStackFrame("   ", ulStackFramePtr, ulDepth++, 0xffff);
        GetFieldValue(ulStackFramePtr, "nt!_RTL_ACTIVATION_CONTEXT_STACK_FRAME", "Previous", ulStackFramePtr);
        if (CheckControlC() || (ulStackFramePtr == 0))
            break;
    }

    return TRUE;
}



BOOL
DumpActCtxData(
    PCSTR LineHeader,
    const ULONG64 ActCtxDataAddressInDebugeeSpace,
    ULONG ulFlags
    )
{
    //
    // ACTIVATION_CONTEXT_DATA is a self-referential type, so dumping it is
    // easy once it's all in memory.
    //
    ACTIVATION_CONTEXT_DATA ActData;
    BYTE *pbActualData = NULL;
    BOOL fOk = FALSE;
    ULONG cbRead = 0;

    if (!LineHeader) LineHeader = "";

    if (!ReadMemory(ActCtxDataAddressInDebugeeSpace, &ActData, sizeof(ActData), &cbRead) ||
        (cbRead != sizeof(ActData)))
    {
        dprintf(
            "%sFailed reading ACTIVATION_CONTEXT_DATA @ %p , or wrong kind of block is there.\n",
            LineHeader,
            ActCtxDataAddressInDebugeeSpace);
        goto Exit;
    }

    //
    // Let's create a blob of memory that can hold the whole thing, then
    //
    pbActualData = new BYTE[ActData.TotalSize];
    if (!pbActualData)
    {
        dprintf(
            "%sUnable to allocate %d bytes to store activation context data\n",
            LineHeader,
            ActData.TotalSize);
        goto Exit;
    }

    //
    // And re-read from the debugee
    //
    if (!ReadMemory(ActCtxDataAddressInDebugeeSpace, pbActualData, ActData.TotalSize, &cbRead) ||
        (cbRead != ActData.TotalSize))
    {
        dprintf(
            "%sUnable to read in %d bytes from %p as an activation context object?\n",
            LineHeader,
            ActData.TotalSize,
            ActCtxDataAddressInDebugeeSpace);
        goto Exit;
    }

    DbgExtPrintActivationContextData( 
        (ulFlags & DUMPACTCTXDATA_FLAG_FULL) == DUMPACTCTXDATA_FLAG_FULL,
        (PCACTIVATION_CONTEXT_DATA)pbActualData,
        L"   "
        );

    fOk = TRUE;
Exit:
    if (pbActualData)
        delete[] pbActualData;

    return fOk;

}




BOOL
DumpActCtx(
    const ULONG64 ActCtxAddressInDebugeeSpace,
    ULONG   ulFlags
    )
{
    ULONG64 ActCtxAddr = ActCtxAddressInDebugeeSpace;
    ULONG64 ulSymbolOffset = 0;
    PRIVATE_ACTIVATION_CONTEXT prvContextFilled = { 0 };
    CHAR NotificationSymbol[1024] = { 0 };
    BOOL fOk = FALSE;
    int i = 0;

#define GET_FIELD(a, fn, dst) { GetFieldData((a), "nt!_ACTIVATION_CONTEXT", #fn, sizeof((dst).##fn), (PVOID)&((dst).##fn)); }
    GET_FIELD(ActCtxAddr, Flags, prvContextFilled);
    GET_FIELD(ActCtxAddr, RefCount, prvContextFilled);
    GET_FIELD(ActCtxAddr, ActivationContextData, prvContextFilled);
    GET_FIELD(ActCtxAddr, NotificationRoutine, prvContextFilled);
    GET_FIELD(ActCtxAddr, NotificationContext, prvContextFilled);
    // GET_FIELD(ActCtxAddr, SentNotifications, prvContextFilled);
    // GET_FIELD(ActCtxAddr, DisabledNotifications, prvContextFilled);
    // GET_FIELD(ActCtxAddr, StorageMap, prvContextFilled);
    // GET_FIELD(ActCtxAddr, InlineStorageMapEntries, prvContextFilled);
#undef GET_FIELD


    dprintf(
        "Activation context structure @ 0x%p\n"
        "   RefCount                 %d\n"
        "   Flags                    0x%08x\n"
        "   ActivationContextData    0x%p\n",
        ActCtxAddressInDebugeeSpace,
        (LONG)prvContextFilled.RefCount,
        (ULONG)prvContextFilled.Flags,
        (PVOID)prvContextFilled.ActivationContextData);

    if (ulFlags & DUMPACTCTX_DATA)
    {
//        if (!DumpActCtxData("   ", (ULONG64)prvContextFilled.ActivationContextData, ulFlags))
//            goto Exit;
        DumpActCtxData("   ", (ULONG64)prvContextFilled.ActivationContextData, ulFlags);
    }

    //
    // This icky gunk is to print out a symbol name properly...
    //
    dprintf("   NotificationRoutine      0x%p ", prvContextFilled.NotificationRoutine);
    GetSymbol((ULONG64)prvContextFilled.NotificationRoutine, NotificationSymbol, &ulSymbolOffset);
    if (strlen(NotificationSymbol))
    {
        dprintf("(%s" , NotificationSymbol);
        if (ulSymbolOffset)
            dprintf("+0x%p", ulSymbolOffset);
        dprintf(")");
    }
    dprintf("\n");


    dprintf("   NotificationContext      0x%p\n", prvContextFilled.NotificationContext);

    dprintf("   SentNotifications        [");
    for (i = 0; i < NUMBER_OF(prvContextFilled.SentNotifications); i++)
    {
        if (i) dprintf(" ");
        dprintf("%d", prvContextFilled.SentNotifications[i]);
    }
    dprintf("]\n");

    dprintf("   DisabledNotifications    [");
    for (i = 0; i < NUMBER_OF(prvContextFilled.DisabledNotifications); i++)
    {
        if (i) dprintf(" ");
        dprintf("%d", prvContextFilled.DisabledNotifications[i]);
    }
    dprintf("]\n");

    {
        ULONG ulStorageMapFlags, ulCount;
        ULONG64 ulMapAddress;

        GetFieldValue(ActCtxAddressInDebugeeSpace, "_ACTIVATION_CONTEXT", "StorageMap.Flags", ulStorageMapFlags);
        GetFieldValue(ActCtxAddressInDebugeeSpace, "_ACTIVATION_CONTEXT", "StorageMap.AssemblyCount", ulCount);
        GetFieldValue(ActCtxAddressInDebugeeSpace, "_ACTIVATION_CONTEXT", "StorageMap.AssemblyArray", ulMapAddress);
        dprintf(
            "   StorageMap (Flags = 0x%08lx Count = %d MapArray = %p)\n",
            ulStorageMapFlags,
            ulCount,
            ulMapAddress);
    }

    fOk = TRUE;

    return fOk;
}


BOOL
GetActiveActivationContextData(
    PULONG64 pulActiveActCtx
    )
{
    ULONG64 ulTebAddress = 0, ulPebAddress = 0;
    ULONG64 ulTebActiveFrameAddress = 0;
    //
    // The algorithm is like this:
    // - Look at Teb.ActivationContextStack.ActiveFrame.ActivationContext.  If this is
    //   nonzero, stop looking.
    // - Now look at the process default activation context in Peb.ActivationContextData.
    //   If this is nonzero, stop looking.
    // - Look at the system default act ctx data, in Peb.SystemDefaultActivationContextData
    //   If this is nonzero, stop looking.
    // - Didn't find any active activation context data? Fooey.
    //

    *pulActiveActCtx = 0;

    GetTebAddress(&ulTebAddress);
    GetPebAddress(0, &ulPebAddress);

    if (ulTebAddress != NULL)
    {
        // Look at the active stack frame in the teb
        GetFieldValue(ulTebAddress, "nt!TEB", "ActivationContextStack.ActiveFrame", ulTebActiveFrameAddress);
        if (ulTebActiveFrameAddress)
        {
            ULONG64 ulActivationContextFrame;

            // Get the pointer to the active activation context itself
            GetFieldValue(
                ulTebActiveFrameAddress,
                "ntdll!_RTL_ACTIVATION_CONTEXT_STACK_FRAME",
                "ActivationContext",
                ulActivationContextFrame);
            // If that was valid, then ask for the pointer to the activation context data
            if (ulActivationContextFrame)
            {
                GetFieldValue(
                    ulActivationContextFrame,
                    "ntdll!ACTIVATION_CONTEXT",
                    "ActivationContextData",
                    *pulActiveActCtx);
                return TRUE;
            }
            // Is this really requesting the process default?
            else if (ulActivationContextFrame == NULL)
            {
                // Then get it and return
                GetFieldValue(ulPebAddress, "nt!PEB", "ActivationContextData", *pulActiveActCtx);
                return TRUE;
            }
        }
    }

    //
    // Still nothing, so go look at the process default directly
    //
    {
        ULONG ActCtxDataOffset;
        ULONG64 PebData;

        GetFieldOffset("nt!_PEB", "ActivationContextData", &ActCtxDataOffset);
        if ((ReadPtr(ulPebAddress + ActCtxDataOffset, &PebData) == 0) && PebData)
        {
            *pulActiveActCtx = PebData;
            return TRUE;
        }
    }

    //
    // Otherwise...
    //
    GetFieldValue(ulPebAddress, "nt!PEB", "SystemDefaultActivationContextData", *pulActiveActCtx);
    return (*pulActiveActCtx ? TRUE : FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\amd64sxsmk.inc ===
#
# This file is intentionally empty, see "sxsmk" in sources.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\debugexts\fusiondbgext.h ===
#pragma once

#include "sxstypes.h"

class COutOfMemory { };

__declspec(noreturn) inline void ThrowOutOfMemory()
{
    throw COutOfMemory();
}

#define DUMPACTCTX_HEADER           (0x00000001)
#define DUMPACTCTX_DATA             (0x00000002)
#define DUMPACTCTXDATA_FLAG_FULL    (0x00010000)
#define NUMBER_OF(x) ( (sizeof(x) / sizeof(*x) ) )

typedef struct PRIVATE_ACTIVATION_CONTEXT {
    LONG RefCount;
    ULONG Flags;
    ULONG64 ActivationContextData; // _ACTIVATION_CONTEXT_DATA
    ULONG64 NotificationRoutine; // PACTIVATION_CONTEXT_NOTIFY_ROUTINE
    ULONG64 NotificationContext;
    ULONG SentNotifications[8];
    ULONG DisabledNotifications[8];
    ULONG64 StorageMap; // ASSEMBLY_STORAGE_MAP
    PVOID InlineStorageMapEntries[32]; // PASSEMBLY_STORAGE_MAP_ENTRY
} PRIVATE_ACTIVATION_CONTEXT;

// then the unicode string struct is probably not defined either
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;


BOOL
DumpActivationContextStackFrame(
	PCSTR pcsLineHeader,
    ULONG64 ulStackFrameAddress,
    ULONG ulDepth,
    DWORD dwFlags
    );

BOOL
DumpActCtxData(
    PCSTR LineHeader,
    const ULONG64 ActCtxDataAddressInDebugeeSpace,
    ULONG ulFlags
    );

BOOL
DumpActCtx(
    const ULONG64 ActCtxAddressInDebugeeSpace,
    ULONG   ulFlags
    );

BOOL
GetActiveActivationContextData(
    PULONG64 pulActiveActCtx
    );

BOOL
DumpActCtxStackFullStack(
    ULONG64 ulFirstStackFramePointer
    );

VOID
DbgExtPrintActivationContextData(
    BOOL fFull,
    PCACTIVATION_CONTEXT_DATA Data,
    PCWSTR rbuffPLP
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\i386sxsmk.inc ===
#
# We pull these in directly because they are in both ntdll.lib
# and libcmt.lib and if we let link search .libs, it complains about
# duplicate symbols. ".objs beat .libs."
#
TARGETLIBS=\
  $(PROJECT_ROOT)\crts\crtw32\misc\nt\$(O)\exsup.obj \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\exitproc.c ===
#define _KERNEL32_
#include "windows.h"

void
SxspCrtRaiseExit(
    PCSTR    pszCaller,
    int      crtError
    );

VOID
WINAPI
ExitProcess(
    IN UINT uExitCode
    )
{
    SxspCrtRaiseExit(__FUNCTION__, (int)uExitCode);
}

#if !defined(_M_IX86) && !defined(_X86_)
const extern FARPROC __imp_ExitProcess = (FARPROC)&ExitProcess;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\ia64sxsmk.inc ===
#
# This file is intentionally empty, see "sxsmk" in sources.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\debugexts\sources.inc ===
FUSION_BUILD_TYPE=WIN
!include $(PROJECT_ROOT)\win32\fusion\fusion.inc
MSC_WARNING_LEVEL = -W3 -WX
MAJORCOMP=fusion
MINORCOMP=debugexts

SOURCES_USED=$(SOURCES_USED) ..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\termproc.c ===
#define _KERNEL32_
#include "windows.h"

void
SxspCrtRaiseExit(
    PCSTR    pszCaller,
    int      crtError
    );

BOOL
WINAPI
TerminateProcess(
    IN HANDLE hProcess,
    IN UINT uExitCode
    )
{
    SxspCrtRaiseExit(__FUNCTION__, (int)uExitCode);
    return FALSE;
}

#if !defined(_M_IX86) && !defined(_X86_)
const extern FARPROC __imp_TerminateProcess = (FARPROC)&TerminateProcess;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\i386\exitprocasm.asm ===
;
; This is in assembly because assembly lets you generate arbitrarily named symbols.
;

	.386p
.model flat

extern	_ExitProcess@4:near
public	__imp__ExitProcess@4

CONST   segment
__imp__ExitProcess@4 dd _ExitProcess@4
CONST	ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\i386\termprocasm.asm ===
;
; This is in assembly because assembly lets you generate arbitrarily named symbols.
;

	.386p
.model flat

extern	_TerminateProcess@8:near
public	__imp__TerminateProcess@8

CONST   segment
__imp__TerminateProcess@8 dd _TerminateProcess@8
CONST	ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\i386\setunhandledexceptionfilterasm.asm ===
;
; This is in assembly because assembly lets you generate arbitrarily named symbols.
;

	.386p
.model flat

extern	_SetUnhandledExceptionFilter@4:near
public	__imp__SetUnhandledExceptionFilter@4

CONST   segment
__imp__SetUnhandledExceptionFilter@4 dd _SetUnhandledExceptionFilter@4
CONST	ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dll\whistler\setunhandledexceptionfilter.c ===
#define _KERNEL32_
#include "windows.h"

LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    )
{
    /* don't do anything */
    return NULL;
}

#if !defined(_M_IX86) && !defined(_X86_)
const extern FARPROC __imp_SetUnhandledExceptionFilter = (FARPROC)&SetUnhandledExceptionFilter;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dumplib\typeinfo.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    typeinfo.cpp

Abstract:

Author:

    Jay Krell (JayKrell) November 2001

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusiondump.h"
#include "sxstypes.h"

#if DBG // until we work out factoring between sxs.dll, sxstest.dll, fusiondbg.dll.

extern const FUSIONP_DUMP_BUILTIN_SYMBOLS_FIELD FieldInfo_ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION[] =
{
#define FUSIONP_DUMP_CURRENT_STRUCT ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION
    FUSIONP_DUMP_MAKE_FIELD(Size, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(Flags, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(EncodedAssemblyIdentityLength, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(EncodedAssemblyIdentityOffset, ULONG_OFFSET_TO_PCWSTR | FUSIONP_DUMP_OFFSET_BASE_0)
    FUSIONP_DUMP_MAKE_FIELD(ManifestPathType, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(ManifestPathLength, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(ManifestPathOffset, ULONG_OFFSET_TO_PCWSTR | FUSIONP_DUMP_OFFSET_BASE_0)
    FUSIONP_DUMP_MAKE_FIELD(ManifestLastWriteTime, LARGE_INTEGER_TIME)
    FUSIONP_DUMP_MAKE_FIELD(PolicyPathType, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(PolicyPathLength, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(PolicyLastWriteTime, LARGE_INTEGER_TIME)
    FUSIONP_DUMP_MAKE_FIELD(MetadataSatelliteRosterIndex, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(Unused2, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(ManifestVersionMajor, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(ManifestVersionMinor, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(AssemblyDirectoryNameLength, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(AssemblyDirectoryNameOffset, ULONG_OFFSET_TO_PCWSTR | FUSIONP_DUMP_OFFSET_BASE_0)
    FUSIONP_DUMP_MAKE_FIELD(NumOfFilesInAssembly, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(LanguageLength, ULONG)
    FUSIONP_DUMP_MAKE_FIELD(LanguageOffset, ULONG_OFFSET_TO_PCWSTR | FUSIONP_DUMP_OFFSET_BASE_0)
    { 0 }
#undef FUSIONP_DUMP_CURRENT_STRUCT
};

extern const FUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT StructInfo_ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION =
{
    "ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION",
    RTL_NUMBER_OF("ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION") - 1,
    sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION),
    RTL_NUMBER_OF(FieldInfo_ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) - 1,
    FieldInfo_ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\dumplib\dump.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    dump.cpp

Abstract:

    Merge/refactor stuff in sxstest with dumpers.cpp
    Eventually merge with debug extensions, let it be optionally
    driven by symbol info available to debug extensions via .pdbs.

Author:

    Jay Krell (JayKrell) November 2001

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusiondump.h"
#include "fusiontrace.h"
#include "fusionstring.h"

#if DBG // until we work out factoring between sxs.dll, sxstest.dll, fusiondbg.dll.

typedef const BYTE * PCBYTE;

BOOL
FusionpDumpStruct(
    PCFUSIONP_DUMP_CALLBACKS                Callbacks,
    PCFUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT   TypeInfo,
    ULONG64                                 pint,
    PCSTR                                   Name,
    const ULONG64 *                         Bases
    )
{
    //
    // This code currently runs inproc, but it should be transitioned to
    // run in a debugger, or to do either, based on "builtin typeinfo" vs.
    // availability of .pdb.
    //
    typedef FUSIONP_DUMP_BUILTIN_SYMBOLS_FIELD FIELD;

    FN_PROLOG_WIN32

    ULONG MaxNameLength = 0;
    ULONG i = 0;
    CAnsiString AnsiStringField;
    CAnsiString AnsiStringStruct(Name);
    LARGE_INTEGER li = { 0 };
    PCWSTR s = 0;
    PCBYTE Base = 0;
    const FIELD * Field = 0;
    const FIELD * FieldEnd = 0;
    const FIELD * Fields = TypeInfo->Fields;
    PCBYTE p = reinterpret_cast<const BYTE*>(static_cast<ULONG_PTR>(pint));

    for ( FieldEnd = Fields ; FieldEnd->Name ; ++FieldEnd )
    {
        /* nothing */
    }

    for ( Field = Fields ; Field != FieldEnd ; ++Field )
    {
        if (Field->NameLength > MaxNameLength)
            MaxNameLength = Field->NameLength;
    }
    for ( Field = Fields ; Field != FieldEnd ; ++Field )
    {
        AnsiStringField.Buffer = const_cast<PSTR>(Field->Name);
        AnsiStringField.Length = Field->NameLength;
        switch (Field->Type & 0x0F)
        {
        case FUSIONP_DUMP_TYPE_ULONG:
            PARAMETER_CHECK(Field->Size == sizeof(ULONG));
            i = *reinterpret_cast<const ULONG*>(p + Field->Offset);
            Callbacks->Printf("%Z.%-*Z: 0x%lx (0n%lu)\n",
                &AnsiStringStruct,
                static_cast<int>(MaxNameLength + 1),
                &AnsiStringField,
                i,
                i
                );
            break;
        case FUSIONP_DUMP_TYPE_ULONG_OFFSET_TO_PCWSTR:
            PARAMETER_CHECK(Field->Size == sizeof(ULONG));
            i = *reinterpret_cast<const ULONG*>(p + Field->Offset);
            Base = reinterpret_cast<PCBYTE>(static_cast<ULONG_PTR>(Bases[(Field->Type >> 4) & 0x0F]));
            s = (i != 0) ? reinterpret_cast<PCWSTR>(Base + i) : L"";
            Callbacks->Printf("%Z.%-*Z: %ls (base 0x%I64x + offset 0x%lx (0n%lu))\n",
                &AnsiStringStruct,
                static_cast<int>(MaxNameLength + 1),
                &AnsiStringField,
                s,
                Base,
                i,
                i
                );
            break;
        case FUSIONP_DUMP_TYPE_LARGE_INTEGER_TIME:
            PARAMETER_CHECK(Field->Size == sizeof(LARGE_INTEGER));
            li = *reinterpret_cast<const LARGE_INTEGER*>(p + Field->Offset);
            Callbacks->Printf("%Z.%-*Z: %s (0x%I64x (0n%I64u))\n",
                &AnsiStringStruct,
                static_cast<int>(MaxNameLength + 1),
                &AnsiStringField,
                Callbacks->FormatTime(li),
                li.QuadPart,
                li.QuadPart
                );
            break;
        }
    }

    FN_EPILOG;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\eventlog\eventlog.cpp ===
#include "stdinc.h"
#include "fusioneventlog.h"
#include "search.h"
#include <stdlib.h>
#include "fusionunused.h"
#include "sxsid.h"
#include "smartptr.h"

/*
NTRAID#NTBUG9-591790-2002/03/31-JayKrell

General issues in this file
   missing error check on .Win32Format (dbgprint related, under #if DBG)


//
// ISSUE:jonwis:2002-3-29: This version is smarter about rolling back if something bad
//  happens, and much better about playing nice with tracing and whatnot.  It should be
//  put into place at some point, but it's too much of a change to just make offhand.
//
static BOOL
FusionpRegisterEventLog()

Registration of the our event logging should be moved to a setup text file.

FormatMessage with inserts is not "safe". Our code depends on our resources.
  Our code picks some maximums that our resources need to stay under.

CEventLogLastError::CEventLogLastError()
and CEventLogLastError::CEventLogLastError(DWORD)
are copy pastes of each other; they should share code

*/

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

const UNICODE_STRING g_strEmptyUnicodeString = { 0, 0, L""};

extern HINSTANCE g_hInstance;
HANDLE g_hEventLog = NULL;
BOOL   g_fEventLogOpenAttempted = FALSE;


// a registry key name, and appears in the EventVwr ui.
// should be localized?
// a macro is provided for easy static concatenation
#define EVENT_SOURCE L"SideBySide"

// path we put in the registry to our message file
// we might want to change this to ntdll.dll or kernel32.dll
// whatever file it is, you can't replace it while EventVwr is running, which stinks
#define MESSAGE_FILE L"%SystemRoot%\\System32\\sxs.dll"

// the non macro, string pool formed, to use for other than string concatenation
const WCHAR szEventSource[] = EVENT_SOURCE;

// same thing in another form
const static UNICODE_STRING strEventSource = RTL_CONSTANT_STRING(EVENT_SOURCE);

// machine is assumed to be the local machine
const static UNICODE_STRING strMachine = {0, 0, NULL};

// we only actually log errors, but this is far and away the most common value in the registry
// and there doesn't seem to be a downside to using it
static const DWORD dwEventTypesSupported = (EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE);

// a registry value name
static const WCHAR szTypesSupportedName[] = L"TypesSupported";

// a registry value name
static const WCHAR szEventMessageFileName[] = L"EventMessageFile";

static const WCHAR szEventMessageFileValue[] = MESSAGE_FILE;
static const HKEY  hkeyEventLogRoot = HKEY_LOCAL_MACHINE;
#define EVENT_LOG_SUBKEY_PARENT L"System\\CurrentControlSet\\Services\\EventLog\\System\\"
#define EVENT_LOG_SUBKEY  (EVENT_LOG_SUBKEY_PARENT EVENT_SOURCE)

const static PCUNICODE_STRING g_rgpsEmptyStrings[] =
{
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
    &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString
};

/*--------------------------------------------------------------------------
call this from DllMain
--------------------------------------------------------------------------*/

BOOL
FusionpEventLogMain(
    HINSTANCE,
    DWORD dwReason,
    PVOID pvReserved
    )
{
    if ((dwReason == DLL_PROCESS_DETACH) &&
        (g_hEventLog != NULL)
        )
    {
        if (pvReserved != NULL)
        {
            ::ElfDeregisterEventSource(g_hEventLog);
        }
        g_hEventLog = NULL;
    }
    return TRUE;
}


const static WCHAR Error_Message_is_unavailable[] = L"Error Message is unavailable\n";

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/
CEventLogLastError::CEventLogLastError()
{
    const DWORD dwLastError = FusionpGetLastWin32Error();

    // extra string copy..
    WCHAR rgchLastError[NUMBER_OF(m_rgchBuffer)];
    rgchLastError[0] = 0;

    C_ASSERT(sizeof(Error_Message_is_unavailable) <= sizeof(rgchLastError));

    // I expect FormatMessage will truncate, which is acceptable.
    const DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY;
    if (::FormatMessageW(dwFlags, NULL, dwLastError, 0, rgchLastError, NUMBER_OF(rgchLastError), NULL) == 0 )
    {
        CopyMemory(rgchLastError, Error_Message_is_unavailable, sizeof(Error_Message_is_unavailable));
    }

    // Format will truncate, which is acceptable.
    //Format(L"FusionpGetLastWin32Error()=(%ld,%ls)", nLastError, rgchLastError);
    Format(L"%ls", rgchLastError);

    SetLastError(dwLastError);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/
CEventLogLastError::CEventLogLastError(
    DWORD dwLastError
    )
{
    // extra string copy..
    WCHAR rgchLastError[NUMBER_OF(m_rgchBuffer)];
    rgchLastError[0] = 0;

    C_ASSERT(sizeof(Error_Message_is_unavailable) <= sizeof(rgchLastError));

    // I expect FormatMessage will truncate, which is acceptable.
    const DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY;
    if (::FormatMessageW(dwFlags, NULL, dwLastError, 0, rgchLastError, NUMBER_OF(rgchLastError), NULL) == 0)
    {
        CopyMemory(rgchLastError, Error_Message_is_unavailable, sizeof(Error_Message_is_unavailable));
    }

    // Format will truncate, which is acceptable.
    //Format(L"FusionpGetLastWin32Error()=(%ld,%ls)", nLastError, rgchLastError);
    Format(L"%ls", rgchLastError);

    SetLastError(dwLastError);
}

/*--------------------------------------------------------------------------
register ourselves in the registry on demand
FUTURE Do this in setup?
HKLM\System\CurrentControlSet\Services\EventLog\System\SideBySide
    EventMessageFile = %SystemRoot%\System32\Fusion.dll
    TypesSupported = 7
--------------------------------------------------------------------------*/

// NTRAID#NTBUG9 - 566261 - jonwis - 2002/4/25 - We should be doing better in terms of rollback
BOOL
FusionpRegisterEventLog()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    HKEY hkey = NULL;
    BOOL fValidHkey = FALSE;
    LONG lRet = ERROR_SUCCESS;
    DWORD dwDisposition = 0;
    WCHAR szSubKey[] = EVENT_LOG_SUBKEY;

    // first see if it's there, in which case we have less to do
    lRet = ::RegOpenKeyExW(
        hkeyEventLogRoot,
        szSubKey,
        0, // reserved options
        KEY_READ | FUSIONP_KEY_WOW64_64KEY,
        &hkey);

    if (lRet == ERROR_SUCCESS)
    {
        fValidHkey = TRUE;
        goto Exit;
    }
    if (lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpRegisterEventLog/RegOpenKeyExW failed %ld\n", lRet);
        goto Exit;
    }
    lRet = ::RegCreateKeyExW(
        hkeyEventLogRoot,
        szSubKey,
        0, // reserved
        NULL, // class
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS | FUSIONP_KEY_WOW64_64KEY,
        NULL, // security
            &hkey,
        &dwDisposition);
    if (lRet != ERROR_SUCCESS)
    {
        goto Exit;
    }

    fValidHkey = TRUE;
    lRet = ::RegSetValueExW(
        hkey,
        szEventMessageFileName,
        0, // reserved
        REG_EXPAND_SZ,
        reinterpret_cast<const BYTE*>(szEventMessageFileValue),
        sizeof(szEventMessageFileValue));

    if (lRet != ERROR_SUCCESS)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpRegisterEventLog/RegSetValueExW failed %ld\n", lRet);
        goto Exit;
    }

    lRet = ::RegSetValueExW(
        hkey,
        szTypesSupportedName,
        0, // reserved
        REG_DWORD,
        reinterpret_cast<const BYTE*>(&dwEventTypesSupported),
        sizeof(dwEventTypesSupported));
    if (lRet != ERROR_SUCCESS)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpRegisterEventLog/RegSetValueExW failed %ld\n", lRet);
        goto Exit;
    }
Exit:

    if (fValidHkey)
    {
        if (lRet != ERROR_SUCCESS)
        {
            if (dwDisposition == REG_CREATED_NEW_KEY)
            {
            // rollback if there definitely wasn't anything there before
                PWSTR szParentKey = szSubKey;
                LONG lSubRet = ERROR_SUCCESS;
                HKEY hkeyParent = reinterpret_cast<HKEY>(INVALID_HANDLE_VALUE);

                ASSERT(szParentKey[NUMBER_OF(szSubKey) - NUMBER_OF(szEventSource)] == L'\\');
                szParentKey[NUMBER_OF(szSubKey) - NUMBER_OF(szEventSource)] = 0;

                ::RegDeleteValueW(hkey, szEventMessageFileName);
                ::RegDeleteValueW(hkey, szTypesSupportedName);

                lSubRet = ::RegOpenKeyExW(
                    hkeyEventLogRoot,
                    szParentKey,
                    0, // reserved options
                    KEY_WRITE | FUSIONP_KEY_WOW64_64KEY,
                    &hkeyParent);
                if (lSubRet == ERROR_SUCCESS)
                {
                    ::RegDeleteKeyW(hkeyParent, szEventSource);
                    ::RegCloseKey(hkeyParent);
                }
            }
        }
        ::RegCloseKey(hkey);
        fValidHkey = FALSE;
    }

    if (lRet != ERROR_SUCCESS)
    {
        ::SetLastError(lRet);
    }
    else
    fSuccess = TRUE;
    return fSuccess;
}

/*--------------------------------------------------------------------------
convert the upper two bits of an event id to the small numbered analogous
parameter to ReportEvent
--------------------------------------------------------------------------*/
WORD
FusionpEventIdToEventType(
    DWORD dwEventId
    )
{
    switch (dwEventId >> 30)
    {
        case STATUS_SEVERITY_SUCCESS:       return EVENTLOG_SUCCESS;
        case STATUS_SEVERITY_WARNING:       return EVENTLOG_WARNING_TYPE;
        case STATUS_SEVERITY_INFORMATIONAL: return EVENTLOG_INFORMATION_TYPE;
        case STATUS_SEVERITY_ERROR:         return EVENTLOG_ERROR_TYPE;
        default: __assume(FALSE);
    }
     __assume(FALSE);
}

/*--------------------------------------------------------------------------
a Fusion event id and its corresponding Win32 lastError
the mapping is defined in Messages.x
--------------------------------------------------------------------------*/
struct EventIdErrorPair
{
    DWORD   dwEventId;
    LONG    nError;
};

/*--------------------------------------------------------------------------
the type of function used with bsearch
--------------------------------------------------------------------------*/
typedef int (__cdecl* PFNBSearchFunction)(const void*, const void*);

/*--------------------------------------------------------------------------
a function appropriate for use with bsearch
--------------------------------------------------------------------------*/
int __cdecl
CompareEventIdErrorPair(
    const EventIdErrorPair* x,
    const EventIdErrorPair* y
    )
{
    return
          (x->dwEventId < y->dwEventId) ?  -1
        : (x->dwEventId > y->dwEventId) ?  +1
        :                                   0;
}

const static EventIdErrorPair eventIdToErrorMap[] =
{
    #include "Messages.hi" // generated from .x file, like .mc
};

/*--------------------------------------------------------------------------
find the Win32 last error corresponding to this Fusion event id
--------------------------------------------------------------------------*/
DWORD
FusionpEventIdToError(
    DWORD dwEventId
    )
{
    DWORD dwFacility = HRESULT_FACILITY(dwEventId);
    if (dwFacility < 0x100)
    { // it's actually a system event id
        ASSERT2_NTC(FALSE, "system event id in " __FUNCTION__);
        return dwEventId;
    }
    static BOOL fSortVerified = FALSE;
    static BOOL fSorted = FALSE;
    if (!fSortVerified)
    {
        ULONG i;
        for (i = 0 ; i != NUMBER_OF(eventIdToErrorMap) - 1; ++i)
        {
            if (eventIdToErrorMap[i+1].dwEventId < eventIdToErrorMap[i].dwEventId)
            {
                break;
            }
        }
        if (i != NUMBER_OF(eventIdToErrorMap) - 1)
        {
            ASSERT2_NTC(FALSE, "eventIdToErrorMap is not sorted, reverting to linear search");
            fSorted = FALSE;
        }
        else
        {
            fSorted = TRUE;
        }
        fSortVerified = TRUE;
    }
    const EventIdErrorPair* found = NULL;
    const EventIdErrorPair key = { dwEventId };
    unsigned numberOf = NUMBER_OF(eventIdToErrorMap);

    if (fSorted)
    {
        found = reinterpret_cast<const EventIdErrorPair*>(
                    bsearch(
                        &key,
                        &eventIdToErrorMap,
                        numberOf,
                        sizeof(eventIdToErrorMap[0]),
                        reinterpret_cast<PFNBSearchFunction>(CompareEventIdErrorPair)));
    }
    else
    {
        found = reinterpret_cast<const EventIdErrorPair*>(
                    _lfind(
                        &key,
                        &eventIdToErrorMap,
                        &numberOf,
                        sizeof(eventIdToErrorMap[0]),
                        reinterpret_cast<PFNBSearchFunction>(CompareEventIdErrorPair)));
    }
    if (found == NULL)
    {
#if DBG
        CANSIStringBuffer msg;
        msg.Win32Format("Event id %lx not found in eventIdToErrorMap", static_cast<ULONG>(dwEventId));
        ASSERT2_NTC(found != NULL, const_cast<PSTR>(static_cast<PCSTR>(msg)));
#endif
        return ::FusionpGetLastWin32Error();
    }
    if (found->nError != 0)
    {
        return found->nError;
    }
    return ::FusionpGetLastWin32Error();
}

/*--------------------------------------------------------------------------
open the event log on demand
confusingly, this is called "registering" an event source
--------------------------------------------------------------------------*/
BOOL
FusionpOpenEventLog()
{
    HANDLE hEventLog;
    NTSTATUS status;
    if (g_fEventLogOpenAttempted)
    {
        goto Exit;
    }
    if (!FusionpRegisterEventLog())
    {
        goto Exit;
    }
    status = ::ElfRegisterEventSourceW(
        const_cast<PUNICODE_STRING>(&strMachine),
        const_cast<PUNICODE_STRING>(&strEventSource),
        &hEventLog);
    if (!NT_SUCCESS(status))
    {
        if (status != RPC_NT_SERVER_UNAVAILABLE)
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpOpenEventLog/ElfRegisterEventSourceW failed %lx\n", static_cast<ULONG>(status));
        goto Exit;
    }
    if (InterlockedCompareExchangePointer(
        &g_hEventLog,
        hEventLog, // exchange value
        NULL // compare value
        ) != NULL) // value returned is value that was there before we called
    {
        ::ElfDeregisterEventSource(hEventLog);
        goto Exit;
    }
    g_hEventLog = hEventLog;
Exit:
    g_fEventLogOpenAttempted = TRUE;
    return (g_hEventLog != NULL);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogError(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2,
    const UNICODE_STRING& s3,
    const UNICODE_STRING& s4
    )
{
    PCUNICODE_STRING rgps[] = { &s1, &s2, &s3, &s4 };
    return ::FusionpLogError(dwEventId, NUMBER_OF(rgps), rgps);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogErrorToDebugger(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2,
    const UNICODE_STRING& s3,
    const UNICODE_STRING& s4
    )
{
    PCUNICODE_STRING rgps[] = { &s1, &s2, &s3, &s4 };
    return FusionpLogErrorToDebugger(dwEventId, NUMBER_OF(rgps), rgps);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogErrorToEventLog(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2,
    const UNICODE_STRING& s3,
    const UNICODE_STRING& s4
    )
{
    PCUNICODE_STRING rgps[] = { &s1, &s2, &s3, &s4 };
    return FusionpLogErrorToEventLog(dwEventId, NUMBER_OF(rgps), rgps);
}

void
LocalFreeWcharPointer(
    WCHAR * p
    )
{
    LocalFree(p);
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogErrorToDebugger(
    DWORD dwEventId,
    ULONG nStrings,
    const PCUNICODE_STRING * rgps
    )
{
    const LONG  lastError = FusionpEventIdToError(dwEventId);
    const HRESULT hr = HRESULT_FROM_WIN32(lastError);

    PCUNICODE_STRING rgpsManyStrings[] =
    {
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString,
        &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString, &g_strEmptyUnicodeString
    };
    if (nStrings < NUMBER_OF(rgpsManyStrings))
    {
        CopyMemory(rgpsManyStrings, rgps, nStrings * sizeof(rgps[0]));
        rgps = rgpsManyStrings;
    }

    DWORD dwFormatMessageFlags = 0;

    CSmartPtrWithNamedDestructor<WCHAR, LocalFreeWcharPointer> pszBuffer1;
    CSmartPtrWithNamedDestructor<WCHAR, LocalFreeWcharPointer> pszBuffer2;
    DWORD dw = 0;
    static const WCHAR rgchParseContextPrefix[] = PARSE_CONTEXT_PREFIX;
    const SIZE_T cchParseContextPrefixLength = RTL_NUMBER_OF(rgchParseContextPrefix) - 1;
    PCWSTR pszSkipFirstLine = NULL;

    // load the string from the message table,
    // substituting %n with %n!wZ!
    // the Rtl limit here is 200, but we don't expect very many in our messages
    const static PCWSTR percentZw[] = { L"%1!wZ!", L"%2!wZ!", L"%3!wZ!", L"%4!wZ!", L"%5!wZ!",
                                        L"%6!wZ!", L"%7!wZ!", L"%8!wZ!", L"%9!wZ!", L"%10!wZ!",
                                        L"%11!wZ!", L"%12!wZ!", L"%13!wZ!", L"%14!wZ!", L"%15!wZ!"
                                        L"%16!wZ!", L"%17!wZ!", L"%18!wZ!", L"%19!wZ!", L"%20!wZ!"
                                      };

    dwFormatMessageFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_HMODULE;
    dwFormatMessageFlags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;
    dw = FormatMessageW(
        dwFormatMessageFlags,
        g_hInstance,
        dwEventId,
        0, // langid
        reinterpret_cast<PWSTR>(static_cast<PWSTR*>(&pszBuffer1)),
        300, // minimum allocation
        const_cast<va_list*>(reinterpret_cast<const va_list*>(&percentZw)));
    if (dw == 0)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpLogError/FormatMessageW failed %ld\n", static_cast<long>(FusionpGetLastWin32Error()));
        goto Exit;
    }

    // do the substitutions
    dwFormatMessageFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING;
    dwFormatMessageFlags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;
    dw = FormatMessageW(
        dwFormatMessageFlags,
        pszBuffer1,
        0, // message id
        0, // langid
        reinterpret_cast<PWSTR>(static_cast<PWSTR*>(&pszBuffer2)),
        1 + StringLength(pszBuffer1), // minimum allocation
        reinterpret_cast<va_list*>(const_cast<PUNICODE_STRING*>(rgps)));
    if (dw == 0)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpLogError/FormatMessageW failed %ld\n", static_cast<long>(FusionpGetLastWin32Error()));
        goto Exit;
    }

    //
    // acceptable hack
    //
    // The first line of parse errors is a verbose context, see Messages.x.
    // For DbgPrint we want instead file(line): on the same line instead.
    // We make that transformation here.
    //
    pszSkipFirstLine = wcschr(pszBuffer2, '\n');
    BOOL fAreWeInOSSetupMode = FALSE;
    FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode);
    if (
        pszSkipFirstLine != NULL
        && nStrings >= PARSE_CONTEXT_INSERTS_END
        && StringLength(pszBuffer2) >= cchParseContextPrefixLength
        && FusionpEqualStringsI(pszBuffer2, cchParseContextPrefixLength, rgchParseContextPrefix, cchParseContextPrefixLength)
        )
    {
        // we might fiddle with the form of the newline, so skip whatever is there
        while (wcschr(L"\r\n", *pszSkipFirstLine) != NULL)
            pszSkipFirstLine += 1;

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR | ( fAreWeInOSSetupMode ? FUSION_DBG_LEVEL_SETUPLOG : 0),
            "%wZ(%wZ): %S",
            rgps[PARSE_CONTEXT_FILE - 1],
            rgps[PARSE_CONTEXT_LINE - 1],
            pszSkipFirstLine);
    }
    else
    {
        // just print it verbatim
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR | ( fAreWeInOSSetupMode ? FUSION_DBG_LEVEL_SETUPLOG : 0),
            "SXS.DLL: %S",
            pszBuffer2);
    }
Exit:
    ::SetLastError(lastError);
    return hr;
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogErrorToEventLog(
    DWORD dwEventId,
    ULONG nStrings,
    const PCUNICODE_STRING * rgps
    )
{
    const LONG  lastError = FusionpEventIdToError(dwEventId);
    const HRESULT hr = HRESULT_FROM_WIN32(lastError);

    const WORD  wType = FusionpEventIdToEventType(dwEventId);
    // The use of the lower bits of the hresult facility as the event log
    // facility is my own invention, but it seems a good one.
    // ReportEvent has too many parameters, those three integers instead of one.
    const WORD  wCategory = 0/*static_cast<WORD>(HRESULT_FACILITY(dwEventId) & 0xff)*/;
    const DWORD dwDataSize = 0;
    void const* const pvRawData = NULL;
    const PSID pSecurityIdentifier = NULL;

    if (!::FusionpOpenEventLog())
    {
        goto Exit;
    }
    else
    {
        NTSTATUS status;
        status = ::ElfReportEventW(
            g_hEventLog,
            wType,
            wCategory,
            dwEventId,
            pSecurityIdentifier,
            static_cast<USHORT>(nStrings),
            dwDataSize,
            const_cast<PUNICODE_STRING*>(rgps),
            const_cast<void*>(pvRawData),
            0,
            NULL,
            NULL);
        //
        // the excluded error status is because it is in the early setup time.
        //
        if (!NT_SUCCESS(status))
        {
             if (status != RPC_NT_SERVER_UNAVAILABLE)
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: FusionpLogError/ElfReportEventW failed %lx\n", static_cast<ULONG>(status));
            goto Exit;
        }
    }
Exit:
    ::SetLastError(lastError);
    return hr;
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

HRESULT
FusionpLogError(
    DWORD dwEventId,
    ULONG nStrings,
    const PCUNICODE_STRING * rgps
    )
{
    const HRESULT hr = FusionpLogErrorToEventLog(dwEventId, nStrings, rgps);
    const HRESULT hr2 = FusionpLogErrorToDebugger(dwEventId, nStrings, rgps);
    RETAIL_UNUSED(hr);
    RETAIL_UNUSED(hr2);
    ASSERT_NTC(hr == hr2);

    return hr;
}

HRESULT
FusionpLogParseError(
    PCWSTR FilePath,
    SIZE_T FilePathCch,
    ULONG LineNumber,
    DWORD dwLastParseError,
    PCUNICODE_STRING p1,
    PCUNICODE_STRING p2,
    PCUNICODE_STRING p3,
    PCUNICODE_STRING p4,
    PCUNICODE_STRING p5,
    PCUNICODE_STRING p6,
    PCUNICODE_STRING p7,
    PCUNICODE_STRING p8,
    PCUNICODE_STRING p9,
    PCUNICODE_STRING p10,
    PCUNICODE_STRING p11,
    PCUNICODE_STRING p12,
    PCUNICODE_STRING p13,
    PCUNICODE_STRING p14,
    PCUNICODE_STRING p15,
    PCUNICODE_STRING p16,
    PCUNICODE_STRING p17,
    PCUNICODE_STRING p18,
    PCUNICODE_STRING p19,
    PCUNICODE_STRING p20
    )
{
    const DWORD lastError = ::FusionpEventIdToError(dwLastParseError);
    const HRESULT hr = HRESULT_FROM_WIN32(lastError);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: %s() entered\n", __FUNCTION__);

    //
    // FormatMessage (actually sprintf) AVs on NULL UNICODE_STRING*
    // and/or when we don't pass enough of them;
    // we can't tell it how many strings we are passing,
    // and it isn't easy to tell how many it needs,
    // so we load it up with a bunch of extra non NULL ones.
    // Besides that, we have holes to fill.
    //
    static const UNICODE_STRING s_strEmptyUnicodeString = { 0, 0, L""};
    static const PCUNICODE_STRING s_rgpsEmptyStrings[] =
    {
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString,
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString,
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString,
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString,
        &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString, &s_strEmptyUnicodeString
    };
    PCUNICODE_STRING rgpsAll[NUMBER_OF(s_rgpsEmptyStrings)];

    ::memcpy(rgpsAll, s_rgpsEmptyStrings, sizeof(rgpsAll));

#define HANDLE_STRING(_n) do { if (p ## _n != NULL) rgpsAll[_n - 1] = p ## _n; } while (0)

    HANDLE_STRING(1);
    HANDLE_STRING(2);
    HANDLE_STRING(3);
    HANDLE_STRING(4);
    HANDLE_STRING(5);
    HANDLE_STRING(6);
    HANDLE_STRING(7);
    HANDLE_STRING(8);
    HANDLE_STRING(9);
    HANDLE_STRING(10);
    HANDLE_STRING(11);
    HANDLE_STRING(12);
    HANDLE_STRING(13);
    HANDLE_STRING(14);
    HANDLE_STRING(15);
    HANDLE_STRING(16);
    HANDLE_STRING(17);
    HANDLE_STRING(18);
    HANDLE_STRING(19);
    HANDLE_STRING(20);

#undef HANDLE_STRING

    //
    // form up some "context" UNICODE_STRINGs and put them in the array of pointers
    // the first two are the ones that we always use, even for DbgPrint
    //
    CEventLogString file(FilePath, FilePathCch);
    CEventLogInteger lineNumber(LineNumber);

    rgpsAll[PARSE_CONTEXT_FILE - 1] = &file;
    rgpsAll[PARSE_CONTEXT_LINE - 1] = &lineNumber;

    ::FusionpLogErrorToEventLog(
        dwLastParseError,
        NUMBER_OF(rgpsAll),
        rgpsAll);

    // we should tell this function that it was a parse error and to do
    // the context munging, but it detects it itself imperfectly
    ::FusionpLogErrorToDebugger(dwLastParseError, NUMBER_OF(rgpsAll), rgpsAll);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: %s():%#lx exited\n", __FUNCTION__, hr);

    ::SetLastError(lastError);
    return hr;
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

VOID
FusionpLogRequiredAttributeMissingParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    )
{
    ::FusionpLogParseError(
        SourceFilePath,
        SourceFileCch,
        LineNumber,
        MSG_SXS_XML_REQUIRED_ATTRIBUTE_MISSING,
        CEventLogString(ElementName, ElementNameCch),
        CEventLogString(AttributeName, AttributeNameCch));
}

VOID
FusionpLogInvalidAttributeValueParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    )
{
    ::FusionpLogParseError(
        SourceFilePath,
        SourceFileCch,
        LineNumber,
        MSG_SXS_XML_INVALID_ATTRIBUTE_VALUE,
        CEventLogString(ElementName, ElementNameCch),
        CEventLogString(AttributeName, AttributeNameCch));
}

VOID
FusionpLogInvalidAttributeValueParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE &rAttribute
    )
{
    ::FusionpLogInvalidAttributeValueParseError(
        SourceFilePath,
        SourceFileCch,
        LineNumber,
        ElementName,
        ElementNameCch,
        rAttribute.Name,
        rAttribute.NameCch);
}

VOID
FusionpLogAttributeNotAllowedParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    )
{
    ::FusionpLogParseError(
        SourceFilePath,
        SourceFileCch,
        LineNumber,
        MSG_SXS_XML_ATTRIBUTE_NOT_ALLOWED,
        CEventLogString(ElementName, ElementNameCch),
        CEventLogString(AttributeName, AttributeNameCch));
}

VOID
FusionpLogWin32ErrorToEventLog()
{
    DWORD dwLastError = ::FusionpGetLastWin32Error();
    if (dwLastError == 0 )
        return;
    FusionpLogError(MSG_SXS_WIN32_ERROR_MSG, CEventLogLastError(dwLastError));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\eventlog\stdinc.h ===
// Copyright (c) Microsoft Corporation
#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include "fusionunused.h"
#define MAXDWORD (~(DWORD)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\eventlog\win2000\makefile.inc ===
# makefile.inc

$(O)\MSG00409.bin : ..\Messages.x
$(O)\message.h : $(O)\Messages.mc

$(O)\Messages.hi : ..\Messages.x
	@echo Creating $@ from $?
	$(C_PREPROCESSOR_NAME) /DCPLUSPLUS_INVOKED $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\Messages.mc : ..\Messages.x
	@echo Creating $@ from $?
	$(C_PREPROCESSOR_NAME) /DMC_INVOKED $(C_PREPROCESSOR_FLAGS) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\eventlog\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Michael Grier

!ENDIF

MAJORCOMP=fusion
MINORCOMP=eventlog

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)eventlog
TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)
INCLUDES=..;$(FUSION_INC_PATH);$(INCLUDES)

MC_FLAGS=-b

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

NTTARGETFILE0= \
    $(O)\Messages.hi \
    $(O)\Messages.mc \
    $(O)\Messages.h

SOURCES= \
    ..\eventlog.cpp \
    $(O)\Messages.mc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\eventlog\whistler\makefile.inc ===
# makefile.inc

$(O)\MSG00409.bin : ..\Messages.x
$(O)\message.h : $(O)\Messages.mc

$(O)\Messages.hi : ..\Messages.x
	@echo Creating $@ from $?
	$(C_PREPROCESSOR_NAME) /DCPLUSPLUS_INVOKED $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\Messages.mc : ..\Messages.x
	@echo Creating $@ from $?
	$(C_PREPROCESSOR_NAME) /DMC_INVOKED $(C_PREPROCESSOR_FLAGS) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\gencomctlt\gencomctlt.cpp ===
/*
Copyright (c) Microsoft Corporation
generate comctl tool
based on gennt32t
*/
#pragma warning( disable : 4786) //disable identifier is too long for debugging error
#pragma warning( disable : 4503) //disable decorated name is too long
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <sstream>
#include <set>
#include <map>

extern "C" {

#include "gen.h"

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#endif

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'GENCOMCTLT' ";

void
HandlePreprocessorDirective(
   char *p
   )
{
   ExitErrMsg(FALSE, "Preprocessor directives not allowed by gencomctlt.\n");
}

}

using namespace std;
typedef string String;

PRBTREE pFunctions = NULL;
PRBTREE pStructures = NULL;
PRBTREE pTypedefs = NULL;

void ExtractCVMHeader(PCVMHEAPHEADER pHeader) {
   pFunctions = &pHeader->FuncsList;
   pTypedefs =  &pHeader->TypeDefsList;
   pStructures =&pHeader->StructsList;
}

// globals so debugging works
PKNOWNTYPES pFunction; 
PFUNCINFO   pfuncinfo;

void DumpFunctionDeclarationsHeader(void)
{
    //PKNOWNTYPES pFunction; 
    //PFUNCINFO   pfuncinfo;

    cout << "///////////////////////////////////////////\n";
    cout << "// This file is autogenerated by gencomctlt. \n";
    cout << "// Do not edit                             \n";
    cout << "///////////////////////////////////////////\n";
    cout << '\n' << '\n';

    cout << "#include \"windows.h\"\n";
    cout << "#include \"commctrl.h\"\n\n";

    cout << "///////////////////////////////////////////\n";
    cout << "//  Functions                            //\n";
    cout << "///////////////////////////////////////////\n";
    for (
        pFunction = pFunctions->pLastNodeInserted;
        pFunction != NULL
            && pFunction->TypeName != NULL
            && strcmp(pFunction->TypeName, "MarkerFunction_8afccfaa_27e7_45d5_8ff7_7ac0b970789d") != 0 ;
        pFunction = pFunction->Next)
    {
    /*
    for now, just like print out commctrl as a demo/test of understanding the tool
    tomorrow, print out what we actually need
    */
        cout << pFunction->FuncRet << ' ';
        cout << pFunction->FuncMod << ' '; // __stdcall
        cout << pFunction->TypeName << "(\n"; // function name
        pfuncinfo = pFunction->pfuncinfo;
        if (pfuncinfo == NULL || pfuncinfo->sType == NULL || pfuncinfo->sName == NULL)
        {
            cout << "void";
        }
        else
        {
            for ( ; pfuncinfo != NULL ; pfuncinfo = pfuncinfo->pfuncinfoNext )
            {
                cout << ' ' << pfuncinfo->sType << ' ' << pfuncinfo->sName << ",\n";
            }
        }
        cout << ")\n";
    }
    cout << '\n' << '\n';
}

int __cdecl main(int argc, char*argv[])
{
    ExtractCVMHeader(MapPpmFile(argv[1], TRUE));
    DumpFunctionDeclarationsHeader();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\id\stdinc.h ===
// Copyright (c) Microsoft Corporation
#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include "fusionunused.h"
#define MAXDWORD (~(DWORD)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\id\encdec.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsasmidencdec.c

Abstract:

    Implementation of the encoding/decoding support for the assembly identity data type.

Author:

    Michael Grier (MGrier) 7/28/2000

Revision History:

--*/
#include "stdinc.h"
#include <setupapi.h>
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>
#include "idp.h"
static const WCHAR s_rgHexChars[] = L"0123456789abcdef";

BOOL
SxspValidateXMLName(
    PCWSTR psz,
    SIZE_T cch,
    bool &rfValid
    );

typedef struct _CHARPAIR
{
    WCHAR wchStart;
    WCHAR wchEnd;
} CHARPAIR, *PCHARPAIR;

typedef const CHARPAIR *PCCHARPAIR;

const CHARPAIR s_rgXMLBaseChar[] =
{
    { 0x0041, 0x005a },
    { 0x0061, 0x007a },
    { 0x00c0, 0x00d6 },
    { 0x00d8, 0x00f6 },
    { 0x00f8, 0x00ff },
    { 0x0100, 0x0131 },
    { 0x0134, 0x013e },
    { 0x0141, 0x0148 },
    { 0x014a, 0x017e },
    { 0x0180, 0x01c3 },
    { 0x01cd, 0x01f0 },
    { 0x01f4, 0x01f5 },
    { 0x01fa, 0x0217 },
    { 0x0250, 0x02a8 },
    { 0x02bb, 0x02c1 },
    { 0x0386, 0x0386 },
    { 0x0388, 0x038a },
    { 0x038c, 0x038c },
    { 0x038e, 0x03a1 },
    { 0x03a3, 0x03ce },
    { 0x03d0, 0x03d6 },
    { 0x03da, 0x03da },
    { 0x03dc, 0x03dc },
    { 0x03de, 0x03de },
    { 0x03e0, 0x03e0 },
    { 0x03e2, 0x03f3 },
    { 0x0401, 0x040c },
    { 0x040e, 0x044f },
    { 0x0451, 0x045c },
    { 0x045e, 0x0481 },
    { 0x0490, 0x04c4 },
    { 0x04c7, 0x04c8 },
    { 0x04cb, 0x04cc },
    { 0x04d0, 0x04eb },
    { 0x04ee, 0x04f5 },
    { 0x04f8, 0x04f9 },
    { 0x0531, 0x0556 },
    { 0x0559, 0x0559 },
    { 0x0561, 0x0586 },
    { 0x05d0, 0x05ea },
    { 0x05f0, 0x05f2 },
    { 0x0621, 0x063a },
    { 0x0641, 0x064a },
    { 0x0671, 0x06b7 },
    { 0x06ba, 0x06be },
    { 0x06c0, 0x06ce },
    { 0x06d0, 0x06d3 },
    { 0x06d5, 0x06d5 },
    { 0x06e5, 0x06e6 },
    { 0x0905, 0x0939 },
    { 0x093d, 0x093d },
    { 0x0958, 0x0961 },
    { 0x0985, 0x098c },
    { 0x098f, 0x0990 },
    { 0x0993, 0x09a8 },
    { 0x09aa, 0x09b0 },
    { 0x09b2, 0x09b2 },
    { 0x09b6, 0x09b9 },
    { 0x09dc, 0x09dd },
    { 0x09df, 0x09e1 },
    { 0x09f0, 0x09f1 },
    { 0x0a05, 0x0a0a },
    { 0x0a0f, 0x0a10 },
    { 0x0a13, 0x0a28 },
    { 0x0a2a, 0x0a30 },
    { 0x0a32, 0x0a33 },
    { 0x0a35, 0x0a36 },
    { 0x0a38, 0x0a39 },
    { 0x0a59, 0x0a5c },
    { 0x0a5e, 0x0a5e },
    { 0x0a72, 0x0a74 },
    { 0x0a85, 0x0a8b },
    { 0x0a8d, 0x0a8d },
    { 0x0a8f, 0x0a91 },
    { 0x0a93, 0x0aa8 },
    { 0x0aaa, 0x0ab0 },
    { 0x0ab2, 0x0ab3 },
    { 0x0ab5, 0x0ab9 },
    { 0x0abd, 0x0abd },
    { 0x0ae0, 0x0ae0 },
    { 0x0b05, 0x0b0c },
    { 0x0b0f, 0x0b10 },
    { 0x0b13, 0x0b28 },
    { 0x0b2a, 0x0b30 },
    { 0x0b32, 0x0b33 },
    { 0x0b36, 0x0b39 },
    { 0x0b3d, 0x0b3d },
    { 0x0b5c, 0x0b5d },
    { 0x0b5f, 0x0b61 },
    { 0x0b85, 0x0b8a },
    { 0x0b8e, 0x0b90 },
    { 0x0b92, 0x0b95 },
    { 0x0b99, 0x0b9a },
    { 0x0b9c, 0x0b9c },
    { 0x0b9e, 0x0b9f },
    { 0x0ba3, 0x0ba4 },
    { 0x0ba8, 0x0baa },
    { 0x0bae, 0x0bb5 },
    { 0x0bb7, 0x0bb9 },
    { 0x0c05, 0x0c0c },
    { 0x0c0e, 0x0c10 },
    { 0x0c12, 0x0c28 },
    { 0x0c2a, 0x0c33 },
    { 0x0c35, 0x0c39 },
    { 0x0c60, 0x0c61 },
    { 0x0c85, 0x0c8c },
    { 0x0c8e, 0x0c90 },
    { 0x0c92, 0x0ca8 },
    { 0x0caa, 0x0cb3 },
    { 0x0cb5, 0x0cb9 },
    { 0x0cde, 0x0cde },
    { 0x0ce0, 0x0ce1 },
    { 0x0d05, 0x0d0c },
    { 0x0d0e, 0x0d10 },
    { 0x0d12, 0x0d28 },
    { 0x0d2a, 0x0d39 },
    { 0x0d60, 0x0d61 },
    { 0x0e01, 0x0e2e },
    { 0x0e30, 0x0e30 },
    { 0x0e32, 0x0e33 },
    { 0x0e40, 0x0e45 },
    { 0x0e81, 0x0e82 },
    { 0x0e84, 0x0e84 },
    { 0x0e87, 0x0e88 },
    { 0x0e8a, 0x0e8a },
    { 0x0e8d, 0x0e8d },
    { 0x0e94, 0x0e97 },
    { 0x0e99, 0x0e9f },
    { 0x0ea1, 0x0ea3 },
    { 0x0ea5, 0x0ea5 },
    { 0x0ea7, 0x0ea7 },
    { 0x0eaa, 0x0eab },
    { 0x0ead, 0x0eae },
    { 0x0eb0, 0x0eb0 },
    { 0x0eb2, 0x0eb3 },
    { 0x0ebd, 0x0ebd },
    { 0x0ec0, 0x0ec4 },
    { 0x0f40, 0x0f47 },
    { 0x0f49, 0x0f69 },
    { 0x10a0, 0x10c5 },
    { 0x10d0, 0x10f6 },
    { 0x1100, 0x1100 },
    { 0x1102, 0x1103 },
    { 0x1105, 0x1107 },
    { 0x1109, 0x1109 },
    { 0x110b, 0x110c },
    { 0x110e, 0x1112 },
    { 0x113c, 0x113c },
    { 0x113e, 0x113e },
    { 0x1140, 0x1140 },
    { 0x114c, 0x114c },
    { 0x114e, 0x114e },
    { 0x1150, 0x1150 },
    { 0x1154, 0x1155 },
    { 0x1159, 0x1159 },
    { 0x115f, 0x1161 },
    { 0x1163, 0x1163 },
    { 0x1165, 0x1165 },
    { 0x1167, 0x1167 },
    { 0x1169, 0x1169 },
    { 0x116d, 0x116e },
    { 0x1172, 0x1173 },
    { 0x1175, 0x1175 },
    { 0x119e, 0x119e },
    { 0x11a8, 0x11a8 },
    { 0x11ab, 0x11ab },
    { 0x11ae, 0x11af },
    { 0x11b7, 0x11b8 },
    { 0x11ba, 0x11ba },
    { 0x11bc, 0x11c2 },
    { 0x11eb, 0x11eb },
    { 0x11f0, 0x11f0 },
    { 0x11f9, 0x11f9 },
    { 0x1e00, 0x1e9b },
    { 0x1ea0, 0x1ef9 },
    { 0x1f00, 0x1f15 },
    { 0x1f18, 0x1f1d },
    { 0x1f20, 0x1f45 },
    { 0x1f48, 0x1f4d },
    { 0x1f50, 0x1f57 },
    { 0x1f59, 0x1f59 },
    { 0x1f5b, 0x1f5b },
    { 0x1f5d, 0x1f5d },
    { 0x1f5f, 0x1f7d },
    { 0x1f80, 0x1fb4 },
    { 0x1fb6, 0x1fbc },
    { 0x1fbe, 0x1fbe },
    { 0x1fc2, 0x1fc4 },
    { 0x1fc6, 0x1fcc },
    { 0x1fd0, 0x1fd3 },
    { 0x1fd6, 0x1fdb },
    { 0x1fe0, 0x1fec },
    { 0x1ff2, 0x1ff4 },
    { 0x1ff6, 0x1ffc },
    { 0x2126, 0x2126 },
    { 0x212a, 0x212b },
    { 0x212e, 0x212e },
    { 0x2180, 0x2182 },
    { 0x3041, 0x3094 },
    { 0x30a1, 0x30fa },
    { 0x3105, 0x312c },
    { 0xac00, 0xd7a3 },
};

BOOL
SxsComputeAssemblyIdentityEncodedSize(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL,
    IN ULONG EncodingFormat,
    OUT SIZE_T *SizeOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T Size = 0;
    ULONG i;
    ULONG AttributeCount, NamespaceCount;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;

    if (SizeOut != NULL)
        *SizeOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(SizeOut != NULL);

    if (EncodingGroup != NULL)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingGroup, ERROR_SXS_UNKNOWN_ENCODING_GROUP);

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingId, ERROR_SXS_UNKNOWN_ENCODING);

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    AttributeCount = AssemblyIdentity->AttributeCount;
    NamespaceCount = AssemblyIdentity->NamespaceCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;
    NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

    switch (EncodingFormat)
    {
    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY:
        // NTRAID#NTBUG9 - 586520 - 2002/03/26 - xiaoyuw:
        //  - this function calculate the encoded size of assembly identity: 
        //    if it overflow, what to do...


        // First, we know we need a header.

        Size = sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);

        // Then a ULONG hash per attribute:
        Size += (AssemblyIdentity->AttributeCount * sizeof(ULONG));

        // Then a ULONG per namespace...
        Size += (AssemblyIdentity->NamespaceCount * sizeof(ULONG));

        // Then we need an attribute header per attribute:

        Size += AssemblyIdentity->AttributeCount * sizeof(ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER);

        // Then come the namespace strings...

        for (i=0; i<NamespaceCount; i++)
            Size += NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR);

        // Then we need space for each of the attributes' names and value.

        AttributePointerArray = AssemblyIdentity->AttributePointerArray;

        for (i=0; i<AttributeCount; i++)
        {
            INTERNAL_ERROR_CHECK(AttributePointerArray[i] != NULL);

            Size += AttributePointerArray[i]->Attribute.NameCch * sizeof(WCHAR);
            Size += AttributePointerArray[i]->Attribute.ValueCch * sizeof(WCHAR);
        }

        // We should at least be byte aligned here...
        ASSERT((Size % 2) == 0);

        // And finally pad out to a multiple of four if we are not...
        Size = (Size + 3) & ~3;

        break;

    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL:
        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute = AttributePointerArray[i];
            BOOL IsAssemblyName = FALSE;
            SIZE_T BytesThisAttribute = 0;

            INTERNAL_ERROR_CHECK(Attribute != NULL);

            IFW32FALSE_EXIT(::SxspIsInternalAssemblyIdentityAttribute(
                                0,
                                Attribute,
                                NULL,
                                0,
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
                                NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1,
                                &IsAssemblyName));

            // It's the attribute name.  Just account for the size of the encoded value string
            IFW32FALSE_EXIT(::SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
                            IsAssemblyName ?
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY |
                                    SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES
                                    : 0,
                            Attribute,
                            &BytesThisAttribute));

            // Account for the separator character
            if (i != 0)
                Size += sizeof(WCHAR);

            Size += BytesThisAttribute;
        }

        break;
    }

    *SizeOut = Size;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

SIZE_T
__fastcall
SxspComputeQuotedStringSize(
    IN const WCHAR *StringIn,
    IN SIZE_T Cch
    )
{
    SIZE_T Bytes = 0;

    while (Cch != 0)
    {
        const WCHAR wch = *StringIn++;

        if (((wch >= L'A') && (wch <= L'Z')) ||
            ((wch >= L'a') && (wch <= L'z')) ||
            ((wch >= L'0') && (wch <= L'9')) ||
            (wch == L'.') ||
            (wch == L'-') ||
            (wch == L'_'))
        {
            Bytes += sizeof(WCHAR);
        }
        else
        {
            switch (wch)
            {
            case L'&':
                // &amp;
                Bytes += (5 * sizeof(WCHAR));
                break;

            case L'"':
                // &quot;
                Bytes += (6 * sizeof(WCHAR));
                break;

            case L'<':
                // &lt;
                Bytes += (4 * sizeof(WCHAR));
                break;

            case L'>':
                // &gt;
                Bytes += (4 * sizeof(WCHAR));
                break;

            case L'\'':
                // &apos;
                Bytes += (6 * sizeof(WCHAR));
                break;

            default:
                // Otherwise, it's going to be &#xn;
                if (wch < 0x10)
                    Bytes += (5 * sizeof(WCHAR));
                else if (wch < 0x100)
                    Bytes += (6 * sizeof(WCHAR));
                else if (wch < 0x1000)
                    Bytes += (7 * sizeof(WCHAR));
                else
                    Bytes += (8 * sizeof(WCHAR));
                break;
            }
        }

        Cch--;
    }

    return Bytes;
}

BOOL
SxspDequoteString(
    IN DWORD dwFlags,
    IN PCWSTR pcwszStringIn,
    IN SIZE_T cchStringIn,
    OUT PWSTR pwszStringOut,
    OUT SIZE_T *pcchStringOut
    )
{
    FN_PROLOG_WIN32

    PCWSTR pcwszInputCursor = pcwszStringIn;
    PWSTR pwszOutputCursor = pwszStringOut;
    PCWSTR pcwszInputCursorEnd = pcwszStringIn + cchStringIn;
    SIZE_T cchOutputRemaining = 0;
    BOOL fInsufficient = FALSE;

    PARAMETER_CHECK(dwFlags == 0);

    if (pcchStringOut != NULL)
    {
        cchOutputRemaining = *pcchStringOut;
        *pcchStringOut = 0;
    }

    if (pwszStringOut != NULL)
        pwszStringOut[0] = UNICODE_NULL;

    PARAMETER_CHECK(pcchStringOut != NULL);

    //
    // reserve one wchar for trailing NULL
    //
#define APPEND_OUTPUT_CHARACTER( toadd ) { \
    if ( cchOutputRemaining > 1 ) { \
        *pwszOutputCursor++ = (toadd); \
        cchOutputRemaining--; \
        (*pcchStringOut)++; \
    } else fInsufficient = TRUE; \
}

#define CONTAINS_TAG(tag) (::FusionpCompareStrings(pcwszInputCursor, cchToNextSemicolon, (tag), NUMBER_OF(tag)-1, false) == 0)

#define REPLACE_TAG( tag, newchar ) if ( CONTAINS_TAG(tag) ) { APPEND_OUTPUT_CHARACTER(newchar) }

    //
    // Zing through the input string until there's nothing left
    //
    while ((pcwszInputCursor < pcwszInputCursorEnd) && (!fInsufficient))
    {
        const WCHAR wchCurrent = *pcwszInputCursor;

        // Something we know and love?
        if (wchCurrent == L'&')
        {
            pcwszInputCursor++;
            SIZE_T cchToNextSemicolon = StringComplimentSpan(
                pcwszInputCursor,
                pcwszInputCursorEnd,
                L";");
            PCWSTR pcwszSemicolon = pcwszInputCursor + cchToNextSemicolon;

            REPLACE_TAG(L"amp", L'&')
            else REPLACE_TAG(L"quot", L'"')
            else REPLACE_TAG(L"lt", L'<')
            else REPLACE_TAG(L"gt", L'>')
            else REPLACE_TAG(L"apos", L'\'')
            // This might be an encoded character...
            else if ( cchToNextSemicolon >= 2 )
            {
                bool fIsHexString = false;
                WCHAR wchReplacement = 0;

                // The only non-chunk think accepted is the # character
                PARAMETER_CHECK(*pcwszInputCursor == L'#');

                // which means we've skipped one
                pcwszInputCursor++;

                fIsHexString = (*pcwszInputCursor == L'x') || (*pcwszInputCursor == 'X');
                if (fIsHexString) {
                    pcwszInputCursor++;
                }

                while ( pcwszInputCursor != pcwszSemicolon )
                {
                    if ( fIsHexString )
                    {
                        wchReplacement <<= 4;
                        switch ( *pcwszInputCursor++ ) {
                        case L'0' : break;
                        case L'1' : wchReplacement += 0x1; break;
                        case L'2' : wchReplacement += 0x2; break;
                        case L'3' : wchReplacement += 0x3; break;
                        case L'4' : wchReplacement += 0x4; break;
                        case L'5' : wchReplacement += 0x5; break;
                        case L'6' : wchReplacement += 0x6; break;
                        case L'7' : wchReplacement += 0x7; break;
                        case L'8' : wchReplacement += 0x8; break;
                        case L'9' : wchReplacement += 0x9; break;
                        case L'a': case L'A': wchReplacement += 0xA; break;
                        case L'b': case L'B': wchReplacement += 0xB; break;
                        case L'c': case L'C': wchReplacement += 0xC; break;
                        case L'd': case L'D': wchReplacement += 0xD; break;
                        case L'e': case L'E': wchReplacement += 0xE; break;
                        case L'f': case L'F': wchReplacement += 0xF; break;
                        default:
                            PARAMETER_CHECK(FALSE && L"wchReplacement contains a non-hex digit");
                            break;
                        }
                    }
                    else
                    {
                        wchReplacement *= 10;
                        switch ( *pcwszInputCursor++ ) {
                        case L'0' : break;
                        case L'1' : wchReplacement += 0x1; break;
                        case L'2' : wchReplacement += 0x2; break;
                        case L'3' : wchReplacement += 0x3; break;
                        case L'4' : wchReplacement += 0x4; break;
                        case L'5' : wchReplacement += 0x5; break;
                        case L'6' : wchReplacement += 0x6; break;
                        case L'7' : wchReplacement += 0x7; break;
                        case L'8' : wchReplacement += 0x8; break;
                        case L'9' : wchReplacement += 0x9; break;
                        default:
                            PARAMETER_CHECK(FALSE && "wchReplacement contains a non-decimal digit");
                            break;
                        }
                    }
                }

                APPEND_OUTPUT_CHARACTER(wchReplacement);
            }

            if (!fInsufficient) 
                pcwszInputCursor = pcwszSemicolon + 1;
        }
        // Otherwise, simply copy the character to the output string
        else
        {
            APPEND_OUTPUT_CHARACTER(wchCurrent);
            if (!fInsufficient) 
                pcwszInputCursor++;
        }
    }

    if (fInsufficient)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    pwszStringOut[*pcchStringOut] = L'\0';

    FN_EPILOG
}

BOOL
SxspQuoteString(
    IN DWORD Flags,
    IN const WCHAR *StringIn,
    IN SIZE_T Cch,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT SIZE_T *BytesWrittenOut
    )
{
    BOOL fSuccess = FALSE;
    WCHAR *Cursor;
    SIZE_T BytesWritten = 0;
    SIZE_T BytesLeft = BufferSize;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    W32PARAMETER_CHECK_NTC(Flags == 0);
    W32PARAMETER_CHECK_NTC(StringIn != NULL || Cch == 0);
    W32PARAMETER_CHECK_NTC(Buffer != NULL || BufferSize == 0);

    Cursor = (WCHAR *) Buffer;
    BytesWritten = 0;

    while (Cch != 0)
    {
        const WCHAR wch = *StringIn++;

        if (((wch >= L'A') && (wch <= L'Z')) ||
            ((wch >= L'a') && (wch <= L'z')) ||
            ((wch >= L'0') && (wch <= L'9')) ||
            (wch == L'.') ||
            (wch == L'-') ||
            (wch == L'_'))
        {
            if (BytesLeft < sizeof(WCHAR))
                ORIGINATE_WIN32_FAILURE_AND_EXIT_NTC(NoRoom, ERROR_INSUFFICIENT_BUFFER);

            *Cursor++ = wch;
            BytesLeft -= sizeof(WCHAR);
            BytesWritten += sizeof(WCHAR);
        }
        else
        {

#define HANDLE_CASE(_wch, _wstr) \
            case _wch: \
            { \
            ULONG i; \
            if (BytesLeft < (sizeof(_wstr) - sizeof(WCHAR))) \
                ORIGINATE_WIN32_FAILURE_AND_EXIT_NTC(NoRoom, ERROR_INSUFFICIENT_BUFFER); \
            for (i=0; i<(NUMBER_OF(_wstr) - 1); i++) \
                *Cursor++ = _wstr[i]; \
            BytesLeft -= (sizeof(_wstr) - sizeof(WCHAR)); \
            BytesWritten += (sizeof(_wstr) - sizeof(WCHAR)); \
            break; \
            }

            switch (wch)
            {
            HANDLE_CASE(L'"', L"&quot;")
            HANDLE_CASE(L'&', L"&amp;")
            HANDLE_CASE(L'<', L"&lt;")
            HANDLE_CASE(L'>', L"&gt;")
            HANDLE_CASE(L'\'', L"&apos;")

            default:
                if (wch < 0x10)
                {
                    if (BytesLeft < (5 * sizeof(WCHAR)))
                        ORIGINATE_WIN32_FAILURE_AND_EXIT_NTC(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[wch];
                    *Cursor++ = L';';

                    BytesWritten += (5 * sizeof(WCHAR));
                    BytesLeft -= (5 * sizeof(WCHAR));
                }
                else if (wch < 0x100)
                {
                    if (BytesLeft < (6 * sizeof(WCHAR)))
                        ORIGINATE_WIN32_FAILURE_AND_EXIT_NTC(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (6 * sizeof(WCHAR));
                    BytesLeft -= (6 * sizeof(WCHAR));
                }
                else if (wch < 0x1000)
                {
                    if (BytesLeft < (7 * sizeof(WCHAR)))
                        ORIGINATE_WIN32_FAILURE_AND_EXIT_NTC(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 8) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (7 * sizeof(WCHAR));
                    BytesLeft -= (7 * sizeof(WCHAR));
                }
                else
                {
                    W32INTERNAL_ERROR_CHECK_NTC(wch <= 0xffff);

                    if (BytesLeft < (8 * sizeof(WCHAR)))
                        ORIGINATE_WIN32_FAILURE_AND_EXIT_NTC(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                    *Cursor++ = L'&';
                    *Cursor++ = L'#';
                    *Cursor++ = L'x';
                    *Cursor++ = s_rgHexChars[(wch >> 12) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 8) & 0xf];
                    *Cursor++ = s_rgHexChars[(wch >> 4) & 0xf];
                    *Cursor++ = s_rgHexChars[wch & 0xf];
                    *Cursor++ = L';';

                    BytesWritten += (8 * sizeof(WCHAR));
                    BytesLeft -= (8 * sizeof(WCHAR));
                }

                break;
            }

        }

        Cch--;
    }

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT SIZE_T *BytesOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T Bytes = 0;

    if (BytesOut != NULL)
        *BytesOut = 0;

    PARAMETER_CHECK((Flags & ~(
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY |
                                SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES)) == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(BytesOut != NULL);

    Bytes = 0;
    if ((Flags & SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY) == 0)
    {
        if (Attribute->Attribute.NamespaceCch != 0)
        {
            // Figure out the ns:n= part
            Bytes += ::SxspComputeQuotedStringSize(Attribute->Attribute.Namespace, Attribute->Attribute.NamespaceCch);
            Bytes += sizeof(WCHAR); // the ":"
        }

        Bytes += ::SxspComputeQuotedStringSize(Attribute->Attribute.Name, Attribute->Attribute.NameCch);
        Bytes += sizeof(WCHAR); // the "="
    }

    Bytes += ::SxspComputeQuotedStringSize(Attribute->Attribute.Value, Attribute->Attribute.ValueCch);

    if ((Flags & SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES) == 0)
        Bytes += 2 * sizeof(WCHAR); // the beginning and ending quotes

    *BytesOut = Bytes;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEncodeInternalAssemblyIdentityAttributeAsText(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PVOID Buffer,
    SIZE_T *BytesWrittenOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesWritten = 0;
    SIZE_T BytesLeft = 0;
    SIZE_T BytesThisSegment;
    WCHAR *Cursor;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK((Buffer != NULL) || (BufferSize == 0));

    BytesWritten = 0;
    BytesLeft = BufferSize;
    Cursor = reinterpret_cast<WCHAR *>(Buffer);

    if (Attribute->Attribute.NamespaceCch != 0)
    {
        IFW32FALSE_EXIT(::SxspQuoteString(0, Attribute->Namespace->Namespace, Attribute->Namespace->NamespaceCch, BytesLeft, Cursor, &BytesThisSegment));

        INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

        Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
        BytesLeft -= BytesThisSegment;
        BytesWritten += BytesThisSegment;

        if (BytesLeft < sizeof(WCHAR))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

        *Cursor++ = L':';
        BytesLeft -= sizeof(WCHAR);
        BytesWritten += sizeof(WCHAR);
    }

    IFW32FALSE_EXIT(::SxspQuoteString(0, Attribute->Attribute.Name, Attribute->Attribute.NameCch, BytesLeft, Cursor, &BytesThisSegment));

    INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

    Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
    BytesLeft -= BytesThisSegment;
    BytesWritten += BytesThisSegment;

    if (BytesLeft < (2 * sizeof(WCHAR)))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    *Cursor++ = L'=';
    *Cursor++ = L'"';
    BytesLeft -= (2 * sizeof(WCHAR));
    BytesWritten += (2 * sizeof(WCHAR));

    IFW32FALSE_EXIT(::SxspQuoteString(0, Attribute->Attribute.Value, Attribute->Attribute.ValueCch, BytesLeft, Cursor, &BytesThisSegment));

    INTERNAL_ERROR_CHECK(BytesThisSegment <= BytesLeft);

    Cursor = (WCHAR *) (((ULONG_PTR) Cursor) + BytesThisSegment);
    BytesLeft -= BytesThisSegment;
    BytesWritten += BytesThisSegment;

    if (BytesLeft < sizeof(WCHAR))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    *Cursor++ = L'"';
    BytesLeft -= sizeof(WCHAR);
    BytesWritten += sizeof(WCHAR);

    *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEncodeAssemblyIdentityTextually(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT SIZE_T *BytesWrittenOut)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG AttributeCount, NamespaceCount;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes;
    PCASSEMBLY_IDENTITY_NAMESPACE *Namespaces;
    ULONG i;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NameInternalAttribute = NULL;
    SIZE_T BytesLeft;
    SIZE_T BytesWritten;
    PVOID Cursor;
    SIZE_T TempBytesWritten;

    if (BytesWrittenOut != NULL)
        *BytesWrittenOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(BufferSize != 0);
    PARAMETER_CHECK(Buffer != NULL);
    PARAMETER_CHECK(BytesWrittenOut != NULL);

    Cursor = Buffer;
    BytesLeft = BufferSize;
    BytesWritten = 0;

    // The root assembly identity is actually totally empty, so we'll short-circuit that case.
    AttributeCount = AssemblyIdentity->AttributeCount;
    if (AttributeCount != 0)
    {
        NamespaceCount = AssemblyIdentity->NamespaceCount;
        Attributes = AssemblyIdentity->AttributePointerArray;
        Namespaces = AssemblyIdentity->NamespacePointerArray;

        // First, let's look for the "name" attribute.
        Attribute.Flags = 0;
        Attribute.Namespace = NULL;
        Attribute.NamespaceCch = 0;
        Attribute.Name = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME;
        Attribute.NameCch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME) - 1;

        NameInternalAttribute =
            ::SxspLocateInternalAssemblyIdentityAttribute(
                SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME,
                AssemblyIdentity,
                &Attribute,
                NULL);
        if (NameInternalAttribute == NULL)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(AttributeNotFound, ERROR_NOT_FOUND);

        IFW32FALSE_EXIT(::SxspQuoteString(0, NameInternalAttribute->Attribute.Value, NameInternalAttribute->Attribute.ValueCch, BytesLeft, Cursor, &TempBytesWritten));
        INTERNAL_ERROR_CHECK(TempBytesWritten <= BytesLeft);

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + TempBytesWritten);
        BytesLeft -= TempBytesWritten;
        BytesWritten += TempBytesWritten;

        for (i=0; i<AttributeCount; i++)
        {
            // Skip the standard "name" attribute
            if (Attributes[i] == NameInternalAttribute)
                continue;

            if (BytesLeft < sizeof(WCHAR))
                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

            *((WCHAR *) Cursor) = L',';
            Cursor = (PVOID) (((ULONG_PTR) Cursor) + sizeof(WCHAR));
            BytesLeft -= sizeof(WCHAR);
            BytesWritten += sizeof(WCHAR);

            IFW32FALSE_EXIT(::SxspEncodeInternalAssemblyIdentityAttributeAsText(0, Attributes[i], BytesLeft, Cursor, &TempBytesWritten));
            INTERNAL_ERROR_CHECK(TempBytesWritten <= BytesLeft);

            Cursor = (PVOID) (((ULONG_PTR) Cursor) + TempBytesWritten);
            BytesLeft -= TempBytesWritten;
            BytesWritten += TempBytesWritten;
        }
    }

    *BytesWrittenOut = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxsEncodeAssemblyIdentity(
    IN ULONG Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    OUT PVOID Buffer,
    OUT SIZE_T *BytesWrittenOrRequired
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T TotalSize = 0;
    PVOID Cursor = NULL;
    SIZE_T i;
    PENCODED_ASSEMBLY_IDENTITY_HEADER EncodedAssemblyIdentityHeader = NULL;
    PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER EncodedAssemblyIdentityAttributeHeader = NULL;
    ULONG *TempULONGArrayPointer;
    SIZE_T BytesWritten = 0;
    ULONG AttributeCount, NamespaceCount;

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (Buffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesWrittenOrRequired != NULL));

    if (EncodingGroup != NULL)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingGroup, ERROR_SXS_UNKNOWN_ENCODING_GROUP);

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingId, ERROR_SXS_UNKNOWN_ENCODING);

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));
    IFW32FALSE_EXIT(::SxsComputeAssemblyIdentityEncodedSize(0, AssemblyIdentity, EncodingGroup, EncodingFormat, &TotalSize));

    if (TotalSize > BufferSize)
    {
        if (BytesWrittenOrRequired != NULL)
            *BytesWrittenOrRequired = TotalSize;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);
    }

    AttributeCount = AssemblyIdentity->AttributeCount;
    NamespaceCount = AssemblyIdentity->NamespaceCount;

    //
    //  Let's start filling it in.
    //

    switch (EncodingFormat)
    {
    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY:
        BytesWritten = 0;
        Cursor = Buffer;

        EncodedAssemblyIdentityHeader = (PENCODED_ASSEMBLY_IDENTITY_HEADER) Cursor;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER));
        BytesWritten += sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);

        EncodedAssemblyIdentityHeader->HeaderSize = sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER);
        EncodedAssemblyIdentityHeader->Magic = ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC;
        EncodedAssemblyIdentityHeader->TotalSize = static_cast<ULONG>(TotalSize);
        // turn off any flags not relevant to persisted state
        EncodedAssemblyIdentityHeader->Type = AssemblyIdentity->Type;
        EncodedAssemblyIdentityHeader->Flags = AssemblyIdentity->Flags & ~(ASSEMBLY_IDENTITY_FLAG_FROZEN);
        EncodedAssemblyIdentityHeader->EncodingFlags = 0;
        EncodedAssemblyIdentityHeader->AttributeCount = AttributeCount;
        EncodedAssemblyIdentityHeader->NamespaceCount = NamespaceCount;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero1 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero2 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero3 = 0;
        EncodedAssemblyIdentityHeader->ReservedMustBeZero4 = 0;

        TempULONGArrayPointer = (ULONG *) Cursor;
        Cursor = (PVOID) (TempULONGArrayPointer + AttributeCount);
        BytesWritten += (AttributeCount * sizeof(ULONG));

        for (i=0; i<AttributeCount; i++)
            TempULONGArrayPointer[i] = AssemblyIdentity->AttributePointerArray[i]->WholeAttributeHash;

        // sort 'em...
        qsort(TempULONGArrayPointer, AttributeCount, sizeof(ULONG), &SxspCompareULONGsForQsort);

        TempULONGArrayPointer = (ULONG *) Cursor;
        Cursor = (PVOID) (TempULONGArrayPointer + NamespaceCount);
        BytesWritten += (sizeof(ULONG) * NamespaceCount);

        for (i=0; i<NamespaceCount; i++)
            TempULONGArrayPointer[i] = static_cast<ULONG>(AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch);

        EncodedAssemblyIdentityAttributeHeader = (PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER) Cursor;
        Cursor = (PVOID) (EncodedAssemblyIdentityAttributeHeader + AttributeCount);
        BytesWritten += (AttributeCount * sizeof(ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER));

        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AssemblyIdentity->AttributePointerArray[i];
            ULONG NamespaceIndex;

            // Totally gross linear search to determine the namespace index.  Fortunately the common case
            // will be a single namespace for all attributes.
            for (NamespaceIndex = 0; NamespaceIndex < NamespaceCount; NamespaceIndex++)
            {
                if (AssemblyIdentity->NamespacePointerArray[NamespaceIndex] == InternalAttribute->Namespace)
                    break;
            }

            // If this assert fires, the attribute refers to a namespace that's not in the identity; bad!
            INTERNAL_ERROR_CHECK(
                (InternalAttribute->Namespace == NULL) ||
                (NamespaceIndex < NamespaceCount));

            EncodedAssemblyIdentityAttributeHeader[i].NamespaceIndex = NamespaceIndex + 1;
            EncodedAssemblyIdentityAttributeHeader[i].NameCch = static_cast<ULONG>(InternalAttribute->Attribute.NameCch);
            EncodedAssemblyIdentityAttributeHeader[i].ValueCch = static_cast<ULONG>(InternalAttribute->Attribute.ValueCch);
        }

        // so much for the fixed length stuff; write the namespaces.
        for (i=0; i<NamespaceCount; i++)
        {
            PWSTR psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + (AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR)));

            BytesWritten += (AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR));

            memcpy(
                psz,
                AssemblyIdentity->NamespacePointerArray[i]->Namespace,
                AssemblyIdentity->NamespacePointerArray[i]->NamespaceCch * sizeof(WCHAR));
        }

        // And the attributes...
        for (i=0; i<AttributeCount; i++)
        {
            PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AssemblyIdentity->AttributePointerArray[i];
            PWSTR psz;

            psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + (InternalAttribute->Attribute.NameCch * sizeof(WCHAR)));
            BytesWritten += (InternalAttribute->Attribute.NameCch * sizeof(WCHAR));

            memcpy(
                psz,
                InternalAttribute->Attribute.Name,
                InternalAttribute->Attribute.NameCch * sizeof(WCHAR));

            psz = (PWSTR) Cursor;
            Cursor = (PVOID) (((ULONG_PTR) psz) + InternalAttribute->Attribute.ValueCch * sizeof(WCHAR));
            BytesWritten += InternalAttribute->Attribute.ValueCch * sizeof(WCHAR);

            memcpy(
                psz,
                InternalAttribute->Attribute.Value,
                InternalAttribute->Attribute.ValueCch * sizeof(WCHAR));
        }

        if ((BytesWritten % 4) != 0) {
            ASSERT((BytesWritten % 4) == sizeof(USHORT));

            *((USHORT *) Cursor) = 0;
            BytesWritten += sizeof(USHORT);
        }

        break;

    case SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL:
        IFW32FALSE_EXIT(::SxspEncodeAssemblyIdentityTextually(0, AssemblyIdentity, BufferSize, Buffer, &BytesWritten));
        break;
    }

    INTERNAL_ERROR_CHECK(BytesWritten == TotalSize);

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = BytesWritten;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxsDecodeAssemblyIdentity(
    ULONG Flags,
    IN const GUID *EncodingGroup,
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    IN const VOID *Buffer,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentityOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCENCODED_ASSEMBLY_IDENTITY_HEADER EncodedAssemblyIdentityHeader = NULL;
    PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER EncodedAssemblyIdentityAttributeHeader = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    ULONG AttributeCount = 0;
    ULONG NamespaceCount = 0;
    ULONG AttributeArraySize = 0;
    ULONG NamespaceArraySize = 0;
    ULONG i;
    const ULONG *NamespaceLengthArray = NULL;
    const ULONG *AttributeHashArray = NULL;
    const WCHAR *UnicodeStringArray = NULL;

    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) == 0);
    PARAMETER_CHECK(BufferSize >= sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER));
    PARAMETER_CHECK(Buffer != NULL);
    PARAMETER_CHECK(AssemblyIdentityOut != NULL);

    if (EncodingGroup != NULL)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncodingGroup, ERROR_SXS_UNKNOWN_ENCODING_GROUP);

    if ((EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY) &&
        (EncodingFormat != SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(UnknownEncoding, ERROR_SXS_UNKNOWN_ENCODING);

    EncodedAssemblyIdentityHeader = (PCENCODED_ASSEMBLY_IDENTITY_HEADER) Buffer;

    if ((EncodedAssemblyIdentityHeader->HeaderSize != sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)) ||
        (EncodedAssemblyIdentityHeader->Magic != ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC) ||
        (EncodedAssemblyIdentityHeader->TotalSize > BufferSize) ||
        (EncodedAssemblyIdentityHeader->Flags != 0) ||
        ((EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (EncodedAssemblyIdentityHeader->Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
        (EncodedAssemblyIdentityHeader->EncodingFlags != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero1 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero2 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero3 != 0) ||
        (EncodedAssemblyIdentityHeader->ReservedMustBeZero4 != 0)) {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFALLOCFAILED_EXIT(AssemblyIdentity = new ASSEMBLY_IDENTITY);

    NamespaceCount = EncodedAssemblyIdentityHeader->NamespaceCount;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        NamespaceArraySize = NamespaceCount;
    }
    else if (NamespaceCount == 0)
    {
        NamespaceArraySize = 8;
    }
    else
    {
        NamespaceArraySize = (NamespaceCount + 7) & ~7;
    }

    if (NamespaceArraySize != 0)
    {
        IFALLOCFAILED_EXIT(NamespacePointerArray = new PCASSEMBLY_IDENTITY_NAMESPACE[NamespaceArraySize]);

        for (i=0; i<NamespaceArraySize; i++)
            NamespacePointerArray[i] = NULL;
    }

    AttributeCount = EncodedAssemblyIdentityHeader->AttributeCount;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        // If we're going to freeze, just perform an exact allocation.
        AttributeArraySize = AttributeCount;
    }
    else if (AttributeCount == 0)
    {
        AttributeArraySize = 8;
    }
    else
    {
        AttributeArraySize = (AttributeCount + 7) & ~7;
    }

    if (AttributeArraySize != 0)
    {
        IFALLOCFAILED_EXIT(AttributePointerArray = new PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE[AttributeArraySize]);

        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    AttributeHashArray = (const ULONG *) (EncodedAssemblyIdentityHeader + 1);
    NamespaceLengthArray = (const ULONG *) (AttributeHashArray + AttributeCount);
    EncodedAssemblyIdentityAttributeHeader = (PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER) (NamespaceLengthArray + NamespaceCount);
    UnicodeStringArray = (const WCHAR *) (EncodedAssemblyIdentityAttributeHeader + AttributeCount);

    // Start by building up those namespaces...
    for (i=0; i<NamespaceCount; i++)
    {
        ULONG NamespaceHash = 0;
        NamespaceHash = ::FusionpHashUnicodeStringCaseSensitive(UnicodeStringArray, NamespaceLengthArray[i]);
        IFW32FALSE_EXIT(::SxspAllocateAssemblyIdentityNamespace(0, UnicodeStringArray, NamespaceLengthArray[i], NamespaceHash, &NamespacePointerArray[i]));
        UnicodeStringArray += NamespaceLengthArray[i];
    }

    if (AttributeCount != 0)
    {
        // and now those attributes...
        for (i=0; i<AttributeCount; i++)
        {
            const ULONG NamespaceIndex = EncodedAssemblyIdentityAttributeHeader[i].NamespaceIndex;
            const ULONG NameCch = EncodedAssemblyIdentityAttributeHeader[i].NameCch;
            const ULONG ValueCch = EncodedAssemblyIdentityAttributeHeader[i].ValueCch;
            const WCHAR * const Name = UnicodeStringArray;
            const WCHAR * const Value = &UnicodeStringArray[NameCch];

            UnicodeStringArray = &Value[ValueCch];

            IFW32FALSE_EXIT(
                ::SxspAllocateInternalAssemblyIdentityAttribute(
                    0,
                    NamespacePointerArray[NamespaceIndex],
                    Name,
                    NameCch,
                    Value,
                    ValueCch,
                    &AttributePointerArray[i]));
        }

        // sort 'em...
        qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), &SxspCompareInternalAttributesForQsort);
    }

    IFW32FALSE_EXIT(::SxspHashInternalAssemblyIdentityAttributes(0, AttributeCount, AttributePointerArray, &AssemblyIdentity->Hash));

    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->Type = EncodedAssemblyIdentityHeader->Type;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION | ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    if (Flags & SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    //
    // REVIEW: Should this be an SxsDestroyAssemblyIdentity
    //
    if (AssemblyIdentity != NULL)
        FUSION_DELETE_SINGLETON(AssemblyIdentity);

    if ((AttributeCount != 0) && (AttributePointerArray != NULL))
    {
        for (i=0; i<AttributeCount; i++)
        {
            if (AttributePointerArray[i] != NULL)
            {
                ::SxspDeallocateInternalAssemblyIdentityAttribute(const_cast<PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE>(AttributePointerArray[i]));
                AttributePointerArray[i] = NULL;
            }
        }

        FUSION_DELETE_ARRAY(AttributePointerArray);
    }

    if ((NamespaceCount != 0) && (NamespacePointerArray != NULL))
    {
        for (i=0; i<NamespaceCount; i++)
        {
            if (NamespacePointerArray[i] != NULL)
            {
                ::SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);
                NamespacePointerArray[i] = NULL;
            }
        }

        FUSION_DELETE_ARRAY( NamespacePointerArray );
    }

    return fSuccess;
}

int __cdecl
SxspCharPairArrayComparisonCallback(
    const void *pelem1,
    const void *pelem2
    )
{
    PCCHARPAIR pcp1 = (PCCHARPAIR) pelem1;
    PCCHARPAIR pcp2 = (PCCHARPAIR) pelem2;

    if (pcp1->wchEnd < pcp2->wchStart)
        return -1;

    if (pcp2->wchEnd < pcp1->wchStart)
        return 1;

    return 0;
}

bool
__fastcall
SxspIsCharInCharPairArray(
    WCHAR wch,
    PCCHARPAIR prg,
    SIZE_T n
    )
{
    CHARPAIR cp = { wch, wch };
    return (::bsearch(&cp, prg, n, sizeof(CHARPAIR), &::SxspCharPairArrayComparisonCallback) != NULL);
}

__forceinline
bool
__fastcall
SxspIsCharXMLBaseChar(
    WCHAR wch
    )
{
    if (wch < 0x41)
        return false;

    if (wch <= 0x5a)
        return true;

    if (wch < 0x61)
        return false;

    if (wch <= 0x7a)
        return true;

    return ::SxspIsCharInCharPairArray(wch, s_rgXMLBaseChar, NUMBER_OF(s_rgXMLBaseChar));
}

bool
__fastcall
SxspIsCharXMLIdeographic(
    WCHAR wch
    )
{
    return (
        (wch >= 0x4e00 && wch <= 0x9fa5) ||
        (wch == 0x3007) ||
        (wch >= 0x3021 && wch <= 0x3029)
        );
}

__forceinline
bool
__fastcall
SxspIsCharXMLLetter(
    WCHAR wch
    )
{
    return
        ::SxspIsCharXMLBaseChar(wch) ||
        ::SxspIsCharXMLIdeographic(wch);
}

bool
__fastcall
SxspIsCharXMLCombiningChar(
    WCHAR wch
    )
{
    return (
        (wch >= 0x0300 && wch <= 0x0345) ||
        (wch >= 0x0360 && wch <= 0x0361) ||
        (wch >= 0x0483 && wch <= 0x0486) ||
        (wch >= 0x0591 && wch <= 0x05a1) ||
        (wch >= 0x05a3 && wch <= 0x05b9) ||
        (wch >= 0x05bb && wch <= 0x05bd) ||
        wch == 0x05bf ||
        (wch >= 0x05c1 && wch <= 0x05c2) ||
        wch == 0x05c4 ||
        (wch >= 0x064b && wch <= 0x0652) ||
        wch == 0x0670 ||
        (wch >= 0x06d6 && wch <= 0x06dc) ||
        (wch >= 0x06dd && wch <= 0x06df) ||
        (wch >= 0x06e0 && wch <= 0x06e4) ||
        (wch >= 0x06e7 && wch <= 0x06e8) ||
        (wch >= 0x06ea && wch <= 0x06ed) ||
        (wch >= 0x0901 && wch <= 0x0903) ||
        wch == 0x093c ||
        (wch >= 0x093e && wch <= 0x094c) ||
        wch == 0x094d ||
        (wch >= 0x0951 && wch <= 0x0954) ||
        (wch >= 0x0962 && wch <= 0x0963) ||
        (wch >= 0x0981 && wch <= 0x0983) ||
        wch == 0x09bc ||
        wch == 0x09be ||
        wch == 0x09bf ||
        (wch >= 0x09c0 && wch <= 0x09c4) ||
        (wch >= 0x09c7 && wch <= 0x09c8) ||
        (wch >= 0x09cb && wch <= 0x09cd) ||
        wch == 0x09d7 ||
        (wch >= 0x09e2 && wch <= 0x09e3) ||
        wch == 0x0a02 ||
        wch == 0x0a3c ||
        wch == 0x0a3e ||
        wch == 0x0a3f ||
        (wch >= 0x0a40 && wch <= 0x0a42) ||
        (wch >= 0x0a47 && wch <= 0x0a48) ||
        (wch >= 0x0a4b && wch <= 0x0a4d) ||
        (wch >= 0x0a70 && wch <= 0x0a71) ||
        (wch >= 0x0a81 && wch <= 0x0a83) ||
        wch == 0x0abc ||
        (wch >= 0x0abe && wch <= 0x0ac5) ||
        (wch >= 0x0ac7 && wch <= 0x0ac9) ||
        (wch >= 0x0acb && wch <= 0x0acd) ||
        (wch >= 0x0b01 && wch <= 0x0b03) ||
        wch == 0x0b3c ||
        (wch >= 0x0b3e && wch <= 0x0b43) ||
        (wch >= 0x0b47 && wch <= 0x0b48) ||
        (wch >= 0x0b4b && wch <= 0x0b4d) ||
        (wch >= 0x0b56 && wch <= 0x0b57) ||
        (wch >= 0x0b82 && wch <= 0x0b83) ||
        (wch >= 0x0bbe && wch <= 0x0bc2) ||
        (wch >= 0x0bc6 && wch <= 0x0bc8) ||
        (wch >= 0x0bca && wch <= 0x0bcd) ||
        wch == 0x0bd7 ||
        (wch >= 0x0c01 && wch <= 0x0c03) ||
        (wch >= 0x0c3e && wch <= 0x0c44) ||
        (wch >= 0x0c46 && wch <= 0x0c48) ||
        (wch >= 0x0c4a && wch <= 0x0c4d) ||
        (wch >= 0x0c55 && wch <= 0x0c56) ||
        (wch >= 0x0c82 && wch <= 0x0c83) ||
        (wch >= 0x0cbe && wch <= 0x0cc4) ||
        (wch >= 0x0cc6 && wch <= 0x0cc8) ||
        (wch >= 0x0cca && wch <= 0x0ccd) ||
        (wch >= 0x0cd5 && wch <= 0x0cd6) ||
        (wch >= 0x0d02 && wch <= 0x0d03) ||
        (wch >= 0x0d3e && wch <= 0x0d43) ||
        (wch >= 0x0d46 && wch <= 0x0d48) ||
        (wch >= 0x0d4a && wch <= 0x0d4d) ||
        wch == 0x0d57 ||
        wch == 0x0e31 ||
        (wch >= 0x0e34 && wch <= 0x0e3a) ||
        (wch >= 0x0e47 && wch <= 0x0e4e) ||
        wch == 0x0eb1 ||
        (wch >= 0x0eb4 && wch <= 0x0eb9) ||
        (wch >= 0x0ebb && wch <= 0x0ebc) ||
        (wch >= 0x0ec8 && wch <= 0x0ecd) ||
        (wch >= 0x0f18 && wch <= 0x0f19) ||
        wch == 0x0f35 ||
        wch == 0x0f37 ||
        wch == 0x0f39 ||
        wch == 0x0f3e ||
        wch == 0x0f3f ||
        (wch >= 0x0f71 && wch <= 0x0f84) ||
        (wch >= 0x0f86 && wch <= 0x0f8b) ||
        (wch >= 0x0f90 && wch <= 0x0f95) ||
        wch == 0x0f97 ||
        (wch >= 0x0f99 && wch <= 0x0fad) ||
        (wch >= 0x0fb1 && wch <= 0x0fb7) ||
        wch == 0x0fb9 ||
        (wch >= 0x20d0 && wch <= 0x20dc) ||
        wch == 0x20e1 ||
        (wch >= 0x302a && wch <= 0x302f) ||
        wch == 0x3099 ||
        wch == 0x309a
        );
}

__forceinline
bool
__fastcall
SxspIsCharXMLDigit(
    WCHAR wch
    )
{
    return (
        (wch >= 0x0030 && wch <= 0x0039) ||
        (wch >= 0x0660 && wch <= 0x0669) ||
        (wch >= 0x06f0 && wch <= 0x06f9) ||
        (wch >= 0x0966 && wch <= 0x096f) ||
        (wch >= 0x09e6 && wch <= 0x09ef) ||
        (wch >= 0x0a66 && wch <= 0x0a6f) ||
        (wch >= 0x0ae6 && wch <= 0x0aef) ||
        (wch >= 0x0b66 && wch <= 0x0b6f) ||
        (wch >= 0x0be7 && wch <= 0x0bef) ||
        (wch >= 0x0c66 && wch <= 0x0c6f) ||
        (wch >= 0x0ce6 && wch <= 0x0cef) ||
        (wch >= 0x0d66 && wch <= 0x0d6f) ||
        (wch >= 0x0e50 && wch <= 0x0e59) ||
        (wch >= 0x0ed0 && wch <= 0x0ed9) ||
        (wch >= 0x0f20 && wch <= 0x0f29)
        );
}

__forceinline
bool
__fastcall
SxspIsCharXMLExtender(
    WCHAR wch
    )
{
    return (
        wch == 0x00b7 ||
        wch == 0x02d0 ||
        wch == 0x02d1 ||
        wch == 0x0387 ||
        wch == 0x0640 ||
        wch == 0x0e46 ||
        wch == 0x0ec6 ||
        wch == 0x3005 ||
        (wch >= 0x3031 && wch <= 0x3035) ||
        (wch >= 0x309d && wch <= 0x309e) ||
        (wch >= 0x30fc && wch <= 0x30fe)
        );
}

BOOL
SxspValidateXMLName(
    PCWSTR psz,
    SIZE_T cch,
    bool &rfValid
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SIZE_T i;

    rfValid = false;

    // [4]  NameChar ::=  Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender 
    // [5]  Name ::=  (Letter | '_' | ':') (NameChar)* 

    if (cch >= 1)
    {
        WCHAR wch = psz[0];

        if (::SxspIsCharXMLLetter(wch) ||
            (wch == L'_') ||
            (wch == L':'))
        {
            for (i=1; i<cch; i++)
            {
                wch = psz[i];

                if (!::SxspIsCharXMLLetter(wch) &&
                    !::SxspIsCharXMLDigit(wch) &&
                    (wch != L'.') &&
                    (wch != L'-') &&
                    (wch != L'_') &&
                    (wch != L':') &&
                    !::SxspIsCharXMLCombiningChar(wch) &&
                    !::SxspIsCharXMLExtender(wch))
                    break;
            }

            if (i == cch)
                rfValid = true;
        }
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\id\policy.cpp ===
#include "stdinc.h"

#include "idp.h"
#include "sxsapi.h"
#include "sxsid.h"
#include "smartptr.h"

BOOL
SxspMapAssemblyIdentityToPolicyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PASSEMBLY_IDENTITY *pPolicyIdentity
    )
{
    FN_PROLOG_WIN32
    PCWSTR pszTemp = NULL;
    SIZE_T cchTemp = 0;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> NewIdentity;
    CSmallStringBuffer Name;
    bool fFirst = false;
    const bool fOmitEntireVersion = ((Flags & SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION) != 0);
    BOOL fIsPolicy = FALSE;

    if (pPolicyIdentity)
        *pPolicyIdentity = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != 0);
    PARAMETER_CHECK(pPolicyIdentity != NULL);

    //
    // Duplicate the assembly identity first so we can change it
    //
    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            0,
            AssemblyIdentity,
            &NewIdentity));

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));

    //
    // If this was not a policy identity, then swizzle its type
    //
    if (!fIsPolicy)
    {
        PCWSTR pcwszOriginalType;
        SIZE_T cchOriginalType;

        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                AssemblyIdentity,
                &s_IdentityAttribute_type,
                &pcwszOriginalType,
                &cchOriginalType));

        if (cchOriginalType == 0)
        {
            IFW32FALSE_EXIT(
                ::SxspSetAssemblyIdentityAttributeValue(
                    SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                    NewIdentity,
                    &s_IdentityAttribute_type,
                    ASSEMBLY_TYPE_POLICY,
                    ASSEMBLY_TYPE_POLICY_CCH));
        }
        else
        {
            CSmallStringBuffer MappedName;
            IFW32FALSE_EXIT(MappedName.Win32Assign(pcwszOriginalType, cchOriginalType));
            IFW32FALSE_EXIT(MappedName.Win32Append(ASSEMBLY_TYPE_POLICY_SUFFIX, ASSEMBLY_TYPE_POLICY_SUFFIX_CCH));

            IFW32FALSE_EXIT(
                ::SxspSetAssemblyIdentityAttributeValue(
                    SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                    NewIdentity,
                    &s_IdentityAttribute_type,
                    MappedName));
        }
    }

    IFW32FALSE_EXIT(Name.Win32Assign(L"Policy.", 7));

    if (!fOmitEntireVersion)
    {
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                0,
                AssemblyIdentity,
                &s_IdentityAttribute_version,
                &pszTemp,
                &cchTemp));

        fFirst = true;

        while (cchTemp != 0)
        {
            if (pszTemp[--cchTemp] == L'.')
            {
                if (!fFirst)
                    break;

                fFirst = false;
            }
        }

        // This should not be zero; someone prior to this should have validated the version format
        // to include three dots.
        INTERNAL_ERROR_CHECK(cchTemp != 0);

        IFW32FALSE_EXIT(Name.Win32Append(pszTemp, cchTemp + 1));
    }

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            0,
            AssemblyIdentity,
            &s_IdentityAttribute_name,
            &pszTemp,
            &cchTemp));

    IFW32FALSE_EXIT(Name.Win32Append(pszTemp, cchTemp));

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            NewIdentity,
            &s_IdentityAttribute_name,
            Name));

    // finally we whack the version...

    IFW32FALSE_EXIT(
        ::SxspRemoveAssemblyIdentityAttribute(
            SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
            NewIdentity,
            &s_IdentityAttribute_version));

    if (pPolicyIdentity)
        *pPolicyIdentity = NewIdentity.Detach();

    FN_EPILOG;
}

BOOL
SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    CBaseStringBuffer &rbuffEncodedIdentity,
    PASSEMBLY_IDENTITY *PolicyIdentityOut
    )
{
    FN_PROLOG_WIN32
    
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> PolicyIdentity;
    DWORD dwMapFlags = 0;

    if (PolicyIdentityOut != NULL)
        *PolicyIdentityOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (Flags & SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION)
        dwMapFlags |= SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION;

    IFW32FALSE_EXIT(::SxspMapAssemblyIdentityToPolicyIdentity(dwMapFlags, AssemblyIdentity, &PolicyIdentity));
    IFW32FALSE_EXIT(::SxspGenerateTextualIdentity(0, PolicyIdentity, rbuffEncodedIdentity));

    if (PolicyIdentityOut != NULL)
    {
        *PolicyIdentityOut = PolicyIdentity.Detach();
    }

    FN_EPILOG;
}

//
// the difference between this func and SxsHashAssemblyIdentity() is that for policy,
// version should not be calcaulated as part of hash
//
BOOL
SxspHashAssemblyIdentityForPolicy(
    IN DWORD dwFlags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG & IdentityHash)
{
    FN_PROLOG_WIN32
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, ::SxsDestroyAssemblyIdentity> pAssemblyIdentity;

    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE,
            AssemblyIdentity,
            &pAssemblyIdentity));

    IFW32FALSE_EXIT(
        ::SxspRemoveAssemblyIdentityAttribute(
            SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS,
            pAssemblyIdentity,
            &s_IdentityAttribute_version));

    IFW32FALSE_EXIT(::SxsHashAssemblyIdentity(0, pAssemblyIdentity, &IdentityHash));

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\id\id.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    id.cpp

Abstract:

    Implementation of the assembly identity data type.

Author:

    Michael Grier (MGrier) 7/20/2000

Revision History:

--*/
#include "stdinc.h"
#include <setupapi.h>
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>
#include "smartptr.h"
#include "idp.h"
#include "sxsid.h"

//
//  Power of two to which to round the number of allocated attribute
//  pointers.
//

#define ROUNDING_FACTOR_BITS (3)

#define WILDCARD_CHAR '*'

#define ENTRY(x) { x, NUMBER_OF(x) - 1 },

const static struct
{
    const WCHAR *String;
    SIZE_T Cch;
} s_rgLegalNamesNotInANamespace[] =
{
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
    ENTRY(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
};

#undef ENTRY

BOOL
SxspValidateXMLName(
    PCWSTR psz,
    SIZE_T cch,
    bool &rfValid
    );

BOOL
SxspValidateAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK((Flags & ~(SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL)) == 0);
    PARAMETER_CHECK((AssemblyIdentity != NULL) || (Flags & SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL));
    if (AssemblyIdentity != NULL)
    {
        const ULONG IdentityType = AssemblyIdentity->Type;

        PARAMETER_CHECK(
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_REFERENCE) ||
            (IdentityType == ASSEMBLY_IDENTITY_TYPE_WILDCARD));
    }

    FN_EPILOG
}

//
//  Note!
//
//  We currently are very very restrictive on the legal characters in namespaces.
//
//  This is because the various rules for equivalences of namespaces are extremely
//  complex w.r.t. when "a" == "A" and "%Ab" == "%aB" etc.
//
//  We're side-stepping this issue by requireing everything to be lower case and
//  not permitting the "%" character.
//

const WCHAR s_rgLegalNamespaceChars[] = L"abcdefghijklmnopqrstuvwxyz0123456789.-_/\\:";
BOOL
SxspValidateAssemblyIdentityAttributeNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch
    )
{
    FN_PROLOG_WIN32
    ULONG i;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));

    //
    //  We really should ensure that the namespace is a well-formed URI
    //

    for (i=0; i<NamespaceCch; i++)
    {
        if (::wcschr(s_rgLegalNamespaceChars, Namespace[i]) == NULL)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidNamespaceURI, ERROR_SXS_INVALID_XML_NAMESPACE_URI);
    }

    FN_EPILOG
}

BOOL
SxspValidateAssemblyIdentityAttributeName(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch
    )
{
    FN_PROLOG_WIN32
    bool fNameWellFormed = false;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK((Name != NULL) || (NameCch == 0));

    //
    //  We should ensure that Name is a well-formed XML identifier
    //
    IFW32FALSE_EXIT(::SxspValidateXMLName(Name, NameCch, fNameWellFormed));

    if (!fNameWellFormed)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(BadAttributeName, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME);

    FN_EPILOG
}

BOOL
SxspValidateAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN const WCHAR * /* Value */,
    SIZE_T /* ValueCch */
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK((Flags & ~(SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED)) == 0);

    FN_EPILOG
}

BOOL
SxsValidateAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK((Flags & ~(
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED)) == 0);
    PARAMETER_CHECK(Attribute != NULL);

    //
    //  apply useful defaults.  Note that by default, wildcards are not permitted.
    //

    if (Flags == 0)
    {
        Flags =
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME |
            SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
    }

    // No attribute flags defined or permitted at this time.
    PARAMETER_CHECK(Attribute->Flags == 0);

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE)
        IFW32FALSE_EXIT(::SxspValidateAssemblyIdentityAttributeNamespace(0, Attribute->Namespace, Attribute->NamespaceCch));

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME)
        IFW32FALSE_EXIT(::SxspValidateAssemblyIdentityAttributeName(0, Attribute->Name, Attribute->NameCch));

    if (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE)
        IFW32FALSE_EXIT(::SxspValidateAssemblyIdentityAttributeValue(
                        (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED) ?
                            SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED : 0,
                         Attribute->Value,
                         Attribute->ValueCch));

    if ((Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE) &&
        (Flags & SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME) &&
        (Attribute->NamespaceCch == 0))
    {
        ULONG i;
        // There is only a small set of legal attribute names when the namespace is omitted.

        for (i=0; i<NUMBER_OF(s_rgLegalNamesNotInANamespace); i++)
        {
            if (Attribute->NameCch == s_rgLegalNamesNotInANamespace[i].Cch)
            {
                if (::memcmp(Attribute->Name, s_rgLegalNamesNotInANamespace[i].String, Attribute->NameCch * sizeof(WCHAR)) == 0)
                    break;
            }
        }

        if (i == NUMBER_OF(s_rgLegalNamesNotInANamespace))
        {
            // Someone had an attribute on the <assemblyIdentity> element which was not in a namespace and
            // was not listed as a builtin attribute.  Boom.
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidAssemblyIdentityAttribute, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE);
        }
    }

    FN_EPILOG
}

BOOL
SxsHashAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *HashOut
    )
{
    FN_PROLOG_WIN32
    ULONG Hash = 0;

    if (HashOut != NULL)
        *HashOut = 0;

    if (Flags == 0)
        Flags = SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
                SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE;

    PARAMETER_CHECK((Flags & ~(SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE)) == 0);

    // if hash value, must hash name, if hash name, must hash namespace
    PARAMETER_CHECK(!(((Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE) && (
        (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) == 0)) ||
        ((Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME) && (
        (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE) == 0))));

    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(HashOut != NULL);

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE)
    {
        // URLs are case sensitive but due to a pre-Windows XP RTM bug, we can't
        // change the hashes, so we're stuck with performing case insensitive
        // namespace hashes for the near future.
        Hash = ::FusionpHashUnicodeStringCaseInsensitive(Attribute->Namespace, Attribute->NamespaceCch);
    }

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME)
    {
        const ULONG TempHash = ::FusionpHashUnicodeStringCaseInsensitive(Attribute->Name, Attribute->NameCch);
        Hash = (Hash * 65599) + TempHash;
    }

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE)
    {
        const ULONG TempHash = ::FusionpHashUnicodeStringCaseInsensitive(Attribute->Value, Attribute->ValueCch);
        Hash = (Hash * 65599) + TempHash;
    }

    *HashOut = Hash;

    FN_EPILOG
}

ULONG
__fastcall
SxspHashAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    ULONG Hash = 0;

    ASSERT_NTC(Flags != 0);
    ASSERT_NTC((Flags & ~(SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
                  SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE)) == 0);
    ASSERT_NTC(Attribute != NULL);

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE)
    {
        Hash = ::FusionpHashUnicodeStringCaseInsensitive(Attribute->Namespace, Attribute->NamespaceCch);
    }

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME)
    {
        const ULONG TempHash = ::FusionpHashUnicodeStringCaseInsensitive(Attribute->Name, Attribute->NameCch);
        Hash = (Hash * 65599) + TempHash;
    }

    if (Flags & SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE)
    {
        const ULONG TempHash = ::FusionpHashUnicodeStringCaseInsensitive(Attribute->Value, Attribute->ValueCch);
        Hash = (Hash * 65599) + TempHash;
    }

    return Hash;
}

BOOL
SxspComputeInternalAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT SIZE_T *BytesRequiredOut
    )
{
    FN_PROLOG_WIN32
    SIZE_T BytesNeeded = 0;

    if (BytesRequiredOut != NULL)
        *BytesRequiredOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(BytesRequiredOut != NULL);
    PARAMETER_CHECK((NameCch == 0) || (Name != NULL));
    PARAMETER_CHECK((ValueCch == 0) || (Value != NULL));

    BytesNeeded = sizeof(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE);

    // Note that we do not account for the namespace length because namespaces are pooled
    // for the identity object and come from a separate allocation.

    if ((Name != NULL) && (NameCch != 0))
        BytesNeeded += ((NameCch + 1) * sizeof(WCHAR));

    if ((Value != NULL) && (ValueCch != 0))
        BytesNeeded += ((ValueCch + 1) * sizeof(WCHAR));

    *BytesRequiredOut = BytesNeeded;

    FN_EPILOG
}

BOOL
SxspComputeAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT SIZE_T *BytesRequiredOut
    )
{
    FN_PROLOG_WIN32
    SIZE_T BytesNeeded = 0;

    if (BytesRequiredOut != NULL)
        *BytesRequiredOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Source != NULL);
    PARAMETER_CHECK(BytesRequiredOut != NULL);

    BytesNeeded = sizeof(ASSEMBLY_IDENTITY_ATTRIBUTE);

    // We do account for the namespace length here because we're presumably about
    // to copy into an ASSEMBLY_IDENTITY_ATTRIBUTE where the namespace isn't pooled.

    if (Source->NamespaceCch != 0)
        BytesNeeded += ((Source->NamespaceCch + 1) * sizeof(WCHAR));

    if (Source->NameCch != 0)
        BytesNeeded += ((Source->NameCch + 1) * sizeof(WCHAR));

    if (Source->ValueCch != 0)
        BytesNeeded += ((Source->ValueCch + 1) * sizeof(WCHAR));

    *BytesRequiredOut = BytesNeeded;

    FN_EPILOG
}

BOOL
SxspFindAssemblyIdentityNamespaceInArray(
    IN DWORD Flags,
    IN OUT PCASSEMBLY_IDENTITY_NAMESPACE **NamespacePointerArrayPtr,
    IN OUT ULONG *NamespaceArraySizePtr,
    IN OUT ULONG *NamespaceCountPtr,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i, j;
    ULONG NamespaceHash = 0;
    ULONG NamespaceCount;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray;
    ULONG NewNamespaceArraySize = 0;
    PCASSEMBLY_IDENTITY_NAMESPACE *NewNamespacePointerArray = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;
    PCASSEMBLY_IDENTITY_NAMESPACE NewNamespacePointer = NULL;
    ULONG NamespaceArraySize = 0;
    LONG Comparison;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND)) == 0);
    PARAMETER_CHECK(NamespacePointerArrayPtr != NULL);
    PARAMETER_CHECK(NamespaceCountPtr != NULL);
    PARAMETER_CHECK(NamespaceArraySizePtr != NULL);
    PARAMETER_CHECK((NamespaceCch == 0) || (Namespace != NULL));

    NamespacePointerArray = *NamespacePointerArrayPtr;
    NamespaceCount = *NamespaceCountPtr;
    NamespaceArraySize = *NamespaceArraySizePtr;

    NamespaceHash = ::FusionpHashUnicodeStringCaseSensitive(Namespace, NamespaceCch);

    for (i=0; i<NamespaceCount; i++)
    {
        if (NamespaceHash <= NamespacePointerArray[i]->Hash)
            break;
    }

    // Loop through the duplicate hash values seeing if we have a match.
    while ((i < NamespaceCount) && (NamespacePointerArray[i]->Hash == NamespaceHash) && (NamespacePointerArray[i]->NamespaceCch == NamespaceCch))
    {
        NamespacePointer = NamespacePointerArray[i];

        Comparison = ::memcmp(Namespace, NamespacePointerArray[i]->Namespace, NamespaceCch * sizeof(WCHAR));
        if (Comparison == 0)
            break;

        NamespacePointer = NULL;
        i++;
    }

    if ((NamespacePointer == NULL) && (Flags & SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND))
    {
        // We didn't find a match.  Allocate a new one and push it into the array at the
        // appropriate location.  If the namespace isn't null.
        if (NamespaceCch != 0)
        {
            // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
            IFW32FALSE_EXIT(::SxspAllocateAssemblyIdentityNamespace(0, Namespace, NamespaceCch, NamespaceHash, &NewNamespacePointer));

            // the "i" variable is where we want to insert this one.
            if (i >= NamespaceArraySize)
            {
                NewNamespaceArraySize = NamespaceArraySize + 8;
                // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
                IFALLOCFAILED_EXIT(NewNamespacePointerArray = FUSION_NEW_ARRAY(PCASSEMBLY_IDENTITY_NAMESPACE, NewNamespaceArraySize));

                for (j=0; j<NamespaceCount; j++)
                    NewNamespacePointerArray[j] = NamespacePointerArray[j];

                while (j < NewNamespaceArraySize)
                    NewNamespacePointerArray[j++] = NULL;

                FUSION_DELETE_ARRAY(NamespacePointerArray);

                *NamespacePointerArrayPtr = NewNamespacePointerArray;
                *NamespaceArraySizePtr = NewNamespaceArraySize;

                NamespacePointerArray = NewNamespacePointerArray;
                NamespaceArraySize = NewNamespaceArraySize;

                NewNamespacePointerArray = NULL;
                NewNamespaceArraySize = 0;
            }

            INTERNAL_ERROR_CHECK(i < NamespaceArraySize);

            for (j = NamespaceCount; j > i; j--)
                NamespacePointerArray[j] = NamespacePointerArray[j-1];

            ASSERT(j == i);

            NamespacePointerArray[i] = NewNamespacePointer;
            NamespacePointer = NewNamespacePointer;
            NewNamespacePointer = NULL;

            *NamespaceCountPtr = NamespaceCount + 1;
        }
    }

    if (NamespaceOut != NULL)
        *NamespaceOut = NamespacePointer;

    // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use FN_EPILOG when we switch to smart pointers
    fSuccess = TRUE;

Exit:
    if (NewNamespacePointer != NULL)
        SxspDeallocateAssemblyIdentityNamespace(NewNamespacePointer);

    if (NewNamespacePointerArray != NULL)
        FUSION_DELETE_ARRAY(NewNamespacePointerArray);

    return fSuccess;
}

BOOL
SxspFindAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    FN_PROLOG_WIN32
    PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(NamespaceOut != NULL);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));
    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    IFW32FALSE_EXIT(
        ::SxspFindAssemblyIdentityNamespaceInArray(
            (Flags & SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND) ?
                SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND : 0,
            &AssemblyIdentity->NamespacePointerArray,
            &AssemblyIdentity->NamespaceArraySize,
            &AssemblyIdentity->NamespaceCount,
            Namespace,
            NamespaceCch,
            &NamespacePointer));

    *NamespaceOut = NamespacePointer;

    FN_EPILOG
}

BOOL
SxspAllocateAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN ULONG NamespaceHash,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY_NAMESPACE NewNamespace = NULL;
    SIZE_T BytesRequired = 0;

    if (NamespaceOut != NULL)
        *NamespaceOut = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(NamespaceOut != NULL);
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceHash == 0));
    PARAMETER_CHECK((Namespace != NULL) || (NamespaceCch == 0));

    BytesRequired = sizeof(ASSEMBLY_IDENTITY_NAMESPACE);

    if (NamespaceCch != 0)
        BytesRequired += (NamespaceCch + 1) * sizeof(WCHAR);

    // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
    IFALLOCFAILED_EXIT(NewNamespace = reinterpret_cast<PASSEMBLY_IDENTITY_NAMESPACE>(FUSION_RAW_ALLOC(BytesRequired, ASSEMBLY_IDENTITY_NAMESPACE)));

    NewNamespace->Flags = 0;

    if (NamespaceCch != 0)
    {
        NewNamespace->Namespace = (PWSTR) (NewNamespace + 1);
        NewNamespace->NamespaceCch = NamespaceCch;

        ::memcpy(
            (PVOID) NewNamespace->Namespace,
            Namespace,
            NamespaceCch * sizeof(WCHAR));

        ((PWSTR) NewNamespace->Namespace) [NamespaceCch] = L'\0';
        NewNamespace->NamespaceCch = NamespaceCch;
    }
    else
    {
        NewNamespace->Namespace = NULL;
        NewNamespace->NamespaceCch = 0;
    }

    NewNamespace->Hash = NamespaceHash;

    *NamespaceOut = NewNamespace;
    NewNamespace = NULL;

    fSuccess = TRUE;
Exit:
    if (NewNamespace != NULL)
        FUSION_RAW_DEALLOC(NewNamespace);

    return fSuccess;
}

VOID
SxspDeallocateAssemblyIdentityNamespace(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    )
{
    FN_TRACE();
    // The whole thing is allocated as a single chunk...
    ASSERT(Namespace != NULL);

    if (Namespace != NULL)
        FUSION_RAW_DEALLOC((PVOID) Namespace);
}

void
SxspPopulateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Destination
    )
{    
    PVOID Cursor = NULL;

    ASSERT_NTC(Flags == 0);
    ASSERT_NTC(Destination != NULL);

    Destination->Attribute.Flags = 0;
    Destination->Namespace = Namespace;

    Cursor = (PVOID) (Destination + 1);

    if (Namespace != NULL)
    {
        Destination->Attribute.Namespace = Namespace->Namespace;
        Destination->Attribute.NamespaceCch = Namespace->NamespaceCch;
    }
    else
    {
        Destination->Attribute.Namespace = NULL;
        Destination->Attribute.NamespaceCch = 0;
    }

    if ((Name != NULL) && (NameCch != 0))
    {
        Destination->Attribute.Name = (PWSTR) Cursor;
        ::memcpy(
            Cursor,
            Name,
            NameCch * sizeof(WCHAR));
        ((PWSTR) Destination->Attribute.Name) [NameCch] = L'\0';
        Destination->Attribute.NameCch = NameCch;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((NameCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        Destination->Attribute.Name = NULL;
        Destination->Attribute.NameCch = 0;
    }

    if ((Value != NULL) && (ValueCch != 0))
    {
        Destination->Attribute.Value = (PWSTR) Cursor;
        ::memcpy(
            Cursor,
            Value,
            ValueCch * sizeof(WCHAR));
        ((PWSTR) Destination->Attribute.Value)[ValueCch] = L'\0';
        Destination->Attribute.ValueCch = ValueCch;
        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((ValueCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        Destination->Attribute.Value = NULL;
        Destination->Attribute.ValueCch = 0;
    }

    Destination->WholeAttributeHash = 
        ::SxspHashAssemblyIdentityAttribute(
            SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
            SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME |
            SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE,
            &Destination->Attribute);
    Destination->NamespaceAndNameHash =
        ::SxspHashAssemblyIdentityAttribute(
            SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE |
            SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME,
            &Destination->Attribute);
}

BOOL
SxspAllocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    )
{
    // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Switch to FN_PROLOG_WIN32 and smart pointer class
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesNeeded = 0;
    PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewAttribute = NULL;

    if (Destination != NULL)
        *Destination = NULL;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Destination != NULL);
    PARAMETER_CHECK((NameCch == 0) || (Name != NULL));
    PARAMETER_CHECK((ValueCch == 0) || (Value != NULL));

    IFW32FALSE_EXIT(::SxspComputeInternalAssemblyIdentityAttributeBytesRequired(0, Name, NameCch, Value, ValueCch, &BytesNeeded));
    // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
    IFALLOCFAILED_EXIT(NewAttribute = (PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) FUSION_RAW_ALLOC(BytesNeeded, INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));
    ::SxspPopulateInternalAssemblyIdentityAttribute(0, Namespace, Name, NameCch, Value, ValueCch, NewAttribute);

    NewAttribute->RefCount = 1;

    *Destination = NewAttribute;
    NewAttribute = NULL;

    fSuccess = TRUE;
Exit:
    if (NewAttribute != NULL)
        FUSION_RAW_DEALLOC(NewAttribute);

    return fSuccess;
}

BOOL
SxspDuplicateInternalAssemblyIdentityAttribute(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T BytesNeeded = 0;
    PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewAttribute = NULL;
    PVOID Cursor;

    if (Destination != NULL)
        *Destination = NULL;

    ASSERT(Source != NULL);
    ASSERT(Destination != NULL);

    if (Namespace != NULL)
    {
        IFW32FALSE_EXIT(::SxspComputeInternalAssemblyIdentityAttributeBytesRequired(0, Source->Attribute.Name, Source->Attribute.NameCch, Source->Attribute.Value, Source->Attribute.ValueCch, &BytesNeeded));
        IFALLOCFAILED_EXIT(NewAttribute = (PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) FUSION_RAW_ALLOC(BytesNeeded, INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));

        NewAttribute->Attribute.Flags = 0;
        NewAttribute->Namespace = Namespace;
		NewAttribute->RefCount = 1;

        Cursor = (PVOID) (NewAttribute + 1);

        NewAttribute->Attribute.Namespace = Namespace->Namespace;
        NewAttribute->Attribute.NamespaceCch = Namespace->NamespaceCch;

        if ((Source->Attribute.Name != NULL) && (Source->Attribute.NameCch != 0))
        {
            NewAttribute->Attribute.Name = (PWSTR) Cursor;
            memcpy(
                Cursor,
                Source->Attribute.Name,
                Source->Attribute.NameCch * sizeof(WCHAR));
            ((PWSTR) NewAttribute->Attribute.Name) [Source->Attribute.NameCch] = L'\0';
            NewAttribute->Attribute.NameCch = Source->Attribute.NameCch;
            Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Source->Attribute.NameCch + 1) * sizeof(WCHAR)));
        }
        else
        {
            NewAttribute->Attribute.Name = NULL;
            NewAttribute->Attribute.NameCch = 0;
        }

        if ((Source->Attribute.Value != NULL) && (Source->Attribute.ValueCch != 0))
        {
            NewAttribute->Attribute.Value = (PWSTR) Cursor;
            memcpy(
                Cursor,
                Source->Attribute.Value,
                Source->Attribute.ValueCch * sizeof(WCHAR));
            ((PWSTR) NewAttribute->Attribute.Value)[Source->Attribute.ValueCch] = L'\0';
            NewAttribute->Attribute.ValueCch = Source->Attribute.ValueCch;
            Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Source->Attribute.ValueCch + 1) * sizeof(WCHAR)));
        }
        else
        {
            NewAttribute->Attribute.Value = NULL;
            NewAttribute->Attribute.ValueCch = 0;
        }

        NewAttribute->WholeAttributeHash = Source->WholeAttributeHash;
        NewAttribute->NamespaceAndNameHash = Source->NamespaceAndNameHash;
    }
    else
    {
        Source->RefCount++;
        NewAttribute = Source;
    }

    *Destination = NewAttribute;
    NewAttribute = NULL;

    fSuccess = TRUE;
Exit:
    if (NewAttribute != NULL)
        FUSION_RAW_DEALLOC(NewAttribute);

    return fSuccess;
}

VOID
SxspDeallocateInternalAssemblyIdentityAttribute(
    PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    )
{
    if (Attribute != NULL)
    {
        ASSERT_NTC(Attribute->RefCount != 0);

        if ((Attribute->RefCount == 0) ||
            ((--Attribute->RefCount) == 0))
            FUSION_RAW_DEALLOC((PVOID) Attribute);
    }
}

LONG
MikesComparison(
    PCWSTR s1,
    SIZE_T cch1,
    PCWSTR s2,
    SIZE_T cch2
    )
{
    const PCWSTR Limit = (s1 + (cch1 <= cch2 ? cch1 : cch2));

    while (s1 < Limit) {
        const LONG l = ((LONG) (*s1++)) - ((LONG) (*s2++));
        if (l != 0)
            return l;
    }
    
    if (cch1 < cch2)
        return 1;

    if (cch1 == cch2)
        return 0;

    return -1;
}

ULONG
SxspCompareAssemblyIdentityAttributes(
    DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2
    )
{
    LONG Comparison = 0;

    ASSERT_NTC(Flags != 0);
    ASSERT_NTC((Flags & ~(SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE)) == 0);
    ASSERT_NTC(Attribute1 != NULL);
    ASSERT_NTC(Attribute2 != NULL);

    if (Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE)
    {
//        const LONG Comparison1 = ::FusionpCompareStrings(Attribute1->Namespace, Attribute1->NamespaceCch, Attribute2->Namespace, Attribute2->NamespaceCch, false);
        const LONG Comparison1 = ::MikesComparison(Attribute1->Namespace, Attribute1->NamespaceCch, Attribute2->Namespace, Attribute2->NamespaceCch);
        if (Comparison1 != 0)
        {
            // we have get the result
            Comparison = Comparison1;
            goto done;
        }
    }

    if (Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME) {
        const LONG Comparison2 = ::MikesComparison(Attribute1->Name, Attribute1->NameCch, Attribute2->Name, Attribute2->NameCch);
        if (Comparison2 != 0)
        {
            // we have get the result
            Comparison = Comparison2;
            goto done;
        }
    }

    if (Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE) {
        const LONG Comparison3 = ::FusionpCompareStrings(Attribute1->Value, Attribute1->ValueCch, Attribute2->Value, Attribute2->ValueCch, true);
        if (Comparison3 != 0)
        { 
            // we have get the result
            Comparison = Comparison3;
            goto done;
        }
    }

done:
    if (Comparison < 0)
        return SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN;
    else if (Comparison == 0)
        return SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;

    return SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN;
}

BOOL
SxsCompareAssemblyIdentityAttributes(
    DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2,
    OUT ULONG *ComparisonResult
    )
{
    FN_PROLOG_WIN32
    LONG Comparison = 0, Comparison1, Comparison2, Comparison3;

    if (Flags == 0)
        Flags = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;

    PARAMETER_CHECK((Flags & ~(SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME |
                    SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE)) == 0);
    PARAMETER_CHECK(Attribute1 != NULL);
    PARAMETER_CHECK(Attribute2 != NULL);
    PARAMETER_CHECK(ComparisonResult != NULL);

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE) {
        Comparison1 = ::FusionpCompareStrings(Attribute1->Namespace, Attribute1->NamespaceCch, Attribute2->Namespace, Attribute2->NamespaceCch, false);
        if (Comparison1 != 0) { // we have get the result
            Comparison = Comparison1 ;
            goto done;
        }
    }

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME) {
        Comparison2 = ::FusionpCompareStrings(Attribute1->Name, Attribute1->NameCch, Attribute2->Name, Attribute2->NameCch, false);
        if (Comparison2 != 0) { // we have get the result
            Comparison = Comparison2;
            goto done;
        }
    }

    if ( Flags & SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE){
        Comparison3 = ::FusionpCompareStrings(Attribute1->Value, Attribute1->ValueCch, Attribute2->Value, Attribute2->ValueCch, true);
        if (Comparison3 != 0) { // we have get the result
            Comparison = Comparison3;
            goto done;
        }
    }
    Comparison = 0;
done:
    if (Comparison < 0)
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN;
    else if (Comparison == 0)
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;
    else
        *ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN;

    FN_EPILOG
}

int
__cdecl
SxspCompareInternalAttributesForQsort(
    const void *elem1,
    const void *elem2
    )
{
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE * p1 = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *)elem1;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE patt1 = *p1;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE * p2 = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *)elem2;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE patt2 = *p2;
    LONG Comparison;

    Comparison = ::FusionpCompareStrings(patt1->Attribute.Namespace, patt1->Attribute.NamespaceCch, patt2->Attribute.Namespace, patt2->Attribute.NamespaceCch, false);
    if (Comparison == 0)
        Comparison = ::FusionpCompareStrings(patt1->Attribute.Name, patt1->Attribute.NameCch, patt2->Attribute.Name, patt2->Attribute.NameCch, false);
    if (Comparison == 0)
        Comparison = ::FusionpCompareStrings(patt1->Attribute.Value, patt1->Attribute.ValueCch, patt2->Attribute.Value, patt2->Attribute.ValueCch, true);
    return Comparison;
}

int
__cdecl
SxspCompareULONGsForQsort(
    const void *elem1,
    const void *elem2
    )
{
    ULONG *pul1 = (ULONG *) elem1;
    ULONG *pul2 = (ULONG *) elem2;

    if (*pul1 > *pul2)
        return -1;
    else if (*pul1 == *pul2)
        return 0;

    // else
    return 1;
}

BOOL
SxspCompareAssemblyIdentityAttributeLists(
    DWORD Flags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List1,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List2,
    ULONG *ComparisonResultOut
    )
{
    FN_PROLOG_WIN32
    ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL;
    ULONG i;

    PARAMETER_CHECK(
        !((Flags != 0) ||
         ((AttributeCount != 0) &&
          ((List1 == NULL) ||
           (List2 == NULL))) ||
         (ComparisonResultOut == NULL)));

    for (i=0; i<AttributeCount; i++)
    {
        IFW32FALSE_EXIT(::SxsCompareAssemblyIdentityAttributes(0, &List1[i]->Attribute, &List2[i]->Attribute, &ComparisonResult));

        if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL){
            break;
        }
    }

    *ComparisonResultOut = ComparisonResult;

    FN_EPILOG
}

BOOL
SxspHashInternalAssemblyIdentityAttributes(
    DWORD Flags,
    ULONG Count,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes,
    ULONG *HashOut
    )
{
    FN_PROLOG_WIN32
    ULONG Hash = 0;
    ULONG i;

    if (HashOut != NULL)
        *HashOut = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK((Count == 0) || (Attributes != NULL));
    PARAMETER_CHECK(HashOut != NULL);

    for (i=0; i<Count; i++)
        Hash = (Hash * 65599) + Attributes[i]->WholeAttributeHash;

    *HashOut = Hash;

    FN_EPILOG
}

VOID SxspDbgPrintInternalAssemblyIdentityAttribute(DWORD dwflags, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute)
{
    ::FusionpDbgPrintEx(dwflags, "Attribute: \n"
        "\tNamespace = %S, \tNamespaceCch = %d\n"
        "\tAttributeName = %S, \tAttributeNameCch = %d\n"
        "\tAttributeValue = %S, \tAttributeValueCch = %d\n\n",
        Attribute->Attribute.Namespace == NULL ? L"" : Attribute->Attribute.Namespace, Attribute->Attribute.NamespaceCch,
        Attribute->Attribute.Name == NULL ? L"" : Attribute->Attribute.Name, Attribute->Attribute.NameCch,
        Attribute->Attribute.Value == NULL ? L"" : Attribute->Attribute.Value, Attribute->Attribute.ValueCch);
}

VOID
SxspDbgPrintInternalAssemblyIdentityAttributes(DWORD dwflags, ULONG AttributeCount, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes)
{
    for (SIZE_T i=0; i<AttributeCount; i++)
    {
        ::SxspDbgPrintInternalAssemblyIdentityAttribute(dwflags, Attributes[i]);
    }
}

VOID SxspDbgPrintAssemblyIdentity(DWORD dwflags, PCASSEMBLY_IDENTITY pAssemblyIdentity){
    if (pAssemblyIdentity != NULL)
    {
        ::SxspDbgPrintInternalAssemblyIdentityAttributes(
            dwflags,
            pAssemblyIdentity->AttributeCount,
            pAssemblyIdentity->AttributePointerArray);
    }
}

VOID SxspDbgPrintAssemblyIdentityAttribute(DWORD dwflags, PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute)
{
    ::FusionpDbgPrintEx(dwflags, "Attribute: \n"
        "\tNamespace = %S, \tNamespaceCch = %d\n"
        "\tAttributeName = %S, \tAttributeNameCch = %d\n"
        "\tAttributeValue = %S, \tAttributeValueCch = %d\n\n",
        Attribute->Namespace == NULL ? L"" : Attribute->Namespace, Attribute->NamespaceCch,
        Attribute->Name == NULL ? L"" : Attribute->Name, Attribute->NameCch,
        Attribute->Value == NULL ? L"" : Attribute->Value, Attribute->ValueCch);
}

VOID
SxspDbgPrintAssemblyIdentityAttributes(DWORD dwflags, ULONG AttributeCount, PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes)
{
    for (SIZE_T i=0; i<AttributeCount; i++)
        ::SxspDbgPrintAssemblyIdentityAttribute(dwflags, Attributes[i]);
}

BOOL
SxsCreateAssemblyIdentity(
    DWORD Flags,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    ULONG AttributeCount,
    PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG AttributeArraySize = 0;
    SIZE_T BytesNeeded = 0;
    ULONG i;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    ULONG NamespaceArraySize = 0;
    ULONG NamespaceCount = 0;

#if DBG
    ::SxspDbgPrintAssemblyIdentityAttributes(FUSION_DBG_LEVEL_VERBOSE, AttributeCount, Attributes);
#endif
    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    if (((Flags & ~(SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) != 0) ||
        ((Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
         ((AttributeCount != 0) && (Attributes == NULL)))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    //  Validate all our inputs before we get started...
    for (i=0; i<AttributeCount; i++)
    {
        IFW32FALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(0, Attributes[i]));
    }

    //
    //  If we were told that this is a frozen assembly identity, we could be super-smart and
    //  have a single allocation for the whole thing.  Instead we'll leave that optimization
    //  for a future maintainer.  We'll at least be smart enough to allocate both the
    //  assembly identity and the array of attribute pointers in a single whack tho'.
    //

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        AttributeArraySize = AttributeCount;
    }
    else
    {
        // For non-frozen identities, we'll add a rounding factor and round up for the number of
        // array elements.
        AttributeArraySize = (AttributeCount + (1 << ROUNDING_FACTOR_BITS)) & ~((1 << ROUNDING_FACTOR_BITS) - 1);
    }

    // allocate everything except namespace array
    BytesNeeded = sizeof(ASSEMBLY_IDENTITY) + (AttributeArraySize * sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));
    IFALLOCFAILED_EXIT(AssemblyIdentity = (PASSEMBLY_IDENTITY) FUSION_RAW_ALLOC(BytesNeeded, ASSEMBLY_IDENTITY));

    if (AttributeArraySize != 0)
    {
        AttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) (AssemblyIdentity + 1);

        // Initialize the pointers so we can clean up non-NULL ones in the error path
        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

        IFW32FALSE_EXIT(
            ::SxspFindAssemblyIdentityNamespaceInArray(
                    SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND,
                    &NamespacePointerArray,
                    &NamespaceArraySize,
                    &NamespaceCount,
                    Attributes[i]->Namespace,
                    Attributes[i]->NamespaceCch,
                    &NamespacePointer));
        // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
        IFW32FALSE_EXIT(
            ::SxspAllocateInternalAssemblyIdentityAttribute(
                0,
                NamespacePointer,
                Attributes[i]->Name,
                Attributes[i]->NameCch,
                Attributes[i]->Value,
                Attributes[i]->ValueCch,
                &AttributePointerArray[i]));
    }

    // sort 'em.
    ::qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), &::SxspCompareInternalAttributesForQsort);

    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION; // namespace is allocated sperately
    AssemblyIdentity->Type = Type;
    AssemblyIdentity->HashDirty = TRUE;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    IFW32FALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, AssemblyIdentity));

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    if ((AttributePointerArray != NULL) && (AttributeCount != 0))
    {
        for (i=0; i<AttributeCount; i++)
            ::SxspDeallocateInternalAssemblyIdentityAttribute(const_cast<PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE>(AttributePointerArray[i]));
    }

    if ((NamespacePointerArray != NULL) && (NamespaceCount != 0))
    {
        for (i=0; i<NamespaceCount; i++)
            ::SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);

        FUSION_DELETE_ARRAY(NamespacePointerArray);
    }

    if (AssemblyIdentity != NULL)
    {
        FUSION_RAW_DEALLOC(AssemblyIdentity);
    }

    return fSuccess;
}

BOOL
SxspCreateAssemblyIdentity(
    DWORD Flags,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG AttributeArraySize = 0;
    SIZE_T BytesNeeded = 0;
    ULONG i;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = NULL;
    ULONG NamespaceArraySize = 0;
    ULONG NamespaceCount = 0;

#if DBG
    ::SxspDbgPrintAssemblyIdentityAttributes(FUSION_DBG_LEVEL_VERBOSE, AttributeCount, (PCASSEMBLY_IDENTITY_ATTRIBUTE const *) Attributes);
#endif

    if (AssemblyIdentityOut != NULL)
        *AssemblyIdentityOut = NULL;

    if (((Flags & ~(SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)) != 0) ||
        ((Type != ASSEMBLY_IDENTITY_TYPE_DEFINITION) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_REFERENCE) &&
         (Type != ASSEMBLY_IDENTITY_TYPE_WILDCARD)) ||
         ((AttributeCount != 0) && (Attributes == NULL)))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    //  If we were told that this is a frozen assembly identity, we could be super-smart and
    //  have a single allocation for the whole thing.  Instead we'll leave that optimization
    //  for a future maintainer.  We'll at least be smart enough to allocate both the
    //  assembly identity and the array of attribute pointers in a single whack tho'.
    //

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
    {
        AttributeArraySize = AttributeCount;
    }
    else
    {
        // For non-frozen identities, we'll add a rounding factor and round up for the number of
        // array elements.
        AttributeArraySize = (AttributeCount + (1 << ROUNDING_FACTOR_BITS)) & ~((1 << ROUNDING_FACTOR_BITS) - 1);
    }

    // allocate everything except namespace array
    BytesNeeded = sizeof(ASSEMBLY_IDENTITY) + (AttributeArraySize * sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));
    IFALLOCFAILED_EXIT(AssemblyIdentity = (PASSEMBLY_IDENTITY) FUSION_RAW_ALLOC(BytesNeeded, ASSEMBLY_IDENTITY));

    if (AttributeArraySize != 0)
    {
        AttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) (AssemblyIdentity + 1);

        // Initialize the pointers so we can clean up non-NULL ones in the error path
        for (i=0; i<AttributeArraySize; i++)
            AttributePointerArray[i] = NULL;
    }

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE NamespacePointer = NULL;

        if (Attributes[i]->Attribute.NamespaceCch != 0)
        {
            IFW32FALSE_EXIT(
                ::SxspFindAssemblyIdentityNamespaceInArray(
                        SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND,
                        &NamespacePointerArray,
                        &NamespaceArraySize,
                        &NamespaceCount,
                        Attributes[i]->Attribute.Namespace,
                        Attributes[i]->Attribute.NamespaceCch,
                        &NamespacePointer));
        }

        IFW32FALSE_EXIT(
            ::SxspDuplicateInternalAssemblyIdentityAttribute(
                NamespacePointer,
                const_cast<PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE>(Attributes[i]),
                &AttributePointerArray[i]));
    }

    // sort 'em.
//    qsort((PVOID) AttributePointerArray, AttributeCount, sizeof(PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE), SxspCompareInternalAttributesForQsort);

    AssemblyIdentity->AttributeArraySize = AttributeArraySize;
    AssemblyIdentity->AttributeCount = AttributeCount;
    AssemblyIdentity->AttributePointerArray = AttributePointerArray;
    AssemblyIdentity->NamespaceArraySize = NamespaceArraySize;
    AssemblyIdentity->NamespaceCount = NamespaceCount;
    AssemblyIdentity->NamespacePointerArray = NamespacePointerArray;
    AssemblyIdentity->Flags = 0;
    AssemblyIdentity->InternalFlags = ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION; // namespace is allocated sperately
    AssemblyIdentity->Type = Type;
    AssemblyIdentity->HashDirty = TRUE;

    AttributePointerArray = NULL;
    NamespacePointerArray = NULL;

    if (Flags & SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    if ((AttributePointerArray != NULL) && (AttributeCount != 0))
    {
        for (i=0; i<AttributeCount; i++)
            ::SxspDeallocateInternalAssemblyIdentityAttribute(const_cast<PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE>(AttributePointerArray[i]));
    }

    if ((NamespacePointerArray != NULL) && (NamespaceCount != 0))
    {
        for (i=0; i<NamespaceCount; i++)
            ::SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);

        FUSION_DELETE_ARRAY(NamespacePointerArray);
    }

    if (AssemblyIdentity != NULL)
    {
        FUSION_RAW_DEALLOC(AssemblyIdentity);
    }

    return fSuccess;
}

BOOL
SxsFreezeAssemblyIdentity(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    // We could possibly do something really interesting like realloc the whole thing but
    // instead we'll just set the flag that stops future modifications.

    AssemblyIdentity->Flags |= ASSEMBLY_IDENTITY_FLAG_FROZEN;

    FN_EPILOG
}

VOID
SxsDestroyAssemblyIdentity(
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    if (AssemblyIdentity == NULL)
        return;

    FN_TRACE();
    CSxsPreserveLastError ple;

    ULONG i;

    //
    // An identity that's created frozen (whether created new or copied from an existing identity)
    // uses a single allocation for everything.  Only free the suballocations if we're not
    // in this state.
    //

    if (!(AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_SINGLE_ALLOCATION_FOR_EVERYTHING))
    {
        const ULONG AttributeCount = AssemblyIdentity->AttributeCount;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = AssemblyIdentity->AttributePointerArray;
        const ULONG NamespaceCount = AssemblyIdentity->NamespaceCount;
        PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

        for (i=0; i<AttributeCount; i++)
        {
            ::SxspDeallocateInternalAssemblyIdentityAttribute((PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) AttributePointerArray[i]);
            AttributePointerArray[i] = NULL;
        }

        for (i=0; i<NamespaceCount; i++)
        {
            ::SxspDeallocateAssemblyIdentityNamespace(NamespacePointerArray[i]);
            NamespacePointerArray[i] = NULL;
        }

        if (AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION)
        {
            FUSION_DELETE_ARRAY(AttributePointerArray);
            AssemblyIdentity->AttributePointerArray = NULL;
        }

        if (AssemblyIdentity->InternalFlags & ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION)
        {
            FUSION_DELETE_ARRAY(NamespacePointerArray);
            AssemblyIdentity->NamespacePointerArray = NULL;
        }
    }

    FUSION_RAW_DEALLOC(AssemblyIdentity);

    ple.Restore();
}

BOOL
SxspCopyInternalAssemblyIdentityAttributeOut(
    DWORD Flags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE DestinationBuffer,
    SIZE_T *BytesCopiedOrRequired
    )
{
    FN_PROLOG_WIN32
    SIZE_T BytesRequired = 0;
    PVOID Cursor;

    if (BytesCopiedOrRequired != NULL)
        *BytesCopiedOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (DestinationBuffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesCopiedOrRequired != NULL));

    IFW32FALSE_EXIT(::SxspComputeAssemblyIdentityAttributeBytesRequired(0, &Attribute->Attribute, &BytesRequired));

    if (BufferSize < BytesRequired)
    {
        if (BytesCopiedOrRequired != NULL)
            *BytesCopiedOrRequired = BytesRequired;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);
    }

    // We must be in the clear...
    DestinationBuffer->Flags = 0;

    Cursor = (PVOID) (DestinationBuffer + 1);

    if (Attribute->Attribute.NamespaceCch != 0)
    {
        DestinationBuffer->Namespace = (PWSTR) Cursor;
        DestinationBuffer->NamespaceCch = Attribute->Attribute.NamespaceCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        ::memcpy(
            Cursor,
            Attribute->Attribute.Namespace,
            (Attribute->Attribute.NamespaceCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.NamespaceCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Namespace = NULL;
        DestinationBuffer->NamespaceCch = 0;
    }

    if (Attribute->Attribute.NameCch != 0)
    {
        DestinationBuffer->Name = (PWSTR) Cursor;
        DestinationBuffer->NameCch = Attribute->Attribute.NameCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        ::memcpy(
            Cursor,
            Attribute->Attribute.Name,
            (Attribute->Attribute.NameCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.NameCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Name = NULL;
        DestinationBuffer->NameCch = 0;
    }

    if (Attribute->Attribute.ValueCch != 0)
    {
        DestinationBuffer->Value = (PWSTR) Cursor;
        DestinationBuffer->ValueCch = Attribute->Attribute.ValueCch;

        // We always internally store the strings with a null terminating character, so just copy
        // it with the body of the string.
        memcpy(
            Cursor,
            Attribute->Attribute.Value,
            (Attribute->Attribute.ValueCch + 1) * sizeof(WCHAR));

        Cursor = (PVOID) (((ULONG_PTR) Cursor) + ((Attribute->Attribute.ValueCch + 1) * sizeof(WCHAR)));
    }
    else
    {
        DestinationBuffer->Value = NULL;
        DestinationBuffer->ValueCch = 0;
    }

    if (BytesCopiedOrRequired != NULL)
    {
        *BytesCopiedOrRequired = (((ULONG_PTR) Cursor) - ((ULONG_PTR) DestinationBuffer));
    }

    FN_EPILOG
}

PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE
SxspLocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT ULONG *LastIndexSearched OPTIONAL
    )
{
    ULONG i = 0;
    ULONG AttributeCount = 0;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ULONG LowIndex = 0;
    ULONG HighIndexPlusOne = 0;
    ULONG CompareAttributesFlags = 0;

    if (LastIndexSearched != NULL)
        *LastIndexSearched = 0;

    ASSERT_NTC(
        !(((Flags & ~(SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                    SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)) != 0) ||
         (AssemblyIdentity == NULL) ||
         (Attribute == NULL)));

    ASSERT_NTC(
        !((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) &&
          !(Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)));

    ASSERT_NTC(
        !((Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE) &&
          !(Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)));

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;

    if (Flags & SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;

    AttributeCount = AssemblyIdentity->AttributeCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;

    LowIndex = 0;
    HighIndexPlusOne = AttributeCount;
    i = 0;

    while (LowIndex < HighIndexPlusOne)
    {
        i = (LowIndex + HighIndexPlusOne) / 2;

        if (i == HighIndexPlusOne)
        {
            i = LowIndex;
        }

        const ULONG ComparisonResult = ::SxspCompareAssemblyIdentityAttributes(CompareAttributesFlags, Attribute, &AttributePointerArray[i]->Attribute);

        ASSERT_NTC(
            (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL) ||
            (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN) ||
            (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN));

        if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
        {
            InternalAttribute = AttributePointerArray[i];
            break;
        }
        else if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN)
        {
            if ( HighIndexPlusOne == i){
                i--;
                break;
            }
            else
                HighIndexPlusOne = i;
        }
        else if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN)
        {
            if ( LowIndex == i){
                i++;
                break;
            }
            else
                LowIndex = i;
        }
    }

    // If it's equal, there's no guarantee it's the first.  Back up to find the first non-equal match
    if (InternalAttribute != NULL)
    {
        while (i > 0)
        {
            const ULONG ComparisonResult = ::SxspCompareAssemblyIdentityAttributes(CompareAttributesFlags, Attribute, &AttributePointerArray[i - 1]->Attribute);
            if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                break;

            i--;
            InternalAttribute = AttributePointerArray[i];
        }
    }

    if (LastIndexSearched != NULL)
        *LastIndexSearched = i;

    return InternalAttribute;
}

BOOL
SxsInsertAssemblyIdentityAttribute(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE NewInternalAttribute = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *NewAttributePointerArray = NULL;
    ULONG NewAttributeArraySize = 0;
    ULONG i;
    ULONG LastIndexSearched;

    PARAMETER_CHECK((Flags & ~(SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyIdentityAttribute != NULL);

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));
    IFW32FALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(0, AssemblyIdentityAttribute));

    INTERNAL_ERROR_CHECK((AssemblyIdentity->Flags & ASSEMBLY_IDENTITY_FLAG_FROZEN) == 0);

    IFW32FALSE_EXIT(
        ::SxspFindAssemblyIdentityNamespace(
            SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND,
            AssemblyIdentity,
            AssemblyIdentityAttribute->Namespace,
            AssemblyIdentityAttribute->NamespaceCch,
            &Namespace));

    // Let's see if we can find it.
    InternalAttribute =
        ::SxspLocateInternalAssemblyIdentityAttribute(
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
            SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME,
            AssemblyIdentity,
            AssemblyIdentityAttribute,
            &LastIndexSearched);

    if (InternalAttribute != NULL)
    {
        if (Flags & SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING)
        {
            // Ok, replace it!
            // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
            IFW32FALSE_EXIT(
                ::SxspAllocateInternalAssemblyIdentityAttribute(
                    0,
                    Namespace,
                    AssemblyIdentityAttribute->Name,
                    AssemblyIdentityAttribute->NameCch,
                    AssemblyIdentityAttribute->Value,
                    AssemblyIdentityAttribute->ValueCch,
                    &NewInternalAttribute));
            AssemblyIdentity->AttributePointerArray[LastIndexSearched] = NewInternalAttribute;
            NewInternalAttribute = NULL;

            ::SxspDeallocateInternalAssemblyIdentityAttribute(const_cast<PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE>(InternalAttribute));
        }
        else
        {
            // We actually wanted it to fail...
            ORIGINATE_WIN32_FAILURE_AND_EXIT(InserttingNonDuplicateAttribute, ERROR_DUP_NAME);
        }
    }
    else
    {
        // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
        IFW32FALSE_EXIT(
            ::SxspAllocateInternalAssemblyIdentityAttribute(
                0,
                Namespace,
                AssemblyIdentityAttribute->Name,
                AssemblyIdentityAttribute->NameCch,
                AssemblyIdentityAttribute->Value,
                AssemblyIdentityAttribute->ValueCch,
                &NewInternalAttribute));

        // Now we have it and we even know where to put it.  Grow the array if we need to.
        if (AssemblyIdentity->AttributeCount == AssemblyIdentity->AttributeArraySize)
        {
            NewAttributeArraySize = AssemblyIdentity->AttributeCount + 8;

            // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
            IFALLOCFAILED_EXIT(NewAttributePointerArray = (PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *) FUSION_RAW_ALLOC(sizeof(PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE) * NewAttributeArraySize, PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE));

            // Instead of copying the data and then shuffling, we'll copy the stuff before the insertion
            // point, fill in at the insertion point and then copy the rest.

            for (i=0; i<LastIndexSearched; i++)
                NewAttributePointerArray[i] = AssemblyIdentity->AttributePointerArray[i];

            for (i=LastIndexSearched; i<AssemblyIdentity->AttributeCount; i++)
                NewAttributePointerArray[i+1] = AssemblyIdentity->AttributePointerArray[i];

            if (AssemblyIdentity->AttributePointerArray != NULL)
                FUSION_RAW_DEALLOC((PVOID) AssemblyIdentity->AttributePointerArray);

            AssemblyIdentity->AttributePointerArray = NewAttributePointerArray;
            AssemblyIdentity->AttributeArraySize = NewAttributeArraySize;
        }
        else
        {
            // The array's big enough; shuffle the ending part of the array down one.
            for (i=AssemblyIdentity->AttributeCount; i>LastIndexSearched; i--)
                AssemblyIdentity->AttributePointerArray[i] = AssemblyIdentity->AttributePointerArray[i-1];
        }

        AssemblyIdentity->AttributePointerArray[LastIndexSearched] = NewInternalAttribute;
        NewInternalAttribute = NULL;

        AssemblyIdentity->AttributeCount++;
    }

    AssemblyIdentity->HashDirty = TRUE;

    fSuccess = TRUE;
Exit:
    if (NewInternalAttribute != NULL)
        ::SxspDeallocateInternalAssemblyIdentityAttribute(const_cast<PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE>(NewInternalAttribute));

    return fSuccess;
}

BOOL
SxsRemoveAssemblyIdentityAttributesByOrdinal(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    ULONG Count
    )
{
    FN_PROLOG_WIN32
    ULONG AttributeCount;
    ULONG i;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG StopIndex;

    if ((Flags != 0) ||
        (AssemblyIdentity == NULL) ||
        (Count == 0))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    AttributeCount = AssemblyIdentity->AttributeCount;
    AttributePointerArray = AssemblyIdentity->AttributePointerArray;

    // We can't delete outside the bounds of [0 .. AttributeCount - 1]
    if ((Ordinal >= AssemblyIdentity->AttributeCount) ||
        (Count > AssemblyIdentity->AttributeCount) ||
        ((Ordinal + Count) > AssemblyIdentity->AttributeCount))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    StopIndex = Ordinal + Count;

    // Let's get rid of them!  We're going to go through the array twice; it's somewhat
    // unnecessary but in the first run, we're going to NULL out any attribute pointers
    // that we're removing and clean up namespaces that aren't in use any more.  On the
    // second pass, we'll compress the array down.  This is somewhat wasteful, but
    // in the alternative case, we end up doing "Count" shifts down of the tail of the array.

    for (i = Ordinal; i < StopIndex; i++)
    {
        PCASSEMBLY_IDENTITY_NAMESPACE Namespace = NULL;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AttributePointerArray[i];

        // If this is the last use of this namespace, keep track of it so we can
        // clean it up.

        if ((i + 1) < AttributeCount)
        {
            // If the next attribute has a different namespace, there's some possibility
            // that this attribute was the last one that used it, so we'll delete the
            // attribute then ask to get rid of the namespace if there aren't any more
            // attributes using it.
            if (AttributePointerArray[i+1]->Namespace != InternalAttribute->Namespace)
                Namespace = InternalAttribute->Namespace;
        }

        AttributePointerArray[i] = NULL;

        SxspDeallocateInternalAssemblyIdentityAttribute(const_cast<PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE>(InternalAttribute));

        if (Namespace != NULL)
            SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(0, AssemblyIdentity, Namespace);
    }

    for (i = StopIndex; i < AttributeCount; i++)
    {
        AttributePointerArray[i - Count] = AttributePointerArray[i];
        AttributePointerArray[i] = NULL;
    }

    AssemblyIdentity->AttributeCount -= Count;
    AssemblyIdentity->HashDirty = TRUE;

    FN_EPILOG
}

BOOL
SxsFindAssemblyIdentityAttribute(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    ULONG *OrdinalOut,
    ULONG *CountOut OPTIONAL
    )
{
    FN_PROLOG_WIN32
    ULONG ValidateAttributeFlags = 0;
    ULONG LocateAttributeFlags = 0;
    ULONG CompareAttributesFlags = 0;
    ULONG Ordinal;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ULONG AttributeCount = 0;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = NULL;
    ULONG i;
    ULONG ComparisonResult;

    if (OrdinalOut != NULL)
        *OrdinalOut = 0;

    if (CountOut != NULL)
        *CountOut = 0;

    if (((Flags & ~(SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) != 0) ||
        (AssemblyIdentity == NULL) ||
        (Attribute == NULL))
    {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (Flags == 0)
        Flags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE;

    PARAMETER_CHECK(
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) == 0) ||
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) != 0));

    PARAMETER_CHECK((Flags &
                        (SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE |
                         SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME |
                         SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)) != 0);

    PARAMETER_CHECK(
        ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE) == 0) ||
        (((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME) != 0) &&
         ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) != 0)));

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    ValidateAttributeFlags = 0;

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
    {
        ValidateAttributeFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
        LocateAttributeFlags |= SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE;
        CompareAttributesFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    IFW32FALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(ValidateAttributeFlags, Attribute));

    InternalAttribute =
        ::SxspLocateInternalAssemblyIdentityAttribute(
            LocateAttributeFlags,
            AssemblyIdentity,
            Attribute,
            &Ordinal);

    if (InternalAttribute == NULL)
    {
        if ((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS) == 0)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(AttributeNotFound, ERROR_NOT_FOUND);
    }
    else
    {
        if (CountOut != NULL)
        {
            // We found it, now let's look for how many matches we have.  We'll separately handle the three levels
            // of specificity:

            AttributeCount = AssemblyIdentity->AttributeCount;
            AttributePointerArray = AssemblyIdentity->AttributePointerArray;

            for (i = (Ordinal + 1); i<AttributeCount; i++)
            {
                PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE AnotherInternalAttribute = AttributePointerArray[i];

                if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->WholeAttributeHash != InternalAttribute->WholeAttributeHash)
                        break;
                }
                else if (Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME)
                {
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->NamespaceAndNameHash != InternalAttribute->NamespaceAndNameHash)
                        break;
                }
                else
                {
                    INTERNAL_ERROR_CHECK((Flags & SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE) != 0);
                    // If the hashes are different, we're certainly different.
                    if (AnotherInternalAttribute->Namespace->Hash != InternalAttribute->Namespace->Hash)
                        break;
                }

                IFW32FALSE_EXIT(
                    ::SxsCompareAssemblyIdentityAttributes(
                        CompareAttributesFlags,
                        Attribute,
                        &AnotherInternalAttribute->Attribute,
                        &ComparisonResult));

                if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                    break;
            }

            *CountOut = i - Ordinal;
        }

        if (OrdinalOut != NULL)
            *OrdinalOut = Ordinal;
    }

    FN_EPILOG
}

VOID
SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    )
{
    FN_TRACE();

    ASSERT(AssemblyIdentity != NULL);
    ASSERT(Flags == 0);

    if ((AssemblyIdentity != NULL) && (Namespace != NULL))
    {
        const ULONG AttributeCount = AssemblyIdentity->AttributeCount;
        PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray = AssemblyIdentity->AttributePointerArray;
        ULONG i;

        // We could do some sort of binary search here based on the text string of the namespace since
        // the attributes are sorted first on namespace, but my guess is that a single text comparison
        // is worth a few dozen simple pointer comparisons, so the attribute array would have to be
        // pretty darned huge for the k1*O(log n) to be faster than the k2*(n) algorithm to actually
        // dominate.
        for (i=0; i<AttributeCount; i++)
        {
            const PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = AttributePointerArray[i];

            if ((InternalAttribute != NULL) &&
                (InternalAttribute->Namespace == Namespace))
                break;
        }

        if (i == AttributeCount)
        {
            // We fell through; it must be orphaned.
            const ULONG NamespaceCount = AssemblyIdentity->NamespaceCount;
            PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray = AssemblyIdentity->NamespacePointerArray;

            for (i=0; i<NamespaceCount; i++)
            {
                if (NamespacePointerArray[i] == Namespace)
                    break;
            }

            // This assert should only fire if the namespace isn't actually present.
            ASSERT(i != NamespaceCount);

            if (i != NamespaceCount)
            {
                ULONG j;

                for (j=(i+1); j<NamespaceCount; j++)
                    NamespacePointerArray[j-1] = NamespacePointerArray[j];

                NamespacePointerArray[NamespaceCount - 1] = NULL;

                ::SxspDeallocateAssemblyIdentityNamespace(Namespace);

                AssemblyIdentity->NamespaceCount--;
            }
        }
    }

    AssemblyIdentity->HashDirty = TRUE;
}

BOOL
SxsGetAssemblyIdentityAttributeByOrdinal(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG Ordinal,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttributeBuffer,
    SIZE_T *BytesWrittenOrRequired
    )
{
    FN_PROLOG_WIN32

    if (BytesWrittenOrRequired != NULL)
        *BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK((BufferSize == 0) || (AssemblyIdentityAttributeBuffer != NULL));
    PARAMETER_CHECK((BufferSize != 0) || (BytesWrittenOrRequired != NULL));
    PARAMETER_CHECK(Ordinal < AssemblyIdentity->AttributeCount);

    IFW32FALSE_EXIT(
        ::SxspCopyInternalAssemblyIdentityAttributeOut(
            0,
            AssemblyIdentity->AttributePointerArray[Ordinal],
            BufferSize,
            AssemblyIdentityAttributeBuffer,
            BytesWrittenOrRequired));

    FN_EPILOG
}

BOOL
SxsDuplicateAssemblyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY Source,
    PASSEMBLY_IDENTITY *Destination
    )
{
    FN_PROLOG_WIN32
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> NewIdentity;
    ULONG CreateAssemblyIdentityFlags = 0;

    if (Destination != NULL)
        *Destination = NULL;

    PARAMETER_CHECK((Flags & ~(SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE | SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL)) == 0);
    PARAMETER_CHECK(((Flags & SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL) != 0) || (Source != NULL));
    PARAMETER_CHECK(Destination != NULL);

    if (Flags & SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE)
        CreateAssemblyIdentityFlags |= SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE;

    //
    //  We depend on the Attribute field being first in the internal attribute
    //  structure below where we callously cast a pointer to an array of
    //  internal attribute pointers into a pointer to an array of attribute pointers.
    //

    ASSERT(FIELD_OFFSET(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, Attribute) == 0);

    if (Source != NULL)
    {
        // NTRAID#NTBUG9 - 591751 - 2002/04/01 - mgrier - Use smart pointer class for better leak tracking and less cleanup/exit code
        IFW32FALSE_EXIT(
            ::SxspCreateAssemblyIdentity(
                        CreateAssemblyIdentityFlags,
                        Source->Type,
                        &NewIdentity,
                        Source->AttributeCount,
                        Source->AttributePointerArray));

        NewIdentity->Hash = Source->Hash;
        NewIdentity->HashDirty = Source->HashDirty;
    }

    *Destination = NewIdentity.Detach();

    FN_EPILOG;
}

BOOL
SxsQueryAssemblyIdentityInformation(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PVOID Buffer,
    SIZE_T BufferSize,
    ASSEMBLY_IDENTITY_INFORMATION_CLASS AssemblyIdentityInformationClass
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyIdentityInformationClass == AssemblyIdentityBasicInformation);

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    switch (AssemblyIdentityInformationClass)
    {
        case AssemblyIdentityBasicInformation: {
            PASSEMBLY_IDENTITY_BASIC_INFORMATION BasicBuffer = NULL;

            if (BufferSize < sizeof(ASSEMBLY_IDENTITY_BASIC_INFORMATION))
                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

            BasicBuffer = (PASSEMBLY_IDENTITY_BASIC_INFORMATION) Buffer;

            BasicBuffer->Flags = AssemblyIdentity->Flags;
            BasicBuffer->Type = AssemblyIdentity->Type;
            BasicBuffer->AttributeCount = AssemblyIdentity->AttributeCount;
            BasicBuffer->Hash = AssemblyIdentity->Hash;

            break;
        }
    }

    FN_EPILOG
}

BOOL
SxsEnumerateAssemblyIdentityAttributes(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE EnumerationRoutine,
    IN PVOID Context
    )
{
    FN_PROLOG_WIN32
    ULONG AttributeCount;
    ULONG i;
    ULONG ValidateFlags = 0;
    ULONG CompareFlags = 0;

    PARAMETER_CHECK(!(((Flags & ~(SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE |
                    SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME |
                    SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)) != 0) ||
        ((Flags & (SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE |
                   SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME |
                   SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)) &&
         (Attribute == NULL)) ||
        (AssemblyIdentity == NULL) ||
        (EnumerationRoutine == NULL)));

    IFW32FALSE_EXIT(::SxspValidateAssemblyIdentity(0, AssemblyIdentity));

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME;
    }

    if (Flags & SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE)
    {
        ValidateFlags |= SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE;
        CompareFlags |= SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE;
    }

    IFW32FALSE_EXIT(::SxsValidateAssemblyIdentityAttribute(ValidateFlags, Attribute));

    AttributeCount = AssemblyIdentity->AttributeCount;

    for (i=0; i<AttributeCount; i++)
    {
        PCASSEMBLY_IDENTITY_ATTRIBUTE CandidateAttribute = &AssemblyIdentity->AttributePointerArray[i]->Attribute;
        ULONG ComparisonResult = 0;

        if (CompareFlags != 0)
        {
            IFW32FALSE_EXIT(
                ::SxsCompareAssemblyIdentityAttributes(
                    CompareFlags,
                    Attribute,
                    CandidateAttribute,
                    &ComparisonResult));

            // If they're not equal, skip it!
            if (ComparisonResult != SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                continue;
        }

        (*EnumerationRoutine)(
            AssemblyIdentity,
            CandidateAttribute,
            Context);
    }

    FN_EPILOG
}

BOOL
SxspIsInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    OUT BOOL *EqualsOut
    )
{
    FN_PROLOG_WIN32

    if (EqualsOut != NULL)
        *EqualsOut = FALSE;

    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(Attribute != NULL);
    PARAMETER_CHECK(Namespace != NULL || NamespaceCch == 0);
    PARAMETER_CHECK(Name != NULL || NameCch == 0);
    PARAMETER_CHECK(EqualsOut != NULL);

    if ((NamespaceCch == Attribute->Attribute.NamespaceCch) &&
        (NameCch == Attribute->Attribute.NameCch))
    {
        if ((NamespaceCch == 0) ||
            (::memcmp(Attribute->Attribute.Namespace, Namespace, NamespaceCch * sizeof(WCHAR)) == 0))
        {
            if ((NameCch == 0) ||
                (::memcmp(Attribute->Attribute.Name, Name, NameCch * sizeof(WCHAR)) == 0))
            {
                *EqualsOut = TRUE;
            }
        }
    }

    FN_EPILOG
}

BOOL
SxspDoesStringIndicatePolicy(
    SIZE_T cchString,
    PCWSTR pcwsz,
    BOOL &fIsPolicy
    )
{
    FN_PROLOG_WIN32
    fIsPolicy = FALSE;

    //
    // If this type is just "policy", then it's a policy.
    //
    if (::FusionpEqualStrings(pcwsz, cchString, ASSEMBLY_TYPE_POLICY, ASSEMBLY_TYPE_POLICY_CCH, false)) 
    {
        fIsPolicy = TRUE;
    }
    //
    // If this string ends in -policy, then it's a policy assembly
    //
    else if ((cchString > ASSEMBLY_TYPE_POLICY_SUFFIX_CCH) &&
        ::FusionpEqualStrings(
            pcwsz + (cchString - ASSEMBLY_TYPE_POLICY_SUFFIX_CCH), 
            ASSEMBLY_TYPE_POLICY_SUFFIX_CCH,
            ASSEMBLY_TYPE_POLICY_SUFFIX,
            ASSEMBLY_TYPE_POLICY_SUFFIX_CCH,
            false))
    {
        fIsPolicy = TRUE;
    }

    FN_EPILOG;

}

BOOL
SxspDetermineAssemblyType(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    BOOL &fIsPolicyAssembly
    )
{
    FN_PROLOG_WIN32;
    PCWSTR pcwszType = NULL;
    SIZE_T cchType = 0;

    fIsPolicyAssembly = FALSE;

    PARAMETER_CHECK(pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pAssemblyIdentity,
            &s_IdentityAttribute_type,
            &pcwszType,
            &cchType));

    IFW32FALSE_EXIT(::SxspDoesStringIndicatePolicy(cchType, pcwszType, fIsPolicyAssembly));

    FN_EPILOG;
}


BOOL
SxspGenerateTextualIdentity(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY pAsmIdent,
    CBaseStringBuffer &rsbTextualString
    )
{
    FN_PROLOG_WIN32

    SIZE_T cbRequiredBytes = 0;
    SIZE_T cbWrittenBytes = 0;
    CStringBufferAccessor sba;

    PARAMETER_CHECK(pAsmIdent != NULL);
    PARAMETER_CHECK(dwFlags == 0);

    rsbTextualString.Clear();

    IFW32FALSE_EXIT(
        ::SxsComputeAssemblyIdentityEncodedSize(
            0,
            pAsmIdent,
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            &cbRequiredBytes));

    INTERNAL_ERROR_CHECK((cbRequiredBytes % sizeof(WCHAR)) == 0);

    sba.Attach(&rsbTextualString);

    if (sba.GetBufferCb() < (cbRequiredBytes + sizeof(WCHAR)))
    {
        sba.Detach();
        IFW32FALSE_EXIT(
            rsbTextualString.Win32ResizeBuffer(
                (cbRequiredBytes / sizeof(WCHAR)) + 1, 
                eDoNotPreserveBufferContents));
        sba.Attach(&rsbTextualString);
    }

    IFW32FALSE_EXIT(
        ::SxsEncodeAssemblyIdentity(
            0,
            pAsmIdent, 
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            sba.GetBufferCb(),
            sba.GetBufferPtr(),
            &cbWrittenBytes));

    //
    // If the computation didn't match the written bytes, then that's a problem.
    // If we wrote too much and didn't include space for a NULL term, that's
    // a problem with this code.
    //
    ASSERT(cbWrittenBytes == cbRequiredBytes);
    INTERNAL_ERROR_CHECK(cbWrittenBytes <= (sba.GetBufferCb() + sizeof(WCHAR)));

    (sba.GetBufferPtr())[cbWrittenBytes / sizeof(WCHAR)] = CBaseStringBuffer::NullCharacter();
    
    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\id\sources.inc ===
!IF 0
Copyright (c) 2000-2001  Microsoft Corporation
!ENDIF

MAJORCOMP=fusion
MINORCOMP=id

TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)id
TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)

INCLUDES=\
    ..;\
    $(FUSION_INC_PATH);\
    $(FUSION_PATH)\external\inc;\
    $(FUSION_PATH)\idl\$(O); \
    $(INCLUDES);\
    $(COM_INC_PATH)

SOURCES= \
    id.cpp \
    encdec.cpp \
    policy.cpp \
    sxsid.cpp

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\id\sxsid.cpp ===
#include "stdinc.h"
#include <setupapi.h>
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>

#include "idp.h"
#include "sxsapi.h"
#include "sxsapi.h"
#include "sxsid.h"

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const WCHAR *Value,
    SIZE_T ValueCch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    DWORD FlagsToRealInsert = 0;
	
    PARAMETER_CHECK((Flags & ~(SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
	//
	// the validation of attribute content, such as value, name and namespace, is done within SxsInsertAssemblyIdentityAttribute
	// it is good to keep validation in one place.
	//
    PARAMETER_CHECK(AttributeReference != NULL);
    PARAMETER_CHECK(Value != NULL || ValueCch == 0);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;
    Attribute.Value = Value;
    Attribute.ValueCch = ValueCch;

    if (Flags & SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING)
        FlagsToRealInsert |= SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING;

    IFW32FALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(FlagsToRealInsert, AssemblyIdentity, &Attribute));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const CBaseStringBuffer &Value
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            Flags,
            AssemblyIdentity,
            AttributeReference,
            static_cast<PCWSTR>(Value),
            Value.Cch()));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// Action :
// 1. if (namespace, name) is provided, remove all attributes with such (namespace, name)
// 2. if (namespace, name, value), remove at most 1 attribute from assembly-identity
///////////////////////////////////////////////////////////////////////////////
BOOL
SxspRemoveAssemblyIdentityAttribute(
    DWORD Flags,
    PASSEMBLY_IDENTITY pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    ULONG Ordinal;
    ULONG Count;
    DWORD dwFindAttributeFlags = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)) == 0);
    PARAMETER_CHECK(pAssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;

    dwFindAttributeFlags = SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;

    // If it's OK for the attribute not to exist, set the flag in the call to find it.
    if (Flags & SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS)
        dwFindAttributeFlags |= SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS;

    IFW32FALSE_EXIT(
        ::SxsFindAssemblyIdentityAttribute(
            dwFindAttributeFlags,
            pAssemblyIdentity,
            &Attribute,
            &Ordinal,
            &Count));

    INTERNAL_ERROR_CHECK(Count <= 1);

    if (Count > 0)
    {
        IFW32FALSE_EXIT(
            ::SxsRemoveAssemblyIdentityAttributesByOrdinal(
                0,                  //  DWORD Flags,
                pAssemblyIdentity,
                Ordinal,
                Count));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
/////////////////////////////////////////////////////////////////////////////
// if no such attribure with such (namespace and name), return FALSE with
// ::SetLastError(ERROR_NOT_FOUND);
///////////////////////////////////////////////////////////////////////////////
BOOL
SxspGetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *StringOut,
    OUT SIZE_T *CchOut OPTIONAL
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE InternalAttribute = NULL;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    DWORD dwLocateFlags = SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE | SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME;

    if (StringOut != NULL)
        *StringOut = NULL;

    if (CchOut != NULL)
        *CchOut = 0;

    PARAMETER_CHECK((Flags & ~(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL)) == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);
    PARAMETER_CHECK(AttributeReference != NULL);

    Attribute.Flags = 0;
    Attribute.Namespace = AttributeReference->Namespace;
    Attribute.NamespaceCch = AttributeReference->NamespaceCch;
    Attribute.Name = AttributeReference->Name;
    Attribute.NameCch = AttributeReference->NameCch;

    InternalAttribute =
        ::SxspLocateInternalAssemblyIdentityAttribute(
            dwLocateFlags,
            AssemblyIdentity,
            &Attribute,
            NULL);

    if (InternalAttribute != NULL)
    {
        if (StringOut != NULL)
            *StringOut = InternalAttribute->Attribute.Value;

        if (CchOut != NULL)
            *CchOut = InternalAttribute->Attribute.ValueCch;
    }
    else
    {
        if ((Flags & SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL) == 0)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(AttributeNotFound, ERROR_NOT_FOUND);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT CBaseStringBuffer &Value
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR String = NULL;
    SIZE_T Cch = 0;

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            Flags,
            AssemblyIdentity,
            AttributeReference,
            &String,
            &Cch));

    IFW32FALSE_EXIT(Value.Win32Assign(String, Cch));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspUpdateAssemblyIdentityHash(
    DWORD dwFlags,
    PASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (AssemblyIdentity->HashDirty)
    {
        IFW32FALSE_EXIT(::SxspHashInternalAssemblyIdentityAttributes(
                            0,
                            AssemblyIdentity->AttributeCount,
                            AssemblyIdentity->AttributePointerArray,
                            &AssemblyIdentity->Hash));

        AssemblyIdentity->HashDirty = FALSE;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspEnsureAssemblyIdentityHashIsUpToDate(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    if (AssemblyIdentity->HashDirty)
        IFW32FALSE_EXIT(::SxspUpdateAssemblyIdentityHash(0, const_cast<PASSEMBLY_IDENTITY>(AssemblyIdentity)));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxsHashAssemblyIdentity(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    ULONG * pulPseudoKey
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG ulPseudoKey;

    if (pulPseudoKey)
        *pulPseudoKey = 0;

    PARAMETER_CHECK(dwFlags == 0);

    if (pAssemblyIdentity == NULL)
        ulPseudoKey = 0;
    else
    {
        IFW32FALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity));
        ulPseudoKey = pAssemblyIdentity->Hash;
    }

    if (pulPseudoKey != NULL)
        *pulPseudoKey = ulPseudoKey;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

// just to find whether Equal or Not
BOOL
SxsAreAssemblyIdentitiesEqual(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity1,
    PCASSEMBLY_IDENTITY pAssemblyIdentity2,
    BOOL *EqualOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL Equal = FALSE;

    if (EqualOut != NULL)
        *EqualOut = FALSE;

    PARAMETER_CHECK((dwFlags & ~(SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF)) == 0);
    PARAMETER_CHECK(pAssemblyIdentity1 != NULL);
    PARAMETER_CHECK(pAssemblyIdentity2 != NULL);
    PARAMETER_CHECK(EqualOut != NULL);

    // get hash for each assembly identity
    IFW32FALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity1));
    IFW32FALSE_EXIT(::SxspEnsureAssemblyIdentityHashIsUpToDate(0, pAssemblyIdentity2));

    // compare hash value of two identity; it's a quick way to determine they're not equal.
    if (pAssemblyIdentity2->Hash == pAssemblyIdentity1->Hash)
    {
        // Note that two identities which differ only in their internal flags are still semantically
        // equal.
        if ((pAssemblyIdentity1->Flags ==  pAssemblyIdentity2->Flags) &&
            (pAssemblyIdentity1->Hash ==  pAssemblyIdentity2->Hash) &&
            (pAssemblyIdentity1->NamespaceCount ==  pAssemblyIdentity2->NamespaceCount) &&
            (pAssemblyIdentity1->AttributeCount ==  pAssemblyIdentity2->AttributeCount))
        {
            if (dwFlags & SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF)
            {
                if (((pAssemblyIdentity1->Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
                     (pAssemblyIdentity1->Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE)) &&
                    ((pAssemblyIdentity2->Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) ||
                     (pAssemblyIdentity2->Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE)))
                {
                    // They match sufficiently...
                    Equal = TRUE;
                }
            }
            else
                Equal = (pAssemblyIdentity1->Type == pAssemblyIdentity2->Type);

            if (Equal)
            {
                ULONG ComparisonResult = SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_INVALID;

                // Reset our assumption...
                Equal = FALSE;

                IFW32FALSE_EXIT(
                    ::SxspCompareAssemblyIdentityAttributeLists(
                        0,
                        pAssemblyIdentity1->AttributeCount,
                        pAssemblyIdentity1->AttributePointerArray,
                        pAssemblyIdentity2->AttributePointerArray,
                        &ComparisonResult));

                INTERNAL_ERROR_CHECK(
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN) ||
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL) ||
                    (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN));

                if (ComparisonResult == SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL)
                    Equal = TRUE;
            }
        }
    }

    *EqualOut = Equal;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\arrayhelp.h ===
#if !defined(FUSION_ARRAYHELP_H_INCLUDED_)
#define FUSION_ARRAYHELP_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <oleauto.h>
#include "fusionheap.h"
#include "fusiontrace.h"

//
//  arrayhelp.h
//
//  Helper function(s) to deal with growable arrays.
//
//  Users of this utility should provide explicit template
//  specializations for classes for which you can safely (without
//  possibility of failure) transfer the contens from a source
//  instance to a destination instance, leaving the source "empty".
//
//  If moving the data may fail, you must provide a specialization
//  of FusionCopyContents() which returns an appropriate HRESULT
//  on failure.
//
//
//  C++ note:
//
//  the C++ syntax for explicit function template specialization
//  is:
//
//  template <> BOOLEAN FusionCanMoveContents<CFoo>(CFoo *p) { UNUSED(p); return TRUE; }
//

#if !defined(FUSION_UNUSED)
#define FUSION_UNUSED(x) (x)
#endif

//
//  The default implementation just does assignment which may not fail;
//  you can (and must if assignment may fail) specialize as you like to
//  do something that avoids data copies; you may assume that the source
//  element will be destroyed momentarily.
//

//
//  The FusionCanMemcpyContents() template function is used to determine
//  if a class is trivial enough that a raw byte transfer of the old
//  contents to the new contents is sufficient.  The default is that the
//  assignment operator is used as that is the only safe alternative.
//

template <typename T>
inline bool
FusionCanMemcpyContents(
    T *ptDummyRequired = NULL
    )
{
    FUSION_UNUSED(ptDummyRequired);
    return false;
}

//
//  The FusionCanMoveContents() template function is used by the array
//  copy template function to optimize for the case that it should use
//  FusionMoveContens<T>().
//
//  When overriding this function, the general rule is that if the data
//  movement may allocate memory etc. that will fail, we need to use the
//  FusionCopyContens() member function instead.
//
//  It takes a single parameter which is not used because a C++ template
//  function must take at least one parameter using the template type so
//  that the decorated name is unique.
//

template <typename T>
inline BOOLEAN
FusionCanMoveContents(
    T *ptDummyRequired = NULL
    )
{
    FUSION_UNUSED(ptDummyRequired);
    return FALSE;
}

template <> inline BOOLEAN
FusionCanMoveContents<LPWSTR>(LPWSTR  *ptDummyRequired)
{
    FUSION_UNUSED(ptDummyRequired);
    return TRUE;
}

//
//  FusionCopyContents is a default implementation of the assignment
//  operation from rtSource to rtDestination, except that it may return a
//  failure status.  Trivial classes which do define an assignment
//  operator may just use the default definition, but any copy implementations
//  which do anything non-trivial need to provide an explicit specialization
//  of FusionCopyContents<T> for their class.
//

template <typename T>
inline BOOL
FusionWin32CopyContents(
    T &rtDestination,
    const T &rtSource
    )
{
    rtDestination = rtSource;
    return TRUE;
}

//
//  FusionAllocateArray() is a helper function that performs array allocation.
//
//  It's a separate function so that users of these helpers may provide an
//  explicit specialization of the allocation/default construction mechanism
//  for an array without replacing all of FusionExpandArray().
//

template <typename T>
inline BOOL
FusionWin32AllocateArray(
    SIZE_T nElements,
    T *&rprgtElements
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    rprgtElements = NULL;

    T *prgtElements = NULL;

    if (nElements != 0)
        IFALLOCFAILED_EXIT(prgtElements = new T[nElements]);

    rprgtElements = prgtElements;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

//
//  FusionFreeArray() is a helper function that performs array deallocation.
//
//  It's a separate function so that users of the array helper functions may
//  provide an explicit specialization of the deallocation mechanism for an
//  array of some particular type without replacing the whole of FusionExpandArray().
//
//  We include nElements in the parameters so that overridden implementations
//  may do something over the contents of the array before the deallocation.
//  The default implementation just uses operator delete[], so nElements is
//  unused.
//

template <typename T>
inline VOID
FusionFreeArray(
    SIZE_T nElements,
    T *prgtElements
    )
{
    FUSION_UNUSED(nElements);

    ASSERT_NTC((nElements == 0) || (prgtElements != NULL));

    if (nElements != 0)
        FUSION_DELETE_ARRAY(prgtElements);
}

template <> inline VOID FusionFreeArray<LPWSTR>(SIZE_T nElements, LPWSTR *prgtElements)
{
    FUSION_UNUSED(nElements);

    ASSERT_NTC((nElements == 0) || (prgtElements != NULL));

    for (SIZE_T i = 0; i < nElements; i++)
        prgtElements[i] = NULL ;

    if (nElements != 0)
        FUSION_DELETE_ARRAY(prgtElements);
}

template <typename T>
inline BOOL
FusionWin32ResizeArray(
    T *&rprgtArrayInOut,
    SIZE_T nOldSize,
    SIZE_T nNewSize
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    T *prgtTempNewArray = NULL;

    //
    //  nMaxCopy is the number of elements currently in the array which
    //  need to have their values preserved.  If we're actually shrinking
    //  the array, it's the new size; if we're expanding the array, it's
    //  the old size.
    //
    const SIZE_T nMaxCopy = (nOldSize > nNewSize) ? nNewSize : nOldSize;

    PARAMETER_CHECK((rprgtArrayInOut != NULL) || (nOldSize == 0));

    // If the resize is to the same size, complain in debug builds because
    // the caller should have been smarter than to call us, but don't do
    // any actual work.
    ASSERT(nOldSize != nNewSize);
    if (nOldSize != nNewSize)
    {
        // Allocate the new array:
        IFW32FALSE_EXIT(::FusionWin32AllocateArray(nNewSize, prgtTempNewArray));

        if (::FusionCanMemcpyContents(rprgtArrayInOut))
        {
            memcpy(prgtTempNewArray, rprgtArrayInOut, sizeof(T) * nMaxCopy);
        }
        else if (!::FusionCanMoveContents(rprgtArrayInOut))
        {
            // Copy the body of the array:
            for (SIZE_T i=0; i<nMaxCopy; i++)
                IFW32FALSE_EXIT(::FusionWin32CopyContents(prgtTempNewArray[i], rprgtArrayInOut[i]));
        }
        else
        {
            // Move each of the elements:
            for (SIZE_T i=0; i<nMaxCopy; i++)
            {
                ::FusionWin32CopyContents(prgtTempNewArray[i], rprgtArrayInOut[i]);
            }
        }

        // We're done.  Blow away the old array and put the new one in its place.
        ::FusionFreeArray(nOldSize, rprgtArrayInOut);
        rprgtArrayInOut = prgtTempNewArray;
        prgtTempNewArray = NULL;
    }

    fSuccess = TRUE;

Exit:
    if (prgtTempNewArray != NULL)
        ::FusionFreeArray(nNewSize, prgtTempNewArray);

    return fSuccess;
}

#define MAKE_CFUSIONARRAY_READY(Typename, CopyFunc) \
    template<> inline BOOL FusionWin32CopyContents<Typename>(Typename &rtDest, const Typename &rcSource) { \
        FN_PROLOG_WIN32 IFW32FALSE_EXIT(rtDest.CopyFunc(rcSource)); FN_EPILOG } \

#endif // !defined(FUSION_ARRAYHELP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\id\idp.h ===
#if !defined(_FUSION_ID_IDP_H_INCLUDED_)
#define _FUSION_ID_IDP_H_INCLUDED_

/*++

Copyright (c) Microsoft Corporation

Module Name:

    idp.h

Abstract:

    private definitions for assembly identity

Author:

    Michael Grier (MGrier) 7/27/2000

Revision History:

--*/

#pragma once

#include "debmacro.h"
#include "fusiontrace.h"
#include "fusionhashstring.h"
#include "fusionheap.h"
#include "util.h"

#include <sxstypes.h>
#include <sxsapi.h>

//
//  Power of two to which to round the number of allocated attribute
//  pointers.
//

#define ROUNDING_FACTOR_BITS (3)

#define WILDCARD_CHAR '*'

//
//  Note! Do not change this algorithm lightly.  Encoded identities stored in the
//  filesystem contain hashes using it.  Actually, just do not change it.
//

#define HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

typedef struct _ASSEMBLY_IDENTITY_NAMESPACE {
    ULONG Hash;
    DWORD Flags;
    SIZE_T NamespaceCch;
    const WCHAR *Namespace;
} ASSEMBLY_IDENTITY_NAMESPACE, *PASSEMBLY_IDENTITY_NAMESPACE;

typedef const ASSEMBLY_IDENTITY_NAMESPACE *PCASSEMBLY_IDENTITY_NAMESPACE;

//
//  Internal-use ASSEMBLY_IDENTITY_ATTRIBUTE struct that
//  also contains the hash of the attribute definition.
//

typedef struct _INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE {
    // NOTE!!! It is very important that the Attribute member appear first in this struct;
    // there are several places in the code that make this assumption.  If it is not true,
    // the code will break!
    // Note also that the Attribute's namespace string is actually allocated in common
    // for all attributes with the same namespace.
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PCASSEMBLY_IDENTITY_NAMESPACE Namespace;
    ULONG NamespaceAndNameHash;
    ULONG WholeAttributeHash;
    ULONG RefCount;
} INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, *PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE;

C_ASSERT(FIELD_OFFSET(INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE, Attribute) == 0);

typedef const INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE;

#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_ATTRIBUTE_POINTERS_IN_SEPARATE_ALLOCATION   (0x00000001)
#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_SINGLE_ALLOCATION_FOR_EVERYTHING            (0x00000002)
#define ASSEMBLY_IDENTITY_INTERNAL_FLAG_NAMESPACE_POINTERS_IN_SEPARATE_ALLOCATION   (0x00000004)

//
//  Revelation of the ASSEMBLY_IDENTITY struct:
//

typedef struct _ASSEMBLY_IDENTITY {
    DWORD Flags;
    ULONG InternalFlags;
    ULONG Type;
    ULONG Hash;
    ULONG AttributeCount;
    ULONG AttributeArraySize; // preallocated a little larger so that we don't have to keep growing
    ULONG NamespaceCount;
    ULONG NamespaceArraySize;
    BOOL  HashDirty;
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *AttributePointerArray;
    PCASSEMBLY_IDENTITY_NAMESPACE *NamespacePointerArray;
} ASSEMBLY_IDENTITY;

//
//  Header for encoded/serialized assembly identities:
//

#define ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC ((ULONG) 'dIAE')

//
//  Encoded assembly identity layout:
//
//      ENCODED_ASSEMBLY_IDENTITY_HEADER
//      <AttributeCount hashes of the attributes, sorted by the hash value>
//      <NamespaceCount ENCODED_ASSEMBLY_IDENTITY_NAMESPACE_HEADER headers, each
//          followed by the unicode namespace value>
//      <AttributeCount ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER headers, each
//          followed by the unicode attribute name and value>
//
//
//      e.g.
//
//      <begin ENCODED_ASSEMBLY_IDENTITY_HEADER>
//      00000000:   00000038            HeaderSize == sizeof(ENCODED_ASSEMBLY_IDENTITY_HEADER)
//      00000004:   'EAId'              Magic (ENCODED_ASSEMBLY_IDENTITY_HEADER_MAGIC)
//      00000008:   0000014C            TotalSize
//      0000000C:   00000000            Flags
//      00000010:   00000001            Type (1 = ASSEMBLY_IDENTITY_TYPE_DEFINITION)
//      00000014:   00000000            EncodingFlags
//      00000018:   00000001            HashAlgorithm (1 = HASH_STRING_ALGORITHM_X65599)
//      0000001C:   ????????            Logical hash value of entire identity based on hash algorithm
//                                      (algorithm described in more detail below...)
//      00000020:   00000003            AttributeCount
//      00000024:   00000002            NamespaceCount
//      00000028:   00000000            ReservedMustBeZero1
//      0000002C:   00000000            ReservedMustBeZero2
//      00000030:   00000000 00000000   ReservedMustBeZero3
//      00000038:   00000000 00000000   ReservedMustBeZero4
//      <end ENCODED_ASSEMBLY_IDENTITY_HEADER>
//      <begin sorted attribute hash list>
//      00000040:   xxxxxxxx            hash of attribute #1
//      00000044:   yyyyyyyy            hash of attribute #0 - note that yyyyyyyy >= xxxxxxxx
//      00000048:   zzzzzzzz            hash of attribute #2 - note that zzzzzzzz >= yyyyyyyy
//      <end sorted attribute hash list>
//      <begin namespace length list>
//      0000004C:   00000015            length (in Unicode chars) of namespace #1 - "http://www.amazon.com" - 21 chars = 0x00000015
//      00000050:   00000018            length (in Unicode chars) of namespace #2 - "http://www.microsoft.com" - 24 chars = 0x00000018
//      <end namespace length list>
//      <begin attribute headers>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      00000054:   00000001            NamespaceIndex: 1 (http://www.amazon.com)
//      00000058:   00000004            Name length ("name" - 4 chars = 0x00000004)
//      0000005C:   00000006            Value length ("foobar" - 6 chars = 0x00000006)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      00000060:   00000002            NamespaceIndex: 2 (http://www.microsoft.com)
//      00000064:   00000004            Name length ("guid" - 4 chars = 0x00000004)
//      00000068:   00000026            Value length ("{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" - 38 chars = 0x00000026)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <begin ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      0000006C:   00000002            NamespaceIndex: 2 (http://www.microsoft.com)
//      00000070:   00000004            Name length ("type" - 4 chars = 0x00000004)
//      00000074:   00000005            Value length ("win32" - 5 chars = 0x00000005)
//      <end ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER>
//      <end attribute headers>
//      <begin namespace strings>
//      00000078:   "http://www.amazon.com"
//      000000A2:   "http://www.microsoft.com"
//      <end namespace strings>
//      <begin attribute values - names and values for each attribute in series>
//      000000D2:   "name"
//      000000DA:   "foobar"
//      000000E6:   "guid"
//      000000EE:   "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
//      0000013A:   "type"
//      00000142:   "win32"
//      <end attribute values>
//      0000014C:
//
//  Computing the whole identity hash:
//
//      The hash of the entire encoded identity is not the hash of the binary form, but
//      rather is a combination of the hashes for the various components.
//
//      For any Unicode character string, its hash is computed according to HashAlgorithm.
//      Currently this must be HASH_STRING_ALGORITHM_X65599 which is a multiply-and-
//      accumulate algorithm, implemented essentially as follows:
//
//          HashValue = 0;
//          for (i=0; i<Chars; i++)
//              HashValue = (HashValue * 65599) + OptionalToUpper(String[i]);
//
//      Note that the characters are converted to upper case.  This is somewhat in
//      conflict with the Unicode recommendation to convert to lower case for case
//      insensitive operations, but it is what the rest of the Windows NT system
//      does, so consistency matters more than doing the "right thing".
//
//      Note also that no trailing null characters are included in the hash.  This
//      is significant because of the fact that applying the loop to another character
//      even though its value is zero will significantly change the hash value.
//
//      Namespaces and attribute names are case sensitive, derived from the fact
//      that they appear in case sensitive contexts in the real world.  This is
//      unfortunate, but simpler in many ways.
//
//      Assembly identity attributes are composed of a triple of:
//          - Namespace URI (e.g. http://www.microsoft.com/schemas/side-by-side)
//          - Name (e.g. "publicKey")
//          - Value (case insensitive Unicode string)
//
//      The hash of an attribute is computed by computing the hash of the three
//      strings, and then combining them as:
//
//          AttributeHashValue = (((NamespaceHash * 65599) + NameHash) * 65599) + ValueHash
//
//      Now, sort the attributes based first on namespace, then on name then on
//      value (case sensitive, case sensitive and case insensitive respectively),
//      and combine their hashes as follows:
//
//          IdentityHash = 0;
//          for (i=0; i<AttributeCount; i++)
//              IdentityHash = (IdentityHash * 65599) + AttributeHashes[i];
//
//      IdentityHash is the value stored in the encoded header.
//
//      The attribute hash array stored in the encoded data is the attribute
//      hashes as described above.  The interesting thing is that they are stored
//      in order of ascending hash value, not in the canonical ordering for
//      attributes.
//
//      This is because a common scenario is to find an identity which has a
//      superset of a given identity.  While the actual attributes have to
//      be consulted to verify that the candidate is a true subset, non-
//      matches can be very quickly found by sorting both lists of hash
//      values and first looping over the smaller reference list, then
//      in a single pass walking the larger definition list.  Attributes present
//      in one but not in the other will be immediately noticable due to
//      the missing hashes.
//
//      As always with hashes, just because an encoded identity contains a
//      superset of the hash values in your candidate assembly reference,
//      it does not mean that the actual values appear and you must perform
//      real character string comparisons to verify containment.
//

#include <pshpack4.h>

typedef struct _ENCODED_ASSEMBLY_IDENTITY_HEADER {
    ULONG HeaderSize;           // bytes just in the header
    ULONG Magic;
    ULONG TotalSize;            // bytes for the whole encoded thing
    DWORD Flags;                // as defined for assembly identity flags
    ULONG Type;                 // type of identity - def, ref or wildcard
    ULONG EncodingFlags;        // flags describing the encoding itself
    ULONG HashAlgorithm;        // Algorithm ID for the hashes stored in the identity
    ULONG Hash;                 // Hash value of the entire identity
    ULONG AttributeCount;       // number of attributes
    ULONG NamespaceCount;       // number of distinct namespaces
    ULONG ReservedMustBeZero1;
    ULONG ReservedMustBeZero2;
    ULONGLONG ReservedMustBeZero3;
    ULONGLONG ReservedMustBeZero4;
} ENCODED_ASSEMBLY_IDENTITY_HEADER, *PENCODED_ASSEMBLY_IDENTITY_HEADER;

typedef const ENCODED_ASSEMBLY_IDENTITY_HEADER *PCENCODED_ASSEMBLY_IDENTITY_HEADER;

typedef struct _ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER {
    ULONG NamespaceIndex;       // number of the namespace for this attribute
    ULONG NameCch;              // size in Unicode characters of the name immediately following the
                                // namespace
    ULONG ValueCch;             // size in Unicode characters of the value immediately following the
                                // name.
} ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER, *PENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER;

typedef const ENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER *PCENCODED_ASSEMBLY_IDENTITY_ATTRIBUTE_HEADER;

#include <poppack.h>

#define SXSP_VALIDATE_ASSEMBLY_IDENTITY_FLAGS_MAY_BE_NULL (0x00000001)

BOOL
SxspValidateAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity
    );

BOOL
SxspValidateAssemblyIdentityAttributeNamespace(
    IN DWORD Flags,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch
    );

BOOL
SxspValidateAssemblyIdentityAttributeName(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch
    );

#define SXSP_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_WILDCARDS_PERMITTED (0x00000001)

BOOL
SxspValidateAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch
    );

BOOL
SxspComputeInternalAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT SIZE_T *BytesRequiredOut
    );

BOOL
SxspComputeAssemblyIdentityAttributeBytesRequired(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Source,
    OUT SIZE_T *BytesRequiredOut
    );

#define SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_IN_ARRAY_FLAG_ADD_IF_NOT_FOUND (0x00000001)

BOOL
SxspFindAssemblyIdentityNamespaceInArray(
    IN DWORD Flags,
    IN OUT PCASSEMBLY_IDENTITY_NAMESPACE **NamespacePointerArrayPtr,
    IN OUT ULONG *NamespaceArraySizePtr,
    IN OUT ULONG *NamespaceCountPtr,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

#define SXSP_FIND_ASSEMBLY_IDENTITY_NAMESPACE_FLAG_ADD_IF_NOT_FOUND (0x00000001)

BOOL
SxspFindAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN struct _ASSEMBLY_IDENTITY* AssemblyIdentity,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

BOOL
SxspAllocateAssemblyIdentityNamespace(
    IN DWORD Flags,
    IN const WCHAR *NamespaceString,
    IN SIZE_T NamespaceCch,
    IN ULONG NamespaceHash,
    OUT PCASSEMBLY_IDENTITY_NAMESPACE *NamespaceOut
    );

VOID
SxspDeallocateAssemblyIdentityNamespace(
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    );

void
SxspPopulateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Destination
    );

BOOL
SxspAllocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    IN const WCHAR *Value,
    IN SIZE_T ValueCch,
    OUT PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Destination
    );

VOID
SxspCleanUpAssemblyIdentityNamespaceIfNotReferenced(
    IN DWORD Flags,
    IN struct _ASSEMBLY_IDENTITY* AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_NAMESPACE Namespace
    );

VOID
SxspDeallocateInternalAssemblyIdentityAttribute(
    PINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

int
__cdecl
SxspCompareInternalAttributesForQsort(
    const void *elem1,
    const void *elem2
    );

int
__cdecl
SxspCompareULONGsForQsort(
    const void *elem1,
    const void *elem2
    );

BOOL
SxspCompareAssemblyIdentityAttributeLists(
    DWORD Flags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List1,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *List2,
    ULONG *ComparisonResultOut
    );

BOOL
SxspHashInternalAssemblyIdentityAttributes(
    DWORD Flags,
    ULONG Count,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE *Attributes,
    ULONG *HashOut
    );

BOOL
SxspCopyInternalAssemblyIdentityAttributeOut(
    DWORD Flags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    SIZE_T BufferSize,
    PASSEMBLY_IDENTITY_ATTRIBUTE DestinationBuffer,
    SIZE_T *BytesCopiedOrRequired
    );

BOOL
SxspIsInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN const WCHAR *Namespace,
    IN SIZE_T NamespaceCch,
    IN const WCHAR *Name,
    IN SIZE_T NameCch,
    OUT BOOL *EqualsOut
    );

#define SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_VALUE_ONLY (0x00000001)
#define SXSP_COMPUTE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_ENCODED_TEXTUAL_SIZE_FLAG_OMIT_QUOTES (0x00000002)

BOOL
SxspComputeInternalAssemblyIdentityAttributeEncodedTextualSize(
    IN DWORD Flags,
    IN PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT SIZE_T *BytesOut
    );

#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE   (0x00000001)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME        (0x00000002)
#define SXSP_LOCATE_INTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE       (0x00000004)

PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE
SxspLocateInternalAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT ULONG *LastIndexSearched OPTIONAL
    );

SIZE_T
__fastcall
SxspComputeQuotedStringSize(
    IN const WCHAR *StringIn,
    IN SIZE_T Cch
    );

VOID
SxspDbgPrintInternalAssemblyIdentityAttribute(
    DWORD dwflags,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

VOID
SxspDbgPrintInternalAssemblyIdentityAttributes(
    DWORD dwflags,
    ULONG AttributeCount,
    PCINTERNAL_ASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    );

VOID
SxspDbgPrintAssemblyIdentityAttribute(
    DWORD dwflags,
    PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

VOID
SxspDbgPrintAssemblyIdentityAttributes(
    DWORD dwflags,
    ULONG AttributeCount,
    PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes
    );

BOOL
SxspEnsureAssemblyIdentityHashIsUpToDate(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\cfusionpointeriterator.h ===
/*-----------------------------------------------------------------------------
Microsoft Confidential
Copyright (c) Microsoft Corporation. All Rights Reserved.

Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.

Copyright (c) 1994
Hewlett-Packard Company

Permission to use, copy, modify, distribute and sell this
software and its documentation for any purpose is hereby
granted without fee, provided that the above copyright notice
appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation.
Hewlett-Packard Company makes no representations about the
suitability of this software for any purpose. It is provided
"as is" without express or implied warranty.

@doc external

@module CFusionPointerIterator

@owner a-JayK, JayKrell
-----------------------------------------------------------------------------*/
#if !defined(FUSION_INC_CPOINTER_ITERATOR_H_INCLUDED_) // {
#define FUSION_INC_CPOINTER_ITERATOR_H_INCLUDED_
#pragma once

/*
Name: CFusionPointerIterator

@class
This is copied from std::_Ptrit, and cleaned up.

@hung i or it for iterator
@owner a-JayK, JayKrell
*/
template
<
	typename T,       // @tcarg the type pointed to
	typename Distance, // @tcarg usually ptrdiff_t, which is usually long or __int64
	typename Pointer, // @tcarg const or mutable
	typename Reference, // @tcarg const or mutable
	typename MutablePointer, // @tcarg never const
	typename MutableReference // @tcarg never const
>
class CFusionPointerIterator
//FUTURE : public std::iterator<std::random_access_iterator_tag, T, Distance, Pointer, Reference>
{
public:
	// @cmember
	CFusionPointerIterator(Pointer p = Pointer()) throw();
	// @cmember
	CFusionPointerIterator
	(
		const CFusionPointerIterator
		<
			T,
			Distance,
			MutablePointer,
			MutableReference,
			MutablePointer,
			MutableReference
		>&
	) throw();

	// @cmember
	Pointer PtBase() const throw();
	// @cmember
	Reference operator*() const throw();
	// @cmember
	Pointer operator->() const throw();
	// @cmember
	CFusionPointerIterator& operator++() throw();
	// @cmember
	CFusionPointerIterator operator++(int) throw();
	// @cmember
	CFusionPointerIterator& operator--() throw();
	// @cmember
	CFusionPointerIterator operator--(int) throw();

	// Why is this in xutility
	//bool operator==(int y) const throw();

	// @cmember
	bool operator==(const CFusionPointerIterator& y) const throw();
	// @cmember
	bool operator!=(const CFusionPointerIterator& y) const throw();
	// @cmember
	CFusionPointerIterator& operator+=(Distance n) throw();
	// @cmember
	CFusionPointerIterator operator+(Distance n) const throw();
	// @cmember
	CFusionPointerIterator& operator-=(Distance n) throw();
	// @cmember
	CFusionPointerIterator operator-(Distance n) const throw();
	// @cmember
	Reference operator[](Distance n) const throw();
	// @cmember
	// @cmember
	bool operator<(const CFusionPointerIterator& y) const throw();
	// @cmember
	bool operator>(const CFusionPointerIterator& y) const throw();
	// @cmember
	bool operator<=(const CFusionPointerIterator& y) const throw();
	// @cmember
	bool operator>=(const CFusionPointerIterator& y) const throw();
	// @cmember
	Distance operator-(const CFusionPointerIterator& y) const throw();

protected:
	// @cmember
	Pointer m_current;
};

// @func
template
<
	typename T, // @tfarg
	typename Distance, // @tfarg
	typename Pointer, // @tfarg
	typename Reference, // @tfarg
	typename MutablePointer, // @tfarg
	typename MutableReference // @tfarg
>
inline CFusionPointerIterator<T, Distance, Pointer, Reference, MutablePointer, MutableReference>
operator+
(
	Distance n,
	const CFusionPointerIterator
	<
		T,
		Distance,
		Pointer,
		Reference,
		MutablePointer,
		MutableReference
	>&
) throw();

#include "CFusionPointerIterator.inl"

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\csxspreservelasterror.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    CSxsPreserveLastError.h

Abstract:

Author:

    Jay Krell (a-JayK, JayKrell) October 2000

Revision History:

--*/
#pragma once

#include "fusionlastwin32error.h"

//
// The idea here is to avoid hitting breakpoints on ::SetLastError
// or data breakpoints on NtCurrentTeb()->LastErrorValue.
//
class CSxsPreserveLastError
{
public:
    DWORD LastError() const { return m_dwLastError; }

    inline CSxsPreserveLastError() { ::FusionpGetLastWin32Error(&m_dwLastError); }
    inline void Restore() const { ::FusionpSetLastWin32Error(m_dwLastError); }

protected:
    DWORD m_dwLastError;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\cfusionarraytypedefs.h ===
/*-----------------------------------------------------------------------------
Microsoft Confidential
Copyright (c) Microsoft Corporation. All Rights Reserved.

@doc external

@module CFusionArrayTypedefs.h

@owner JayK
-----------------------------------------------------------------------------*/
#if !defined(FUSION_INC_CFUSIONARRAYTYPEDEFS_H_INCLUDED_) // {
#define FUSION_INC_CFUSIONARRAYTYPEDEFS_H_INCLUDED_
#pragma once

#include <stddef.h>
#include "CFusionPointerIterator.h"

/*-----------------------------------------------------------------------------
Name: CFusionArrayTypedefs

@class

@owner JayK
-----------------------------------------------------------------------------*/
template
<
	typename type
>
class CFusionArrayTypedefs
{
public:
	// @cmember This is the type the array holds.
	//It is like std::vector<T>::value_type.
	typedef type				ValueType;

	// @cmember the type returned by GetSize
    // (size_type in the STL, and more usually size_t)
	typedef SIZE_T              SizeType;

    // @cmember the type you get subtracting iterators
    // (difference_type in the STL, and more usually ptrdiff_t)
	typedef SSIZE_T             DifferenceType;

	// @cmember
	typedef ValueType*			Pointer;
	// @cmember
	typedef const ValueType*	ConstPointer;

	// @cmember
	typedef ValueType&			Reference;
	// @cmember
	typedef const ValueType&	ConstReference;

	// @cmember
	typedef CFusionPointerIterator
	<
		ValueType,
		SSIZE_T,
		Pointer,
		Reference,
		Pointer,
		Reference
	> Iterator;

	// @cmember
	typedef CFusionPointerIterator
	<
		ValueType,
		SSIZE_T,
		ConstPointer,
		ConstReference,
		Pointer,
		Reference
	> ConstIterator;

private:
	// The compiler generates bad code when you have empty base classes.
	int m_workaroundVC7Bug76863;
};

// }

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\dialogs.h ===
#ifndef __SXS_DIALOGS
#define __SXS_DIALOGS


#define IDC_STATIC                              -1
#define IDC_PROGRESS                            101
#define IDC_NET_NAME                            102
#define IDC_MEDIA_NAME                          103
#define IDC_PROMPT_TEXT                         104

#define IDC_RETRY                               150
#define IDC_INFO                                151

#define IDI_CDROM                               201
#define IDI_NETWORK                             202

#define IDS_TITLE                               301
#define IDS_ERROR_TITLE                         302
#define IDS_PROTDLL_DISABLED                    303
#define IDS_FILE_CHANGE                         304
#define IDS_CANCEL_CONFIRM                      305
#define IDS_WRONG_CD                            306
#define IDS_MORE_INFORMATION_CD                 307
#define IDS_MORE_INFORMATION_NET                308
#define IDS_WRONG_NETCD                         309
#define IDS_RESTORE_TEXT                        310
#define IDS_CACHE_TEXT                          311
#define IDS_INSTALL_PROTECTED_TEXT              312
#define IDS_CANCEL_CONFIRM_INSTALL              313
#define IDS_CANCEL_CONFIRM_CACHE                314


#define IDS_UNKNOWN                             320

#define IDD_PROGRESS                            401
#define IDD_SFC_CD_PROMPT                       402
#define IDD_SFC_NETWORK_PROMPT                  403


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\enumbitoperations.h ===
#pragma once

/*-----------------------------------------------------------------------------
This macro generates various bit operations (and, or, etc.) for an enum type.
Copied from \\jayk1\g\vs\src\vsee\lib\TransactionalFileSystem
-----------------------------------------------------------------------------*/
#define ENUM_BIT_OPERATIONS(e) \
    inline e operator|(e x, e y) { return static_cast<e>(static_cast<INT>(x) | static_cast<INT>(y)); } \
    inline e operator&(e x, e y) { return static_cast<e>(static_cast<INT>(x) & static_cast<INT>(y)); } \
    inline void operator&=(e& x, INT y) { x = static_cast<e>(static_cast<INT>(x) & y); } \
    inline void operator&=(e& x, e y) { x &= static_cast<INT>(y); } \
    inline void operator|=(e& x, INT y) { x = static_cast<e>(static_cast<INT>(x) | y); } \
    inline void operator|=(e& x, e y) { x |= static_cast<INT>(y); } \
    /* maybe more in the future */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\debmacro.h ===
#if !defined(_FUSION_INC_DEBMACRO_H_INCLUDED_)
#define _FUSION_INC_DEBMACRO_H_INCLUDED_

#pragma once

//
// Copyright (c) Microsoft Corporation
//
// Fusion Debug Macros
//


//
// Sorry but we're way too in bed with C++ constructs etc.  You need to author
// C++ source code to interop with this header.

#if !defined(__cplusplus)
#error "You need to build Fusion sources as C++ files"
#endif // !defined(__cplusplus)

#ifndef SZ_COMPNAME
#define SZ_COMPNAME "FUSION: "
#endif

#ifndef WSZ_COMPNAME
#define WSZ_COMPNAME L"FUSION: "
#endif

#if !defined(NT_INCLUDED)
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#endif
#include "fusionlastwin32error.h"

#undef ASSERT

//
//  These definitions are always valid, regardless of whether this is a free
//  or checked build.
//

#if !defined(DPFLTR_ERROR_LEVEL)
#define DPFLTR_ERROR_LEVEL 0
#endif

#if !defined(DPFLTR_WARNING_LEVEL)
#define DPFLTR_WARNING_LEVEL 1
#endif

#if !defined(DPFLTR_TRACE_LEVEL)
#define DPFLTR_TRACE_LEVEL 2
#endif

#if !defined(DPFLTR_INFO_LEVEL)
#define DPFLTR_INFO_LEVEL 3
#endif

#if !defined(DPFLTR_MASK)
#define DPFLTR_MASK 0x80000000
#endif

//
//  Guidlines:
//
//  Use bits 0-15 for general types of issues, e.g. entry/exit tracing,
//  dumping heap usage, etc.
//
//  Use bits 16-30 for more fusion-specific kinds of topics like
//  binding diagnosis, etc.
//

#define FUSION_DBG_LEVEL_INFO           (0x00000002 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_VERBOSE        (0x00000004 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_ENTEREXIT      (0x00000008 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_ERROREXITPATH  (0x00000010 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_CONSTRUCTORS   (0x00000020 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_DESTRUCTORS    (0x00000040 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_REFCOUNTING    (0x00000080 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_HEAPALLOC      (0x00000100 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_HEAPDEALLOC    (0x00000200 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_HEAPDEBUG      (0x00000400 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_MSI_INSTALL	(0x00000800 | DPFLTR_MASK)

#define FUSION_DBG_LEVEL_POLICY         (0x00010000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_HASHTABLE      (0x00020000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_WFP            (0x00040000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_ACTCTX         (0x00080000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_XMLNAMESPACES  (0x00100000 | DPFLTR_MASK)
// The XML tree code is never used, so this is a dead flag.  Hence sharing
// of values between it and 'binding'
#define FUSION_DBG_LEVEL_SAFEMODE       (0x00100000 | DPFLTR_MASK)
// since we run out of bits, and FUSION_DBG_LEVEL_XMLNAMESPACES is a 
// dead flag, we just reuse it
#define FUSION_DBG_LEVEL_XMLTREE        (0x00200000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_BINDING        (0x00200000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_INSTALLATION   (0x00400000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_PROBING        (0x00800000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_XMLSTREAM      (0x01000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_SETUPLOG       (0x02000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_NODEFACTORY    (0x04000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_FULLACTCTX     (0x08000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_FILECHANGENOT  (0x10000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_LOG_ACTCTX     (0x20000000 | DPFLTR_MASK)
#define FUSION_DBG_LEVEL_FREEBUILDERROR (0x40000000 | DPFLTR_MASK)

#if DBG

//
//  In DBG builds, all error level events are always shown.
//

#define FUSION_DBG_LEVEL_ERROR DPFLTR_ERROR_LEVEL

#else // DBG

//
//  In FRE builds, use an explicit mask.
//

#define FUSION_DBG_LEVEL_ERROR FUSION_DBG_LEVEL_FREEBUILDERROR

#endif // DBG

// updated when the user-mode copy of the kernel debugging flags are updated
extern "C" bool g_FusionEnterExitTracingEnabled;

extern "C" DWORD kd_fusion_mask;

bool
FusionpDbgWouldPrintAtFilterLevel(
    ULONG FilterLevel
    );

DWORD
FusionpHRESULTToWin32(
    HRESULT hr
    );

typedef struct _FRAME_INFO
{
    PCSTR pszFile;
    PCSTR pszFunction;
    INT nLine;
} FRAME_INFO, *PFRAME_INFO;

typedef const struct _FRAME_INFO *PCFRAME_INFO;

typedef struct _CALL_SITE_INFO CALL_SITE_INFO, *PCALL_SITE_INFO;
typedef const struct _CALL_SITE_INFO *PCCALL_SITE_INFO;

void __fastcall FusionpTraceWin32LastErrorFailureExV(const CALL_SITE_INFO &rCallSiteInfo, PCSTR Format, va_list Args);
void __fastcall FusionpTraceWin32LastErrorFailureOriginationExV(const CALL_SITE_INFO &rCallSiteInfo, PCSTR Format, va_list Args);

typedef struct _CALL_SITE_INFO
{
    PCSTR pszFile;
    PCSTR pszFunction;
    PCSTR pszApiName;
    INT   nLine;

    void __cdecl TraceWin32LastErrorFailureEx(PCSTR Format, ...) const
        { va_list Args; va_start(Args, Format); FusionpTraceWin32LastErrorFailureExV(*this, Format, Args); va_end(Args); }

    void __cdecl TraceWin32LastErrorFailureOriginationEx(PCSTR Format, ...) const
        { va_list Args; va_start(Args, Format); FusionpTraceWin32LastErrorFailureOriginationExV(*this, Format, Args); va_end(Args); }

} CALL_SITE_INFO, *PCALL_SITE_INFO;

bool
FusionpPopulateFrameInfo(
    FRAME_INFO &rFrameInfo,
    PCSTR pszFile,
    PCSTR pszFunction,
    INT nLine
    );

bool
__fastcall
FusionpPopulateFrameInfo(
    FRAME_INFO &rFrameInfo,
    PCTEB_ACTIVE_FRAME ptaf
    );

bool
__fastcall
FusionpGetActiveFrameInfo(
    FRAME_INFO &rFrameInfo
    );

#if _X86_
#define FUSION_DEBUG_BREAK_IN_FREE_BUILD() __asm { int 3 }
#else // _X86_
#define FUSION_DEBUG_BREAK_IN_FREE_BUILD() DebugBreak()
#endif // _X86_

VOID FusionpReportCondition(bool fBreakin, PCSTR pszMessage, ...);

#if DBG

// Normal macro for breaking in checked builds; make people use the nasty name
// if they're going to do the nasty thing.
#define FUSION_DEBUG_BREAK() FUSION_DEBUG_BREAK_IN_FREE_BUILD()

//
//  Assertion failure reporting internal APIs.
//
//  They return true if they were not able to issue the breakpoint; false if they were.
//

bool FusionpAssertionFailed(PCSTR pszExpression, PCSTR pszMessage = NULL, ...);
bool FusionpAssertionFailed(const FRAME_INFO &rFrameInfo, PCSTR pszExpression, PCSTR pszMessage = NULL);
bool FusionpAssertionFailed(PCSTR pszFile, PCSTR pszFunction, INT nLine, PCSTR pszExpression, PCSTR pszMessage = NULL);

//
//  Soft assertion failures are really just debug messages, but they should result in
//  bugs being filed.
//

VOID FusionpSoftAssertFailed(PCSTR pszExpression, PCSTR pszMessage = NULL);
VOID FusionpSoftAssertFailed(const FRAME_INFO &rFrameInfo, PCSTR pszExpression, PCSTR pszMessage = NULL);
VOID FusionpSoftAssertFailed(PCSTR pszFile, PCSTR pszFunction, INT nLine, PCSTR pszExpression, PCSTR pszMessage = NULL);

#define HARD_ASSERT2_ACTION(_e, _m) \
do \
{ \
    if (::FusionpAssertionFailed(__FILE__, __FUNCTION__, __LINE__, #_e, (_m))) \
    { \
        FUSION_DEBUG_BREAK();\
    } \
} while (0)

#define HARD_ASSERT2(_e, _m) \
do \
{ \
    __t.SetLine(__LINE__); \
    if (!(_e)) \
        HARD_ASSERT2_ACTION(_e, (_m)); \
} while (0)

/*
    if (__exists(__t)) \
    { \
        CNoTraceContextUsedInFrameWithTraceObject x; \
    }

*/

#define HARD_ASSERT2_NTC(_e, _m) \
do \
{ \
    if (!(_e)) \
        HARD_ASSERT2_ACTION(_e, (_m)); \
} while (0)

// Pick up the locally-scoped trace context by default
#define HARD_ASSERT(_e) HARD_ASSERT2(_e, NULL)
#define HARD_ASSERT_NTC(_e) HARD_ASSERT2_NTC(_e, NULL)

/*-----------------------------------------------------------------------------
VERIFY is like ASSERT, but it evaluates it expression in retail/free builds
too, so you can say VERIFY(CloseHandle(h)) whereas ASSERT(CloseHandle(h))
would fail to close the handle in free builds

VERIFY2 adds a message as well, like VSASSERT or ASSERTMSG, in its second parameter
-----------------------------------------------------------------------------*/

#define HARD_VERIFY(_e) HARD_ASSERT(_e)
#define HARD_VERIFY_NTC(_e) HARD_ASSERT_NTC(_e)

#define HARD_VERIFY2(_e, _m) HARD_ASSERT2(_e, _m)
#define HARD_VERIFY2_NTC(_e, _m) HARD_ASSERT2_NTC(_e, _m)

#define SOFT_ASSERT2(_e, _m) \
    do \
    { \
        __t.SetLine(__LINE__); \
        if (!(_e)) \
            ::FusionpSoftAssertFailed(__FILE__, __FUNCTION__, __LINE__, #_e, (_m)); \
    } while (0)

#define SOFT_ASSERT(_e) SOFT_ASSERT2(_e, NULL)

#define SOFT_ASSERT2_NTC(_e, _m) \
    do \
    { \
        if (!(_e)) \
            ::FusionpSoftAssertFailed(__FILE__, __FUNCTION__, __LINE__, #_e, (_m)); \
    } while (0)

#define SOFT_ASSERT_NTC(_e) SOFT_ASSERT2_NTC(_e, NULL)

#define SOFT_VERIFY(_e) SOFT_ASSERT(_e)
#define SOFT_VERIFY_NTC(_e) SOFT_ASSERT_NTC(_e)

#define SOFT_VERIFY2(_e, _m) SOFT_ASSERT2(_e, _m)
#define SOFT_VERIFY2_NTC(_e, _m) SOFT_ASSERT2_NTC(_e, _m)

#else // DBG

#define FUSION_DEBUG_BREAK() do { } while (0)
#define HARD_ASSERT(_e) do { } while (0)
#define HARD_ASSERT_NTC(_e) do { } while (0)
#define HARD_ASSERT2_ACTION(_e, _m) do { } while (0)
#define HARD_ASSERT2(_e, _m) do { } while (0)
#define HARD_ASSERT2_NTC(_e, _m) do { } while (0)

#define HARD_VERIFY(_e) do { (_e); } while (0)
#define HARD_VERIFY_NTC(_e) do { (_e); } while (0)
#define HARD_VERIFY2(_e, _m) do { (_e); } while (0)
#define HARD_VERIFY2_NTC(_e, _m) do { (_e); } while (0)

#define SOFT_ASSERT(_expr) do { } while (0)
#define SOFT_ASSERT_NTC(_e) do { } while (0)
#define SOFT_ASSERT2(_e, _m) do { } while (0)
#define SOFT_ASSERT2_NTC(_e, _m) do { } while (0)

#define SOFT_VERIFY(_e) do { (_e); } while (0)
#define SOFT_VERIFY_NTC(_e) do { (_e); } while (0)

#define SOFT_VERIFY2(_e, _m) do { (_e); } while (0)
#define SOFT_VERIFY2_NTC(_e, _m) do { (_e); } while (0)

#endif // DBG

#define VERIFY(_e) HARD_VERIFY(_e)
#define VERIFY_NTC(_e) HARD_VERIFY_NTC(_e)
#define VERIFY2(_e, _m) HARD_VERIFY2(_e, _m)
#define VERIFY2_NTC(_e, _m) HARD_VERIFY2_NTC(_e, _m)

#define ASSERT(_e) HARD_ASSERT(_e)
#define ASSERT2(_e, _m) HARD_ASSERT2(_e, _m)
#define ASSERT_NTC(_e) HARD_ASSERT_NTC(_e)
#define ASSERT2_NTC(_e, _m) HARD_ASSERT2_NTC(_e, _m)

#define INTERNAL_ERROR2_ACTION(_e, _m) do { HARD_ASSERT2_ACTION(_e, _m); __t.MarkInternalError(); goto Exit; } while (0)
#define W32INTERNAL_ERROR2_ACTION_NTC(_e, _m) do { HARD_ASSERT2_ACTION(_e, _m); ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR); goto Exit; } while (0)

#define INTERNAL_ERROR_CHECK(_e) do { if (!(_e)) { INTERNAL_ERROR2_ACTION(_e, NULL); } } while (0)
#define INTERNAL_ERROR_CHECK2(_e, _m) do { if (!(_e)) { INTERNAL_ERROR2_ACTION(_e, _m); } } while (0)

#define W32INTERNAL_ERROR_CHECK_NTC(_e) do { if (!(_e)) { W32INTERNAL_ERROR2_ACTION_NTC(_e, NULL); } } while (0)
#define W32INTERNAL_ERROR_CHECK2_NTC(_e, _m) do { if (!(_e)) { W32INTERNAL_ERROR2_ACTION_NTC(_e, _m); } } while (0)

// There are several win32 errors for out of memory.
// We'll always use FUSION_WIN32_ALLOCFAILED_ERROR so that if we change
// out minds about which one is right we can do it in one place.

#define FUSION_WIN32_ALLOCFAILED_ERROR ERROR_OUTOFMEMORY

class CNoTraceContextUsedInFrameWithTraceObject
{
private:
    CNoTraceContextUsedInFrameWithTraceObject(); // intentionally not implemented
    ~CNoTraceContextUsedInFrameWithTraceObject(); // intentionally not implemented
};

typedef struct _SXS_STATIC_TRACE_CONTEXT
{
    TEB_ACTIVE_FRAME_CONTEXT_EX m_FrameContext;
    INT m_StartLine;
} SXS_STATIC_TRACE_CONTEXT;

typedef struct _SXS_STATIC_RELEASE_TRACE_CONTEXT
{
    SXS_STATIC_TRACE_CONTEXT m_TraceContext;
    PCSTR m_TypeName;
} SXS_STATIC_RELEASE_TRACE_CONTEXT;

class CFrame;

typedef struct _FROZEN_STACK
{
    ULONG        ulDepth;
    ULONG        ulMaxDepth;
    CFrame *pContents;
} FROZEN_STACK, *PFROZEN_STACK;

typedef enum _TRACETYPE
{
    TRACETYPE_INFO,
    TRACETYPE_CALL_START,
    TRACETYPE_CALL_EXIT_NOHRESULT,
    TRACETYPE_CALL_EXIT_HRESULT,
} TRACETYPE;

extern bool g_FusionBreakOnBadParameters;

/*
MEMORY_BASIC_INFORMATION g_SxsDllMemoryBasicInformation;
*/

VOID FusionpConvertCOMFailure(HRESULT & __hr);

int STDAPIVCALLTYPE _DebugTraceA(PCSTR pszMsg, ...);
int STDAPICALLTYPE _DebugTraceVaA(PCSTR pszMsg, va_list ap);
int STDAPIVCALLTYPE _DebugTraceW(PCWSTR pszMsg, ...);
int STDAPICALLTYPE _DebugTraceVaW(PCWSTR pszMsg, va_list ap);

int STDAPIVCALLTYPE _DebugTraceExA(DWORD dwFlags, TRACETYPE tt, HRESULT hr, PCSTR pszMsg, ...);
int STDAPICALLTYPE _DebugTraceExVaA(DWORD dwFlags, TRACETYPE tt, HRESULT hr, PCSTR pszMsg, va_list ap);
int STDAPIVCALLTYPE _DebugTraceExW(DWORD dwFlags, TRACETYPE tt, HRESULT hr, PCWSTR pszMsg, ...);
int STDAPICALLTYPE _DebugTraceExVaW(DWORD dwFlags, TRACETYPE tt, HRESULT hr, PCWSTR pszMsg, va_list ap);

void __fastcall FusionpTraceWin32LastErrorFailure(const CALL_SITE_INFO &rCallSiteInfo);
void __fastcall FusionpTraceWin32LastErrorFailureOrigination(const CALL_SITE_INFO &rCallSiteInfo);
void __fastcall FusionpTraceCOMFailure(const CALL_SITE_INFO &rCallSiteInfo, HRESULT hrLastError);
void __fastcall FusionpTraceCOMFailureOrigination(const CALL_SITE_INFO &rCallSiteInfo, HRESULT hrLastError);

/*
These are never used outside trace.cpp.

void FusionpTraceWin32FailureNoFormatting(const FRAME_INFO &rFrameInfo, DWORD dwWin32Status, PCSTR pszMessage);
void FusionpTraceWin32FailureNoFormatting(DWORD dwWin32Status, PCSTR pszMessage);
void FusionpTraceWin32FailureNoFormatting(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwWin32Status, PCSTR pszMessage);

void FusionpTraceWin32FailureOriginationNoFormatting(const FRAME_INFO &rFrameInfo, DWORD dwWin32Status, PCSTR pszMessage);
void FusionpTraceWin32FailureOriginationNoFormatting(DWORD dwWin32Status, PCSTR pszMessage);
void FusionpTraceWin32FailureOriginationNoFormatting(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwWin32Status, PCSTR pszMessage);

void FusionpTraceWin32Failure(const FRAME_INFO &rFrameInfo, DWORD dwWin32Status, PCSTR pszMessage, ...);
void FusionpTraceWin32Failure(DWORD dwWin32Status, PCSTR pszMessage, ...);
void FusionpTraceWin32Failure(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwWin32Status, PCSTR pszMessage, ...);
*/

void FusionpTraceWin32FailureVa(const FRAME_INFO &rFrameInfo, DWORD dwWin32Status, PCSTR pszMsg, va_list ap);
void FusionpTraceWin32FailureVa(DWORD dwWin32Status, PCSTR pszMsg, va_list ap);
void FusionpTraceWin32FailureVa(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwWin32Status, PCSTR pszMsg, va_list ap);

void FusionpTraceCOMFailure(HRESULT hrIn, PCSTR pszMsg, ...);
void FusionpTraceCOMFailureVa(HRESULT hrIn, PCSTR pszMsg, va_list ap);

void FusionpTraceCOMFailureOrigination(HRESULT hrIn, PCSTR pszMsg, ...);
void FusionpTraceCOMFailureOriginationVa(HRESULT hrIn, PCSTR pszMsg, va_list ap);

void FusionpTraceCallEntry();
void FusionpTraceCallExit();

void FusionpTraceCallCOMSuccessfulExit(HRESULT hrIn, PCSTR szFormat, ...);
void FusionpTraceCallCOMSuccessfulExitVa(HRESULT hrIn, PCSTR szFormat, va_list ap);

void FusionpTraceCallSuccessfulExit(PCSTR szFormat, ...);
void FusionpTraceCallSuccessfulExitVa(PCSTR szFormat, va_list ap);

void FusionpTraceCallWin32UnsuccessfulExit(DWORD dwLastError, PCSTR szFormat, ...);
void FusionpTraceCallWin32UnsuccessfulExitVa(DWORD dwLastError, PCSTR szFormat, va_list ap);

 void FusionpTraceCallCOMUnsuccessfulExit(HRESULT hrError, PCSTR szFormat, ...);
 void FusionpTraceCallCOMUnsuccessfulExitVa(HRESULT hrError, PCSTR szFormat, va_list ap);

void FusionpTraceAllocFailure(PCSTR pszExpression);

void FusionpTraceInvalidFlags(const FRAME_INFO &rFrameInfo, DWORD dwFlagsPassed, DWORD dwValidFlags);
void FusionpTraceInvalidFlags(PCSTR pszFile, PCSTR pszFunction, INT nLine, DWORD dwFlagsPassed, DWORD dwValidFlags);
void FusionpTraceInvalidFlags(DWORD dwFlagsPassed, DWORD dwValidFlags);

void FusionpTraceNull(PCSTR pszExpression);
void FusionpTraceZero(PCSTR pszExpression);
void FusionpTraceParameterMustNotBeNull(PCSTR pszExpression);

void FusionpTraceParameterCheck(PCSTR pszExpression);
void FusionpTraceParameterCheck(PCSTR pszFile, PCSTR pszFunction, INT nLine, PCSTR pszExpression);
void FusionpTraceParameterCheck(const FRAME_INFO &rFrame, PCSTR pszExpression);

#define FUSIONP_DUMP_STACK_FORMAT_SHORT      ( 0x00000001 )
#define FUSIONP_DUMP_STACK_FORMAT_MEDIUM     ( 0x00000002 )
#define FUSIONP_DUMP_STACK_FORMAT_LONG       ( 0x00000003 )
#define FUSIONP_DUMP_STACK_FORMAT_MASK       ( 0x00000003 )

VOID FusionpDumpStack(DWORD dwFlags, ULONG ulLevel, PCWSTR pcwszLinePrefix, ULONG ulDepth);


#define TRACEMSG(_paramlist) _DebugTraceA _paramlist

#if DBG
#define DEFINE_CURRENT_FRAME_INFO(_frame) static const FRAME_INFO _frame = { __FILE__, __FUNCTION__, __LINE__ }
#define DBG_TEXT(_x) #_x
#else
#define DEFINE_CURRENT_FRAME_INFO(_frame) static const FRAME_INFO _frame = { __FILE__, "", __LINE__ }
#define DBG_TEXT(_x) ""
#endif

#define DEFINE_CALL_SITE_INFO(_callsite, _apiname) static const CALL_SITE_INFO _callsite = { __FILE__, __FUNCTION__, DBG_TEXT(_apiname), __LINE__ }
#define DEFINE_CALL_SITE_INFO_EX(_callsite) static const CALL_SITE_INFO _callsite = { __FILE__, __FUNCTION__, "", __LINE__ }

#define TRACE_WIN32_FAILURE(_apiname) \
do \
{ \
    DEFINE_CALL_SITE_INFO(__callsite, _apiname); \
    ::FusionpTraceWin32LastErrorFailure(__callsite); \
} while (0)

#define TRACE_WIN32_FAILURE_ORIGINATION(_apiname) \
do \
{ \
    DEFINE_CALL_SITE_INFO(__callsite, _apiname); \
    ::FusionpTraceWin32LastErrorFailureOrigination(__callsite); \
} while (0)

#define TRACE_HR_FAILURE_ORIGINATON(_apiname, _hresult) \
do \
{ \
    DEFINE_CALL_SITE_INFO(__callsite, _apiname); \
    ::FusionpTraceCOMFailureOrigination(__callsite, _hresult)  ; \
} while (0)    

// FusionpTraceWin32Failure(FUSION_DBG_LEVEL_ERROR, __FILE__, __LINE__, __FUNCTION__, ::FusionpGetLastWin32Error(), #_apiname)
#define TRACE_COM_FAILURE(_hresult, _apiname) ::FusionpTraceCOMFailure((_hresult), DBG_TEXT(_apiname))
#define TRACE_COM_FAILURE_ORIGINATION(_hresult, _apiname) ::FusionpTraceCOMFailureOrigination((_hresult), DBG_TEXT(_apiname))

#define TRACE_DUMP_STACK(_includetop) _DebugTraceDumpStack((_includetop))
#define TRACE_ALLOCFAILED(_e) ::FusionpTraceAllocFailure(DBG_TEXT(_e))
#define TRACE_INVALID_FLAGS(_fPassed, _fExpected) ::FusionpTraceInvalidFlags((_fPassed), (_fExpected))
#define TRACE_NULL(_e) ::FusionpTraceNull(DBG_TEXT(_e))
#define TRACE_ZERO(_e) ::FusionpTraceZero(DBG_TEXT(_e))
#define TRACE_PARAMETER_MUST_NOT_BE_NULL(_p) do { ::FusionpTraceParameterMustNotBeNull(DBG_TEXT(_p)); } while (0)
#define TRACE_PARAMETER_CHECK(_e) do { ::FusionpTraceParameterCheck(DBG_TEXT(_e)); } while (0)
#define TRACE_PARAMETER_CHECK_INTERNAL(_e) do { ASSERT(false && "Invalid parameter passed to private function"); ::FusionpTraceParameterCheck(DBG_TEXT(_e)); } while (0)

//
// on DBG avoid both the code breakpoint on ::FusionpSetLastWin32Error
// and the data write breakpoint on NtCurrentTeb()->LastErrorValue
//
// on !DBG, only avoid the first (perf)
//

#if DBG

// aka Sxsp::FusionpSetLastWin32ErrorAvoidingGratuitousBreakpoints
#define SxspRestoreLastError(x) \
    ((void)                                        \
    (                                              \
          (NtCurrentTeb()->LastErrorValue != (x))  \
        ? (NtCurrentTeb()->LastErrorValue = (x))   \
        : 0                                        \
    ))

#else

#define SxspRestoreLastError(x) ((void)((NtCurrentTeb()->LastErrorValue = (x))))

#endif // DBG

class CGlobalFakeTraceContext
{
public:
    static inline void SetLastError(DWORD dwLastError) { ::FusionpSetLastWin32Error(dwLastError); }
    static inline void ClearLastError() { ::FusionpClearLastWin32Error(); }
};

__declspec(selectany) CGlobalFakeTraceContext g_GlobalFakeTraceContext;

class CFrame : public _TEB_ACTIVE_FRAME_EX
{
    friend bool
    __fastcall
    FusionpGetActiveFrameInfo(
        FRAME_INFO &rFrameInfo
        );

    friend bool
    __fastcall
    FusionpPopulateFrameInfo(
        FRAME_INFO &rFrameInfo,
        PCTEB_ACTIVE_FRAME ptaf
        );

public:
    inline CFrame(const SXS_STATIC_TRACE_CONTEXT &rc)
    {
        this->BasicFrame.Flags = TEB_ACTIVE_FRAME_FLAG_EXTENDED;
        this->BasicFrame.Previous = NULL;
        this->BasicFrame.Context = &rc.m_FrameContext.BasicContext;
        this->ExtensionIdentifier = (PVOID) (' sxS');
        m_nLine = rc.m_StartLine;
    }

    inline void BaseEnter()
    {
#if FUSION_WIN
        ::FusionpRtlPushFrame(&this->BasicFrame);
#endif // FUSION_WIN
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallEntry();
    };

    inline void Enter() { BaseEnter(); }

    inline void SetLine(int nLine) { m_nLine = nLine; }

    inline static void SetLastError(PTEB Teb, DWORD dwLastError) { Teb->LastErrorValue = dwLastError; }
    inline static void SetLastError(DWORD dwLastError) { ::FusionpSetLastWin32Error(dwLastError); }
    inline static DWORD GetLastError() { return ::FusionpGetLastWin32Error(); }
    inline static void ClearLastError() { ::FusionpClearLastWin32Error(); }

    inline void TraceNull(PCSTR pszExpression) const { ::FusionpTraceNull(pszExpression); }
    inline void TraceCOMFailure(HRESULT hrIn, PCSTR pszExpression) const { ::FusionpTraceCOMFailure(hrIn, pszExpression); }

    inline HRESULT ConvertCOMFailure(HRESULT hrIn) { ASSERT_NTC(FAILED(hrIn)); ::FusionpConvertCOMFailure(hrIn); ASSERT_NTC(FAILED(hrIn)); return hrIn; }

    inline ~CFrame()
    {
#if FUSION_WIN
        ::FusionpRtlPopFrame(&this->BasicFrame);
#endif
    }

protected:
    int m_nLine;

    const SXS_STATIC_TRACE_CONTEXT *GetTraceContext() const { return reinterpret_cast<const SXS_STATIC_TRACE_CONTEXT *>(BasicFrame.Context); }
    template <typename T> const T *GetTypedTraceContext() const { return static_cast<const T *>(this->GetTraceContext()); }

private:
    CFrame(const CFrame &r); // unimplemented copy constructor
    CFrame &operator =(const CFrame &r); // unimplemented assignment operator
};

class CFnTracer : public CFrame
{
public:
    inline CFnTracer(
        const SXS_STATIC_TRACE_CONTEXT &rsftc
    ) : CFrame(rsftc)
    {
    }

    ~CFnTracer()
    {
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallExit();
    }

    // These three lines should be removed.
    void MarkInternalError() { this->SetLastError(ERROR_INTERNAL_ERROR); }
    void MarkAllocationFailed() { this->SetLastError(FUSION_WIN32_ALLOCFAILED_ERROR); }
    void MarkWin32LastErrorFailure() { ASSERT_NTC(this->GetLastError() != ERROR_SUCCESS); }
    void MarkWin32Failure(DWORD dw) { this->SetLastError(dw); }

    void MarkSuccess() { }
    void ReturnValue() const { }

protected:

private:
    CFnTracer(const CFnTracer &r); // intentionally not implemented
    CFnTracer &operator =(const CFnTracer &r); // intentionally not implemented
};

template <typename T> class CFnTracerConstructor : public CFrame
{
public:
    CFnTracerConstructor(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        PCSTR szTypeName,
        T *pThis
        ) : CFrame(rsftc),
            m_pThis(pThis),
            m_szTypeName(szTypeName)
    {
    }

    ~CFnTracerConstructor()
    {
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallExit();
    }

protected:
    const PCSTR m_szTypeName;
    T const *m_pThis;

private:
    CFnTracerConstructor &operator=(const CFnTracerConstructor &r); // intentionally not implemented
    CFnTracerConstructor(const CFnTracerConstructor &r); // intentionally not implemented
};

template <typename T> class CFnTracerDestructor : public CFrame
{
public:
    CFnTracerDestructor(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        PCSTR szTypeName,
        T *pThis
        ) : CFrame(rsftc),
            m_pThis(pThis),
            m_szTypeName(szTypeName)
    {
    }

    ~CFnTracerDestructor()
    {
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallExit();
    }

protected:
    const PCSTR m_szTypeName;
    T const *m_pThis;

private:
    CFnTracerDestructor &operator=(const CFnTracerDestructor &r); // intentionally not implemented
    CFnTracerDestructor(const CFnTracerDestructor &r); // intentionally not implemented
};

template <typename T> class CFnTracerAddRef : public CFrame
{
public:
    CFnTracerAddRef(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        PCSTR szTypeName,
        T *pThis,
        LONG &rlRefCount
        ) : CFrame(rsftc),
            m_pThis(pThis),
            m_rlRefCount(rlRefCount),
            m_szTypeName(szTypeName)
    {
    }

    CFnTracerAddRef(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        PCSTR szTypeName,
        T *pThis,
        ULONG &rlRefCount
        ) : CFrame(rsftc),
            m_pThis(pThis),
            m_rlRefCount(*((LONG *) &rlRefCount)),
            m_szTypeName(szTypeName)
    {
    }

    ~CFnTracerAddRef()
    {
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallExit();
    }

protected:
    const PCSTR m_szTypeName;
    T const *m_pThis;
    LONG &m_rlRefCount;

private:
    CFnTracerAddRef &operator=(const CFnTracerAddRef &r); // intentionally not implemented
    CFnTracerAddRef(const CFnTracerAddRef &r); // intentionally not implemented
};

template <typename T> class CFnTracerRelease : public CFrame
{
public:
    CFnTracerRelease(
        const SXS_STATIC_RELEASE_TRACE_CONTEXT &rsrtc,
        T *pThis,
        LONG &rlRefCount
        ) : CFrame(rsrtc.m_TraceContext),
            m_pThis(pThis),
            m_rlRefCount(rlRefCount)
    {
    }

    CFnTracerRelease(
        const SXS_STATIC_RELEASE_TRACE_CONTEXT &rsrtc,
        T *pThis,
        ULONG &rlRefCount
        ) : CFrame(rsrtc.m_TraceContext),
            m_pThis(pThis),
            m_rlRefCount(*((LONG *) &rlRefCount))
    {
    }

    ~CFnTracerRelease()
    {
        if (g_FusionEnterExitTracingEnabled)
            ::FusionpTraceCallExit();
    }

protected:
    T const *m_pThis;
    LONG &m_rlRefCount;

private:
    CFnTracerRelease &operator=(const CFnTracerRelease &r); // intentionally not implemented
    CFnTracerRelease(const CFnTracerRelease &r); // intentionally not implemented
};

class CFnTracerHR : public CFrame
{
public:
    CFnTracerHR(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        HRESULT &rhr
        ) : CFrame(rsftc),
        m_rhr(rhr) { }

    ~CFnTracerHR()
    {
        if (g_FusionEnterExitTracingEnabled)
        {
            const DWORD dwLastError = this->GetLastError();

            if (SUCCEEDED(m_rhr))
            {
                ::FusionpTraceCallCOMSuccessfulExit(m_rhr, NULL);
            }
            else
            {
                ::FusionpTraceCallCOMUnsuccessfulExit(m_rhr, NULL);
            }

            this->SetLastError(dwLastError);
        }
    }

    void MarkInternalError() { m_rhr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); }
    void MarkAllocationFailed() { m_rhr = E_OUTOFMEMORY; }
    void MarkInvalidParameter() { m_rhr = E_INVALIDARG; }
    void MarkWin32LastErrorFailure() { m_rhr = HRESULT_FROM_WIN32(this->GetLastError()); ASSERT_NTC(FAILED(m_rhr)); }
    void MarkWin32Failure(DWORD dwErrorCode) { m_rhr = HRESULT_FROM_WIN32(dwErrorCode); ::FusionpConvertCOMFailure(m_rhr); ASSERT_NTC(FAILED(m_rhr)); }
    void MarkCOMFailure(HRESULT hr) { ASSERT_NTC(FAILED(hr)); ::FusionpConvertCOMFailure(hr); ASSERT_NTC(FAILED(hr)); m_rhr = hr; }
    void MarkSuccess() { m_rhr = NOERROR; }

    HRESULT ReturnValue() const { return m_rhr; }

    HRESULT &m_rhr;
private:
    CFnTracerHR &operator=(const CFnTracerHR &r); // intentionally not implemented
    CFnTracerHR(const CFnTracerHR &r); // intentionally not implemented
};

class CFnTracerWin32 : public CFrame
{
public:
    inline CFnTracerWin32(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        BOOL &rfSucceeded
        ) : CFrame(rsftc),
            m_rfSucceeded(rfSucceeded)
    {
    }

    inline ~CFnTracerWin32()
    {
        if (g_FusionEnterExitTracingEnabled)
            this->TraceExit();
    }

    __declspec(nothrow) void TraceExit() const
    {
        if (m_rfSucceeded)
            ::FusionpTraceCallSuccessfulExit(NULL);
        else
        {
            ASSERT_NTC(this->GetLastError() != ERROR_SUCCESS);
            ::FusionpTraceCallWin32UnsuccessfulExit(this->GetLastError(), NULL);
        }
    }

    inline void MarkInternalError() { this->SetLastError(ERROR_INTERNAL_ERROR); m_rfSucceeded = FALSE; }
    inline void MarkAllocationFailed() { this->SetLastError(FUSION_WIN32_ALLOCFAILED_ERROR); m_rfSucceeded = FALSE; }
    inline void MarkInvalidParameter() { this->SetLastError(ERROR_INVALID_PARAMETER); m_rfSucceeded = FALSE; }
    inline void MarkSuccess() { this->SetLastError(ERROR_SUCCESS); m_rfSucceeded = TRUE; }
    inline void MarkWin32LastErrorFailure() { ASSERT_NTC(this->GetLastError() != ERROR_SUCCESS); m_rfSucceeded = FALSE; }
    inline void MarkWin32Failure(DWORD dwErrorCode) { ASSERT_NTC(dwErrorCode != ERROR_SUCCESS); this->SetLastError(dwErrorCode); m_rfSucceeded = FALSE; }
    void MarkCOMFailure(HRESULT hr) { hr = this->ConvertCOMFailure(hr); this->SetLastError(::FusionpHRESULTToWin32(hr)); m_rfSucceeded = FALSE; }

    inline BOOL ReturnValue() const { return m_rfSucceeded; }

    BOOL &m_rfSucceeded;

protected:

private:
    CFnTracerWin32 &operator=(const CFnTracerWin32 &r); // intentionally not implemented
    CFnTracerWin32(const CFnTracerWin32 &r); // intentionally not implemented
};

class CFnTracerReg : public CFrame
{
public:
    inline CFnTracerReg(
        const SXS_STATIC_TRACE_CONTEXT &rsftc,
        LONG &rlError
        ) : CFrame(rsftc),
            m_rlError(rlError)
    {
    }

    ~CFnTracerReg()
    {
        if (g_FusionEnterExitTracingEnabled)
        {
            if (m_rlError == ERROR_SUCCESS)
            {
                ::FusionpTraceCallSuccessfulExit(NULL);
            }
            else
            {
                ::FusionpTraceCallWin32UnsuccessfulExit(m_rlError, NULL);
            }
        }
    }

    void MarkInternalError() { m_rlError = ERROR_INTERNAL_ERROR; }
    void MarkAllocationFailed() { m_rlError = FUSION_WIN32_ALLOCFAILED_ERROR; }
    void MarkInvalidParameter() { m_rlError = ERROR_INVALID_PARAMETER; }
    LONG ReturnValue() const { return m_rlError; }

    LONG &m_rlError;

protected:

private:
    CFnTracerReg &operator=(const CFnTracerReg &r); // intentionally not implemented
    CFnTracerReg(const CFnTracerReg &r); // intentionally not implemented
};

#define FN_TRACE_EX(_stc) CFnTracer __t(_stc); __t.Enter()
#define FN_TRACE_WIN32_EX(_stc, _fsucceeded) CFnTracerWin32 __t(_stc, _fsucceeded); __t.Enter()
#define FN_TRACE_REG_EX(_stc, _lastError) CFnTracerReg __t(_stc, _lastError); __t.Enter()
#define FN_TRACE_HR_EX(_stc, _hr) CFnTracerHR __t(_stc, _hr); __t.Enter()
#define FN_TRACE_CONSTRUCTOR_EX(_stc, _thistype, _this) CFnTracerConstructor<_thistype> __t(_stc, #_thistype, _this); __t.Enter()
#define FN_TRACE_DESTRUCTOR_EX(_stc, _thistype, _this) CFnTracerDestructor<_thistype> __t(_stc, #_thistype, _this); __t.Enter()
#define FN_TRACE_ADDREF_EX(_stc, _thistype, _this, _var) CFnTracerAddRef<_thistype> __t(_stc, #_thistype, (_this), (_var)); __t.Enter()
#define FN_TRACE_RELEASE_EX(_stc, _thistype, _this, _var) CFnTracerRelease<_thistype> __t(_stc, (_this), (_var)); __t.Enter()

#if !defined(FUSION_DEFAULT_FUNCTION_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_FUNCTION_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_ENTEREXIT)
#endif

#if !defined(FUSION_DEFAULT_FUNCTION_SUCCESSFUL_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_FUNCTION_SUCCESSFUL_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_ENTEREXIT)
#endif

#if !defined(FUSION_DEFAULT_FUNCTION_UNSUCCESSFUL_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_FUNCTION_UNSUCCESSFUL_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_ENTEREXIT | FUSION_DBG_LEVEL_ERROREXITPATH)
#endif

#if !defined(FUSION_DEFAULT_CONSTRUCTOR_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_CONSTRUCTOR_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_CONSTRUCTORS)
#endif

#if !defined(FUSION_DEFAULT_CONSTRUCTOR_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_CONSTRUCTOR_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_CONSTRUCTORS)
#endif

#if !defined(FUSION_DEFAULT_DESTRUCTOR_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_DESTRUCTOR_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_DESTRUCTORS)
#endif

#if !defined(FUSION_DEFAULT_DESTRUCTOR_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_DESTRUCTOR_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_DESTRUCTORS)
#endif

#if !defined(FUSION_DEFAULT_ADDREF_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_ADDREF_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

#if !defined(FUSION_DEFAULT_ADDREF_EXIT_TRACE_LEVEL)
#define FUSION_DEFAULT_ADDREF_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

#if !defined(FUSION_DEFAULT_RELEASE_ENTRY_TRACE_LEVEL)
#define FUSION_DEFAULT_RELEASE_ENTRY_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

#if !defined(FUSION_DEFAULT_RELEASE_EXIT_NONZERO_TRACE_LEVEL)
#define FUSION_DEFAULT_RELEASE_NONZERO_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

#if !defined(FUSION_DEFAULT_RELEASE_EXIT_ZERO_TRACE_LEVEL)
#define FUSION_DEFAULT_RELEASE_ZERO_EXIT_TRACE_LEVEL (FUSION_DBG_LEVEL_REFCOUNTING)
#endif

//
//  #undef and #define FUSION_FACILITY_MASK to any specific additional debug output
//  filtering bits you want to set.
//

#if !defined(FUSION_FACILITY_MASK)
#define FUSION_FACILITY_MASK (0)
#endif // !defined(FUSION_FACILITY_MASK)

#define DEFINE_STATIC_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_FN_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_CONSTRUCTOR_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_DESTRUCTOR_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_ADDREF_TRACE_CONTEXT() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define DEFINE_STATIC_RELEASE_TRACE_CONTEXT(_thistype) static const SXS_STATIC_RELEASE_TRACE_CONTEXT __stc = { { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }, #_thistype }

#define DEFINE_STATIC_FN_TRACE_CONTEXT2() static const SXS_STATIC_TRACE_CONTEXT __stc = { { { TEB_ACTIVE_FRAME_CONTEXT_FLAG_EXTENDED, __FUNCTION__ }, __FILE__ }, __LINE__ }

#define FN_TRACE() DEFINE_STATIC_FN_TRACE_CONTEXT(); FN_TRACE_EX(__stc)
#define FN_TRACE_SMART_TLS() FN_TRACE()
#define FN_TRACE_WIN32(_fsucceeded) DEFINE_STATIC_FN_TRACE_CONTEXT2(); FN_TRACE_WIN32_EX(__stc, _fsucceeded)
#define FN_TRACE_REG(_lastError) DEFINE_STATIC_FN_TRACE_CONTEXT2(); FN_TRACE_REG_EX(__stc, _lastError)
#define FN_TRACE_HR(_hr) DEFINE_STATIC_FN_TRACE_CONTEXT2(); FN_TRACE_HR_EX(__stc, _hr)
#define FN_TRACE_CONSTRUCTOR(_thistype) DEFINE_STATIC_CONSTRUCTOR_TRACE_CONTEXT(); FN_TRACE_CONSTRUCTOR_EX(__stc, _thistype, this)
#define FN_TRACE_DESTRUCTOR(_thistype) DEFINE_STATIC_DESTRUCTOR_TRACE_CONTEXT(); FN_TRACE_DESTRUCTOR_EX(__stc, _thistype, this)
#define FN_TRACE_ADDREF(_thistype, _var) DEFINE_STATIC_ADDREF_TRACE_CONTEXT(); FN_TRACE_ADDREF_EX(__stc, _thistype, this, _var)
#define FN_TRACE_RELEASE(_thistype, _var) DEFINE_STATIC_RELEASE_TRACE_CONTEXT(_thistype); FN_TRACE_RELEASE_EX(__stc, _thistype, this, _var)

#define FN_PROLOG_VOID FN_TRACE();
#define FN_PROLOG_VOID_TLS FN_TRACE();
#define FN_PROLOG_WIN32 BOOL __fSuccess = FALSE; FN_TRACE_WIN32(__fSuccess);
#define FN_PROLOG_HR HRESULT __hr = ~static_cast<HRESULT>(0); FN_TRACE_HR(__hr);

// "if (false) { goto Exit; }" here is probably to quash the compiler's warning about
// Exit not being otherwise used.
#define FN_EPILOG if (false) { goto Exit; } __t.MarkSuccess(); Exit: return __t.ReturnValue();

#define TRACED_RELEASE(_var) __t.Release(_var)

#define FN_TRACE_UPDATE_LINE() do { __t.SetLine(__LINE__); } while (0)

#define FUSION_CLEAR_LAST_ERROR() do { __t.ClearLastError(); } while (0)
#define FUSION_SET_LAST_ERROR(_le) do { __t.SetLastError((_le)); } while (0)

#define FUSION_VERIFY_LAST_ERROR_SET() do { ASSERT(::FusionpGetLastWin32Error() != ERROR_SUCCESS); } while (0)

#define LIST_1(x) { x }
#define LIST_2(x, y) { x , y }
#define LIST_3(x, y, z) { x , y , z }
#define LIST_4(a, b, c, d) { a , b , c , d }
#define LIST_5(a, b, c, d, e) { a , b , c , d, e }

/*
for example:
    ORIGINATE_WIN32_FAILURE_AND_EXIT_EX(dwLastError, ("%s(%ls)", "GetFileAttributesW", lpFileName));
or
    ORIGINATE_WIN32_FAILURE_AND_EXIT_EX(dwLastError, (GetFileAttributesW(%ls)", lpFileName));
*/
#define ORIGINATE_WIN32_FAILURE_AND_EXIT_EX(le_, dbgprint_va_) \
    do { __t.MarkWin32Failure(le_); TRACE_WIN32_FAILURE_ORIGINATION_EX(dbgprint_va_); goto Exit; } while (0)

#define TRACE_WIN32_FAILURE_EX(dbgprint_va_) do { \
    DEFINE_CALL_SITE_INFO_EX(callsite_); callsite_.TraceWin32LastErrorFailureEx dbgprint_va_; } while (0)

#define TRACE_WIN32_FAILURE_ORIGINATION_EX(dbgprint_va_) do { \
    DEFINE_CALL_SITE_INFO_EX(callsite_); callsite_.TraceWin32LastErrorFailureOriginationEx dbgprint_va_; } while (0)

#define ORIGINATE_HR_FAILURE_AND_EXIT(_x, _hr) do { __t.MarkCOMFailure((_hr)); TRACE_HR_FAILURE_ORIGINATON(_x, _hr); goto Exit; } while (0)
#define ORIGINATE_WIN32_FAILURE_AND_EXIT(_x, _le) do { __t.MarkWin32Failure((_le)); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } while (0)
#define ORIGINATE_WIN32_FAILURE_AND_EXIT_NTC(_x, _le) do { ::FusionpSetLastWin32Error((_le)); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } while (0)
#define IFFALSE_ORIGINATE_WIN32_FAILURE_AND_EXIT(_x, _le) do { if (!(_x)) { __t.MarkWin32Failure((_le)); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } while (0)

#define IFINVALIDHANDLE_EXIT_WIN32_TRACE(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == INVALID_HANDLE_VALUE) { FUSION_VERIFY_LAST_ERROR_SET(); TRACE_WIN32_FAILURE(_x); goto Exit; } } while (0)

/*
for example:
    IFW32FALSE_EXIT_EX(f.Win32CreateFile(psz), ("%ls", psz));
*/
#define IFW32FALSE_EXIT_EX(_x, dbgprint_va_) \
    do { FUSION_CLEAR_LAST_ERROR(); \
         if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); \
                      __t.MarkWin32LastErrorFailure(); \
                      DEFINE_CALL_SITE_INFO(__callsite, _x); \
                      __callsite.TraceWin32LastErrorFailureEx dbgprint_va_; \
                      goto Exit; } } while (0)
#define IFW32FALSE_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); __t.MarkWin32LastErrorFailure(); TRACE_WIN32_FAILURE(_x); goto Exit; } } while (0)
#define IFW32FALSE_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); __t.MarkWin32LastErrorFailure(); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } while (0)

#define IFW32FALSE_EXIT_UNLESS(_x, _unless, _unlessHitFlag) do { FUSION_CLEAR_LAST_ERROR(); (_unlessHitFlag) = false; if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); if (_unless) (_unlessHitFlag) = true; else { TRACE_WIN32_FAILURE(_x); goto Exit; } } } while (0)
#define IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS(_x, _unless, _unlessHitFlag) do { FUSION_CLEAR_LAST_ERROR(); (_unlessHitFlag) = false; if (!(_x)) { FUSION_VERIFY_LAST_ERROR_SET(); if (_unless) (_unlessHitFlag) = true; else { TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } } while (0)

#define IFW32FALSE_EXIT_UNLESS2(_x, _unless, _unlessHitFlag) do { static const DWORD _s_rgdwAcceptableLastErrorValues[] = _unless; FUSION_CLEAR_LAST_ERROR(); (_unlessHitFlag) = false; if (!(_x)) { ULONG _i; const DWORD _dwLastError = ::FusionpGetLastWin32Error(); FUSION_VERIFY_LAST_ERROR_SET(); for (_i=0; _i<NUMBER_OF(_s_rgdwAcceptableLastErrorValues); _i++) { if (_dwLastError == _s_rgdwAcceptableLastErrorValues[_i]) { (_unlessHitFlag) = true; break; } } if (_i == NUMBER_OF(_s_rgdwAcceptableLastErrorValues)) { TRACE_WIN32_FAILURE(_x); goto Exit; } } } while (0)
#define IFW32FALSE_EXIT_UNLESS3(_x, _unless, _dwLastError) do { static const DWORD _s_rgdwAcceptableLastErrorValues[] = _unless; FUSION_CLEAR_LAST_ERROR(); (_dwLastError) = NO_ERROR; if (!(_x)) { ULONG _i; _dwLastError = ::FusionpGetLastWin32Error(); FUSION_VERIFY_LAST_ERROR_SET(); for (_i=0; _i<NUMBER_OF(_s_rgdwAcceptableLastErrorValues); _i++) { if (_dwLastError == _s_rgdwAcceptableLastErrorValues[_i]) { break; } } if (_i == NUMBER_OF(_s_rgdwAcceptableLastErrorValues)) { TRACE_WIN32_FAILURE(_x); goto Exit; } } } while (0)
#define IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS2(_x, _unless, _unlessHitFlag) do { static const DWORD _s_rgdwAcceptableLastErrorValues[] = _unless; FUSION_CLEAR_LAST_ERROR(); (_unlessHitFlag) = false; if (!(_x)) { ULONG _i; const DWORD _dwLastError = ::FusionpGetLastWin32Error(); FUSION_VERIFY_LAST_ERROR_SET(); for (_i=0; _i<NUMBER_OF(_s_rgdwAcceptableLastErrorValues); _i++) { if (_dwLastError == _s_rgdwAcceptableLastErrorValues[_i]) { (_unlessHitFlag) = true; break; } } if (_i == NUMBER_OF(_s_rgdwAcceptableLastErrorValues)) { TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } } while (0)
#define IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(_x, _unless, _dwLastError) do { static const DWORD _s_rgdwAcceptableLastErrorValues[] = _unless; FUSION_CLEAR_LAST_ERROR(); (_dwLastError) = NO_ERROR; if (!(_x)) { ULONG _i; _dwLastError = ::FusionpGetLastWin32Error(); FUSION_VERIFY_LAST_ERROR_SET(); for (_i=0; _i<NUMBER_OF(_s_rgdwAcceptableLastErrorValues); _i++) { if (_dwLastError == _s_rgdwAcceptableLastErrorValues[_i]) { break; } } if (_i == NUMBER_OF(_s_rgdwAcceptableLastErrorValues)) { TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } } while (0)

#define IFW32INVALIDHANDLE_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == INVALID_HANDLE_VALUE) { FUSION_VERIFY_LAST_ERROR_SET(); TRACE_WIN32_FAILURE(_x); goto Exit; } } while (0)
#define IFW32INVALIDHANDLE_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == INVALID_HANDLE_VALUE) { FUSION_VERIFY_LAST_ERROR_SET(); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } while (0)

#define IFREGFAILED_EXIT(_x) do { LONG __l; __l = (_x); if (__l != ERROR_SUCCESS) { __t.MarkWin32Failure(__l); FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE(_x); goto Exit; } } while (0)
#define IFREGFAILED_ORIGINATE_AND_EXIT(_x) do { LONG __l; __l = (_x); if (__l != ERROR_SUCCESS) { __t.MarkWin32Failure(__l); FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; } } while (0)

#define IFREGFAILED_EXIT_UNLESS(_x, _unlessStatuses, _dwLastError) do { LONG _validStatuses[] = _unlessStatuses; LONG __l; (_dwLastError) = ERROR_SUCCESS; __l = (_x); if (__l != ERROR_SUCCESS) { ULONG i; for (i = 0; i < NUMBER_OF(_validStatuses); i++) if (_validStatuses[i] == __l) { (_dwLastError) = __l; break; } if (i == NUMBER_OF(_validStatuses)) { FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE(_x); goto Exit; }}} while (0)
#define IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS(_x, _unlessStatuses, _dwLastError) do { LONG _validStatuses[] = _unlessStatuses; LONG __l; (_dwLastError) = ERROR_SUCCESS; __l = (_x); if (__l != ERROR_SUCCESS) { ULONG i; for (i = 0; i < NUMBER_OF(_validStatuses); i++) if (_validStatuses[i] == __l) { (_dwLastError) = __l; break; } if (i == NUMBER_OF(_validStatuses)) { FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit; }}} while (0)
#define IFREGFAILED_EXIT_UNLESS2(_x, _unlessStatuses, _unlessHitFlag) do { LONG _validStatuses[] = _unlessStatuses; LONG __l; (_unlessHitFlag) = false; __l = (_x); if ( __l != ERROR_SUCCESS ) { ULONG i; for ( i = 0; i < NUMBER_OF(_validStatuses); i++ ) if ( _validStatuses[i] == __l ) { (_unlessHitFlag) = true; break; } if (i == NUMBER_OF(_validStatuses)) { FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE(_x); goto Exit;}}} while (0)
#define IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2(_x, _unlessStatuses, _unlessHitFlag) do { LONG _validStatuses[] = _unlessStatuses; LONG __l; (_unlessHitFlag) = false; __l = (_x); if ( __l != ERROR_SUCCESS ) { ULONG i; for ( i = 0; i < NUMBER_OF(_validStatuses); i++ ) if ( _validStatuses[i] == __l ) { (_unlessHitFlag) = true; break; } if (i == NUMBER_OF(_validStatuses)) { FusionpSetLastWin32Error(__l); TRACE_WIN32_FAILURE_ORIGINATION(_x); goto Exit;}}} while (0)


#define IFCOMFAILED_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); HRESULT __hr = (_x); if (FAILED(__hr)) { TRACE_COM_FAILURE(__hr, _x); __t.MarkCOMFailure(__hr); goto Exit; } } while (0)
#define IFCOMFAILED_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); HRESULT __hr = (_x); if (FAILED(__hr)) { TRACE_COM_FAILURE_ORIGINATION(__hr, _x); __t.MarkCOMFailure(__hr); goto Exit; } } while (0)

#define IFFAILED_CONVERTHR_HRTOWIN32_EXIT_TRACE(_x) do { HRESULT __hr = (_x); if (FAILED(__hr)) { FusionpConvertCOMFailure(__hr); TRACE_COM_FAILURE(__hr, _x); FusionpSetLastErrorFromHRESULT(__hr); goto Exit; } } while (0)

#define IFALLOCFAILED_EXIT(_x) do { if ((_x) == NULL) { TRACE_ALLOCFAILED(_x); __t.MarkAllocationFailed(); goto Exit; } } while (0)

#define IFW32NULL_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == NULL) { TRACE_WIN32_FAILURE_ORIGINATION(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } while (0)
#define IFW32NULL_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == NULL) { TRACE_WIN32_FAILURE_ORIGINATION(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } while (0)
#define IFW32NULL_ORIGINATE_AND_EXIT_UNLESS2(_x, _unlessStatuses, _unlessHitFlag) do { DWORD __validStatuses[] = _unlessStatuses; _unlessHitFlag = false; FUSION_CLEAR_LAST_ERROR(); if ((_x) == NULL) { const DWORD __dwLastError = ::FusionpGetLastWin32Error(); ULONG __i; for (__i = 0; __i < NUMBER_OF(__validStatuses); __i++ ) if (__validStatuses[__i] == __dwLastError) { (_unlessHitFlag) = true; break; } if (i == NUMBER_OF(__validStatuses)) { TRACE_WIN32_FAILURE_ORIGINATION(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } } while (0)

#define IFW32ZERO_ORIGINATE_AND_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == 0) { TRACE_WIN32_FAILURE_ORIGINATION(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } while (0)
#define IFW32ZERO_EXIT(_x) do { FUSION_CLEAR_LAST_ERROR(); if ((_x) == 0) { TRACE_NULL(_x); FUSION_VERIFY_LAST_ERROR_SET(); goto Exit; } } while (0)

#define PARAMETER_CHECK(_e) do { if (!(_e)) { __t.SetLine(__LINE__); TRACE_PARAMETER_CHECK(_e); __t.MarkInvalidParameter(); goto Exit; } } while (0)
#define PARAMETER_CHECK_INTERNAL(_e) do { if (!(_e)) { __t.SetLine(__LINE__); TRACE_PARAMETER_CHECK_INTERNAL(_e); __t.MarkInvalidParameter(); goto Exit; } } while (0)

#define W32PARAMETER_CHECK_NTC(_e) do { if (!(_e)) { ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER); TRACE_PARAMETER_CHECK(_e); goto Exit; } } while (0)

#define IFINVALID_FLAGS_EXIT_WIN32(_f, _fValid)    PARAMETER_CHECK(((_f) & ~(_fValid)) == 0)

#define FN_SUCCESSFUL_EXIT() do { FUSION_CLEAR_LAST_ERROR(); __t.MarkSuccess(); goto Exit; } while (0)

/*
This is not exposed without doing more work wrt "FusionpDbgWouldPrintAtFilterLevel".
ULONG
FusionpvDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    va_list ap
    );
*/

ULONG
FusionpDbgPrintEx(
    ULONG Level,
    PCSTR Format,
    ...
    );

VOID
FusionpDbgPrintBlob(
    ULONG Level,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
    );

void
FusionpGetProcessImageFileName(
    PUNICODE_STRING ProcessImageFileName
    );

#endif // !defined(_FUSION_INC_DEBMACRO_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\cfusionpointeriterator.inl ===
/*-----------------------------------------------------------------------------
Microsoft Confidential
Copyright (c) Microsoft Corporation. All Rights Reserved.

Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.

Copyright (c) 1994
Hewlett-Packard Company

Permission to use, copy, modify, distribute and sell this
software and its documentation for any purpose is hereby
granted without fee, provided that the above copyright notice
appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation.
Hewlett-Packard Company makes no representations about the
suitability of this software for any purpose. It is provided
"as is" without express or implied warranty.

@doc external

@module CFusionPointerIterator

@owner a-Jayk, JayKrell
-----------------------------------------------------------------------------*/
#pragma once
#include "CFusionPointerIterator.h"

//namespace NVseeLibContainer
//{

/*
Name: CFusionPointerIterator::CFusionPointerIterator

@mfunc
This constructs the iterator, making it equivalent (at least its value,
not quite its interface) to the pointer passed in.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::CFusionPointerIterator
(
	Pointer p // @arg set the iterator to this initially.
) throw()
: m_current(p)
{
}

/*
Name: CFusionPointerIterator::CFusionPointerIterator

@mfunc
This copy constructs an iterator, but it is not necessarily
the "default" copy constructor. If the iterator is const, this
copy constructor constructs it from a non const iterator. The
reverse conversion (const to non const) is invalid and disallowed.

If the iterator is not const, this does end up being the usual
copy constructor.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::CFusionPointerIterator
(
	const CFusionPointerIterator
	<
		T,
		Distance,
		MutablePointer,
		MutableReference,
		MutablePointer,
		MutableReference
	>& x
) throw()
: m_current(x.PtBase())
{
}

/*
Name: CFusionPointerIterator::PtBase

@mfunc
This returns the value of the pointer underlying the iterator.
It is in std::_Ptrit, but should not be needed by clients,
but it used once internally.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Pointer
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::PtBase
(
) const throw()
{
	return (m_current);
}

/*
Name: CFusionPointerIterator::operator*

@mfunc
This dereferences the iterator, which is exactly like
dereferencing the underlying pointer.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Reference
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator*
(
) const throw()
{
	return (*m_current);
}

/*
Name: CFusionPointerIterator::operator->

@mfunc
This dereferences the underlying pointer, but in the way
that can be followed by the name of a member datum or
member function.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Pointer
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator->
(
) const throw()
{
	return (&**this);
}

/*
Name: CFusionPointerIterator::operator++

@mfunc
This increments the iterator, and returns the new value.
It is pre increment.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>&
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator++
(
) throw()
{
	++m_current;
	return (*this);
}

/*
Name: CFusionPointerIterator::operator++

@mfunc
This increments the iterator, and returns the old value.
It is post increment.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator++
(
	int
) throw()
{
	CFusionPointerIterator tmp = *this;
	++m_current;
	return (tmp);
}

/*
Name: CFusionPointerIterator::operator--

@mfunc
This decrements the iterator, and returns the new value.
It is pre decrement.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>&
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator--
(
) throw()
{
	--m_current;
	return (*this);
}

/*
Name: CFusionPointerIterator::operator--

@mfunc
This decrements the iterator, and returns the old value.
It is post decrement.

@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator--
(
	int
) throw()
{
	CFusionPointerIterator tmp = *this;
	--m_current;
	return (tmp);
}

/*
Name: CFusionPointerIterator::operator==

@mfunc
This compares an iterator for equality with an integer.
It is totally type unsafe and I don't know why std::_Ptrit
provides it. Maybe for comparison to NULL?..no, that doesn't
make sense, you should only compare iterators with other iterators,
including the return value of Container::end().

@owner a-Jayk, JayKrell
*/
/* FUTURE Why is this in xutility
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator==(int y) const
{
	return (m_current == reinterpret_cast<Pointer>(y));
}
*/

/*
Name: CFusionPointerIterator::operator==
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator==
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (m_current == y.m_current);
}

/*
Name: CFusionPointerIterator::operator!=
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator!=
(
	const CFusionPointerIterator& y
) const throw()
{
	return (!(*this == y));
}

/*
Name: CFusionPointerIterator::operator+=
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>&
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator+=
(
	Distance n // @arg
) throw()
{
	m_current += n;
	return (*this);
}

/*
Name: CFusionPointerIterator::operator+
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator+
(
	Distance n // @arg
) const throw()
{
	return (CFusionPointerIterator(m_current + n));
}

/*
Name: CFusionPointerIterator::operator-=
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>&
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator-=
(
	Distance n // @arg
) throw()
{
	m_current -= n;
	return (*this);
}

/*
Name: CFusionPointerIterator::operator-
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator-
(
	Distance n // @arg
) const throw()
{
	return (CFusionPointerIterator(m_current - n));
}

/*
Name: CFusionPointerIterator::operator[]
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Reference
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator[]
(
	Distance n // @arg
) const throw()
{
	return (*(*this + n));
}

/*
Name: CFusionPointerIterator::operator<
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator<
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (m_current < y.m_current);
}

/*
Name: CFusionPointerIterator::operator>
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator>
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (y < *this);
}

/*
Name: CFusionPointerIterator::operator<=
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator<=
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (!(y < *this));
}

/*
Name: CFusionPointerIterator::operator>=
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline bool
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator>=
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
	return (!(*this < y));
}

/*
Name: CFusionPointerIterator::operator-
@mfunc
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline Distance
CFusionPointerIterator<T,Distance,Pointer,Reference,MutablePointer,MutableReference>::operator-
(
	const CFusionPointerIterator& y // @arg
) const throw()
{
    // static_cast, say, __int64 down to int
	return static_cast<Distance>(m_current - y.m_current);
}

/*
Name: operator+
@func
@owner a-Jayk, JayKrell
*/
template<typename T, typename Distance, typename Pointer, typename Reference, typename MutablePointer, typename MutableReference>
inline CFusionPointerIterator<T, Distance, Pointer, Reference, MutablePointer, MutableReference>
operator+
(
	Distance n, // @arg
	const CFusionPointerIterator<T, Distance, Pointer, Reference, MutablePointer, MutableReference>& y // @arg
) throw()
{
	return (y + n);
}

//} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionalgorithm.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    FusionAlgorithm.h

Abstract:

    Stuff inspired by and copied from <algorithm>.
    See also NVseeLibAlgorithm.
        StdFind
        ReverseFind
        StdSwap

Author:

    Jay M. Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#pragma once

/*-----------------------------------------------------------------------------
code based on <algorithm>
-----------------------------------------------------------------------------*/

template<typename InputIterator, typename T>
inline InputIterator
StdFind(
    InputIterator begin,
    InputIterator end,
    const T&      valueToFind
    )
{
    for (; begin != end ; ++begin)
    {
	    if (*begin == valueToFind)
        {
            break;
        }
    }
    return begin;
}

/*-----------------------------------------------------------------------------
This is not in the STL in this form; it is there like so:

    std::vector<T> v;
    T valueToFind;
    i = std::find(v.rbegin(), v.rend(), valueToFind);
    if (i != v.rend())
        ..
where rbegin and rend are implemented via the
supplied "iterator adaptor" std::reverse_iterator<>:

	typedef std::reverse_iterator<const_iterator, value_type,
		const_reference, const_reference *, difference_type>
			const_reverse_iterator;

  	const_reverse_iterator rbegin() const
		{return const_reverse_iterator(end()); }
	const_reverse_iterator rend() const
		{return const_reverse_iterator(begin()); }

It is actually very elegant I believe, but I haven't used it, and we don't
have an equivalent to std::reverse_iterator.
-----------------------------------------------------------------------------*/
/* InputIterator isn't quite the right name here, since we use -- instead of ++. */
template<typename InputIterator, typename T>
inline InputIterator
ReverseFind(
    InputIterator begin,
    InputIterator end,
    const T&      valueToFind
    )
{
    for ( InputIterator scan = end ; scan != begin ; )
    {
	    if (*--scan == valueToFind)
        {
            return scan;
        }
    }
    return end;
}

/*-----------------------------------------------------------------------------
you should specialize this to memberwise swap, doing so
usually makes it impossible for Swap to fail; two CFusionStringBuffers
with the same heap can be swapped with no chance of failure
-----------------------------------------------------------------------------*/
template<typename T>
inline VOID
StdSwap(
    T& x,
    T& y
    )
{
    T temp = x;
    x = y;
    y = temp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionbuffer.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionbuffer.h

Abstract:

Author:

Revision History:

--*/
#if !defined(FUSION_INC_FUSIONBUFFER_H_INCLUDED_)
#define FUSION_INC_FUSIONBUFFER_H_INCLUDED_

#pragma once

#include <stdio.h>
#include <limits.h>
#include "arrayhelp.h"
#include "smartref.h"
#include "returnstrategy.h"
#include "fusionstring.h"
#include "fusiontrace.h"
#include "fusionchartraits.h"

// avoid circular reference to Util.h
BOOL FusionpIsPathSeparator(WCHAR ch);
BOOL FusionpIsDriveLetter(WCHAR ch);

//
//  This header file defines the Fusion character string buffer class.
//  The purpose of this class is to encapsulate common activities that
//  callers want to do with character string buffers and handle it in
//  a generic fashion.  A principle tenet of this class is that it is
//  not a string class, although one could consider building a string
//  class upon it.
//
//  The buffer maintains a certain amount of storage within the buffer
//  object itself, and if more storage is required, a buffer is
//  dynamically allocated from a heap.
//


//
//  Like the STL string class, we use a helper class called a "character
//  traits" class to provide the actual code to manipulate character string
//  buffers with a specific encoding.
//
//  All the members are inline static and with normal optimization turned
//  on, the C++ compiler generates code that fully meets expectations.
//

//
//  We provide two implementations: one for Unicode strings, and another
//  template class for MBCS strings.  The code page of the string is a
//  template parameter for the MBCS string, so without any extra storage
//  wasted per-instance, code can separately handle MBCS strings which
//  are expected to be in the thread-default windows code page (CP_THREAD_ACP),
//  process-default windows code page (CP_ACP) or even a particular code
//  page (e.g. CP_UTF8).
//


//
//  This template class uses a number of non-type template parameters to
//  control things like growth algorithms etc.  As a result there are
//  many comparisons of template parameters against well-known constant
//  values, for which the compiler generates warning C4127.  We'll turn that
//  warning off.
//

#pragma warning(disable:4127)
#pragma warning(disable:4284)

#if !defined(FUSION_DEFAULT_STRINGBUFFER_CHARS)
#define FUSION_DEFAULT_STRINGBUFFER_CHARS (MAX_PATH)
#endif

#if !defined(FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS)
#define FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS (8)
#endif

#if !defined(FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS)
#define FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS (64)
#endif

#if !defined(FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS)
#define FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS (128)
#endif

enum EIfNoExtension
{
    eAddIfNoExtension,
    eDoNothingIfNoExtension,
    eErrorIfNoExtension
};

enum ECaseConversionDirection
{
    eConvertToUpperCase,
    eConvertToLowerCase
};

enum EPreserveContents
{
    ePreserveBufferContents,
    eDoNotPreserveBufferContents
};

template <typename TCharTraits> class CGenericStringBufferAccessor;

template <typename TCharTraits> class CGenericBaseStringBuffer
{
    friend TCharTraits;
    friend CGenericStringBufferAccessor<TCharTraits>;

    //
    // These two are to induce build breaks on people doing sb1 = sb2
    //
    CGenericBaseStringBuffer& operator=(PCWSTR OtherString);
    CGenericBaseStringBuffer& operator=(CGenericBaseStringBuffer &rOtherString);

public:
    typedef typename TCharTraits::TChar TChar;
    typedef typename TCharTraits::TMutableString TMutableString;
    typedef typename TCharTraits::TConstantString TConstantString;
    typedef CGenericStringBufferAccessor<TCharTraits> TAccessor;

    inline static TChar NullCharacter() { return TCharTraits::NullCharacter(); }
    inline static bool IsNullCharacter(TChar ch) { return TCharTraits::IsNullCharacter(ch); }
    inline static TChar PreferredPathSeparator() { return TCharTraits::PreferredPathSeparator(); }
    inline static TConstantString PreferredPathSeparatorString() { return TCharTraits::PreferredPathSeparatorString(); }
    inline static TConstantString PathSeparators() { return TCharTraits::PathSeparators(); }
    inline static bool IsPathSeparator(TChar ch) { return TCharTraits::IsPathSeparator(ch); }
    inline static TConstantString DotString() { return TCharTraits::DotString(); }
    inline static SIZE_T DotStringCch() { return TCharTraits::DotStringCch(); }
    inline static TChar DotChar() { return TCharTraits::DotChar(); }

protected:
    // You may not instantiate an instance of this class directly; you need to provide a derived
    // class which adds allocation/deallocation particulars.

    CGenericBaseStringBuffer() : m_prgchBuffer(NULL), m_cchBuffer(0), m_cAttachedAccessors(0), m_cch(0)
    {
    }

    //
    //  Note that somewhat counter-intuitively, there is neither an assignment operator,
    //  copy constructor or constructor taking a TConstantString.  This is necessary
    //  because such a constructor would need to perform a dynamic allocation
    //  if the path passed in were longer than nInlineChars which could fail and
    //  since we do not throw exceptions, constructors may not fail.  Instead the caller
    //  must just perform the default construction and then use the Assign() member
    //  function, remembering of course to check its return status.
    //

    ~CGenericBaseStringBuffer()
    {
        ASSERT_NTC(m_cAttachedAccessors == 0);
    }

    inline void IntegrityCheck() const
    {
#if DBG
        ASSERT_NTC(m_cch < m_cchBuffer);
#endif // DBG
    }

    // Derived constructors should call this to get the initial buffer pointers set up.
    inline void InitializeInlineBuffer()
    {
        ASSERT_NTC(m_prgchBuffer == NULL);
        ASSERT_NTC(m_cchBuffer == 0);

        m_prgchBuffer = this->GetInlineBuffer();
        m_cchBuffer = this->GetInlineBufferCch();
    }

    VOID AttachAccessor(TAccessor *)
    {
        ::InterlockedIncrement(&m_cAttachedAccessors);
    }

    VOID DetachAccessor(TAccessor *)
    {
        ::InterlockedDecrement(&m_cAttachedAccessors);
    }

    virtual BOOL Win32AllocateBuffer(SIZE_T cch, TMutableString &rpsz) const = 0;
    virtual VOID DeallocateBuffer(TMutableString sz) const = 0;
    virtual TMutableString GetInlineBuffer() const = 0;
    virtual SIZE_T GetInlineBufferCch() const = 0;

public:

    BOOL Win32Assign(PCWSTR psz, SIZE_T cchIn)
    {
        FN_PROLOG_WIN32

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        this->IntegrityCheck();

        SIZE_T cchIncludingTrailingNull;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(psz, cchIn, cchIncludingTrailingNull));

        // Only force the buffer to be dynamically grown if the new contents do not
        // fit in the old buffer.
        if (cchIncludingTrailingNull > m_cchBuffer)
            IFW32FALSE_EXIT(this->Win32ResizeBufferPreserveContentsInternal(cchIncludingTrailingNull));

        IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(m_prgchBuffer, m_cchBuffer, psz, cchIn));

        ASSERT(cchIncludingTrailingNull <= m_cchBuffer);
        ASSERT((cchIncludingTrailingNull == 0) || this->IsNullCharacter(m_prgchBuffer[cchIncludingTrailingNull - 1]));

        // cch was the buffer size we needed (including the trailing null); we don't need the trailing
        // null any more...
        m_cch = cchIncludingTrailingNull - 1;

        FN_EPILOG
    }

    BOOL Win32Assign(PCSTR psz, SIZE_T cchIn)
    {
        FN_PROLOG_WIN32

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        this->IntegrityCheck();

        SIZE_T cchIncludingTrailingNull;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(psz, cchIn, cchIncludingTrailingNull));

        // Only force the buffer to be dynamically grown if the new contents do not
        // fit in the old buffer.
        if (cchIncludingTrailingNull > m_cchBuffer)
            IFW32FALSE_EXIT(this->Win32ResizeBufferPreserveContentsInternal(cchIncludingTrailingNull));

        IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(m_prgchBuffer, m_cchBuffer, psz, cchIn));

        ASSERT(cchIncludingTrailingNull <= m_cchBuffer);
        ASSERT((cchIncludingTrailingNull == 0) || this->IsNullCharacter(m_prgchBuffer[cchIncludingTrailingNull - 1]));

        // cch was the buffer size we needed (including the trailing null); we don't need the trailing
        // null any more...
        m_cch = cchIncludingTrailingNull - 1;

        FN_EPILOG
    }

    BOOL Win32Assign(const UNICODE_STRING* NtString)
    {
        return Win32Assign(NtString->Buffer, RTL_STRING_GET_LENGTH_CHARS(NtString));
    }

    BOOL Win32Assign(const ANSI_STRING* NtString)
    {
        return Win32Assign(NtString->Buffer, RTL_STRING_GET_LENGTH_CHARS(NtString));
    }

    BOOL Win32Append(const UNICODE_STRING* NtString)
        { return this->Win32Append(NtString->Buffer, RTL_STRING_GET_LENGTH_CHARS(NtString)); }

    BOOL Win32AppendPathElement(const UNICODE_STRING* NtString)
        { return this->Win32AppendPathElement(NtString->Buffer, RTL_STRING_GET_LENGTH_CHARS(NtString)); }

    BOOL Win32Assign(const CGenericBaseStringBuffer &r) { return this->Win32Assign(r, r.Cch()); }

    BOOL Win32AssignWVa(SIZE_T cStrings, va_list ap)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        TMutableString pszCursor;
        SIZE_T cchIncludingTrailingNull = 1; // leave space for trailing null...
        SIZE_T cchTemp = 0;
        SIZE_T i = 0;
        va_list ap2 = ap;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        for (i=0; i<cStrings; i++)
        {
            PCWSTR psz = va_arg(ap, PCWSTR);
            INT cchArg = va_arg(ap, INT);
            SIZE_T cchThis = (cchArg < 0) ? ((psz != NULL) ? ::wcslen(psz) : 0) : static_cast<SIZE_T>(cchArg);
            SIZE_T cchRequired;

            IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(psz, cchThis, cchRequired));

            ASSERT((cchRequired != 0) || (cchThis == 0));

            cchIncludingTrailingNull += (cchRequired - 1);
        }

        IFW32FALSE_EXIT(this->Win32ResizeBuffer(cchIncludingTrailingNull, eDoNotPreserveBufferContents));

        pszCursor = m_prgchBuffer;
        cchTemp = cchIncludingTrailingNull;

        for (i=0; i<cStrings; i++)
        {
            PCWSTR psz = va_arg(ap2, PCWSTR);
            INT cchArg = va_arg(ap2, INT);
            SIZE_T cchThis = (cchArg < 0) ? ((psz != NULL) ? ::wcslen(psz) : 0) : static_cast<SIZE_T>(cchArg);

            IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBufferAndAdvanceCursor(pszCursor, cchTemp, psz, cchThis));
        }

        *pszCursor++ = this->NullCharacter();

        ASSERT(cchTemp == 1);
        ASSERT(static_cast<SIZE_T>(pszCursor - m_prgchBuffer) == cchIncludingTrailingNull);

        m_cch = (cchIncludingTrailingNull - 1);

        FN_EPILOG
    }

    BOOL Win32AssignW(ULONG cStrings, ...)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        va_list ap;

        va_start(ap, cStrings);

        IFW32FALSE_EXIT(this->Win32AssignWVa(cStrings, ap));

        fSuccess = TRUE;
    Exit:
        va_end(ap);

        return fSuccess;
    }

    BOOL Win32AssignFill(TChar ch, SIZE_T cch)
    {
        FN_PROLOG_WIN32

        TMutableString Cursor;

        ASSERT(static_cast<SSIZE_T>(cch) >= 0);

        IFW32FALSE_EXIT(this->Win32ResizeBuffer(cch + 1, eDoNotPreserveBufferContents));
        Cursor = m_prgchBuffer;

        while (cch > 0)
        {
            *Cursor++ = ch;
            cch--;
        }

        *Cursor = NullCharacter();

        m_cch = (Cursor - m_prgchBuffer);

        FN_EPILOG
    }

    BOOL Win32Append(PCWSTR sz, SIZE_T cchIn)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        ASSERT_NTC(static_cast<SSIZE_T>(cchIn) >= 0);

        SIZE_T cchIncludingTrailingNull;             // note that cch will include space for a tailing null character

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        ASSERT_NTC(m_cAttachedAccessors == 0);

        if (!TCharTraits::Win32DetermineRequiredCharacters(sz, cchIn, cchIncludingTrailingNull))
            goto Exit;

        // Bypass all this junk if the string to append is empty.
        if (cchIncludingTrailingNull > 1)
        {
            if (!this->Win32ResizeBufferPreserveContentsInternal(m_cch + cchIncludingTrailingNull))
                goto Exit;

            if (!TCharTraits::Win32CopyIntoBuffer(&m_prgchBuffer[m_cch], m_cchBuffer - m_cch, sz, cchIn))
                goto Exit;

            m_cch += (cchIncludingTrailingNull - 1);
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32Append(PCSTR sz, SIZE_T cchIn)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        SIZE_T cchIncludingTrailingNull;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(sz, cchIn, cchIncludingTrailingNull));

        // Bypass all this junk if the string to append is empty.
        if (cchIncludingTrailingNull > 1)
        {
            IFW32FALSE_EXIT(this->Win32ResizeBufferPreserveContentsInternal(m_cch + cchIncludingTrailingNull));
            IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(&m_prgchBuffer[m_cch], m_cchBuffer - m_cch, sz, cchIn));
            m_cch += (cchIncludingTrailingNull - 1);

            this->IntegrityCheck();
        }

        FN_EPILOG
    }

    BOOL Win32Append(const CGenericBaseStringBuffer &r) { return this->Win32Append(r, r.Cch()); }
    BOOL Win32Append(WCHAR wch) { WCHAR rgwch[1] = { wch }; return this->Win32Append(rgwch, 1); }

    BOOL Win32AppendFill(TChar ch, SIZE_T cch)
    {
        FN_PROLOG_WIN32

        ASSERT(static_cast<SSIZE_T>(cch) >= 0);

        TMutableString Cursor;

        IFW32FALSE_EXIT(this->Win32ResizeBufferPreserveContentsInternal(m_cch + cch + 1));
        Cursor = m_prgchBuffer + m_cch;

        while (cch > 0)
        {
            *Cursor++ = ch;
            cch--;
        }

        *Cursor = NullCharacter();

        m_cch = Cursor - m_prgchBuffer;

        FN_EPILOG
    }

    BOOL Win32Prepend(const CGenericBaseStringBuffer& other ) { return this->Win32Prepend(other, other.Cch()); }

    BOOL Win32Prepend(TConstantString sz, SIZE_T cchIn)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        ASSERT(static_cast<SSIZE_T>(cchIn) >= 0);

        SIZE_T cchIncludingTrailingNull;             // note that cch will include space for a tailing null character

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        if ( m_cch == 0 )
        {
            IFW32FALSE_EXIT(this->Win32Assign(sz, cchIn));
        }
        else
        {
            //
            // Enlarge the buffer, move the current data to past where the new data will need
            // to go, copy in the new data, and place the trailing null.
            //
            TChar SavedChar = m_prgchBuffer[0];

            IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(sz, cchIn, cchIncludingTrailingNull));
            IFW32FALSE_EXIT(this->Win32ResizeBufferPreserveContentsInternal(m_cch + cchIncludingTrailingNull));

            // Move current buffer "up"
            MoveMemory(m_prgchBuffer + ( cchIncludingTrailingNull - 1), m_prgchBuffer, (m_cch + 1) * sizeof(TChar));

            // Copy from the source string into the buffer.
            IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(
                this->m_prgchBuffer,
                this->m_cchBuffer,
                sz,
                cchIn));

            m_prgchBuffer[cchIncludingTrailingNull - 1] = SavedChar;
            m_cch += cchIncludingTrailingNull - 1;
        }
        FN_EPILOG
    }

    BOOL Win32Prepend(TChar ch)
    {
        FN_PROLOG_WIN32

        IFW32FALSE_EXIT(this->Win32ResizeBufferPreserveContentsInternal(m_cch + 1 + 1));

        // move buffer ahead, including null
        MoveMemory(m_prgchBuffer + 1, m_prgchBuffer, (m_cch + 1) * sizeof(TChar));
        m_prgchBuffer[0] = ch;
        m_cch++;

        FN_EPILOG
    }

    operator TConstantString() const { this->IntegrityCheck(); return m_prgchBuffer; }

    inline VOID Clear(bool fFreeStorage = false)
    {
        FN_TRACE();

        this->IntegrityCheck();

        // You can't free the storage if there's an attached accessor
        ASSERT(!fFreeStorage || m_cAttachedAccessors == 0);

        if (fFreeStorage && (m_cAttachedAccessors == 0))
        {
            if (m_prgchBuffer != NULL)
            {
                const TMutableString pszInlineBuffer = this->GetInlineBuffer();

                if (m_prgchBuffer != pszInlineBuffer)
                {
                    this->DeallocateBuffer(m_prgchBuffer);
                    m_prgchBuffer = pszInlineBuffer;
                    m_cchBuffer = this->GetInlineBufferCch();
                }
            }
        }

        if (m_prgchBuffer != NULL)
            m_prgchBuffer[0] = this->NullCharacter();

        m_cch = 0;
    }


    BOOL Win32ConvertCase( ECaseConversionDirection direction )
    {
#if !FUSION_WIN
        return FALSE;
#else
        FN_PROLOG_WIN32

        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        TMutableString Cursor = m_prgchBuffer;

        for ( ULONG ul = 0; ul < this->Cch(); ul++ )
        {
            if ( direction == eConvertToUpperCase )
                *Cursor = RtlUpcaseUnicodeChar(*Cursor);
            else
                *Cursor = RtlDowncaseUnicodeChar(*Cursor);

            Cursor++;
        }

        FN_EPILOG
#endif
    }

    BOOL Win32Compare(TConstantString szCandidate, SIZE_T cchCandidate, StringComparisonResult &rscrOut, bool fCaseInsensitive) const
    {
        this->IntegrityCheck();
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        IFW32FALSE_EXIT(TCharTraits::Win32CompareStrings(rscrOut, m_prgchBuffer, m_cch, szCandidate, cchCandidate, fCaseInsensitive));
        FN_EPILOG
    }

    BOOL Win32Equals(TConstantString szCandidate, SIZE_T cchCandidate, bool &rfMatches, bool fCaseInsensitive) const
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        IFW32FALSE_EXIT(
            TCharTraits::Win32EqualStrings(
                rfMatches,
                m_prgchBuffer,
                m_cch,
                szCandidate,
                cchCandidate,
                fCaseInsensitive));
        FN_EPILOG
    }

    BOOL Win32Equals(const CGenericBaseStringBuffer &r, bool &rfMatches, bool fCaseInsensitive) const
    {
        return this->Win32Equals(r, r.Cch(), rfMatches, fCaseInsensitive);
    }

    SIZE_T GetBufferCch() const { this->IntegrityCheck(); return m_cchBuffer; }
    INT GetBufferCchAsINT() const { this->IntegrityCheck(); if (m_cchBuffer > INT_MAX) return INT_MAX; return static_cast<INT>(m_cchBuffer); }
    DWORD GetBufferCchAsDWORD() const { this->IntegrityCheck(); if (m_cchBuffer > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cchBuffer); }
    DWORD GetCchAsDWORD() const { this->IntegrityCheck(); if (m_cch > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cch); }
     INT  GetCchAsINT() const { this->IntegrityCheck(); if (m_cch >  INT_MAX) return  INT_MAX; return  static_cast<INT>(m_cch); }
    UINT GetCchAsUINT() const { this->IntegrityCheck(); if (m_cch > UINT_MAX) return UINT_MAX; return static_cast<UINT>(m_cch); }

    SIZE_T GetBufferCb() const { this->IntegrityCheck(); return m_cchBuffer * sizeof(TChar); }
    INT GetBufferCbAsINT() const { this->IntegrityCheck(); if ((m_cchBuffer * sizeof(TChar)) > INT_MAX) return INT_MAX; return static_cast<INT>(m_cchBuffer * sizeof(TChar)); }
    DWORD GetBufferCbAsDWORD() const { this->IntegrityCheck(); if ((m_cchBuffer * sizeof(TChar)) > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cchBuffer * sizeof(TChar)); }
    DWORD GetCbAsDWORD() const { this->IntegrityCheck(); if ((m_cch * sizeof(TChar)) > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cch * sizeof(TChar)); }
     INT  GetCbAsINT() const { this->IntegrityCheck(); if ((m_cch * sizeof(TChar)) >  INT_MAX) return  INT_MAX;  return static_cast<INT>(m_cch * sizeof(TChar)); }
    UINT GetCbAsUINT() const { this->IntegrityCheck(); if ((m_cch * sizeof(TChar)) > UINT_MAX) return UINT_MAX; return static_cast<UINT>(m_cch * sizeof(TChar)); }

    bool ContainsCharacter(WCHAR wch) const
    {
        this->IntegrityCheck();
        return TCharTraits::ContainsCharacter(m_prgchBuffer, m_cch, wch);
    }

    BOOL
    Win32ResizeBuffer(
        SIZE_T cch,
        EPreserveContents epc
        )
    {
        FN_PROLOG_WIN32

        this->IntegrityCheck();

        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);
        PARAMETER_CHECK((epc == ePreserveBufferContents) || (epc == eDoNotPreserveBufferContents));

        if (cch > m_cchBuffer)
        {
            TMutableString prgchBufferNew = NULL;

            IFW32FALSE_EXIT(this->Win32AllocateBuffer(cch, prgchBufferNew));

            if (epc == ePreserveBufferContents)
            {
                // We assume that the buffer is/was null-terminated.
                IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(prgchBufferNew, cch, m_prgchBuffer, m_cch));
            }
            else
            {
                m_prgchBuffer[0] = this->NullCharacter();
                m_cch = 0;
            }

            if ((m_prgchBuffer != NULL) && (m_prgchBuffer != this->GetInlineBuffer()))
                this->DeallocateBuffer(m_prgchBuffer);

            m_prgchBuffer = prgchBufferNew;
            m_cchBuffer = cch;
        }

        FN_EPILOG
    }

    BOOL Win32Format(TConstantString pszFormat, ...)
    {
        this->IntegrityCheck();

        va_list args;
        va_start(args, pszFormat);
        BOOL f = this->Win32FormatV(pszFormat, args);
        va_end(args);
        return f;
    }

    BOOL Win32FormatAppend(TConstantString pszFormat, ...)
    {
        this->IntegrityCheck();

        va_list args;
        va_start(args, pszFormat);
        BOOL f = Win32FormatAppendV(pszFormat, args);
        va_end(args);
        return f;
    }

    BOOL Win32FormatV(TConstantString pszFormat, va_list args)
    {
        BOOL fSuccess = FALSE;
        this->Clear();
        fSuccess = Win32FormatAppendV(pszFormat, args);
        return fSuccess;
    }

    BOOL Win32FormatAppendV(TConstantString pszFormat, va_list args)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        SIZE_T cchRequiredBufferSize = 0;
        INT i = 0;

        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        m_prgchBuffer[m_cchBuffer - 1] = this->NullCharacter();
        i = TCharTraits::FormatV(m_prgchBuffer + m_cch, m_cchBuffer - 1 - m_cch, pszFormat, args);
        ASSERT(m_prgchBuffer[m_cchBuffer - 1] == NullCharacter());
        fSuccess = (i >= 0);
        if ( fSuccess )
            m_cch += i;
        else
        {
            //
            // Sprintf doesn't touch last error. The fn tracer
            // will fail an assertion if we return false but FusionpGetLastWin32Error()==NOERROR
            //
            ORIGINATE_WIN32_FAILURE_AND_EXIT(snwprintf_MaybeBufferTooSmall, ERROR_INVALID_PARAMETER);
        }
    Exit:
        return fSuccess;
    }

    SIZE_T Cch() const
    {
        this->IntegrityCheck();
        return this->m_cch;
    }

    BOOL IsEmpty() const
    {
        this->IntegrityCheck();
        const BOOL fResult = (this->m_prgchBuffer[0] == this->NullCharacter());
#if DBG
        //
        // We should probably reverse how we compute the result in
        // retail vs. what we assert. That would be one pointer
        // deref instead of two in retail; not worth churn right now.
        //  - JayKrell, June 2002.
        //
        if (fResult)
        {
            ASSERT_NTC(this->m_cch == 0);
        }
#endif
        return fResult;
    }

    WCHAR GetLastCharUnsafe() const
    {
        ASSERT_NTC(!this->IsEmpty());
        return this->m_prgchBuffer[this->m_cch - 1];
    }

    BOOL Win32EnsureTrailingChar(WCHAR ch)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        if ((m_cch == 0) || (m_prgchBuffer[m_cch - 1] != ch))
        {
            IFW32FALSE_EXIT(this->Win32ResizeBufferPreserveContentsInternal(m_cch + 1 + 1));
            m_prgchBuffer[m_cch++] = ch;
            m_prgchBuffer[m_cch] = this->NullCharacter();
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32EnsureTrailingPathSeparator()
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        if ((m_cch == 0) || !TCharTraits::IsPathSeparator(m_prgchBuffer[m_cch - 1]))
        {
            IFW32FALSE_EXIT(this->Win32ResizeBufferPreserveContentsInternal(m_cch + 1 + 1));
            m_prgchBuffer[m_cch++] = this->PreferredPathSeparator();
            m_prgchBuffer[m_cch] = this->NullCharacter();
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32AppendPathElement(PCWSTR pathElement, SIZE_T cchPathElement)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(this->Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(this->Win32Append(pathElement, cchPathElement));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32AppendPathElement(const CGenericBaseStringBuffer &r) { return this->Win32AppendPathElement(r, r.Cch()); }

    BOOL Win32AppendPathElement(PCSTR pathElement, SIZE_T cchPathElement)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(this->Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(this->Win32Append(pathElement, cchPathElement));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Left(SIZE_T newLength)
    {
        this->IntegrityCheck();

        ASSERT_NTC(newLength <= m_cch);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        // Note also that while the current implementation does not change the buffer
        // pointer, this is just a shortcut in the implementation; if a call to Left()
        // were to make the string short enough to fit in the inline buffer, we should
        // copy it to the inline buffer and deallocate the dynamic one.
        ASSERT_NTC(m_cAttachedAccessors == 0);

        if (m_cchBuffer > newLength)
        {
            m_prgchBuffer[newLength] = this->NullCharacter();
        }

        m_cch = newLength;

        this->IntegrityCheck();

        return TRUE;
    }

    TConstantString Begin() const
    {
        this->IntegrityCheck();
        return m_prgchBuffer;
    }

    TConstantString End() const
    {
        this->IntegrityCheck();
        return &m_prgchBuffer[m_cch];
    }

    // should factor this for reuse in CchWithoutLastPathElement
    SIZE_T CchWithoutTrailingPathSeparators() const
    {
        this->IntegrityCheck();
        // Until GetLength is constant time, optimize its use..
        SIZE_T length = m_cch;
        if (length > 0)
        {
            length -= ::StringReverseSpan(&*m_prgchBuffer, &*m_prgchBuffer + length, TCharTraits::PathSeparators());
        }
        return length;
    }

    BOOL RestoreNextPathElement()
    {
        SIZE_T index;

        this->IntegrityCheck();

        index = m_cch;
        m_prgchBuffer[index++] = L'\\';    // replace trailing NULL with '\'

        while ((index < m_cchBuffer) && (!this->IsNullCharacter(m_prgchBuffer[index])))
        {
            if (::FusionpIsPathSeparator(m_prgchBuffer[index]))
            {
                this->Left(index);
                return TRUE;
            }

            index++;
        }

        return FALSE;
    }

    bool HasTrailingPathSeparator() const
    {
        FN_TRACE();

        this->IntegrityCheck();

        if ((m_cch != 0) && TCharTraits::IsPathSeparator(m_prgchBuffer[m_cch - 1]))
            return true;

        return false;
    }

    BOOL Win32RemoveTrailingPathSeparators()
    {
        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        // Note also that while the current implementation does not change the buffer
        // pointer, this is just a shortcut in the implementation; if a call to Left()
        // were to make the string short enough to fit in the inline buffer, we should
        // copy it to the inline buffer and deallocate the dynamic one.
        ASSERT_NTC(m_cAttachedAccessors == 0);

        while ((m_cch != 0) && TCharTraits::IsPathSeparator(m_prgchBuffer[m_cch - 1]))
            m_cch--;

        m_prgchBuffer[m_cch] = this->NullCharacter();

        this->IntegrityCheck();

        return TRUE;
    }

    BOOL Right( SIZE_T cchRightCount )
    {
        this->IntegrityCheck();

        ASSERT_NTC(m_cAttachedAccessors == 0);
        ASSERT_NTC(cchRightCount <= m_cch);

        if (cchRightCount < m_cch)
        {
            ::MoveMemory(
                m_prgchBuffer,
                &m_prgchBuffer[m_cch - cchRightCount],
                (cchRightCount + 1)*sizeof(TCharTraits::TChar));
            m_cch = cchRightCount;
        }
        this->IntegrityCheck();

        return TRUE;
    }

    BOOL RemoveLeadingPathSeparators()
    {
        this->IntegrityCheck();
        BOOL fSuccess = this->Right(m_cch - wcsspn(m_prgchBuffer, TCharTraits::PathSeparators()));
        this->IntegrityCheck();
        return fSuccess;
    }

    BOOL Win32StripToLastPathElement()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);
        this->IntegrityCheck();
        IFW32FALSE_EXIT(this->Right(m_cch - this->CchWithoutLastPathElement()));
        IFW32FALSE_EXIT(this->RemoveLeadingPathSeparators());
        fSuccess = TRUE;
    Exit:
        this->IntegrityCheck();
        return fSuccess;
    }

    BOOL Win32GetFirstPathElement( CGenericBaseStringBuffer &sbDestination, BOOL bRemoveAsWell = FALSE )
    {
        FN_PROLOG_WIN32

        this->IntegrityCheck();

        IFW32FALSE_EXIT( sbDestination.Win32Assign( m_prgchBuffer, this->CchOfFirstPathElement() ) );
        sbDestination.RemoveLeadingPathSeparators();

        if ( bRemoveAsWell )
            IFW32FALSE_EXIT(this->Win32RemoveFirstPathElement());

        this->IntegrityCheck();

        FN_EPILOG
    }

    BOOL Win32GetFirstPathElement( CGenericBaseStringBuffer &sbDestination ) const
    {
        BOOL bSuccess = FALSE;

        this->IntegrityCheck();

        if ( sbDestination.Win32Assign( m_prgchBuffer, CchOfFirstPathElement() ) )
        {
            sbDestination.RemoveLeadingPathSeparators();
            bSuccess = TRUE;
        }

        return bSuccess;
    }

    BOOL Win32StripToFirstPathElement()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);
        this->IntegrityCheck();

        IFW32FALSE_EXIT(this->Left(this->CchOfFirstPathElement()));
        IFW32FALSE_EXIT(this->RemoveLeadingPathSeparators());

        fSuccess = TRUE;
    Exit:
        this->IntegrityCheck();
        return fSuccess;
    }

    BOOL Win32RemoveFirstPathElement()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        this->IntegrityCheck();
        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(this->Right(this->CchWithoutFirstPathElement()));
        IFW32FALSE_EXIT(this->RemoveLeadingPathSeparators());
        fSuccess = TRUE;
    Exit:
        this->IntegrityCheck();
        return fSuccess;
    }

    SIZE_T CchOfFirstPathElement() const
    {
        return Cch() - CchWithoutFirstPathElement();
    }

    SIZE_T CchWithoutFirstPathElement() const
    {
        this->IntegrityCheck();

        SIZE_T cch = m_cch;

        //
        // We just look for the first path element, which can also be the drive
        // letter!
        //
        if ( cch != 0 )
        {
            cch -= wcscspn( m_prgchBuffer, PathSeparators() );
        }

        return cch;
    }

    BOOL Win32GetLastPathElement(CGenericBaseStringBuffer &sbDestination) const
    {
        BOOL bSuccess = FALSE;
        FN_TRACE_WIN32(bSuccess);
        this->IntegrityCheck();
        sbDestination.IntegrityCheck();
        IFW32FALSE_EXIT(sbDestination.Win32Assign(m_prgchBuffer, m_cch));
        IFW32FALSE_EXIT(sbDestination.Win32StripToLastPathElement());
        bSuccess = TRUE;
    Exit:
        this->IntegrityCheck();
        sbDestination.IntegrityCheck();
        return bSuccess;
    }

    SIZE_T CchWithoutLastPathElement() const
    {
        this->IntegrityCheck();

        // Paths are assumed to be
        // "\\machine\share"
        // or
        // "x:\"
        // Worry about alternate NTFS streams at a later date.
        // Worry about NT paths at a later date.
        // Worry about URLs at a later date.
        const SIZE_T length = m_cch;
        SIZE_T newLength = length;
        if (length > 0)
        {
            if ((length == 3) &&
                (m_prgchBuffer[1] == ':') &&
                ::FusionpIsPathSeparator(m_prgchBuffer[2]) &&
                ::FusionpIsDriveLetter(m_prgchBuffer[0]))
            {
                // c:\ => empty string
                newLength = 0;
            }
            else
            {
                // Remove trailing path seperators here, in the future when it is not risky.
                //newLength -= ::StringReverseSpan(&*m_prgchBuffer, &*m_prgchBuffer + newLength, PathSeparators());
                newLength -= ::StringReverseComplementSpan(&*m_prgchBuffer, &*m_prgchBuffer + newLength, PathSeparators());
                newLength -= ::StringReverseSpan(&*m_prgchBuffer, &*m_prgchBuffer + newLength, PathSeparators());
                if ((newLength == 2) && // "c:"
                    (length >= 4) && // "c:\d"
                    (m_prgchBuffer[1] == ':') &&
                    ::FusionpIsPathSeparator(m_prgchBuffer[2]) &&
                    ::FusionpIsDriveLetter(m_prgchBuffer[0]))
                {
                    ++newLength; // put back the slash in "c:\"
                }
            }
        }
        return newLength;
    }

    BOOL Win32RemoveLastPathElement()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32( fSuccess );

        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        // Note also that while the current implementation does not change the buffer
        // pointer, this is just a shortcut in the implementation; if a call to Left()
        // were to make the string short enough to fit in the inline buffer, we should
        // copy it to the inline buffer and deallocate the dynamic one.
        ASSERT_NTC(m_cAttachedAccessors == 0);

        IFW32FALSE_EXIT(this->Left(this->CchWithoutLastPathElement()));

        fSuccess = TRUE;
Exit:
        this->IntegrityCheck();
        return fSuccess;
    }

    BOOL Win32ClearPathExtension()
    {
        //
        // Replace the final '.' with a \0 to clear the path extension
        //
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32( fSuccess );

        this->IntegrityCheck();

        TMutableString dot = 0;

        const TMutableString end = End();

        IFW32FALSE_EXIT(TCharTraits::Win32ReverseFind(dot, m_prgchBuffer, m_cch, this->DotChar(), false));

        if((dot != end) && (dot != NULL))
        {
            *dot = this->NullCharacter();
            m_cch = (dot - m_prgchBuffer);
        }

        fSuccess = TRUE;
    Exit:
        this->IntegrityCheck();
        return fSuccess;
    }

    BOOL Win32GetPathExtension(CGenericBaseStringBuffer<TCharTraits> &destination) const
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        SIZE_T cchExtension;

        const TConstantString start = Begin();
        const TConstantString end = End();

        cchExtension = ::StringReverseComplementSpan( &(*start), &(*end), L"." );
        IFW32FALSE_EXIT(destination.Win32Assign( static_cast<PCWSTR>(*this) + ( m_cch - cchExtension ), cchExtension));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    // newExtension can start with a dot or not
    BOOL Win32ChangePathExtension(PCWSTR newExtension, SIZE_T cchExtension, EIfNoExtension e)
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        TMutableString end = 0;
        TMutableString dot = 0;

        INTERNAL_ERROR_CHECK(m_cAttachedAccessors == 0);

        PARAMETER_CHECK((e == eAddIfNoExtension) ||
                              (e == eDoNothingIfNoExtension) ||
                              (e == eErrorIfNoExtension));

        if ((cchExtension != 0) && (newExtension[0] == L'.'))
        {
            cchExtension--;
            newExtension++;
        }

        // the use of append when we know where the end of the string is inefficient
        end = this->End();

        IFW32FALSE_EXIT(TCharTraits::Win32ReverseFind(dot, m_prgchBuffer, m_cch, this->DotChar(), false));

        // Found the end of the string, or Win32ReverseFind didn't find the dot anywhere...
        if ((dot == end) || (dot == NULL))
        {
            switch (e)
            {
                case eAddIfNoExtension:
                    IFW32FALSE_EXIT(this->Win32Append(this->DotString(), 1));
                    IFW32FALSE_EXIT(this->Win32Append(newExtension, cchExtension));
                    break;

                case eDoNothingIfNoExtension:
                    break;

                case eErrorIfNoExtension:
					ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingExtension, ERROR_BAD_PATHNAME);
            }
        }
        else
        {
            ++dot;
            IFW32FALSE_EXIT(this->Left(dot - this->Begin()));
            IFW32FALSE_EXIT(this->Win32Append(newExtension, cchExtension));
        }

        fSuccess = TRUE;
    Exit:
        this->IntegrityCheck();
        return fSuccess;
    }

    BOOL Win32ChangePathExtension(const UNICODE_STRING* NtString, EIfNoExtension e)
    {
        return Win32ChangePathExtension(
            NtString->Buffer,
            RTL_STRING_GET_LENGTH_CHARS(NtString),
            e);
    }

    BOOL Win32CopyStringOut(LPWSTR sz, ULONG *pcch) const
    {
        FN_PROLOG_WIN32

        this->IntegrityCheck();

        SIZE_T cwchRequired = 0;

        PARAMETER_CHECK(pcch != NULL);

        IFW32FALSE_EXIT(TCharTraits::Win32DetermineRequiredCharacters(m_prgchBuffer, m_cch, cwchRequired));

        if ((*pcch) < cwchRequired)
        {
            *pcch = static_cast<DWORD>(cwchRequired);
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);
        }

        IFW32FALSE_EXIT(TCharTraits::Win32CopyIntoBuffer(sz, *pcch, m_prgchBuffer, m_cch));

        FN_EPILOG
    }

    //
    //  This function is rather special purpose in that several design choices are not
    //  implemented as parameters.  In particular, the pcbBytesWritten is assumed to
    //  accumulate a number (thus it's updated by adding the number of bytes written to
    //  it rather than just setting it to the count of bytes written).
    //
    //  It also writes 0 bytes into the buffer is the string is zero length; if the string
    //  is not zero length, it writes the string including a trailing null.
    //

    inline BOOL Win32CopyIntoBuffer(
        PWSTR *ppszCursor,
        SIZE_T *pcbBuffer,
        SIZE_T *pcbBytesWritten,
        PVOID pvBase,
        ULONG *pulOffset,
        ULONG *pulLength
        ) const
    {
        this->IntegrityCheck();

        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        PWSTR pszCursor = NULL;
        SSIZE_T dptr = 0;
        SIZE_T cbRequired = 0;
        SIZE_T cch = 0;

        if (pulOffset != NULL)
            *pulOffset = 0;

        if (pulLength != NULL)
            *pulLength = 0;

        PARAMETER_CHECK(pcbBuffer != NULL);
        PARAMETER_CHECK(ppszCursor != NULL);

        pszCursor = *ppszCursor;
        dptr = ((SSIZE_T) pszCursor) - ((SSIZE_T) pvBase);

        // If they're asking for an offset or length and the cursor is too far from the base,
        // fail.
        PARAMETER_CHECK((pulOffset == NULL) || (dptr <= ULONG_MAX));

        cch = m_cch;

        cbRequired = (cch != 0) ? ((cch + 1) * sizeof(WCHAR)) : 0;

        if ((*pcbBuffer) < cbRequired)
        {
            ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        if (cbRequired > ULONG_MAX)
        {
            ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        CopyMemory(pszCursor, static_cast<PCWSTR>(*this), cbRequired);

        if (pulOffset != NULL)
        {
            if (cbRequired != 0)
                *pulOffset = (ULONG) dptr;
        }

        if (pulLength != NULL)
        {
            if (cbRequired == 0)
                *pulLength = 0;
            else
            {
                *pulLength = (ULONG) (cbRequired - sizeof(WCHAR));
            }
        }

        *pcbBytesWritten += cbRequired;
        *pcbBuffer -= cbRequired;

        *ppszCursor = (PWSTR) (((ULONG_PTR) pszCursor) + cbRequired);

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

protected:
    BOOL
    __fastcall
    Win32ResizeBufferPreserveContentsInternal(
        SIZE_T cch
        )
    {
        // Note: this function is performance-sensitive, so we do not use the normal
        // tracing infrastucture here
        if (cch > m_cchBuffer)
        {
            TMutableString prgchBufferNew = NULL;

            if (!this->Win32AllocateBuffer(cch, prgchBufferNew))
                return FALSE;

            // We assume that the buffer is/was null-terminated.
            if (!TCharTraits::Win32CopyIntoBuffer(prgchBufferNew, cch, m_prgchBuffer, m_cch))
            {
                this->DeallocateBuffer(prgchBufferNew);
                return FALSE;
            }

            if ((m_prgchBuffer != NULL) && (m_prgchBuffer != this->GetInlineBuffer()))
                this->DeallocateBuffer(m_prgchBuffer);

            m_prgchBuffer = prgchBufferNew;
            m_cchBuffer = cch;
        }

        return TRUE;
    }

    TMutableString Begin()
    {
        this->IntegrityCheck();
        /* CopyBeforeWrite() */
        return m_prgchBuffer;
    }

    TMutableString End()
    {
        this->IntegrityCheck();
        return &m_prgchBuffer[m_cch];
    }

    LONG m_cAttachedAccessors;
    TChar *m_prgchBuffer;
    SIZE_T m_cchBuffer;
    SIZE_T m_cch; // current length of string
};

template <typename TCharTraits> class CGenericStringBufferAccessor
{
public:
    typedef CGenericBaseStringBuffer<TCharTraits> TBuffer;
    typedef typename CGenericBaseStringBuffer<TCharTraits>::TChar TChar;

    CGenericStringBufferAccessor(TBuffer* pBuffer = NULL)
    : m_pBuffer(NULL),
      m_pszBuffer(NULL),
      m_cchBuffer(NULL)
    {
        if (pBuffer != NULL)
        {
            Attach(pBuffer);
        }
    }

    ~CGenericStringBufferAccessor()
    {
        if (m_pBuffer != NULL)
        {
            m_pBuffer->m_cch = TCharTraits::NullTerminatedStringLength(m_pszBuffer);
            m_pBuffer->DetachAccessor(this);
            m_pBuffer = NULL;
            m_pszBuffer = NULL;
            m_cchBuffer = 0;
        }
    }

    bool IsAttached() const
    {
        return (m_pBuffer != NULL);
    }

    static TChar NullCharacter() { return TCharTraits::NullCharacter(); }

    void Attach(TBuffer *pBuffer)
    {
        FN_TRACE();

        // NTRAID#NTBUG9 - 586534 - 2002/03/26 - xiaoyuw
        // should be changed to be INTERNAL_ERROR_CHECK
        //
        ASSERT(!this->IsAttached());

        if (!this->IsAttached())
        {
            pBuffer->AttachAccessor(this);

            m_pBuffer = pBuffer;
            m_pszBuffer = m_pBuffer->m_prgchBuffer;
            m_cchBuffer = m_pBuffer->m_cchBuffer;
        }
    }

    void Detach()
    {
        FN_TRACE();

        // NTRAID#NTBUG9 - 586534 - 2002/03/26 - xiaoyuw
        // should be changed to be INTERNAL_ERROR_CHECK
        //
        ASSERT (IsAttached());

        if (IsAttached())
        {
            ASSERT(m_pszBuffer == m_pBuffer->m_prgchBuffer);

            m_pBuffer->m_cch = TCharTraits::NullTerminatedStringLength(m_pszBuffer);
            m_pBuffer->DetachAccessor(this);

            m_pBuffer = NULL;
            m_pszBuffer = NULL;
            m_cchBuffer = 0;
        }
        else
        {
            ASSERT(m_pszBuffer == NULL);
            ASSERT(m_cchBuffer == 0);
        }
    }

    operator typename TCharTraits::TMutableString() const { ASSERT_NTC(this->IsAttached()); return m_pszBuffer; }

    SIZE_T Cch() const { ASSERT_NTC(this->IsAttached()); return (m_pszBuffer != NULL) ? ::wcslen(m_pszBuffer) : 0; }

    typename TCharTraits::TMutableString GetBufferPtr() const { ASSERT_NTC(IsAttached()); return m_pszBuffer; }

    SIZE_T GetBufferCch() const { ASSERT_NTC(this->IsAttached()); return m_cchBuffer; }
    INT GetBufferCchAsINT() const { ASSERT_NTC(this->IsAttached()); if (m_cchBuffer > INT_MAX) return INT_MAX; return static_cast<INT>(m_cchBuffer); }
    UINT GetBufferCchAsUINT() const { ASSERT_NTC(this->IsAttached()); if (m_cchBuffer > UINT_MAX) return UINT_MAX; return static_cast<UINT>(m_cchBuffer); }
    DWORD GetBufferCchAsDWORD() const { ASSERT_NTC(this->IsAttached()); if (m_cchBuffer > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cchBuffer); }
    DWORD GetCchAsDWORD() const { ASSERT_NTC(this->IsAttached()); if (m_cch > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cch); }

    // NTRAID#NTBUG9 - 586534 - 2002/03/26 - xiaoyuw
    //  (1) overflow of the result of m_cchBuffer * sizeof(TChar)
    //  (2) calls GetXXXAsDWORD need to check whether the return value is DWORDMAX, if so, stop;
    SIZE_T GetBufferCb() const { ASSERT_NTC(this->IsAttached()); return m_cchBuffer * sizeof(*m_pszBuffer); }
    INT GetBufferCbAsINT() const { ASSERT_NTC(this->IsAttached()); if ((m_cchBuffer * sizeof(TChar)) > INT_MAX) return INT_MAX; return static_cast<INT>(m_cchBuffer * sizeof(TChar)); }
    DWORD GetBufferCbAsDWORD() const { ASSERT_NTC(this->IsAttached()); if ((m_cchBuffer * sizeof(TChar)) > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cchBuffer * sizeof(TChar)); }
    DWORD GetCbAsDWORD() const { ASSERT_NTC(this->IsAttached()); if ((m_cch * sizeof(TChar)) > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cch * sizeof(TChar)); }

protected:
    TBuffer *m_pBuffer;
    typename TCharTraits::TMutableString m_pszBuffer;
    SIZE_T m_cchBuffer;
};

template <SIZE_T nInlineChars, typename TCharTraits> class CGenericStringBuffer : public CGenericBaseStringBuffer<TCharTraits>
{
    typedef CGenericBaseStringBuffer<TCharTraits> Base;

protected:
    BOOL Win32AllocateBuffer(SIZE_T cch, TMutableString &rpsz) const
    {
        // You shouldn't be doing this if the required buffer size is small enough to be inline...
        ASSERT_NTC(cch > nInlineChars);

        rpsz = NULL;

        TCharTraits::TMutableString String = NULL;
        String = reinterpret_cast<TCharTraits::TMutableString>(::FusionpHeapAllocEx(
                                                                        FUSION_DEFAULT_PROCESS_HEAP(),
                                                                        0,
                                                                        cch * sizeof(TCharTraits::TChar),
                                                                        "<string buffer>",
                                                                        __FILE__,
                                                                        __LINE__,
                                                                        0));            // fusion heap allocation flags
        if (String == NULL)
        {
            ::FusionpSetLastWin32Error(FUSION_WIN32_ALLOCFAILED_ERROR);
            return FALSE;
        }

        rpsz = String;
        return TRUE;
    }

    VOID DeallocateBuffer(TMutableString sz) const
    {
        VERIFY_NTC(::FusionpHeapFree(FUSION_DEFAULT_PROCESS_HEAP(), 0, sz));
    }

    TMutableString GetInlineBuffer() const { return const_cast<TMutableString>(m_rgchInlineBuffer); }
    SIZE_T GetInlineBufferCch() const { return nInlineChars; }

    void Initialize() { m_rgchInlineBuffer[0] = this->NullCharacter(); Base::InitializeInlineBuffer(); }
    void Cleanup() { if (m_prgchBuffer != m_rgchInlineBuffer) { this->DeallocateBuffer(m_prgchBuffer); } m_prgchBuffer = NULL; m_cchBuffer = 0; }

public:
    void Reinitialize() { Cleanup(); Initialize(); }
    CGenericStringBuffer() { Initialize(); }
    ~CGenericStringBuffer() { Cleanup(); }

protected:
    TChar m_rgchInlineBuffer[nInlineChars];

private:
    CGenericStringBuffer(const CGenericStringBuffer &); // intentionally not implemented
    void operator =(const CGenericStringBuffer &); // intentionally not implemented
};

template <SIZE_T nInlineChars, typename TCharTraits> class CGenericHeapStringBuffer : public CGenericBaseStringBuffer<TCharTraits>
{
//    friend CGenericBaseStringBuffer<TCharTraits>;
    typedef CGenericBaseStringBuffer<TCharTraits> Base;

protected:
    BOOL Win32AllocateBuffer(SIZE_T cch, TMutableString &rpsz) const
    {
        // You shouldn't be doing this if the required buffer size is small enough to be inline...
        ASSERT_NTC(cch > nInlineChars);

        rpsz = NULL;

        TCharTraits::TMutableString String = NULL;
        String = reinterpret_cast<TCharTraits::TMutableString>(::FusionpHeapAllocEx(
                                                                        m_hHeap,
                                                                        dwDefaultWin32HeapAllocFlags,
                                                                        cch * sizeof(TCharTraits::TChar),
                                                                        "<string buffer>",
                                                                        __FILE__,
                                                                        __LINE__,
                                                                        0))             // fusion heap allocation flags
        if (String == NULL)
        {
            ::FusionpSetLastWin32Error(FUSION_WIN32_ALLOCFAILED_ERROR);
            return FALSE;
        }

        rpsz = String;
        return TRUE;
    }

    VOID DeallocateBuffer(TMutableString sz) const
    {
        VERIFY_NTC(::FusionpHeapFree(m_hHeap, dwDefaultWin32HeapFreeFlags, sz));
    }

    TMutableString GetInlineBuffer() const { return m_rgchInlineBuffer; }
    SIZE_T GetInlineBufferCch() const { return nInlineChars; }

public:
    CGenericHeapStringBuffer(HANDLE hHeap) : m_hHeap(hHeap) { m_rgchInlineBuffer[0] = this->NullCharacter(); Base::InitializeInlineBuffer(); }

    ~CGenericHeapStringBuffer() { ASSERT(m_cchBuffer == 0); ASSERT(m_prgchBuffer == NULL); }

protected:
    HANDLE m_hHeap;
    TChar m_rgchInlineBuffer[nInlineChars];
};

typedef CGenericStringBufferAccessor<CUnicodeCharTraits> CUnicodeStringBufferAccessor;

typedef CGenericBaseStringBuffer<CUnicodeCharTraits> CUnicodeBaseStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_STRINGBUFFER_CHARS, CUnicodeCharTraits> CUnicodeStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_STRINGBUFFER_CHARS, CUnicodeCharTraits> CUnicodeHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS, CUnicodeCharTraits> CTinyUnicodeStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS, CUnicodeCharTraits> CTinyUnicodeHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS, CUnicodeCharTraits> CSmallUnicodeStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS, CUnicodeCharTraits> CSmallUnicodeHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS, CUnicodeCharTraits> CMediumUnicodeStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS, CUnicodeCharTraits> CMediumUnicodeHeapStringBuffer;

typedef CGenericStringBufferAccessor<CANSICharTraits> CANSIStringBufferAccessor;

typedef CGenericBaseStringBuffer<CANSICharTraits> CANSIBaseStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_STRINGBUFFER_CHARS, CANSICharTraits> CANSIStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_STRINGBUFFER_CHARS, CANSICharTraits> CANSIHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS, CANSICharTraits> CTinyANSIStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_TINY_STRINGBUFFER_CHARS, CANSICharTraits> CTinyANSIHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS, CANSICharTraits> CSmallANSIStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_SMALL_STRINGBUFFER_CHARS, CANSICharTraits> CSmallANSIHeapStringBuffer;

typedef CGenericStringBuffer<FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS, CANSICharTraits> CMediumANSIStringBuffer;
typedef CGenericHeapStringBuffer<FUSION_DEFAULT_MEDIUM_STRINGBUFFER_CHARS, CANSICharTraits> CMediumANSIHeapStringBuffer;

typedef CUnicodeBaseStringBuffer CBaseStringBuffer;
typedef CUnicodeStringBuffer CStringBuffer;
typedef CUnicodeHeapStringBuffer CHeapStringBuffer;

typedef CUnicodeStringBufferAccessor CStringBufferAccessor;

typedef CTinyUnicodeStringBuffer CTinyStringBuffer;
typedef CTinyUnicodeHeapStringBuffer CTinyHeapStringBuffer;

typedef CSmallUnicodeStringBuffer CSmallStringBuffer;
typedef CSmallUnicodeHeapStringBuffer CSmallHeapStringBuffer;

typedef CMediumUnicodeStringBuffer CMediumStringBuffer;
typedef CMediumUnicodeHeapStringBuffer CMediumHeapStringBuffer;

template <typename T1, typename T2> inline HRESULT HashTableCompareKey(T1 t1, T2 *pt2, bool &rfMatch);

template <> inline HRESULT HashTableCompareKey(PCWSTR sz, CUnicodeStringBuffer *pbuff, bool &rfMatch)
{
    HRESULT hr = NOERROR;
    SIZE_T cchKey = (sz != NULL) ? ::wcslen(sz) : 0;

    rfMatch = false;

    if (!pbuff->Win32Equals(sz, cchKey, rfMatch, false))
    {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

template <> inline HRESULT HashTableCompareKey(PCSTR sz, CANSIStringBuffer *pbuff, bool &rfMatch)
{
    HRESULT hr = NOERROR;
    SIZE_T cchKey = ::strlen(sz);

    rfMatch = false;

    if (!pbuff->Win32Equals(sz, cchKey, rfMatch, false))
    {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

//
// Support for CFusionArrays of strings
//
template<>
inline BOOL
FusionWin32CopyContents<CStringBuffer>(
    CStringBuffer &rDestination,
    const CStringBuffer &rSource
    )
{
    return rDestination.Win32Assign(rSource);
}

inline BOOL
FusionWin32CopyContents(
    CStringBuffer &rDestination,
    const CBaseStringBuffer &rSource
    )
{
    return rDestination.Win32Assign(rSource);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusioncoinitialize.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusioncoinitialize.h

Abstract:

  exception safe contructor/destructor local for CoInitialize(Ex)/CoUninitialize

Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#if !defined(FUSION_INC_FUSION_COINITIALIZE_H_INCLUDED_)
#define FUSION_INC_FUSION_COINITIALIZE_H_INCLUDED_
#pragma once

namespace F
{
class CWin32CoInitialize
{
private:
	HRESULT m_hresult;

	static HRESULT STDMETHODCALLTYPE CoInitializeEx_DownlevelFallback(void * Reserved, DWORD dwCoInit)
	{
		return ::CoInitialize(NULL);
	}

public:

	CWin32CoInitialize();
	BOOL Win32Initialize(DWORD dwCoInit = COINIT_APARTMENTTHREADED);
	~CWin32CoInitialize();
};

class CThrCoInitialize : public CWin32CoInitialize
{
protected:
    void ThrInit();
public:
    CThrCoInitialize();
    ~CThrCoInitialize() { }
};
}

inline void F::CThrCoInitialize::ThrInit()
{
    FN_PROLOG_VOID_THROW
    IFW32FALSE_EXIT(this->Win32Initialize());
    FN_EPILOG_THROW
}

inline F::CThrCoInitialize::CThrCoInitialize()
{
    this->ThrInit();
}

inline F::CWin32CoInitialize::CWin32CoInitialize() : m_hresult(E_FAIL) { }
inline F::CWin32CoInitialize::~CWin32CoInitialize() { if (SUCCEEDED(m_hresult)) { m_hresult = E_FAIL; CoUninitialize(); } }

inline BOOL F::CWin32CoInitialize::Win32Initialize(DWORD dwCoInit)
{
	typedef HRESULT (STDMETHODCALLTYPE * PFN)(void * Reserved, DWORD dwCoInit);
	static PFN s_pfn;
	if (s_pfn == NULL)
	{
		PFN pfn = NULL;
        //
        // GetModuleHandle would be sufficient because we have static references to
        // CoInitialize and CoUninitialize, but in case delayload is used..
        //
		HMODULE Ole32 = ::LoadLibraryW(L"Ole32.dll");
		if (Ole32 != NULL)
			pfn = reinterpret_cast<PFN>(::GetProcAddress(Ole32, "CoInitializeEx"));
		if (pfn == NULL)
			pfn = &CoInitializeEx_DownlevelFallback;
		s_pfn = pfn;
	}
	return SUCCEEDED(m_hresult = (*s_pfn)(NULL, dwCoInit));
}

#endif // !defined(FUSION_INC_FUSION_COINITIALIZE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionarray.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionarray.h

Abstract:


Author:


Revision History:

--*/
#if !defined(FUSION_FUSIONARRAY_H_INCLUDED_)
#define FUSION_FUSIONARRAY_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
//  fusionarray.h
//
//  Fusion C++ array class.  Functionally similar to ever other array
//  class out there, but since we do not throw exceptions, instead this
//  implementation does not define all the funky operators and
//  instead defines member functions to access elements of the array
//  which may return HRESULTs.
//

#if !defined(FUSION_UNUSED)
#define FUSION_UNUSED(x) (x)
#endif

#include <arrayhelp.h>
#include "CFusionArrayTypedefs.h"

#ifndef  FUSION_ARRAY_DEFINED
#define FUSION_ARRAY_DEFINED
template <typename TStored, typename TPassed = TStored, bool fExponentialGrowth = false, int nDefaultSize = 0, int nGrowthParam = 1>
#else
template <typename TStored, typename TPassed, bool fExponentialGrowth, int nDefaultSize, int nGrowthParam>
#endif
class CFusionArray : public CFusionArrayTypedefs<TStored>
{
public:
    ConstIterator Begin() const
    {
        return m_prgtElements;
    }

    ConstIterator End() const
    {
        return m_prgtElements + this->GetSize();
    }

    Iterator Begin()
    {
        return m_prgtElements;
    }

    Iterator End()
    {
        return m_prgtElements + this->GetSize();
    }

    template <typename Integer>
    Reference operator[](Integer index)
    {
        return *(Begin() + index);
    }

    template <typename Integer>
    ConstReference operator[](Integer index) const
    {
        return *(Begin() + index);
    }

    CFusionArray() : m_prgtElements(NULL), m_cElements(0), m_iHighWaterMark(0) { C_ASSERT(nGrowthParam >= 1); }

    ~CFusionArray()
    {
        ::FusionFreeArray(m_cElements, m_prgtElements);
        m_prgtElements = NULL;
        m_cElements = 0;
        m_iHighWaterMark = 0;
    }

    BOOL Win32Initialize(SIZE_T nSize = nDefaultSize)
    {
        FN_PROLOG_WIN32

        INTERNAL_ERROR_CHECK(m_cElements == 0);

        if (nSize != 0)
        {
            IFW32FALSE_EXIT(::FusionWin32ResizeArray(m_prgtElements, m_cElements, nSize));
            m_cElements = nSize;
        }

        FN_EPILOG
    }

    BOOL Win32Access(SIZE_T iElement, TStored *&rptOut, bool fExtendIfNecessary = false)
    {
        FN_PROLOG_WIN32
        rptOut = NULL;

        PARAMETER_CHECK(fExtendIfNecessary || (iElement < m_cElements));

        if (iElement >= m_cElements)
            IFW32FALSE_EXIT(this->Win32InternalExpand(iElement));

        rptOut = &m_prgtElements[iElement];

        if (iElement >= m_iHighWaterMark)
            m_iHighWaterMark = iElement + 1;
        
        FN_EPILOG
    }

//    HRESULT GetSize(SIZE_T &rcElementsOut) const { rcElementsOut = m_cElements; return NOERROR; }
    SIZE_T GetSize() const { return m_cElements; }

    DWORD GetSizeAsDWORD() const { if (m_cElements > MAXDWORD) return MAXDWORD; return static_cast<DWORD>(m_cElements); }
    ULONG GetSizeAsULONG() const { if (m_cElements > ULONG_MAX) return ULONG_MAX; return static_cast<ULONG>(m_cElements); }

    //
    //  Enumeration used to control the behavior of CFusionArray::SetSize().
    //  if eSetSizeModeExact is passed, the internal array is set to exactly
    //  the cElements passed in; if eSetSizeModeApplyRounding is passed (the
    //  default), we apply the normal expansion/shrinking algorithm for the
    //  array.
    //
    enum SetSizeMode
    {
        eSetSizeModeExact = 0,
        eSetSizeModeApplyRounding = 1,
    };

    //
    //  Member function to manually set the size of the internal array stored
    //  by the CFusionArray.  Default behavior is to find an appropriate rounded
    //  size (based on the exponential vs. linear growth characteristic of the
    //  array) and resize to that.  Alternately, the caller may supply an
    //  exact size and the internal size is set to that.  Note that explicitly
    //  setting the array size may have interesting side-effects on future
    //  growth of the array; for example if an array is set to grow exponentially
    //  at a factor of 2^1 (nGrowthFactor == 1; doubling on each growth pass),
    //  its size will normally be a power of two. However, explicitly setting the
    //  size to, for example, 10 and then trying to access element 11 will cause
    //  the exponential growth factor to grow the array to 20 elements, rather than
    //  a power of two.
    //
    BOOL Win32SetSize(SIZE_T cElements, SetSizeMode ssm = eSetSizeModeApplyRounding)
    {
        FN_PROLOG_WIN32

        if (ssm == eSetSizeModeExact)
        {
            IFW32FALSE_EXIT(::FusionWin32ResizeArray(m_prgtElements, m_cElements, cElements));

            if (cElements < m_iHighWaterMark)
                m_iHighWaterMark = cElements;

            m_cElements = cElements;
        }
        else
        {
            if (cElements > m_cElements)
            {
                IFW32FALSE_EXIT(this->Win32InternalExpand(cElements - 1));
            }
            else
            {
                // For now, since it's inexact, we'll punt non-exact shrinking.
            }
        }

        FN_EPILOG
    }

    const TStored *GetArrayPtr() const { return m_prgtElements; }
    TStored *GetArrayPtr() { return m_prgtElements; }

    //
    //  Member function to reset the array to its size and storage associated with
    //  its initial construction.
    //

    enum ResetMode {
        eResetModeZeroSize = 0,
        eResetModeDefaultSize = 1,
    };

    BOOL Win32Reset(ResetMode rm = eResetModeDefaultSize)
    {
        FN_PROLOG_WIN32

        if (rm == eResetModeDefaultSize)
        {
            if (m_cElements != nDefaultSize)
            {
                IFW32FALSE_EXIT(::FusionWin32ResizeArray(m_prgtElements, m_cElements, nDefaultSize));
                m_cElements = nDefaultSize;
            }
            
            if (m_iHighWaterMark > nDefaultSize)
                m_iHighWaterMark = nDefaultSize;
        }
        else if (rm == eResetModeZeroSize)
        {
            ::FusionFreeArray(m_cElements, m_prgtElements);
            m_prgtElements = NULL;
            m_cElements = m_iHighWaterMark = 0;
        }
        
        FN_EPILOG
    }

    enum AppendMode {
        eAppendModeExtendArray = 0,
        eAppendModeNoExtendArray = 1,
    };

    BOOL Win32Append(const TPassed& tNew, AppendMode am = eAppendModeExtendArray)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        INTERNAL_ERROR_CHECK(m_iHighWaterMark <= m_cElements);

        PARAMETER_CHECK((am != eAppendModeNoExtendArray) || (m_iHighWaterMark < m_cElements));

        if (m_iHighWaterMark >= m_cElements)
        {
            SIZE_T cElementsOld = m_cElements;
            IFW32FALSE_EXIT(this->Win32InternalExpand(m_cElements));
            m_iHighWaterMark = cElementsOld;
        }

        // Clients of this class should provide explicit overrides for FusionCopyContents()
        // for their types as appropriate.
        IFW32FALSE_EXIT(::FusionWin32CopyContents(m_prgtElements[m_iHighWaterMark++], tNew));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Win32Remove(SIZE_T i)
    {
        FN_PROLOG_WIN32

        SIZE_T j;

        INTERNAL_ERROR_CHECK(m_iHighWaterMark <= m_cElements);

        PARAMETER_CHECK(i < m_cElements);

        for (j = (i + 1); j < m_cElements; j++)
            IFW32FALSE_EXIT(::FusionWin32CopyContents(m_prgtElements[j-1], m_prgtElements[j]));

        m_cElements--;
        m_iHighWaterMark--;

        FN_EPILOG
    }

    // 03/14/2001 - Added constness
    BOOL Win32Assign(SIZE_T celt, const TPassed *prgtelt)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        SIZE_T i;

        // So that we can fail gracefully, we need to copy our state off, attempt
        // the population of the array and then revert if necessary.
        TStored *prgtElementsSaved = m_prgtElements;
        SIZE_T cElementsSaved = m_cElements;
        SIZE_T iHighWaterMarkSaved = m_iHighWaterMark;

        PARAMETER_CHECK((celt == 0) || (prgtelt != NULL));

        m_prgtElements = NULL;
        m_cElements = 0;
        m_iHighWaterMark = 0;

        IFW32FALSE_EXIT(this->Win32Initialize(celt));

        for (i=0; i<celt; i++)
        {
            IFW32FALSE_EXIT(::FusionWin32CopyContents(m_prgtElements[i], prgtelt[i]));
        }

        m_iHighWaterMark = celt;

        // We can drop the old contents...
        ::FusionFreeArray(cElementsSaved, prgtElementsSaved);
        cElementsSaved = 0;
        prgtElementsSaved = NULL;

        fSuccess = TRUE;

    Exit:
        if (!fSuccess)
        {
            // Revert to previous state...
            ::FusionFreeArray(m_cElements, m_prgtElements);
            m_prgtElements = prgtElementsSaved;
            m_cElements = cElementsSaved;
            m_iHighWaterMark = iHighWaterMarkSaved;
        }

        return fSuccess;
    }

    // Xiaoyu 01/24/00 : copy this to prgDest
    //
    // jonwis 20-Sept-2000 : Update to be a little cleaner and 'const'
    //
    BOOL Win32Clone(CFusionArray<TStored, TPassed> &prgDest) const
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        SIZE_T i;

        //
        // Cloning an empty array shouldn't break things.
        //
        if (m_prgtElements == NULL)
        {
            IFW32FALSE_EXIT(prgDest.Win32Reset(eResetModeZeroSize));
        }
        else
        {

            //
            // Resize the destiny array to what it should be
            //
            if (prgDest.m_cElements != m_cElements)
                IFW32FALSE_EXIT(::FusionWin32ResizeArray(prgDest.m_prgtElements, prgDest.m_cElements, m_cElements));

            //
            // Copy the elements from point A to point B
            //
            for (i = 0; i < m_cElements; i++)
            {
                IFW32FALSE_EXIT(::FusionWin32CopyContents(prgDest.m_prgtElements[i], m_prgtElements[i]));
            }

            prgDest.m_cElements = m_cElements;
            prgDest.m_iHighWaterMark = m_iHighWaterMark;
        }
        
        fSuccess = TRUE;

    Exit:
        if (!fSuccess)
        {
            prgDest.Win32Reset(eResetModeZeroSize);
        }

        return fSuccess;
    }

protected:

    BOOL Win32InternalExpand(SIZE_T iElement)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        SIZE_T nNewElements = 0;

        if (fExponentialGrowth)
        {
            if (m_cElements == 0)
            {
                if (nDefaultSize == 0)
                    nNewElements = (1 << nGrowthParam);
                else
                    nNewElements = nDefaultSize;
            }
            else
            {
                nNewElements = m_cElements * (1 << nGrowthParam);
            }

            while ((nNewElements != 0) && (nNewElements <= iElement))
                nNewElements = nNewElements << nGrowthParam;

            // Ok, it's possible that nGrowthParam was something crazy like 10
            // (meaning to grow the array by a factor of 2^10 each time), so we
            // never really found a size that was appropriate.  We'll be slightly
            // less crazy and find the power-of-two that's big enough.  We still
            // have a possibility here that the user is asking for an index between
            // 2^31 and ((2^32)-1), which of course will fail because we can't
            // allocate that much storage.

            if (nNewElements == 0)
            {
                nNewElements = 1;

                while ((nNewElements != 0) && (nNewElements <= iElement))
                    nNewElements = nNewElements << 1;
            }
        }
        else
        {
            // In the linear growth case, we can use simple division to do all the
            // work done above for exponential growth.

            nNewElements = iElement + nGrowthParam - 1;

            if (nGrowthParam > 1)
                nNewElements = nNewElements - (nNewElements % nGrowthParam);

            // We'll handle overflow in the generic checking below...
        }

        // fallback; we'll try to make it just big enough.  It's true we lose the
        // growth pattern etc. that the caller requested, but it's pretty clear that
        // the caller messed up by either specifying a wacky nGrowthParam or there's
        // an outlandishly large iElement coming in.
        if (nNewElements <= iElement)
            nNewElements = iElement + 1;

        IFW32FALSE_EXIT(::FusionWin32ResizeArray(m_prgtElements, m_cElements, nNewElements));

        m_cElements = nNewElements;

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    TStored *m_prgtElements;
    SIZE_T m_cElements;
    SIZE_T m_iHighWaterMark;
};


#endif // !defined(FUSION_FUSIONARRAY_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionbytebuffer.h ===
#if !defined(_FUSION_INC_FUSIONBYTEBUFFER_H_INCLUDED_)
#define _FUSION_INC_FUSIONBYTEBUFFER_H_INCLUDED_

#pragma once

typedef const BYTE *LPCBYTE;
typedef const BYTE *PCBYTE;

class CGenericByteBufferDefaultAllocator
{
public:
    static inline BYTE *Allocate(SIZE_T cb) { return FUSION_NEW_ARRAY(BYTE, cb); }
    static inline VOID Deallocate(LPBYTE prgb) { FUSION_DELETE_ARRAY(prgb); }
};

template<SIZE_T nInlineBytes = MAX_PATH, class TAllocator = CGenericByteBufferDefaultAllocator> class CGenericByteBuffer
{
public:
    CGenericByteBuffer() : m_prgbBuffer(m_rgbInlineBuffer), m_cbBuffer(nInlineBytes), m_cb(0) { }

    //
    //  Note that somewhat counter-intuitively, there is neither an assignment operator,
    //  copy constructor or constructor taking a TConstantString.  This is necessary
    //  because such a constructor would need to perform a dynamic allocation
    //  if the path passed in were longer than nInlineBytes which could fail and
    //  since we do not throw exceptions, constructors may not fail.  Instead the caller
    //  must just perform the default construction and then use the Assign() member
    //  function, remembering of course to check its return status.
    //

    ~CGenericByteBuffer()
    {
        if (m_prgbBuffer != m_rgbInlineBuffer)
        {
            TAllocator::Deallocate(m_prgbBuffer);
            m_prgbBuffer = NULL;
        }
    }

    HRESULT Append(LPCBYTE prgb, SIZE_T cb)
    {
        HRESULT hr = NOERROR;

        if ((cb + m_cb) > m_cbBuffer)
        {
            hr = this->ResizeBuffer(cb + m_cb, true);
            if (FAILED(hr))
                goto Exit;
        }

        CopyMemory(&m_prgbBuffer[m_cb], prgb, cb);
        m_cb += cb;

        hr = NOERROR;

    Exit:
        return hr;
    }

    operator LPCBYTE() const { return m_prgbBuffer; }

    VOID Clear(bool fFreeStorage = false)
    {
        if (fFreeStorage)
        {
            if (m_prgbBuffer != NULL)
            {
                if (m_prgbBuffer != m_rgbInlineBuffer)
                {
                    TAllocator::Deallocate(m_prgbBuffer);
                    m_prgbBuffer = m_rgbInlineBuffer;
                    m_cbBuffer = nInlineBytes;
                }
            }
        }

        m_cb = 0;
    }

    SIZE_T GetCurrentCb() const { return m_cb; }

    HRESULT ResizeBuffer(SIZE_T cb, bool fPreserveContents = false)
    {
        HRESULT hr = NOERROR;

        if (cb > m_cbBuffer)
        {
            LPBYTE prgbBufferNew = TAllocator::Allocate(cb);
            if (prgbBufferNew == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            if (fPreserveContents)
            {
                CopyMemory(prgbBufferNew, m_prgbBuffer, m_cb);
            }
            else
            {
                m_cb = 0;
            }

            if (m_prgbBuffer != m_rgbInlineBuffer)
            {
                TAllocator::Deallocate(m_prgbBuffer);
            }

            m_prgbBuffer = prgbBufferNew;
            m_cbBuffer = cb;
        }
        else if ((m_prgbBuffer != m_rgbInlineBuffer) && (cb <= nInlineBytes))
        {
            // The buffer is small enough to fit into the inline buffer, so get rid of
            // the dynamically allocated one.

            if (fPreserveContents)
            {
                CopyMemory(m_rgbInlineBuffer, m_prgbBuffer, nInlineBytes);
                m_cb = nInlineBytes;
            }
            else
            {
                m_cb = 0;
            }

            TAllocator::Deallocate(m_prgbBuffer);
            m_prgbBuffer = m_rgbInlineBuffer;
            m_cbBuffer = nInlineBytes;
        }

        hr = NOERROR;

    Exit:
        return hr;
    }

private:
    BYTE m_rgbInlineBuffer[nInlineBytes];
    LPBYTE m_prgbBuffer;
    SIZE_T m_cbBuffer;
    SIZE_T m_cb;
};

// 128 is just an arbitrary size.
typedef CGenericByteBuffer<128> CByteBuffer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionchartraits.h ===
#if !defined(_FUSION_INC_FUSIONCHARTRAITS_H_INCLUDED_)
#define _FUSION_INC_FUSIONCHARTRAITS_H_INCLUDED_

#pragma once

#include <stdio.h>
#include <limits.h>
#include "returnstrategy.h"
#include "fusionhashstring.h"
#include "fusionstring.h"

enum StringComparisonResult {
    eLessThan,
    eEquals,
    eGreaterThan
};

//
// This is not the base of all possible CharTraits, but it is the base of the ones
// we have so far. There are pieces of this you can imagine changing.
//   StringLength could be strlen/wcslen (msvcrt/Rtl/ntoskrnl)
//   CompareStrings could be stricmp/wcsicmp or like unilib and do all the work itself
//   WideCharToMultiByte / MultiByteToWideChar could use Rtl.
//   more
//
template <typename Char, typename OtherChar>
class CCharTraitsBase
{
    typedef CCharTraitsBase<Char, OtherChar> TThis;

public:
    typedef Char TChar;
    typedef Char* TMutableString;
    typedef const Char* TConstantString;

    // MFC 7.0 templatized CString makes some good use of this idea; we do not yet.
    typedef OtherChar TOtherChar;
    typedef OtherChar* TOtherString;
    typedef const OtherChar* TOtherConstantString;

    inline static TChar NullCharacter() { return 0; }
    inline static bool IsNullCharacter(TChar ch)
        { return ch == NullCharacter(); }

    inline static TConstantString PreferredPathSeparatorString()
    {
        const static TChar Result[] = { '\\', 0 };
        return Result;
    }

    inline static TChar PreferredPathSeparator()
        { return '\\'; }
    inline static bool IsPathSeparator(TChar ch)
        { return ((ch == '\\') || (ch == '/')); }
    inline static TConstantString PathSeparators()
    {
        const static TChar Result[] = { '\\', '/', 0 };
        return Result;
    }

    inline static TChar DotChar()
        { return '.'; }

    // copy into buffer from TChar to TChar
    template <typename ReturnStrategy>
    inline static typename ReturnStrategy::ReturnType
    CopyIntoBuffer(
        ReturnStrategy &returnStrategy,
        TChar rgchBuffer[],
        SIZE_T cchBuffer,
        TConstantString szString,
        SIZE_T cchIn
        )
    {
        if (cchBuffer != 0)
        {
            if (szString != NULL)
            {
                SIZE_T cchToCopy = cchIn;

                // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Silent truncation.
                if (cchToCopy >= cchBuffer)
                    cchToCopy = cchBuffer - 1;

                CopyMemory(rgchBuffer, szString, cchToCopy * sizeof(TChar));
                rgchBuffer[cchToCopy] = NullCharacter();
            }
            else
                rgchBuffer[0] = NullCharacter();
        }
        returnStrategy.SetWin32Bool(TRUE);
        return returnStrategy.Return();
    }

    // copy into buffer from TChar to TChar
    inline static HRESULT CopyIntoBuffer(TChar rgchBuffer[], SIZE_T cchBuffer, TConstantString szString, SIZE_T cchIn)
    {
        CReturnStrategyHresult hr;
        return TThis::CopyIntoBuffer(hr, rgchBuffer, cchBuffer, szString, cchIn);
    }

    // copy into buffer from TChar to TChar
    inline static BOOL Win32CopyIntoBuffer(TChar rgchBuffer[], SIZE_T cchBuffer, TConstantString szString, SIZE_T cchIn)
    {
        CReturnStrategyBoolLastError f;
        return TThis::CopyIntoBuffer(f, rgchBuffer, cchBuffer, szString, cchIn);
    }


    // copy into buffer from TChar to TChar
    template <typename ReturnStrategy>
    inline static typename ReturnStrategy::ReturnType
    CopyIntoBufferAndAdvanceCursor(
        ReturnStrategy &returnStrategy,
        TMutableString &rBuffer,
        SIZE_T &cchBuffer,
        TConstantString szString,
        SIZE_T cchIn
        )
    {
        // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Should be parameter checks
        ASSERT_NTC((cchBuffer != 0) || (cchIn == 0));
        ASSERT_NTC((szString != NULL) || (cchIn == 0));

        if (cchBuffer != 0)
        {
            if (szString != NULL)
            {
                SIZE_T cchToCopy = static_cast<SIZE_T>(cchIn);

                // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Should be internal error checks
                // Someone should have stopped this before we got this far.
                ASSERT_NTC(cchToCopy <= cchBuffer);
                // You should not include the null character in the count in
                ASSERT_NTC((cchToCopy == NULL) || (szString[cchToCopy-1] != NullCharacter()));

                if (cchToCopy > cchBuffer)
                    cchToCopy = cchBuffer;

                CopyMemory(rBuffer, szString, cchToCopy * sizeof(TChar));

                rBuffer += cchToCopy;
                cchBuffer -= cchToCopy;
            }
        }
        returnStrategy.SetWin32Bool(TRUE);
        return returnStrategy.Return();
    }

    inline static BOOL Win32HashString(TConstantString szString, SIZE_T cchIn, ULONG &rulPseudoKey, bool fCaseInsensitive)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        IFW32FALSE_EXIT(::FusionpHashUnicodeString(szString, cchIn, &rulPseudoKey, fCaseInsensitive));
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    // copy into buffer from TChar to TChar
    inline static BOOL Win32CopyIntoBufferAndAdvanceCursor(TMutableString &rBuffer, SIZE_T &cchBuffer, TConstantString szString, SIZE_T cchIn)
    {
        CReturnStrategyBoolLastError f;
        return TThis::CopyIntoBufferAndAdvanceCursor(f, rBuffer, cchBuffer, szString, cchIn);
    }

    // copy into buffer from TChar to TChar
    inline static HRESULT ComCopyIntoBufferAndAdvanceCursor(TMutableString &rBuffer, SIZE_T &cchBuffer, TConstantString szString, SIZE_T cchIn)
    {
        CReturnStrategyHresult hr;
        return TThis::CopyIntoBufferAndAdvanceCursor(hr, rBuffer, cchBuffer, szString, cchIn);
    }

    // determine characters required for matching type (TChar)
    // like strlen but checks for null and optionally can be told the length
    template <typename ReturnStrategy>
    inline static typename ReturnStrategy::ReturnType
    DetermineRequiredCharacters(
        ReturnStrategy &returnStrategy,
        TConstantString /* sz */,
        SIZE_T         cchIn,
        SIZE_T          &rcch
        )
    {
        rcch = cchIn + 1;
        returnStrategy.SetWin32Bool(TRUE);
        return returnStrategy.Return();
    }

    // determine characters required for matching type (TChar)
    inline static HRESULT DetermineRequiredCharacters(TConstantString sz, SIZE_T cchIn, SIZE_T &rcch)
    {
        CReturnStrategyHresult returnStrategy;
        return TThis::DetermineRequiredCharacters(returnStrategy, sz, cchIn, rcch);
    }

    // determine characters required for matching type (TChar)
    inline static BOOL Win32DetermineRequiredCharacters(TConstantString sz, SIZE_T cchIn, SIZE_T &rcch)
    {
        CReturnStrategyBoolLastError returnStrategy;
        return TThis::DetermineRequiredCharacters(returnStrategy, sz, cchIn, rcch);
    }

    inline static BOOL Win32EqualStrings(bool &rfMatches, PCWSTR psz1, SIZE_T cch1, PCWSTR psz2, SIZE_T cch2, bool fCaseInsensitive)
    {
        rfMatches = (::FusionpCompareStrings(psz1, cch1, psz2, cch2, fCaseInsensitive) == 0);
        return TRUE;
    }

    inline static BOOL Win32EqualStrings(bool &rfMatches, PCSTR psz1, SIZE_T cch1, PCSTR psz2, SIZE_T cch2, bool fCaseInsensitive)
    {
        rfMatches = (::FusionpCompareStrings(psz1, cch1, psz2, cch2, fCaseInsensitive) == 0);
        return TRUE;
    }

    inline static BOOL Win32CompareStrings(StringComparisonResult &rscr, PCWSTR psz1, SIZE_T cch1, PCWSTR psz2, SIZE_T cch2, bool fCaseInsensitive)
    {
        int i = ::FusionpCompareStrings(psz1, cch1, psz2, cch2, fCaseInsensitive);

        if (i == 0)
            rscr = eEquals;
        else if (i < 0)
            rscr = eLessThan;
        else
            rscr = eGreaterThan;

        return TRUE;
    }

    inline static BOOL Win32CompareStrings(StringComparisonResult &rscr, PCSTR psz1, SIZE_T cch1, PCSTR psz2, SIZE_T cch2, bool fCaseInsensitive)
    {
        int i = ::FusionpCompareStrings(psz1, cch1, psz2, cch2, fCaseInsensitive);

        if (i == 0)
            rscr = eEquals;
        else if (i < 0)
            rscr = eLessThan;
        else
            rscr = eGreaterThan;

        return TRUE;
    }

    inline static int CompareStrings(LCID lcid, DWORD dwCmpFlags, PCWSTR psz1, int cch1, PCWSTR psz2, int cch2)
    {
        return ::CompareStringW(lcid, dwCmpFlags, psz1, cch1, psz2, cch2);
    }

    inline static int CompareStrings(LCID lcid, DWORD dwCmpFlags, PCSTR psz1, int cch1, PCSTR psz2, int cch2)
    {
        return ::CompareStringA(lcid, dwCmpFlags, psz1, cch1, psz2, cch2);
    }

    inline static int FormatV(PSTR pszBuffer, SIZE_T nBufferSize, PCSTR pszFormat, va_list args)
    {
        return ::_vsnprintf(pszBuffer, nBufferSize, pszFormat, args);
    }

    inline static int FormatV(PWSTR pszBuffer, SIZE_T nBufferSize, PCWSTR pszFormat, va_list args)
    {
        return ::_vsnwprintf(pszBuffer, nBufferSize, pszFormat, args);
    }
};

class CUnicodeCharTraits : public CCharTraitsBase<WCHAR, CHAR>
{
    typedef CUnicodeCharTraits TThis;
    typedef CCharTraitsBase<WCHAR, CHAR> Base;

public:
    // without using, we end up hiding these by providing equally named functions
    using Base::DetermineRequiredCharacters;
    using Base::Win32DetermineRequiredCharacters;
    using Base::CopyIntoBuffer;
    using Base::Win32CopyIntoBuffer;

    inline static PCWSTR DotString() { return L"."; }
    inline static SIZE_T DotStringCch() { return 1; }

    // determine characters required for mismatched type (CHAR -> WCHAR)
    template <typename ReturnStrategy>
    inline static typename ReturnStrategy::ReturnType
    DetermineRequiredCharacters(
        ReturnStrategy &returnStrategy,
        PCSTR  sz,
        SIZE_T cchIn,
        SIZE_T  &rcch,
        UINT    cp = CP_THREAD_ACP,
        DWORD dwFlags = MB_ERR_INVALID_CHARS
        )
    {
        FN_TRACE();

        // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Missing parameter checks

        if (sz != NULL)
        {
            // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Should be parameter check
            // For 64-bit, clamp the maximum size passed in to the largest that the INT
            // parameter to MultiByteToWideChar() can take.
            ASSERT2(cchIn <= INT_MAX, "large parameter clamped");
            if (cchIn > INT_MAX)
                cchIn = INT_MAX;

            INT cch = ::MultiByteToWideChar(cp, dwFlags, sz, static_cast<INT>(cchIn), NULL, 0);
            if ((cch == 0) && (cchIn > 0))
            {
                returnStrategy.SetWin32Bool(FALSE);
                goto Exit;
            }
            rcch = static_cast<SIZE_T>(cch) + 1;
        }
        else
            rcch = 1;

        returnStrategy.SetWin32Bool(TRUE);
    Exit:
         return returnStrategy.Return();
    }

    inline static BOOL FindCharacter(PCWSTR sz, SIZE_T cch, WCHAR ch, BOOL *pfFound, SIZE_T *pich)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        // There doesn't seem to be a builtin to do this...
        SIZE_T i;

        if (pfFound != NULL)
            *pfFound = FALSE;

        if (pich != NULL)
            *pich = 0;

        PARAMETER_CHECK((pfFound != NULL) && (pich != NULL));

        for (i=0; i<cch; i++)
        {
            if (sz[i] == ch)
            {
                *pich = i;
                *pfFound = TRUE;
                break;
            }
        }

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    inline static bool ContainsCharacter(PCWSTR sz, SIZE_T cch, WCHAR ch)
    {
        SIZE_T i;

        for (i=0; i<cch; i++)
        {
            if (sz[i] == ch)
                return true;
        }

        return false;
    }

    inline static BOOL Win32ToLower(WCHAR wchToConvert, WCHAR &rwchConverted)
    {
        rwchConverted = ::FusionpRtlDowncaseUnicodeChar(wchToConvert);
        return TRUE;
    }

    inline static BOOL Win32ToUpper(WCHAR wchToConvert, WCHAR &rwchConverted)
    {
        rwchConverted = ::FusionpRtlUpcaseUnicodeChar(wchToConvert);
        return TRUE;
    }

    inline static BOOL Win32ReverseFind(PCWSTR &rpchFound, PCWSTR psz, SIZE_T cch, WCHAR wchToFind, bool fCaseInsensitive)
    {
        BOOL fSuccess = FALSE;
        SIZE_T i = 0;

        rpchFound = NULL;

        if (fCaseInsensitive)
        {
            // Map the character to its lower case equivalent...
            if (!TThis::Win32ToLower(wchToFind, wchToFind))
                goto Exit;

            for (i=cch; i>0; i--)
            {
                bool fMatch = false;

                if (!TThis::Win32CompareLowerCaseCharacterToCharCaseInsensitively(fMatch, wchToFind, psz[i - 1]))
                    goto Exit;

                if (fMatch)
                    break;
            }

        }
        else
        {
            for (i=cch; i>0; i--)
            {
                if (psz[i - 1] == wchToFind)
                    break;
            }
        }

        if (i != 0)
            rpchFound = &psz[i - 1];

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    inline static BOOL Win32CompareLowerCaseCharacterToCharCaseInsensitively(bool &rfMatch, WCHAR wchLowerCase, WCHAR wchCandidate)
    {
        BOOL fSuccess = FALSE;

        rfMatch = false;

        if (!TThis::Win32ToLower(wchCandidate, wchCandidate))
            goto Exit;

        if (wchCandidate == wchLowerCase)
            rfMatch = true;

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    // determine characters required for mismatched type (CHAR -> WCHAR)
    inline static HRESULT DetermineRequiredCharacters(PCSTR sz, SIZE_T cchIn, SIZE_T &rcch, UINT cp = CP_THREAD_ACP, DWORD dwFlags = MB_ERR_INVALID_CHARS)
    {
        CReturnStrategyHresult hr;
        return TThis::DetermineRequiredCharacters(hr, sz, cchIn, rcch, cp, dwFlags);
    }

    // determine characters required for mismatched type (CHAR -> WCHAR)
    inline static BOOL Win32DetermineRequiredCharacters(PCSTR sz, SIZE_T cchIn, SIZE_T &rcch, UINT cp = CP_THREAD_ACP, DWORD dwFlags = MB_ERR_INVALID_CHARS)
    {
        CReturnStrategyBoolLastError f;
        return TThis::DetermineRequiredCharacters(f, sz, cchIn, rcch, cp, dwFlags);
    }

    inline static SIZE_T NullTerminatedStringLength(PCWSTR sz) { return (sz != NULL) ? ::wcslen(sz) : 0; }

    // copy into buffer from CHAR to WCHAR
    template <typename ReturnStrategy>
    inline static typename ReturnStrategy::ReturnType
    CopyIntoBuffer(
        ReturnStrategy &returnStrategy,
        WCHAR rgchBuffer[],
        SIZE_T cchBuffer,
        PCSTR szString,
        SIZE_T cchIn,
        UINT cp = CP_THREAD_ACP,
        DWORD dwFlags = MB_ERR_INVALID_CHARS
        )
    {
        // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Missing explicit parameter checks

        // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Missing explicit parameter checks
        // The caller must be on drugs if they (think that they) have a buffer larger than 2gb, but
        // let's at least clamp it so that we don't get a negative int value passed in
        // to ::MultiByteToWideChar().
        ASSERT2_NTC(cchBuffer <= INT_MAX, "large parameter clamped");

        if (cchBuffer > INT_MAX)
            cchBuffer = INT_MAX;

        if (cchBuffer != 0)
        {
            if (szString != NULL)
            {
                // It would seem that you could just pass the -1 into MultiByteToWideChar(), but
                // you get some errors on the boundary conditions, because -1 implies that you
                // want to consider the null termination on the input string, and the output
                // string will be null terminated also.  Consider the degenerate case of a 2
                // character output buffer and an input string that's a single non-null
                // character followed by a null character.  We're going to trim the size of
                // cchBuffer by 1 so that we manually null-terminate in case the input string
                // was not null-terminated, so MultiByteToWideChar() just writes a single
                // null character to the output buffer since it thinks it must write a null-
                // terminated string.
                //
                // Instead, we'll just always pass in an exact length, not including the null character
                // in the input, and we'll always put the null in place after the conversion succeeds.
                //
                // (this comment is mostly outdated - 11/24/2000 - but the discussion of how the
                // MultiByteToWideChar() API works is worth keeping -mgrier)

                // Since MultiByteToWideChar() takes an "int" length, clamp the maximum
                // value we pass in to 2gb.
                // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Missing parameter check
                ASSERT2_NTC(cchIn <= INT_MAX, "large parameter clamped");
                if (cchIn > INT_MAX)
                    cchIn = INT_MAX;

                INT cch = ::MultiByteToWideChar(cp, dwFlags, szString, static_cast<INT>(cchIn), rgchBuffer, static_cast<INT>(cchBuffer) - 1);
                if ((cch == 0) && (cchBuffer > 1))
                {
                    returnStrategy.SetWin32Bool(FALSE);
                    goto Exit;
                }
                rgchBuffer[cch] = NullCharacter();
            }
            else
                rgchBuffer[0] = NullCharacter();
        }

        returnStrategy.SetWin32Bool(TRUE);
    Exit:
        return returnStrategy.Return();
    }

    // copy into buffer from CHAR to WCHAR
    inline static BOOL Win32CopyIntoBuffer(WCHAR rgchBuffer[], SIZE_T cchBuffer, PCSTR szString, SIZE_T cchIn, UINT cp = CP_THREAD_ACP, DWORD dwFlags = MB_ERR_INVALID_CHARS)
    {
        CReturnStrategyBoolLastError f;
        return TThis::CopyIntoBuffer(f, rgchBuffer, cchBuffer, szString, cchIn, cp, dwFlags);
    }

    // copy into buffer from CHAR to WCHAR
    inline static HRESULT CopyIntoBuffer(WCHAR rgchBuffer[], SIZE_T cchBuffer, PCSTR szString, SIZE_T cchIn, UINT cp = CP_THREAD_ACP, DWORD dwFlags = MB_ERR_INVALID_CHARS)
    {
        CReturnStrategyHresult hr;
        return TThis::CopyIntoBuffer(hr, rgchBuffer, cchBuffer, szString, cchIn, cp, dwFlags);
    }

    inline static SIZE_T Cch(PCWSTR psz) { return (psz != NULL) ? ::wcslen(psz) : 0; }

};

template <UINT cp = CP_THREAD_ACP> class CMBCSCharTraits : public CCharTraitsBase<CHAR, WCHAR>
{
private:
    typedef CCharTraitsBase<CHAR, WCHAR> Base;
public:
    typedef CHAR TChar;
    typedef LPSTR TMutableString;
    typedef PCSTR TConstantString;

    typedef CUnicodeCharTraits TOtherTraits;
    typedef TOtherTraits::TOtherChar TOtherChar;
    typedef TOtherTraits::TOtherString TOtherString;
    typedef TOtherTraits::TConstantString TOtherConstantString;

    inline static PCSTR DotString() { return "."; }
    inline static SIZE_T DotStringCch() { return 1; }

    // without using, we end up hiding these by providing equally named functions
    using Base::DetermineRequiredCharacters;
    using Base::Win32DetermineRequiredCharacters;
    using Base::CopyIntoBuffer;
    using Base::Win32CopyIntoBuffer;

    // determine characters required for mismatched type (WCHAR -> CHAR)
    template <typename ReturnStrategy>
    inline static typename ReturnStrategy::ReturnType
    DetermineRequiredCharacters(
            ReturnStrategy &returnStrategy,
            PCWSTR sz,
            SIZE_T cchIn,
            SIZE_T &rcch,
            DWORD dwFlags = 0,
            PCSTR pszDefaultChar = NULL,
            LPBOOL lpUsedDefaultChar = NULL
            )
    {
        // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Missing parameter checks
        if (sz != NULL)
        {
            ASSERT2(cchIn <= INT_MAX, "large parameter clamped");
            ASSERT(cchIn <= INT_MAX);
            if (cchIn > INT_MAX)
                cchIn = INT_MAX;

            INT cch = ::WideCharToMultiByte(cp, dwFlags, sz, static_cast<INT>(cchIn), NULL, 0, pszDefaultChar, lpUsedDefaultChar);
            if ((cch == 0) && (cchIn > 0))
            {
                returnStrategy.SetWin32Bool(FALSE);
                goto Exit;
            }

            // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - internal error check that cch >= 0

            rcch = static_cast<SIZE_T>(cch) + 1;
        } else
            rcch = 1;

        returnStrategy.SetWin32Bool(TRUE);
    Exit:
        return returnStrategy.Return();
    }

    inline static SIZE_T NullTerminatedStringLength(PCSTR sz) { return ::strlen(sz); }

    // determine characters required for mismatched type (WCHAR -> CHAR)
    inline static BOOL Win32DetermineRequiredCharacters(PCWSTR sz, SIZE_T cchIn, SIZE_T &rcch, DWORD dwFlags = 0, PCSTR pszDefaultChar = NULL, LPBOOL lpUsedDefaultChar = NULL)
    {
        CReturnStrategyBoolLastError f;
        return TThis::DetermineRequiredCharacters(f, sz, cchIn, rcch, dwFlags, pszDefaultChar, lpUsedDefaultChar);
    }

    // # characters required for mismatched type (WCHAR -> CHAR)
    inline static HRESULT DetermineRequiredCharacters(PCWSTR sz, SIZE_T cchIn, SIZE_T &rcch, DWORD dwFlags = 0, PCSTR pszDefaultChar = NULL, LPBOOL lpUsedDefaultChar = NULL)
    {
        CReturnStrategyHresult hr;
        return TThis::DetermineRequiredCharacters(hr, sz, cchIn, rcch, dwFlags, pszDefaultChar, lpUsedDefaultChar);
    }

    // copy into buffer from WCHAR to CHAR
    template <typename ReturnStrategy>
    inline static typename ReturnStrategy::ReturnType
    CopyIntoBuffer(
        ReturnStrategy &returnStrategy,
        CHAR rgchBuffer[],
        SIZE_T cchBuffer,
        PCWSTR szString,
        SIZE_T cchIn,
        DWORD dwFlags = 0,
        PCSTR pszDefaultChar = NULL,
        LPBOOL lpUsedDefaultChar = NULL
        )
    {
        // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Missing parameter checks
        if (cchBuffer != 0)
        {
            // Clamp the maximum buffer size to maxint, since the buffer size passed in to
            // WideCharToMultiByte() is an INT rather than a SIZE_T or INT_PTR etc.
            // After all, who's really going to have a buffer size > 2gb?  The caller
            // probably just messed up.
            ASSERT2(cchBuffer <= INT_MAX, "large parameter clamped");
            if (cchBuffer > INT_MAX)
                cchBuffer = INT_MAX;

            if (szString != NULL)
            {
                // It would seem that you could just pass the -1 into MultiByteToWideChar(), but
                // you get some errors on the boundary conditions, because -1 implies that you
                // want to consider the null termination on the input string, and the output
                // string will be null terminated also.  Consider the degenerate case of a 2
                // character output buffer and an input string that's a single non-null
                // character followed by a null character.  We're going to trim the size of
                // cchBuffer by 1 so that we manually null-terminate in case the input string
                // was not null-terminated, so MultiByteToWideChar() just writes a single
                // null character to the output buffer since it thinks it must write a null-
                // terminated string.
                //
                // Instead, we'll just always pass in an exact length, not including the null character
                // in the input, and we'll always put the null in place after the conversion succeeds.
                //

                ASSERT2(cchIn <= INT_MAX, "large parameter clamped");
                if (cchIn > INT_MAX)
                    cchIn = INT_MAX;

                INT cch = ::WideCharToMultiByte(cp, dwFlags, szString, static_cast<INT>(cchIn), rgchBuffer, static_cast<INT>(cchBuffer - 1), pszDefaultChar, lpUsedDefaultChar);
                if ((cch == 0) && (cchBuffer > 1))
                {
                    returnStrategy.SetWin32Bool(FALSE);
                    goto Exit;
                }

                // NTRAID#NTBUG9 - 590078 - 2002/03/29 - mgrier - Missing internal error check that cch >= 0

                rgchBuffer[cch] = NullCharacter();
            }
            else
                rgchBuffer[0] = NullCharacter();
        }
        returnStrategy.SetWin32Bool(TRUE);
    Exit:
        return returnStrategy.Return();
    }

    // copy into buffer from WCHAR to CHAR
    inline static HRESULT CopyIntoBuffer(CHAR rgchBuffer[], SIZE_T cchBuffer, PCWSTR szString, SIZE_T cchIn, DWORD dwFlags = 0, PCSTR pszDefaultChar = NULL, LPBOOL lpUsedDefaultChar = NULL)
    {
        CReturnStrategyHresult hr;
        return TThis::CopyIntoBuffer(hr, rgchBuffer, cchBuffer, szString, cchIn, dwFlags, pszDefaultChar, lpUsedDefaultChar);
    }

    // copy into buffer from WCHAR to CHAR
    inline static BOOL Win32CopyIntoBuffer(CHAR rgchBuffer[], SIZE_T cchBuffer, PCWSTR szString, SIZE_T cchIn, DWORD dwFlags = 0, PCSTR pszDefaultChar = NULL, LPBOOL lpUsedDefaultChar = NULL)
    {
        CReturnStrategyBoolLastError f;
        return TThis::CopyIntoBuffer(f, rgchBuffer, cchBuffer, szString, cchIn, dwFlags, pszDefaultChar, lpUsedDefaultChar);
    }

    inline static SIZE_T Cch(PCSTR psz) { return ::strlen(psz); }

};

typedef CMBCSCharTraits<CP_THREAD_ACP> CANSICharTraits;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusiondequelinkage.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusiondequelinkage.h

Abstract:

Author:

Revision History:

--*/
#if !defined(_FUSION_INC_FUSIONDEQUELINKAGE_H_INCLUDED_)
#define _FUSION_INC_FUSIONDEQUELINKAGE_H_INCLUDED_

#pragma once

#include "fusiontrace.h"

class CDequeBase;

class CDequeLinkage : protected LIST_ENTRY
{
    friend CDequeBase;

public:
    inline CDequeLinkage() : m_pDeque(NULL), m_ulLockCount(0) { this->Flink = NULL; this->Blink = NULL; }
    inline ~CDequeLinkage() { ASSERT_NTC(m_ulLockCount == 0); m_pDeque = NULL; }

    inline bool IsNotLocked() const { return (m_ulLockCount == 0); }
#if DBG
    inline VOID Lock() { m_ulLockCount++; }
    inline VOID Unlock() { m_ulLockCount--; }
#else
    inline VOID Lock() { }
    inline VOID Unlock() { }
#endif

    inline VOID Remove() { this->Flink->Blink = this->Flink; this->Blink->Flink = this->Flink; }

protected:
    inline VOID InitializeHead(CDequeBase *pDequeBase) { ASSERT_NTC(pDequeBase != NULL); this->Flink = this; this->Blink = this; this->m_pDeque = pDequeBase; }
    inline CDequeLinkage *GetFlink() const { return static_cast<CDequeLinkage *>(this->Flink); }
    inline CDequeLinkage *GetBlink() const { return static_cast<CDequeLinkage *>(this->Blink); }

    inline CDequeBase *GetDequeBase() const { return m_pDeque; }
    inline VOID SetDeque(CDequeBase *pDeque) { m_pDeque = pDeque; }

    inline VOID SetFlink(CDequeLinkage *pFlink) { this->Flink = pFlink; }
    inline VOID SetBlink(CDequeLinkage *pBlink) { this->Blink = pBlink; }

    CDequeBase *m_pDeque;

    // m_ulLockCount is incremented when an iterator is positioned on an entry, to stop
    // it from being deleted.  Note that no interlocked synchronization is attempted;
    // this is merely to stop blatent programming errors.  If you want multithreaded
    // access to the deque, you need to provide your own synchronization.
    ULONG m_ulLockCount;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusiondump.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusiondump.h

Abstract:

    Merge/refactor stuff in sxstest with dumpers.cpp
    Eventually merge with debug extensions, let it be optionally
    driven by symbol info available to debug extensions via .pdbs.

Author:

    Jay Krell (JayKrell) November 2001

Revision History:


--*/

//
// Probably we should treat everything as a sized integer, and leave the
// indirection up to the caller. This code was not originally intended
// to be symbol driven in a debugger extension, so we'll keep the "native"
// features for now.
//
#define FUSIONP_DUMP_TYPE_ULONG                   0x01
#define FUSIONP_DUMP_TYPE_ULONG_OFFSET_TO_PCWSTR  0x02
#define FUSIONP_DUMP_TYPE_LARGE_INTEGER_TIME      0x03
#define FUSIONP_DUMP_OFFSET_BASE_0                0x00
#define FUSIONP_DUMP_OFFSET_BASE_1                0x10
#define FUSIONP_DUMP_OFFSET_BASE_2                0x20

typedef struct _FUSIONP_DUMP_BUILTIN_SYMBOLS_FIELD
{
    // more generally, these UCHARs should be ULONG or SIZE_T
    PCSTR   Name;
    UCHAR   NameLength;
    UCHAR   Type;
    UCHAR   Offset;
    UCHAR   Size;
} FUSIONP_DUMP_BUILTIN_SYMBOLS_FIELD, *PFUSIONP_DUMP_BUILTIN_SYMBOLS_FIELD;
typedef const FUSIONP_DUMP_BUILTIN_SYMBOLS_FIELD * PCFUSIONP_DUMP_BUILTIN_SYMBOLS_FIELD;

#define FUSIONP_DUMP_MAKE_FIELD(x, t) \
{ \
    #x, \
    static_cast<UCHAR>(sizeof(#x)-1), \
    FUSIONP_DUMP_TYPE_ ## t, \
    static_cast<UCHAR>(FIELD_OFFSET(FUSIONP_DUMP_CURRENT_STRUCT, x)), \
    static_cast<UCHAR>(RTL_FIELD_SIZE(FUSIONP_DUMP_CURRENT_STRUCT, x)) \
},

typedef struct _FUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT
{
    // more generally, these UCHARs should be ULONG or SIZE_T
    PCSTR   Name;
    UCHAR   NameLength;
    UCHAR   Size;
    UCHAR   NumberOfFields;
    PCFUSIONP_DUMP_BUILTIN_SYMBOLS_FIELD Fields;

} FUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT, *PFUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT;
typedef const FUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT * PCFUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT;

typedef int   (__cdecl * PFN_FUSIONP_DUMP_PRINTF)(const char * Format, ...);
typedef PCSTR (__stdcall * PFN_FUSIONP_DUMP_FORMATTIME)(LARGE_INTEGER);

typedef struct _FUSIONP_DUMP_CALLBACKS {

    PFN_FUSIONP_DUMP_PRINTF       Printf;
    PFN_FUSIONP_DUMP_FORMATTIME   FormatTime;

} FUSIONP_DUMP_CALLBACKS, *PFUSIONP_DUMP_CALLBACKS;
typedef const FUSIONP_DUMP_CALLBACKS * PCFUSIONP_DUMP_CALLBACKS;

BOOL
FusionpDumpStruct(
    PCFUSIONP_DUMP_CALLBACKS Callbacks,
    PCFUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT BuiltinTypeInfo,
    ULONG64     StructBase,
    PCSTR       StructFriendlyName,  // should be more like "per line prefix"
    const ULONG64 * Bases           // helps with position independent data, but is it sufficient?
    );

#define FUSIONP_DUMP_NATIVE_DEREF(StructType, Struct, Field) ((ULONG64)(((StructType)(ULONG_PTR)Struct)->Field))

ULONG64
FusionpDumpSymbolDrivenDeref(
    PCSTR   StructType,
    ULONG64 StructBase,
    PCSTR   FieldName
    );

#define FUSIONP_DUMP_SYMBOL_DRIVEN_DEREF(StructType, Struct, Field) \
    (FusionpDumpSymbolDrivenDeref(#StructType, static_cast<ULONG64>(reinterpret_cast<ULONG_PTR>(Struct)), #Field))

//
// initial test case migrated from sxstest
//
extern const FUSIONP_DUMP_BUILTIN_SYMBOLS_STRUCT StructInfo_ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusiongetfilesizeex.h ===
#pragma once

#if defined(__cplusplus)
extern "C"
{
#endif

BOOL
WINAPI
FusionpGetFileSizeEx(
    HANDLE         FileHandle,
    PLARGE_INTEGER FileSize
    );

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusiondeque.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusiondeque.h

Abstract:

Author:

Revision History:

--*/
#pragma once

#include "fusiontrace.h"
#include "fusiondequelinkage.h"

class CDequeBase
{
protected:
    inline CDequeBase() : m_EntryCount(0) { m_Head.InitializeHead(this); }

    inline ~CDequeBase()
    {
        // Derived class should have cleaned up
        ASSERT_NTC(m_EntryCount == 0);
    }

    inline VOID VerifyLinkageFromThisDeque(const CDequeLinkage &r)
    {
        ASSERT_NTC(r.GetDequeBase() == this);
    }

#if DBG
    inline bool Valid() const { return (m_Head.GetFlink() != NULL) && (m_Head.GetBlink() != NULL); }
#endif // DBG

    void ResetHead() { FN_TRACE(); m_Head.InitializeHead(this); }

    inline VOID InsertAfter(CDequeLinkage *pExistingLinkage, CDequeLinkage *pNewLinkage, bool fUpdateEntryCount = true)
    {
        ASSERT_NTC(this->Valid());
        this->VerifyLinkageFromThisDeque(m_Head);

        pNewLinkage->SetFlink(pExistingLinkage->GetFlink());
        pNewLinkage->SetBlink(pExistingLinkage);
        pExistingLinkage->GetFlink()->SetBlink(pNewLinkage);
        pExistingLinkage->SetFlink(pNewLinkage);
        pNewLinkage->SetDeque(this);
        if (fUpdateEntryCount)
            m_EntryCount++;
    }

    VOID InsertBefore(CDequeLinkage *pExistingLinkage, CDequeLinkage *pNewLinkage, bool fUpdateEntryCount = true)
    {
        ASSERT_NTC(this->Valid());
        this->VerifyLinkageFromThisDeque(m_Head);

        pNewLinkage->SetBlink(pExistingLinkage->GetBlink());
        pNewLinkage->SetFlink(pExistingLinkage);
        pExistingLinkage->GetBlink()->SetFlink(pNewLinkage);
        pExistingLinkage->SetBlink(pNewLinkage);
        pNewLinkage->SetDeque(this);
        if (fUpdateEntryCount)
            m_EntryCount++;
    }

    VOID Remove(CDequeLinkage *pLinkage, bool fUpdateEntryCount = true)
    {
        ASSERT_NTC(this->Valid());
        this->VerifyLinkageFromThisDeque(m_Head);

        // You can't remove the head...
        ASSERT_NTC(pLinkage->GetDequeBase() == this);
        ASSERT_NTC(pLinkage != &m_Head);
        ASSERT_NTC(pLinkage->m_ulLockCount == 0);

        if ((pLinkage != NULL) &&
            (pLinkage->GetDequeBase() == this) &&
            (pLinkage != &m_Head))
        {
            pLinkage->GetBlink()->SetFlink(pLinkage->GetFlink());
            pLinkage->GetFlink()->SetBlink(pLinkage->GetBlink());
            if (fUpdateEntryCount)
                m_EntryCount--;
        }
    }

    VOID SetDeque(CDequeLinkage *pLinkage) { pLinkage->SetDeque(this); }

    static CDequeLinkage *GetFlink(const CDequeLinkage *pLinkage) { return pLinkage->GetFlink(); }
    static CDequeLinkage *GetFlink(const CDequeLinkage &rLinkage) { return rLinkage.GetFlink(); }
    static CDequeLinkage *GetBlink(const CDequeLinkage *pLinkage) { return pLinkage->GetBlink(); }
    static CDequeLinkage *GetBlink(const CDequeLinkage &rLinkage) { return rLinkage.GetBlink(); }
    static VOID SetFlink(CDequeLinkage *pLinkage, CDequeLinkage *pFlink) { pLinkage->SetFlink(pFlink); }
    static VOID SetFlink(CDequeLinkage &rLinkage, CDequeLinkage *pFlink) { rLinkage.SetFlink(pFlink); }
    static VOID SetBlink(CDequeLinkage *pLinkage, CDequeLinkage *pBlink) { pLinkage->SetBlink(pBlink); }
    static VOID SetBlink(CDequeLinkage &rLinkage, CDequeLinkage *pBlink) { rLinkage.SetBlink(pBlink); }

    CDequeLinkage m_Head;
    SIZE_T m_EntryCount;

private:
    CDequeBase(const CDequeBase &r); // intentionally not implemented
    void operator =(const CDequeBase &r); // intentionally not implemented
};

template <typename TEntry, size_t LinkageMemberOffset> class CConstDequeIterator;

template <typename TEntry, size_t LinkageMemberOffset> class CDeque : protected CDequeBase
{
    friend CConstDequeIterator<TEntry, LinkageMemberOffset>;

public:
    // NTRAID#NTBUG9 - 590101 - 2002/03/29 - mgrier - Should C_ASSERT that the linkage fits in TEntry
    CDeque() { }

    ~CDeque()
    {
        CSxsPreserveLastError ple;

        ASSERT_NTC(this->Valid());
        this->VerifyLinkageFromThisDeque(m_Head);

        // You should have cleaned up this deque beforehand...
        ASSERT_NTC(m_EntryCount == 0);

        m_EntryCount = 0;

        ple.Restore();
    }

    VOID TakeValue(CDeque &rThat)
    {
        FN_TRACE();

        ASSERT(this->Valid());

        // Since we don't manage the storage of the entries, "this" deque
        // must be empty.
        ASSERT(m_EntryCount == 0);

        // with regards to linkages, we only need to change the pseudo-head flink
        // and blink, the actual head blink and the actual tail flink.  However,
        // for debugging purposes, we keep the identity of the deque that contains
        // the linkage in the linkage, so we also have to fix those.

        ASSERT(rThat.Valid());

        CDequeLinkage *pLinkage = rThat.GetFlink(rThat.m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &rThat.m_Head)
            {
                ASSERT(pLinkage->IsNotLocked());
                this->SetDeque(pLinkage);
                pLinkage = rThat.GetFlink(pLinkage);
            }
        }

        // Now munge the pointers...
        this->SetFlink(m_Head, rThat.GetFlink(rThat.m_Head));
        this->SetBlink(m_Head, rThat.GetBlink(rThat.m_Head));
        this->SetBlink(rThat.GetFlink(rThat.m_Head), &m_Head);
        this->SetFlink(rThat.GetBlink(rThat.m_Head), &m_Head);
        rThat.SetFlink(rThat.m_Head, &rThat.m_Head);
        rThat.SetBlink(rThat.m_Head, &rThat.m_Head);

        m_EntryCount = rThat.m_EntryCount;
        rThat.m_EntryCount = 0;
    }

    VOID AddToHead(TEntry *pEntry)
    {
        FN_TRACE();
        ASSERT(this->Valid());
        this->InsertAfter(&m_Head, this->MapEntryToLinkage(pEntry), true);
    }

    VOID AddToTail(TEntry *pEntry)
    {
        FN_TRACE();
        ASSERT(this->Valid());
        this->InsertBefore(&m_Head, this->MapEntryToLinkage(pEntry), true);
    }

    VOID Add(TEntry *pEntry)
    {
        FN_TRACE();
        ASSERT(this->Valid());
        AddToTail(pEntry);
    }

    TEntry *RemoveHead()
    {
        FN_TRACE();

        ASSERT(this->Valid());

        TEntry *pEntry = NULL;

        if (this->GetFlink(m_Head) != &m_Head)
        {
            CDequeLinkage *pLinkage = this->GetFlink(m_Head);
            this->Remove(pLinkage, true);
            pEntry = this->MapLinkageToEntry(pLinkage);
        }

        return pEntry;
    }

    TEntry *RemoveTail()
    {
        FN_TRACE();

        ASSERT(this->Valid());

        TEntry *pEntry = NULL;

        if (this->GetBlink(m_Head) != &m_Head)
        {
            pEntry = this->GetBlink(m_Head);
            this->Remove(pEntry, true);
        }

        return pEntry;
    }

    bool IsHead(CDequeLinkage *pLinkage) const { return pLinkage == &m_Head; }

    VOID Remove(TEntry *pEntry)
    {
        FN_TRACE();

        ASSERT(this->Valid());

        this->Remove(this->MapEntryToLinkage(pEntry), true);
    }

    template <typename T> VOID ForEach(T *pt, VOID (T::*pmfn)(TEntry *p))
    {
        FN_TRACE();

        ASSERT(this->Valid());

        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                // You can't remove the element that you're on during a ForEach() call.
                pLinkage->Lock();
                (pt->*pmfn)(this->MapLinkageToEntry(pLinkage));
                pLinkage->Unlock();
                pLinkage = this->GetFlink(pLinkage);
            }
        }
    }

    template <typename T> VOID ForEach(const T *pt, VOID (T::*pmfn)(TEntry *p) const)
    {
        FN_TRACE();

        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                pLinkage->Lock();
                (pt->*pmfn)(this->MapLinkageToEntry(pLinkage));
                pLinkage->Unlock();
                pLinkage = this->GetFlink(pLinkage);
            }
        }
    }

    template <typename T> VOID Clear(T *pt, VOID (T::*pmfn)(TEntry *p))
    {
        FN_TRACE();

        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        // NTRAID#NTBUG9 - 590101 - 2002/03/29 - mgrier - We should verify that the total iteration
        // count (including if pLinkage == NULL!) is equal to m_ElementCount.
        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                CDequeLinkage *pLinkage_Next = this->GetFlink(pLinkage);
                ASSERT(pLinkage->IsNotLocked());
                (pt->*pmfn)(this->MapLinkageToEntry(pLinkage));
                pLinkage = pLinkage_Next;
            }
        }

        this->ResetHead();
        m_EntryCount = 0;
    }

    template <typename T> VOID Clear(const T *pt, VOID (T::*pmfn)(TEntry *p) const)
    {
        FN_TRACE();

        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                CDequeLinkage *pLinkage_Next = this->GetFlink(pLinkage);
                ASSERT(pLinkage->IsNotLocked());
                (pt->*pmfn)(this->MapLinkageToEntry(pLinkage));
                pLinkage = pLinkage_Next;
            }
        }

        this->ResetHead();
        m_EntryCount = 0;
    }

    VOID Clear(VOID (TEntry::*pmfn)())
    {
        FN_TRACE();

        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                CDequeLinkage *pLinkage_Next = this->GetFlink(pLinkage);
                ASSERT(pLinkage->IsNotLocked());
                TEntry* pEntry = this->MapLinkageToEntry(pLinkage);
                (pEntry->*pmfn)();
                pLinkage = pLinkage_Next;
            }
        }

        this->ResetHead();
        m_EntryCount = 0;
    }

    VOID ClearAndDeleteAll()
    {
        FN_TRACE();
        ASSERT(this->Valid());
        CDequeLinkage *pLinkage = this->GetFlink(m_Head);

        if (pLinkage != NULL)
        {
            while (pLinkage != &m_Head)
            {
                CDequeLinkage *pLinkage_Next = this->GetFlink(pLinkage);
                ASSERT(pLinkage->IsNotLocked());
                TEntry* pEntry = this->MapLinkageToEntry(pLinkage);
                FUSION_DELETE_SINGLETON(pEntry);
                pLinkage = pLinkage_Next;
            }
        }

        this->ResetHead();
        m_EntryCount = 0;
    }

    void ClearNoCallback()
    {
        FN_TRACE();

        ASSERT(this->Valid());

        this->ResetHead();
        m_EntryCount = 0;
    }


    SIZE_T GetEntryCount() const { return m_EntryCount; }
    bool IsEmpty() const { return m_EntryCount == 0; }

protected:
    using CDequeBase::Remove;

    TEntry *MapLinkageToEntry(CDequeLinkage *pLinkage) const
    {
        ASSERT_NTC(pLinkage != &m_Head);

        if (pLinkage == &m_Head)
            return NULL;

        return (TEntry *) (((LONG_PTR) pLinkage) - LinkageMemberOffset);
    }

    CDequeLinkage *MapEntryToLinkage(TEntry *pEntry) const
    {
        ASSERT_NTC(pEntry != NULL);

        return (CDequeLinkage *) (((LONG_PTR) pEntry) + LinkageMemberOffset);
    }

private:
    CDeque(const CDeque &r); // intentionally not implemented
    void operator =(const CDeque &r); // intentionally not implemented
};

enum DequeIteratorMovementDirection
{
    eDequeIteratorMoveForward,
    eDequeIteratorMoveBackward
};

template <typename TEntry, size_t LinkageMemberOffset> class CConstDequeIterator
{
public:
    CConstDequeIterator(const CDeque<TEntry, LinkageMemberOffset> *Deque = NULL) : m_Deque(Deque), m_pCurrent(NULL) { }

    ~CConstDequeIterator()
    {
        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }
    }

    VOID Rebind(const CDeque<TEntry, LinkageMemberOffset> *NewDeque)
    {
        FN_TRACE();

        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }

        m_Deque = NewDeque;
        if (NewDeque != NULL)
        {
            m_pCurrent = this->GetFirstLinkage();
            m_pCurrent->Lock();
        }
    }

    bool IsBound() const { return (m_Deque != NULL); }

    VOID Unbind()
    {
        FN_TRACE();

        if (m_Deque != NULL)
        {
            if (m_pCurrent != NULL)
            {
                m_pCurrent->Unlock();
                m_pCurrent = NULL;
            }

            m_Deque = NULL;
        }
    }

    // You can't remove an element that the iterator is sitting on; usually you just
    // save the current element and move to the next one, but if you found the exact
    // element you wanted and don't want to use the iterator any more, you can Close()
    // it to release the lock.
    VOID Close()
    {
        FN_TRACE();

        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }
    }

    inline VOID Reset()
    {
        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }

        m_pCurrent = this->GetFirstLinkage();
        m_pCurrent->Lock();
    }

    inline VOID Move(DequeIteratorMovementDirection eDirection)
    {
        ASSERT_NTC(m_pCurrent != NULL);
        ASSERT_NTC((eDirection == eDequeIteratorMoveForward) ||
               (eDirection == eDequeIteratorMoveBackward));

        m_pCurrent->Unlock();
        if (eDirection == eDequeIteratorMoveForward)
            m_pCurrent = m_Deque->GetFlink(m_pCurrent);
        else if (eDirection == eDequeIteratorMoveBackward)
            m_pCurrent = m_Deque->GetBlink(m_pCurrent);
        m_pCurrent->Lock();
    }

    VOID Next() { this->Move(eDequeIteratorMoveForward); }
    VOID Previous() { this->Move(eDequeIteratorMoveBackward); }

    bool More() const { return (m_pCurrent != NULL) && (m_pCurrent != &m_Deque->m_Head); }

    TEntry *operator ->() const { ASSERT_NTC(m_pCurrent != NULL); return this->MapLinkageToEntry(m_pCurrent); }
    operator TEntry *() const { ASSERT_NTC(m_pCurrent != NULL); return this->MapLinkageToEntry(m_pCurrent); }
    TEntry *Current() const { ASSERT_NTC(m_pCurrent != NULL); return this->MapLinkageToEntry(m_pCurrent); }

protected:
    CDequeLinkage *GetFirstLinkage() const { return m_Deque->GetFlink(m_Deque->m_Head); }
    CDequeLinkage *GetLastLinkage() const { return m_Deque->GetBlink(m_Deque->m_Head); }

    TEntry *MapLinkageToEntry(CDequeLinkage *pLinkage) const { return m_Deque->MapLinkageToEntry(pLinkage); }

    const CDeque<TEntry, LinkageMemberOffset> *m_Deque;
    CDequeLinkage *m_pCurrent;
};

template <typename TEntry, size_t LinkageMemberOffset> class CDequeIterator : public CConstDequeIterator<TEntry, LinkageMemberOffset>
{
    typedef CConstDequeIterator<TEntry, LinkageMemberOffset> Base;

public:
    CDequeIterator(CDeque<TEntry, LinkageMemberOffset> *Deque = NULL) : Base(Deque) { }

    ~CDequeIterator() { }

    VOID Rebind(CDeque<TEntry, LinkageMemberOffset> *NewDeque)
    {
        FN_TRACE();

        if (m_pCurrent != NULL)
        {
            m_pCurrent->Unlock();
            m_pCurrent = NULL;
        }

        m_Deque = NewDeque;

        if (NewDeque != NULL)
        {
            m_pCurrent = this->GetFirstLinkage();
            m_pCurrent->Lock();
        }
    }

    TEntry *RemoveCurrent(DequeIteratorMovementDirection eDirection)
    {
        FN_TRACE();
        TEntry *Result = NULL;

        ASSERT(m_pCurrent != NULL);
        ASSERT(!m_Deque->IsHead(m_pCurrent));

        if ((m_pCurrent != NULL) && (!m_Deque->IsHead(m_pCurrent)))
        {
            Result = this->MapLinkageToEntry(m_pCurrent);
            this->Move(eDirection);
            const_cast<CDeque<TEntry, LinkageMemberOffset> *>(m_Deque)->Remove(Result);
        }
        return Result;
    }

    void DeleteCurrent(DequeIteratorMovementDirection eDirection)
    {
        FN_TRACE();
        TEntry *Result = this->RemoveCurrent(eDirection);

        if (Result != NULL)
            FUSION_DELETE_SINGLETON(Result);
    }

protected:
    // All member data is in the parent...
};

#ifdef FN_TRACE_SHOULD_POP
#pragma pop_macro("FN_TRACE")
#undef FN_TRACE_SHOULD_POP
#elif defined(FN_TRACE_SHOULD_DESTROY)
#undef FN_TRACE
#endif

#ifdef FN_TRACE_CONSTRUCTOR_SHOULD_POP
#pragma pop_macro("FN_TRACE_CONSTRUCTOR")
#undef FN_TRACE_CONSTRUCTOR_SHOULD_POP
#elif defined(FN_TRACE_CONSTRUCTOR_SHOULD_DESTROY)
#undef FN_TRACE_CONSTRUCTOR
#endif

#ifdef FN_TRACE_DESTRUCTOR_SHOULD_POP
#pragma pop_macro("FN_TRACE_DESTRUCTOR")
#undef FN_TRACE_DESTRUCTOR_SHOULD_POP
#elif defined(FN_TRACE_DESTRUCTOR_SHOULD_DESTROY)
#undef FN_TRACE_DESTRUCTOR
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusiongetvolumepathnamesforvolumename.h ===
#pragma once

#if defined(__cplusplus)
extern "C"
{
#endif

BOOL 
WINAPI
FusionpGetVolumePathNamesForVolumeNameA(
    LPCSTR lpszVolumeName,
    LPSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );

BOOL 
WINAPI
FusionpGetVolumePathNamesForVolumeNameW(
    LPCWSTR lpszVolumeName,
    LPWSTR lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusioneventlog.h ===
#pragma once

#if !defined(NT_INCLUDED) && defined(_WINDOWS_)
#error You must not include windows.h before this.
#endif
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <limits.h>
#include "debmacro.h"
#include "FusionString.h"
#include "messages.h"
#include "numberof.h"
#include <ole2.h>
#include <xmlparser.h>
#include "fusionbuffer.h"
#include <sxstypes.h>
#include "util.h"

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

typedef struct _SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

BOOL
FusionpEventLogMain(
    HINSTANCE,
    DWORD dwReason,
    PVOID pvReserved
    );

HRESULT
FusionpLogError(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s3 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s4 = g_strEmptyUnicodeString
    );

HRESULT
FusionpLogError(
    DWORD dwEventId,
    ULONG nStrings = 0,
    UNICODE_STRING const* const* rgps = NULL
    );

HRESULT
FusionpLogErrorToEventLog(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s3 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s4 = g_strEmptyUnicodeString
    );

HRESULT
FusionpLogErrorToEventLog(
    DWORD dwEventId,
    ULONG nStrings = 0,
    UNICODE_STRING const* const* rgps = NULL
    );

HRESULT
FusionpLogErrorToDebugger(
    DWORD dwEventId,
    const UNICODE_STRING& s1,
    const UNICODE_STRING& s2 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s3 = g_strEmptyUnicodeString,
    const UNICODE_STRING& s4 = g_strEmptyUnicodeString
    );

HRESULT
FusionpLogErrorToDebugger(
    DWORD dwEventId,
    ULONG nStrings = 0,
    UNICODE_STRING const* const* rgps = NULL
    );

HRESULT
FusionpLogParseError(
    PCWSTR FilePath,
    SIZE_T FilePathCch,
    ULONG LineNumber,
    DWORD dwLastParseError,
    const UNICODE_STRING *p1 = NULL,
    const UNICODE_STRING *p2 = NULL,
    const UNICODE_STRING *p3 = NULL,
    const UNICODE_STRING *p4 = NULL,
    const UNICODE_STRING *p5 = NULL,
    const UNICODE_STRING *p6 = NULL,
    const UNICODE_STRING *p7 = NULL,
    const UNICODE_STRING *p8 = NULL,
    const UNICODE_STRING *p9 = NULL,
    const UNICODE_STRING *p10 = NULL,
    const UNICODE_STRING *p11 = NULL,
    const UNICODE_STRING *p12 = NULL,
    const UNICODE_STRING *p13 = NULL,
    const UNICODE_STRING *p14 = NULL,
    const UNICODE_STRING *p15 = NULL,
    const UNICODE_STRING *p16 = NULL,
    const UNICODE_STRING *p17 = NULL,
    const UNICODE_STRING *p18 = NULL,
    const UNICODE_STRING *p19 = NULL,
    const UNICODE_STRING *p20 = NULL
    );

DWORD
FusionpEventIdToError(
    DWORD dwEventId
    );

VOID
FusionpLogRequiredAttributeMissingParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    );

VOID
FusionpLogInvalidAttributeValueParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    );

VOID
FusionpLogInvalidAttributeValueParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE &rAttribute
    );

VOID
FusionpLogAttributeNotAllowedParseError(
    PCWSTR SourceFilePath,
    SIZE_T SourceFileCch,
    ULONG LineNumber,
    PCWSTR ElementName,
    SIZE_T ElementNameCch,
    PCWSTR AttributeName,
    SIZE_T AttributeNameCch
    );

VOID
FusionpLogWin32ErrorToEventLog(
    );

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

typedef CUnicodeString CEventLogString;

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

// sizeof(__int64)*CHAR_BIT is big enough to format an __int64,
// it's enough of an overestimate for negative decimals, 0x prefixed
// hex, and the terminal nul; I don't know about octal.
//
// Using this to log GetLastError may truncate some characters,
// but we'll always have a terminal nul.
typedef CUnicodeStringN<sizeof(ULONGLONG)*CHAR_BIT> CEventLogBuffer;

// but this size is not enough for LastError LogBuffer
typedef CUnicodeStringN<160> CEventLogBufferLastError;

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/
class CEventLogInteger : public CEventLogBuffer
{
public:
    explicit CEventLogInteger(LONGLONG i);
    ~CEventLogInteger() { }

private: // deliberately not implemented
    CEventLogInteger();
    CEventLogInteger(const CEventLogInteger&);
    void operator=(const CEventLogInteger&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogHex : public CEventLogBuffer
{
public:
    explicit CEventLogHex(LONGLONG i);
    ~CEventLogHex() { }

    LONGLONG m_i;

private: // deliberately not implemented
    CEventLogHex();
    CEventLogHex(const CEventLogHex&);
    void operator=(const CEventLogHex&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogHResult : public CEventLogBuffer
{
public:
    explicit CEventLogHResult(HRESULT hr);
    ~CEventLogHResult() { }

    HRESULT m_hresult;

private: // deliberately not implemented
    CEventLogHResult();
    CEventLogHResult(const CEventLogHResult&);
    void operator=(const CEventLogHResult&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogLastError : public CEventLogBufferLastError
{
public:
    CEventLogLastError();
    CEventLogLastError(DWORD dwLastError);
    ~CEventLogLastError() { }

private: // deliberately not implemented
    CEventLogLastError(const CEventLogLastError&);
    void operator=(const CEventLogLastError&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

inline CEventLogInteger::CEventLogInteger(LONGLONG i)
{
    _i64tow(i, m_rgchBuffer, 10);
    Sync();
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

inline CEventLogHex::CEventLogHex(LONGLONG i)
{
    m_rgchBuffer[0] = '0';
    m_rgchBuffer[1] = 'x';
    _i64tow(i, &m_rgchBuffer[2], 16);
    // CONSIDER _wcsupr(m_psz+2);
    Sync();
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

inline CEventLogHResult::CEventLogHResult(HRESULT hr)
{
    Format(L"hr = %#08lx", static_cast<ULONG>(hr));
}

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogProcessorArchitecture :
public CUnicodeStringN<MAX_PATH + sizeof(int)*CHAR_BIT + 3>
{
public:
    ~CEventLogProcessorArchitecture() { }

    explicit CEventLogProcessorArchitecture(USHORT usProcessorArchitecture)
    {
        CSmallStringBuffer buffer;
        ::FusionpFormatProcessorArchitecture(usProcessorArchitecture, buffer);
        this->Format(L"%d(%ls)", usProcessorArchitecture, static_cast<PCWSTR>(buffer));
    }

private:
    // deliberately not implemented
    CEventLogProcessorArchitecture();
    CEventLogProcessorArchitecture(const CEventLogProcessorArchitecture&);
    void operator=(const CEventLogProcessorArchitecture&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogAssemblyVersion : public CUnicodeStringN<4*sizeof(unsigned)*CHAR_BIT+4>
{
public:
    ~CEventLogAssemblyVersion() { }

    explicit CEventLogAssemblyVersion(const ASSEMBLY_VERSION& av)
    {
        unsigned major = av.Major;
        unsigned minor = av.Minor;
        unsigned revision = av.Revision;
        unsigned build = av.Build;
        Format(L"%u.%u.%u.%u", major, minor, revision, build);
    }

private:  // deliberately not implemented
    CEventLogAssemblyVersion();
    CEventLogAssemblyVersion(const CEventLogAssemblyVersion&);
    void operator=(const CEventLogAssemblyVersion&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogLanguageName : public CUnicodeString
{
private:
    typedef CUnicodeString base;
public:
    ~CEventLogLanguageName() { }

    explicit CEventLogLanguageName(LANGID languageId)
    {
        ::FusionpFormatEnglishLanguageName(languageId, m_buffer);
        (*this) = static_cast<PCWSTR>(m_buffer);
    }

    void operator=(PCWSTR sz)
    {
        base::operator=(sz);
    }

private:
    CSmallStringBuffer m_buffer;

    // deliberately not implemented
    CEventLogLanguageName();
    CEventLogLanguageName(const CEventLogLanguageName&);
    void operator=(const CEventLogLanguageName&);
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

class CEventLogFileCopyCallbackDisposition
{
public:
};

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------
--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionguiddatatoxxx.h ===
/*-----------------------------------------------------------------------------
Microsoft FUSION

Microsoft Confidential
Copyright (c) Microsoft Corporation. All Rights Reserved.

@doc external
@module fusionguiddatatoxxx.h

Macros to convert "guid data", of the
form (3f32766f, 2d94, 444d, bf,32,2f,32,9c,71,d4,08), to all of the various
needed forms:
  3f32766f-2d94-444d-bf32-2f329c71d408                               FUSIONP_GUID_DATA_TO_DASHED
 '3f32766f-2d94-444d-bf32-2f329c71d408'                              FUSIONP_GUID_DATA_TO_DASHED_CHAR
 "3f32766f-2d94-444d-bf32-2f329c71d408"                              FUSIONP_GUID_DATA_TO_DASHED_STRING
 {3f32766f-2d94-444d-bf32-2f329c71d408}                              FUSIONP_GUID_DATA_TO_BRACED_DASHED
'{3f32766f-2d94-444d-bf32-2f329c71d408}'                             FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR
"{3f32766f-2d94-444d-bf32-2f329c71d408}"                             FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING
{0x3f32766f,0x2d94,0x444d,{0xbf,0x32,0x2f,0x32,0x9c,0x71,0xd4,0x08}} FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(FUSIONP_GUID_DATA_TO_XXX_H_INCLUDED_)
#define FUSIONP_GUID_DATA_TO_XXX_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "fusionpreprocessorpaste.h"
#include "fusionpreprocessorstringize.h"
#include "fusionpreprocessorcharize.h"

/*-----------------------------------------------------------------------------
I need to investigate more, but present usage is:

FUSIONP_GUID_DATA_TO_DASHED_STRING : __declpec(uuid())
FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING : also works with__declpec(uuid())
FUSIONP_GUID_DATA_TO_BRACED_DASHED : in .rgs files (unquoted)
FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER : would be used in .ctc files
FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR : used in .rgs files (quoted)

-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER
@macro
This macro does like:
FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> { 0x80f3e6ba, 0xd9b2, 0x4c41, { 0xae, 0x90, 0x63, 0x93, 0xda, 0xce, 0xac, 0x2a } }

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER\
( \
	dwData1,  \
	 wData2,  \
	 wData3,  \
	bData4_0, \
	bData4_1, \
	bData4_2, \
	bData4_3, \
	bData4_4, \
	bData4_5, \
	bData4_6, \
	bData4_7  \
) \
{ \
	FusionpPreprocessorPaste2(0x, dwData1), \
	FusionpPreprocessorPaste2(0x,  wData2), \
	FusionpPreprocessorPaste2(0x,  wData3), \
	{ \
		FusionpPreprocessorPaste2(0x, bData4_0), \
		FusionpPreprocessorPaste2(0x, bData4_1), \
		FusionpPreprocessorPaste2(0x, bData4_2), \
		FusionpPreprocessorPaste2(0x, bData4_3), \
		FusionpPreprocessorPaste2(0x, bData4_4), \
		FusionpPreprocessorPaste2(0x, bData4_5), \
		FusionpPreprocessorPaste2(0x, bData4_6), \
		FusionpPreprocessorPaste2(0x, bData4_7)  \
	} \
}

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_DASHED
@macro
This macro does like:
FUSIONP_GUID_DATA_TO_DASHED(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> 80f3e6ba-d9b2-4c41-ae90-6393daceac2a

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_DASHED\
( \
	dwData1,  \
	 wData2,  \
	 wData3,  \
	bData4_0, \
	bData4_1, \
	bData4_2, \
	bData4_3, \
	bData4_4, \
	bData4_5, \
	bData4_6, \
	bData4_7  \
) \
FusionpPreprocessorPaste15(dwData1,-,wData2,-,wData3,-,bData4_0,bData4_1,-,bData4_2,bData4_3,bData4_4,bData4_5,bData4_6,bData4_7)

// without braces

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_DASHED_STRING
@macro
FUSIONP_GUID_DATA_TO_DASHED_STRING(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> "80f3e6ba-d9b2-4c41-ae90-6393daceac2a"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_DASHED_STRING\
( \
	dw1,  \
	 w2,  \
	 w3,  \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorStringize(FUSIONP_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_DASHED_CHAR
@macro
FUSIONP_GUID_DATA_TO_DASHED_CHAR(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> '80f3e6ba-d9b2-4c41-ae90-6393daceac2a'

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_DASHED_CHAR\
( \
	dw1,  \
	 w2,  \
	 w3,  \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorCharize(FUSIONP_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

// with braces

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_BRACED_DASHED
@macro
FUSIONP_GUID_DATA_TO_BRACED_DASHED(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> {80f3e6ba-d9b2-4c41-ae90-6393daceac2a}

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_BRACED_DASHED\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorPaste3({,FUSIONP_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7),})

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING
@macro
FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> "{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorStringize(FUSIONP_GUID_DATA_TO_BRACED_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING_W
@macro
FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING_W(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> L"{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING_W(dw1, w2, w3, b0, b1, b2, b3, b4, b5, b6, b7) \
	FusionpPreprocessorPaste(L, FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING(dw1, w2, w3, b0, b1, b2, b3, b4, b5, b6, b7))

/*-----------------------------------------------------------------------------
Name: FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR
@macro
FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> '{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}'

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayKrell
-----------------------------------------------------------------------------*/
#define \
FUSIONP_GUID_DATA_TO_BRACED_DASHED_CHAR\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	FusionpPreprocessorCharize(FUSIONP_GUID_DATA_TO_BRACED_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

#endif /* FUSIONP_GUID_DATA_TO_XXX_H_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionhandle.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    FusionHandle.h

Abstract:

    Simple exception safe wrappers of Win32 "handle" types, defining "handle" loosely.
        CFusionFile
        CDynamicLinkLibrary
        CFindFile (should be named CFindFileHandle, see NVseeLibIo::CFindFile vs. NVseeLibIo::CFindFileHandle
            CFindFile includes a WIN32_FIND_DATA, CFindFileHandle does not.)
        CFileMapping
        CMappedViewOfFile
        CRegKey
        CFusionSetupInfFile
    See also:
        NVseeLibReg::CRegKey
        NVseeLibIo::CFusionFile
        NVseeLibIo::CFileMapping
        NVseeLibIo::CMappedViewOfFile
        NVseeLibIo::CFindFullPath
        NVseeLibModule::CDynamicLinkLibrary
        etc.
 
Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#pragma once

#include "fusiontrace.h"
#include "fusionbuffer.h"
#include <wtypes.h>
#include <wincrypt.h>
#include <setupapi.h>

template <void* const* invalidValue, typename Closer>
class CHandleTemplate
{
public:
    // void* instead of HANDLE to fudge views
    // HANDLE is void*
    CHandleTemplate(const void* handle = *invalidValue);
    ~CHandleTemplate();
    BOOL Win32Close();
    void* Detach();
    void operator=(const void*);

    operator void*() const;
    operator const void*() const;

    // private
    class CSmartPointerPointerOrDumbPointerPointer
    {
    public:
        CSmartPointerPointerOrDumbPointerPointer(CHandleTemplate* p) : m(p) { }
        operator CHandleTemplate*() { return m; }
        operator void**() { /*assert((**m).m_handle == *invalidValue);*/ return &(*m).m_handle; }
        operator HKEY*() { /*assert((**m).m_handle == *invalidValue);*/
            //compiler bug? m->operator HKEY(); // only allow this to compile for CFusionRegKey
            //static_cast<HKEY>(*m);
            static_cast<CRegKey*>(m);
            return reinterpret_cast<HKEY*>(operator void**()); }
        operator HCRYPTHASH*() {
            static_cast<CCryptHash*>(m);
            return reinterpret_cast<HCRYPTHASH*>(operator void**()); }
        operator HMODULE*() {
            static_cast<CDynamicLinkLibrary*>(m);
            return reinterpret_cast<HMODULE*>(operator void**()); }

        CHandleTemplate* m;
    };

    CSmartPointerPointerOrDumbPointerPointer operator&() { return CSmartPointerPointerOrDumbPointerPointer(this); }

    void* m_handle;

    static void* GetInvalidValue() { return *invalidValue; }
    bool IsValid() const { return m_handle != *invalidValue; }

private:
    CHandleTemplate(const CHandleTemplate&); // deliberately not implemented
    void operator=(const CHandleTemplate&); // deliberately not implemented
};

__declspec(selectany) extern void* const hInvalidValue    = INVALID_HANDLE_VALUE;
__declspec(selectany) extern void* const hNull            = NULL;

/* This closes a Win32 event log handle for writing. */
class COperatorDeregisterEventSource
{
public:    BOOL operator()(void* handle) const;
};

/* This closes a Win32 event log handle for reading. */
class COperatorCloseEventLog
{
public:    BOOL operator()(void* handle) const;
};

/* This closes file, event, mutex, semaphore, etc. kernel objects */
class COperatorCloseHandle
{
public:    BOOL operator()(void* handle) const;
};

//
// Closes HCRYPTHASH objects
//
class COperatorCloseCryptHash
{
public:    BOOL operator()(void* handle) const;
};

/* this closes FindFirstFile/FindNextFile */
class COperatorFindClose
{
public:    BOOL operator()(void* handle) const;
};

/* this closes MapViewOfFile */
class COperatorUnmapViewOfFile
{
public: BOOL operator()(void* handle) const;
};

/* this closes FreeLibrary */
class COperatorFreeLibrary
{
public: BOOL operator()(void* handle) const;
};

/* this closes CreateActCtx/AddRefActCtx */
class COperatorReleaseActCtx
{
public: BOOL operator()(void* handle) const;
};

/* this closes  SetupOpenInfFile  */
class COperatorSetupCloseInfFile
{
public: BOOL operator()(void* handle) const;
};

#include "fusionreg.h"

class CEvent : public CHandleTemplate<&hNull, COperatorCloseHandle>
{
private:
    typedef CHandleTemplate<&hNull, COperatorCloseHandle> Base;
public:
    CEvent(void* handle = NULL) : Base(handle) { }

    BOOL Win32CreateEvent(BOOL ManualReset, BOOL InitialState, PCWSTR Name = NULL);

    void operator=(void* v) { Base::operator=(v); }

private:
    CEvent(const CEvent &); // intentionally not implemented
    void operator =(const CEvent &); // intentionally not implemented
};

class CThread : public CHandleTemplate<&hNull, COperatorCloseHandle>
{
private:
    typedef CHandleTemplate<&hNull, COperatorCloseHandle> Base;
public:
    CThread(void* handle = NULL) : Base(handle) { }

    BOOL Win32CreateThread(LPTHREAD_START_ROUTINE StartAddress, LPVOID Parameter, DWORD Flags = 0, LPDWORD ThreadId = NULL);

    void operator=(void* v) { Base::operator=(v); }

private:
    CThread(const CThread &); // intentionally not implemented
    void operator =(const CThread &); // intentionally not implemented
};

class CFindFile : public CHandleTemplate<&hInvalidValue, COperatorFindClose>
{
private:
    typedef CHandleTemplate<&hInvalidValue, COperatorFindClose> Base;
public:
    CFindFile(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }
    HRESULT HrFindFirstFile(PCSTR nameOrWildcard, WIN32_FIND_DATAA*);
    HRESULT HrFindFirstFile(PCWSTR nameOrWildcard, WIN32_FIND_DATAW*);
    BOOL Win32FindFirstFile( PCSTR nameOrWildcard, WIN32_FIND_DATAA*);
    BOOL Win32FindFirstFile(PCWSTR nameOrWildcard, WIN32_FIND_DATAW*);
    void operator=(void* v) { Base::operator=(v); }

private:
    CFindFile(const CFindFile &); // intentionally not implemented
    void operator =(const CFindFile &); // intentionally not implemented
};

class CFusionFile : public CHandleTemplate<&hInvalidValue, COperatorCloseHandle>
{
private:
    typedef CHandleTemplate<&hInvalidValue, COperatorCloseHandle> Base;

public:
    CFusionFile(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }
    HRESULT HrCreateFile( PCSTR name, DWORD access, DWORD share, DWORD openOrCreate);
    HRESULT HrCreateFile(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate);
    BOOL Win32CreateFile( PCSTR name, DWORD access, DWORD share, DWORD openOrCreate);
    BOOL Win32CreateFile(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate);
    BOOL Win32GetSize(ULONGLONG &rulSize) const;
    void operator=(void* v) { Base::operator=(v); }

private:
    CFusionFile(const CFusionFile &); // intentionally not implemented
    void operator =(const CFusionFile &); // intentionally not implemented
};

class CFileMapping : public CHandleTemplate<&hNull, COperatorCloseHandle>
{
private:
    typedef CHandleTemplate<&hNull, COperatorCloseHandle> Base;
public:
    CFileMapping(void* handle = NULL) : Base(handle) { }
    HRESULT HrCreateFileMapping(void* file, DWORD flProtect, ULONGLONG maximumSize=0, PCWSTR name=0);
    BOOL Win32CreateFileMapping(void* file, DWORD flProtect, ULONGLONG maximumSize=0, PCWSTR name=0);
    void operator=(void* v) { Base::operator=(v); }
private:
    CFileMapping(const CFileMapping &); // intentionally not implemented
    void operator =(const CFileMapping &); // intentionally not implemented
};

class CCryptHash : public CHandleTemplate<&hNull, COperatorCloseCryptHash>
{
private:
    typedef CHandleTemplate<&hNull, COperatorCloseCryptHash> Base;
public:
    CCryptHash( HCRYPTHASH hash = NULL ) : Base((void*)hash) { }
    operator HCRYPTHASH() { return (HCRYPTHASH)(Base::operator void*()); }
    void operator=(HCRYPTHASH hash) { 
        ASSERT_NTC(!IsValid());
        m_handle = (void*)hash;
    }

private:
    CCryptHash( const CCryptHash & );
    CCryptHash &operator=( const CCryptHash & );
};


class CMappedViewOfFile : public CHandleTemplate<&hNull, COperatorUnmapViewOfFile>
{
private:
    typedef CHandleTemplate<&hNull, COperatorUnmapViewOfFile> Base;
public:
    CMappedViewOfFile(void* handle = NULL) : Base(handle) { }
    HRESULT HrMapViewOfFile(void* fileMapping, DWORD access, ULONGLONG offset=0, SIZE_T size=0);
    BOOL Win32MapViewOfFile(void* fileMapping, DWORD access, ULONGLONG offset=0, SIZE_T size=0);
    void operator=(void* v) { Base::operator=(v); }
    operator void*()        { return Base::operator void*(); }
private:
    CMappedViewOfFile(const CMappedViewOfFile &); // intentionally not implemented
    void operator =(const CMappedViewOfFile &); // intentionally not implemented
    operator void*() const; // intentionally not implemented
};

class CDynamicLinkLibrary : public CHandleTemplate<&hNull, COperatorFreeLibrary>
{
private:
    typedef CHandleTemplate<&hNull, COperatorFreeLibrary> Base;
public:
    CDynamicLinkLibrary(void* handle = NULL) : Base(handle) { }

    BOOL Win32LoadLibrary(PCWSTR file, DWORD flags = 0);

    template <typename PointerToFunction>
    bool Win32GetProcAddress(PCSTR procName, PointerToFunction* ppfn)
    {
        return (*ppfn = reinterpret_cast<PointerToFunction>(::GetProcAddress(*this, procName))) != NULL;
    }

    operator HMODULE() { return reinterpret_cast<HMODULE>(operator void*()); }
    HMODULE Detach() { return reinterpret_cast<HMODULE>(Base::Detach()); }
    void operator=(void* v) { Base::operator=(v); }
private:
    CDynamicLinkLibrary(const CDynamicLinkLibrary &); // intentionally not implemented
    void operator =(const CDynamicLinkLibrary &); // intentionally not implemented
};

class CFusionActCtxHandle : public CHandleTemplate<&hInvalidValue, COperatorReleaseActCtx>
{
private:
    typedef CHandleTemplate<&hInvalidValue, COperatorReleaseActCtx> Base;
public:
    CFusionActCtxHandle(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }
    BOOL Win32Create(PCACTCTXW);
    void operator=(void* v) { Base::operator=(v); }
private:
    CFusionActCtxHandle(const CFusionActCtxHandle &); // intentionally not implemented
    void operator =(const CFusionActCtxHandle &); // intentionally not implemented
};

class CFusionActCtxScope
{
protected:
    BOOL        m_fSuccess;
    ULONG_PTR   m_ulCookie;
public:
    CFusionActCtxScope();
    ~CFusionActCtxScope();
    BOOL Win32Activate(HANDLE hActCtx);

private:
    CFusionActCtxScope(const CFusionActCtxScope &); // intentionally not implemented
    void operator =(const CFusionActCtxScope &); // intentionally not implemented
};


/*--------------------------------------------------------------------------
CFusionSetupInfFile
--------------------------------------------------------------------------*/

class CFusionSetupInfFile : public CHandleTemplate<&hInvalidValue, COperatorSetupCloseInfFile>
{
private:
    typedef CHandleTemplate<&hInvalidValue, COperatorSetupCloseInfFile> Base;
public:
    CFusionSetupInfFile(void* handle = INVALID_HANDLE_VALUE) : Base(handle) { }

    BOOL
    Win32SetupOpenInfFileW(
        PCWSTR FileName,
        PCWSTR InfClass, OPTIONAL
        DWORD InfStyle,
        PUINT ErrorLine OPTIONAL
        );

    //
    // HINF == PVOID so we don't need helpers like
    // CDynamicLinkLibrary has.
    //
    void operator=(void* v) { Base::operator=(v); }
private:
    CFusionSetupInfFile(const CFusionSetupInfFile &); // intentionally not implemented
    void operator =(const CFusionSetupInfFile &); // intentionally not implemented
};


inline
BOOL
CFusionSetupInfFile::Win32SetupOpenInfFileW(
    PCWSTR FileName, // name of the INF to open
    PCWSTR InfClass, // optional, the class of the INF file
    DWORD InfStyle,  // specifies the style of the INF file
    PUINT ErrorLine  // optional, receives error information
    )
{
    BOOL fSuccess = FALSE;
    HINF hTemp = ::SetupOpenInfFileW(FileName, InfClass, InfStyle, ErrorLine);
    if (hTemp == INVALID_HANDLE_VALUE)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(SetupOpenInfFileW);
        goto Exit;
    }
    (*this) = hTemp;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

/*--------------------------------------------------------------------------
CFindFile
--------------------------------------------------------------------------*/

inline BOOL
CFindFile::Win32FindFirstFile(
    PCSTR nameOrWildcard,
    WIN32_FIND_DATAA *data
    )
{
    BOOL fSuccess = FALSE;

    HANDLE hTemp = ::FindFirstFileA(nameOrWildcard, data);
    if (hTemp == INVALID_HANDLE_VALUE)
    {
        goto Exit;
    }

    (*this) = hTemp;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline BOOL
CFindFile::Win32FindFirstFile(
    PCWSTR nameOrWildcard,
    WIN32_FIND_DATAW *data
    )
{
    BOOL fSuccess = FALSE;

    HANDLE hTemp = ::FindFirstFileW(nameOrWildcard, data);
    if (hTemp == INVALID_HANDLE_VALUE)
    {
        goto Exit;
    }

    (*this) = hTemp;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline
HRESULT
CFindFile::HrFindFirstFile(
    PCSTR nameOrWildcard,
    WIN32_FIND_DATAA *data
    )
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    if (!this->Win32FindFirstFile(nameOrWildcard, data))
    {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }
    hr = NOERROR;
Exit:
    return hr;
}

inline
HRESULT
CFindFile::HrFindFirstFile(
    PCWSTR nameOrWildcard,
    WIN32_FIND_DATAW* data
    )
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    if (!this->Win32FindFirstFile(nameOrWildcard, data))
    {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }
    hr = NOERROR;
Exit:
    return hr;
}

/*--------------------------------------------------------------------------
CFusionFile
--------------------------------------------------------------------------*/

inline BOOL
CFusionFile::Win32CreateFile(
    PCSTR name,
    DWORD access,
    DWORD share,
    DWORD openOrCreate
    )
{
    BOOL fSuccess = FALSE;
    HANDLE hTemp = ::CreateFileA(name, access, share, NULL, openOrCreate, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hTemp == INVALID_HANDLE_VALUE)
        goto Exit;
    operator=(hTemp);
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline BOOL
CFusionFile::Win32CreateFile(
    PCWSTR name,
    DWORD access,
    DWORD share,
    DWORD openOrCreate
    )
{
    BOOL fSuccess = FALSE;
    HANDLE hTemp = ::CreateFileW(name, access, share, NULL, openOrCreate, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hTemp == INVALID_HANDLE_VALUE)
        goto Exit;
    operator=(hTemp);
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline HRESULT CFusionFile::HrCreateFile(PCSTR name, DWORD access, DWORD share, DWORD openOrCreate)
{
    if (!this->Win32CreateFile(name, access, share, openOrCreate))
        return HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
    return NOERROR;
}

inline HRESULT CFusionFile::HrCreateFile(PCWSTR name, DWORD access, DWORD share, DWORD openOrCreate)
{
    if (!this->Win32CreateFile(name, access, share, openOrCreate))
        return HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
    return NOERROR;
}

inline BOOL
CFusionFile::Win32GetSize(ULONGLONG &rulSize) const
{
    DWORD highPart = 0;
    DWORD lastError = NO_ERROR;
    DWORD lowPart = ::GetFileSize(m_handle, &highPart);
    if (lowPart == INVALID_FILE_SIZE && (lastError = ::FusionpGetLastWin32Error()) != NO_ERROR)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(GetFileSize);
        return FALSE;
    }
    ULARGE_INTEGER liSize;
    liSize.LowPart = lowPart;
    liSize.HighPart = highPart;
    rulSize = liSize.QuadPart;
    return TRUE;
}

/*--------------------------------------------------------------------------
CFileMapping
--------------------------------------------------------------------------*/

inline HRESULT
CFileMapping::HrCreateFileMapping(void* file, DWORD flProtect, ULONGLONG maximumSize, PCWSTR name)
{
    LARGE_INTEGER liMaximumSize;
    liMaximumSize.QuadPart = maximumSize;
    HANDLE hTemp = ::CreateFileMappingW(file, NULL, flProtect, liMaximumSize.HighPart, liMaximumSize.LowPart, name);
    if (hTemp == NULL)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(CreateFileMapping);
        return HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
    }
    operator=(hTemp);
    return S_OK;
}

inline BOOL
CFileMapping::Win32CreateFileMapping(
    void* file,
    DWORD flProtect,
    ULONGLONG maximumSize,
    PCWSTR name
    )
{
    return SUCCEEDED(this->HrCreateFileMapping(file, flProtect, maximumSize, name));
}

/*--------------------------------------------------------------------------
CMappedViewOfFile
--------------------------------------------------------------------------*/

inline HRESULT
CMappedViewOfFile::HrMapViewOfFile(
    void* fileMapping,
    DWORD access,
    ULONGLONG offset,
    SIZE_T size
    )
{
    ULARGE_INTEGER liOffset;
    liOffset.QuadPart = offset;

    void* pvTemp = ::MapViewOfFile(fileMapping, access, liOffset.HighPart, liOffset.LowPart, size);
    if (pvTemp == NULL)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(MapViewOfFile);
        return HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
    }

    (*this) = pvTemp;

    return S_OK;
}

inline BOOL
CMappedViewOfFile::Win32MapViewOfFile(void* fileMapping, DWORD access, ULONGLONG offset, SIZE_T size)
{
    return SUCCEEDED(this->HrMapViewOfFile(fileMapping, access, offset, size));
}

/*--------------------------------------------------------------------------
CEvent
--------------------------------------------------------------------------*/

inline BOOL CEvent::Win32CreateEvent(BOOL ManualReset, BOOL InitialState, PCWSTR Name)
{
    HANDLE Temp = ::CreateEventW(NULL, ManualReset, InitialState, Name);
    if (Temp == NULL)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(CreateEventW);
        return FALSE;
    }
    (*this) = Temp;
    return TRUE;
}

/*--------------------------------------------------------------------------
CThread
--------------------------------------------------------------------------*/
inline BOOL
CThread::Win32CreateThread(
    LPTHREAD_START_ROUTINE StartAddress,
    LPVOID Parameter,
    DWORD Flags,
    LPDWORD ThreadId
    )
{
    DWORD LocalThreadId;
    if (ThreadId == NULL)
        ThreadId = &LocalThreadId;
    HANDLE Temp = ::CreateThread(NULL, 0, StartAddress, Parameter, Flags, ThreadId);
    if (Temp == NULL)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(CreateThread);
        return FALSE;
    }
    (*this) = Temp;
    return TRUE;
}

/*--------------------------------------------------------------------------
CDynamicLinkLibrary
--------------------------------------------------------------------------*/
inline BOOL
CDynamicLinkLibrary::Win32LoadLibrary(
    PCWSTR file,
    DWORD flags
    )
{
    void* temp = ::LoadLibraryExW(file, NULL, flags);
    if (temp == NULL)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(LoadLibraryExW);
        return FALSE;
    }
    (*this) = temp;
    return TRUE;
}

/*--------------------------------------------------------------------------
CFusionActCtxHandle
--------------------------------------------------------------------------*/
inline BOOL
CFusionActCtxHandle::Win32Create(
    PCACTCTXW pActCtx
    )
{
    typedef HANDLE (WINAPI* PFN)(PCACTCTXW pActCtx);
    static PFN pfn;
    if (pfn == NULL)
    {
        HMODULE hmodKernel32 = ::GetModuleHandleW(L"Kernel32.dll");
        if (hmodKernel32 != NULL)
        {
            pfn = reinterpret_cast<PFN>(::GetProcAddress(hmodKernel32, "CreateActCtxW"));
            if (pfn == NULL)
                TRACE_WIN32_FAILURE_ORIGINATION(GetProcAddress);
        }
        else
            TRACE_WIN32_FAILURE_ORIGINATION(GetModuleHandleW);

        if (pfn == NULL)
            return FALSE;
    }
    void* temp = (*pfn)(pActCtx);
    if (temp == INVALID_HANDLE_VALUE)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(CreateActCtxW);
        return FALSE;
    }
    (*this) = temp;
    return TRUE;
}

inline BOOL COperatorReleaseActCtx::operator()(HANDLE hActCtx) const
{
    typedef BOOL (WINAPI* PFN)(HANDLE);
    static PFN pfn;
    if (pfn == NULL)
    {
        HMODULE hmodKernel32 = ::GetModuleHandleW(L"Kernel32.dll");
        if (hmodKernel32 != NULL)
        {
            pfn = reinterpret_cast<PFN>(::GetProcAddress(hmodKernel32, "ReleaseActCtx"));
            if (pfn == NULL)
                TRACE_WIN32_FAILURE_ORIGINATION(GetProcAddress);
        }
        else
        {
            TRACE_WIN32_FAILURE_ORIGINATION(GetModuleHandleW);
        }
        if (pfn == NULL)
            return FALSE;
    }
    return pfn(hActCtx);
}

/*--------------------------------------------------------------------------
CFusionActCtxScope
--------------------------------------------------------------------------*/

inline CFusionActCtxScope::CFusionActCtxScope() : m_fSuccess(FALSE) { }

inline BOOL CFusionActCtxScope::Win32Activate(HANDLE hActCtx)
{
    typedef BOOL (WINAPI* PFN)(HANDLE hActCtx, ULONG_PTR* lpCookie);
    static PFN pfn;
    if (pfn == NULL)
    {
        HMODULE hmodKernel32 = ::GetModuleHandleW(L"Kernel32.dll");
        if (hmodKernel32 != NULL)
        {
            pfn = reinterpret_cast<PFN>(GetProcAddress(hmodKernel32, "ActivateActCtx"));
            if (pfn == NULL)
                TRACE_WIN32_FAILURE_ORIGINATION(GetProcAddress);
        }
        else
        {
            TRACE_WIN32_FAILURE_ORIGINATION(GetModuleHandleW);
        }

        if (pfn == NULL)
            return FALSE;
    }
    return (m_fSuccess = pfn(hActCtx, &m_ulCookie));
}

inline CFusionActCtxScope::~CFusionActCtxScope()
{
    if (m_fSuccess)
    {
        CSxsPreserveLastError ple;
        m_fSuccess = FALSE;
        typedef BOOL (WINAPI* PFN)(DWORD dwFlags, ULONG_PTR ulCookie);
        static PFN pfn;

        if (pfn == NULL)
        {
            HMODULE hmodKernel32 = GetModuleHandleW(L"Kernel32.dll");
            if (hmodKernel32 != NULL)
            {
                pfn = reinterpret_cast<PFN>(GetProcAddress(hmodKernel32, "DeactivateActCtx"));
                if (pfn == NULL)
                    TRACE_WIN32_FAILURE_ORIGINATION(GetProcAddress);
            }
            else
            {
                TRACE_WIN32_FAILURE_ORIGINATION(GetModuleHandleW);
            }

            if (pfn == NULL)
            {
                ple.Restore();
                return;
            }
        }
        (*pfn)(0, m_ulCookie);
        ple.Restore();
    }
}

/*--------------------------------------------------------------------------
COperator*
--------------------------------------------------------------------------*/

inline BOOL COperatorCloseHandle::operator()(void* handle) const { return ::CloseHandle(handle); }
inline BOOL COperatorFindClose::operator()(void* handle) const { return ::FindClose(handle); }
inline BOOL COperatorUnmapViewOfFile::operator()(void* handle) const { return ::UnmapViewOfFile(handle); }
inline BOOL COperatorCloseEventLog::operator()(void* handle) const { return ::CloseEventLog(handle); }
inline BOOL COperatorDeregisterEventSource::operator()(void* handle) const { return ::DeregisterEventSource(handle); }
inline BOOL COperatorFreeLibrary::operator()(void* handle) const { return ::FreeLibrary(reinterpret_cast<HMODULE>(handle)); }
inline BOOL COperatorCloseCryptHash::operator()(void* handle) const { return ::CryptDestroyHash(reinterpret_cast<HCRYPTHASH>(handle)); };
inline BOOL COperatorSetupCloseInfFile::operator()(void* handle) const { SetupCloseInfFile(handle); return TRUE; };

/*--------------------------------------------------------------------------
CHandleTemplate
--------------------------------------------------------------------------*/

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::CHandleTemplate(const void* handle)
: m_handle(const_cast<void*>(handle))
{
}

template <void* const* invalidValue, typename Closer>
void* CHandleTemplate<invalidValue, Closer>::Detach()
{
    void* handle = m_handle;
    m_handle = *invalidValue;
    return handle;
}

template <void* const* invalidValue, typename Closer>
void CHandleTemplate<invalidValue, Closer>::operator=(const void* handle)
{
    if (handle != m_handle)
    {
        void *SavedHandle = m_handle;
        m_handle = const_cast<void*>(handle);

        if (SavedHandle != *invalidValue)
        {
            Closer close;
            // a bug waiting to happen to customers
            VERIFY_NTC(close(SavedHandle));
        }
    }
}

template <void* const* invalidValue, typename Closer>
BOOL CHandleTemplate<invalidValue, Closer>::Win32Close()
{
    void* handle = Detach();
    if (handle != *invalidValue)
    {
        Closer close;
        return close(handle);
    }
    return TRUE;
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::~CHandleTemplate()
{
    CSxsPreserveLastError ple;
    (void) this->Win32Close();
    ple.Restore();
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::operator void*() const
{
    return m_handle;
}

template <void* const* invalidValue, typename Closer>
CHandleTemplate<invalidValue, Closer>::operator const void*() const
{
    return m_handle;
}

/*--------------------------------------------------------------------------
end of file
--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionguids.h ===
// Copyright (c) Microsoft Corporation
/*
All guids appear in this file, and only once.
No guids appear anywhere else.
All forms of guids can be generated from this file, using the
  macros in fusionguiddatatoxxx.h.
This helps greatly in the ability to reguid.
*/

#if !defined(FUSION_GUIDS_H_INCLUDED_)
#define FUSION_GUIDS_H_INCLUDED_
/* no #pragma once here, deliberately, to not mess up preprocessed files that aren't C/C++ */

#include "fusionguiddatatoxxx.h"
#if defined(__midl)
cpp_quote("#if !defined(FUSION_GUIDS_H_INCLUDED_)")
cpp_quote("#include \"fusionguids.h\"")
cpp_quote("#endif")
#endif

#define IID_IUnknown_data                       (00000000, 0000, 0000, C0, 00, 00, 00, 00, 00, 00, 46)

#define IID_ISxsTest_FreeThreaded_data          (f0554958, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define IID_ISxsTest_SingleThreaded_data        (f0554959, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define IID_ISxsTest_ApartmentThreaded_data     (f055495a, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_FreeThreaded_data        (f055495b, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_SingleThreaded_data      (f055495c, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_ApartmentThreaded_data   (f055495e, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define LIBID_SxsTest_Lib_data                  (f055495f, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define IID_ISxsTest_BothThreaded_data          (f0554960, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_BothThreaded_data        (f0554961, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define IID_ISxsTest_SingleThreadedDual_data    (f0554962, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)
#define CLSID_CSxsTest_SingleThreadedDual_data  (f0554963, aef2, 11d5, a2, 72, 00, 30, 48, 21, 53, 71)

#define OLEAUT_IDISPATCH_PROXY_STUB_CLSID_data  (00020420, 0000, 0000, C0, 00, 00, 00, 00, 00, 00, 46)
#define OLEAUT_PROXY_STUB_CLSID_data            (00020424, 0000, 0000, C0, 00, 00, 00, 00, 00, 00, 46)

/*----------------------------------------------------------------------------------------------------*/

#define IID_ISxsTest_FreeThreaded_midl                  FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_FreeThreaded_data
#define IID_ISxsTest_SingleThreaded_midl                FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_SingleThreaded_data
#define IID_ISxsTest_ApartmentThreaded_midl             FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_ApartmentThreaded_data
#define CLSID_CSxsTest_FreeThreaded_midl                FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_FreeThreaded_data
#define CLSID_CSxsTest_SingleThreaded_midl              FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_SingleThreaded_data
#define CLSID_CSxsTest_ApartmentThreaded_midl           FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_ApartmentThreaded_data
#define LIBID_SxsTest_Lib_midl                          FUSIONP_GUID_DATA_TO_DASHED LIBID_SxsTest_Lib_data
#define IID_ISxsTest_BothThreaded_midl                  FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_BothThreaded_data
#define CLSID_CSxsTest_BothThreaded_midl                FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_BothThreaded_data

#define IID_ISxsTest_FreeThreaded_rgs                   FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_FreeThreaded_data
#define IID_ISxsTest_SingleThreaded_rgs                 FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_SingleThreaded_data
#define IID_ISxsTest_ApartmentThreaded_rgs              FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_ApartmentThreaded_data
#define CLSID_CSxsTest_FreeThreaded_rgs                 FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_FreeThreaded_data
#define CLSID_CSxsTest_SingleThreaded_rgs               FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_SingleThreaded_data
#define CLSID_CSxsTest_ApartmentThreaded_rgs            FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_ApartmentThreaded_data
#define LIBID_SxsTest_Lib_rgs                           FUSIONP_GUID_DATA_TO_BRACED_DASHED LIBID_SxsTest_Lib_data
#define IID_ISxsTest_BothThreaded_rgs                   FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_BothThreaded_data
#define CLSID_CSxsTest_BothThreaded_rgs                 FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_BothThreaded_data

#define IID_ISxsTest_SingleThreaded_manifest            FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING IID_ISxsTest_SingleThreaded_data
#define LIBID_SxsTest_Lib_manifest                      FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING LIBID_SxsTest_Lib_data
#define IID_IUnknown_manifest                           FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING IID_IUnknown_data
#define CLSID_CSxsTest_SingleThreaded_manifest          FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING CLSID_CSxsTest_SingleThreaded_data

#define IID_ISxsTest_SingleThreadedDual_midl            FUSIONP_GUID_DATA_TO_DASHED IID_ISxsTest_SingleThreadedDual_data
#define CLSID_CSxsTest_SingleThreadedDual_midl          FUSIONP_GUID_DATA_TO_DASHED CLSID_CSxsTest_SingleThreadedDual_data
#define IID_ISxsTest_SingleThreadedDual_rgs             FUSIONP_GUID_DATA_TO_BRACED_DASHED IID_ISxsTest_SingleThreadedDual_data
#define CLSID_CSxsTest_SingleThreadedDual_rgs           FUSIONP_GUID_DATA_TO_BRACED_DASHED CLSID_CSxsTest_SingleThreadedDual_data
#define IID_ISxsTest_SingleThreadedDual_manifest        FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING IID_ISxsTest_SingleThreadedDual_data
#define CLSID_CSxsTest_SingleThreadedDual_manifest      FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING CLSID_CSxsTest_SingleThreadedDual_data

#define OLEAUT_PROXY_STUB_CLSID_manifest                FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING OLEAUT_PROXY_STUB_CLSID_data
#define OLEAUT_PROXY_STUB_CLSID_structInit              FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER   OLEAUT_PROXY_STUB_CLSID_data
#define OLEAUT_IDISPATCH_PROXY_STUB_CLSID_manifest      FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING OLEAUT_IDISPATCH_PROXY_STUB_CLSID_data
#define OLEAUT_IDISPATCH_PROXY_STUB_CLSID_structInit    FUSIONP_GUID_DATA_TO_STRUCT_INITIALIZER   OLEAUT_IDISPATCH_PROXY_STUB_CLSID_data

#define CLSID_CSxsTest_BothThreaded_manifest           FUSIONP_GUID_DATA_TO_BRACED_DASHED_STRING CLSID_CSxsTest_BothThreaded_data

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionheap.h ===
#if !defined(FUSION_INC_FUSIONHEAP_H_INCLUDED_)
#define FUSION_INC_FUSIONHEAP_H_INCLUDED_

#pragma once

#include "debmacro.h"
#include "SxsExceptionHandling.h"
#include "fusionunused.h"
#include "fusionlastwin32error.h"

#if !defined(FUSION_DISABLE_DEBUG_HEAP_ON_WIN98)
#if DBG
#if defined(FUSION_DEBUG_HEAP)
#undef FUSION_DEBUG_HEAP
#endif // defined(FUSION_DEBUG_HEAP)
#define FUSION_DEBUG_HEAP 1
#endif // DBG
#else
#undef FUSION_DEBUG_HEAP
#endif

//
//  We allocate FUSION_ARRAY_PREFIX_LENGTH extra bytes at
//  the beginning of array allocations to store the number of
//  elements in the array.
//

#define FUSION_ARRAY_PREFIX_LENGTH (sizeof(void*)*2)

C_ASSERT(FUSION_ARRAY_PREFIX_LENGTH >= sizeof(SIZE_T));

EXTERN_C
BOOL
FusionpInitializeHeap(
    HINSTANCE hInstance
    );

EXTERN_C
VOID
FusionpUninitializeHeap();

// Unique type so that we can overload operator new and delete and not
// have ambiguity with the fact that HANDLE == PVOID.

typedef struct _FUSION_HEAP_HANDLE_FAKE_STRUCT *FUSION_HEAP_HANDLE;

EXTERN_C FUSION_HEAP_HANDLE g_hHeap;
#define FUSION_DEFAULT_PROCESS_HEAP() (g_hHeap)

#if FUSION_DEBUG_HEAP

EXTERN_C FUSION_HEAP_HANDLE g_hDebugInfoHeap;
EXTERN_C LONG g_FusionHeapAllocationCount;
EXTERN_C LONG g_FusionHeapAllocationToBreakOn;

#define FUSION_HEAP_ALLOCATION_FREED_WHEN_DLL_UNLOADED (0x00000001)
#define FUSION_HEAP_DO_NOT_REPORT_LEAKED_ALLOCATION (0x00000002)

typedef struct _FUSION_HEAP_ALLOCATION_TRACKER *PFUSION_HEAP_ALLOCATION_TRACKER;

#if defined(_WIN64)
#define FUSION_HEAP_ALIGNMENT         16 /* 2*sizeof(void*) but __declspec(align()) doesn't like that */
#else
#define FUSION_HEAP_ALIGNMENT         8  /* 2*sizeof(void*) but __declspec(align()) doesn't like that */
#endif
#define FUSION_HEAP_ALIGNMENT_MINUS_1 (FUSION_HEAP_ALIGNMENT - 1)
#define FUSION_HEAP_ROUND_SIZE(_x)    (((_x) + FUSION_HEAP_ALIGNMENT_MINUS_1) & ~FUSION_HEAP_ALIGNMENT_MINUS_1)

C_ASSERT(FUSION_ARRAY_PREFIX_LENGTH >= FUSION_HEAP_ALIGNMENT);
C_ASSERT((FUSION_ARRAY_PREFIX_LENGTH % FUSION_HEAP_ALIGNMENT) == 0);

typedef struct DECLSPEC_ALIGN(FUSION_HEAP_ALIGNMENT) _FUSION_HEAP_PREFIX
{
    union
    {
        PFUSION_HEAP_ALLOCATION_TRACKER Tracker;
        void* InterlockedAlignment[2];
    };
} FUSION_HEAP_PREFIX, *PFUSION_HEAP_PREFIX;

typedef struct DECLSPEC_ALIGN(FUSION_HEAP_ALIGNMENT) _FUSION_HEAP_ALLOCATION_TRACKER
{
    PFUSION_HEAP_PREFIX Prefix;
    FUSION_HEAP_HANDLE Heap;
    size_t AllocationSize;
    size_t RequestedSize;
    PCSTR FileName;
    PCSTR Expression;
    LONG SequenceNumber;
    INT Line;
    DWORD Flags;
    // We have to track this here because someone could change the global setting while the dll is running
    PUCHAR PostAllocPoisonArea;
    UCHAR PostAllocPoisonChar;
    ULONG PostAllocPoisonBytes;
#if FUSION_ENABLE_FROZEN_STACK
    PVOID pvFrozenStack;
#endif
} FUSION_HEAP_ALLOCATION_TRACKER, *PFUSION_HEAP_ALLOCATION_TRACKER;

PVOID
FusionpDbgHeapAlloc(
    FUSION_HEAP_HANDLE hHeap,
    DWORD dwHeapAllocFlags,
    SIZE_T cb,
    PCSTR pszFile,
    INT nLine,
    PCSTR pszExpression,
    DWORD dwFusionFlags
    );

PVOID
FusionpDbgHeapReAlloc(
    FUSION_HEAP_HANDLE hHeap,
    DWORD dwHeapReAllocFlags,
    PVOID lpMem,
    SIZE_T cb,
    PCSTR pszFile,
    INT nLine,
    PCSTR pszExpression,
    DWORD dwFusionFlags
    );

EXTERN_C
BOOL
FusionpDbgHeapFree(
    FUSION_HEAP_HANDLE hHeap,
    DWORD dwHeapFreeFlags,
    PVOID lpMem
    );

EXTERN_C
VOID
FusionpDeallocateTracker(
    PFUSION_HEAP_PREFIX p
    );

EXTERN_C
BOOL
FusionpEnableLeakTracking(
    BOOL Enable);

EXTERN_C
VOID *
FusionpGetFakeVTbl();


EXTERN_C
VOID
FusionpDontTrackBlk(
    VOID *pv
    );

#define FusionpHeapAllocEx(_hHeap, _dwFlags, _nBytes, _szExpr, _szFile, _nLine, _dwFusionHeapFlags) FusionpDbgHeapAlloc((_hHeap), (_dwFlags), (_nBytes), (_szFile), (_nLine), (_szExpr), (_dwFusionHeapFlags))
#define FusionpHeapReAllocEx(_hHeap, _dwFlags, _lpMem, _nBytes, _szExpr, _szFile, _nLine, _dwFusionHeapFlags) FusionpDbgHeapReAlloc((_hHeap), (_dwFlags), (_lpMem), (_nBytes), (_szFile), (_nLine), (_szExpr), (_dwFusionHeapFlags))
#define FusionpHeapFreeEx(_hHeap, _dwFlags, _lpMem) FusionpDbgHeapFree((_hHeap), (_dwFlags), (_lpMem))

#define FusionpHeapAlloc(_hHeap, _dwFlags, _nBytes) FusionpHeapAllocEx((_hHeap), (_dwFlags), (_nBytes), NULL, NULL, 0, 0)
#define FusionpHeapReAlloc(_hHeap, _dwFlags, _lpMem, _nBytes) FusionpHeapReAllocEx((_hHeap), (_dwFlags), (_lpMem), (_nBytes), NULL, NULL, 0, 0)
#define FusionpHeapFree(_hHeap, _dwFlags, _lpMem) FusionpHeapFreeEx((_hHeap), (_dwFlags), (_lpMem))

#define FUSION_HEAP_DISABLE_LEAK_TRACKING() do { ::FusionpEnableLeakTracking(FALSE); } while (0)
#define FUSION_HEAP_ENABLE_LEAK_TRACKING() do { ::FusionpEnableLeakTracking(TRUE); } while (0)

EXTERN_C
VOID
FusionpDumpHeap(
    PCWSTR PerLinePrefix
    );

#else // FUSION_DEBUG_HEAP

LPVOID
WINAPI
FusionpHeapAlloc(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN SIZE_T dwBytes
    );

LPVOID
WINAPI
FusionpHeapReAlloc(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpMem,
    IN SIZE_T dwBytes
    );

#define FusionpHeapFree HeapFree

#define FusionpHeapAllocEx(_hHeap, _dwFlags, _nBytes, _szExpr, _szFile, _nLine, _dwFusionHeapFlags) HeapAlloc((_hHeap), (_dwFlags), (_nBytes))
#define FusionpHeapReAllocEx(_hHeap, _dwFlags, _lpMem, _nBytes, _szExpr, _szFile, _nLine, _dwFusionHeapFlags) HeapReAlloc((_hHeap), (_dwFlags), (_lpMem), (_nBytes))
#define FusionpHeapFreeEx(_hHeap, _dwFlags, _lpMem) HeapFree((_hHeap), (_dwFlags), (_lpMem))

#define FUSION_HEAP_DISABLE_LEAK_TRACKING()
#define FUSION_HEAP_ENABLE_LEAK_TRACKING()

#endif // FUSION_DEBUG_HEAP

template <typename T> class CAllocator
{
public:
    static inline T *AllocateArray(FUSION_HEAP_HANDLE hHeap, PCSTR szFile, int nLine, PCSTR szExpression, DWORD dwWin32HeapFlags, SIZE_T cElements, DWORD dwFusionHeapFlags)
    {
        T *prgtResult = NULL;
        PVOID pv = ::FusionpHeapAllocEx(hHeap, dwWin32HeapFlags, FUSION_ARRAY_PREFIX_LENGTH + (sizeof(T) * cElements), szExpression, szFile, nLine, dwFusionHeapFlags);
        if (pv != NULL)
        {
            SIZE_T i;
            T *prgt = (T *) (((ULONG_PTR) pv) + FUSION_ARRAY_PREFIX_LENGTH);

            *((SIZE_T *) pv) = cElements;

            // Initialize each element by calling its constructing via the "normal" placement new.
            for (i=0; i<cElements; i++)
            {
                T *pt = new(&prgt[i]) T;
                ASSERT_NTC(pt == &prgt[i]);
                RETAIL_UNUSED(pt);
            }

            prgtResult = prgt;
        }

        return prgtResult;
    }

    static inline T *AllocateSingleton(FUSION_HEAP_HANDLE hHeap, PCSTR szFile, int nLine, PCSTR szExpression, DWORD dwWin32HeapFlags, DWORD dwFusionHeapFlags)
    {
        T *ptResult = NULL;
        PVOID pv = ::FusionpHeapAllocEx(hHeap, dwWin32HeapFlags, sizeof(T), szExpression, szFile, nLine, dwFusionHeapFlags);
        if (pv != NULL)
        {
            // Initialize calling its constructing via the "normal" placement new.
            T *pt = new(pv) T;
            ASSERT_NTC(pt == pv);
            ptResult = pt;
        }

        return ptResult;
    }

    static inline VOID DeallocateArray(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *prgt)
    {
        const DWORD _dwLastError = ::FusionpGetLastWin32Error();

        if (prgt != NULL)
        {
            // This thing had better be aligned...

            ASSERT_NTC((((ULONG_PTR) prgt) % FUSION_HEAP_ALIGNMENT) == 0);

            SIZE_T *pcElements = (SIZE_T *) (((ULONG_PTR) prgt) - FUSION_ARRAY_PREFIX_LENGTH);
            SIZE_T i;
            SIZE_T cElements = *pcElements;

            for (i=0; i<cElements; i++)
                prgt[i].~T();

            ::FusionpHeapFree(hHeap, dwWin32HeapFlags, pcElements);
        }

        ::FusionpSetLastWin32Error( _dwLastError );
    }

    static inline VOID DeallocateSingleton(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *pt)
    {
        const DWORD _dwLastError = ::FusionpGetLastWin32Error();

        if (pt != NULL)
        {
            pt->~T();
            ::FusionpHeapFree(hHeap, dwWin32HeapFlags, pt);
        }

        ::FusionpSetLastWin32Error( _dwLastError );
    }
};

template <typename T> inline void FusionpAllocateSingletonFromPrivateHeap(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *ptUnused, PCSTR szFile, int nLine, PCSTR szTypeName) { (ptUnused); return CAllocator<T>::AllocateSingleton(hHeap, szFile, nLine, szTypeName, 0, 0); }
template <typename T> inline void FusionpAllocateArrayFromPrivateHeap(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, SIZE_T cElements, T *ptUnused, PCSTR szFile, int nLine, PCSTR szTypeName) { (ptUnused); return CAllocator<T>::AllocateArray(hHeap, szFile, nLine, szTypeName, 0, cElements, 0); }
template <typename T> inline void FusionpDeleteArrayFromPrivateHeap(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *prgt) { CAllocator<T>::DeallocateArray(hHeap, dwWin32HeapFlags, prgt); }

template <typename T> inline void FusionpDeleteSingletonFromPrivateHeap(FUSION_HEAP_HANDLE hHeap, DWORD dwWin32HeapFlags, T *pt) { CAllocator<T>::DeallocateSingleton(hHeap, dwWin32HeapFlags, pt); }

#define FUSION_NEW_SINGLETON(_type) (new(__FILE__, __LINE__, #_type) _type)
#define FUSION_NEW_ARRAY(_type, _n) (new _type[_n])

// #define FUSION_DELETE_SINGLETON_(_heap, _ptr) do { ::FusionpDeleteSingletonFromPrivateHeap((_heap), 0, (_ptr)); } while (0)
// #define FUSION_DELETE_ARRAY_(_heap, _ptr) do { ::FusionpDeleteArrayFromPrivateHeap((_heap), 0, _ptr); } while (0)

#define FUSION_DELETE_SINGLETON(_ptr) do { delete (_ptr); } while (0) /* FUSION_DELETE_SINGLETON_(FUSION_DEFAULT_PROCESS_HEAP(), _ptr) */
#define FUSION_DELETE_ARRAY(_ptr) do { delete [](_ptr); } while (0) /* FUSION_DELETE_ARRAY_(FUSION_DEFAULT_PROCESS_HEAP(), _ptr) */

#define FUSION_RAW_ALLOC_(_heap, _cb, _typeTag) (::FusionpHeapAllocEx((_heap), 0, (_cb), #_typeTag, __FILE__, __LINE__, 0))
#define FUSION_RAW_DEALLOC_(_heap, _ptr) (::FusionpHeapFree((_heap), 0, (_ptr)))

#define FUSION_RAW_ALLOC(_cb, _typeTag) FUSION_RAW_ALLOC_(FUSION_DEFAULT_PROCESS_HEAP(), _cb, _typeTag)
#define FUSION_RAW_DEALLOC(_ptr) FUSION_RAW_DEALLOC_(FUSION_DEFAULT_PROCESS_HEAP(), _ptr)

#define NEW(_type) FUSION_NEW_SINGLETON(_type)
#define NEW_SINGLETON_(_heap, _type) FUSION_NEW_SINGLETON_(_heap, _type)
#define NEW_ARRAY_(_heap, _type, _n) FUSION_NEW_ARRAY_(_heap, _type, _n)

#define DELETE_ARRAY(_ptr) FUSION_DELETE_ARRAY(_ptr)
#define DELETE_ARRAY_(_heap, _ptr) FUSION_DELETE_ARRAY_(_heap, _ptr)

#define DELETE_SINGLETON(_ptr) FUSION_DELETE_SINGLETON(_ptr)
#define DELETE_SINGLETON_(_heap, _ptr) FUSION_DELETE_SINGLETON_(_heap, _ptr)

#if defined(__cplusplus)

#if FUSION_ENABLE_UNWRAPPED_NEW

inline void * __cdecl operator new(size_t cb)
{
    return ::FusionpHeapAllocEx(FUSION_DEFAULT_PROCESS_HEAP(), 0, cb, NULL, NULL, NULL, 0);
}

inline void * __cdecl operator new(size_t cb, PCSTR pszFile, int nLine, PCSTR pszTypeName)
{
    return ::FusionpHeapAllocEx(FUSION_DEFAULT_PROCESS_HEAP(), 0, cb, pszTypeName, pszFile, nLine, 0);
}

#else // FUSION_ENABLE_UNWRAPPED_NEW

EXTERN_C PVOID SomebodyUsedUnwrappedOperatorNew(size_t cb);

#pragma warning(push)
#pragma warning(disable: 4211)

static inline void * __cdecl operator new(size_t cb)
{
    // Call a bogus function so that we'll get a link error. DO NOT IMPLEMENT THIS
    // FUNCTION EVER!  It's referenced here to generate build errors rather than runtime ones.
    return ::SomebodyUsedUnwrappedOperatorNew(cb);
}

#pragma warning(pop)

#endif // FUSION_ENABLE_UNWRAPPED_NEW

#if FUSION_ENABLE_UNWRAPPED_DELETE

inline void __cdecl operator delete(void *pv)
{
    if (pv != NULL)
        ::FusionpHeapFreeEx(FUSION_DEFAULT_PROCESS_HEAP(), 0, pv);
}

inline void __cdecl operator delete(void *pv, PCSTR pszFile, int nLine, PCSTR pszTypeName)
{
    if (pv != NULL)
        ::FusionpHeapFreeEx(FUSION_DEFAULT_PROCESS_HEAP(), 0, pv);
}

#else

EXTERN_C VOID SomebodyUsedUnwrappedOperatorDelete(void *pv);

static void __cdecl operator delete(void *pv)
{
    return ::SomebodyUsedUnwrappedOperatorDelete(pv);
}

#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *P) { return (P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *) { return; }
#endif
#endif

inline void * __cdecl operator new(size_t cb, FUSION_HEAP_HANDLE hHeap, PCSTR pszFile, INT nLine, PCSTR pszExpression, DWORD dwFusionHeapFlags)
{
    ASSERT_NTC(hHeap != 0);
    return ::FusionpHeapAllocEx(hHeap, 0, cb, pszExpression, pszFile, nLine, dwFusionHeapFlags);
}

//
// error C4291: 'void *operator new(size_t,FUSION_HEAP_HANDLE,const PCSTR,INT,const PCSTR,DWORD)'
// : no matching operator delete found; memory will not be freed if initialization throws an exception
//
inline void __cdecl
operator delete(
    void* p,
    FUSION_HEAP_HANDLE hHeap,
    PCSTR /* pszFile */,
    INT /* nLine */,
    PCSTR /* pszExpression */,
    DWORD /* dwFusionHeapFlags */)
{
    ASSERT_NTC(hHeap != 0);
    FusionpDeleteSingletonFromPrivateHeap(hHeap, 0, p);
}

#endif // defined(__cplusplus)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionlastwin32error.h ===
#if !defined(FUSION_INC_FUSIONLASTWIN32ERROR_H_INCLUDED_)
#define FUSION_INC_FUSIONLASTWIN32ERROR_H_INCLUDED_
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#if defined(_M_IX86) && defined(FUSION_WIN)

inline DWORD FusionpGetLastWin32Error(void)
/* This works fine. */
{
    __asm
    { 
        mov eax, fs:[0] _TEB.LastErrorValue
    }
}

inline void FusionpGetLastWin32Error(
    DWORD *pdwLastError
    )
{
    *pdwLastError = ::FusionpGetLastWin32Error();
}

/* This works pretty ok. */

__forceinline VOID FusionpSetLastWin32Error(DWORD dw)
{
    NtCurrentTeb()->LastErrorValue = dw;
}

__forceinline void FusionpClearLastWin32Error(void)
{
    if (::FusionpGetLastWin32Error() != NO_ERROR)
    {
        __asm
        {
            mov fs:[0] _TEB.LastErrorValue, 0
        }
    }
}

inline void FusionpRtlPopFrame(PTEB_ACTIVE_FRAME Frame)
{
    NtCurrentTeb()->ActiveFrame = Frame->Previous;
}

inline void FusionpRtlPushFrame(PTEB_ACTIVE_FRAME Frame)
{
    const PTEB Teb = NtCurrentTeb();
    Frame->Previous = Teb->ActiveFrame;
    Teb->ActiveFrame = Frame;
}

#else

inline DWORD FusionpGetLastWin32Error(void)
{
    return ::GetLastError();
}

inline void FusionpGetLastWin32Error(
    DWORD *pdwLastError
    )
{
    *pdwLastError = ::GetLastError();
}

inline VOID FusionpSetLastWin32Error(DWORD dw)
{
    ::SetLastError(dw);
}

inline void FusionpClearLastWin32Error(void)
{
    ::SetLastError(ERROR_SUCCESS);
}

inline void FusionpRtlPopFrame(PTEB_ACTIVE_FRAME Frame)
{
    ::RtlPopFrame(Frame);
}

inline void FusionpRtlPushFrame(PTEB_ACTIVE_FRAME Frame)
{
    ::RtlPushFrame(Frame);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionhashstring.h ===
#if !defined(_FUSION_INC_FUSIONHASHSTRING_H_INCLUDED_)
#define _FUSION_INC_FUSIONHASHSTRING_H_INCLUDED_

#pragma once

//
//  Do not change this algorithm ID!  We depend on persisted string hashes for
//  quick lookups.
//

#define FUSION_HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

BOOL
FusionpHashUnicodeString(
    PCWSTR szString,
    SIZE_T cchString,
    PULONG HashValue,
    bool fCaseInsensitive
    );

ULONG
__fastcall
FusionpHashUnicodeStringCaseSensitive(
    PCWSTR String,
    SIZE_T Cch
    );

ULONG
__fastcall
FusionpHashUnicodeStringCaseInsensitive(
    PCWSTR String,
    SIZE_T Cch
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusioninitializecriticalsection.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusioninitializecriticalsection.h

Abstract:

    non throwing replacements for InitializeCriticalSection and InitializeCriticalAndSpinCount

Author:

    Jay Krell (JayKrell) November 2001

Revision History:

--*/
#pragma once

/*
Use instead of InitializeCriticalSection.
*/
BOOL
FusionpInitializeCriticalSection(
    LPCRITICAL_SECTION CriticalSection
    );

/*
Use instead of InitializeCriticalSectionAndSpinCount
*/
BOOL
FusionpInitializeCriticalSectionAndSpinCount(
    LPCRITICAL_SECTION  CriticalSection,
    DWORD               SpinCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionhash.h ===
#if !defined(_FUSION_INC_FUSIONHASH_H_INCLUDED_)
#define _FUSION_INC_FUSIONHASH_H_INCLUDED_

#pragma once

#include "fusionheap.h"
#include "fusionbuffer.h"
#include "fusionchartraits.h"
#include "fusiondeque.h"

#define T2P(x, y) < x , y >

#pragma warning(disable:4327)  // indirection alignment of LHS (16) is greater than RHS (8)
#pragma warning(disable:4328)  // indirection alignment of formal parameter 2 (16) is greater than the actual argument alignment (8)

enum InsertOrUpdateIfDisposition
{
    eUpdateValue,
    eLeaveValueAlone,
};

template <typename TPassed, class TStored> inline BOOL HashTableCompareKey(TPassed tpassed, const TStored &rtstored, bool &rfMatch)
{
    return rtstored.Compare(tpassed, rfMatch);
}

template<> inline BOOL HashTableCompareKey<REFGUID, GUID>(REFGUID rguid, const GUID &rguidstored, bool &rfMatch)
{
    rfMatch = ((rguid == rguidstored) != 0);
    return TRUE;
}

template <typename TPassed> inline BOOL HashTableHashKey(TPassed tpassed, ULONG &rulPseudoKey);

// common override for GUID-indexed tables
template<> inline BOOL HashTableHashKey<REFGUID>(REFGUID rguid, ULONG &rulPseudoKey)
{
    const ULONG *p = (const ULONG *) &rguid;
    rulPseudoKey = p[0] + p[1] + p[2] + p[3];
    return TRUE;
}

template <typename TPassed, class TStored> inline BOOL HashTableInitializeKey(TPassed tpassed, TStored &rtstored)
{
    return rtstored.Initialize(tpassed);
}

// common override for GUID-indexed tables
template<> inline BOOL HashTableInitializeKey<REFGUID, GUID>(REFGUID rguidIn, GUID &rguidOut)
{
    rguidOut = rguidIn;
    return TRUE;
}

template <typename TPassed, class TStored> inline BOOL HashTableInitializeValue(TPassed tpassed, TStored &rtstored)
{
    return rtstored.Initialize(tpassed);
}

template <typename TPassed, class TStored> inline BOOL HashTableUpdateValue(TPassed tpassed, TStored &rtstored)
{
    return rtstored.Assign(tpassed);
}

template <typename TStored> inline VOID HashTablePreInitializeKey(TStored &rtstored) { }

template <typename TStored> inline VOID HashTablePreInitializeValue(TStored &rtstored) { }

template <typename TStored> inline VOID HashTableFinalizeKey(TStored &rtstored) { }

template <typename TStored> inline VOID HashTableFinalizeValue(TStored &rtstored) { }

template <typename TCharTraits>
class CCountedStringHolder
{
public:
    CCountedStringHolder() : m_psz(NULL), m_cch(0) { }
    CCountedStringHolder(typename TCharTraits::TConstantString sz) : m_psz(sz), m_cch(TCharTraits::Cch(sz)) { }
    CCountedStringHolder(const CGenericBaseStringBuffer<TCharTraits> &rBuffer) : m_psz(rBuffer), m_cch(TCharTraits::Cch(rBuffer)) { }
    ~CCountedStringHolder() { }

    typename TCharTraits::TConstantString m_psz;
    SIZE_T m_cch;
};

//
//  You want to create a class derived from CHashTableHelper, and
//  use it as THashHelper for CHashTable.
//

template <typename TKPassed, class TKStored, typename TVPassed, typename TVStored> class CHashTableHelper
{
public:
    static BOOL HashKey(TKPassed keyin, ULONG &rulPseudoKey) { return ::HashTableHashKey<TKPassed>(keyin, rulPseudoKey); }
    static BOOL CompareKey(TKPassed keyin, const TKStored &rtkeystored, bool &rfMatch) { return ::HashTableCompareKey<TKPassed, TKStored>(keyin, rtkeystored, rfMatch); }
    static VOID PreInitializeKey(TKStored &rtkeystored) { return ::HashTablePreInitializeKey<TKStored>(rtkeystored); }
    static VOID PreInitializeValue(TVStored &rtvaluestored) { return ::HashTablePreInitializeValue<TVStored>(rtvaluestored); }
    static BOOL InitializeKey(TKPassed keyin, TKStored &rtkeystored) { return ::HashTableInitializeKey<TKPassed>(keyin, rtkeystored); }
    static BOOL InitializeValue(TVPassed vin, TVStored &rvstored) { return ::HashTableInitializeValue<TVPassed, TVStored>(vin, rvstored); }
    static BOOL UpdateValue(TVPassed vin, TVStored &rvstored) { return ::HashTableUpdateValue<TVPassed, TVStored>(vin, rvstored); }
    static VOID FinalizeKey(TKStored &rtkeystored) { return ::HashTableFinalizeKey<TKStored>(rtkeystored); }
    static VOID FinalizeValue(TVStored &rtvstored) { return ::HashTableFinalizeValue<TVStored>(rtvstored); }
};

template <typename TKPassed, typename TKStored, typename TVPassed, typename TVStored, class THashHelper = CHashTableHelper<TKPassed, TKStored, TVPassed, TVStored>, ULONG nInlineBucketChains = 7, bool fAllowDups = false> class CHashTableIter;

template <typename TKPassed, typename TKStored, typename TVPassed, typename TVStored, class THashHelper = CHashTableHelper<TKPassed, TKStored, TVPassed, TVStored>, ULONG nInlineBucketChains = 7, bool fAllowDups = false> class CHashTable
{
    friend CHashTableIter<TKPassed, TKStored, TVPassed, TVStored, THashHelper, nInlineBucketChains, fAllowDups>;

    typedef CHashTable<TKPassed, TKStored, TVPassed, TVStored, THashHelper, nInlineBucketChains, fAllowDups> TThisHashTable;
public:
    CHashTable() :
        m_cBucketChains(nInlineBucketChains),
        m_prgBucketChains(m_rgInlineBucketChains),
        m_ulLockCount(0),
        m_cEntries(0)
    {
    }

    ~CHashTable()
    {
        // This denotes a programming error.
        ASSERT_NTC(m_ulLockCount == 0);
        ULONG i;
        SIZE_T cFound = 0;

        for (i=0; i<m_cBucketChains; i++)
        {
            SIZE_T cThisBucket = 0;
            m_prgBucketChains[i].ClearNoCallback(this, cThisBucket);
            FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "Destroying hash table %p; found %Id buckets at index %d\n", this, cThisBucket, i);
            cFound += cThisBucket;
        }

        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "After loop, destroying hash table %p; found total of %Id buckets; m_cEntries == %Id\n", this, cFound, m_cEntries);

        ASSERT_NTC(cFound == m_cEntries);

        if ((m_prgBucketChains != m_rgInlineBucketChains) &&
            (m_prgBucketChains != NULL))
        {
            ASSERT_NTC(m_cBucketChains != 0);

            FUSION_DELETE_ARRAY(m_prgBucketChains);
            m_cBucketChains = 0;
            m_prgBucketChains = NULL;
        }
        else
        {
            // Better safe than sorry
            ASSERT_NTC((m_prgBucketChains == m_rgInlineBucketChains) || (m_cBucketChains == 0));
            m_cBucketChains = 0;
        }

        m_prgBucketChains = NULL;
    }

    BOOL Initialize(ULONG cBucketChains = nInlineBucketChains)
    {
        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        PARAMETER_CHECK(cBucketChains != 0);

        // If you hit this assertion, it either means that you're calling Initialize
        // twice on the same hash table, the hash table has been corrupted since it was
        // constructed, or someone messed up the constructor.
        INTERNAL_ERROR_CHECK(m_prgBucketChains == m_rgInlineBucketChains);

        // Since we already have nInlineBucketChains allocated, there's no point
        // in going lower.  However, do perform the dynamic allocation if necessary.
        if (cBucketChains > nInlineBucketChains)
        {
            IFALLOCFAILED_EXIT(m_prgBucketChains = FUSION_NEW_ARRAY(CBucketChain, cBucketChains));
            m_cBucketChains = cBucketChains;
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    void Lock(bool fAllowInsertions)
    {
        FN_TRACE();

        if (m_ulLockCount++ == 0)
        {
            m_fInsertionsPermitted = fAllowInsertions;
            m_fRemovalsPermitted = false;
        }
    }

    void Unlock()
    {
        FN_TRACE();

        m_ulLockCount--;
    }

    BOOL Insert(TKPassed keyin, TVPassed valuein, DWORD DuplicateKeyErrorCode)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        PARAMETER_CHECK(DuplicateKeyErrorCode != ERROR_SUCCESS);

        INTERNAL_ERROR_CHECK((m_ulLockCount == 0) || (m_fInsertionsPermitted));
        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Insert(this, keyin, valuein, ulPseudoKey, DuplicateKeyErrorCode));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    BOOL Insert(TKPassed keyin, TVPassed valuein)
    {
        return this->Insert(keyin, valuein, ERROR_ALREADY_EXISTS);
    }

    BOOL FindOrInsertIfNotPresent(TKPassed keyin, TVPassed valuein, TVStored **ppvaluestored = NULL, BOOL *pfFound = NULL)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        if (ppvaluestored != NULL)
            *ppvaluestored = NULL;

        if (pfFound != NULL)
            *pfFound = FALSE;

        INTERNAL_ERROR_CHECK((m_ulLockCount == 0) || (m_fInsertionsPermitted));
        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].FindOrInsertIfNotPresent(this, keyin, valuein, ulPseudoKey, ppvaluestored, pfFound));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    // U is always as indicated, but the compiler would rather
    // deduce that seperately than deduce types dependent on each other
    template <typename T>
    BOOL InsertOrUpdateIf(
        TKPassed keyin,
        TVPassed valuein,
        T *pt,
        BOOL (T::*pmfn)(
            TVPassed,
            const TVStored &,
            InsertOrUpdateIfDisposition &)
        )
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        INTERNAL_ERROR_CHECK((m_ulLockCount == 0) || (m_fInsertionsPermitted));

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].InsertOrUpdateIf T2P(TThisHashTable, T)(this, keyin, valuein, ulPseudoKey, pt, pmfn));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    inline VOID ClearNoCallback()
    {
        FN_TRACE();

        ULONG i;
        SIZE_T cFound = 0;

        for (i=0; i<m_cBucketChains; i++)
        {
            SIZE_T cThisBucket = 0;
            m_prgBucketChains[i].ClearNoCallback(this, cThisBucket);
            cFound += cThisBucket;
        }

        if (m_prgBucketChains != m_rgInlineBucketChains)
        {
            FUSION_DELETE_ARRAY(m_prgBucketChains);
            m_prgBucketChains = m_rgInlineBucketChains;
            m_cBucketChains = nInlineBucketChains;
        }

        m_cEntries = 0;
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Cleared hash table %p entries to 0\n", __FILE__, __LINE__, this);
    }

    template <typename T> inline VOID Clear(T *pt = NULL, VOID (T::*pmfn)(TKStored &, TVStored &) = NULL)
    {
        FN_TRACE();
        ULONG i;

        // Either both have to be NULL or neither.
        ASSERT((pt == NULL) == (pmfn == NULL));

        if ((pt != NULL) && (pmfn != NULL))
        {
            for (i=0; i<m_cBucketChains; i++)
                m_prgBucketChains[i].Clear(this, pt, pmfn);
        }

        if (m_prgBucketChains != m_rgInlineBucketChains)
        {
            FUSION_DELETE_ARRAY(m_prgBucketChains);
            m_prgBucketChains = m_rgInlineBucketChains;
            m_cBucketChains = nInlineBucketChains;
        }

        m_cEntries = 0;
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Cleared hash table %p entries to 0\n", __FILE__, __LINE__, this);
    }

    BOOL Remove(TKPassed keyin, bool fRemoveFirstFoundOnly = false)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        INTERNAL_ERROR_CHECK((m_ulLockCount == 0) || (m_fRemovalsPermitted));

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Remove(this, keyin, ulPseudoKey, fRemoveFirstFoundOnly));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    BOOL Find(TKPassed keyin, TVStored const *&rpvaluestored) const
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        rpvaluestored = NULL;
        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));
        iBucket = ulPseudoKey % m_cBucketChains;
        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, rpvaluestored));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    BOOL Find(TKPassed keyin, TVStored *&rpvaluestored)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, rpvaluestored));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    BOOL Assign(CHashTable &TableToCopy) { return FALSE; }

    VOID TakeValue(CHashTable &That)
    {
        FN_TRACE();

        ULONG i;

        // Nothing can fail in this function, so we're theoretically safe to preemptively clean up our own storage.
        if (m_prgBucketChains != m_rgInlineBucketChains)
        {
            FUSION_DELETE_ARRAY(m_prgBucketChains);
            m_prgBucketChains = m_rgInlineBucketChains;
            m_cBucketChains = nInlineBucketChains;
        }

        // Just steal any storage from the other table.
        if (That.m_prgBucketChains != That.m_rgInlineBucketChains)
        {
            // It's a dynamically allocated array in the source; just move the pointer over
            // and clean up its state to be somewhat consistent.
            m_prgBucketChains = That.m_prgBucketChains;
            m_cBucketChains = That.m_cBucketChains;

            That.m_prgBucketChains = That.m_rgInlineBucketChains;
            That.m_cBucketChains = nInlineBucketChains;
        }
        else
        {
            // The inline chain of the other table is being used; we have to copy the
            // chains over one by one.
            for (i=0; i<nInlineBucketChains; i++)
                m_rgInlineBucketChains[i].TakeValue(this, That.m_rgInlineBucketChains[i]);
        }

        m_cEntries = That.m_cEntries;
        That.m_cEntries = 0;
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Hash table %p took over hash table %p's %Id entries\n", __FILE__, __LINE__, this, &That, m_cEntries);
    }

    SIZE_T GetEntryCount() const { return m_cEntries; }

//protected:

    class CBucketChain;

    class CBucket
    {
    public:
        CBucket(ULONG ulPseudoKey) : m_ulPseudoKey(ulPseudoKey) { THashHelper::PreInitializeKey(m_tkey); THashHelper::PreInitializeValue(m_tvalue); }

        ~CBucket() { THashHelper::FinalizeKey(m_tkey); THashHelper::FinalizeValue(m_tvalue); }

        BOOL Initialize(CHashTable const * pTable, TKPassed keyin, TVPassed valuein)
        {
            BOOL fSuccess = FALSE;

            FN_TRACE_WIN32(fSuccess);

            IFW32FALSE_EXIT(THashHelper::InitializeKey(keyin, m_tkey));
            IFW32FALSE_EXIT(THashHelper::InitializeValue(valuein, m_tvalue));

            fSuccess = TRUE;

        Exit:
            return fSuccess;
        }

        BOOL Matches(TKPassed keyin, ULONG ulPseudoKey, bool &rfMatches) const
        {
            BOOL fSuccess = FALSE;
            bool fMatches = false;

            if (m_ulPseudoKey == ulPseudoKey)
            {
                if (!THashHelper::CompareKey(keyin, m_tkey, fMatches))
                    goto Exit;
            }

            rfMatches = fMatches;

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        template <typename T> VOID Clear(TThisHashTable const * pTable, T *pt, VOID (T::*pmfn)(TKStored &keystored, TVStored &rvaluestored))
        {
            FN_TRACE();
            (pt->*pmfn)(m_tkey, m_tvalue);
        }

        template <typename T> VOID Clear(TThisHashTable const * pTable, T *pt, VOID (T::*pmfn)(TKStored &keystored, TVStored &rvaluestored) const)
        {
            FN_TRACE();
            (pt->*pmfn)(m_tkey, m_tvalue);
        }

        VOID Remove()
        {
            FN_TRACE();
            m_Linkage.Remove();
        }

        BOOL Update(TVPassed valuein)
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            IFW32FALSE_EXIT(THashHelper::UpdateValue(m_tvalue, valuein));
            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        TKStored m_tkey;
        TVStored m_tvalue;
        ULONG m_ulPseudoKey;
        CDequeLinkage m_Linkage;

    private:
        CBucket(const CBucket &);
        void operator =(const CBucket &);
    };

    typedef CDequeIterator<CBucket, FIELD_OFFSET(CBucket, m_Linkage)> CBucketIterator;
    typedef CConstDequeIterator<CBucket, FIELD_OFFSET(CBucket, m_Linkage)> CConstBucketIterator;

    class CBucketChain
    {
    public:
        CBucketChain() { }
        ~CBucketChain() { }

        inline void DeallocateBuckets(CHashTable const *pTable, SIZE_T &rcFound)
        {
            rcFound = m_Buckets.GetEntryCount();
            m_Buckets.Clear(pTable, &CHashTable::DeallocateBucket);
        }

        BOOL Insert(
            CHashTable *pTable,
            TKPassed keyin,
            TVPassed valuein,
            ULONG ulPseudoKey,
            DWORD DuplicateKeyErrorCode)
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);

            bool fMatches = false;
            CBucket *pCBucket = NULL;

            if (!fAllowDups)
            {
                CBucketIterator Iter(&m_Buckets);

                for (Iter.Reset(); Iter.More(); Iter.Next())
                {
                    IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                    if (fMatches)
                        ORIGINATE_WIN32_FAILURE_AND_EXIT(DuplicateKey, DuplicateKeyErrorCode);
                }
            }

            IFW32FALSE_EXIT(pTable->AllocateAndInitializeBucket(ulPseudoKey, keyin, valuein, pCBucket));

            m_Buckets.AddToTail(pCBucket);
            pTable->m_cEntries++;
            FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Incremented hash table %p entries to %Id\n", __FILE__, __LINE__, pTable, pTable->m_cEntries);

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        BOOL FindOrInsertIfNotPresent(
            CHashTable *pTable,
            TKPassed keyin,
            TVPassed valuein,
            ULONG ulPseudoKey,
            TVStored **ppvaluestored,
            BOOL *pfFound
            )
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;
            CBucketIterator Iter(&m_Buckets);

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    *ppvaluestored = &Iter->m_tvalue;
                    break;
                }
            }

            if (!fMatches)
            {
                CBucket *pCBucket = NULL;

                IFW32FALSE_EXIT(pTable->AllocateAndInitializeBucket(ulPseudoKey, keyin, valuein, pCBucket));

                m_Buckets.AddToTail(pCBucket);

                pTable->m_cEntries++;
                FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Incremented hash table %p entries to %Id\n", __FILE__, __LINE__, pTable, pTable->m_cEntries);

                if (ppvaluestored != NULL)
                    *ppvaluestored = &pCBucket->m_tvalue;
            }

            if (pfFound != NULL)
                *pfFound = fMatches;

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        template <typename THashTable, typename T>
        BOOL InsertOrUpdateIf(
            THashTable *pTable,
            TKPassed keyin,
            TVPassed valuein,
            ULONG ulPseudoKey,
            T *pt,
            BOOL (T::*pmfn)(
                TVPassed,
                const TVStored &,
                InsertOrUpdateIfDisposition &)
            )
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;
            CBucketIterator Iter(&m_Buckets);

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    InsertOrUpdateIfDisposition Disposition;

                    IFW32FALSE_EXIT((pt->*pmfn)(valuein, Iter->m_tvalue, Disposition));

                    if (Disposition == eUpdateValue)
                    {
                        FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Updating value in hash table %p\n", __FILE__, __LINE__, pTable);
                        IFW32FALSE_EXIT(THashHelper::UpdateValue(valuein, Iter->m_tvalue));
                    }

                    break;
                }
            }

            // If we didn't find one, we want to insert.
            if (!fMatches)
            {
                CBucket *pCBucket = NULL;

                IFW32FALSE_EXIT(pTable->AllocateAndInitializeBucket(ulPseudoKey, keyin, valuein, pCBucket));

                m_Buckets.AddToTail(pCBucket);
                pTable->m_cEntries++;
                FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Incremented hash table %p entries to %Id\n", __FILE__, __LINE__, pTable, pTable->m_cEntries);
            }

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        inline VOID ClearNoCallback(TThisHashTable const *pTable, SIZE_T &rcFound)
        {
            FN_TRACE();
            this->DeallocateBuckets(pTable, rcFound);
        }

        template <typename T> class CLEAR_CALLBACK_BLOCK
        {
        public:
            VOID DoClear(CBucket *pCBucket) { pCBucket->Clear(pTable, pt, pmfn); pTable->DeallocateBucket(pCBucket); }

            TThisHashTable const *pTable;
            T *pt;
            VOID (T::*pmfn)(TKStored &, TVStored &);
        };

        template <typename T> VOID Clear(TThisHashTable const *pTable, T *pt, VOID (T::*pmfn)(TKStored &keystored, TVStored &valuestored))
        {
            FN_TRACE();
            SIZE_T cFound = 0;
            ASSERT((pt != NULL) && (pmfn != NULL));

            CLEAR_CALLBACK_BLOCK<T> CallbackBlock;

            CallbackBlock.pTable = pTable;
            CallbackBlock.pt = pt;
            CallbackBlock.pmfn = pmfn;

            m_Buckets.Clear<CLEAR_CALLBACK_BLOCK<T> >(&CallbackBlock, &CLEAR_CALLBACK_BLOCK<T>::DoClear);

            this->DeallocateBuckets(pTable, cFound);
        }

//        BOOL Remove(CHashTable const *pTable, TKPassed keyin, ULONG ulPseudoKey, bool fFirstOnly = false)
        BOOL Remove(CHashTable *pTable, TKPassed keyin, ULONG ulPseudoKey, bool fFirstOnly = false)
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fFoundOne = false;
            bool fMatches = false;

            CBucketIterator Iter(&m_Buckets);

            Iter.Reset();

            while (Iter.More())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    CBucket *pCBucket = Iter.RemoveCurrent(eDequeIteratorMoveForward);
                    pTable->DeallocateBucket(pCBucket);
                    fFoundOne = true;

                    pTable->m_cEntries--;
                    FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Decremented hash table %p entries to %Id\n", __FILE__, __LINE__, pTable, pTable->m_cEntries);

                    // If we don't allow duplicates, our job is done and there's no point
                    // in searching the remainder of the list.  Also, if we're only interested
                    // in removing the first match we find (and not necessarily all of them),
                    // then also bail out.
                    if ((!fAllowDups) || (fFirstOnly))
                        break;
                }
                else
                    Iter.Next();
            }

            // If we didn't at least find one, then tell the caller.
            if (!fFoundOne)
                ORIGINATE_WIN32_FAILURE_AND_EXIT(HashTableEntryNotFound, ERROR_FILE_NOT_FOUND);

            fSuccess = TRUE;
        Exit:
            return fSuccess;
        }

        BOOL Find(TKPassed keyin, ULONG ulPseudoKey, TVStored const *&rpvaluestored) const
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;
            CConstBucketIterator Iter(&m_Buckets);

            rpvaluestored = NULL;

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    rpvaluestored = &Iter->m_tvalue;
                    break;
                }
            }

            fSuccess = TRUE;

        Exit:
            return fSuccess;
        }

        BOOL Find(TKPassed keyin, ULONG ulPseudoKey, TVStored *&rpvaluestored)
        {
            BOOL fSuccess = FALSE;
            FN_TRACE_WIN32(fSuccess);
            bool fMatches = false;
            CBucketIterator Iter(&m_Buckets);

            rpvaluestored = NULL;

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(Iter->Matches(keyin, ulPseudoKey, fMatches));

                if (fMatches)
                {
                    rpvaluestored = &Iter->m_tvalue;
                    break;
                }
            }

            fSuccess = TRUE;

        Exit:
            return fSuccess;
        }

        VOID TakeValue(CHashTable *pTable, CBucketChain &That)
        {
            SIZE_T cFound = 0;
            this->DeallocateBuckets(pTable, cFound);
            m_Buckets.TakeValue(That.m_Buckets);
        }

        CDeque<CBucket, FIELD_OFFSET(CBucket, m_Linkage)> m_Buckets;
    private:
        CBucketChain(const CBucketChain &);
        void operator =(const CBucketChain &);
    };

    inline BOOL AllocateAndInitializeBucket(
        ULONG ulPseudoKey,
        TKPassed keyin,
        TVPassed valuein,
        CBucket *&rpBucket
        ) const
    {
        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        rpBucket = NULL;
        CBucket *pBucket = NULL;

        IFALLOCFAILED_EXIT(pBucket = new CBucket(ulPseudoKey));
        IFW32FALSE_EXIT(pBucket->Initialize(this, keyin, valuein));

        rpBucket = pBucket;
        pBucket = NULL;
        fSuccess = TRUE;

    Exit:
        if (pBucket != NULL)
            this->DeallocateBucket(pBucket);

        return fSuccess;
    }

    inline void DeallocateBucket(CBucket *pCBucket) const { FUSION_DELETE_SINGLETON(pCBucket); }

    friend CBucket;
    friend CBucketChain;

    ULONG m_cBucketChains;
    CBucketChain *m_prgBucketChains;
    CBucketChain m_rgInlineBucketChains[nInlineBucketChains];
    SIZE_T m_ulLockCount;
    SIZE_T m_cEntries;
    bool m_fInsertionsPermitted;
    bool m_fRemovalsPermitted;
private:
    CHashTable(const CHashTable &r); // intentionally not implmented
    void operator =(const CHashTable &r); // intentionally not implemented

};

template <typename TKPassed, typename TKStored, typename TVPassed, typename TVStored, class THashHelper /*= CHashTableHelper<TKPassed, TKStored, TVPassed, TVStored> */, ULONG nInlineBucketChains /*= 7 */, bool fAllowDups /*= false */> class CHashTableIter
{
    typedef CHashTable<TKPassed, TKStored, TVPassed, TVStored, THashHelper, nInlineBucketChains, fAllowDups> THashTable;

public:
    inline CHashTableIter(CHashTable<TKPassed, TKStored, TVPassed, TVStored, THashHelper, nInlineBucketChains, fAllowDups> &r) : m_rTable(r), m_iBucketChain(0),
        m_fAlreadyAdvanced(false) { }

    inline ~CHashTableIter() { }

    inline void Reset()
    {
        FN_TRACE();

        m_iBucketChain = 0;
        m_fAlreadyAdvanced = false;

        // Move the bucket iterator across the bucket chains looking for one with some
        // buckets
        for (m_iBucketChain = 0; m_iBucketChain < m_rTable.m_cBucketChains; m_iBucketChain++)
        {
            m_Iter.Rebind(&m_rTable.m_prgBucketChains[m_iBucketChain].m_Buckets);
            m_Iter.Reset();
            if (m_Iter.More())
                break;
        }

        if (m_iBucketChain == m_rTable.m_cBucketChains)
        {
            // There wasn't anything.  Unbind the iterator to signal that we're
            // totally done.
            m_Iter.Unbind();
        }
    }

    inline void Delete()
    {
        FN_TRACE();

        CSxsPreserveLastError ple;

        ASSERT(m_Iter.IsBound());
        if (m_Iter.IsBound())
        {
            THashTable::CBucket *pCBucket = m_Iter.RemoveCurrent(eDequeIteratorMoveForward);
            FUSION_DELETE_SINGLETON(pCBucket);
            m_fAlreadyAdvanced = true;
            m_rTable.m_cEntries--;
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_HASHTABLE, "%s(%d): Decremented hash table %p entries to %Id\n", __FILE__, __LINE__, &m_rTable, m_rTable.m_cEntries);
        }

        ple.Restore();
    }

    inline BOOL Update(TVPassed valuein) const
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        INTERNAL_ERROR_CHECK(m_Iter.IsBound());
        INTERNAL_ERROR_CHECK(!m_fAlreadyAdvanced);

        IFW32FALSE_EXIT(m_Iter->Update(valuein));

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    inline bool More() const { return m_Iter.IsBound(); }

    inline void Next()
    {
        FN_TRACE();

        if (m_Iter.IsBound())
        {
            // If someone deleted the current element, the iterator has already been
            // advanced. Otherwise, move on.
            if (!m_fAlreadyAdvanced)
                m_Iter.Next();

            // We've taken it into account, now forget about it.
            m_fAlreadyAdvanced = false;

            // If there aren't any more elements in this deque, try the next bucket chain
            if (!m_Iter.More())
            {
                m_iBucketChain++;

                while (m_iBucketChain < m_rTable.m_cBucketChains)
                {
                    m_Iter.Rebind(&m_rTable.m_prgBucketChains[m_iBucketChain].m_Buckets);
                    m_Iter.Reset();
                    if (m_Iter.More())
                        break;
                    m_iBucketChain++;
                }

                if (m_iBucketChain == m_rTable.m_cBucketChains)
                    m_Iter.Unbind();
            }
        }
    }

    inline const TKStored &GetKey() const
    {
        FN_TRACE();

        // Should not call this if More() returns false
        ASSERT(m_Iter.IsBound());

        if (m_Iter.IsBound() && m_Iter.More())
        {
            return m_Iter->m_tkey;
        }

        return *((TKStored *) NULL);
    }

    inline TVStored &GetValue() const
    {
        FN_TRACE();

        // Should not call this function if More() returns false
        ASSERT(m_Iter.IsBound());
        return m_Iter->m_tvalue;
    }

    inline TVStored &operator ->() const
    {
        FN_TRACE();

        // Should not call this function if More() returns false
        ASSERT(m_Iter.IsBound());
        return m_Iter->m_tvalue;
    }

protected:
    THashTable &m_rTable;
    typename THashTable::CBucketIterator m_Iter;
    ULONG m_iBucketChain;
    bool m_fAlreadyAdvanced;

private:
    CHashTableIter(const CHashTableIter &);
    void operator =(const CHashTableIter &);
};

//
//  Helper class for hash tables of filenames:
//

template <typename TVPassed, typename TVStored> class CFusionFilenameHashTableHelper : public CHashTableHelper<LPCWSTR, CUnicodeStringBuffer, TVPassed, TVStored>
{
public:
    inline static BOOL HashKey(LPCWSTR sz, ULONG &rulPseudoKey)
    {
        BOOL fSuccess = FALSE;

        FN_TRACE_WIN32(fSuccess);

        ULONG ulPK = 0;
        LPCWSTR pszTemp;
        WCHAR wch;

        if (sz != NULL)
        {
            SIZE_T cch = ::wcslen(sz);
            IFW32FALSE_EXIT(::FusionpHashUnicodeString(sz, cch, &ulPK, true));
        }

        rulPseudoKey = ulPK;
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    static BOOL CompareKey(LPCWSTR szKey, CUnicodeBaseStringBuffer *pbuff, bool &rfMatch)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        int iResult;

        rfMatch = false;

        PARAMETER_CHECK(pbuff != NULL);

        iResult = ::FusionpCompareStrings(
                        szKey, (szKey == NULL) ? 0 : ::wcslen(szKey),
                        static_cast<LPCWSTR>(*pbuff), pbuff->Cch(),
                        true);

        rfMatch = (iResult == 2); // In SDK DOCS, 2 == CSTR_EQUAL; there is no constant defined.  -mgrier 12/6/1999
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }
};

//
//  CSimpleKeyedTable
//
//  A simplification of the CHashTable class template which assumes that
//  keys are passed as const references.
//

template <typename TKey, typename TVPassed, typename TVStored, typename THashHelper> class CSimpleKeyedTable : public CHashTable<const TKey &, TKey, TVPassed, TVStored, THashHelper>
{
public:
    CSimpleKeyedTable() : CHashTable<const TKey &, TKey, TVPassed, TVStored, THashHelper>() { }
};

template <typename TKey, typename TVPassed, typename TVStored, typename THashHelper> class CSimpleKeyedTableIter : public CHashTableIter<const TKey &, TKey, TVPassed, TVStored, THashHelper>
{
    typedef CHashTableIter<const TKey &, TKey, TVPassed, TVStored, THashHelper> Base;
public:
    CSimpleKeyedTableIter(CSimpleKeyedTable<TKey, TVPassed, TVStored, THashHelper> &Table) : Base(Table) { }
};

template <typename TKPassed, typename TKStored, typename TValue> class CPtrTableHelper : public CHashTableHelper<TKPassed, TKStored, TValue *, TValue *>
{
    typedef TValue *TValuePtr;

public:
    static VOID PreInitializeValue(TValue *&rvstored) { rvstored = NULL; }
    static BOOL InitializeValue(const TValuePtr &vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(const TValuePtr &vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static VOID FinalizeValue(TValuePtr &rvstored) { if (rvstored != NULL) { FUSION_DELETE_SINGLETON(rvstored); rvstored = NULL; } }
};

template <typename TKPassed, typename TKStored, typename TValue, typename THashHelper = CPtrTableHelper<TKPassed, TKStored, TValue> > class CPtrTable : public CHashTable<TKPassed, TKStored, TValue *, TValue *, THashHelper>
{
public:
    CPtrTable() : CHashTable<TKPassed, TKStored, TValue *, TValue *, THashHelper>() { }

    BOOL Find(TKPassed keyin, TValue *&rpvaluestored)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;
        TValue **ppValue = NULL;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, ppValue));

        if (ppValue != NULL)
            rpvaluestored = *ppValue;

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

private:
    CPtrTable(const CPtrTable &);
    void operator =(const CPtrTable &);
};

template <typename TKPassed, typename TKStored, typename TValue, typename THashHelper = CPtrTableHelper<TKPassed, TKStored, TValue> > class CPtrTableIter : public CHashTableIter<TKPassed, TKStored, TValue *, TValue *, THashHelper>
{
public:
    CPtrTableIter(CPtrTable<TKPassed, TKStored, TValue, THashHelper> &Table) : CHashTableIter<TKPassed, TKStored, TValue *, TValue *, THashHelper>(Table) { }

private:
    CPtrTableIter(const CPtrTableIter &);
    void operator =(const CPtrTableIter &);
};

template <typename TKey, typename TValue> class CSimplePtrTableHelper : public CPtrTableHelper<const TKey &, TKey, TValue>
{
public:
};

//
//  CSimplePtrTable
//
//  A simplification of CHashTable class template which assumes
//  that keys are passed as const references and values are pointers.
//
//  Note that the table does NOT own allocating or deallocating the storage
//  to which the pointers refer.  If the table is destroyed, the
//  storage is not released.
//

template <typename TKey, typename TValue, typename THashHelper = CSimplePtrTableHelper<TKey, TValue> > class CSimplePtrTable : public CSimpleKeyedTable<TKey, TValue *, TValue *, THashHelper>
{
public:
    CSimplePtrTable() : CSimpleKeyedTable<TKey, TValue *, TValue *, THashHelper>(hHeap) { }

    BOOL Find(const TKey &keyin, TValue *&rpvaluestored)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;
        TValue **ppValue = NULL;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, ppValue));

        if (ppValue != NULL)
            rpvaluestored = *ppValue;

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

private:
    CSimplePtrTable(const CSimplePtrTable &);
    void operator =(const CSimplePtrTable &);
};

template <typename TKey, typename TValue, typename THashHelper = CSimplePtrTableHelper<TKey, TValue> > class CSimplePtrTableIter : public CSimpleKeyedTableIter<TKey, TValue *, TValue *, THashHelper>
{
    typedef CSimpleKeyedTableIter<TKey, TValue *, TValue *, THashHelper> Base;
public:
    CSimplePtrTableIter(CSimplePtrTable<TKey, TValue, THashHelper> &Table)
       : Base(Table) { }
private:
    CSimplePtrTableIter(const CSimplePtrTableIter &);
    void operator =(const CSimplePtrTableIter &);
};

template <typename TVPassed, typename TVStored> class CGuidTableHelper : public CHashTableHelper<GUID, GUID, TVPassed, TVStored>
{
    typedef CHashTableHelper<REFGUID, GUID, TVPassed, TVStored> Base;
public:
    static BOOL InitializeKey(REFGUID keyin, GUID &rtkeystored) { rtkeystored = keyin; return TRUE; }
};

template <typename TVPassed, typename TVStored, typename THashHelper = CGuidTableHelper<TVPassed, TVStored> > class CGuidTable : public CHashTable<REFGUID, GUID, TVPassed, TVStored, THashHelper >
{
public:
    CGuidTable() : CHashTable<REFGUID, GUID, TVPassed, TVStored, THashHelper >() { }
private:
    CGuidTable(const CGuidTable &);
    void operator =(const CGuidTable &);
};

template <typename TVPassed, typename TVStored, typename THashHelper = CGuidTableHelper<TVPassed, TVStored> > class CGuidTableIter : public CHashTableIter<REFGUID, GUID, TVPassed, TVStored, THashHelper >
{
    typedef CHashTableIter<REFGUID, GUID, TVPassed, TVStored, THashHelper > Base;
public:
    CGuidTableIter(CGuidTable<TVPassed, TVStored, THashHelper> &Table) : Base(Table) { }
private:
    CGuidTableIter(const CGuidTableIter &);
    void operator =(const CGuidTableIter &);
};

template <typename TValue> class CGuidPtrTableHelper : public CHashTableHelper<REFGUID, GUID, TValue *, TValue *>
{
public:
    static BOOL InitializeKey(REFGUID keyin, GUID &rtkeystored) { rtkeystored = keyin; return TRUE; }
    static BOOL InitializeValue(TValue *vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(TValue *vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
};

template <typename TValue, typename THashHelper = CGuidPtrTableHelper<TValue> > class CGuidPtrTable : public CGuidTable<TValue *, TValue *, THashHelper>
{
public:
    CGuidPtrTable() : CGuidTable<TValue *, TValue *, THashHelper>() { }

    BOOL Find(REFGUID rGuid, TValue *&rptvalue) { TValue **pptvalue = NULL; BOOL f = __super::Find(rGuid, pptvalue); if (f && (pptvalue != NULL)) rptvalue = *pptvalue; return f; }
//    BOOL Find(REFGUID rGuid, TValue *const &rptvalue) const { return __super::Find(rGuid, &rptvalue); }

private:
    CGuidPtrTable(const CGuidPtrTable &);
    void operator =(const CGuidPtrTable &);
};

template <typename TValue, typename THashHelper = CGuidPtrTableHelper<TValue> > class CGuidPtrTableIter : public CGuidTableIter<TValue *, TValue *, THashHelper>
{
    typedef CGuidTableIter<TValue *, TValue *, THashHelper> Base;
public:
    CGuidPtrTableIter(CGuidPtrTable<TValue, THashHelper> &Table) : Base(Table) { }
private:
    CGuidPtrTableIter(const CGuidPtrTableIter &);
    void operator =(const CGuidPtrTableIter &);
};

template <typename TVPassed, typename TVStored, typename TCharTraits, bool fCaseInsensitive = false> class CStringTableHelper : public CHashTableHelper<const CCountedStringHolder<TCharTraits> &, CStringBuffer, TVPassed, TVStored>
{
public:
    typedef CCountedStringHolder<TCharTraits> TCountedStringHolder;

    static BOOL HashKey(const TCountedStringHolder &keyin, ULONG &rulPseudoKey) { BOOL fSuccess = FALSE; FN_TRACE_WIN32(fSuccess); IFW32FALSE_EXIT(TCharTraits::Win32HashString(keyin.m_psz, keyin.m_cch, rulPseudoKey, fCaseInsensitive)); fSuccess = TRUE; Exit: return fSuccess; }
    static BOOL InitializeKey(const TCountedStringHolder &keyin, CBaseStringBuffer &rtkeystored) { BOOL fSuccess = FALSE; FN_TRACE_WIN32(fSuccess); IFW32FALSE_EXIT(rtkeystored.Win32Assign(keyin.m_psz, keyin.m_cch)); fSuccess = TRUE; Exit: return fSuccess; }
    static BOOL CompareKey(const TCountedStringHolder &keyin, const CBaseStringBuffer &rtkeystored, bool &rfMatch) { BOOL fSuccess = FALSE; FN_TRACE_WIN32(fSuccess); IFW32FALSE_EXIT(rtkeystored.Win32Equals(keyin.m_psz, keyin.m_cch, rfMatch, fCaseInsensitive)); fSuccess = TRUE; Exit: return fSuccess; }
};

class STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE
{
public:
    virtual VOID DoClear(PVOID) = 0;
};

template <typename TVPassed, typename TVStored, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CStringTableHelper<TVPassed, TVStored, TCharTraits, dwCmpFlags> > class CStringTable : public CHashTable<const CCountedStringHolder<TCharTraits> &, CStringBuffer, TVPassed, TVStored, THashHelper>
{
    typedef CHashTable<const CCountedStringHolder<TCharTraits> &, CStringBuffer, TVPassed, TVStored, THashHelper> Base;

public:
    typedef CCountedStringHolder<TCharTraits> TCountedStringHolder;

protected:
    VOID ClearCallbackWrapper(CStringBuffer &key, TVStored &valuestored)
    {
        FN_TRACE();

        key.Clear();
        m_pActiveClearCallbackBlock->DoClear(valuestored);
    }

    STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE *m_pActiveClearCallbackBlock;

    template <typename T> class STRING_TABLE_CLEAR_CALLBACK_BLOCK : public STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE
    {
    public:
        T *pt;
        VOID (T::*pmfn)(TVStored &valuestored);

        VOID DoClear(PVOID pv) { TVStored *pvstored = (TVStored *) pv; (pt->*pmfn)(*pvstored); }
    };

    // Introduce name that derived classes will not override to work around compiler bugs
    inline VOID ClearStringTable(STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE *pCallbackBlock)
    {
        FN_TRACE();

        ASSERT(m_pActiveClearCallbackBlock == NULL);

        m_pActiveClearCallbackBlock = pCallbackBlock;

        ULONG i;

        for (i=0; i<m_cBucketChains; i++)
            m_prgBucketChains[i].Clear<CStringTable>(this, this, &CStringTable::ClearCallbackWrapper);

        this->ClearNoCallback();

        m_pActiveClearCallbackBlock = NULL;
    }

public:
    typedef CCountedStringHolder<TCharTraits> TCountedStringHolder;

    CStringTable() : CHashTable<const TCountedStringHolder &, CStringBuffer, TVPassed, TVStored, THashHelper>(), m_pActiveClearCallbackBlock(NULL) { }

    template <typename T> inline VOID Clear(T *pt, VOID (T::*pmfn)(TVStored &valuestored))
    {
        FN_TRACE();

        STRING_TABLE_CLEAR_CALLBACK_BLOCK<T> CallbackBlock;
        CallbackBlock.pt = pt;
        CallbackBlock.pmfn = pmfn;
        this->ClearStringTable(&CallbackBlock);
    }

private:
    CStringTable(const CStringTable &);
    void operator =(const CStringTable &);
};

template <typename TVPassed, typename TVStored, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CStringTableHelper<TVPassed, TVStored, TCharTraits, dwCmpFlags> > class CStringTableIter : public CHashTableIter<const CCountedStringHolder<TCharTraits> &, CStringBuffer, TVPassed, TVStored, THashHelper>
{
public:
    typedef CCountedStringHolder<TCharTraits> TCountedStringHolder;

protected:
    typedef CHashTableIter<const TCountedStringHolder &, CStringBuffer, TVPassed, TVStored, THashHelper> Base;

public:
    CStringTableIter(CStringTable<TVPassed, TVStored, TCharTraits, dwCmpFlags, THashHelper> &rTable) : Base(rTable) { }

    inline typename TCharTraits::TConstantString GetKey() const
    {
        FN_TRACE();

        // Should not call this if More() returns false
        ASSERT(m_Iter != NULL);

        //
        // m_ulLockCount doesn't exist. I'm wondering if perhaps this entire function
        // could be axed in favor of using the default one, which does something
        // very similar. (jonwis 8/24/00)
        //
        // ASSERT(m_ulLockCount != 0);

        if (m_Iter != NULL)
            return m_Iter->m_tkey;

        return NULL;
    }
private:
    CStringTableIter(const CStringTableIter &);
    void operator =(const CStringTableIter &);
};

template <typename TValue, typename TCharTraits, bool fCaseInsensitive = false> class CStringPtrTableHelper : public CStringTableHelper<TValue *, TValue *, TCharTraits, fCaseInsensitive>
{
public:
    static VOID PreInitializeValue(TValue *&rvstored) { rvstored = NULL; }
    static BOOL InitializeValue(TValue *vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(TValue *vin, TValue *&rvstored) { rvstored = vin; return TRUE; }
    static VOID FinalizeValue(TValue *&rvstored) { if (rvstored != NULL) { FUSION_DELETE_SINGLETON(rvstored); rvstored = NULL; } }
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CStringPtrTableHelper<TValue, TCharTraits, dwCmpFlags> > class CStringPtrTable : public CStringTable<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper>
{
    typedef CStringTable<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper> Base;

protected:
    template <typename T> class STRING_PTR_TABLE_CLEAR_CALLBACK_BLOCK : public STRING_TABLE_CLEAR_CALLBACK_BLOCK_BASE
    {
    public:
        T *pt;
        VOID (T::*pmfn)(TValue *pvaluestored);

        VOID DoClear(PVOID pv) { /* TValue **ppvstored = (TValue **) pv; */ (pt->*pmfn)((TValue *) pv); }
    };

public:
    CStringPtrTable() : CStringTable<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper>() { }

    template <typename T> VOID Clear(T *pt, VOID (T::*pmfn)(TValue *valuestored))
    {
        FN_TRACE();

        STRING_PTR_TABLE_CLEAR_CALLBACK_BLOCK<T> CallbackBlock;
        CallbackBlock.pt = pt;
        CallbackBlock.pmfn = pmfn;
        this->ClearStringTable(&CallbackBlock);
    }

    BOOL Find(const TCountedStringHolder &keyin, TValue const *&rpvaluestored) const
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, rpvaluestored));

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

    BOOL Find(const TCountedStringHolder &keyin, TValue *&rpvaluestored)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);
        ULONG ulPseudoKey = 0;
        ULONG iBucket = 0;
        TValue **ppvaluestored = NULL;

        rpvaluestored = NULL;

        IFW32FALSE_EXIT(THashHelper::HashKey(keyin, ulPseudoKey));

        iBucket = ulPseudoKey % m_cBucketChains;

        IFW32FALSE_EXIT(m_prgBucketChains[iBucket].Find(keyin, ulPseudoKey, ppvaluestored));

        if (ppvaluestored != NULL)
            rpvaluestored = *ppvaluestored;

        fSuccess = TRUE;

    Exit:
        return fSuccess;
    }

private:
    CStringPtrTable(const CStringPtrTable &);
    void operator =(const CStringPtrTable &);
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CStringPtrTableHelper<TValue, TCharTraits, dwCmpFlags> > class CStringPtrTableIter : public CStringTableIter<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper>
{
    typedef CStringTableIter<TValue *, TValue *, TCharTraits, dwCmpFlags, THashHelper> Base;
public:
    CStringPtrTableIter(CStringPtrTable<TValue, TCharTraits, dwCmpFlags, THashHelper> &rTable) : Base(rTable) { }

    operator TValue *() const { return this->GetValue(); }
    TValue *operator ->() const { return this->GetValue(); }

private:
    CStringPtrTableIter(const CStringPtrTableIter &);
    void operator =(const CStringPtrTableIter &);
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0> class CSimpleStringTableHelper : public CStringTableHelper<const TValue &, TValue, TCharTraits, dwCmpFlags>
{
public:
    static BOOL InitializeValue(const TValue &vin, TValue &rvstored) { rvstored = vin; return TRUE; }
    static BOOL UpdateValue(const TValue &vin, TValue &rvstored) { rvstored = vin; return TRUE; }
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CSimpleStringTableHelper<TValue, TCharTraits, dwCmpFlags> > class CSimpleStringTable : public CStringTable<const TValue &, TValue, TCharTraits, dwCmpFlags, THashHelper>
{
public:
    CSimpleStringTable() : CStringTable<const TValue &, TValue, TCharTraits, dwCmpFlags, THashHelper>() { }
private:
    CSimpleStringTable(const CSimpleStringTable &);
    void operator =(const CSimpleStringTable &);
};

template <typename TValue, typename TCharTraits, DWORD dwCmpFlags = 0, typename THashHelper = CSimpleStringTableHelper<TValue, TCharTraits, dwCmpFlags> > class CSimpleStringTableIter : public CStringTableIter<const TValue &, TValue, TCharTraits, dwCmpFlags, THashHelper>
{
    typedef CStringTableIter<const TValue &, TValue, TCharTraits, dwCmpFlags, THashHelper> Base;
public:
    CSimpleStringTableIter(CSimpleStringTable<TValue, TCharTraits, dwCmpFlags, THashHelper> &rTable) : Base(rTable) { }

private:
    CSimpleStringTableIter(const CSimpleStringTableIter &);
    void operator =(const CSimpleStringTableIter &);
};

// CSimpleUnicodeStringTable et al:

template <typename TValue, DWORD dwCmpFlags = 0> class CSimpleUnicodeStringTableHelper : public CSimpleStringTableHelper<TValue, CUnicodeCharTraits, dwCmpFlags>
{
};

template <typename TValue, DWORD dwCmpFlags = 0, typename THashHelper = CSimpleUnicodeStringTableHelper<TValue, dwCmpFlags> > class CSimpleUnicodeStringTable : public CSimpleStringTable<TValue, CUnicodeCharTraits, dwCmpFlags, THashHelper>
{
    typedef CSimpleStringTable<TValue, CUnicodeCharTraits, dwCmpFlags, THashHelper> Base;
public:
    CSimpleUnicodeStringTable() : Base() { }
private:
    CSimpleUnicodeStringTable(const CSimpleUnicodeStringTable &);
    void operator =(const CSimpleUnicodeStringTable &);
};

template <typename TValue, DWORD dwCmpFlags = 0, typename THashHelper = CSimpleUnicodeStringTableHelper<TValue, dwCmpFlags> > class CSimpleUnicodeStringTableIter : public CSimpleStringTableIter<TValue, CUnicodeCharTraits, dwCmpFlags, THashHelper>
{
    typedef CSimpleStringTableIter<TValue, CUnicodeCharTraits, dwCmpFlags, THashHelper> Base;
    typedef CSimpleUnicodeStringTable<TValue, dwCmpFlags, THashHelper> TTable;

public:
    CSimpleUnicodeStringTableIter(TTable &rTable) : Base(rTable) { }
private:
    CSimpleUnicodeStringTableIter(const CSimpleUnicodeStringTableIter &);
    void operator =(const CSimpleUnicodeStringTableIter &);
};

// CCaseInsensitiveSimpleStringTable et al:

template <typename TValue, typename TCharTraits> class CCaseInsensitiveSimpleStringTableHelper : public CSimpleStringTableHelper<TValue, TCharTraits, true>
{
};

template <typename TValue, typename TCharTraits, typename THashHelper = CCaseInsensitiveSimpleStringTableHelper<TValue, TCharTraits> > class CCaseInsensitiveSimpleStringTable : public CSimpleStringTable<TValue, TCharTraits, true, THashHelper>
{
    typedef CSimpleStringTable<TValue, TCharTraits, true, THashHelper> Base;
public:
    CCaseInsensitiveSimpleStringTable() : Base() { }
};

template <typename TValue, typename TCharTraits, typename THashHelper = CCaseInsensitiveSimpleStringTableHelper<TValue, TCharTraits> > class CCaseInsensitiveSimpleStringTableIter : public CSimpleStringTableIter<TValue, TCharTraits, true, THashHelper>
{
    typedef CSimpleStringTableIter<TValue, TCharTraits, true, THashHelper> Base;
public:
    CCaseInsensitiveSimpleStringTableIter(CCaseInsensitiveSimpleStringTable<TValue, TCharTraits, THashHelper> &rTable) : Base(rTable) { }
};

// CCaseInsensitiveSimpleUnicodeStringTable et al:

template <typename TValue> class CCaseInsensitiveSimpleUnicodeStringTableHelper : public CSimpleUnicodeStringTableHelper<TValue, true>
{
};

template <typename TValue, typename THashHelper = CCaseInsensitiveSimpleUnicodeStringTableHelper<TValue> > class CCaseInsensitiveSimpleUnicodeStringTable : public CSimpleUnicodeStringTable<TValue, true, THashHelper>
{
    typedef CSimpleUnicodeStringTable<TValue, true, THashHelper> Base;
public:
    CCaseInsensitiveSimpleUnicodeStringTable() : Base() { }

private:
    CCaseInsensitiveSimpleUnicodeStringTable(const CCaseInsensitiveSimpleUnicodeStringTable &);
    void operator =(const CCaseInsensitiveSimpleUnicodeStringTable &);
};

template <typename TValue, typename THashHelper = CCaseInsensitiveSimpleUnicodeStringTableHelper<TValue> > class CCaseInsensitiveSimpleUnicodeStringTableIter : public CSimpleUnicodeStringTableIter<TValue, true, THashHelper>
{
    typedef CSimpleUnicodeStringTableIter<TValue, true, THashHelper> Base;
public:
    CCaseInsensitiveSimpleUnicodeStringTableIter(CCaseInsensitiveSimpleUnicodeStringTable<TValue, THashHelper> &rTable) : Base(rTable) { }

private:
    CCaseInsensitiveSimpleUnicodeStringTableIter(const CCaseInsensitiveSimpleUnicodeStringTableIter &);
    void operator =(const CCaseInsensitiveSimpleUnicodeStringTableIter &);
};

// CCaseInsensitiveStringPtrTable et al:

template <typename TValue, typename TCharTraits> class CCaseInsensitiveStringPtrTableHelper : public CStringPtrTableHelper<TValue, TCharTraits, true>
{
};

template <typename TValue, typename TCharTraits, typename THashHelper = CCaseInsensitiveStringPtrTableHelper<TValue, TCharTraits> > class CCaseInsensitiveStringPtrTable : public CStringPtrTable<TValue, TCharTraits, true, THashHelper>
{
    typedef CStringPtrTable<TValue, TCharTraits, true, THashHelper> Base;
public:
    CCaseInsensitiveStringPtrTable() : Base() { }
};

template <typename TValue, typename TCharTraits, typename THashHelper = CCaseInsensitiveStringPtrTableHelper<TValue, TCharTraits> > class CCaseInsensitiveStringPtrTableIter : public CStringPtrTableIter<TValue, TCharTraits, true, THashHelper>
{
    typedef CStringPtrTableIter<TValue, TCharTraits, true, THashHelper> Base;

public:
    CCaseInsensitiveStringPtrTableIter(CCaseInsensitiveStringPtrTable<TValue, TCharTraits, THashHelper> &rTable) : Base(rTable) { }
};

// CCaseInsensitiveUnicodeStringPtrTable et al:

template <typename TValue> class CCaseInsensitiveUnicodeStringPtrTableHelper : public CStringPtrTableHelper<TValue, CUnicodeCharTraits, true>
{
};

template <typename TValue, typename THashHelper = CCaseInsensitiveUnicodeStringPtrTableHelper<TValue> > class CCaseInsensitiveUnicodeStringPtrTable : public CStringPtrTable<TValue, CUnicodeCharTraits, true, THashHelper>
{
    typedef CStringPtrTable<TValue, CUnicodeCharTraits, true, THashHelper> Base;
public:
    CCaseInsensitiveUnicodeStringPtrTable() { }

private:
    CCaseInsensitiveUnicodeStringPtrTable(const CCaseInsensitiveUnicodeStringPtrTable &r);
    void operator =(const CCaseInsensitiveUnicodeStringPtrTable &r);
};

template <typename TValue, typename THashHelper = CCaseInsensitiveUnicodeStringPtrTableHelper<TValue> > class CCaseInsensitiveUnicodeStringPtrTableIter : public CStringPtrTableIter<TValue, CUnicodeCharTraits, true, THashHelper>
{
    typedef CStringPtrTableIter<TValue, CUnicodeCharTraits, true, THashHelper> Base;

public:
    CCaseInsensitiveUnicodeStringPtrTableIter(CCaseInsensitiveUnicodeStringPtrTable<TValue, THashHelper> &rTable) : Base(rTable) { }

private:
    CCaseInsensitiveUnicodeStringPtrTableIter(const CCaseInsensitiveUnicodeStringPtrTableIter &);
    void operator =(const CCaseInsensitiveUnicodeStringPtrTableIter &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionpreprocessorcharize.h ===
/*-----------------------------------------------------------------------------
Microsoft Fusion

Microsoft Confidential
Copyright (c) Microsoft Corporation. All Rights Reserved.

@doc external
@module fusionpreprocessorcharize.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_FUSION_PREPROCESSORCHARIZE_H_INCLUDED_) // {
#define VS_COMMON_INC_FUSION_PREPROCESSORCHARIZE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "fusionpreprocessorpaste.h"

#define FusionpPrivatePreprocessorCharize(x) #@ x

/*-----------------------------------------------------------------------------
Name: SxApwPreprocessorCharize, SxApwPreprocessorCharizeW
@macro
These macros simply charize their parameter, after evaluating it;
it is evaluated so that
define A B
SxApwPreprocessorCharize(A) -> 'B' instead of 'A'
SxApwPreprocessorCharizeW(A) -> 'B' instead of L'A'
@owner JayKrell
-----------------------------------------------------------------------------*/
#define FusionpPreprocessorCharize(x)  FusionpPrivatePreprocessorCharize(x)
#define FusionpPreprocessorCharizeW(x) FusionpPreprocessorPaste(L, FusionpPrivatePreprocessorCharize(x))

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionparser.h ===
#if !defined(_FUSION_INC_PARSER_H_INCLUDED_)
#define _FUSION_INC_PARSER_H_INCLUDED_

#pragma once

#include "fusionarray.h"
#include "sxstypes.h"

class CFusionParser
{
public:
    static BOOL ParseULONG(ULONG &rul, PCWSTR sz, SIZE_T cch, ULONG Radix = 10);
    static BOOL ParseFILETIME(FILETIME &rft, PCWSTR sz, SIZE_T cch);
    static BOOL ParseIETFDate( FILETIME &rft, PCWSTR sz, SIZE_T cch );
    static BOOL ParseVersion(ASSEMBLY_VERSION &rav, PCWSTR sz, SIZE_T cch, bool &rfSyntaxValid);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionpreprocessorstringize.h ===
/*-----------------------------------------------------------------------------
Microsoft Fusion

Microsoft Confidential
Copyright Microsoft Corporation. All Rights Reserved.

@doc external
@module fusionpreprocessorstringize.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_FUSION_PREPROCESSORSTRINGIZE_H_INCLUDED_) // {
#define VS_COMMON_INC_FUSION_PREPROCESSORSTRINGIZE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "fusionpreprocessorpaste.h"

#define FusionpPrivatePreprocessorStringize(x) # x

/*-----------------------------------------------------------------------------
Name: FusionpPreprocessorStringize, FusionpPreprocessorStringizeW
@macro
These macros simply stringize their parameter, after evaluating it;
it is evaluated so that
define A B
FusionpPreprocessorStringize(A) -> "B" instead of "A"
FusionpPreprocessorStringizeW(A) -> L"B" instead of L"A"
@owner JayKrell
-----------------------------------------------------------------------------*/
#define FusionpPreprocessorStringize(x) FusionpPrivatePreprocessorStringize(x)
#define FusionpPreprocessorStringizeW(x) FusionpPreprocessorPaste(L, FusionpPrivatePreprocessorStringize(x))

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionprintf.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionprintf.h

Abstract:

    safer sprintf variants

Author:

    Jay Krell (JayKrell) November 2000

Revision History:

    Jay Krell (JayKrell) January 2002
    from base\ntsetup\textmode\kernel\spprintf.c to base\win32\fusion\inc\fusionprintf.h

--*/

#include <stdarg.h>
#include <stdio.h>

//
// _snprintf and co. do not write a terminal nul when the string just fits.
// These function do.
//

inline
void
FusionpFormatStringVaA(
    PSTR Buffer,
    SIZE_T Size,
    PCSTR Format,
    va_list Args
    )
{
    if (Buffer != NULL && Size != 0)
    {
        Buffer[0] = 0;
        Size -= 1;
        if (Size != 0)
        {
            ::_vsnprintf(Buffer, Size, Format, Args);
        }
        Buffer[Size] = 0;
    }
}

inline
void
__cdecl
FusionpFormatStringA(
    PSTR Buffer,
    SIZE_T Size,
    PCSTR Format,
    ...
    )
{
    va_list Args;

    va_start(Args, Format);
    FusionpFormatStringVaA(Buffer, Size, Format, Args);
    va_end(Args);
}

inline
void
FusionpFormatStringVaW(
    PWSTR Buffer,
    SIZE_T Size,
    PCWSTR Format,
    va_list Args
    )
{
    if (Buffer != NULL && Size != 0)
    {
        Buffer[0] = 0;
        Size -= 1;
        if (Size != 0)
        {
            ::_vsnwprintf(Buffer, Size, Format, Args);
        }
        Buffer[Size] = 0;
    }
}

inline
void
__cdecl
FusionpFormatStringW(
    PWSTR Buffer,
    SIZE_T Size,
    PCWSTR Format,
    ...
    )
{
    va_list Args;

    va_start(Args, Format);
    FusionpFormatStringVaW(Buffer, Size, Format, Args);
    va_end(Args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionntdll.h ===
#if !defined(FUSION_INC_FUSIONNTDLL_H_INCLUDED_)
#define FUSION_INC_FUSIONNTDLL_H_INCLUDED_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(FUSION_STATIC_NTDLL)
#if FUSION_WIN
#define FUSION_STATIC_NTDLL 1
#else
#define FUSION_STATIC_NTDLL 0
#endif // FUSION_WIN
#endif // !defined(FUSION_STATIC_NTDLL)

void
FusionpInitializeNTDLLPtr(
    PVOID *ppfn,
    PCSTR szFunctionName
    );

#define FUSION_NTDLL_RETURN_VOID     /* nothing */
#define FUSION_NTDLL_RETURN_NTSTATUS return
#define FUSION_NTDLL_RETURN_WCHAR    return
#define FUSION_NTDLL_RETURN_LONG     return
#define FUSION_NTDLL_RETURN_ULONG    return
#define FUSION_NTDLL_RETURN_DWORD    return
#define FUSION_NTDLL_RETURN_ULONG    return

#if defined(__cplusplus)
#define FUSION_NTDLL_INLINE inline
#else
#define FUSION_NTDLL_INLINE __inline
#endif

#if FUSION_STATIC_NTDLL
#define FUSION_WRAP_NTDLL_FN(_rt, _api, _ai, _ao) FUSION_NTDLL_INLINE _rt Fusionp ## _api _ai { FUSION_NTDLL_RETURN_ ## _rt _api _ao; }
#else
#define FUSION_WRAP_NTDLL_FN(_rt, _api, _ai, _ao) \
extern _rt (NTAPI * g_Fusionp ## _api) _ai; \
FUSION_NTDLL_INLINE _rt Fusionp ## _api _ai { FUSION_NTDLL_RETURN_ ## _rt (*g_Fusionp ## _api) _ao; }
#endif

FUSION_WRAP_NTDLL_FN(WCHAR, RtlUpcaseUnicodeChar, (WCHAR wch), (wch))
FUSION_WRAP_NTDLL_FN(WCHAR, RtlDowncaseUnicodeChar, (WCHAR wch), (wch))
FUSION_WRAP_NTDLL_FN(ULONG, vDbgPrintExWithPrefix, (PCSTR Prefix, ULONG ComponentId, ULONG Level, PCSTR Format, va_list arglist), ((PCH) Prefix, ComponentId, Level, (PCH) Format, arglist))
FUSION_WRAP_NTDLL_FN(DWORD, RtlNtStatusToDosError, (NTSTATUS st), (st))
FUSION_WRAP_NTDLL_FN(NTSTATUS, RtlHashUnicodeString, (PCUNICODE_STRING String, BOOLEAN CaseInSensitive, ULONG HashAlgorithm, PULONG HashValue), (String, CaseInSensitive, HashAlgorithm, HashValue))
FUSION_WRAP_NTDLL_FN(NTSTATUS, RtlExpandEnvironmentStrings_U, (PVOID Environment, PUNICODE_STRING Source, PUNICODE_STRING Destination, PULONG ReturnedLength), (Environment, Source, Destination, ReturnedLength))
FUSION_WRAP_NTDLL_FN(NTSTATUS, NtQueryDebugFilterState, (ULONG ComponentId, ULONG Level), (ComponentId, Level))
FUSION_WRAP_NTDLL_FN(LONG, RtlCompareUnicodeString, (PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive), ((PUNICODE_STRING) String1, (PUNICODE_STRING) String2, CaseInSensitive));
FUSION_WRAP_NTDLL_FN(LONG, RtlUnhandledExceptionFilter, (struct _EXCEPTION_POINTERS *ExceptionInfo), (ExceptionInfo))
FUSION_WRAP_NTDLL_FN(NTSTATUS, NtAllocateLocallyUniqueId, (PLUID Luid), (Luid))
FUSION_WRAP_NTDLL_FN(NTSTATUS, LdrLockLoaderLock, (IN ULONG Flags, OUT ULONG *Disposition OPTIONAL, OUT PVOID *Cookie), (Flags, Disposition, Cookie))
FUSION_WRAP_NTDLL_FN(NTSTATUS, LdrUnlockLoaderLock, (IN ULONG Flags, IN OUT PVOID Cookie), (Flags, Cookie))
FUSION_WRAP_NTDLL_FN(VOID, RtlAcquirePebLock, (VOID), ())
FUSION_WRAP_NTDLL_FN(VOID, RtlReleasePebLock, (VOID), ())

#if DBG
FUSION_WRAP_NTDLL_FN(VOID, RtlAssert, (PVOID FailedAssertion, PVOID FileName, ULONG LineNumber, PCSTR Message), (FailedAssertion, FileName, LineNumber, (PCHAR) Message))
#endif // DBG

FUSION_NTDLL_INLINE ULONG FusionpDbgPrint(PCSTR Format, ...) { ULONG uRetVal; va_list ap; va_start(ap, Format); uRetVal = FusionpvDbgPrintExWithPrefix("", DPFLTR_FUSION_ID, 0, Format, ap); va_end(ap); return uRetVal; }

#if !FUSION_STATIC_NTDLL
FUSION_NTDLL_INLINE void FusionpRtlInitUnicodeString(PUNICODE_STRING ntstr, PCWSTR str)
{
    USHORT Length;

    ntstr->Buffer = (PWSTR)str;
    Length = (USHORT)(wcslen(str) * sizeof(WCHAR));
    ntstr->Length = Length;
    ntstr->MaximumLength = Length + sizeof(WCHAR);
}
#else
#define FusionpRtlInitUnicodeString RtlInitUnicodeString
#endif

#ifdef __cplusplus
}
#endif

#endif // FUSION_INC_FUSIONNTDLL_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionpreprocessorpaste.h ===
/*-----------------------------------------------------------------------------
Microsoft FUSION

Microsoft Confidential
Copyright (c) Microsoft Corporation. All Rights Reserved.

@doc external
@module fusionpreprocessorpaste.h

@owner JayKrell
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_FUSION_PREPROCESSORPASTE_H_INCLUDED_) // {
#define VS_COMMON_INC_FUSION_PREPROCESSORPASTE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#define FusionpPrivatePreprocessorPaste(x, y) x ## y

/*-----------------------------------------------------------------------------
Name: FusionpPreprocessorPaste2, FusionpPreprocessorPaste3, etc.
@macro
These macros paste together n tokens, where n is in the name of the macro.
A level of evaluation is inserted as well.

define A 1
define B 2

FusionpPreprocessorPaste2(A, B) -> 12
@owner JayKrell
-----------------------------------------------------------------------------*/

// These are synonyms.
#define FusionpPreprocessorPaste(x, y)  FusionpPrivatePreprocessorPaste(x, y)
#define FusionpPreprocessorPaste2(x, y) FusionpPrivatePreprocessorPaste(x, y)

#define FusionpPreprocessorPaste3(x, y, z) FusionpPreprocessorPaste(FusionpPreprocessorPaste(x, y), z)
#define FusionpPreprocessorPaste4(w, x, y, z) FusionpPreprocessorPaste(FusionpPreprocessorPaste3(w, x, y), z)
#define FusionpPreprocessorPaste5(v, w, x, y, z) FusionpPreprocessorPaste(FusionpPreprocessorPaste4(v, w, x, y), z)
#define FusionpPreprocessorPaste6(u, v, w, x, y, z) FusionpPreprocessorPaste(FusionpPreprocessorPaste5(u, v, w, x, y), z)

#define FusionpPreprocessorPaste15(a1,a2,a3,a4,a5,a6,a7,a8,a9,a,b,c,d,e,f) \
	FusionpPreprocessorPaste3 \
	( \
		FusionpPreprocessorPaste5(a1,a2,a3,a4,a5), \
		FusionpPreprocessorPaste5(a6,a7,a8,a9,a), \
		FusionpPreprocessorPaste5(b,c,d,e,f) \
	)

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusiontrace.h ===
#if !defined(FUSION_INC_FUSIONTRACE_H_INCLUDED_)
#define FUSION_INC_FUSIONTRACE_H_INCLUDED_

#pragma once

#include "debmacro.h"
#include "CSxsPreserveLastError.h"

#endif // FUSION_INC_FUSIONTRACE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionsetfilepointerex.h ===
#pragma once

#if defined(__cplusplus)
extern "C"
{
#endif

BOOL
WINAPI
FusionpSetFilePointerEx(
    HANDLE         File,
    LARGE_INTEGER  DistanceToMove,
    PLARGE_INTEGER NewFilePointer,
    DWORD          MoveMethod
    );

#if defined(__cplusplus)
} /* extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionregenumkeys.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionregenumkeys.h

Abstract:
    ported from vsee\lib\reg\cenumvalues.h
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#if !defined(FUSION_INC_REG_CENUMKEYS_H_INCLUDED_) // {
#define FUSION_INC_REG_CENUMKEYS_H_INCLUDED_
#pragma once

#include "windows.h"
#include "fusionbuffer.h"
#include "fusionregkey2.h"
#include "lhport.h"

namespace F
{

/*-----------------------------------------------------------------------------
Name: CRegEnumKeys
 
@class
This class wraps RegEnumKeyEx (and optimizes by calling RegQueryInfoKey once).

for
(
	F::CRegEnumKeys ek(hKey);
	ek;
	++ek
)
{
	const F::CBaseStringBuffer& strKey = ek;
	CKey hKeyChild;
	hKeyChild.Open(hKey, strKey);
}
	
class and lastWriteTime are not exposed, but they easily could be

REVIEW should this be called CEnumSubKeys, @hung esk ?

@hung ek

@owner
-----------------------------------------------------------------------------*/
class CRegEnumKeys
{
public:
	// @cmember constructor
	CRegEnumKeys(HKEY) throw(CErr);

	// @cmember are we done yet?
	__declspec(nothrow) operator bool() const /*throw()*/;

	// @cmember move to the next subkey
	VOID operator++() throw(CErr);

	// @cmember move to the next subkey
	VOID operator++(int) throw(CErr);

	// @cmember get the name of the current subkey
	__declspec(nothrow) operator const F::CBaseStringBuffer&() const /*throw()*/;

	// @cmember get the name of the current subkey
	__declspec(nothrow) operator PCWSTR() const /*throw()*/;

protected:
	// @cmember the key being enumerated
	HKEY     m_hKey;

	// @cmember the current index we are into the key's subkeys
	DWORD    m_dwIndex;

	// @cmember the name of a subkey
	F::CTinyStringBuffer m_strSubKeyName;

	// @cmember the number of subkeys
	DWORD    m_cSubKeys;

	// @cmember the maximum length of the subkeys' names
	DWORD    m_cchMaxSubKeyNameLength;

	// @cmember get the current subkey name, called by operator++ and constructor
	VOID ThrGet() throw(CErr);

	// @cmember get the next subkey name, called by operator++
	VOID ThrNext() throw(CErr);

private:
    CRegEnumKeys(const CRegEnumKeys&); // deliberately not impelemented
    void operator=(const CRegEnumKeys&);  // deliberately not impelemented
};

} // namespace

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionregenumvalues.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionregenumvalues.h

Abstract:
    ported from vsee\lib\reg\cenumvalues.h
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#if !defined(FUSION_INC_REG_CENUMVALUES_H_INCLUDED_) // {
#define FUSION_INC_REG_CENUMVALUES_H_INCLUDED_

#include "windows.h"
#include "fusionbuffer.h"
#include "fusionarray.h"
#include "lhport.h"

namespace F
{

/*-----------------------------------------------------------------------------
Name: CRegEnumValues
 
@class
This class wraps RegEnumValue (and optimizes by calling RegQueryInfoKey once).

for
(
	F::CRegEnumValues ev(hKey);
	ev;
	++ev
)
{
	DWORD dwType            = ev.GetType();
	const F::CBaseStringBuffer& strName = ev.GetValueName();
	const BYTE* pbData      = ev.GetValueData();
	DWORD       cbData      = ev.GetValueDataSize();
}
	
@hung ev

@owner
-----------------------------------------------------------------------------*/
class CRegEnumValues
{
public:
	// @cmember Constructor
	CRegEnumValues(HKEY) throw(CErr);

	// @cmember are we done yet?
	__declspec(nothrow) operator bool() const /*throw()*/;

	// @cmember move to the next value
	VOID operator++() throw(CErr);

	// @cmember move to the next value
	VOID operator++(int) throw(CErr);

	// @cmember Returns the number of values
	__declspec(nothrow) DWORD			GetValuesCount()   const /*throw()*/;
		
	// @cmember get type
	DWORD           GetType()          const /*throw()*/;

	// @cmember get value name
	__declspec(nothrow) const F::CBaseStringBuffer& GetValueName()    const /*throw()*/;

	// @cmember get value data
	__declspec(nothrow) const BYTE*     GetValueData()    const /*throw()*/;

	// @cmember get value data size
	__declspec(nothrow) DWORD           GetValueDataSize() const /*throw()*/;

protected:
// order down here is arbitrary

	// @cmember the key being enumerated
	HKEY     m_hKey;

	// @cmember the current index we are into the key's subkeys
	DWORD    m_dwIndex;

	// @cmember the name of the current value
	F::CStringBuffer m_strValueName;

	// @cmember the data of the current value
	CFusionArray<BYTE> m_rgbValueData;

	// @cmember the number of values
	DWORD    m_cValues;

	// @cmember the maximum length of the values' names
	DWORD    m_cchMaxValueNameLength;

	// @cmember the maximum length of the values' data
	DWORD    m_cbMaxValueDataLength;

	// @cmember the length of the current value's data
	DWORD    m_cbCurrentValueDataLength;

	// @cmember REG_SZ, REG_DWORD, etc.
	DWORD    m_dwType;

	// @cmember get the current subkey name, called by operator++ and constructor
	VOID ThrGet() throw(CErr);

	// @cmember get the next subkey name, called by operator++
	VOID ThrNext() throw(CErr);

private:
    CRegEnumValues(const CRegEnumValues&); // deliberately not impelemented
    void operator=(const CRegEnumValues&);  // deliberately not impelemented
};

} // namespace

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionsha1.h ===
#pragma once

#include "fusionarray.h"
#include "wincrypt.h"
#include "fusionhandle.h"

#define A_SHA_DIGEST_LEN 20

#ifndef INVALID_CRYPT_HASH
#define INVALID_CRYPT_HASH (static_cast<HCRYPTHASH>(NULL))
#endif

#define PRIVATIZE_COPY_CONSTRUCTORS( obj ) obj( const obj& ); obj& operator=(const obj&);

class CSha1Context
{
    PRIVATIZE_COPY_CONSTRUCTORS(CSha1Context);
    unsigned char m_workspace[64];
    unsigned long state[5];
    SIZE_T count[2];
    unsigned char buffer[64];

    BOOL Transform( const unsigned char* buffer );

public:
    CSha1Context() { }

    BOOL Update( const unsigned char* data, SIZE_T len );
    BOOL GetDigest( unsigned char* digest, PSIZE_T len );
    BOOL Initialize();
};

/*
void A_SHATransform(CSha1Context* context, const unsigned char buffer);
void A_SHAInit(CSha1Context* context);
void A_SHAUpdate(CSha1Context* context, const unsigned char* data, const ULONG len);
BOOL A_SHAFinal(CSha1Context* context, unsigned char* digest, ULONG *len);
*/


class CFusionHash
{
private:
    PRIVATIZE_COPY_CONSTRUCTORS(CFusionHash);
    
protected:
    CSha1Context m_Sha1Context;
    CCryptHash m_hCryptHash;
    ALG_ID m_aid;
    BOOL m_fInitialized;

    BOOL GetIsValid();

public:
    CFusionHash() 
        : m_fInitialized(FALSE), m_aid(0), m_hCryptHash(INVALID_CRYPT_HASH)
    { }

    BOOL Win32Initialize( ALG_ID aid );
    BOOL Win32HashData(const BYTE *pbBuffer, SIZE_T cbSize);
    BOOL Win32GetValue(OUT CFusionArray<BYTE> &out);
};


//
// There's no "real" invalid value defined anywhere, but by inspecting the
// codebase, NULL is the accepted "invalid" value - check the logon service
// code, they do the same thing.
//
#define INVALID_CRYPT_HANDLE (static_cast<HCRYPTPROV>(NULL))

//
// Global crypto context stuff
//
BOOL SxspAcquireGlobalCryptContext( HCRYPTPROV *pContext );
BOOL
WINAPI
FusionpCryptoContext_DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pvReserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionreg.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionreg.h

Abstract:
    registry pieces of FusionHandle
    other registry stuff -- Win2000 32bit-on-64bit support
 
Author:

    Jay Krell (JayKrell) April 2001

Revision History:

--*/

#pragma once

namespace F
{

BOOL RegistryTypeDwordToString(DWORD, PCWSTR &);
BOOL RegistryTypeStringToDword(PCWSTR, DWORD &);

BOOL RegistryBuiltinRootToString(HKEY, PCWSTR &);
BOOL RegistryBuiltinStringToRoot(PCWSTR, HKEY &);
}

#ifndef  FUSION_ARRAY_DEFINED
#define FUSION_ARRAY_DEFINED
template <typename TStored, typename TPassed = TStored, bool fExponentialGrowth = false, int nDefaultSize = 0, int nGrowthParam = 1>
#else
template <typename TStored, typename TPassed, bool fExponentialGrowth, int nDefaultSize, int nGrowthParam>
#endif
class CFusionArray;

//
// KEY_WOW64_64KEY if it is supported on this system, else 0.
//
DWORD FUSIONP_KEY_WOW64_64KEY();

/* this closes RegOpenKey/RegCreateKey */
class COperatorFRegCloseKey
{
public: BOOL operator()(void* handle) const;
};

//
// there isn't an actual invalid value, and HKEY is not HANDLE.
// The right solution is to keep a seperate bool as in \\JayK1\g\vs\src\vsee\lib\Reg.
// See about porting that over.
//
// 3/20/2001 - JonWis - "NULL" really is the "invalid key" value, as I watched
//      RegOpenKeyExW fill out its out PHKEY with "NULL" when the tag could not be
//      opened.
//
class CRegKey : public CHandleTemplate<&hNull, COperatorFRegCloseKey>
{
private:
    typedef CHandleTemplate<&hNull, COperatorFRegCloseKey> Base;
public:
    ~CRegKey() { }
    CRegKey(void* handle = GetInvalidValue()) : Base(handle) { }
    operator HKEY() const { return reinterpret_cast<HKEY>(m_handle); }
    void operator=(HKEY hkValue) { return Base::operator=(hkValue); }

    BOOL OpenOrCreateSubKey(
		OUT CRegKey &Target,
		IN PCWSTR SubKeyName, 
        IN REGSAM rsDesiredAccess = KEY_ALL_ACCESS,
		IN DWORD dwOptions = 0,
		IN PDWORD pdwDisposition = NULL,
        IN PWSTR pwszClass = NULL) const;
    BOOL OpenSubKey( OUT CRegKey &Target, IN PCWSTR SubKeyName, REGSAM rsAccess = KEY_READ, DWORD ulOptions = 0) const;
    BOOL EnumKey( IN DWORD dwIndex, OUT CBaseStringBuffer &rbuffKeyName, PFILETIME pftLastWriteTime = NULL, PBOOL pbNoMoreItems = NULL ) const;
/*
NTRAID#NTBUG9-591714-2002/03/31-JayKrell
use of CRegKey::LargestSubItemLengths invites race conditions
*/
    BOOL LargestSubItemLengths( PDWORD pdwSubkeyLength = NULL, PDWORD pdwValueLength = NULL ) const;
    BOOL EnumValue(IN DWORD dwIndex, OUT CBaseStringBuffer &rbuffValueName, LPDWORD lpdwType = NULL, PBOOL pbNoMoreItems = NULL );
    BOOL SetValue(IN PCWSTR pcwszValueName, IN DWORD dwRegType, IN const BYTE *pbData, IN SIZE_T cbDataLength) const;
    BOOL SetValue(IN PCWSTR pcwszValueName, IN const CBaseStringBuffer &rcbuffValueValue) const;
    BOOL SetValue(IN PCWSTR pcwszValueName, IN DWORD dwValue) const;
    BOOL DeleteValue(IN PCWSTR pcwszValueName, OUT DWORD &rdwWin32Error, SIZE_T cExceptionalWin32Errors, ...) const;
    BOOL DeleteValue(IN PCWSTR pcwszValueName) const;
    BOOL DeleteKey( IN PCWSTR pcwszValue );
    BOOL DestroyKeyTree();
    BOOL GetValue(IN PCWSTR pcwszValueName, OUT CBaseStringBuffer &rbuffValueData);
    BOOL GetValue(IN const CBaseStringBuffer &rbuffValueName, OUT CBaseStringBuffer &rbuffValueData);
    BOOL GetValue(IN PCWSTR pcwszValueName, OUT CFusionArray<BYTE> &);
    BOOL GetValue(IN const CBaseStringBuffer &pcwszValueName, OUT CFusionArray<BYTE> &);

    BOOL Save( IN PCWSTR TargetFilePath, IN DWORD dwFlags = REG_LATEST_FORMAT, IN LPSECURITY_ATTRIBUTES pSecAttrsOnTargetFile = NULL );
    BOOL Restore( IN PCWSTR SourceFilePath, DWORD dwFlags );

    static HKEY GetInvalidValue() { return reinterpret_cast<HKEY>(Base::GetInvalidValue()); }

private:
    void operator =(const HANDLE);
    CRegKey(const CRegKey &); // intentionally not implemented
    void operator =(const CRegKey &); // intentionally not implemented
};

/*--------------------------------------------------------------------------
inline implementation
--------------------------------------------------------------------------*/

inline BOOL COperatorFRegCloseKey::operator()(void* handle) const
{
    HKEY hk = reinterpret_cast<HKEY>(handle);
    if ((hk != NULL) && (hk != INVALID_HANDLE_VALUE))
    {
        LONG lRet = ::RegCloseKey(reinterpret_cast<HKEY>(handle));
        if (lRet == NO_ERROR)
            return true;
        ::FusionpSetLastWin32Error(lRet);
        return false;
    }
    return true;
}

#if defined(FUSION_WIN)

#define FUSIONP_KEY_WOW64_64KEY KEY_WOW64_64KEY
inline DWORD FusionpKeyWow6464key() { return KEY_WOW64_64KEY; }

#else

#include "fusionversion.h"

inline DWORD FusionpKeyWow6464key()
{
    static DWORD dwResult;
    static BOOL  fInited;
    if (!fInited)
    {
        //
        // GetVersion gets the significance wrong, returning 0x0105 in the lower word.
        // As well since these functions say WindowsNt in their names, they return 0 for Win9x.
        //
        DWORD dwVersion = (FusionpGetWindowsNtMajorVersion() << 8) | FusionpGetWindowsNtMinorVersion();
        if (dwVersion >= 0x0501)
        {
            dwResult = KEY_WOW64_64KEY;
        }
        fInited = TRUE;
    }
    return dwResult;
}

#define FUSIONP_KEY_WOW64_64KEY FusionpKeyWow6464key()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionstring.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionstring.h

Abstract:

    Stuff to futz with everybody's favorite type, generally templatized
        to work on char, wchar_t, or anything else; occasionally
        templatized to work on arbitrary STL style [begin, end)
        sequences.
    Also stuff particularly for NT's UNICODE_STRING.
    To be merged with cfusionbuffer.h.

Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#pragma once

#include <stdio.h>
#include "fusionntdll.h"

//
// This is the main bottleneck for FusionpCompareStrings.
// All overloads should call this directly.
//
int
FusionpCompareStrings(
    PCWSTR sz1,
    SIZE_T cch1,
    PCWSTR sz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    );

#ifdef __cplusplus

class CUnicodeCharTraits;
template <typename T> class CGenericBaseStringBuffer;

//
// This is the main bottleneck for FusionpEqualStrings.
// All overloads call this directly.
//
inline bool
FusionpEqualStrings(
    PCWSTR sz1,
    SIZE_T cch1,
    PCWSTR sz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    )
{
/*
NTRAID#NTBUG9-591667-2002/04/01-JayKrell
string locale case mapping issues
string can be equal even if they have different lengths,
but not at the rtl/fs/ob level, so maybe this is ok
It's good to have this bottleneck regardless.
*/
    return ((cch1 == cch2) && (FusionpCompareStrings(sz1, cch1, sz2, cch2, fCaseInsensitive) == 0));
}


inline bool
FusionpEqualStringsI(
    PCWSTR sz1,
    SIZE_T cch1,
    PCWSTR sz2,
    SIZE_T cch2
    )
{
    return ::FusionpEqualStrings(sz1, cch1, sz2, cch2, true);
}

inline bool
FusionpEqualStrings(
    PCUNICODE_STRING s1,
    PCUNICODE_STRING s2,
    bool fCaseInsensitive
    )
{
    return ::FusionpEqualStrings(
        s1->Buffer, RTL_STRING_GET_LENGTH_CHARS(s1),
        s2->Buffer, RTL_STRING_GET_LENGTH_CHARS(s2),
        fCaseInsensitive
        );
}

inline bool
FusionpEqualStringsI(
    PCUNICODE_STRING s1,
    PCUNICODE_STRING s2
    )
{
    return ::FusionpEqualStrings(
        s1->Buffer, RTL_STRING_GET_LENGTH_CHARS(s1),
        s2->Buffer, RTL_STRING_GET_LENGTH_CHARS(s2),
        true);
}

inline bool
FusionpEqualStringsI(
    PCUNICODE_STRING s1,
    PCWSTR sz2,
    SIZE_T cch2
    )
{
    return ::FusionpEqualStrings(
        s1->Buffer, RTL_STRING_GET_LENGTH_CHARS(s1),
        sz2, cch2,
        true
        );
}

inline bool
FusionpEqualStringsI(
    PCWSTR sz1,
    SIZE_T cch1,
    PCUNICODE_STRING s2
    )
{
    return ::FusionpEqualStrings(
        sz1, cch1,
        s2->Buffer, RTL_STRING_GET_LENGTH_CHARS(s2),
        true
        );
}

inline
int
FusionpCompareStringsI(
    PCWSTR sz1,
    SIZE_T cch1,
    PCUNICODE_STRING s2
    )
{
    return FusionpCompareStrings(
        sz1, cch1,
        s2->Buffer, RTL_STRING_GET_LENGTH_CHARS(s2),
        true);
}


inline
int
FusionpCompareStringsI(
    PCUNICODE_STRING s1,
    PCWSTR sz2,
    SIZE_T cch2
    )
{
    return FusionpCompareStrings(
        s1->Buffer, RTL_STRING_GET_LENGTH_CHARS(s1),
        sz2, cch2,
        true);
}

inline
int
FusionpCompareStrings(
    PCWSTR sz1,
    SIZE_T cch1,
    PCUNICODE_STRING s2,
    bool fCaseInsensitive
    )
{
    return FusionpCompareStrings(
        sz1, cch1,
        s2->Buffer, RTL_STRING_GET_LENGTH_CHARS(s2),
        fCaseInsensitive);
}

inline
int
FusionpCompareStrings(
    PCUNICODE_STRING s1,
    PCWSTR sz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    )
{
    return FusionpCompareStrings(
        s1->Buffer, RTL_STRING_GET_LENGTH_CHARS(s1),
        sz2, cch2,
        fCaseInsensitive);
}

bool
FusionpEqualStringsI(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    PCWSTR psz2,
    SIZE_T cch2
    );

bool
FusionpEqualStringsI(
    PCWSTR psz2,
    SIZE_T cch2,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1
    );

bool
FusionpEqualStringsI(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2
    );

bool
FusionpEqualStrings(
    PCWSTR psz1,
    SIZE_T cch1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2,
    bool fCaseInsensitive
    );

bool
FusionpEqualStrings(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    PCWSTR psz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    );

inline
bool
FusionpEqualStrings(
    PCUNICODE_STRING s1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2,
    bool fCaseInsensitive
    )
{
    return ::FusionpEqualStrings(s1->Buffer, RTL_STRING_GET_LENGTH_CHARS(s1), rbuff2, fCaseInsensitive);
}

inline
bool
FusionpEqualStrings(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    PCUNICODE_STRING s2,
    bool fCaseInsensitive
    )
{
    return ::FusionpEqualStrings(rbuff1, s2->Buffer, RTL_STRING_GET_LENGTH_CHARS(s2), fCaseInsensitive);
}

inline
bool
FusionpEqualStringsI(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    PCUNICODE_STRING s2
    )
{
    return ::FusionpEqualStrings(rbuff1, s2->Buffer, RTL_STRING_GET_LENGTH_CHARS(s2), true);
}

inline
bool
FusionpEqualStringsI(
    PCUNICODE_STRING s1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2
    )
{
    return ::FusionpEqualStrings(s1->Buffer, RTL_STRING_GET_LENGTH_CHARS(s1), rbuff2, true);
}

int
FusionpCompareStrings(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    PCWSTR psz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    );

int
FusionpCompareStrings(
    PCWSTR psz1,
    SIZE_T cch1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2,
    bool fCaseInsensitive
    );

int
FusionpCompareStrings(
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff1,
    const CGenericBaseStringBuffer<CUnicodeCharTraits> &rbuff2,
    bool fCaseInsensitive
    );

int
FusionpCompareStrings(
    PCSTR sz1,
    SIZE_T cch1,
    PCSTR sz2,
    SIZE_T cch2,
    bool fCaseInsensitive
    );

#if !defined(FUSION_CANONICAL_CASE_IS_UPPER)
#define FUSION_CANONICAL_CASE_IS_UPPER 1
#endif // !defined(FUSION_CANONICAL_CASE_IS_UPPER)

#if FUSION_CANONICAL_CASE_IS_UPPER

inline WCHAR FusionpCanonicalizeUnicodeChar(WCHAR wch) { return ::FusionpRtlUpcaseUnicodeChar(wch); }

#else

inline WCHAR FusionpCanonicalizeUnicodeChar(WCHAR wch) { return ::FusionpRtlDowncaseUnicodeChar(wch); }

#endif


inline int
FusionpStrCmpI(
    PCWSTR psz1,
    PCWSTR psz2
    )
{
    return ::FusionpCompareStrings(
        psz1,
        (psz1 != NULL) ? ::wcslen(psz1) : 0,
        psz2,
        (psz2 != NULL) ? ::wcslen(psz2) : 0,
        true);
}

inline bool
FusionpEqualStringsI(
    PCWSTR psz1,
    PCWSTR psz2
    )
{
    return ::FusionpEqualStrings(
        psz1,
        (psz1 != NULL) ? ::wcslen(psz1) : 0,
        psz2,
        (psz2 != NULL) ? ::wcslen(psz2) : 0,
        true);
}

/*-----------------------------------------------------------------------------
StringLength is a generic name for getting the length, in count of
characters, of various kinds of strings
-----------------------------------------------------------------------------*/

inline SIZE_T StringLength(LPCSTR psz)
{
    return ::strlen(psz);
}

inline SIZE_T StringLength(LPCWSTR psz)
{
    return ::wcslen(psz);
}

#if defined(NT_INCLUDED) // { {

inline SIZE_T StringLength(const UNICODE_STRING* s)
{
    return RTL_STRING_GET_LENGTH_CHARS(s);
}

inline SIZE_T StringLength(const ANSI_STRING* s)
{
    return RTL_STRING_GET_LENGTH_CHARS(s);
}

extern const UNICODE_STRING g_strEmptyUnicodeString;

template <typename NT_STRING, typename TChar>
class CGenericNtString : public NT_STRING
{
public:
    ~CGenericNtString() { }

    CGenericNtString(const TChar * buffer, SIZE_T length)
    {
        this->Buffer = const_cast<TChar*>(buffer); // Careful!
        this->Length = static_cast<USHORT>(length * sizeof(*Buffer));
        this->MaximumLength = this->Length;
    }

    CGenericNtString(const TChar* buffer)
    {
        this->Buffer = const_cast<TChar*>(buffer);
        this->Length = static_cast<USHORT>(::StringLength(buffer) * sizeof(*Buffer));
        this->MaximumLength = this->Length;
    }

//protected:
    CGenericNtString()
    {
        const static TChar zero;
        this->Buffer = const_cast<TChar*>(&zero);
        this->Length = sizeof(*Buffer);
        this->MaximumLength = this->Length;
    }

private: // deliberately not implemented
    CGenericNtString(const CGenericNtString&);
    void operator=(const CGenericNtString&);
};

typedef CGenericNtString<ANSI_STRING, CHAR> CAnsiString;

class CUnicodeString : public CGenericNtString<UNICODE_STRING, WCHAR>
{
    typedef CGenericNtString<UNICODE_STRING, WCHAR> Base;
public:
    ~CUnicodeString() { }

    CUnicodeString(PCWSTR buffer, SIZE_T length) : Base(buffer, length) { }
    CUnicodeString(PCWSTR buffer) : Base(buffer) { }

    operator const UNICODE_STRING *() const { return this; }

    void operator=(PCWSTR buffer)
    {
        this->Buffer = const_cast<PWSTR>(buffer); // Careful!
        this->Length = static_cast<USHORT>(::StringLength(buffer) * sizeof(*Buffer));
        this->MaximumLength = this->Length;
    }

    void Sync()
    {
        this->Length = static_cast<USHORT>(::StringLength(Buffer) * sizeof(*Buffer));
    }

    int FormatV(PCWSTR pszFormat, va_list args)
    {
        // note that vsnprintf doesn't nul terminate if there isn't room,
        // it squeezes the nul out in favor of an additional character,
        // we work around this by telling it one char less, and by always
        // putting a nul at the end
        int cchMaximumLength = this->MaximumLength / sizeof(*Buffer);
        this->Buffer[cchMaximumLength - 1] = 0;
        int i = _vsnwprintf(this->Buffer, cchMaximumLength - 1, pszFormat, args);
        if (i >= 0)
        {
            this->Buffer[i] = 0;
            this->Length = static_cast<USHORT>(i * sizeof(*Buffer));
        }
        return i;
    }

    int Format(PCWSTR pszFormat, ...)
    {
        va_list args;
        va_start(args, pszFormat);
        int i = FormatV(pszFormat, args);
        va_end(args);
        return i;
    }

//protected:
    CUnicodeString() { }

private: // deliberately not implemented
    CUnicodeString(const CUnicodeString&);
    void operator=(const CUnicodeString&);
};

template <int N>
class CUnicodeStringN : public CUnicodeString
{
public:
    ~CUnicodeStringN() { }

    CUnicodeStringN()
    {
        this->Buffer = m_rgchBuffer;
        this->Length = 0;
        this->MaximumLength = sizeof(m_rgchBuffer);

        m_rgchBuffer[0] = 0;
        m_rgchBuffer[N-1] = 0;
    }

    WCHAR m_rgchBuffer[N];

private: // deliberately not implemented
    CUnicodeStringN(const CUnicodeStringN&);
    void operator=(const CUnicodeStringN&);
};

#endif // } }

/*-----------------------------------------------------------------------------
genericized name for strchr and wcschr
-----------------------------------------------------------------------------*/
//template <typename Char> const Char* StringFindChar(const Char* s, Char ch)
// Automatically provide non const, but looser type binding between s
// and ch. Still requires nul termination, so doesn't really support more than
// char*, const char*, wchar_t*, and const wchar_t*.
//
// StdFind is the obvious generalization that doesn't require a particular
// terminal value, but the ability to pass a terminal pointer or iterator.
template <typename String, typename Char>
inline String
StringFindChar(String s, Char ch)
{
    String end = s + StringLength(s);
    String found = StdFind(s, end, ch);
    if (found == end)
    {
        found = NULL;
    }
    return found;
}

/*-----------------------------------------------------------------------------
specialize StringFindChar for char to use strchr provided
in msvcrt.dll or ntdll.dll.
-----------------------------------------------------------------------------*/
// strchr is getting defined to be StrChrW, which does not work.
#if !defined(strchr) // { {
template <>
inline const char* StringFindChar<const char*>(const char* s, char ch)
{
    s = strchr(s, ch);
    return s;
}

template <>
inline char* StringFindChar<char*>(char* s, char ch)
{
    s = strchr(s, ch);
    return s;
}
#endif // } }

/*-----------------------------------------------------------------------------
specialize StringFindChar for wchar_t to use wcschr provided
in msvcrt.dll or ntdll.dll.
-----------------------------------------------------------------------------*/
template <>
inline const wchar_t* StringFindChar<const wchar_t*>(const wchar_t* s, wchar_t ch)
{
    s = wcschr(s, ch);
    return s;
}

template <>
inline wchar_t* StringFindChar<wchar_t*>(wchar_t* s, wchar_t ch)
{
    s = wcschr(s, ch);
    return s;
}

/*-----------------------------------------------------------------------------
common code for StringReverseSpan and StringReverseComplementSpan
-----------------------------------------------------------------------------*/
template <typename Char>
INT
PrivateStringReverseSpanCommon(
    const Char* begin,
    const Char* end,
    const Char* set, // nul terminated
    bool breakVal
    )
{
    const Char* t = end;
    while (t != begin)
    {
        if (breakVal == !!StringFindChar(set, *--t))
        {
            ++t; // don't count the last checked one
            break;
        }
    }
    return static_cast<INT>(end - t);
}


/*-----------------------------------------------------------------------------
Find the length of the run of characters in set from the end of [begin, end).
"wcsrspn"
variants of this can be seen at
    \vsee\lib\xfcstr\strexw.cpp
    and \\jayk1\g\temp\rspn.cpp
-----------------------------------------------------------------------------*/
template <typename Char>
inline INT
StringReverseSpan(
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    // break when not found
    return ::PrivateStringReverseSpanCommon(begin, end, set, false);
}

/*-----------------------------------------------------------------------------
Find the length of the run of characters not in set from the end of [begin, end).
"wcsrcspn"
variants of this can be seen at
    \vsee\lib\xfcstr\strexw.cpp
    and \\jayk1\g\temp\rspn.cpp
-----------------------------------------------------------------------------*/
template <typename Char>
inline INT
StringReverseComplementSpan(
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    // break when found
    return ::PrivateStringReverseSpanCommon(begin, end, set, true);
}


template <typename Char>
inline INT
StringReverseComplimentSpan( // alternate spelling
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    return StringReverseComplementSpan(begin, end, set);
}

template <typename Char>
inline INT
PrivateStringSpanCommon(
    const Char* begin,
    const Char* end,
    const Char* set,
    bool breakVal
    )
{
    const Char* t = begin;

    while ( t != end )
    {
        if (breakVal == !!StringFindChar(set, *t++)) 
        {
            --t;
            break;
        }
    }
    return static_cast<INT>(t - begin);
}


template <typename Char>
inline INT
StringSpan(
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    return ::PrivateStringSpanCommon( begin, end, set, false );
}

template <typename Char>
inline INT
StringComplimentSpan(
    const Char* begin,
    const Char* end,
    const Char* set
    )
{
    return ::PrivateStringSpanCommon( begin, end, set, true );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionregkey2.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionregenumkeys.h

Abstract:
    ported from vsee\lib\reg\ckey.h
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#if !defined(FUSION_INC_REGKEY2_H_INCLUDED_) // {
#define FUSION_INC_REGKEY2_H_INCLUDED_
#pragma once

#include "windows.h"
#include "fusionbuffer.h"
#include "lhport.h"

namespace F
{

/*-----------------------------------------------------------------------------
Name: CRegKey2
 
@class
This class is a "smart" wrapper for an HKEY.

@hung key or hkey

@owner
-----------------------------------------------------------------------------*/
class CRegKey2
{
public:
	// @cmember constructor
	__declspec(nothrow) CRegKey2() /*throw()*/;

	// @cmember constructor
	__declspec(nothrow) CRegKey2(HKEY) /*throw()*/;

	// @cmember destructor
	__declspec(nothrow) ~CRegKey2() /*throw()*/;

	// @cmember open
	void ThrOpen(HKEY hKeyParent, PCWSTR pszKeyName, REGSAM samDesired = KEY_READ) throw(CErr);

	// @cmember open can fail reasonably with
	// at least ERROR_FILE_NOT_FOUND (2),
	// can still throw for invalid parameters, etc.
	__declspec(nothrow) HRESULT HrOpen(HKEY hKeyParent, PCWSTR pszKeyName, REGSAM samDesired = KEY_READ) /*throw()*/;

	// @cmember return disposition
	DWORD Create(HKEY hKeyParent, PCWSTR pszKeyName, REGSAM samDesired = KEY_ALL_ACCESS) throw(CErr);

	// @cmember Delete a value from registry
	void ThrDeleteValue ( const F::CBaseStringBuffer& strValueName );

	// @cmember operator =
	VOID operator=(HKEY) throw(CErr);

	// @cmember operator HKEY
	operator HKEY() throw(CErr); // bitwise const, but not necessarily logically const

	// @cmember same as operator=
	void ThrAttach(HKEY) throw(CErr);

	__declspec(nothrow) HKEY Detach() /*throw()*/;

	// @cmember set value
	void ThrSetValue(PCWSTR pszValueName, const F::CBaseStringBuffer& strValue) throw(CErr);

	// @cmember set value
	void ThrSetValue(PCWSTR pszValueName, const DWORD& dwValue) throw(CErr);

	// @cmember query value
	void ThrQueryValue(PCWSTR pszValueName, DWORD* pdwType, BYTE* pbData, DWORD* pcbData) const throw(CErr);

	// @cmember query value
	void ThrQueryValue(PCWSTR szValueName, F::CBaseStringBuffer* pstrValue) const throw(CErr);

	// @cmember FUTURE
	//void ThrQueryValue(PCWSTR szValueName, DWORD* pdwValue) const throw(CErr);

	// @cmember query can fail reasonably with at least ERROR_FILE_NOT_FOUND (==2),
	// can still throw for invalid parameters, etc.
	HRESULT HrQueryValue(PCWSTR szValueName, F::CBaseStringBuffer* pstrValue) const throw(CErr);

	// @cmember query can fail reasonably with at least ERROR_FILE_NOT_FOUND (==2),
	// can still throw for invalid parameters, etc.
	HRESULT HrQueryValue(PCWSTR szValueName, DWORD* pdwValue) const throw(CErr);

	// @cmember a subset of RegQueryInfoKey
	// consumed by CEnumValues
	static void ThrQueryValuesInfo(HKEY hKey, DWORD* pcValues, DWORD* pcchMaxValueNameLength, DWORD* pcbMaxValueLength) throw(CErr);

	// @cmember a subset of RegQueryInfoKey
	// consumed by CEnumKeys
	static void ThrQuerySubKeysInfo(HKEY hKey, DWORD* pcSubKeys, DWORD* pcchMaxSubKeyNameLength) throw(CErr);

	// @cmember
	// intended client is CEnumKeys, so lack of F::CStringBuffer support is ok
	static void ThrEnumKey(HKEY hKey, DWORD dwIndex, PWSTR pszSubKeyName, DWORD* pcchSubKeyNameLength) throw(CErr);
	static LONG RegEnumKey(HKEY hKey, DWORD dwIndex, PWSTR pszSubKeyName, DWORD* pcchSubKeyNameLength) throw(CErr);

	// @cmember
	// intended client is CEnumValues, so lack of F::CStringBuffer support is ok
	static void ThrEnumValue(HKEY hKey, DWORD dwIndex, PWSTR pszValueName, DWORD* pcchValueNameLength, DWORD* pdwType, BYTE* pbData, DWORD* pcbData) throw(CErr);

	// @cmember query values into
	void ThrQueryValuesInfo(DWORD* pcValues, DWORD* pcchMaxValueNameLength, DWORD* cbMaxValueLength) const throw(CErr);

	// @cmember Recursively delete keys
	void ThrRecurseDeleteKey(LPCWSTR lpszKey) throw(CErr);

	// @cmember Delete a sub key
	void DeleteSubKey(LPCWSTR lpszSubKey) throw(CErr);

	// @cmember FUTURE no clients
	//void ThrQuerySubKeysInfo(DWORD* pcSubKeys, DWORD* pcchMaxSubKeyNameLength) const throw(CErr);

	// @cmember FUTURE no clients
	//void ThrEnumValue(DWORD dwIndex, PWSTR pszValueName, DWORD* pcchValueNameLength, DWORD* pdwType, BYTE* pbData, DWORD* pcbData) const throw(CErr);

	// @cmember FUTURE no clients
	//void ThrEnumKey(DWORD dwIndex, PWSTR pszSubKeyName, DWORD* pcchSubKeyNameLength) const throw(CErr);

	/* FUTURE stuff from ATL 6.0
		LONG Close();
		HKEY Detach();
		void Attach(HKEY hKey);
		LONG DeleteValue(LPCTSTR lpszValue);
	*/

	// because there is no documented invalid value for HKEY, we do
	// not offer a way to get at the HKEY directly to store over it;
	// we must maintain the m_fValid member datum.
	// HKEY* PhPointerToUnderlying();

protected:
	// @cmember a regular HKEY that we wrap
	HKEY m_hKey;

	// @cmember
	// so that VReadString doesn't call RegQueryInfoKey every time
	// invalidated by VSetValue, but we still handle
	// ERROR_MORE_DATA in VReadString since this isn't robust
	mutable DWORD m_cbMaxValueLength;

	// bools at end for alignment reasons

	// @cmember since there is no documented invalid value for HKEY, this
	// seperate bool indicates if we have a valid value.
	bool m_fValid;

	// @cmember is m_cbMaxValueLength up to date as far as we know.
	mutable bool  m_fMaxValueLengthValid;

	// @cmember access value is valid
	bool m_fKnownSam;

	// @cmember keep the access that we opened with.
	REGSAM m_samDesired;

	// @cmember Needs a definition
	operator HKEY() const throw(CErr); // bitwise const, but not necessarily logically const

	// @cmember fix up nulls etc
	__declspec(nothrow) static VOID
	FixBadRegistryStringValue
	(
        HKEY   Key,
        PCWSTR ValueName,
		DWORD  cbActualBufferSize,
		LONG   lRes,
		DWORD  dwType,
		BYTE*  pbData,
		DWORD* pcbData
	) /*throw()*/;

	// @cmember query info
	static VOID
	ThrQueryInfo
	(
		HKEY      hKey,
		WCHAR*    pClass,
		DWORD*    pcbClass,
		DWORD*    pReserved,
		DWORD*    pcSubKeys,
		DWORD*    pcchMaxSubKeyLength,
		DWORD*    pcchMaxClassLength,
		DWORD*    pcValues,
		DWORD*    pcchMaxValueNameLength,
		DWORD*	  pcbMaxValueDataLength,
		DWORD*    pcbSecurityDescriptorLength,
		FILETIME* pftLastWriteTime
	) throw(CErr);

    static void GetKeyNameForDiagnosticPurposes(HKEY, F::CUnicodeBaseStringBuffer &);

private:
    CRegKey2(const CRegKey2&); // deliberately not impelemented
    void operator=(const CRegKey2&);  // deliberately not impelemented
};

} // namespace

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionversion.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusionversion.h

Abstract:
 
Author:

    Jay Krell (JayKrell) April 2001

Revision History:

--*/

#pragma once

inline DWORD FusionpGetWindowsNtBuildVersion()
{
    DWORD dwVersion = GetVersion();
    if ((dwVersion & 0x80000000) != 0)
        return 0;
    return (dwVersion & 0xffff0000) >> 16;
}

inline DWORD FusionpGetWindowsNtMinorVersion()
{
    DWORD dwVersion = GetVersion();
    if ((dwVersion & 0x80000000) != 0)
        return 0;
    return (dwVersion & 0xff00) >> 8;
}

inline DWORD FusionpGetWindowsNtMajorVersion()
{
    DWORD dwVersion = GetVersion();
    if ((dwVersion & 0x80000000) != 0)
        return 0;
    return (dwVersion & 0xff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionunused.h ===
#pragma once
#if !defined(UNUSED)
#define UNUSED(x) x
#endif
#if DBG
#define RETAIL_UNUSED(x) /* nothing */
#else
#define RETAIL_UNUSED(x) UNUSED(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusion_msxml_sax_attributes.h ===
#pragma once

//
// Per BryanT, either do not use #import, or checkin what it produces.
//
//#pragma warning(disable:4192) // automatically excluding 'IErrorInfo' while importing type library 'msxml3.dll'
//#import "msxml3.dll"
#include "fusion_msxml3.tlh"

namespace F
{

void ThrowHresult(HRESULT hr);

class CXmlAttributes
//
// This class combines the interface pointers to one object.
//
{
public:
    ~CXmlAttributes() { Release(); }

    CXmlAttributes()
    {
        HRESULT hr = 0;

        if (FAILED(hr = this->IMXAttributes.CreateInstance(const_cast<PWSTR>(L"Msxml2.SAXAttributes.3.0"))))
            ThrowHresult(hr);
        this->ISAXAttributes = this->IMXAttributes;
    }

    void Release()
    {
        if (this->IMXAttributes != NULL)
        {
            this->IMXAttributes.Release();
        }
        if (this->ISAXAttributes != NULL)
        {
            this->ISAXAttributes.Release();
        }
    }

    operator MSXML2::ISAXAttributes * () { return this->ISAXAttributes; }

    HRESULT clear() { return this->IMXAttributes->clear(); }

    HRESULT addAttribute(
        _bstr_t strURI,
        _bstr_t strLocalName,
        _bstr_t strQName,
        _bstr_t strType,
        _bstr_t strValue)
    {
        return this->IMXAttributes->addAttribute(
            strURI,
            strLocalName,
            strQName,
            strType,
            strValue);
    }

    MSXML2::IMXAttributesPtr  IMXAttributes;
    MSXML2::ISAXAttributesPtr ISAXAttributes;
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusionxml.h ===
#if !defined(_FUSION_INC_FUSIONXML_H_INCLUDED_)
#define _FUSION_INC_FUSIONXML_H_INCLUDED_

#pragma once

void
SxspDumpXmlTree(
    IN DWORD Flags,
    IN PCSXS_XML_DOCUMENT Document
    );

void
SxspDumpXmlSubTree(
    IN PCWSTR PerLinePrefix,
    IN PCSXS_XML_DOCUMENT Document, // need for string table resolution
    IN PCSXS_XML_NODE Node
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\lhport.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    lhport.h

Abstract:
    for porting code from longhorn (namespaces, exceptions)
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/
#pragma once

#include "debmacro.h"
#include "fusionbuffer.h"
#include "fusionlastwin32error.h"
#include "fusionhandle.h"

#pragma warning(disable:4290) /* exception specifications mostly ignored */
namespace F
{
typedef :: CStringBuffer CStringBuffer;
typedef :: CStringBufferAccessor CStringBufferAccessor;
typedef :: CUnicodeBaseStringBuffer CUnicodeBaseStringBuffer;
typedef :: CBaseStringBuffer CBaseStringBuffer;
typedef :: CTinyStringBuffer CTinyStringBuffer;
typedef :: CDynamicLinkLibrary CDynamicLinkLibrary;
inline BOOL InitializeHeap(HMODULE Module) { return FusionpInitializeHeap(Module); }
inline void UninitializeHeap() { FusionpUninitializeHeap(); }
inline DWORD GetLastWin32Error() { return FusionpGetLastWin32Error(); }
inline void SetLastWin32Error(DWORD dw) { return FusionpSetLastWin32Error(dw); }

class CErr
{
public:
    static void ThrowWin32(DWORD dw) {
        CErr e; ASSERT_NTC(dw != ERROR_SUCCESS); e.m_Type = eWin32Error; e.m_Win32Error = dw; throw e; }

    static void ThrowHresult(HRESULT hr) {
        CErr e; ASSERT_NTC(hr != S_OK); e.m_Type = eHresult; e.m_Hresult = hr; throw e; }

    bool IsWin32Error(DWORD dw) const {
        return (this->m_Type == eWin32Error && this->m_Win32Error == dw)
            || (this->m_Type == eHresult && HRESULT_FROM_WIN32(dw) == m_Hresult); }

    enum EType { eNtStatus, eHresult, eWin32Error };
    EType m_Type;
    union
    {
        LONG    m_NtStatus;
        HRESULT m_Hresult;
        DWORD   m_Win32Error;
    };
};

class CFnTracerVoidThrow : public ::CFrame
{
public:
    CFnTracerVoidThrow(const SXS_STATIC_TRACE_CONTEXT &rsftc) : CFrame(rsftc) { }
    ~CFnTracerVoidThrow() { if (g_FusionEnterExitTracingEnabled) ::FusionpTraceCallExit(); }
    void MarkInternalError()        { this->MarkWin32Failure(ERROR_INTERNAL_ERROR); }
    void MarkAllocationFailed()     { this->MarkWin32Failure(FUSION_WIN32_ALLOCFAILED_ERROR); }
    void MarkWin32LastErrorFailure(){ this->MarkWin32Failure(this->GetLastError()); }
    void MarkWin32Failure(DWORD dw) { F::CErr::ThrowWin32(dw); }
    void MarkCOMFailure(HRESULT hr) { F::CErr::ThrowHresult(hr); }
    void MarkSuccess() { }
    void ReturnValue() const { }

private:
    void operator=(const CFnTracerVoidThrow&); // intentionally not implemented
    CFnTracerVoidThrow(const CFnTracerVoidThrow&); // intentionally not implemented
};

#define FN_PROLOG_VOID_THROW DEFINE_STATIC_FN_TRACE_CONTEXT(); F::CFnTracerVoidThrow __t(__stc); __t.Enter()
#define FN_EPILOG_THROW FN_EPILOG

// These are not right, but ok for "tools".
#define ORIGINATE_COM_FAILURE_AND_EXIT(x, hr) IFCOMFAILED_ORIGINATE_AND_EXIT(hr)
#define ThrResizeBuffer Win32ResizeBuffer
#define ThrAssign Win32Assign
#define ThrFormatAppend Win32FormatAppend
#define ThrAppend Win32Append

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\numberof.h ===
////
// Macro for dimension of static arrays.
#if !defined(FUSION_INC_NUMBEROF_H_INCLUDED_)
#define FUSION_INC_NUMBEROF_H_INCLUDED_

#pragma once

#if defined(NUMBER_OF)
#undef NUMBER_OF
#endif

#if FUSION_USE_CHECKED_NUMBER_OF

//
//   Note!
//
//  Use of this "checked" number of macro causes CRT initializers to have to run
//  for static/constant arrays.
//
//  We cannot enable this for fusion right now, but turning it on and running at
//  least will lead to the compiler errors
//


// Static arrays will match this signature.
template< typename	T
		>
inline
SIZE_T
NUMBER_OF_validate
		( void const *
		, T
		)
throw()
{
	return (0);
}

// Other things (e.g. pointers) will match this signature.
template< typename	T
		>
inline
void
NUMBER_OF_validate
		( T * const
		, T * const *
		)
throw()
{
}

// Use the size of the validation function's return type to create an
//	error when this macro is misused.
#define NUMBER_OF(array)									\
		(sizeof(NUMBER_OF_validate((array), &(array))),	\
			(sizeof((array)) / sizeof((array)[0])))

#else

#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

#endif // FUSION_USE_CHECKED_NUMBER_OF

#endif // !defined(FUSION_INC_NUMBEROF_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\perfclocking.h ===
#ifndef __FUSION_PERFCLOCKING
#define __FUSION_PERFCLOCKING

typedef struct _tagFUSION_PERF_INFO
{
    LARGE_INTEGER   AccumulatedCycles;
    LARGE_INTEGER   LineHits;
    BOOL            bInitialized;
    int             iSourceLine;
    CHAR            *pSourceFile;
    CHAR            *pStatement;

#ifdef __cplusplus
    _tagFUSION_PERF_INFO() { AccumulatedCycles.QuadPart = LineHits.QuadPart = 0; bInitialized = FALSE; }
#endif
} FUSION_PERF_INFO, *PFUSION_PERF_INFO;

#if defined(DBG) && defined(FUSION_PROFILING)

#define PERFINFOTIME( pPerfInfo, statement ) \
{ \
    if ( !(pPerfInfo)->bInitialized ) { \
        (pPerfInfo)->iSourceLine = __LINE__; \
        (pPerfInfo)->pSourceFile = __FILE__; \
        (pPerfInfo)->pStatement = (#statement); \
        (pPerfInfo)->bInitialized = TRUE; \
    } \
    TIMEANDACCUMULATE( (pPerfInfo)->AccumulatedCycles, statement ); \
    (pPerfInfo)->LineHits.QuadPart++; \
}

#define CLOCKINTO( destiny ) \
    __asm { __asm cpuid __asm rdtsc }; \
    __asm { mov destiny.HighPart, edx }; \
    __asm { mov destiny.LowPart, eax };



#define STARTCLOCK( destination, lag ) \
{ \
    LARGE_INTEGER __start, __stop; \
    LARGE_INTEGER *__pdest = &(destination), *__plag = &(lag); \
    CLOCKINTO( __start );

#define STOPCLOCK() \
    CLOCKINTO( __stop ); \
    __pdest->QuadPart = __stop.QuadPart - ( __start.QuadPart + __plag->QuadPart ); \
}

#define STARTCLOCKACCUMULATE( accum, lag ) \
{ \
    LARGE_INTEGER __start, __stop; \
    LARGE_INTEGER *__acc = &(accum), *__plag = &(lag); \
    CLOCKINTO( __start ); \

#define STOPCLOCKACCUMULATE() \
    CLOCKINTO( __stop ); \
    __acc->QuadPart += ( __stop.QuadPart - ( __start.QuadPart + __plag->QuadPart ) ); \
}

#define TIMEANDACCUMULATE( accumulator, statement ) \
    TIMEANDACCUMULATEWITHLAG( accumulator, statement, CpuIdLag )

#define TIMEANDACCUMULATEWITHLAG( accumulator, statement, lag ) \
    STARTCLOCKACCUMULATE( accumulator, lag ); \
    statement; \
    STOPCLOCKACCUMULATE();

#define FUSIONPERF_DUMP_TARGET_MASK     ( 0x0000000F )
#define FUSIONPERF_DUMP_TO_DEBUGGER     ( 0x00000001 )
#define FUSIONPERF_DUMP_TO_STDOUT       ( 0x00000002 )
#define FUSIONPERF_DUMP_TO_STDERR       ( 0x00000003 )

#define FUSIONPERF_DUMP_ALL_MASK		( 0x00000F00 )
#define FUSIONPERF_DUMP_ALL_STATISTICS	( 0x00000100 )
#define FUSIONPERF_DUMP_ALL_SOURCEINFO	( 0x00000200 )
#define FUSIONPERF_DUMP_ALL_CONCISE     ( 0x00000400 )
#define FUSIONPERF_DUMP_TALLYS          ( 0x00001000 )

inline static VOID
FusionpDumpPerfInfo( DWORD dwFlags, PFUSION_PERF_INFO pInfo )
{
/*
NTRAID#NTBUG9-591616-2002/03/31-JayKrell
large frame
*/
    CStringBuffer sbTemp;

	if ( dwFlags & FUSIONPERF_DUMP_ALL_SOURCEINFO )
	{
/*
NTRAID#NTBUG9-591616-2002/03/31-JayKrell
missing check for error
*/
		sbTemp.Win32Format(
			L"Perf: %S(%d) - Hit %I64d times\n\t%I64d cycles total, %I64d average\n\t%S\n",
			pInfo->pSourceFile,
			pInfo->iSourceLine,
			pInfo->LineHits.QuadPart,
			pInfo->AccumulatedCycles.QuadPart,
			pInfo->AccumulatedCycles.QuadPart / pInfo->LineHits.QuadPart,
			pInfo->pStatement
		);
	}
	else if ( dwFlags & FUSIONPERF_DUMP_ALL_CONCISE )
	{
/*
NTRAID#NTBUG9-591616-2002/03/31-JayKrell
missing check for error
*/
		sbTemp.Win32Format(
			L"%S(%d) - Hit %I64d times %I64d cycles total %I64d average\n",
			pInfo->pSourceFile,
			pInfo->iSourceLine,
			pInfo->LineHits.QuadPart,
			pInfo->AccumulatedCycles.QuadPart,
			pInfo->AccumulatedCycles.QuadPart / pInfo->LineHits.QuadPart
		);
	}
	else
	{
/*
NTRAID#NTBUG9-591616-2002/03/31-JayKrell
missing check for error
*/
		sbTemp.Win32Format(
			L"Perf: %S(%d) - Hit %I64d times, \n\t%I64d cycles total, %I64d average\n",
			pInfo->pSourceFile,
			pInfo->iSourceLine,
			pInfo->LineHits.QuadPart,
			pInfo->AccumulatedCycles.QuadPart,
			pInfo->AccumulatedCycles.QuadPart / pInfo->LineHits.QuadPart
		);
	}

    switch ( dwFlags & FUSIONPERF_DUMP_TARGET_MASK )
    {
    case FUSIONPERF_DUMP_TO_DEBUGGER:
        OutputDebugStringW( static_cast<PCWSTR>(sbTemp) );
        break;
    case FUSIONPERF_DUMP_TO_STDOUT:
        wprintf( static_cast<PCWSTR>(sbTemp) );
        break;
    case FUSIONPERF_DUMP_TO_STDERR:
        fwprintf( stderr, static_cast<PCWSTR>(sbTemp) );
        break;
    }
}

inline static VOID
FusionpReportPerfInfo( DWORD dwFlags, FUSION_PERF_INFO Info[], SIZE_T cInfo )
{
	LARGE_INTEGER liAveragedTotalHits, liRawTotalCycles;
	liAveragedTotalHits.QuadPart = 0;
	liRawTotalCycles.QuadPart = 0;

	for ( SIZE_T i = 0; i < cInfo; i++ )
	{
		if ( dwFlags & FUSIONPERF_DUMP_ALL_STATISTICS )
		{
			FusionpDumpPerfInfo( dwFlags, Info + i );
		}

		liAveragedTotalHits.QuadPart +=
			( Info[i].AccumulatedCycles.QuadPart / Info[i].LineHits.QuadPart );
	    liRawTotalCycles.QuadPart += Info[i].AccumulatedCycles.QuadPart;
	}

	wprintf( L"Perf: Profiled %Iu statements, cyclecount average per set %I64d\n"
	         L"      %I64d total cycles in this set",
		cInfo,
		liAveragedTotalHits.QuadPart,
		liRawTotalCycles.QuadPart
	);
}


#define PERFINFOSINGLESTATEMENT( statement ) \
{ \
	FUSION_PERF_INFO __dumpinfo; \
	TIMEANDACCUMULATE( &__dumpinfo, statement ); \
	FusionpDumpPerfInfo( FUSIONPERF_DUMP_TO_STDOUT, &__dumpinfo ); \
}
	


#else

#define PERFINFOTIME( pDump, statement ) statement;
#define TIMEANDACCUMULATE( a, s ) s;
#define TIMEANDACCUMULATEWITHLAG( a, s, l ) s;
#define FusionpReportPerfInfo( a, b, c )
#define FusionpDumpPerfInfo( a, b )
#define PERFINFOSINGLESTATEMENT( statement ) statement;

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\fusion_msxml_sax_writer.h ===
#pragma once

//
// Per BryanT, either do not use #import, or checkin what it produces.
//
//#pragma warning(disable:4192) // automatically excluding 'IErrorInfo' while importing type library 'msxml3.dll'
//#import "msxml3.dll"
#include "fusion_msxml3.tlh"

namespace F
{

void ThrowHresult(HRESULT hr);

class CXmlWriter
//
// This class combines the interface pointers to one object.
//
{
public:

    ~CXmlWriter() { Release(); }

    CXmlWriter()
    {
        HRESULT hr;

        if (FAILED(hr = this->IMXWriter.CreateInstance(const_cast<PWSTR>(L"Msxml2.MXXMLWriter.3.0"))))
            ThrowHresult(hr);
        this->ISAXContentHandler = this->IMXWriter;
    }

    void Release()
    {
        if (this->IMXWriter != NULL)
        {
            this->IMXWriter.Release();
        }
        if (this->ISAXContentHandler != NULL)
        {
            this->ISAXContentHandler.Release();
        }
    }

    HRESULT startDocument() { return this->ISAXContentHandler->startDocument(); }
    HRESULT endDocument() { return this->ISAXContentHandler->endDocument(); }

    HRESULT startElement(
        const wchar_t * pwchQName,
        int cchQName = -1,
        MSXML2::ISAXAttributes * pAttributes = NULL
        )
    {
        return this->startElement(L"", 0, L"", 0, pwchQName, cchQName, pAttributes);
    }

    void setLength(const wchar_t * pwch, int & cch)
    {
        if (cch == -1)
            cch = static_cast<int>(wcslen(pwch));
    }

    void setLengths(
        const wchar_t * pwchNamespaceUri,
        int & cchNamespaceUri,
        const wchar_t * pwchLocalName,
        int & cchLocalName,
        const wchar_t * pwchQName,
        int & cchQName)

    {
        setLength(pwchNamespaceUri, cchNamespaceUri);
        setLength(pwchLocalName, cchLocalName);
        setLength(pwchQName, cchQName);
    }

    HRESULT startElement(
        const wchar_t * pwchNamespaceUri,
        int cchNamespaceUri,
        const wchar_t * pwchLocalName,
        int cchLocalName,
        const wchar_t * pwchQName,
        int cchQName,
        MSXML2::ISAXAttributes * pAttributes)
    {
        setLengths(pwchNamespaceUri, cchNamespaceUri, pwchLocalName, cchLocalName, pwchQName, cchQName);
        return this->ISAXContentHandler->startElement(
            pwchNamespaceUri, cchNamespaceUri, pwchLocalName,
            cchLocalName, pwchQName, cchQName, pAttributes);
    }

    HRESULT endElement(
        const wchar_t * pwchQName,
        int cchQName = -1)
    {
        return this->endElement(L"", 0, L"", 0, pwchQName, cchQName);
    }

    HRESULT endElement(
        const wchar_t * pwchNamespaceUri,
        int cchNamespaceUri,
        const wchar_t * pwchLocalName,
        int cchLocalName,
        const wchar_t * pwchQName,
        int cchQName)
    {
        setLengths(pwchNamespaceUri, cchNamespaceUri, pwchLocalName, cchLocalName, pwchQName, cchQName);
        return this->ISAXContentHandler->endElement(
            pwchNamespaceUri, cchNamespaceUri, pwchLocalName,
            cchLocalName, pwchQName, cchQName);
    }

    HRESULT characters(
        const wchar_t * pwchChars,
        int cchChars = -1)
    {
        setLength(pwchChars, cchChars);
        return this->ISAXContentHandler->characters(pwchChars, cchChars);
    }

    __declspec(property(get=Getindent,put=Putindent)) VARIANT_BOOL indent;
    void Putindent(VARIANT_BOOL fIndentMode) { this->IMXWriter->indent = fIndentMode; }
    VARIANT_BOOL Getindent() { return this->IMXWriter->indent; }

    __declspec(property(get=Getoutput,put=Putoutput)) _variant_t output;
    void Putoutput(const _variant_t & varDestination) { this->IMXWriter->output = varDestination; }
    _variant_t Getoutput() { return this->IMXWriter->output; }

    __declspec(property(get=Getencoding,put=Putencoding)) _bstr_t encoding;
    void Putencoding(_bstr_t strEncoding) { this->IMXWriter->encoding = strEncoding; }
    _bstr_t Getencoding() { return this->IMXWriter->encoding; }

    MSXML2::IMXWriterPtr           IMXWriter;
    MSXML2::ISAXContentHandlerPtr  ISAXContentHandler;
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\processorarchitecture.h ===
#if !defined(_FUSION_INC_PROCESSORARCHITECTURE_H_INCLUDED_)
#define _FUSION_INC_PROCESSORARCHITECTURE_H_INCLUDED_

#pragma once

/*-----------------------------------------------------------------------------
Define a macro, DEFAULT_ARCHITECTURE, which is the appropriate
PROCESSOR_ARCHITECTURE_xxx value for the target platform.
-----------------------------------------------------------------------------*/

#if defined(_X86_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_INTEL
#elif defined(_AMD64_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_AMD64
#elif defined(_IA64_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_IA64
#else
#error Unknown Processor type
#endif


#endif // _FUSION_INC_PROCESSORARCHITECTURE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\smartptr.h ===
#if !defined(_FUSION_INC_SMARTPTR_H_INCLUDED_)
#define _FUSION_INC_SMARTPTR_H_INCLUDED_

/*++

Copyright (c) Microsoft Corporation

Module Name:

    smartptr.h

Abstract:

Author:

    Jay Krell (a-JayK, JayKrell) October 2000

Revision History:

--*/
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "fusiontrace.h"
#include "csxspreservelasterror.h" // Most destructors should use this.
#include "fusionheap.h"
#include <typeinfo.h>

//
// Need to flesh this out.
// See \\cpvsbuild\Drops\v7.0\raw\current\vs\src\VSEE\lib\Memory\*Pointer*.
//

//
// Split off into ATL style Base/TDerived to avoid compiler ICE;
// Otherwise was void (*Delete)(T*) = SxsDelete<T>
//

template <typename T>
class CSmartPtrBaseTypeHelper
{
public:

#if DBG
#define SXS_TYPE_NAME(t) (typeid(T).name())
#else
#define SXS_TYPE_NAME(t) ("")
#endif // DBG

    static T *AllocateSingleton(PCSTR pszFileName, int nLine) { return new(pszFileName, nLine, SXS_TYPE_NAME(T)) T; }
    static T *AllocateArray(SIZE_T n, PCSTR pszFileName, int nLine) { return new(pszFileName, nLine, SXS_TYPE_NAME(T)) T[n]; }

#undef SXS_TYPE_NAME

    static void DeleteSingleton(T *pt) { CSxsPreserveLastError ple; delete pt; ple.Restore(); }
    static void DeleteArray(T *pt) { CSxsPreserveLastError ple; delete []pt; ple.Restore(); }
};

//
// Derived is never used. This is may be by accident or by design.
//
template <typename T, typename /*Derived*/, typename TTypeHelper = CSmartPtrBaseTypeHelper<T> >
class CSmartPtrBase
{
    typedef T *TPtr;
    typedef T const *TConstPtr;

public:
    CSmartPtrBase() : m_p(NULL), m_fDelete(false) { }
    ~CSmartPtrBase() { ASSERT_NTC(m_p == NULL); }

    operator TPtr () { return m_p; }
    operator TConstPtr () const { return m_p; }
    TPtr *operator&() { ASSERT_NTC(m_p == NULL); m_fDelete = true; return &m_p; }
    TPtr operator->() { return m_p; }
    TConstPtr operator->() const { return m_p; }

    // this stores null in m_p and returns its previous value
    TPtr Detach() { T *p = m_p; m_p = NULL; m_fDelete = false; return p; }
    TPtr DetachAndHold() { m_fDelete = false; return m_p; }

    void FinalizeSingletonBase() { if (m_p != NULL) { if (m_fDelete) TTypeHelper::DeleteSingleton(m_p); m_p = NULL; } }
    void FinalizeArrayBase() { if (m_p != NULL) { if (m_fDelete) TTypeHelper::DeleteArray(m_p); m_p = NULL; } }

protected:
    T* m_p;
    bool m_fDelete;

    void AttachForDeleteBase(T *p) { ASSERT_NTC(m_p == NULL); if (m_p == NULL) { m_p = p; m_fDelete = true; } }
    void AttachNoDeleteBase(T *p) { ASSERT_NTC(m_p == NULL); if (m_p == NULL) { m_p = p; m_fDelete = false; } }

    BOOL Win32AllocateSingletonBase(PCSTR pszFileName, int nLine) { BOOL fSuccess = FALSE; ASSERT_NTC(m_p == NULL); if ((m_p = TTypeHelper::AllocateSingleton(pszFileName, nLine)) == NULL) goto Exit; m_fDelete = true; fSuccess = TRUE; Exit: return fSuccess; }
    BOOL Win32AllocateArrayBase(SIZE_T n, PCSTR pszFileName, int nLine) { FN_PROLOG_WIN32 INTERNAL_ERROR_CHECK(m_p == NULL); IFALLOCFAILED_EXIT(m_p = TTypeHelper::AllocateArray(n, pszFileName, nLine)); m_fDelete = true; FN_EPILOG }

    static void DeleteSingleton(T *p) { TTypeHelper::DeleteSingleton(p); }
    static void DeleteArray(T *p) { TTypeHelper::DeleteArray(p); }

private:
    CSmartPtrBase(const CSmartPtrBase&); // deliberately not implemented
    void operator=(const CSmartPtrBase&); // deliberately not implemented
};

template <typename T, typename TTypeHelper = CSmartPtrBaseTypeHelper<T> >
class CSmartPtr : public CSmartPtrBase<T, CSmartPtr>
{
public:
    CSmartPtr() : Base() { }
    ~CSmartPtr() { if (m_p != NULL) { if (m_fDelete) Base::DeleteSingleton(m_p); m_p = NULL; } }

    CSmartPtr &AttachForDelete(T* p) { Base::AttachForDeleteBase(p); return *this; }
    CSmartPtr &AttachNoDelete(T* p) { Base::AttachNoDeleteBase(p); return *this; }

    bool operator ==(const CSmartPtr &r) const { return m_p == r.m_p; }

    BOOL Win32Allocate(PCSTR pszFileName, int nLine) { return Base::Win32AllocateSingletonBase(pszFileName, nLine); }

private:
    typedef CSmartPtrBase<T, CSmartPtr> Base;
    CSmartPtr(const CSmartPtr&); // deliberately not implemented
    operator=(const CSmartPtr&); // deliberately not implemented
};

template <typename T>
class CSmartArrayPtr : public CSmartPtrBase<T, CSmartArrayPtr>
{
    typedef CSmartPtrBase<T, CSmartArrayPtr> Base;

public:
    CSmartArrayPtr() : Base() { }
    ~CSmartArrayPtr() { if (m_p != NULL) { if (m_fDelete) Base::DeleteArray(m_p); m_p = NULL; } }

    CSmartArrayPtr &AttachForDelete(T *p) { Base::AttachForDelete(p); return *this; }
    CSmartArrayPtr &AttachNoDelete(T *p) { Base::AttachNoDelete(p); return *this; }

    bool operator ==(const CSmartArrayPtr &r) const { return m_p == r.m_p; }
    bool operator ==(T *prgt) const { return m_p == prgt; }

    BOOL Win32Allocate(SIZE_T n, PCSTR pszFileName, int nLine) { return Base::Win32AllocateArrayBase(n, pszFileName, nLine); }

private:
    CSmartArrayPtr(const CSmartArrayPtr &);
    void operator =(const CSmartArrayPtr &);
};

template <typename T, void (*pfnDestructor)(T *)>
class CSmartPtrWithNamedDestructorHelper
{
public:
    static void DeleteSingleton(T *pt) { CSxsPreserveLastError ple; (*pfnDestructor)(pt); ple.Restore(); }
};

template <
    typename T,
    void (*pfnDestructor)(T *),
    typename TTypeHelper = CSmartPtrWithNamedDestructorHelper<T, pfnDestructor> >
class CSmartPtrWithNamedDestructor : public CSmartPtrBase<T, CSmartPtrWithNamedDestructor, TTypeHelper>
{
public:
    CSmartPtrWithNamedDestructor() : Base() { }
    ~CSmartPtrWithNamedDestructor() { if (m_p != NULL) { if (m_fDelete) Base::DeleteSingleton(m_p); m_p = NULL; } }

    CSmartPtrWithNamedDestructor &AttachForDelete(T* p) { Base::AttachForDeleteBase(p); return *this; }
    CSmartPtrWithNamedDestructor &AttachNoDelete(T* p) { Base::AttachNoDeleteBase(p); return *this; }

    bool operator ==(const CSmartPtrWithNamedDestructor &r) const { return m_p == r.m_p; }

    BOOL Win32Allocate(PCSTR pszFileName, int nLine) { return Base::Win32AllocateSingletonBase(pszFileName, nLine); }

    void Finalize() { Base::FinalizeSingletonBase(); }

private:
    typedef CSmartPtrBase<T, CSmartPtrWithNamedDestructor, TTypeHelper> Base;
    CSmartPtrWithNamedDestructor(const CSmartPtrWithNamedDestructor &r); // deliberately not implemented
    operator=(const CSmartPtrWithNamedDestructor &r); // deliberately not implemented
};

#endif // !defined(_FUSION_INC_SMARTPTR_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\sxshimlib.h ===
#pragma once

typedef struct SXPE_APPLY_SHIMS_IN
{
    SIZE_T  Size;
    ULONG   Flags;
    HMODULE DllToRedirectFrom;
    struct
    {
        PCWSTR  Path;
        HMODULE DllHandle;
    } DllToRedirectTo;
    PCSTR  Prefix; // for packaging multiple shimsets in one .dll
} SXPE_APPLY_SHIMS_IN, *PSXPE_APPLY_SHIMS_IN;
typedef const SXPE_APPLY_SHIMS_IN* PCSXPE_APPLY_SHIMS_IN;

typedef struct SXPE_APPLY_SHIMS_OUT
{
    SIZE_T  Size;
    ULONG   Flags;
    struct
    {
        PCWSTR  Path;
        HMODULE DllHandle;
    } DllToRedirectTo;
} SXPE_APPLY_SHIMS_OUT, *PSXPE_APPLY_SHIMS_OUT;
typedef const SXPE_APPLY_SHIMS_OUT* PCSXPE_APPLY_SHIMS_OUT;

BOOL
SxPepApplyShims(
    PCSXPE_APPLY_SHIMS_IN  in,
    PSXPE_APPLY_SHIMS_OUT  out
    );

BOOL
SxPepRevokeShims(
    HMODULE DllHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\sxsid.h ===
#if !defined(_FUSION_INC_SXSID_H_INCLUDED_)
#define _FUSION_INC_SXSID_H_INCLUDED_

#pragma once

#include <windows.h>
#include <setupapi.h>
#include <sxsapi.h>
#include <stdlib.h>
#include <search.h>

typedef struct _SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE
{
    const WCHAR *Namespace;
    SIZE_T NamespaceCch;
    const WCHAR *Name;
    SIZE_T NameCch;
} SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE, *PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

typedef const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE *PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE;

#define SXS_DEFINE_ATTRIBUTE_REFERENCE_EX(_id, _ns, _n) EXTERN_C __declspec(selectany) const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE _id = { _ns, (sizeof(_ns) / sizeof(_ns[0])) - 1, _n, (sizeof(_n) / sizeof(_n[0])) - 1 };
#define SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(_id, _n) EXTERN_C __declspec(selectany) const SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE _id = { NULL, 0, _n, (sizeof(_n) / sizeof(_n[0])) - 1 };

SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_name, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_type, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_version, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_processorArchitecture, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_publicKey, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_publicKeyToken, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN)
SXS_DEFINE_STANDARD_ATTRIBUTE_REFERENCE_EX(s_IdentityAttribute_language, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE)

#define ASSEMBLY_TYPE_POLICY                                    (L"policy")
#define ASSEMBLY_TYPE_POLICY_CCH                                (NUMBER_OF(ASSEMBLY_TYPE_POLICY) - 1)
#define ASSEMBLY_TYPE_POLICY_SUFFIX                             (L"-policy")
#define ASSEMBLY_TYPE_POLICY_SUFFIX_CCH                         (NUMBER_OF(ASSEMBLY_TYPE_POLICY_SUFFIX) - 1)

//
//  This header defines the "semi-public" assembly identity functions.
//
//  The public ones are in sxsapi.h; these are not private to the identity
//  implementation directly but are private to sxs.dll.
//

BOOL
SxsIsAssemblyIdentityAttributePresent(
    DWORD Flags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    BOOL *pfFound
    );

#define SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING (0x00000001)

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    PCWSTR pszValue,
    SIZE_T cchValue
    );

BOOL
SxspSetAssemblyIdentityAttributeValue(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    const CBaseStringBuffer &Value
    );

#define SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS (0x00000001)

BOOL
SxspRemoveAssemblyIdentityAttribute(
    DWORD Flags,
    struct _ASSEMBLY_IDENTITY* pAssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference
    );

#define SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL (0x00000001)

BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *ValuePointer,
    OUT SIZE_T *ValueCch
    );

BOOL
SxspGetAssemblyIdentityAttributeValue(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT CBaseStringBuffer &Value
    );

VOID
SxspDbgPrintAssemblyIdentity(
    DWORD dwflags,
    PCASSEMBLY_IDENTITY pAssemblyIdentity
    );

#define SXSP_MAP_ASSEMBLY_IDENTITY_TO_POLICY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION (0x00000001)

BOOL
SxspMapAssemblyIdentityToPolicyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT PASSEMBLY_IDENTITY *PolicyIdentity
    );

#define SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION (0x00000001)

BOOL
SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    CBaseStringBuffer &rbuffEncodedIdentity,
    PASSEMBLY_IDENTITY *PolicyIdentity OPTIONAL
    );

BOOL
SxspHashAssemblyIdentityForPolicy(
    IN DWORD dwFlags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG & IdentityHash);

BOOL
SxspDoesStringIndicatePolicy(
    SIZE_T cchString,
    PCWSTR pcwsz,
    BOOL &fIsPolicy
    );

BOOL
SxspDetermineAssemblyType(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    BOOL &fIsPolicyAssembly
    );

BOOL
SxspGenerateTextualIdentity(
    DWORD dwFlags,
    PCASSEMBLY_IDENTITY pAsmIdent,
    CBaseStringBuffer &rsbTextualString
    );


#endif // !defined(_FUSION_INC_SXSID_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\returnstrategy.h ===
#pragma once

//
// This an incomplete return strategy bridge.
// Return strategies include BOOL/LastError, no tls LastError, HRESULT, HRESULT/IErrorInfo, exception.
// Where exception is multiple types, including HRESULT and _com_error.
// This only bridges BOOL/LastError and HRESULT.
//
// What problem we are solving.
//
// We had a few functions duplicated. One copy would return HRESULTs "all the way down",
// one would propagate BOOL and the thread local LastError "all the way down". By
// "all the way down" I mean any function calls were changed to call a function of the
// corresponding "return strategy", cloning that function as well do to the same thing,
// "transitive closure". Such source code duplication is not good; there were
// inconsistencies in the clones and the source was a little confusing for all the duplication
// (it's still confusing, and it isn't clear we helped the situation).
// There are at least two ways to fix this source code duplication.
//
// a) write most code using one return strategy, and occasionally transition to the
// other as needed; this results in no code duplication, but you must be sure
// that maximal error information is available/preserved, and that transitions are
// not too difficult to write or too slow to run; this is well demonstrated in the Vsee
// code base that throws _com_errors internally and transitions to HRESULT/IErrorInfo*
// at COM boundaries.
//
// b) templatize the code as we have
//
// How you use it.
//
//  See FusionBuffer.h
//
// Future stuff.
//
// A more complete design probably requires a nested typedef "BeginTryBlockType".
//
// try
// {
//      returnStrategy.BeginTryBlock(&beginTryBlockValue);
//      if (FAILED())
//          return returnStrategy.ReturnHr(hr);
//      returnStrategy.EndTryBlock(&beginTryBlockValue);
//  }
//  catch (TReturnStrategy::ExceptionType exceptionValue) // to bad we can't catch void
//  {
//      .. something like returnStrategy.Catch(exceptionValue)
//      or if returnStrategy.Rethrow(exceptionValue)
//      or returnStrategy.ReturnException(); !
// }
//
// and then wrap it up in macros like VSEE_TRY \\jayk1\g\vs\src\vsee\lib\Try.h
//
// More generally, you might just have work to do upon any return strategy transition.
//
// TBD.
//
// Furthermore, the act of "saving last error" (Win32 GetLastError/::FusionpSetLastWin32Error
// or COM GetErrorInfo/SetErrorInfo) around cleanup should probably be encapsulated here.
// It would be nothing for "full" exception types, only IErrorInfo* for some, only LastError for others,
// etc.
//
// TBD.
//

#define UNCHECKED_DOWNCAST static_cast

template <typename T, typename RetType>
/*
T should have
    nested enums (or member data set in the constructor or static member data)
        SuccessValue, FailureValue of type ReturnType
    functions SetHresult, SetWin32Bool, GetBool,
    if you actually use enough of it for the compiler to enforce these
*/
class CReturnStrategyBase
{
public:
    typedef RetType ReturnType;
    ReturnType m_returnValue;

    // like ATL; the compiler does not typecheck this, it depends
    // on "careful inheritance"
    T*          t()       { return UNCHECKED_DOWNCAST<T*>(this); }
    const T*    t() const { return UNCHECKED_DOWNCAST<const T*>(this); }

    // this is like a constructor, where you'd start a function with
    // BOOL fSucceeded = FALSE;
    // or
    // HRESULT hr = E_FAIL;
    //
    // But note that following the pattern of BOOL fSucceeded = FALSE doesn't work.
    // You know that the pattern HRESULT hr = E_FAIL is usually actually
    // hr = NOERROR, because if you fail, it will be by propogating someone else's
    // returned HRESULT. Well, we might be returning a BOOL or an HRESULT.
    // We propagate an HRESULT, if that is the case, by explicitly calling
    // SetWin32Bool(FALSE) after a failed Win32 calls, which if we are returning
    // HRESULTs, will call GetLastError.
    ReturnType AssumeFailure()
    {
        return (m_returnValue = t()->FailureValue);
    }

    // this is like a constructor, where you'd start a function with
    // BOOL fSucceeded = TRUE;
    // or
    // HRESULT hr = NOERROR;
    //
    // There is really no advantage to this over
    //   returnStrategy->SetWin32Bool(TRUE) or SetHresult(NOERROR);
    //   return returnStrategy->Return();
    //
    // We must assume some level of translatability between return strategies.
    // Win32Bool(TRUE) and SetHresult(NOERROR) convert losslessly.
    //
    // We might have "informational" and "warning" to contend with at some point.
    ReturnType AssumeSuccess()
    {
        return (m_returnValue = t()->SuccessValue);
    }

    ReturnType Return() const
    {
        return m_returnValue;
    }

    // CallThatUsesReturnStrategy(...);
    // if (returnStrategy->Failed())
    //     goto Exit;
    BOOL Failed() const
    {
        return !t()->GetBool();
    }

    BOOL Succeeded() const
    {
        return t()->GetBool();
    }

    ReturnType ReturnHr(HRESULT hr)
    {
        t()->SetHresult(hr);
        return Return();
    }

    ReturnType ReturnWin32Bool(BOOL f)
    {
        t()->SetWin32Bool(f);
        return Return();
    }
};

class CReturnStrategyBoolLastError : public CReturnStrategyBase<CReturnStrategyBoolLastError, BOOL>
{
public:
    enum
    {
        SuccessValue = TRUE,
        FailureValue = FALSE
    };

    BOOL GetBool() const
    {
        return m_returnValue;
    }

    VOID SetInternalCodingError()
    {
        m_returnValue = FALSE;
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
    }

    VOID SetWin32Error(DWORD lastError)
    {
        if (lastError == NO_ERROR)
        {
            m_returnValue = TRUE;
        }
        else
        {
            m_returnValue = FALSE;
            ::FusionpSetLastWin32Error(lastError);
        }
    }

    VOID SetWin32Bool(BOOL f)
    {
        m_returnValue = f;
    }

    VOID SetHresult(HRESULT hr)
    {
        ASSERT_NTC(
               HRESULT_FACILITY(hr) == FACILITY_NULL
            || HRESULT_FACILITY(hr) == FACILITY_WINDOWS
            || HRESULT_FACILITY(hr) == FACILITY_WIN32);

        if (!(m_returnValue = SUCCEEDED(hr)))
        {
            // It's confusing if this is FACILITY_WIN32 or FACILITY_WINDOWS
            // or what, we avoid knowing it.
            const DWORD facilityWin32 = HRESULT_FACILITY(HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED));
            if (HRESULT_FACILITY(hr) == facilityWin32)
            {
                DWORD dwWin32Error = HRESULT_CODE(hr);
                ::FusionpSetLastWin32Error(dwWin32Error);
            }
            else
            {
                // This is dubious, but FormatMessage can cope with
                // many of them, and that's the most common thing I
                // imagine people do with this other than propagate.
                // They also check for particular values, and if we
                // pretend this is FACILITY_WIN32, we'll bogusly
                // impersonate values.
                ::FusionpSetLastWin32Error(hr);
            }
        }
    }

    HRESULT GetHresult() const
    {
        if (m_returnValue)
        {
            return NOERROR;
        }
        else
        {
            DWORD lastError = ::FusionpGetLastWin32Error();
            if (lastError == NO_ERROR)
            {
                return E_FAIL;
            }
            return HRESULT_FROM_WIN32(lastError);
        }
    }
};

class CReturnStrategyHresult : public CReturnStrategyBase<CReturnStrategyHresult, HRESULT>
{
public:
    enum
    {
        SuccessValue = NOERROR,
        FailureValue = E_FAIL // not the only one
    };

    BOOL GetBool() const
    {
        return SUCCEEDED(m_returnValue);
    }

    VOID SetInternalCodingError()
    {
        m_returnValue = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    }

    VOID SetWin32Error(DWORD lastError)
    {
        m_returnValue = HRESULT_FROM_WIN32(lastError);
    }

    VOID SetWin32Bool(BOOL f)
    {
        if (f)
        {
            m_returnValue = NOERROR;
        }
        else
        {
            DWORD lastError = ::FusionpGetLastWin32Error();
            if (lastError != NO_ERROR)
            {
                m_returnValue = HRESULT_FROM_WIN32(lastError);
            }
            else
            {
                m_returnValue = E_FAIL;
            }
        }
    }

    VOID SetHresult(HRESULT hr)
    {
        m_returnValue = hr;
    }

    HRESULT GetHresult() const
    {
        return m_returnValue;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\smartref.h ===
#if !defined(_FUSION_MI_CIPTR_H_INCLUDED_)
#define _FUSION_MI_CIPTR_H_INCLUDED_

#pragma once

#include <unknwn.h>
#include "CSxsPreserveLastError.h"

template <typename T> class CSmartRef
{
public:
    inline CSmartRef() : m_pt(NULL) { }
    inline CSmartRef(const CSmartRef& r) : m_pt(r.m_pt) { if (m_pt) m_pt->AddRef(); }
    inline CSmartRef(T *pt) : m_pt(pt) { if (pt != NULL) pt->AddRef(); }
    inline ~CSmartRef() { if (m_pt != NULL) { CSxsPreserveLastError ple; m_pt->Release(); m_pt = NULL; ple.Restore(); } }

    inline T *operator ->() const { ASSERT_NTC(m_pt != NULL); return m_pt; }
    inline T **operator &() { ASSERT_NTC(m_pt == NULL); return &m_pt; }

    CSmartRef<T> &operator =(T *pt) { if (pt != NULL) pt->AddRef(); if (m_pt != NULL) m_pt->Release(); m_pt = pt; return *this; }
    CSmartRef<T> &operator =(const CSmartRef& r) { return operator=(r.m_pt); }

    inline operator T *() const { return m_pt; }
    inline T *Ptr() const { return m_pt; }

    inline void Release() { if (m_pt != NULL) { m_pt->Release(); m_pt = NULL; } }
    T *Disown() { T *pt = m_pt; m_pt = NULL; return pt; }

    inline void Take(CSmartRef<T> &r) { if (r.m_pt != NULL) { r.m_pt->AddRef(); } if (m_pt != NULL) { m_pt->Release(); } m_pt = r.m_pt; r.m_pt = NULL; }

    HRESULT Initialize(T *pt) { (*this) = pt; return NOERROR; }

    HRESULT CreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter = NULL, CLSCTX clsctx = static_cast<CLSCTX>(CLSCTX_ALL))
    {
        T *pt = NULL;
        HRESULT hr = ::CoCreateInstance(rclsid, pUnkOuter, clsctx, __uuidof(T), (LPVOID *) &pt);
        if (FAILED(hr)) return hr;
        if (m_pt != NULL)
            m_pt->Release();
        m_pt = pt;
        pt = NULL;
        return NOERROR;
    }

    HRESULT QueryInterfaceFrom(IUnknown *pIUnknown)
    {
        HRESULT hr = NOERROR;
        T *pt = NULL;

        if (pIUnknown == NULL)
            this->Release();
        else
        {
            hr = pIUnknown->QueryInterface(__uuidof(T), (void **) &pt);
            if (FAILED(hr))
                goto Exit;

            if (m_pt != NULL)
                m_pt->Release();

            m_pt = pt;
        }

        hr = NOERROR;

    Exit:

        return hr;
    }

    // Not protected, because we need access to it for the table-based aggregation
    // in fusioncom.h to work, but don't touch it unless you understand the consequences!!
    T *m_pt;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\sxsexceptionhandling.h ===
#if !defined(_FUSION_INC_SXSEXCEPTIONHANDLING_H_INCLUDED_)
#define _FUSION_INC_SXSEXCEPTIONHANDLING_H_INCLUDED_

/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsexceptionhandling.h

Abstract:

Author:

    Jay Krell (a-JayK, JayKrell) October 2000

Revision History:

--*/
#pragma once

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "fusionlastwin32error.h"
#include "fusionntdll.h"
#include "fusiontrace.h"
#include "csxspreservelasterror.h" // Most destructors should use this.
#include "fusionheap.h"

/*-----------------------------------------------------------------------------
Instead of:
    __except(EXECEPTION_EXECUTE_HANDLER)
say:
    __except(SXSP_EXCEPTION_FILTER())

This way all exceptions will be logged with DbgPrint,
and probably hit a breakpoint if under a debugger, and any other behavior we
want.

If your exception filter is other than (EXECEPTION_EXECUTE_HANDLER), then
you are on your own.
-----------------------------------------------------------------------------*/

LONG
SxspExceptionFilter(
    PEXCEPTION_POINTERS ExceptionPointers,
    PCSTR Function
    );

LONG
FusionpReadMappedMemoryExceptionFilter(
    PEXCEPTION_POINTERS ExceptionPointers,
    IN PNTSTATUS            ExceptionCode
    );

/*
Use instead of InitializeCriticalSection.
*/
BOOL
FusionpInitializeCriticalSection(
    LPCRITICAL_SECTION CriticalSection
    );

/*
Use instead of InitializeCriticalSectionAndSpinCount
*/
BOOL
FusionpInitializeCriticalSectionAndSpinCount(
    LPCRITICAL_SECTION  CriticalSection,
    DWORD               SpinCount
    );

#define SXSP_EXCEPTION_FILTER() (::SxspExceptionFilter(GetExceptionInformation(), __FUNCTION__))

#define SXS_REPORT_SEH_EXCEPTION(string, fBreakin) \
	do { \
        ::FusionpReportCondition(fBreakin, "SXS.DLL: " __FUNCTION__ " - Unhandled exception caught: 0x%08lx", GetExceptionCode()); \
	} while (0)

class CCriticalSectionNoConstructor : public CRITICAL_SECTION
{
    void operator=(const CCriticalSectionNoConstructor&); // deliberately not implemented
public:
	BOOL Initialize(PCSTR Function = "");
	BOOL Destruct();
};

inline BOOL
CCriticalSectionNoConstructor::Destruct()
{
    ::DeleteCriticalSection(this);
	return TRUE;
}

inline BOOL
CCriticalSectionNoConstructor::Initialize(
    PCSTR /* Function */)
{
    return ::FusionpInitializeCriticalSection(this);
}

class CSxsLockCriticalSection
{
public:
    CSxsLockCriticalSection(CRITICAL_SECTION &rcs) : m_rcs(rcs), m_fIsLocked(false) { }
    BOOL Lock();
    BOOL TryLock();
    BOOL LockWithSEH();
    ~CSxsLockCriticalSection() { if (m_fIsLocked) { CSxsPreserveLastError ple; ::LeaveCriticalSection(&m_rcs); ple.Restore(); } }
    BOOL Unlock();

protected:
    CRITICAL_SECTION &m_rcs;
    bool m_fIsLocked;

private:
    void operator=(const CSxsLockCriticalSection&);
    CSxsLockCriticalSection(const CSxsLockCriticalSection&);
};

inline
BOOL
CSxsLockCriticalSection::Lock()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    INTERNAL_ERROR_CHECK(!m_fIsLocked);
    ::EnterCriticalSection(&m_rcs);
    m_fIsLocked = true;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline
BOOL
CSxsLockCriticalSection::LockWithSEH()
{
//
// EnterCriticalSection on XP and above does not throw exceptions
// (other than continuable "possible deadlock" exception).
//
// EnterCriticalSection on NT4 and Win2000 may throw exceptions.
//    On Win2000 you can avoid this by preallocating the event
//    but it does use up memory. Catching the exception does no
//    good, the critical section is left corrupt.
//
// EnterCriticalSection on Win9x does not throw exceptions.
//
#if defined(FUSION_WIN)
    return this->Lock();
#else
    BOOL fSuccess = FALSE;

    // We can't use the spiffy macros in the same frame as a __try block.
    ASSERT_NTC(!m_fIsLocked);
    if (m_fIsLocked)
    {
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    if (!this->Lock())
        goto Exit;
    m_fIsLocked = true;

    fSuccess = TRUE;
Exit:
    return fSuccess;
#endif // FUSION_WIN
}

inline
BOOL
CSxsLockCriticalSection::TryLock()
{
//
// NTRAID#NTBUG9-591667-2002/03/31-JayKrell
// It is not an error for TryEnterCriticalSection to return false.
//
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    INTERNAL_ERROR_CHECK(!m_fIsLocked);
    IFW32FALSE_ORIGINATE_AND_EXIT(::TryEnterCriticalSection(&m_rcs));
    m_fIsLocked = true;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

inline
BOOL
CSxsLockCriticalSection::Unlock()
{
//
// LeaveCriticalSection on XP and above does not throw exceptions.
//
// LeaveCriticalSection on NT4 and Win2000 may throw exceptions.
//    On Win2000 you can avoid this by preallocating the event
//    but it does use up memory. Catching the exception does no
//    good, the critical section is left corrupt.
//
// LeaveCriticalSection on Win9x does not throw exceptions.
//
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    INTERNAL_ERROR_CHECK(m_fIsLocked);
    ::LeaveCriticalSection(&m_rcs);
    m_fIsLocked = false;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#endif // !defined(_FUSION_INC_SXSEXCEPTIONHANDLING_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\sxspath.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxspath.h

Abstract:

Author:

    Jay Krell (a-JayK, JayKrell) October 2000

Revision History:

--*/

#pragma once

/*-----------------------------------------------------------------------------
 \\machine\share -> \\?\unc\machine\share
 c:\foo -> \\?\c:\foo
 \\? -> \\?
 a\b\c -> \\?\c:\windows\a\b\c current-working-directory is c:\windows (can never be unc)
-----------------------------------------------------------------------------*/
BOOL
FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);

#define MAXIMUM_BIG_PATH_GROWTH_CCH (NUMBER_OF(L"\\\\?\\unc\\"))

/*-----------------------------------------------------------------------------
 \\?\unc\machine\share\bob
 \\?\c:\foo\bar        ^
--------^---------------------------------------------------------------------*/
BOOL
FusionpSkipBigPathRoot(PCWSTR s, OUT SIZE_T*);

/*-----------------------------------------------------------------------------
just the 52 chars a-zA-Z, need to check with fs
-----------------------------------------------------------------------------*/
BOOL
FusionpIsDriveLetter(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\vseeport.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    vseeport.h

Abstract:
    for porting code from vsee
 
Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/

#include "fusionbuffer.h"
#include "lhport.h"

#define VsVerifyThrow(a,b)          (a)
#define VsVerify(a,b)               (a)
#define VSEE_NO_THROW()             /* nothing */
#define VSEE_ASSERT_CAN_THROW()     /* nothing */

void NVseeLibError_VCheck(HRESULT);
void NVseeLibError_VThrowWin32(DWORD);
void VsOriginateError(HRESULT);
void FusionpOutOfMemory();

#define VsVerifyThrowHr(expr, msg, hr) \
    do { if (!(expr)) VsOriginateError(hr); } while(0)

#define VSASSERT(a,b) ASSERT_NTC(a)

template <typename T> const T& NVseeLibAlgorithm_RkMaximum(const T& a, const T& b)
{
    return (a < b) ? b : a;
}

class CStringW_CFixedSizeBuffer : public F::CStringBufferAccessor
{
    typedef F::CStringBufferAccessor Base;
public:
    CStringW_CFixedSizeBuffer(F::CUnicodeBaseStringBuffer* Buffer, SIZE_T Size)
    {
        Buffer->ThrResizeBuffer(Size + 1, /*F::*/ePreserveBufferContents);
        this->Attach(Buffer);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\win32oneshot.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    win32oneshot.h

Abstract:

    one time initialization
    per process or per user or per machine
    optionally thread safe, if per process
    get code out of dllmain(dll_process_attach)
    get code out of setup (eliminate setup) (like, don't populate registry with defaults)

Author:

    Jay Krell (JayKrell) August 2001
    design per discussion with Michael Grier (MGrier)

Revision History:

--*/

#if !defined(WIN32_ONE_SHOT_H_INCLUDED_)
#define WIN32_ONE_SHOT_H_INCLUDED_
#if _MSC_VER > 1000
#pragma once
#endif
#ifdef __cplusplus
extern "C" {
#endif

//#include "nt.h"
//#include "ntrtl.h"
//#include "nturtl.h"
#include "windows.h"

struct _WIN32_ONE_SHOT_OPAQUE_STATIC_STATE;
struct _WIN32_ONE_SHOT_CALL_IN;
struct _WIN32_ONE_SHOT_CALL_OUT;
struct _WIN32_ONE_SHOT_CALL_IN;
struct _WIN32_ONE_SHOT_CALL_OUT;

//
// This is opaque and should be initialized by filling with zeros, as
// static initialization provides. You need not call ZeroMemory on
// static instances, in fact doing so partly defeats the purpose.
//
typedef struct _WIN32_ONE_SHOT_OPAQUE_STATIC_STATE {
    union {
        struct {
            DWORD_PTR WinbasePrivate_UserDefinedDisposition;
            LONG      WinbasePrivate_NumberOfSuccesses;
            LONG      WinbasePrivate_NumberOfFailures;
        } s;
        union {
            PVOID     WinbasePrivate_LockCookie;
            LONG      WinbasePrivate_NumberOfEntries;
            LONG      WinbasePrivate_Done;
        } s2;
        DWORD_PTR     Reserved[4]; // too big? too small? just right? - Goldi Locks circa 1850..
    } u;
} WIN32_ONE_SHOT_OPAQUE_STATIC_STATE, *PWIN32_ONE_SHOT_OPAQUE_STATIC_STATE;
typedef WIN32_ONE_SHOT_OPAQUE_STATIC_STATE const*PCWIN32_ONE_SHOT_OPAQUE_STATIC_STATE;

typedef BOOL (CALLBACK * WIN32_ONE_SHOT_INITIALIZE_FUNCTION)(
    const struct _WIN32_ONE_SHOT_CALL_IN* in,
    struct _WIN32_ONE_SHOT_CALL_OUT* out
    );

#define WIN32_ONE_SHOT_CALL_FLAG_IN_STATIC_STATE_VALID                    (0x00000001)
#define WIN32_ONE_SHOT_CALL_FLAG_IN_FLAGS_OUT_VALID                       (0x00000002)
#define WIN32_ONE_SHOT_CALL_FLAG_IN_USER_DEFINED_CONTEXT_VALID            (0x00000004)
#define WIN32_ONE_SHOT_CALL_FLAG_IN_USER_DEFINED_DISPOSITION_VALID        (0x00000008)
#define WIN32_ONE_SHOT_CALL_FLAG_IN_USER_DEFINED_INITIALIZER_VALID        (0x00000010)
#define WIN32_ONE_SHOT_CALL_FLAG_IN_EXACTLY_ONCE                          (0x00000020)
#define WIN32_ONE_SHOT_CALL_FLAG_IN_AT_LEAST_ONCE                         (0x00000040)
//#define WIN32_ONE_SHOT_CALL_FLAG_IN_SCOPE_QUALIFIER_IS_ASSEMBLY_IDENTITY  (0x00000080)
//#define WIN32_ONE_SHOT_CALL_FLAG_IN_SCOPE_QUALIFIER_IS_ASSEMBLY_DIRECTORY (0x00000100)
//#define WIN32_ONE_SHOT_CALL_FLAG_IN_SCOPE_QUALIFIER_IS_HMODULE            (0x00000200)
//#define WIN32_ONE_SHOT_CALL_FLAG_IN_SCOPE_QUALIFIER_IS_ADDRESS_IN_DLL     (0x00000400)
#define WIN32_ONE_SHOT_CALL_FLAG_IN_RETRY_ON_FAILURE                      (0x00000800)
#define WIN32_ONE_SHOT_CALL_FLAG_IN_ALWAYS_WANT_DETAILED_RESULTS          (0x00001000)
//#define WIN32_ONE_SHOT_CALL_FLAG_IN_UNINSTALL                           (0x00002000) /* must be combined with user or machine scope */

//#define WIN32_ONE_SHOT_SCOPE1_PROCESS           (0x00000001) /* the only one implemented so far */
//#define WIN32_ONE_SHOT_SCOPE1_CURRENT_USER      (0x00000002)
//#define WIN32_ONE_SHOT_SCOPE1_LOCAL_MACHINE     (0x00000004)

//#define WIN32_ONE_SHOT_SCOPE2_COMPONENT_NO_VERSION         (0x000000010)
//#define WIN32_ONE_SHOT_SCOPE2_COMPONENT_WITH_VERSION       (0x000000020)

//#define WIN32_ONE_SHOT_SCOPE3_NOT_APPLICATION_SPECIFIC     (0x000000040)
//#define WIN32_ONE_SHOT_SCOPE3_PER_ACTIVATION_CONTEXT_ROOT  (0x000000080)
//#define WIN32_ONE_SHOT_SCOPE3_PER_ACTIVATION               (0x000000100)

#define WIN32_ONE_SHOT_CALL_FLAG_OUT_THIS_TIME_RAN_CALLBACK           (0x00000001)
#define WIN32_ONE_SHOT_CALL_FLAG_OUT_THIS_TIME_RAN_CALLBACK_RETRIED   (0x00000002)
#define WIN32_ONE_SHOT_CALL_FLAG_OUT_THIS_TIME_CALLBACK_SUCCEEDED     (0x00000004)
#define WIN32_ONE_SHOT_CALL_FLAG_OUT_THIS_TIME_CALLBACK_FAILED        (0x00000008)
#define WIN32_ONE_SHOT_CALL_FLAG_OUT_ANY_CALLBACKS_FAILED             (0x00000010) // mayb we
#define WIN32_ONE_SHOT_CALL_FLAG_OUT_ANY_CALLBACKS_SUCCEEDED          (0x00000020) // should just
#define WIN32_ONE_SHOT_CALL_FLAG_OUT_MULTIPLE_CALLBACKS_FAILED        (0x00000040) // provide the
#define WIN32_ONE_SHOT_CALL_FLAG_OUT_MULTIPLE_CALLBACKS_SUCCEEDED     (0x00000080) // actual counts?
#define WIN32_ONE_SHOT_CALL_FLAG_OUT_DETAILED_RESULTS_VALID           (0x00000100) // or none of this?

typedef struct _WIN32_ONE_SHOT_CALL_IN {
    SIZE_T                              dwSize;
    DWORD                               dwFlags; // describe what members in the struct are valid
    PWIN32_ONE_SHOT_OPAQUE_STATIC_STATE lpOpaqueStaticState;
    DWORD                               dwFlagsIn;
    WIN32_ONE_SHOT_INITIALIZE_FUNCTION  lpfnUserDefinedInitializer;
    PVOID                               lpvUserDefinedContext;

    //
    // extensible scope...
    //
    //DWORD                             dwScope;
    //
} WIN32_ONE_SHOT_CALL_IN, *PWIN32_ONE_SHOT_CALL_IN;
typedef const WIN32_ONE_SHOT_CALL_IN *PCWIN32_ONE_SHOT_CALL_IN;

typedef struct _WIN32_ONE_SHOT_CALL_OUT {
    SIZE_T    dwSize;  // describe what members in the struct are valid
    DWORD     dwFlags;
    DWORD     dwFlagsOut;
    DWORD_PTR dwUserDefinedDisposition;
} WIN32_ONE_SHOT_CALL_OUT, *PWIN32_ONE_SHOT_CALL_OUT;
typedef const WIN32_ONE_SHOT_CALL_OUT *PCWIN32_ONE_SHOT_CALL_OUT;

// aka Win32DoOneTimeInitialization
BOOL
WINAPI
Win32OneShotW( // W because "scope parameters" will contain strings
    PWIN32_ONE_SHOT_CALL_IN  in,
    PWIN32_ONE_SHOT_CALL_OUT out
    );

//
// simpler interface, different implementation
//
#define WIN32_ENTER_ONE_SHOT_FLAG_EXACTLY_ONCE     (0x00000001)
#define WIN32_ENTER_ONE_SHOT_FLAG_AT_LEAST_ONCE    (0x00000002)
BOOL
WINAPI
Win32EnterOneShotW(
    DWORD                               dwFlags,
    PWIN32_ONE_SHOT_OPAQUE_STATIC_STATE pOneshot
    );

VOID
WINAPI
Win32LeaveOneShotW(
    DWORD                               dwFlags,
    PWIN32_ONE_SHOT_OPAQUE_STATIC_STATE pOneshot
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\util.h ===
#ifndef UTIL_H
#define UTIL_H
#pragma once

#include "fusionheap.h"
#include "wincrypt.h"
#include "fusionhandle.h"
#include "numberof.h"

#pragma warning(push)
#pragma warning(disable: 4201)

inline
USHORT FusionGetMajorFromVersionHighHalf(DWORD dwVerHigh)
{
    return HIWORD(dwVerHigh);
}

inline
USHORT FusionGetMinorFromVersionHighHalf(DWORD dwVerHigh)
{
    return LOWORD(dwVerHigh);
}

inline
USHORT FusionGetRevisionFromVersionLowHalf(DWORD dwVerLow)
{
    return HIWORD(dwVerLow);
}

inline
USHORT FusionGetBuildFromVersionLowHalf(DWORD dwVerLow)
{
    return LOWORD(dwVerLow);
}


#include "debmacro.h"
#include "FusionArray.h"
#include "fusionbuffer.h"
#include "EnumBitOperations.h"

//
//  FusionCopyString() has a non-obvious interface due to the overloading of
//  pcchBuffer to both describe the size of the buffer on entry and the number of
//  characters required on exit.
//
//  prgchBuffer is the buffer to write to.  If *pcchBuffer is zero when FusionCopyString()
//      is called, it may be NULL.
//
//  pcchBuffer is a required parameter, which on entry must contain the number of unicode
//      characters in the buffer pointed to by prgchBuffer.  On exit, if the buffer was
//      not large enough to hold the character string, including a trailing null,
//      it is set to the number of WCHARs required to hold the string, including the
//      trailing null, and HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) is returned.
//
//      If the buffer is large enough, *pcchBuffer is set to the number of characters
//      written into the buffer, including the trailing null character.
//
//      This is contrary to most functions which return the number of characters written
//      not including the trailing null, but since both on input and in the error case,
//      it deals with the size of the buffer required rather than the number of non-
//      null characters written, it seems inconsistent to only in the success case
//      omit the null from the count.
//
//  szIn is a pointer to sequence of unicode characters to be copied.
//
//  cchIn is the number of Unicode characters in the character string to copy.  If a
//      value less than zero is passed in, szIn must point to a null-terminated string,
//      and the current length of the string is used.  If a value zero or greater is
//      passed, exactly that many characters are assumed to be in the character string.
//

HRESULT FusionCopyString(
    WCHAR *prgchBuffer,
    SIZE_T *pcchBuffer,
    LPCWSTR szIn,
    SIZE_T cchIn
    );

BOOL
FusionDupString(
    PWSTR *ppszOut,
    PCWSTR szIn,
    SIZE_T cchIn
    );

BOOL
SxspMapLANGIDToCultures(
	LANGID langid,
	CBaseStringBuffer &rbuffGeneric,
	CBaseStringBuffer &rbuffSpecific
	);

BOOL
SxspMapCultureToLANGID(
    PCWSTR pcwszCultureString,
    LANGID &lid,
    PBOOL pfFound
    );

typedef struct _SXSP_LANGUAGE_BUFFER_PAIR
{
    CBaseStringBuffer * m_Generic;
    CBaseStringBuffer * m_Specific;
} SXSP_LANGUAGE_BUFFER_PAIR, *PSXSP_LANGUAGE_BUFFER_PAIR;
typedef const SXSP_LANGUAGE_BUFFER_PAIR * PCSXSP_LANGUAGE_BUFFER_PAIR;

BOOL
SxspCultureStringToCultureStrings(
    PCWSTR              pcwszCultureString,
    bool &              rfFoundOut,
    SXSP_LANGUAGE_BUFFER_PAIR & LanguagePair
    );

BOOL
FusionpParseProcessorArchitecture(
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT USHORT *ProcessorArchitecture OPTIONAL,
    bool &rfValid
    );

BOOL
FusionpFormatProcessorArchitecture(
    IN USHORT ProcessorArchitecture,
    CBaseStringBuffer &rBuffer
    );

BOOL
FusionpFormatEnglishLanguageName(
    IN LANGID LangID,
    CBaseStringBuffer &rBuffer
    );

/*-----------------------------------------------------------------------------
like ::CreateDirectoryW, but will create the parent directories as needed
-----------------------------------------------------------------------------*/
BOOL
FusionpCreateDirectories(
    PCWSTR pszDirectory,
    SIZE_T cchDirectory
    );

/*-----------------------------------------------------------------------------
'\\' or '/'
-----------------------------------------------------------------------------*/
BOOL
FusionpIsPathSeparator(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
just the 52 chars a-zA-Z, need to check with fs
-----------------------------------------------------------------------------*/
BOOL
FusionpIsDriveLetter(
    WCHAR ch
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

VOID
FusionpSetLastErrorFromHRESULT(
    HRESULT hr
    );

DWORD
FusionpHRESULTToWin32(
    HRESULT hr
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

class CFusionDirectoryDifference;

BOOL
FusionpCompareDirectoriesSizewiseRecursively(
    CFusionDirectoryDifference*  pResult,
    const CBaseStringBuffer &rdir1,
    const CBaseStringBuffer &rdir2
    );

class CFusionDirectoryDifference
{
private: // deliberately unimplemented
    CFusionDirectoryDifference(const CFusionDirectoryDifference&);
    VOID operator=(const CFusionDirectoryDifference&);
public:
    CFusionDirectoryDifference()
    :
        m_e(eEqual),
        m_pstr1(&m_str1),
        m_pstr2(&m_str2)
    {
    }

    VOID
    DbgPrint(
        PCWSTR dir1,
        PCWSTR dir2
        );

public:
    enum E
    {
        eEqual,
        eExtraOrMissingFile,
        eMismatchedFileSize,
        eMismatchedFileCount,
        eFileDirectoryMismatch
    };

    E               m_e;

    union
    {
        struct
        {
            CBaseStringBuffer *   m_pstr1;
            CBaseStringBuffer *   m_pstr2;
        };
        struct // eExtraOrMissingFile
        {
            CBaseStringBuffer *   m_pstrExtraOrMissingFile;
        };
        struct // eMismatchFileSize
        {
            CBaseStringBuffer *   m_pstrMismatchedSizeFile1;
            CBaseStringBuffer *   m_pstrMismatchedSizeFile2;
            ULONGLONG        m_nMismatchedFileSize1;
            ULONGLONG        m_nMismatchedFileSize2;
        };
        struct // eMismatchFileCount
        {
            CBaseStringBuffer *   m_pstrMismatchedCountDir1;
            CBaseStringBuffer *   m_pstrMismatchedCountDir2;
            ULONGLONG        m_nMismatchedFileCount1;
            ULONGLONG        m_nMismatchedFileCount2;
        };
        struct // eFileDirectoryMismatch
        {
            CBaseStringBuffer *   m_pstrFile;
            CBaseStringBuffer *   m_pstrDirectory;
        };
    };

// private:
    CStringBuffer m_str1;
    CStringBuffer m_str2;
};

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

class CFusionFilePathAndSize
{
public:
    CFusionFilePathAndSize() : m_size(0), m_bHasHashInfo(false), m_HashAlgorithm(0) { }

    // bsearch and qsort accept optionally subtley different functions
    // bsearch looks for a key in an array, the key and the array elements
    // can be of different types, qsort compares only elements in the array
    static int __cdecl QsortComparePath(const void*, const void*);

    // for qsort/bsearch an array of pointers to CFusionFilePathAndSize
    static int __cdecl QsortIndirectComparePath(const void*, const void*);

    CStringBuffer   m_path;
    __int64         m_size;

    // Do we actually have valid hashing data?
    bool            m_bHasHashInfo;
    CStringBuffer   m_HashString;
    ALG_ID          m_HashAlgorithm;

private:
    CFusionFilePathAndSize(const CFusionFilePathAndSize &); // intentionally not implemented
    void operator =(const CFusionFilePathAndSize &); // intentionally not implemented
};


/*-----------------------------------------------------------------------------
two DWORDs to an __int64
-----------------------------------------------------------------------------*/
ULONGLONG
FusionpFileSizeFromFindData(
    const WIN32_FIND_DATAW& wfd
    );

/*-----------------------------------------------------------------------------
HRESULT_FROM_WIN32(GetLastError()) or E_FAIL if GetLastError() == NO_ERROR
-----------------------------------------------------------------------------*/
HRESULT
FusionpHresultFromLastError();

/*-----------------------------------------------------------------------------
FindFirstFile results you always ignore "." and ".."
-----------------------------------------------------------------------------*/
BOOL FusionpIsDotOrDotDot(PCWSTR str);

/*-----------------------------------------------------------------------------
simple code for walking directories, with a per file callback
could be fleshed out more, but good enough for present purposes
-----------------------------------------------------------------------------*/

#define SXSP_DIR_WALK_FLAGS_FIND_AT_LEAST_ONE_FILEUNDER_CURRENTDIR          (1)
#define SXSP_DIR_WALK_FLAGS_INSTALL_ASSEMBLY_UNDER_CURRECTDIR_SUCCEED       (2)

class CDirWalk
{
public:
    enum ECallbackReason
    {
        eBeginDirectory = 1,
        eFile,
        eEndDirectory
    };

    CDirWalk();

    //
    // the callback cannot reenable what is has disabled
    // perhaps move these to be member data bools
    //
    enum ECallbackResult
    {
        eKeepWalking            = 0x00000000,
        eError                  = 0x00000001,
        eSuccess                = 0x00000002,
        eStopWalkingFiles       = 0x00000004,
        eStopWalkingDirectories = 0x00000008,
        eStopWalkingDeep        = 0x00000010
    };

    //
    // Just filter on like *.dll, in the future you can imagine
    // filtering on attributes like read onlyness, or running
    // SQL queries over the "File System Oledb Provider"...
    //
    // Also, note that we currently do a FindFirstFile/FindNextFile
    // loop for each filter, plus sometimes one more with *
    // to pick up directories. It is probably more efficient to
    // use * and then filter individually but I don't feel like
    // porting over \Vsee\Lib\Io\Wildcard.cpp right now (which
    // was itself ported from FsRtl, and should be in Win32!)
    //
    const PCWSTR*    m_fileFiltersBegin;
    const PCWSTR*    m_fileFiltersEnd;
    CStringBuffer    m_strParent; // set this to the initial directory to walk
    SIZE_T           m_cchOriginalPath;
    WIN32_FIND_DATAW m_fileData; // not valid for directory callbacks, but could be with a little work
    PVOID            m_context;

    CStringBuffer    m_strLastObjectFound;

    ECallbackResult
    (*m_callback)(
        ECallbackReason  reason,
        CDirWalk*        dirWalk,
        DWORD            dwWalkDirFlags
        );

    BOOL
    Walk();

protected:
    ECallbackResult
    WalkHelper();

private:
    CDirWalk(const CDirWalk &); // intentionally not implemented
    void operator =(const CDirWalk &); // intentionally not implemented
};

ENUM_BIT_OPERATIONS(CDirWalk::ECallbackResult)

/*-----------------------------------------------------------------------------*/

typedef struct _FUSION_FLAG_FORMAT_MAP_ENTRY
{
    DWORD m_dwFlagMask;
    PCWSTR m_pszString;
    SIZE_T m_cchString;
    PCWSTR m_pszShortString;
    SIZE_T m_cchShortString;
    DWORD m_dwFlagsToTurnOff; // enables more generic flags first in map hiding more specific combinations later
} FUSION_FLAG_FORMAT_MAP_ENTRY, *PFUSION_FLAG_FORMAT_MAP_ENTRY;

#define DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(_x, _ss) { _x, L ## #_x, NUMBER_OF(L ## #_x) - 1, L ## _ss, NUMBER_OF(_ss) - 1, _x },

typedef const FUSION_FLAG_FORMAT_MAP_ENTRY *PCFUSION_FLAG_FORMAT_MAP_ENTRY;

BOOL
FusionpFormatFlags(
    IN DWORD dwFlagsToFormat,
    IN bool fUseLongNames,
    IN SIZE_T cMapEntries,
    IN PCFUSION_FLAG_FORMAT_MAP_ENTRY prgMapEntries,
    IN OUT CBaseStringBuffer &rbuff
    );

/*-----------------------------------------------------------------------------
inline implementations
-----------------------------------------------------------------------------*/
inline BOOL
FusionpIsPathSeparator(
    WCHAR ch
    )
/*
NTRAID#NTBUG9-591195-2002/03/31-JayKrell
path issues, case mapping.. (but this is probably ok)
*/
{
    return ((ch == L'\\') || (ch == L'/'));
}

inline BOOL
FusionpIsDotOrDotDot(
    PCWSTR str
    )
/*
NTRAID#NTBUG9-591195-2002/03/31-JayKrell
path issues, case mapping..
*/
{
    return ((str[0] == L'.') && ((str[1] == L'\0') || ((str[1] == L'.') && (str[2] == L'\0'))));
}

inline BOOL
FusionpIsDriveLetter(
    WCHAR ch
    )
/*
NTRAID#NTBUG9-591195-2002/03/31-JayKrell
path issues, case mapping..
*/
{
    if (ch >= L'a' && ch <= L'z')
        return TRUE;
    if (ch >= L'A' && ch <= L'Z')
        return TRUE;
    return FALSE;
}

inline ULONGLONG
FusionpFileSizeFromFindData(
    const WIN32_FIND_DATAW& wfd
    )
{
    ULARGE_INTEGER uli;

    uli.LowPart = wfd.nFileSizeLow;
    uli.HighPart = wfd.nFileSizeHigh;

    return uli.QuadPart;
}

inline HRESULT
FusionpHresultFromLastError()
{
    HRESULT hr = E_FAIL;
    DWORD dwLastError = ::FusionpGetLastWin32Error();
    if (dwLastError != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(dwLastError);
    }
    return hr;
}

template <> inline BOOL
FusionWin32CopyContents<CFusionFilePathAndSize>(
    CFusionFilePathAndSize& rtDestination,
    const CFusionFilePathAndSize& rtSource
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    IFW32FALSE_EXIT(rtDestination.m_path.Win32Assign(rtSource.m_path, rtSource.m_path.Cch()));
    IFW32FALSE_EXIT(rtDestination.m_HashString.Win32Assign(rtSource.m_HashString, rtSource.m_HashString.Cch()));
    rtDestination.m_size = rtSource.m_size;
    rtDestination.m_HashAlgorithm = rtSource.m_HashAlgorithm;
    rtDestination.m_bHasHashInfo = rtSource.m_bHasHashInfo;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#define FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING (0x00000001)
#define FUSIONP_REG_QUERY_DWORD_MISSING_VALUE_IS_FAILURE        (0x00000001)
#define FUSIONP_REG_QUERY_BINARY_NO_FAIL_IF_NON_BINARY          (0x00000001)

BOOL
FusionpRegQuerySzValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CBaseStringBuffer &Buffer,
    DWORD &rdwWin32Error,
    SIZE_T cExceptionalLastErrorValues,
    ...
    );

BOOL
FusionpRegQuerySzValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CBaseStringBuffer &Buffer
    );

BOOL
FusionpRegQueryDwordValueEx(
    DWORD   dwFlags,
    HKEY    hKey,
    PCWSTR  wszValueName,
    PDWORD  pdwValue,
    DWORD   dwDefaultValue = 0
    );

BOOL
FusionpRegQueryBinaryValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CFusionArray<BYTE> &rbBuffer
    );

BOOL
FusionpRegQueryBinaryValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CFusionArray<BYTE> &rbBuffer,
    DWORD &rdwLastError,
    SIZE_T cExceptionalLastErrors,
    ...
    );

BOOL
FusionpRegQueryBinaryValueEx(
    DWORD dwFlags,
    HKEY hKey,
    PCWSTR lpValueName,
    CFusionArray<BYTE> &rbBuffer,
    DWORD &rdwLastError,
    SIZE_T cExceptionalLastErrors,
    va_list ap
    );

BOOL
FusionpAreWeInOSSetupMode(
    BOOL*
    );

BOOL
FusionpAreWeInMiniSetupMode(
    BOOL*
    );

BOOL
FusionpMapLangIdToString(
    DWORD dwFlags,
    LANGID LangID,
    PCWSTR *StringOut
    );


BOOL
SxspDequoteString(
    IN DWORD dwFlags,
    IN PCWSTR pcwszStringIn,
    IN SIZE_T cchStringIn,
    OUT PWSTR pwszStringOut,
    OUT SIZE_T *pcchStringOut
    );

BOOL
FusionpGetActivationContextFromFindResult(
    IN PCACTCTX_SECTION_KEYED_DATA askd,
    OUT HANDLE *
    );

#define FUSIONP_SEARCH_PATH_ACTCTX (0x00000001)
BOOL
FusionpSearchPath(
    ULONG               ulFusionFlags,
    LPCWSTR             lpPath,
    LPCWSTR             lpFileName,         // file name
    LPCWSTR             lpExtension,        // file extension
    CBaseStringBuffer & StringBuffer,
    SIZE_T *            lpFilePartOffset,   // file component
    HANDLE              hActCtx
    );

BOOL
FusionpGetModuleFileName(
    ULONG               ulFusionFlags,
    HMODULE             hmodDll,
    CBaseStringBuffer & StringBuffer
    );

#define SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE      (0x00000001)
#define SXSP_DOES_FILE_EXIST_FLAG_INCLUDE_NETWORK_ERRORS (0x00000002)
#define SXSP_DOES_FILE_EXIST_FLAG_CHECK_FILE_ONLY        (0x00000004)
#define SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY   (0x00000008)

BOOL
SxspDoesFileExist(
    DWORD dwFlags,
    PCWSTR pszFileName,
    bool &rfExists
    );

#define SXSP_DOES_FILE_OR_DIRECTORY_EXIST_FLAG_COMPRESSION_AWARE      (0x00000001)
#define SXSP_DOES_FILE_OR_DIRECTORY_EXIST_FLAG_INCLUDE_NETWORK_ERRORS (0x00000002)

#define SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_FILE_EXISTS      (1)
#define SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_DIRECTORY_EXISTS (2)
#define SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_NEITHER_EXISTS   (3)
BOOL
SxspDoesFileOrDirectoryExist(
    DWORD dwFlags,
    PCWSTR pszFileName,
    OUT DWORD &rdwDisposition
    );

BOOL
SxspGetFileAttributesW(
   PCWSTR lpFileName,
   DWORD &rdwFileAttributes
   );

BOOL
SxspGetFileAttributesW(
   PCWSTR lpFileName,
   DWORD &rdwFileAttributes,
   DWORD &rdwWin32Error,
   SIZE_T cExceptionalWin32Errors,
   ...
   );

BOOL
SxspFormatULONG(
    ULONG ul,
    SIZE_T CchBuffer,
    WCHAR Buffer[],
    SIZE_T *CchWrittenOrRequired
    );

#pragma warning(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\lou_multi_examples\1\makefile.inc ===
$(O)\foo.res: $(O_MANIFESTS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\lou_multi_examples\2\makefile.inc ===
$(O)\foo.res: $(O_MANIFESTS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\win32simplelock.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    win32simplelock.h

Abstract:

    works downlevel to Win95/NT3.
    can be statically initialized, but not with all zeros.
    never runs out of memory
    does not wait or boost-upon-exit efficiently.
    must be held for only short periods of time.
    should perhaps be called spinlock
    can be taken recursively.
    can only be taken exclusively, NOT reader/writer.
    acquire has a "SleepCount" parameter:
        0 is like TryEnterCriticalSection
        INFINITE is like EnterCriticalSection
    SHOULD have a spincount to scale hot locks on multiprocs

Author:

    Jay Krell (JayKrell) August 2001

Revision History:

--*/

#pragma once

#if defined(__cplusplus)
extern "C" {
#endif

typedef struct _WIN32_SIMPLE_LOCK {
    DWORD Size;
    LONG  Lock;
    DWORD OwnerThreadId;
    LONG  Waiters;
    ULONG EntryCount;
    PVOID Extra[2];
} WIN32_SIMPLE_LOCK, *PWIN32_SIMPLE_LOCK;

#define WIN32_INIT_SIMPLE_LOCK { sizeof(WIN32_SIMPLE_LOCK), -1 }

#define WIN32_ACQUIRE_SIMPLE_LOCK_WAS_NOT_RECURSIVE_ACQUIRE  (0x00000001)
#define WIN32_ACQUIRE_SIMPLE_LOCK_WAS_RECURSIVE_ACQUIRE      (0x00000002)
#define WIN32_ACQUIRE_SIMPLE_LOCK_WAS_FIRST_ACQUIRE          (0x00000004) /* useful for an exactly one one shot */
DWORD
Win32AcquireSimpleLock(
    PWIN32_SIMPLE_LOCK SimpleLock,
    DWORD SleepCount
#if defined(__cplusplus)
    = INFINITE
#endif
    );

#define WIN32_RELEASE_SIMPLE_LOCK_WAS_RECURSIVE_RELEASE     (0x80000000)
#define WIN32_RELEASE_SIMPLE_LOCK_WAS_NOT_RECURSIVE_RELEASE (0x40000000)
DWORD
Win32ReleaseSimpleLock(
    PWIN32_SIMPLE_LOCK SimpleLock
    );

#if defined(__cplusplus)
}
#endif

#if defined(__cplusplus)
class CWin32SimpleLock
{
public:
    WIN32_SIMPLE_LOCK Base;

    DWORD Acquire(DWORD SleepCount = INFINITE) { return Win32AcquireSimpleLock(&Base, SleepCount); }
    void Release() { Win32ReleaseSimpleLock(&Base); }
    operator PWIN32_SIMPLE_LOCK() { return  &Base; }
    operator  WIN32_SIMPLE_LOCK&()  { return Base; }
};

class CWin32SimpleLockHolder
{
public:
    CWin32SimpleLockHolder(CWin32SimpleLock * Lock) : m_Lock(Lock), m_Result(0)
    {
        m_Result = Lock->Acquire(INFINITE);
    }

    void Release()
    {
        if (m_Lock != NULL)
        {
            m_Lock->Release();
            m_Lock = NULL;
        }
    }

    ~CWin32SimpleLockHolder()
    {
        Release();
    }

    CWin32SimpleLock* m_Lock;
    DWORD             m_Result;
};

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\inc\xmlns.h ===
#if !defined(_FUSION_INC_XMLNS_H_INCLUDED_)
#define _FUSION_INC_XMLNS_H_INCLUDED_

#pragma once

#include <ole2.h>
#include <xmlparser.h>
#include "fusionhash.h"
#include "fusionheap.h"
#include "fusionchartraits.h"
#include "smartptr.h"

class CXMLNamespaceManager
{
public:
    CXMLNamespaceManager();
    ~CXMLNamespaceManager();

    BOOL Initialize();

    // To get things to track, call these functions in your IXMLNodeFactory before your own processing.
    HRESULT OnCreateNode(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);
    HRESULT OnBeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo);
    HRESULT OnEndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);

    enum MapFlags
    {
        eMapFlag_DoNotApplyDefaultNamespace = 0x00000001,
    };

    HRESULT Map(
        DWORD dwMapFlags,
        const XML_NODE_INFO *pNodeInfo,
        CBaseStringBuffer *pbuffNamespace,
        SIZE_T *pcchNamespacePrefix
        );

    class CNamespacePrefix
    {
    public:
        CNamespacePrefix();
        ~CNamespacePrefix();

        CNamespacePrefix *m_Previous;
        CSmallStringBuffer m_NamespaceURI;
        ULONG m_Depth;

    private:
        CNamespacePrefix(const CNamespacePrefix &);
        void operator =(const CNamespacePrefix &);
    };

protected:
    BOOL InsertOrUpdateIfCallback(
        CNamespacePrefix *pPrefixNew,
        CNamespacePrefix * const &rpPrefixCurrent,
        InsertOrUpdateIfDisposition &Disposition
        );

    CStringPtrTable<CNamespacePrefix, CUnicodeCharTraits> m_NamespacePrefixes;
    ULONG m_CurrentDepth;
    CNamespacePrefix *m_DefaultNamespacePrefix;

private:
    CXMLNamespaceManager(const CXMLNamespaceManager &r);
    void operator =(const CXMLNamespaceManager &r);

};

#endif // !defined(_FUSION_INC_XMLNS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\lou_multi_examples\2\resource.h ===
#define ANOTHER_MANIFEST_ID 12345
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\fusion_msi_win.inc ===
FUSION_MSI_LIB_PATH = $(FUSION_MSI_WHISTLER_LIB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\lou_multi_examples\1\resource.h ===
#define FOO_MANIFEST_ID     123
#define ANOTHER_MANIFEST_ID 12345
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\msi.inc ===
!include $(PROJECT_ROOT)\win32\fusion\fusion.inc


FUSION_MSI_PATH = $(FUSION_PATH)\msi
FUSION_MSI_INC_PATH = $(FUSION_MSI_PATH)\inc
FUSION_MSI_WHISTLER_LIB = $(FUSION_MSI_PATH)\winobj\lib
FUSION_MSI_WIN2000_LIB = $(FUSION_MSI_PATH)\w2kobj\lib

# try to define FUSION_MSI_LIB_PATH using BUILD_TYPE
!include fusion_msi_$(FUSION_BUILD_TYPE).inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\fusion_msi_win2000.inc ===
FUSION_MSI_LIB_PATH = $(FUSION_MSI_WIN2000_LIB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_duplicateassemblyfile\idlib.cpp ===
#include "..\..\id\id.cpp"
#include "..\..\id\sxsid.cpp"
#include "..\..\id\policy.cpp"
#include "..\..\id\encdec.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_duplicateassemblyfile\ca_dup.cpp ===
#include "stdinc.h"
#include "macros.h"
#include "common.h"
#include "idp.h"
#include "sxsutil.h"

#include "fusionbuffer.h"
#include "fusionheap.h"

#define FUSION_WIN32_ASSEMBLY_DUP_FILEKEY_PREFIX        L"winsxs_"
#define MSI_ASSEMBLYCACHE_DIRECTORY_KEYNAME             L"MsiFusionWin32AssemblyCache"
#define MSI_ASSEMBLYCACHE_DIRECTORY                     L"winsxs"

#define MSI_ASSEMBLY_MANIFEST_CACHE_DIRECTORY_KEYNAME   L"MsiFusionWin32AssemblyManifestCache"
#define MSI_ASSEMBLY_MANIFEST_CACHE_DIRECTORY           L"Manifests"

#define MSI_ASSEMBLY_MANIFEST_COMPONENT_KEYNAME         L"MsiFusionWin32AssemblyManifestComponent"

#define MANIFEST_FILE_EXT                               L".Manifest"
#define CATALOG_FILE_EXT                                L".cat"


///////////////////////////////////////////////////////////////////////////////
// Assumption : at this moment,we asusme that DuplicateFile table EXISTS
/////////////////////////////////////////////////////////////////////////////////
HRESULT CA_DuplicationWin32AssemblyFiles_Callback(const CA_ENM_ASSEMBLY_CALLBACK_INFO * info)
{
    HRESULT hr = S_OK;    
    CStringBuffer sbDupFileKey;   
    CStringBuffer sbDupFileName;
    CSmallStringBuffer sbExt;
    bool fManifest = false;
    bool fCatalog = false;

        
    PARAMETER_CHECK_NTC(info != NULL);    
    PARAMETER_CHECK_NTC(info->pszFileID != NULL);
    PARAMETER_CHECK_NTC(info->pszFileName);


    sbDupFileKey.Win32Assign(FUSION_WIN32_ASSEMBLY_DUP_FILEKEY_PREFIX, wcslen(FUSION_WIN32_ASSEMBLY_DUP_FILEKEY_PREFIX));
    sbDupFileKey.Win32Append(info->pszFileID, wcslen(info->pszFileID));

    IFFALSE_EXIT(sbDupFileName.Win32Assign(info->pszFileName, wcslen(info->pszFileName)));
    IFFALSE_EXIT(sbDupFileName.Win32GetPathExtension(sbExt));

    //
    //rename manifest file and catalog file 
    //
    if ((FusionpCompareStrings(sbExt, sbExt.Cch(), L"man", wcslen(L"man"), true) == 0) ||                 
        (FusionpCompareStrings(sbExt, sbExt.Cch(), L"manifest", wcslen(L"manifest"), true) == 0))
    {    
        fManifest = true;
    }
    else 
    if ((FusionpCompareStrings(sbExt, sbExt.Cch(), L"cat", wcslen(L"cat"), true) == 0) ||
        (FusionpCompareStrings(sbExt, sbExt.Cch(), L"catalog", wcslen(L"catalog"), true) == 0))
    {
        fCatalog = true;
    }

    if (fManifest || fCatalog)
    {
        PARAMETER_CHECK_NTC(info->pszAssemblyUniqueDir != NULL);
        IFFALSE_EXIT(sbDupFileName.Win32Assign(info->pszAssemblyUniqueDir, wcslen(info->pszAssemblyUniqueDir)));
        
        // reset the extension of manifest file and catalog file in order to keep the same as XP        
        IFFALSE_EXIT(sbDupFileName.Win32Append(fManifest? MANIFEST_FILE_EXT : CATALOG_FILE_EXT, 
            fManifest? wcslen(MANIFEST_FILE_EXT) : wcslen(CATALOG_FILE_EXT)));        
    }else
    {
        PARAMETER_CHECK_NTC(info->pszFileName != NULL);
        IFFALSE_EXIT(sbDupFileName.Win32Assign(info->pszFileName, wcslen(info->pszFileName)));
    }
        
    // if it is a .manifest file or it is a catalog file, put it into winsxs\manifests folder, 
    // otherwise, put it into winsxs\x86_...._12345678
    IFFAILED_EXIT(ExecuteInsertTableSQL(TEMPORARY_DB_OPT, info->hdb, 
        OPT_DUPLICATEFILE, 
        NUMBER_OF_PARAM_TO_INSERT_TABLE_DUPLICATEFILE,
        MAKE_PCWSTR(sbDupFileKey),
        MAKE_PCWSTR(info->pszComponentID),
        MAKE_PCWSTR(info->pszFileID),
        MAKE_PCWSTR(sbDupFileName), 
        (fManifest | fCatalog) ? MSI_ASSEMBLY_MANIFEST_CACHE_DIRECTORY_KEYNAME : MAKE_PCWSTR(info->pszDestFolderID)));

Exit:
    return hr;
}

HRESULT GetXPInstalledDirectory(const CA_ENM_ASSEMBLY_CALLBACK_INFO * info, CStringBuffer & sbAsmDir)
{        
    HRESULT hr = S_OK;
    WCHAR sqlbuf[CA_MAX_BUF];   
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRecord = NULL;   
    WCHAR bufName[CA_MAX_BUF];
    DWORD cchName;
    WCHAR bufValue[CA_MAX_BUF];
    DWORD cchValue;
    BOOL fWin32, fWin32Policy;
    CStringBuffer sbPathBuffer;
    UINT iRet;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;

    PARAMETER_CHECK_NTC(info != NULL);
    PARAMETER_CHECK_NTC(info->pszComponentID != NULL);
    PARAMETER_CHECK_NTC(info->hdb != NULL);
    
    IFFALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &AssemblyIdentity, 0, NULL));
    swprintf(sqlbuf, L"SELECT Name, Value FROM MsiAssemblyName WHERE Component_='%s'", info->pszComponentID);

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info->hdb, sqlbuf, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));

    for (;;)
    {
        //
        // for each entry in MsiAssembly Table
        //
        iRet = MsiViewFetch(hView, &hRecord);
        if (iRet == ERROR_NO_MORE_ITEMS)
            break;
        if (iRet != ERROR_SUCCESS )
            SET_HRERR_AND_EXIT(iRet);

        cchName = NUMBER_OF(bufName);
        cchValue = NUMBER_OF(bufValue);

        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 1, bufName, &cchName));
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 2, bufValue, &cchValue));

        Attribute.Flags = 0;        
        Attribute.NamespaceCch  = 0;
        Attribute.Namespace     = NULL;
        Attribute.NameCch       = cchName;
        Attribute.Name          = bufName;
        Attribute.ValueCch      = cchValue;
        Attribute.Value         = bufValue;

        //BUGBUG
        // Fusion win32 required that the attribute name is case-sensitive, so, for assembly name,
        // it should appear as "name" in MsiAssemblyName, however, for some historical reason,
        // it appears as "Name", so, we have to force it to the right thing for win32.
        //
        // for other attribute in MsiAssemblyName table, there is no such problem,
        //
        //BUGBUG
        if ((Attribute.NameCch == 4) && (_wcsicmp(Attribute.Name, L"name") == 0))
        {
            Attribute.Name          = L"name";
        }

        IFFALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(0, AssemblyIdentity, &Attribute));
    }
    
    IFFALSE_EXIT(SxsHashAssemblyIdentity(0, AssemblyIdentity, NULL));

    //
    // generate the path, something like x86_ms-sxstest-sfp_75e377300ab7b886_1.0.0.0_en_04f354da
    //
    IFFAILED_EXIT(ca_SxspDetermineAssemblyType(AssemblyIdentity, fWin32, fWin32Policy));

    IFFAILED_EXIT(ca_SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | (fWin32Policy ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0),
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            NULL,
            0,
            AssemblyIdentity,
            sbPathBuffer));


    IFFALSE_EXIT(sbAsmDir.Win32Assign(sbPathBuffer));
    hr = S_OK;

Exit:
    SxsDestroyAssemblyIdentity(AssemblyIdentity);
    return hr;
}

HRESULT IsCertainRecordExistInDirectoryTable(const MSIHANDLE & hdb, PCWSTR DirectoryKey, BOOL & fExist)
{
    HRESULT hr = S_OK;
    PMSIHANDLE hRecord = NULL;
    PMSIHANDLE hView = NULL;
    WCHAR sqlBuf[MAX_PATH];
    
    fExist = FALSE;

    swprintf(sqlBuf, ca_sqlQuery[CA_SQL_QUERY_DIRECTORY], DirectoryKey);
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, sqlBuf, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));
    UINT iRet = MsiViewFetch(hView, &hRecord);

    if (iRet == ERROR_SUCCESS)
    {
        fExist = TRUE;
    }
    else if (iRet == ERROR_NO_MORE_ITEMS)
    {
        fExist = FALSE;
    }
    else
        SET_HRERR_AND_EXIT(iRet);

    hr = S_OK;

Exit:
    return hr;
}

//
// add entry to Directory Table and CreateFolder Table
//
HRESULT AddFusionAssemblyDirectories(const CA_ENM_ASSEMBLY_CALLBACK_INFO * info, CStringBuffer & sbDestFolderID)
{
    HRESULT hr = S_OK;    
    BOOL fRecordExist = FALSE;

    PARAMETER_CHECK_NTC(info != NULL);
    PARAMETER_CHECK_NTC(info->pszAssemblyUniqueDir != NULL);
    PARAMETER_CHECK_NTC(info->hdb != NULL);
    PARAMETER_CHECK_NTC(info->pszComponentID != NULL);

    //
    // TODO: here we could make the DirectoryID more unique
    //
    IFFALSE_EXIT(sbDestFolderID.Win32Assign(info->pszAssemblyUniqueDir, wcslen(info->pszAssemblyUniqueDir)));
    IFFAILED_EXIT(ExecuteInsertTableSQL(TEMPORARY_DB_OPT, info->hdb,
            OPT_DIRECTORY,
            NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY,
            MAKE_PCWSTR(sbDestFolderID),
            MAKE_PCWSTR(MSI_ASSEMBLYCACHE_DIRECTORY_KEYNAME),
            MAKE_PCWSTR(info->pszAssemblyUniqueDir)));

    //
    // insert entry to CreateFolder Table
    //

    IFFAILED_EXIT(ExecuteInsertTableSQL(TEMPORARY_DB_OPT, info->hdb,
            OPT_CREATEFOLDER,
            NUMBER_OF_PARAM_TO_INSERT_TABLE_CREATEFOLDER,
            MAKE_PCWSTR(sbDestFolderID),            
            MAKE_PCWSTR(info->pszComponentID)));

    hr = S_OK;

Exit:
    return hr;
}

HRESULT CheckWhetherUserWantMigrate(const CA_ENM_ASSEMBLY_CALLBACK_INFO * info, BOOL & fMigrateDenied)
{
    HRESULT hr = S_OK;
    WCHAR pwszSQL[MAX_PATH];
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRecord = NULL;
    UINT err, iRet;

    fMigrateDenied = FALSE;
        
    // NTRAID#NTBUG9 - 589779 - 2002/03/26 - xiaoyuw
    // should be replaced with _snwprintf
    swprintf(pwszSQL, L"SELECT `fMigrate` FROM `%s` WHERE `Component_` = '%s'", WIN32_ASSEMBLY_MIGRATE_TABLE, info->pszComponentID);

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info->hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, NULL));
    err = ::MsiViewFetch(hView, &hRecord);
    switch (err) {    
    case ERROR_NO_MORE_ITEMS: // not exist in the table, default is migrate-enabled
        break;
    case ERROR_SUCCESS:        
        iRet = MsiRecordGetInteger(hRecord, 1);
        if ( iRet == 0 )
            fMigrateDenied = TRUE;
        break;
    default:
        SET_HRERR_AND_EXIT(err);
    }

Exit:
    return hr;
}
       


//
// CA for Fusion Win32 Assembly installation on downlevel(only) :
//  (1)set entries for each assembly file in DuplicateFile Table
//  (2)after all done, set a RegKey so this would not be done everytime
//
HRESULT __stdcall CA_DuplicationWin32Assembly_Callback(CA_ENM_ASSEMBLY_CALLBACK_INFO * info)
{
    HRESULT hr = S_OK;    
    CStringBuffer sbDestFolder;
    CStringBuffer sbDestFolderID;
    BOOL fExist = FALSE;
    BOOL fMigrateDenied = FALSE;

    PARAMETER_CHECK_NTC((info->dwFlags == 0) ||(info->dwFlags == CA_ENM_ASSEMBLY_CALLBACK_INFO_FLAG_IGNORE_MIGRATE_DENY_CHECK));
    PARAMETER_CHECK_NTC(info->hInstall != NULL);    
    PARAMETER_CHECK_NTC(info->pszComponentID != NULL);
    PARAMETER_CHECK_NTC(info->pszManifestFileID != NULL);
    
    if (! (info->dwFlags & CA_ENM_ASSEMBLY_CALLBACK_INFO_FLAG_IGNORE_MIGRATE_DENY_CHECK))
    {
        IFFAILED_EXIT(CheckWhetherUserWantMigrate(info, fMigrateDenied));
        if (fMigrateDenied)
            goto Exit;
    }

    //
    // get sxs component directory in the format of x86_name_publicKeyToken_1.0.0.0_en_hashvalue
    //
    IFFAILED_EXIT(GetXPInstalledDirectory(info, sbDestFolder));
    info->pszAssemblyUniqueDir = sbDestFolder;

    //
    // Create an entry for this dir in Directory Table, return DirectoryID in Directory Table
    //
    IFFAILED_EXIT(AddFusionAssemblyDirectories(info, sbDestFolderID));    
                
    info->pszDestFolderID = sbDestFolderID;
    
    
    IFFAILED_EXIT(MSI_EnumComponentFiles(info, CA_DuplicationWin32AssemblyFiles_Callback));    
    
Exit:
    return hr;
}

HRESULT __stdcall CustomAction_CopyFusionWin32AsmIntoAsmCache(MSIHANDLE hInstall)
{
    HRESULT hr = S_OK;
    BOOL fExist;
    MSIHANDLE hdb = NULL;

#if DBG
    MessageBoxA(NULL, "Enjoy the Debug", "ca_dup", MB_OK);
#endif
    // Before enumerate all the assemblies, do common work right here ....    

    //
    // (1) insert MsiAsmcache into Directory Table if not present
    //
    hdb = MsiGetActiveDatabase(hInstall);
    INTERNAL_ERROR_CHECK_NTC(hdb != NULL);

    IFFAILED_EXIT(IsCertainRecordExistInDirectoryTable(hdb, L"WindowsFolder", fExist));
    if (fExist == FALSE) 
    {
        
        IFFAILED_EXIT(ExecuteInsertTableSQL(TEMPORARY_DB_OPT, hdb, 
                OPT_DIRECTORY, 
                NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY,
                MAKE_PCWSTR(L"WindowsFolder"),
                MAKE_PCWSTR(L"TARGETDIR"),
                MAKE_PCWSTR(".")));
    }

    // adding winsxs into Directory Table
    IFFAILED_EXIT(IsCertainRecordExistInDirectoryTable(hdb, MSI_ASSEMBLYCACHE_DIRECTORY_KEYNAME, fExist));
    if (fExist == FALSE) 
    {
        
        IFFAILED_EXIT(ExecuteInsertTableSQL(TEMPORARY_DB_OPT, hdb, 
                OPT_DIRECTORY, 
                NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY,
                MAKE_PCWSTR(MSI_ASSEMBLYCACHE_DIRECTORY_KEYNAME),
                MAKE_PCWSTR(L"WindowsFolder"),
                MAKE_PCWSTR(MSI_ASSEMBLYCACHE_DIRECTORY)));
    }

    // adding winsxs\manifests into Directory table
    IFFAILED_EXIT(IsCertainRecordExistInDirectoryTable(hdb, MSI_ASSEMBLY_MANIFEST_CACHE_DIRECTORY_KEYNAME, fExist));
    if (fExist == FALSE) 
    {   
        IFFAILED_EXIT(ExecuteInsertTableSQL(TEMPORARY_DB_OPT, hdb, 
                OPT_DIRECTORY, 
                NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY,
                MAKE_PCWSTR(MSI_ASSEMBLY_MANIFEST_CACHE_DIRECTORY_KEYNAME),
                MAKE_PCWSTR(MSI_ASSEMBLYCACHE_DIRECTORY_KEYNAME),
                MAKE_PCWSTR(MSI_ASSEMBLY_MANIFEST_CACHE_DIRECTORY)));
    }

    // create a component associated with this Directory too
    IFFAILED_EXIT(ExecuteInsertTableSQL(TEMPORARY_DB_OPT, hdb, 
            OPT_COMPONENT, 
            NUMBER_OF_PARAM_TO_INSERT_TABLE_COMPONENT,
            MSI_ASSEMBLY_MANIFEST_COMPONENT_KEYNAME,
            MSI_ASSEMBLY_MANIFEST_CACHE_DIRECTORY_KEYNAME));

    //create the folder : %windir%\winsxs\manifest
    IFFAILED_EXIT(ExecuteInsertTableSQL(TEMPORARY_DB_OPT, hdb,
            OPT_CREATEFOLDER,
            NUMBER_OF_PARAM_TO_INSERT_TABLE_CREATEFOLDER,
            MSI_ASSEMBLY_MANIFEST_CACHE_DIRECTORY_KEYNAME,
            MSI_ASSEMBLY_MANIFEST_COMPONENT_KEYNAME));

    //
    //Enumerate all msi assembly  in MsiAssemblyTable
    //   
    IFFAILED_EXIT(MSI_EnumWinFuseAssembly(ENUM_ASSEMBLY_FLAG_CHECK_ASSEMBLY_ONLY, hInstall, CA_DuplicationWin32Assembly_Callback));

Exit:
    if (hdb)
        MsiCloseHandle(hdb);

    return hr;
}

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  
  DWORD fdwReason,     
  LPVOID lpvReserved   
)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        FusionpInitializeHeap(NULL);
    }    
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        // NTRAID#NTBUG9 - 589779 - 2002/03/26 - xiaoyuw
        // FusionpUninitializeHeap should be called when dll is detached
        FusionpUninitializeHeap();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_duplicateassemblyfile\msicommon.cpp ===
#include "..\common\msidb.cpp"
#include "..\common\db.cpp"
#include "..\common\sxsutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_duplicateassemblyfile\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

FUSION_BUILD_TYPE=WIN2000
FUSION_BUILD_LEAF_DIRECTORY=win2000

!include $(PROJECT_ROOT)\win32\fusion\msi\msi.inc

MAJORCOMP=fusion
MINORCOMP=ca_dup

TARGETNAME=ca_dup
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=..\ca_dup.def
DLLENTRY=DllMain

USE_CRTDLL=1
USE_NATIVE_EH=1

INCLUDES= \
 $(FUSION_MSI_INC_PATH);\
 $(FUSION_INC_PATH);\
 $(FUSION_PATH); \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\utils; \
 $(INCLUDES);\
 $(PROJECT_ROOT)\ntdll; \
 $(PROJECT_ROOT)\ntos\inc; \
 $(PROJECT_ROOT)\ntos\rtl; \

SOURCES=\
 ..\ca_dup.cpp \
 ..\msicommon.cpp \
 ..\idlib.cpp \
 ..\utillib.cpp

TARGETLIBS= \
 $(FUSION_PATH)\$(O)\win32simplelock.lib \
 $(SDK_LIB_PATH)\msvcrt.lib \
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\Advapi32.lib \
 $(SDK_LIB_PATH)\user32.lib \
 $(SDK_LIB_PATH)\msi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_duplicateassemblyfile\utillib.cpp ===
#include "fusionhashstring.cpp"
#include "fusionheap.cpp"
#pragma warning(disable: 4273)
#include "ntdllwrap.cpp"
#pragma warning(default: 4273)
#include "trace.cpp"
#include "debug.cpp"
#include "isprint.c"
#include "fusioninitializecriticalsection.cpp"
#include "sxsexceptionhandling.cpp"
#include "checkSetupMode.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_migrate\ca_migrate.h ===
Volume in drive X is Enlistment
 Volume Serial Number is 626B-FFEA

 Directory of X:\fuse1\base\win32\fusion\msi\ca_migrate

09/03/2001  02:47 PM    <DIR>          .
09/03/2001  02:47 PM    <DIR>          ..
08/31/2001  08:03 PM               672 build.log
09/03/2001  02:41 PM             1,167 ca_migrate.cpp
08/31/2001  05:04 PM                55 ca_migrate.def
09/03/2001  02:47 PM                 0 ca_migrate.h
08/31/2001  01:19 PM                36 makefile
09/03/2001  02:44 PM    <DIR>          obj
08/31/2001  08:03 PM               788 sources
               6 File(s)          2,718 bytes
               3 Dir(s)   9,660,039,168 bytes free
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_policy\ca_pol.cpp ===
// NTRAID#NTBUG9 - 589788 - 2002/03/26 - xiaoyuw
// (1)Do we still need this? or Darwin has fix their side before 2600 client?
// (2)If we still need this, changing the status of Component could be part of CA
// (3)About getting installer state. the current implementation is very weak: 
//    it assume there is only two states: install and uninstall. which is not true....

#include "..\inc\stdinc.h"
#include "..\inc\macros.h"
#include "..\inc\common.h"

#include "msi.h"
#include "msiquery.h"
#include "sxsapi.h"

#define CA_SXSPOLICY_INSTALLATION_IDENTIFIER     L"Fusion Win32 Policy Installation on XP Client"

#define MAX_BUF 1024
#define CA_SXSPOLICY_WIN32_POLICY_INSTALL_PROMPT L"Win32 Policy Installation for XP Client"

HMODULE g_hdSxs = NULL;
PSXS_INSTALL_W g_procSxsInstallW = NULL;
PSXS_UNINSTALL_ASSEMBLYW g_procSxsUninstallW = NULL;
PSXS_QUERY_MANIFEST_INFORMATION g_procSxsQueryManifestInformation = NULL;


HRESULT UninstallSxsPolicy(PCWSTR szManifestFile)
{
    HRESULT hr = S_OK;
    SXS_UNINSTALLW UninstallParameters = {sizeof(UninstallParameters)};
    SXS_INSTALL_REFERENCEW Reference = {sizeof(Reference)};
        
    BYTE ManifestInformationBuffer[1UL << 16];
    PSXS_MANIFEST_INFORMATION_BASIC ManifestBasicInfo = reinterpret_cast<PSXS_MANIFEST_INFORMATION_BASIC>(&ManifestInformationBuffer);
    DWORD Disposition = 0;
    BOOL  Success = FALSE;

    if (g_procSxsUninstallW == NULL)
    {
        if (g_hdSxs == NULL)
        {
            g_hdSxs = LoadLibraryA("sxs.dll");
            if (g_hdSxs == NULL)
                SET_HRERR_AND_EXIT(::GetLastError());
        }
        g_procSxsUninstallW = (PSXS_UNINSTALL_ASSEMBLYW)GetProcAddress(g_hdSxs, "SxsUninstallW");
        if (g_procSxsUninstallW == NULL)
            SET_HRERR_AND_EXIT(::GetLastError());
    }

    if (g_procSxsQueryManifestInformation == NULL)
    {
        g_procSxsQueryManifestInformation = (PSXS_QUERY_MANIFEST_INFORMATION)GetProcAddress(g_hdSxs, "SxsQueryManifestInformation");
        if (g_procSxsQueryManifestInformation == NULL)
            SET_HRERR_AND_EXIT(::GetLastError());
    }       

    IFFALSE_EXIT(g_procSxsQueryManifestInformation(0, szManifestFile,
                SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC, 0, sizeof(ManifestInformationBuffer),
                ManifestBasicInfo, NULL));   

    UninstallParameters.dwFlags |= SXS_UNINSTALL_FLAG_REFERENCE_VALID;
    UninstallParameters.lpInstallReference = &Reference;
    UninstallParameters.lpAssemblyIdentity = ManifestBasicInfo->lpIdentity;

    Reference.lpIdentifier = CA_SXSPOLICY_INSTALLATION_IDENTIFIER;
    Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;

    IFFALSE_EXIT(g_procSxsUninstallW(&UninstallParameters, &Disposition));

Exit:
    return hr;
}

HRESULT InstallSxsPolicy(PCWSTR szManifestFile)
{    
    SXS_INSTALLW InstallParameters = {sizeof(InstallParameters)};
    SXS_INSTALL_REFERENCEW InstallReference = {sizeof(InstallReference)};
    HRESULT hr = S_OK;

    if (g_procSxsInstallW == NULL)
    {
        if (g_hdSxs == NULL)
        {
            g_hdSxs = LoadLibraryA("sxs.dll");
            if (g_hdSxs == NULL)
            {
                SET_HRERR_AND_EXIT(::GetLastError());
            }
        }
        g_procSxsInstallW = (PSXS_INSTALL_W)GetProcAddress(g_hdSxs, "SxsInstallW");
        if (g_procSxsInstallW == NULL)        
        {
            SET_HRERR_AND_EXIT(::GetLastError());
        }
    }


    InstallParameters.dwFlags = 
        SXS_INSTALL_FLAG_REPLACE_EXISTING |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID;
    InstallParameters.lpCodebaseURL = szManifestFile;
    InstallParameters.lpManifestPath = szManifestFile;
    InstallParameters.lpReference = &InstallReference;
    InstallParameters.lpRefreshPrompt = CA_SXSPOLICY_WIN32_POLICY_INSTALL_PROMPT ;

    InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
    InstallReference.lpIdentifier = CA_SXSPOLICY_INSTALLATION_IDENTIFIER;

    IFFALSE_EXIT((*g_procSxsInstallW)(&InstallParameters));
Exit:
    return hr;
}

HRESULT __stdcall CA_Policy_EnumFusionWin32AssemblyCallback(CA_ENM_ASSEMBLY_CALLBACK_INFO * info)
{
    enum CA_MIGRATION_MSI_INSTALL_MODE eInstallMode;
    CStringBuffer sbManfiestFilename;
    HRESULT hr = S_OK;

    PARAMETER_CHECK_NTC((info->dwFlags == 0) ||(info->dwFlags == CA_ENM_ASSEMBLY_CALLBACK_INFO_FLAG_IGNORE_MIGRATE_DENY_CHECK));
    PARAMETER_CHECK_NTC(info->hInstall != NULL); 
    PARAMETER_CHECK_NTC(info->pszComponentID != NULL);
    PARAMETER_CHECK_NTC(info->pszManifestFileID != NULL);

    IFFAILED_EXIT(MSI_GetSourceFileFullPathName(CA_FILEFULLPATHNAME_FILEID_IN_FILE_TABLE, info->hInstall, info->hdb, NULL, info->pszManifestFileID, sbManfiestFilename, info->pszComponentID));

    IFFAILED_EXIT(MSI_GetInstallerState(info->hInstall, eInstallMode));
    //
    // install this API using sxs.dll
    //
    if (eInstallMode == eInstallProduct)
    {
        IFFAILED_EXIT(InstallSxsPolicy(sbManfiestFilename));
    }
    else
    {
        ASSERT_NTC(eInstallMode == eRemoveProduct);
        IFFAILED_EXIT(UninstallSxsPolicy(sbManfiestFilename));
    }

Exit:
    return hr;
}


HRESULT __stdcall CustomAction_SxsPolicy(MSIHANDLE hInstall)
{

    HRESULT hr = S_OK;    
#if DBG
    MessageBoxA(NULL, "Enjoy Debug for sxs policy installation using msi on xpclient", "ca_policy", MB_OK);
#endif
    IFFAILED_EXIT(MSI_EnumWinFuseAssembly(ENUM_ASSEMBLY_FLAG_CHECK_POLICY_ONLY, hInstall, CA_Policy_EnumFusionWin32AssemblyCallback));

Exit:
    
    return hr;
}

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  
  DWORD fdwReason,     
  LPVOID lpvReserved
)
{
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        if (g_hdSxs != NULL)
        {
            if (lpvReserved != NULL)
            {
                FreeLibrary(g_hdSxs);
            }
            g_hdSxs = NULL;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_policy\ca_test\catest.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    catest.cpp

Abstract:

    Test Function calls for ca_policy

Function:
    This tool would generate a new msi for the package which contains a Fusion-Win32 Policy, which fails on XP Client. 
    The user need generate a new msi on one local drive based the original msi. The difference between these two msi would 
    include : 
    (1) add entry of SourceDir into Property Table : SourceDir = CDROM\Source 
    (2) add entry of ResolveSource into InstallExecuteSequence Table
    (3) change Component::Condition to be FALSE for Fusion-Win32-Policy component
    (4) Add CustomAction:
          a. add ca_policy.dll into Binary Table
          b. add Fusion_Win32_Policy_Installation action into Custom Action Table
          c. add Fusion_Win32_Policy_Installation action into InstallExecuteSequence Table   

Author:
    Xiaoyu Wu(xiaoyuw) 01-Aug-2001

--*/
#include "stdinc.h"
#include "macros.h"

#include "fusionbuffer.h"

#include "msi.h"
#include "msiquery.h"


#define CA_TEST_NEWMSI_EXTENSION     L".new.msi"
#define CA_TEST_NEWMSI_TEMPLATE      L"%ProgramFiles%\\msmgen\\templates\\ca_msi.msi"

#define CA_TEST_BINARY_NAME          L"FusionWin32Policy_CustomAction_DLL"
#define CA_TEST_BINARY_VALUE         L"%ProgramFiles%\\msmgen\\ca_policy\\ca_pol.dll"
#define CA_TEST_CUSTOMACTION_ACTION  L"FusionWin32Policy_CustomAction_Action"
#define CA_TEST_CUSTOMACTION_TARGET  L"CustomAction_SxsPolicy"

#define CA_TEST_WIN32_POLICY         L"win32-policy"

#define CA_TEST_CUSTOMACTION_TYPE            1
#define CA_TEST_RESOLVE_SOURCE_SEQUENCE_NUM  850

#define CA_TEST_INSERT_BINARY                        0
#define CA_TEST_INSERT_CUSTOMACTION                  1
#define CA_TEST_INSERT_INSTALL_EXECUTION_SEQUENCE    2
#define CA_TEST_INSERT_PROPERTY                      3

#define CA_TEST_DEFAULT_CA_SEQUENCE_NUMBER           1450

static PCWSTR sqlInsert[]= 
{
    L"INSERT INTO Binary(Name, Data) VALUES (?, ?)",
    L"INSERT INTO CustomAction(Action, Type, Source,Target) VALUES (?, ?, ?, ?)",
    L"INSERT INTO InstallExecuteSequence(Action, Condition, Sequence) VALUES(?, NULL, ?)",
    L"INSERT INTO Property(Property, Value) VALUES(?, ?)"
};

static PCWSTR sqlQuery[]= 
{
    L"SELECT `Component_`,`Value` FROM `MsiAssemblyName` WHERE `Name`='type'",            // check whether it is a policy file
    L"SELECT `Attributes` FROM `MsiAssembly` WHERE `Component_`='%s'",   // check whether it is a win32 assembly

};

static WCHAR sqlUpdate[]= L"UPDATE `%s` SET `%s` = '%s' WHERE `%s`='%s'";


#define CA_TEST_QUERY_MSIASSEMBLYNAME   0
#define CA_TEST_QUERY_MSIASSEMBLY       1

typedef struct _CA_TEST_PACKAGE_INFO
{
    CSmallStringBuffer   m_sbSourcePath;          // fully-qualified filename of the msi file
    CSmallStringBuffer   m_sbDestinationMsi;      // fullpath of new file msi
    DWORD                   m_cchSourceMsi;
    DWORD                   m_cchSourcePath;
    MSIHANDLE               m_hdb;
    BOOL                    m_fFusionWin32Policy;
    UINT                    m_iCAInstallSequenceNum;
}CA_TEST_PACKAGE_INFO;

CA_TEST_PACKAGE_INFO ginfo;

//
// (1)the user must specify msi(could be non-fully-qualified filename) by using "-msi" 
// (2)user could set the destination of new msi, it could be a path or a fully-qualified filename
//    if no dest is specified, it would try to generate the msi on the same place of original msi, with a name 
//    like oldname_new.msi
//
void PrintUsage(WCHAR * exe)
{
    fprintf(stderr, "Usage: %S <options> \n",exe);
    fprintf(stderr, "Generate a new msi for an assembly\n");
    fprintf(stderr, "[-dest             full-path]\n");        
    fprintf(stderr, "-ca                sequNum\n");  // the sequence must be after CostFinalize
    fprintf(stderr, "-msi               msi_filename\n");

    return; 
}

HRESULT ParseInputParameter(wchar_t *exe, int argc, wchar_t** argv, CA_TEST_PACKAGE_INFO &info)
{
    ULONG i = 0 ; 
    DWORD nRet;
    PWSTR psz = NULL;
    WCHAR buf[MAX_PATH];
    HRESULT hr = S_OK;
    
    info.m_cchSourceMsi = 0;
    info.m_cchSourcePath = 0;
    info.m_fFusionWin32Policy = FALSE;
    info.m_hdb = NULL;
    info.m_iCAInstallSequenceNum = 0;

    while (i < argc)
    {
        if (argv[i][0] != L'-')
            goto Invalid_Param;

        if (wcscmp(argv[i], L"-msi") == 0 )
        {
            i ++;
            psz = argv[i];
            nRet = GetFullPathNameW(psz, NUMBER_OF(buf), buf, NULL);
            if ((nRet == 0 ) || (nRet >NUMBER_OF(buf)))
                SET_HRERR_AND_EXIT(::GetLastError());
            psz = wcsrchr(buf, L'\\');
            ASSERT_NTC(psz != NULL);
            psz ++; // skip "\"
            info.m_cchSourcePath = ((ULONG)psz - (ULONG)buf)/sizeof(WCHAR);
            IFFALSE_EXIT(info.m_sbSourcePath.Win32Assign(buf, wcslen(buf)));
            info.m_cchSourceMsi = info.m_sbSourcePath.Cch();
        }else if (wcscmp(argv[i], L"-dest") == 0 )
        {
            i ++; 
            psz = argv[i];
            nRet = GetFullPathNameW(psz, NUMBER_OF(buf), buf, NULL);
            if ((nRet == 0 ) || (nRet >NUMBER_OF(buf)))
                SET_HRERR_AND_EXIT(::GetLastError());
            IFFALSE_EXIT(info.m_sbDestinationMsi.Win32Assign(buf, wcslen(buf)));
        }    
        else if (wcscmp(argv[i], L"-ca") == 0 )
        {
            i ++; 
            psz = argv[i];
            info.m_iCAInstallSequenceNum = _wtoi(psz);
        }else
            goto Invalid_Param;

        i ++;
        
    } // end of while

    if (info.m_sbSourcePath.Cch() == 0)         
        goto Invalid_Param;

    if (info.m_iCAInstallSequenceNum == 0)
        info.m_iCAInstallSequenceNum = CA_TEST_DEFAULT_CA_SEQUENCE_NUMBER;

    if (info.m_sbDestinationMsi.Cch() == 0)    
        IFFALSE_EXIT(info.m_sbDestinationMsi.Win32Assign(info.m_sbSourcePath, info.m_cchSourcePath));
    
    
    nRet = ::GetFileAttributesW(info.m_sbDestinationMsi);

    if ((nRet != DWORD(-1)) && (nRet & FILE_ATTRIBUTE_DIRECTORY))
    {   
        //
        // if the name of new msi does not specified, use the original msi filename
        //

        IFFALSE_EXIT(info.m_sbDestinationMsi.Win32EnsureTrailingPathSeparator());
        IFFALSE_EXIT(info.m_sbDestinationMsi.Win32Append(info.m_sbSourcePath + info.m_cchSourcePath, 
                                        info.m_cchSourceMsi - info.m_cchSourcePath));

        IFFALSE_EXIT(info.m_sbDestinationMsi.Win32Append(CA_TEST_NEWMSI_EXTENSION, NUMBER_OF(CA_TEST_NEWMSI_EXTENSION) - 1));
    }

    goto Exit;

Invalid_Param:
    hr = E_INVALIDARG;
    PrintUsage(exe);
Exit:
    return hr;
}

//
// change Component::Condition of Fusion Win32 policy to be FALSE
//
HRESULT UpdateComponentTable(CA_TEST_PACKAGE_INFO & info)
{
    WCHAR szbuf[128];
    UINT iValue;
    WCHAR tmp[256];
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRecord = NULL;
    HRESULT hr = S_OK;
    UINT iRet;
    DWORD cchbuf;

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info.m_hdb, sqlQuery[CA_TEST_QUERY_MSIASSEMBLYNAME], &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));

    for (;;)
    {
        iRet = MsiViewFetch(hView, &hRecord);
        if (iRet == ERROR_NO_MORE_ITEMS)
            break;

        if (iRet != ERROR_SUCCESS )
            SET_HRERR_AND_EXIT(iRet);

        //
        // check whether it is policy : Note that the value of attribute is case-insensitive...
        //
        cchbuf = NUMBER_OF(szbuf);
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 2, szbuf, &cchbuf));
        if (_wcsicmp(szbuf, CA_TEST_WIN32_POLICY) != 0)
            continue;

        //
        // get ComponentID
        //
        cchbuf = NUMBER_OF(szbuf);
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetString(hRecord, 1, szbuf, &cchbuf));

        {
        // 
        // check whether this a win32 Assembly
        //        
        PMSIHANDLE hView = NULL;
        PMSIHANDLE  hRecord = NULL;   

        swprintf(tmp, sqlQuery[CA_TEST_QUERY_MSIASSEMBLY], szbuf);        
        IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info.m_hdb, tmp, &hView));
        IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiViewFetch(hView, &hRecord)); // this call should succeed otherwise fail
        iValue = MsiRecordGetInteger(hRecord, 1);
        MsiCloseHandle(hRecord);

        }

        if (iValue != 1)        
            continue;
        
        {
        //
        // update Component__Condtion to be FALSE
        // 
        PMSIHANDLE hView = NULL;
        PMSIHANDLE  hRecord = NULL;   

        swprintf(tmp, sqlUpdate, L"Component", L"Condition", L"FALSE", L"Component", szbuf);
        IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info.m_hdb, tmp, &hView));
        IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));
        MsiCloseHandle(hRecord);
        if (info.m_fFusionWin32Policy == FALSE)
            info.m_fFusionWin32Policy = TRUE;
        }
    } // end of for MsiFetchRecord

Exit:
    return hr;
}

HRESULT ImportTablesIfNeeded(CA_TEST_PACKAGE_INFO & info)
{
    ASSERT_NTC(info.m_fFusionWin32Policy == TRUE);
    WCHAR buf[MAX_PATH];
    UINT iRet;
    HRESULT hr = S_OK;
    PMSIHANDLE hDatabase = NULL;

    iRet = ExpandEnvironmentStringsW(CA_TEST_NEWMSI_TEMPLATE, buf, NUMBER_OF(buf));
    if ((iRet == 0) || (iRet > NUMBER_OF(buf)))    
        SET_HRERR_AND_EXIT(::GetLastError());
    
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiOpenDatabaseW(buf, (LPCWSTR)MSIDBOPEN_READONLY, &hDatabase)); 
    ASSERT_NTC(info.m_hdb != NULL);

    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiDatabaseMerge(info.m_hdb, hDatabase, NULL));

Exit:
    if (hDatabase != NULL)
    {
        MsiCloseHandle(hDatabase);
    }
    return hr;    
}

//
// add ca_policy to CustomAction
//
HRESULT AddEntryIntoDB(CA_TEST_PACKAGE_INFO & info)
{
    PMSIHANDLE hRecord = NULL;
    PMSIHANDLE hView = NULL;
    WCHAR tmp[256];
    HRESULT hr = S_OK;
    UINT iRet;
    CSmallStringBuffer buf;

    //
    // Insert BinaryTable
    //
    hRecord = MsiCreateRecord(2);
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStringW(hRecord, 1, CA_TEST_BINARY_NAME));
    iRet = ExpandEnvironmentStringsW(CA_TEST_BINARY_VALUE, tmp, NUMBER_OF(tmp));
    if ((iRet == 0) || (iRet > NUMBER_OF(tmp)))    
        SET_HRERR_AND_EXIT(::GetLastError()); 
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStreamW(hRecord, 2, tmp));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info.m_hdb, sqlInsert[CA_TEST_INSERT_BINARY], &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRecord));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hView));
    hView = NULL;
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hRecord));
    hRecord = NULL;

    //
    // insert CustionAction Table
    //
    hRecord = MsiCreateRecord(4);
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStringW(hRecord, 1, CA_TEST_CUSTOMACTION_ACTION));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetInteger(hRecord, 2, CA_TEST_CUSTOMACTION_TYPE));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStringW(hRecord, 3, CA_TEST_BINARY_NAME));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStringW(hRecord, 4, CA_TEST_CUSTOMACTION_TARGET));
    
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info.m_hdb, sqlInsert[CA_TEST_INSERT_CUSTOMACTION], &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRecord));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hView));
    hView = NULL;
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hRecord));
    hRecord = NULL;

    //
    // insert myAction into CA_TEST_INSERT_INSTALL_EXECUTION_SEQUENCE
    //
    hRecord = MsiCreateRecord(2);
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStringW(hRecord, 1, CA_TEST_CUSTOMACTION_ACTION));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetInteger(hRecord, 2, info.m_iCAInstallSequenceNum));    
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info.m_hdb, sqlInsert[CA_TEST_INSERT_INSTALL_EXECUTION_SEQUENCE], &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRecord));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hView));
    hView = NULL;
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hRecord));
    hRecord = NULL;

    //
    // insert PropertyTable about SourceDir
    //
    hRecord = MsiCreateRecord(2);    
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStringW(hRecord, 1, L"SourceDir"));
    IFFALSE_EXIT(buf.Win32Assign(info.m_sbSourcePath, info.m_cchSourcePath));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStringW(hRecord, 2, buf));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info.m_hdb, sqlInsert[CA_TEST_INSERT_PROPERTY], &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRecord));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hView));
    hView = NULL;
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hRecord));
    hRecord = NULL;


    //
    // insert ResolveSource into CA_TEST_INSERT_INSTALL_EXECUTION_SEQUENCE
    //
    hRecord = MsiCreateRecord(2);
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetStringW(hRecord, 1, L"ResolveSource"));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordSetInteger(hRecord, 2, CA_TEST_RESOLVE_SOURCE_SEQUENCE_NUM));    
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info.m_hdb, sqlInsert[CA_TEST_INSERT_INSTALL_EXECUTION_SEQUENCE], &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRecord));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hView));
    hView = NULL;
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiCloseHandle(hRecord));
    hRecord = NULL;

Exit:
    if (hView != NULL)
        MsiCloseHandle(hView);
    if (hRecord != NULL)
        MsiCloseHandle(hRecord);

    return hr;
}


HRESULT GenerateTestMsiForFusionPolicyInstallOnXPClient(CA_TEST_PACKAGE_INFO & info)
{
    ASSERT_NTC(info.m_sbSourcePath.Cch() != 0);          
    ASSERT_NTC(info.m_sbDestinationMsi.Cch() != 0);       
    ASSERT_NTC(info.m_cchSourceMsi != 0);
    ASSERT_NTC(info.m_cchSourcePath != 0);
    ASSERT_NTC(info.m_iCAInstallSequenceNum != 0);

    HRESULT hr = S_OK;

    IFFALSE_EXIT(CopyFileW(info.m_sbSourcePath, info.m_sbDestinationMsi, FALSE));
    IFFALSE_EXIT(SetFileAttributesW(info.m_sbDestinationMsi, FILE_ATTRIBUTE_NORMAL));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiOpenDatabaseW(info.m_sbDestinationMsi, (LPCWSTR)MSIDBOPEN_DIRECT, &info.m_hdb));    

    IFFAILED_EXIT(UpdateComponentTable(info));
    if (info.m_fFusionWin32Policy == TRUE)
    {
        IFFAILED_EXIT(ImportTablesIfNeeded(info));
        IFFAILED_EXIT(AddEntryIntoDB(info));
    }else
    {
        printf("This package does contain FusionWin32 Policy, use the original msi for installation!");
    }
    
Exit:

    if (info.m_hdb != NULL)
    {   
        if ( SUCCEEDED(hr))
            MsiDatabaseCommit(info.m_hdb);
        MsiCloseHandle(info.m_hdb);
    }

    return hr;
}


extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    HRESULT         hr = S_OK;

    if ((argc < 3) && ((argc % 2) != 1))
    {
        PrintUsage(argv[0]);
        hr = E_INVALIDARG;
        goto Exit;
    }

    //
    // set SourcePath and Destination Path of the package
    //
    IFFAILED_EXIT(ParseInputParameter(argv[0], argc-1 , argv+1, ginfo));
    
    //    
    //   - CustomAction table : one entry for CA
    //   - Binary table : containing the binary stream of this dll
    //   - InstallExecuteSequence : add one entry for CA
    //   - add SourceDir into Property Table
    //   - add ResolveSource into InstallExecuteSequence Table
    //
    IFFAILED_EXIT(GenerateTestMsiForFusionPolicyInstallOnXPClient(ginfo));

#ifdef CA_TEST_TEST
    //
    // install this msi
    //
    if (ginfo.m_fFusionWin32Policy)
        MsiInstallProduct(ginfo.m_sbDestinationMsi, NULL);
        
#endif
    
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\common\idlib.cpp ===
#include "id.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\ca_migrate\ca_migrate.cpp ===
#include "stdinc.h"
#include "macros.h"
#include "common.h"
#include "idp.h"
#include "sxsutil.h"

#include "fusionbuffer.h"
#include "fusionheap.h"

#define CA_MIGRATE_ASM_CACHE_DIR        L"%windir%\\asmcache\\"

HRESULT CA_Migrate_RemoveAssemblyFromAsmCache(CStringBuffer &  fullpath)
{
    HRESULT hr = S_OK;

    IFFAILED_EXIT(ca_SxspDeleteDirectory(fullpath));
Exit:
    return hr;
}

HRESULT CA_Migrate_CopyFileToAsmCache(CA_ENM_ASSEMBLY_FILES_CALLBACK_INFO * pInfo)
{
    HRESULT hr = S_OK;
    CStringBuffer sbFileName;    
    CStringBuffer sbDestFileName;    
    PWSTR p = NULL;


    PARAMETER_CHECK_NTC(dwFlags == 0);
    PARAMETER_CHECK_NTC(pInfo != NULL);    

    IFFAILED_EXIT(MSI_GetSourceFileFullPathName(CA_FILEFULLPATHNAME_FILENAME_IN_FILE_TABLE, 
                        pInfo->hInstall, pInfo->pszComponentSourceDirectory, pszFileNameInFileTable, sbFileName, NULL));

    IFFALSE_EXIT(sbDestFileName.Win32Assign(pInfo->pszAssemblyInAsmCache, wcslen(pInfo->pszAssemblyInAsmCache))); // no trailing slash    
    p = wcsrchr(sbFileName, L'\\');
    INTERNAL_ERROR_CHECK_NTC(p != NULL);
    
    IFFALSE_EXIT(sbDestFileName.Win32Append(p, wcslen(p)));
    IFFALSE_EXIT(CopyFileW(sbFileName, sbDestFileName, FALSE));

Exit:
    return hr;
}

HRESULT CA_Migrate_AddAssemblyIntoAsmCache(DWORD dwFlags, const CA_ENM_ASSEMBLY_FILES_CALLBACK_INFO * info)
{
    HRESULT hr = S_OK;    

    IFFAILED_EXIT(MSI_EnumComponentFiles(info, CA_Migrate_CopyFileToAsmCache));

Exit:
    return hr;
}

HRESULT GetXPInstalledDirectory(MSIHANDLE hInstall, PCWSTR pszComponentID, PWSTR pszAsmDir, DWORD cchbuf)
{    
    PMSIHANDLE hdb = NULL;
    HRESULT hr = S_OK;
    WCHAR sqlbuf[CA_MAX_BUF];    
    PMSIHANDLE hView = NULL;
    MSIHANDLE hRecord = NULL;
    
    WCHAR bufName[CA_MAX_BUF];
    DWORD cchName;
    WCHAR bufValue[CA_MAX_BUF];
    DWORD cchValue;
    BOOL fWin32, fWin32Policy;
    CStringBuffer sbPathBuffer;

    UINT iRet;

    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;

    PARAMETER_CHECK_NTC(hInstall != NULL);
    PARAMETER_CHECK_NTC((pszComponentID != NULL) && (pszAsmDir != NULL));

    hdb = MsiGetActiveDatabase(hInstall);

    INTERNAL_ERROR_CHECK_NTC( hdb != NULL);
    
    IFFALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &AssemblyIdentity, 0, NULL));
    swprintf(sqlbuf, L"SELECT Name, Value FROM MsiAssemblyName WHERE Component_='%s'", pszComponentID);

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, sqlbuf, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));

    for (;;)
    {
        //
        // for each entry in MsiAssembly Table
        //
        iRet = MsiViewFetch(hView, &hRecord);
        if (iRet == ERROR_NO_MORE_ITEMS)
            break;
        if (iRet != ERROR_SUCCESS )
            SET_HRERR_AND_EXIT(iRet);

        cchName = NUMBER_OF(bufName);
        cchValue = NUMBER_OF(bufValue);

        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 1, bufName, &cchName));
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 2, bufValue, &cchValue));

        Attribute.Flags = 0;        
        Attribute.NamespaceCch  = 0;
        Attribute.Namespace     = NULL;
        Attribute.NameCch       = cchName;
        Attribute.Name          = bufName;
        Attribute.ValueCch      = cchValue;
        Attribute.Value         = bufValue;

        IFFALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(0, AssemblyIdentity, &Attribute));
    }
    
    IFFALSE_EXIT(SxsHashAssemblyIdentity(0, AssemblyIdentity, NULL));

    //
    // generate the path, something like x86_ms-sxstest-sfp_75e377300ab7b886_1.0.0.0_en_04f354da
    //
    IFFAILED_EXIT(ca_SxspDetermineAssemblyType(AssemblyIdentity, fWin32, fWin32Policy));

    IFFAILED_EXIT(ca_SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | (fWin32Policy ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0),
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            NULL,
            0,
            AssemblyIdentity,
            sbPathBuffer));

    if (sbPathBuffer.Cch() > cchbuf)
    {
        SET_HRERR_AND_EXIT(ERROR_INSUFFICIENT_BUFFER);
    }

    wcscpy(pszAsmDir, sbPathBuffer);

Exit:
    SxsDestroyAssemblyIdentity(AssemblyIdentity);
    return hr;
}


//
// CA for Fusion Win32 Assembly installation on downlevel(only) :
//  copy files into %windir%\asmcache\textual-identity-of-this-assembly\
//

// In order to generate textual-assembly-name, 
// be sure to put this CustomAction after MsiAssemblyName table is filled
//

HRESULT __stdcall CA_MigrateDll_Callback(DWORD dwFlags, MSIHANDLE hInstall, PCWSTR  pszComponentID, PCWSTR  pszManifetFileID)
{
    HRESULT hr = S_OK;
    WCHAR buf[MAX_PATH];
    DWORD cchbuf = NUMBER_OF(buf);
    CStringBuffer fullpath;  
    DWORD dwAttrib;
    enum CA_MIGRATION_MSI_INSTALL_MODE fMode;
    PMSIHANDLE hdb = NULL;

    PARAMETER_CHECK_NTC(dwFlags == 0);
    PARAMETER_CHECK_NTC(hInstall != NULL);    
    PARAMETER_CHECK_NTC(pszComponentID != NULL);
    PARAMETER_CHECK_NTC(pszManifetFileID != NULL);

    hdb = MsiGetActiveDatabase(hInstall);
    INTERNAL_ERROR_CHECK_NTC(hdb != NULL);
   
    UINT iret = ExpandEnvironmentStringsW(CA_MIGRATE_ASM_CACHE_DIR, buf, NUMBER_OF(buf));
    if (( iret == 0 ) || (iret > NUMBER_OF(buf)))
    {
        SET_HRERR_AND_EXIT(::GetLastError());
    }

    IFFALSE_EXIT(fullpath.Win32Assign(buf, wcslen(buf)));
    dwAttrib = GetFileAttributesW(fullpath);
    if ( dwAttrib == DWORD(-1) )    
    {
        IFFALSE_EXIT(CreateDirectoryW(fullpath, NULL));
    }else       
    {
        ASSERT_NTC(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
        INTERNAL_ERROR_CHECK_NTC((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != 0);
    }
    
    //
    // based on Attributes&Value in MsiAssemblyName Table to generate "x86_assemblyName_6595b64144ccf1df_6.0.0.0_x-ww_98a51133"
    //
    IFFAILED_EXIT(GetXPInstalledDirectory(hInstall, pszComponentID, buf, cchbuf));
    IFFALSE_EXIT(fullpath.Win32Append(buf, wcslen(buf)));

    DWORD dwAttribs = GetFileAttributesW(fullpath);

    IFFAILED_EXIT(MSI_GetInstallerState(hInstall, fMode));

    if ( fMode == eRemoveProduct)
    {
        ASSERT_NTC((dwAttribs != 0) && (dwAttribs & FILE_ATTRIBUTE_DIRECTORY));         
        IFFAILED_EXIT(CA_Migrate_RemoveAssemblyFromAsmCache(fullpath));
    }else
    {
        CA_ENM_ASSEMBLY_FILES_CALLBACK_INFO info ; 
        ZeroMemory(&info, sizeof(info));

        hdb = MsiGetActiveDatabase(hInstall);
        IFFAILED_EXIT(MSI_GetComponentSourceDirectory(hInstall, pszComponentID, buf, cchbuf));
        info.pszAssemblyInAsmCache = fullpath;
        info.pszComponentID = pszComponentID;
        info.pszComponentSourceDirectory = buf;
        info.hInstall = hInstall;

        IFFALSE_EXIT(CreateDirectoryW(fullpath, NULL));
        IFFAILED_EXIT(CA_Migrate_AddAssemblyIntoAsmCache(0, &info));
    }

Exit:
    return hr;
}


HRESULT __stdcall CustomAction_CopyFusionWin32AsmIntoAsmCache(MSIHANDLE hInstall)
{
    HRESULT hr = S_OK;    

    PMSIHANDLE hdb = NULL;
    PMSIHANDLE hView = NULL;
    MSIHANDLE  hRecord = NULL;   

#if DBG
    MessageBoxA(NULL, "Enjoy the Debug", "ca_migrate", MB_OK);
#endif
    
    hdb = MsiGetActiveDatabase(hInstall);
    if ( hdb == 0)
        SETFAIL_AND_EXIT;

    IFFAILED_EXIT(MSI_EnumWinFuseAssembly(0, hInstall, CA_MigrateDll_Callback));

Exit:
    return hr;
}

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  
  DWORD fdwReason,     
  LPVOID lpvReserved   
)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        FusionpInitializeHeap(NULL);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\common\sources.inc ===
!include $(PROJECT_ROOT)\win32\fusion\msi\msi.inc

TARGETTYPE=LIBRARY
TARGETNAME=msi_common
TARGETPATH=$(FUSION_MSI_LIB_PATH)\obj

USE_CRTDLL=1
USE_NATIVE_EH=1

INCLUDES= \
 $(FUSION_MSI_INC_PATH); \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\utils; \
 $(FUSION_INC_PATH);\
 $(INCLUDES);\
 $(PROJECT_ROOT)\ntdll; \
 $(PROJECT_ROOT)\ntos\inc; \
 $(PROJECT_ROOT)\ntos\rtl; \

SOURCES=\
  msidb.cpp \
  db.cpp \
  sxsutil.cpp \
  idlib.cpp \
  utillib.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\common\db.cpp ===
#include "stdinc.h"
#include "macros.h"

#include <msi.h>
#include <msiquery.h>

#include "common.h"

static PWSTR s_InsertTableSQLTemporary[] = 
{
    INSERT_DIRECTORY L"TEMPORARY",
    INSERT_CREATEFOLDER  L"TEMPORARY",
    INSERT_REGISTRY L"TEMPORARY",
    INSERT_DUPLICATEFILE  L"TEMPORARY",
    INSERT_COMPONENT  L"TEMPORARY"
};

HRESULT ExecuteInsertTableSQL(DWORD dwFlags, const MSIHANDLE & hdb, DWORD tableIndex, UINT cRecords, ...)
{
    PMSIHANDLE          hView = NULL;
    PMSIHANDLE          hRecord = NULL;   
    PCWSTR              pwszRecord = NULL;
    va_list             ap;
    HRESULT             hr = S_OK;    
    PWSTR               pwszSQL = NULL;

    PARAMETER_CHECK_NTC(dwFlags == TEMPORARY_DB_OPT);
    pwszSQL = s_InsertTableSQLTemporary[tableIndex];    


     hRecord = ::MsiCreateRecord(cRecords);

    if (hRecord == NULL)
        SETFAIL_AND_EXIT;

    //
    // get parameters
    //
    va_start(ap, cRecords);

    for (DWORD i=0; i<cRecords; i++)
    {
        pwszRecord = va_arg(ap, PCWSTR);

        //
        // set integrater
        //
        if ((tableIndex == OPT_REGISTRY) && (i == 1))
        {
            UINT x = _wtoi(pwszRecord);
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetInteger(hRecord, i+1, x));
        }
        else
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiRecordSetStringW(hRecord, i+1, pwszRecord));
    }
    
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, pwszSQL, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, hRecord));

Exit:
    va_end(ap);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\common\sxsutil.cpp ===
#include "stdinc.h"
#include "macros.h"

#include "util.h"
#include "fusionbuffer.h"
#include "fusionhandle.h"
#include "idp.h"
#include "sxsid.h"
#include "sxsutil.h"

#undef FUSION_DEBUG_HEAP

#define ULONG_STRING_LENGTH                                     8
#define ULONG_STRING_FORMAT                                     L"%08lx"
#define MANIFEST_ROOT_DIRECTORY_NAME                            L"Manifests"
#define POLICY_ROOT_DIRECTORY_NAME                              L"Policies"
#define ASSEMBLY_LONGEST_MANIFEST_FILE_NAME_SUFFIX              L".Manifest"
#define ASSEMBLY_POLICY_FILE_NAME_SUFFIX                        L".Policy"
#define ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX                      L".Manifest"

#define ASSEMBLY_TYPE_WIN32                                     L"win32"
#define ASSEMBLY_TYPE_WIN32_CCH                                 (NUMBER_OF(ASSEMBLY_TYPE_WIN32) - 1)

#define ASSEMBLY_TYPE_WIN32_POLICY                              L"win32-policy"
#define ASSEMBLY_TYPE_WIN32_POLICY_CCH                          (NUMBER_OF(ASSEMBLY_TYPE_WIN32_POLICY) - 1)
//
// functions copied from sxs.dll
//
//

extern BOOL
SxspGetAssemblyIdentityAttributeValue(
    DWORD Flags,
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference,
    OUT PCWSTR *StringOut,
    OUT SIZE_T *CchOut OPTIONAL
    );

///////////////////////////////////////////////////////////////////////////////
// function about delete a non-empty directory recursively
///////////////////////////////////////////////////////////////////////////////
static VOID
SxspDeleteDirectoryHelper(
    CStringBuffer &dir,
    WIN32_FIND_DATAW &wfd,
    DWORD &dwFirstError
    )
{
    //
    // the reason to add this call here is that if installation ends successfully, the directory
    // would be 
    //    C:\WINDOWS\WINSXS\INSTALLTEMP\15349016
    //                                      +---Manifests
    //
    // and they are "empty" directories (no files). Manifests is a SH dir so set it to be 
    // FILE_ATTRIBUTE_NORMAL be more efficient.
    //
    //                 

    SetFileAttributesW(dir, FILE_ATTRIBUTE_NORMAL);
    if (RemoveDirectoryW(dir)) // empty dir
        return;        

    //
    // this is the *only* "valid" reason for DeleteDirectory fail
    // but I am not sure about "only"
    //
    DWORD dwLastError = ::GetLastError(); 
    if ( dwLastError != ERROR_DIR_NOT_EMPTY)
    {
        if (dwFirstError == 0)
            dwFirstError = dwLastError;
        return;
    }

    const static WCHAR SlashStar[] = L"\\*";
    SIZE_T length = dir.Cch();
    CFindFile findFile;

    if (!dir.Win32Append(SlashStar, NUMBER_OF(SlashStar) - 1))
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::GetLastError();
        goto Exit;
    }

    if (!findFile.Win32FindFirstFile(dir, &wfd))
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::GetLastError();
        goto Exit;
    }

    do
    {
        if (FusionpIsDotOrDotDot(wfd.cFileName))
            continue;

        DWORD dwFileAttributes = wfd.dwFileAttributes;

        // Trim back to the slash...
        dir.Left(length + 1);

        if (dir.Win32Append(wfd.cFileName, ::wcslen(wfd.cFileName)))
        {
            if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // recurse
                SxspDeleteDirectoryHelper(dir, wfd, dwFirstError); 
            }
            else
            {
                if (!DeleteFileW(dir))
                {
                    SetFileAttributesW(dir, FILE_ATTRIBUTE_NORMAL);
                    if (!DeleteFileW(dir))
                    {
                        if (dwFirstError == NO_ERROR)
                        {
                            //
                            // continue even in delete file ( delete files as much as possible)
                            // and record the errorCode for first failure
                            //
                            dwFirstError = ::GetLastError();
                        }
                    }
                }
            }
        }
    } while (::FindNextFileW(findFile, &wfd));
    if (::GetLastError() != ERROR_NO_MORE_FILES)
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::GetLastError();
    }
Exit:
    if (!findFile.Win32Close()) // otherwise RemoveDirectory fails
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::GetLastError();

    dir.Left(length);

    if (!RemoveDirectoryW(dir)) // the dir must be empty and NORMAL_ATTRIBUTE : ready to delete
    {
        if (dwFirstError == NO_ERROR)
            dwFirstError = ::GetLastError();
    }
}

/*-----------------------------------------------------------------------------
delete a directory recursively, continues upon errors, but returns
FALSE if there were any.
-----------------------------------------------------------------------------*/
HRESULT
ca_SxspDeleteDirectory(
    const CStringBuffer &dir
    )
{
    HRESULT hr = S_OK;    

    CStringBuffer mutableDir;

    WIN32_FIND_DATAW wfd = {0};
    DWORD dwFirstError = ERROR_SUCCESS;

    IFFALSE_EXIT(mutableDir.Win32Assign(dir));

    IFFALSE_EXIT(mutableDir.Win32RemoveTrailingPathSeparators());

    ::SxspDeleteDirectoryHelper(
        mutableDir,
        wfd,
        dwFirstError);

    //
    // Set wFirstError to Teb->LastWin32Error
    //
    if (dwFirstError != ERROR_SUCCESS)
        goto Exit;
    

Exit:
    return hr;
}
///////////////////////////////////////////////////////////////////////////////
// function about assembly Identity
///////////////////////////////////////////////////////////////////////////////
HRESULT 
ca_SxspFormatULONG(
    ULONG ul,
    SIZE_T CchBuffer,
    WCHAR Buffer[],
    SIZE_T *CchWrittenOrRequired
    )
{
    HRESULT hr = S_OK;    
    int cch;

    if (CchWrittenOrRequired != NULL)
        *CchWrittenOrRequired = 0;

    PARAMETER_CHECK_NTC(Buffer != NULL);

    if (CchBuffer < (ULONG_STRING_LENGTH + 1))
    {
        if (CchWrittenOrRequired != NULL)
            *CchWrittenOrRequired = ULONG_STRING_LENGTH + 1;

        SET_HRERR_AND_EXIT(ERROR_INSUFFICIENT_BUFFER);
    }

    cch = _snwprintf(Buffer, CchBuffer, ULONG_STRING_FORMAT, ul);
    INTERNAL_ERROR_CHECK_NTC(cch > 0);

    if (CchWrittenOrRequired != NULL)
        *CchWrittenOrRequired = cch;

Exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// function about assembly Identity
///////////////////////////////////////////////////////////////////////////////
#define ASSEMBLY_NAME_VALID_SPECIAL_CHARACTERS  L".-"
#define ASSEMBLY_NAME_PRIM_MAX_LENGTH           64
#define ASSEMBLY_NAME_VALID_SEPARATORS          L"."
#define ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH     2
#define ASSEMBLY_NAME_TRIM_INDICATOR            L".."
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE L"no-public-key"
    
BOOL
IsValidAssemblyNameCharacter(WCHAR ch)
{
    if (((ch >= L'A') && (ch <= L'Z')) ||
         ((ch >= L'a') && (ch <= L'z')) ||
         ((ch >= L'0') && (ch <= L'9')) ||
         (wcschr(ASSEMBLY_NAME_VALID_SPECIAL_CHARACTERS, ch)!= NULL))
    {
        return TRUE;
    } else
        return FALSE;
/*
    if (wcschr(ASSEMBLY_NAME_VALID_SPECIAL_CHARACTERS, ch))
        return FALSE;
    else
        return TRUE;
*/
}

HRESULT ca_SxspGenerateAssemblyNamePrimeFromName(
    PCWSTR pszAssemblyName,
    SIZE_T CchAssemblyName,
    CBaseStringBuffer *Buffer
    )
{
    HRESULT hr = S_OK;
    
    PWSTR pStart = NULL, pEnd = NULL;
    PWSTR qEnd = NULL, pszBuffer = NULL;
    ULONG i, j, len, ulSpaceLeft;
    ULONG cch;
    PWSTR pLeftEnd = NULL, pRightStart = NULL, PureNameEnd = NULL, PureNameStart = NULL;
    CStringBuffer buffTemp;
    CStringBufferAccessor accessor;

    PARAMETER_CHECK_NTC(pszAssemblyName != NULL);
    PARAMETER_CHECK_NTC(Buffer != NULL);

    // See how many characters we need max in the temporary buffer.
    cch = 0;

    for (i=0; i<CchAssemblyName; i++)
    {
        if (::IsValidAssemblyNameCharacter(pszAssemblyName[i]))
            cch++;
    }

    IFFALSE_EXIT(buffTemp.Win32ResizeBuffer(cch + 1, eDoNotPreserveBufferContents));

    accessor.Attach(&buffTemp);

    pszBuffer = accessor.GetBufferPtr();

    j = 0;
    for (i=0; i<CchAssemblyName; i++)
    {
        if (::IsValidAssemblyNameCharacter(pszAssemblyName[i]))
        {
            pszBuffer[j] = pszAssemblyName[i];
            j++;
        }
    }

    ASSERT_NTC(j == cch);

    pszBuffer[j] = L'\0';

    // if the name is not too long, just return ;
    if (j < ASSEMBLY_NAME_PRIM_MAX_LENGTH)
    { // less or equal 64
        IFFALSE_EXIT(Buffer->Win32Assign(pszBuffer, cch));
    }
    else
    {
        // name is too long, have to trim a little bit
        ulSpaceLeft = ASSEMBLY_NAME_PRIM_MAX_LENGTH;

        PureNameStart = pszBuffer;
        PureNameEnd = pszBuffer + j;
        pLeftEnd = PureNameStart;
        pRightStart = PureNameEnd;

        while (PureNameStart < PureNameEnd)
        {
            // left end
            pStart = PureNameStart;
            i = 0;
            while ((wcschr(ASSEMBLY_NAME_VALID_SEPARATORS, pStart[i]) == 0) && (pStart+i != pRightStart)) // not a separator character
                i++;

            pEnd = pStart + i ;
            len = i;  // it should be length of WCHAR! not BYTE!!!

            if (len >= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH)  {// because we use ".." if trim happen
                pLeftEnd += (ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH);
                break;
            }
            ulSpaceLeft -=  len;
            pLeftEnd = pEnd; // "abc.xxxxxxx" pointing to "c"

            // right end
            qEnd = PureNameEnd;
            i = 0 ;
            while ((qEnd+i != pLeftEnd) && (wcschr(ASSEMBLY_NAME_VALID_SEPARATORS, qEnd[i]) == 0))
                i--;

            len = 0 - i;
            if (len >= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH)  {// because we use ".." if trim happen
                pRightStart -= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH;
                break;
            }
            ulSpaceLeft -=  len;
            PureNameStart = pLeftEnd + 1;
            PureNameEnd = pRightStart - 1;
        } // end of while

        IFFALSE_EXIT(Buffer->Win32Assign(pszBuffer, pLeftEnd-pszBuffer));
        IFFALSE_EXIT(Buffer->Win32Append(ASSEMBLY_NAME_TRIM_INDICATOR, NUMBER_OF(ASSEMBLY_NAME_TRIM_INDICATOR) - 1));
        IFFALSE_EXIT(Buffer->Win32Append(pRightStart, ::wcslen(pRightStart)));  // till end of the buffer
    }

Exit:

    return hr;
}



HRESULT 
ca_SxspGenerateSxsPath(
    IN DWORD Flags,
    IN ULONG PathType,
    IN const WCHAR *AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT CBaseStringBuffer &PathBuffer
    )
{
    HRESULT hr = S_OK;

    SIZE_T  cch = 0;
    PCWSTR  pszAssemblyName=NULL, pszVersion=NULL, pszProcessorArchitecture=NULL, pszLanguage=NULL, pszPolicyFileNameWithoutExt = NULL;
    PCWSTR  pszAssemblyStrongName=NULL;
    SIZE_T  AssemblyNameCch = 0, AssemblyStrongNameCch=0, VersionCch=0, ProcessorArchitectureCch=0, LanguageCch=0;
    SIZE_T  PolicyFileNameWithoutExtCch=0;
    BOOL    fNeedSlashAfterRoot = FALSE;
    ULONG   IdentityHash;
    BOOL    fOmitRoot     = ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT) != 0);
    BOOL    fPartialPath  = ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH) != 0);

    WCHAR HashBuffer[ULONG_STRING_LENGTH + 1];
    SIZE_T  HashBufferCch;

    CSmallStringBuffer NamePrimeBuffer;

#if DBG_SXS
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: Entered %s()\n"
        "   Flags = 0x%08lx\n"
        "   AssemblyRootDirectory = %p\n"
        "   AssemblyRootDirectoryCch = %lu\n"
        "   PathBuffer = %p\n",
        __FUNCTION__,
        Flags,
        AssemblyRootDirectory,
        AssemblyRootDirectoryCch,
        &PathBuffer);
#endif // DBG_SXS

    PARAMETER_CHECK_NTC(
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY) ||
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ||
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY));
    PARAMETER_CHECK_NTC(pAssemblyIdentity != NULL);
    PARAMETER_CHECK_NTC((Flags & ~(SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION | SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH)) == 0);
    // Not supplying the assembly root is only legal if you're asking for it to be left out...
    PARAMETER_CHECK_NTC((AssemblyRootDirectoryCch != 0) || (Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT));

    // You can't combine SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH with anything else...
    PARAMETER_CHECK_NTC(
        ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH) == 0) ||
        ((Flags & ~(SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH)) == 0));

    // get AssemblyName
    IFFALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, pAssemblyIdentity, &s_IdentityAttribute_name, &pszAssemblyName, &AssemblyNameCch));
    INTERNAL_ERROR_CHECK_NTC((pszAssemblyName != NULL) && (AssemblyNameCch != 0));

    // get AssemblyName' based on AssemblyName
    IFFAILED_EXIT(ca_SxspGenerateAssemblyNamePrimeFromName(pszAssemblyName, AssemblyNameCch, &NamePrimeBuffer));

    // get Assembly Version
    IFFALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
          SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, // for policy_lookup, no version is used
          pAssemblyIdentity,
          &s_IdentityAttribute_version,
          &pszVersion,
          &VersionCch));
    if ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION) || (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY))
    {
        // for policy file, version of the policy file is used as policy filename
        pszPolicyFileNameWithoutExt = pszVersion;
        PolicyFileNameWithoutExtCch = VersionCch;
        pszVersion = NULL;
        VersionCch = 0;
    }
    else
    {
        PARAMETER_CHECK_NTC((pszVersion != NULL) && (VersionCch != 0));
    }

    // get Assembly Langage
    IFFALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pAssemblyIdentity,
            &s_IdentityAttribute_language,
            &pszLanguage,
            &LanguageCch));
    if (pszLanguage == NULL)
    {
        pszLanguage = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE;
        LanguageCch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE) - 1;
    }

    // get Assembly ProcessorArchitecture
    IFFALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pAssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            &pszProcessorArchitecture,
            &ProcessorArchitectureCch));
    if (pszProcessorArchitecture == NULL)
    {
        pszProcessorArchitecture = L"data";
        ProcessorArchitectureCch = 4;
    }

    // get Assembly StrongName
    IFFALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pAssemblyIdentity,
            &s_IdentityAttribute_publicKeyToken,
            &pszAssemblyStrongName,
            &AssemblyStrongNameCch));
    if (pszAssemblyStrongName == NULL)
    {
        pszAssemblyStrongName = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE;
        AssemblyStrongNameCch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1;
    }

    //get Assembly Hash String
    if ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY) || (Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION))
    {
        IFFALSE_EXIT(::SxspHashAssemblyIdentityForPolicy(0, pAssemblyIdentity, IdentityHash));
    }
    else
    {
        IFFALSE_EXIT(::SxsHashAssemblyIdentity(0, pAssemblyIdentity, &IdentityHash));
    }

    IFFAILED_EXIT(ca_SxspFormatULONG(IdentityHash, NUMBER_OF(HashBuffer), HashBuffer, &HashBufferCch));
    INTERNAL_ERROR_CHECK_NTC(HashBufferCch == ULONG_STRING_LENGTH);

    if (!fOmitRoot)
    {
        // If the assembly root was not passed in, get it.
        fNeedSlashAfterRoot = (! ::FusionpIsPathSeparator(AssemblyRootDirectory[AssemblyRootDirectoryCch-1]));
    }
    else
    {
        // If we don't want to include the root, then don't account for it below...
        AssemblyRootDirectoryCch = 0;
        fNeedSlashAfterRoot = FALSE;
    }

    // this computation can be off by one or a few, it's an optimization
    // to pregrow a string buffer
    cch =
            AssemblyRootDirectoryCch +                                          // "C:\WINNT\WinSxS\"
            (fNeedSlashAfterRoot ? 1 : 0);

    switch (PathType)
    {
    case SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST:
        // Wacky parens and ... - 1) + 1) to reinforce that it's the number of
        // characters in the string not including the null and then an extra separator.
        cch += (NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1) + 1;
        break;

    case SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY:
        // Wacky parens and ... - 1) + 1) to reinforce that it's the number of
        // characters in the string not including the null and then an extra separator.
        cch += (NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1) + 1;
        break;
    }

    cch++;

    // fPartialPath means that we don't actually want to take the assembly's identity into
    // account; the caller just wants the path to the manifests or policies directories.
    if (!fPartialPath)
    {
        cch +=
                ProcessorArchitectureCch +                                      // "x86"
                1 +                                                             // "_"
                NamePrimeBuffer.Cch() +                                         // "FooBar"
                1 +                                                             // "_"
                AssemblyStrongNameCch +                                         // StrongName
                1 +                                                             // "_"
                VersionCch +                                                    // "5.6.2900.42"
                1 +                                                             // "_"
                LanguageCch +                                                   // "0409"
                1 +                                                             // "_"
                HashBufferCch;

        if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)
        {
            cch += NUMBER_OF(ASSEMBLY_LONGEST_MANIFEST_FILE_NAME_SUFFIX);        // ".manifest\0"
        }
        else if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)
        {
            // "_" has already reserve space for "\"
            cch += PolicyFileNameWithoutExtCch;
            cch += NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX);          // ".policy\0"
        }
        else {  // pathType must be SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY

            // if (!fOmitRoot)
            //    cch++;
            cch++; // trailing null character
        }
    }

    // We try to ensure that the buffer is big enough up front so that we don't have to do any
    // dynamic reallocation during the actual process.
    IFFALSE_EXIT(PathBuffer.Win32ResizeBuffer(cch, eDoNotPreserveBufferContents));

    // Note that since when GENERATE_ASSEMBLY_PATH_OMIT_ROOT is set, we force AssemblyRootDirectoryCch to zero
    // and fNeedSlashAfterRoot to FALSE, so the first two entries in this concatenation actually don't
    // contribute anything to the string constructed.
    if (fPartialPath)
    {
        IFFALSE_EXIT(PathBuffer.Win32AssignW(5,
                        AssemblyRootDirectory, static_cast<INT>(AssemblyRootDirectoryCch),  // "C:\WINNT\WINSXS"
                        L"\\", (fNeedSlashAfterRoot ? 1 : 0),                               // optional '\'
                        // manifests subdir
                        MANIFEST_ROOT_DIRECTORY_NAME, ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ? NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) -1 : 0), // "manifests"
                        // policies subdir
                        POLICY_ROOT_DIRECTORY_NAME, ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)? NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1 : 0),      // "policies"
                        L"\\", (((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) || (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)) ? 1 : 0)
                       ));                                                                 // optional '\'
    }
    else
    {
        //
        // create one of below
        //  (1) fully-qualified manifest filename,
        //          eg, [C:\WINNT\WinSxS\]Manifests\X86_DynamicDll_6595b64144ccf1df_2.0.0.0_en-us_2f433926.Manifest
        //  (2) fully-qualified policy filename,
        //          eg, [C:\WINNT\WinSxS\]Policies\x86_policy.1.0.DynamicDll_b54bc117ce08a1e8_en-us_d51541cb\1.1.0.0.cat
        //  (3) fully-qulified assembly name (w. or w/o a version)
        //          eg, [C:\WINNT\WinSxS\]x86_DynamicDll_6595b64144ccf1df_6.0.0.0_x-ww_ff9986d7
        //
        IFFALSE_EXIT(
            PathBuffer.Win32AssignW(17,
                AssemblyRootDirectory, static_cast<INT>(AssemblyRootDirectoryCch),  // "C:\WINNT\WINSXS"
                L"\\", (fNeedSlashAfterRoot ? 1 : 0),                               // optional '\'
                MANIFEST_ROOT_DIRECTORY_NAME, ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ? NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1 : 0),
                POLICY_ROOT_DIRECTORY_NAME,   ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY) ? NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1 : 0),
                L"\\", (((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) || (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)) ? 1 : 0),   // optional '\'
                pszProcessorArchitecture, static_cast<INT>(ProcessorArchitectureCch),
                L"_", 1,
                static_cast<PCWSTR>(NamePrimeBuffer), static_cast<INT>(NamePrimeBuffer.Cch()),
                L"_", 1,
                pszAssemblyStrongName, static_cast<INT>(AssemblyStrongNameCch),
                L"_", (VersionCch != 0) ? 1 : 0,
                pszVersion, static_cast<INT>(VersionCch),
                L"_", 1,
                pszLanguage, static_cast<INT>(LanguageCch),
                L"_", 1,
                static_cast<PCWSTR>(HashBuffer), static_cast<INT>(HashBufferCch),
                L"\\", ((fOmitRoot ||(PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)) ? 0 : 1)));

        if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)
            IFFALSE_EXIT(PathBuffer.Win32Append(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX, NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX) - 1));
        else if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY)
        {
            if ((pszPolicyFileNameWithoutExt != NULL) && (PolicyFileNameWithoutExtCch >0))
            {
                IFFALSE_EXIT(PathBuffer.Win32Append(pszPolicyFileNameWithoutExt, PolicyFileNameWithoutExtCch));
                IFFALSE_EXIT(PathBuffer.Win32Append(ASSEMBLY_POLICY_FILE_NAME_SUFFIX, NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX) - 1));
            }
        }
    }
    
Exit:
    return hr;
}


HRESULT 
ca_SxspDetermineAssemblyType(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    BOOL &fIsWin32,
    BOOL &fIsWin32Policy
    )
{
    HRESULT hr = S_OK;
    
    PCWSTR pcwszType = NULL;
    SIZE_T cchType = 0;

    fIsWin32 = FALSE;
    fIsWin32Policy = FALSE;

    PARAMETER_CHECK_NTC(pAssemblyIdentity != NULL);

    IFFALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pAssemblyIdentity,
            &s_IdentityAttribute_type,
            &pcwszType,
            &cchType));

    fIsWin32 = (::FusionpCompareStrings(pcwszType, cchType, ASSEMBLY_TYPE_WIN32, ASSEMBLY_TYPE_WIN32_CCH, false) == 0);
    if (!fIsWin32)
        fIsWin32Policy = (::FusionpCompareStrings(pcwszType, cchType, ASSEMBLY_TYPE_WIN32_POLICY, ASSEMBLY_TYPE_WIN32_POLICY_CCH, false) == 0);

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\inc\common.h ===
#ifndef FUSION_MSI_CA_COMMON_H
#define FUSION_MSI_CA_COMMON_H

#include <msi.h>
#include <msiquery.h>
#include "fusionbuffer.h"

#include "msidb.h"
#include "db.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\common\utillib.cpp ===
#include "fusionhashstring.cpp"
#include "fusionheap.cpp"
#include "debug.cpp"
#include "trace.cpp"
#include "isprint.c"
#include "checkSetupMode.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\common\msidb.cpp ===
#include "stdinc.h"
#include "macros.h"

#include <msi.h>
#include <msiquery.h>

#include "common.h"

HRESULT MSI_GetInstallerState(const MSIHANDLE & hInstall, enum CA_MIGRATION_MSI_INSTALL_MODE &fmode)
{
    WCHAR szbuf[MAX_PATH];
    DWORD cchbuf = NUMBER_OF(szbuf);
    HRESULT hr = S_OK;

    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiGetPropertyW(hInstall, L"REMOVE",  szbuf, &cchbuf));
    if (cchbuf != 0) // remove mode    
        fmode = eRemoveProduct;
    else
        fmode = eInstallProduct;
Exit:
    return hr;
}

VOID ResetCallbackInfo(CA_ENM_ASSEMBLY_CALLBACK_INFO &info)
{
    info.pszComponentID = NULL;
    info.pszAssemblyUniqueDir = NULL;
    info.pszDestFolderID = NULL;
    info.pszManifestFileID = NULL;
    info.pszFileName = NULL;
    info.pszFileID = NULL;

    return;
}


//
// basically, this func first lookup MsiAssembly Table,
//
HRESULT MSI_EnumWinFuseAssembly(DWORD dwFlags, const MSIHANDLE & hInstall, PCA_ENUM_FUSION_WIN32_ASSEMBLY_CALLBACK pfnCallback)
{
    HRESULT hr = S_OK;    
    WCHAR bufSQL[CA_MAX_BUF];
    WCHAR szManifestFileID[256];
    WCHAR szComponentID[128];
    UINT iRet;
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRecord = NULL;    
    DWORD cchManifestFileID, cchComponentID;
    BOOL fFusionWin32Component;
    BOOL fExist = FALSE;    
    CA_ENM_ASSEMBLY_CALLBACK_INFO info;

    MSIHANDLE hdb = NULL;

    PARAMETER_CHECK_NTC((dwFlags & ~(ENUM_ASSEMBLY_FLAG_CHECK_ASSEMBLY_ONLY | 
                                     ENUM_ASSEMBLY_FLAG_CHECK_POLICY_ONLY)) == 0);

    PARAMETER_CHECK_NTC(hInstall != NULL);
    PARAMETER_CHECK_NTC(pfnCallback != NULL);
    
    if (dwFlags == 0)                                   
        dwFlags = (ENUM_ASSEMBLY_FLAG_CHECK_ASSEMBLY_ONLY | ENUM_ASSEMBLY_FLAG_CHECK_POLICY_ONLY);

    hdb = MsiGetActiveDatabase(hInstall);
    INTERNAL_ERROR_CHECK_NTC(hdb != 0);

    IFFAILED_EXIT(MSI_IsTableExist(hdb, L"MsiAssembly", fExist));
    if ( fExist == FALSE)
        goto Exit;


    //
    // initialize info structure
    //
    ZeroMemory(&info, sizeof(info));
    IFFAILED_EXIT(MSI_IsTableExist(hdb, WIN32_ASSEMBLY_MIGRATE_TABLE, fExist));
    if (!fExist)
        info.dwFlags = CA_ENM_ASSEMBLY_CALLBACK_INFO_FLAG_IGNORE_MIGRATE_DENY_CHECK;

    info.hInstall = hInstall;
    info.hdb = hdb;

    //
    // Query Fusion Win32 Assembly, exclude private assembly
    //
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, ca_sqlQuery[CA_SQL_QUERY_MSIASSEMBLY], &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));

    for (;;)
    {
        //
        // reset info structure for component-related fields
        // except handles ( hInstall and hdb) and dwflags
        //
        ResetCallbackInfo(info);
        
        //
        // for each entry in MsiAssembly Table
        //        
        iRet = MsiViewFetch(hView, &hRecord);
        if (iRet == ERROR_NO_MORE_ITEMS)
            break;
        if (iRet != ERROR_SUCCESS )
            SET_HRERR_AND_EXIT(iRet);

        iRet = MsiRecordGetInteger(hRecord, 1);
        if ( iRet != MSI_FUSION_WIN32_ASSEMBLY)
            continue;

        //
        // get manifest-filename ID
        //
        cchManifestFileID = NUMBER_OF(szManifestFileID);
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetString(hRecord, 2, szManifestFileID, &cchManifestFileID));

        //
        // get componentID
        //
        cchComponentID = NUMBER_OF(szComponentID);
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetString(hRecord, 3, szComponentID, &cchComponentID));
        MsiCloseHandle(hRecord);

        //
        // check whether it is policy by searching MsiAssemblyName::type = "win32" or "win32-policy"
        //
        if (dwFlags != (ENUM_ASSEMBLY_FLAG_CHECK_ASSEMBLY_ONLY | ENUM_ASSEMBLY_FLAG_CHECK_POLICY_ONLY)) // otherwise, no check is needed
        {
            PMSIHANDLE local_hView = NULL;
            PMSIHANDLE local_hRecord = NULL;
            WCHAR bufType[64];
            DWORD cchType = NUMBER_OF(bufType);

            swprintf(bufSQL, ca_sqlQuery[CA_SQL_QUERY_MSIASSEMBLYNAME], szComponentID);
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, bufSQL, &local_hView));
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(local_hView, 0));
            IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewFetch(local_hView, &local_hRecord));
            IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetString(local_hRecord, 1, bufType, &cchType));            

            fFusionWin32Component = FALSE;
            if (dwFlags & ENUM_ASSEMBLY_FLAG_CHECK_ASSEMBLY_ONLY)
            {
                if (_wcsicmp(bufType, CA_FUSION_WIN32_ASSEMBLY_TYPE) == 0)
                    fFusionWin32Component = TRUE;
            }

            if (dwFlags & ENUM_ASSEMBLY_FLAG_CHECK_POLICY_ONLY)
            {
                if (_wcsicmp(bufType, CA_FUSION_WIN32_POLICY_TYPE) == 0)
                    fFusionWin32Component = TRUE;
            }

            if (fFusionWin32Component == FALSE)
                continue;
        }

        //
        // OK, we got ComponentID of a fusion-win32 component now; callback would have a show
        //
        ASSERT_NTC(szComponentID != NULL);
        ASSERT_NTC(szManifestFileID != NULL);
        
        info.pszComponentID = szComponentID;
        info.pszManifestFileID = szManifestFileID;        
        
        IFFAILED_EXIT(pfnCallback(&info));
    }

Exit:

    if(hdb != NULL)
        MsiCloseHandle(hdb);

    return hr;
}


HRESULT MSI_GetSourceFileFullPathName(DWORD dwFlags, const MSIHANDLE & hInstall, const MSIHANDLE & hdb, PCWSTR szComponentDirectory, PCWSTR pszFile, CStringBuffer &sbFileName, PCWSTR pszComponent)
{
    HRESULT hr = S_OK;
    WCHAR szFileNameInTable[CA_MAX_BUF];
    DWORD cchFileNameInTable = NUMBER_OF(szFileNameInTable);
    PWSTR pszFileNameInTable = NULL;
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRecord = NULL;
    WCHAR szDirectory[MAX_PATH];
    DWORD cchDirectory = NUMBER_OF(szDirectory);
    PWSTR pszComponentDirectory = NULL;    

    PARAMETER_CHECK_NTC((dwFlags == CA_FILEFULLPATHNAME_FILENAME_IN_FILE_TABLE) || (dwFlags == CA_FILEFULLPATHNAME_FILEID_IN_FILE_TABLE));
    PARAMETER_CHECK_NTC(hInstall != NULL);
    PARAMETER_CHECK_NTC(pszFile != NULL);
    PARAMETER_CHECK_NTC((szComponentDirectory != NULL) || ((hInstall != NULL) && (pszComponent != NULL)));
    PARAMETER_CHECK_NTC((dwFlags != CA_FILEFULLPATHNAME_FILEID_IN_FILE_TABLE) || (pszComponent != NULL));

    if ( dwFlags == CA_FILEFULLPATHNAME_FILEID_IN_FILE_TABLE)
    {
        
        WCHAR sqlbuf[CA_MAX_BUF];

        swprintf(sqlbuf, ca_sqlQuery[CA_SQL_QUERY_FILENAME_USING_FILEID], pszFile, pszComponent);
        IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, sqlbuf, &hView));
        IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiViewFetch(hView, &hRecord)); // this call should succeed otherwise fail
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetString(hRecord, 1, szFileNameInTable, &cchFileNameInTable));
        pszFileNameInTable = szFileNameInTable;
    }
    else
        pszFileNameInTable = const_cast<PWSTR>(pszFile);

    if (szComponentDirectory == NULL)
    {
         IFFAILED_EXIT(MSI_GetComponentSourceDirectory(hInstall, hdb, pszComponent, szDirectory, cchDirectory));
         pszComponentDirectory = szDirectory;
    }
    else
        pszComponentDirectory = const_cast<PWSTR>(szComponentDirectory);



    IFFALSE_EXIT(sbFileName.Win32Assign(pszComponentDirectory, wcslen(pszComponentDirectory)));
    IFFALSE_EXIT(sbFileName.Win32EnsureTrailingPathSeparator());

    PWSTR p = wcschr(pszFileNameInTable, L'|');
    if ( p != NULL)
    {
        p++; // skip '|'
        IFFALSE_EXIT(sbFileName.Win32Append(p, wcslen(p)));
    }else
    {
        WCHAR szLongPathName[MAX_PATH];
        CStringBuffer FullPathShortFileName;
        WCHAR szShortPathName[MAX_PATH];        
        DWORD ret = 0; 

        //
        // get short name of the directory
        //
        ret = GetShortPathNameW(sbFileName, szShortPathName, NUMBER_OF(szShortPathName));
        if (( ret == 0) || (ret > NUMBER_OF(szShortPathName)))
        {
            SET_HRERR_AND_EXIT(::GetLastError());
        }

        IFFALSE_EXIT(FullPathShortFileName.Win32Assign(szShortPathName, wcslen(szShortPathName)));
        IFFALSE_EXIT(FullPathShortFileName.Win32Append(pszFileNameInTable, wcslen(pszFileNameInTable)));

        ret = GetLongPathNameW(FullPathShortFileName, szLongPathName, NUMBER_OF(szLongPathName));
        if (( ret == 0) || (ret > NUMBER_OF(szLongPathName)))
        {
            SET_HRERR_AND_EXIT(::GetLastError());
        }               
        IFFALSE_EXIT(sbFileName.Win32Assign(szLongPathName, wcslen(szLongPathName)));
    }

Exit:
    return hr;
}

HRESULT MSI_GetComponentSourceDirectory(const MSIHANDLE & hInstall, const MSIHANDLE & hdb, PCWSTR pszComponentID, PWSTR szDirectory, DWORD cchDirectory)
{
    HRESULT hr = S_OK;
    WCHAR sqlBuf[CA_MAX_BUF];
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRecord = NULL;
    WCHAR szDirectoryID[128];
    DWORD cchDirectoryID = NUMBER_OF(szDirectoryID);    

    PARAMETER_CHECK_NTC(hInstall != NULL);
    PARAMETER_CHECK_NTC((pszComponentID != NULL) && (szDirectory!= NULL) && (cchDirectory != 0));

    swprintf(sqlBuf, ca_sqlQuery[CA_SQL_QUERY_COMPONENT], pszComponentID);
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, sqlBuf, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiViewFetch(hView, &hRecord)); // this call should succeed otherwise fail
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetString(hRecord, 1, szDirectoryID, &cchDirectoryID));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiGetSourcePath(hInstall, szDirectoryID, szDirectory, &cchDirectory));

Exit:    
    return hr;
}

HRESULT MSI_EnumComponentFiles(CA_ENM_ASSEMBLY_CALLBACK_INFO * info, PCA_ENUM_COMPONENT_FILES_CALLBACK pfnCallback)
{
    HRESULT hr = S_OK;
    WCHAR bufFileName[CA_MAX_BUF];
    WCHAR bufFileID[CA_MAX_BUF];
    WCHAR sqlbuf[CA_MAX_BUF];
    DWORD cchbuf;
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRecord = NULL;
    UINT iRet;    

    PARAMETER_CHECK_NTC((info != NULL) && (info->pszComponentID != (PCWSTR)NULL) && (info->hInstall != NULL));
    PARAMETER_CHECK_NTC(pfnCallback != NULL);    
    
    swprintf(sqlbuf, ca_sqlQuery[CA_SQL_QUERY_FILETABLE_USING_COMPONENTID], info->pszComponentID);
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(info->hdb, sqlbuf, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));

    for (;;)
    {
        //
        // for each entry in MsiAssembly Table
        //
        iRet = MsiViewFetch(hView, &hRecord);
        if (iRet == ERROR_NO_MORE_ITEMS)
            break;
        if (iRet != ERROR_SUCCESS )
            SET_HRERR_AND_EXIT(iRet);

        cchbuf = NUMBER_OF(bufFileID);
        bufFileID[0] = L'\0';
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 1, bufFileID, &cchbuf));

        cchbuf = NUMBER_OF(bufFileName);
        bufFileName[0] = L'\0';       
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 2, bufFileName, &cchbuf));
        
        info->pszFileName = bufFileName;
        info->pszFileID = bufFileID;
        IFFAILED_EXIT(pfnCallback(info));
    }
    
Exit:
    
    return hr; 
}

HRESULT MSI_IsTableExist(const MSIHANDLE & hdb, PCWSTR pszTableName, BOOL & fExist)
{
    HRESULT hr = S_OK;
    WCHAR sqlbuf[CA_MAX_BUF];
    PMSIHANDLE hView = NULL;
    PMSIHANDLE hRecord = NULL;
    DWORD iRet;

    PARAMETER_CHECK_NTC((hdb != NULL) && (pszTableName != NULL));
    fExist = FALSE;

    swprintf(sqlbuf, L"SELECT * FROM `_Tables` WHERE `Name`='%s'", pszTableName);
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, sqlbuf, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));
    iRet = MsiViewFetch(hView, &hRecord);
    if (iRet == ERROR_NO_MORE_ITEMS)
    {
        goto Exit;
    }
    else 
    if (iRet != ERROR_SUCCESS)
    {
        SET_HRERR_AND_EXIT(iRet);
    }
    fExist = TRUE;

Exit:

    return hr;
}

HRESULT Msi_CreateTableIfNotExist(const MSIHANDLE & hdb, PCWSTR pwszTableName, PCWSTR pwszTableSchema, BOOL & fExistAlready)
{
    HRESULT hr = S_OK;
    PMSIHANDLE hView = NULL;    

    PARAMETER_CHECK_NTC((pwszTableSchema != NULL) && (pwszTableName != NULL));
    fExistAlready = FALSE;

    IFFAILED_EXIT(MSI_IsTableExist(hdb, pwszTableName, fExistAlready));
    if (fExistAlready == TRUE)    
        goto Exit;

    //
    // create the table
    //
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, pwszTableSchema, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));
Exit:
    return hr;
}


typedef enum _FUSION_MSI_OS_VERSION
{
    E_OS_UNKNOWN,
    E_WIN95,
    E_WIN_ME,
    E_WIN_NT,
    E_WIN98,
    E_WIN2K,
    E_WHISTLER,
    E_WIN32_OTHERS
}FUSION_MSI_OS_VERSION;

typedef enum _FUSION_MSI_OS_TYPE
{
    E_PERSONAL,
    E_PROFESSIONAL,
    E_DATA_CENTER,
    E_STD_SERVER,
    E_ADV_SERVER,
    E_WORKSTATION,
    E_SERVER
}FUSION_MSI_OS_TYPE;

HRESULT GetOSVersion(FUSION_MSI_OS_VERSION & osv)
{
    HRESULT hr = S_OK;
    OSVERSIONINFO osvi;
    BOOL bOsVersionInfoEx;

    osv = E_OS_UNKNOWN;

    if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )
    {
      // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.

        osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            goto Exit;
        }       
    }

    switch (osvi.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_NT:
            if ( osvi.dwMajorVersion <= 4 )
                osv = E_WIN_NT;
            else if ( osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0 )
                osv = E_WIN2K;           
            else if ( osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1 )
                osv = E_WHISTLER;

        case VER_PLATFORM_WIN32_WINDOWS:
            if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)         
                osv = E_WIN95;
             else if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 10)         
                 osv = E_WIN98;
             else if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)
                 osv = E_WIN_ME;
             break;
        case VER_PLATFORM_WIN32s:
            osv = E_WIN32_OTHERS;         
            break;
    }

Exit:
    return hr;
}

BOOL IsDownlevel()
{
    FUSION_MSI_OS_VERSION osv = E_OS_UNKNOWN;

    if (SUCCEEDED(GetOSVersion(osv)))
    {
        return ((osv == E_WIN2K) || (osv == E_WIN98));
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\inc\db.h ===
#ifndef FUSION_MSI_DB_COMMON_H
#define FUSION_MSI_DB_COMMON_H

#define TEMPORARY_DB_OPT                        1

//
// constant
//
#define OPT_DIRECTORY                                           0
#define OPT_CREATEFOLDER                                        1
#define OPT_REGISTRY                                            2
#define OPT_DUPLICATEFILE                                       3
#define OPT_COMPONENT                                           4

#define NUMBER_OF_PARAM_TO_INSERT_TABLE_DIRECTORY               3
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_CREATEFOLDER            2
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_REGISTRY                4
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_DUPLICATEFILE           5
#define NUMBER_OF_PARAM_TO_INSERT_TABLE_COMPONENT               2

#define INSERT_DIRECTORY        L"INSERT INTO Directory (Directory, Directory_Parent, DefaultDir) VALUES (?, ?, ?) "
#define INSERT_CREATEFOLDER     L"INSERT INTO CreateFolder(Directory_, Component_) VALUES (?, ?) "
#define INSERT_REGISTRY         L"INSERT INTO Registry(Registry, Root, Key, Component_, Name, Value) VALUES (?, ?, ?, ?, '', '') "
#define INSERT_DUPLICATEFILE    L"INSERT INTO DuplicateFile(FileKey, Component_, File_, DestName, DestFolder) VALUES (?, ?, ?, ?, ?) "
#define INSERT_COMPONENT        L"INSERT INTO Component(Component, Directory_, ComponentId, Attributes, Condition, KeyPath) VALUES (?, ?, '' , '0', '', '')"

extern HRESULT ExecuteInsertTableSQL(DWORD dwFlags, const MSIHANDLE & hdb, DWORD tableIndex, UINT cRecords, ...);

#define MAKE_PCWSTR(x) PCWSTR(x)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\inc\stdinc.h ===
#ifndef FUSION_MSI_INC_STDINC_H
#define FUSION_MSI_INC_STDINC_H

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#include "fusionlastwin32error.h"
#include "fusionbuffer.h"

#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#pragma warning(disable: 4663)
#include <yvals.h>

#define UNICODE
#define _UNICODE
#include "yvals.h"
#pragma warning(disable:4127)
#pragma warning(disable:4663)
#pragma warning(disable:4100)
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#pragma warning(disable:4018) /* signed/unsigned mismatch */
#pragma warning(disable:4786) /* long symbols */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion from size_t to int */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\inc\macros.h ===
#ifndef FUSION_MSI_CA_INC_MACROS_H
#define FUSION_MSI_CA_INC_MACROS_H

#define SETFAIL_AND_EXIT  do { hr = E_FAIL; goto Exit;} while (0);

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x)/sizeof(x[0]))
#endif

#define SAFE_RELEASE_COMPOINTER(x) do {if (x != NULL) x->Release();} while(0)

#define IFFALSE_EXIT(x)     do {if (!(x)) {hr = HRESULT_FROM_WIN32(::GetLastError()); goto Exit;}} while(0)
#define IFFAILED_EXIT(x)    do {if ((hr = (x)) != ERROR_SUCCESS) goto Exit;} while(0)
#define IF_NOTSUCCESS_SET_HRERR_EXIT(x) do {UINT __t ; __t = (x); if (__t != ERROR_SUCCESS) {hr = HRESULT_FROM_WIN32(__t); goto Exit;}} while(0)
#define SET_HRERR_AND_EXIT(err) do { hr = HRESULT_FROM_WIN32(err); goto Exit;} while (0)

#define PARAMETER_CHECK_NTC(x) do { if (!(x)) { hr = E_INVALIDARG; goto Exit;}} while (0) 

#define INTERNAL_ERROR_CHECK_NTC(x) do { if (!(x)) { hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); goto Exit;}} while (0) 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\inc\msidb.h ===
#ifndef FUSION_MSI_DB_H
#define FUSION_MSI_DB_H

#define WIN32_ASSEMBLY_MIGRATE_TABLE L"MsiAssemblyMigrate"

#define USING_FILEID_IN_FILETABLE_AS_CALLBACK_FUNC_INPUT        1
#define USING_FILENAME_IN_FILETABLE_AS_CALLBACK_FUNC_INPUT      2

enum CA_MIGRATION_MSI_INSTALL_MODE
{
    eInstallProduct,
    eRemoveProduct
};

typedef struct _ca_enm_assembly_callback_info
{
    DWORD  dwFlags;
    MSIHANDLE hInstall;
    MSIHANDLE hdb;

    PCWSTR pszComponentID;
    PCWSTR pszAssemblyUniqueDir;
    PCWSTR pszDestFolderID;
    PCWSTR pszManifestFileID;
    PCWSTR pszFileName;
    PCWSTR pszFileID;
}CA_ENM_ASSEMBLY_CALLBACK_INFO;

#define CA_ENM_ASSEMBLY_CALLBACK_INFO_FLAG_IGNORE_MIGRATE_DENY_CHECK 0x01

typedef HRESULT (__stdcall * PCA_ENUM_COMPONENT_FILES_CALLBACK)(
    const CA_ENM_ASSEMBLY_CALLBACK_INFO * info
    );

typedef HRESULT (__stdcall * PCA_ENUM_FUSION_WIN32_ASSEMBLY_CALLBACK)(    
    CA_ENM_ASSEMBLY_CALLBACK_INFO * info
    );

#define ENUM_ASSEMBLY_FLAG_CHECK_ASSEMBLY_ONLY                      0x01
#define ENUM_ASSEMBLY_FLAG_CHECK_POLICY_ONLY                        0x02

#define CA_SQL_QUERY_MSIASSEMBLYNAME                        0
#define CA_SQL_QUERY_MSIASSEMBLY                            1
#define CA_SQL_QUERY_COMPONENT                              2
#define CA_SQL_QUERY_FILENAME_USING_FILEID                  3
#define CA_SQL_QUERY_FILETABLE_USING_COMPONENTID            4
#define CA_SQL_QUERY_COMPONENT_FOR_COMPONENTGUID            5
#define CA_SQL_QUERY_DIRECTORY                              6

static PCWSTR ca_sqlQuery[]= 
{
    L"SELECT `Value` FROM `MsiAssemblyName` WHERE `Name`='type' AND `Component_`='%s'", 
    L"SELECT `Attributes`, `File_Manifest`, `Component_` FROM `MsiAssembly` WHERE `File_Application`=''",  // check whether it is a win32 assembly
    L"SELECT `Directory_` FROM `Component` WHERE `Component`='%s'",
    L"SELECT `FileName` FROM `File` WHERE `File`='%s' AND `Component_`='%s'",
    L"SELECT `File`, `FileName` FROM `File` WHERE `Component_`='%s'",
    L"SELECT `ComponentId` FROM `Component` WHERE `Component`='%s'",
    L"SELECT * FROM `Directory` WHERE `Directory`='%s'"
};

#define CA_FUSION_WIN32_POLICY_TYPE         L"win32-policy"
#define CA_FUSION_WIN32_ASSEMBLY_TYPE       L"win32"

#define MSI_FUSION_WIN32_ASSEMBLY           1
#define MSI_FUSION_URT_ASSEMBLY             0

#define CA_MAX_BUF  256

#define CA_FILEFULLPATHNAME_FILENAME_IN_FILE_TABLE      1
#define CA_FILEFULLPATHNAME_FILEID_IN_FILE_TABLE        2

extern HRESULT MSI_GetSourceFileFullPathName(DWORD, const MSIHANDLE &, const MSIHANDLE &, PCWSTR, PCWSTR, CStringBuffer &, PCWSTR);
extern HRESULT MSI_EnumWinFuseAssembly(DWORD, const MSIHANDLE &, PCA_ENUM_FUSION_WIN32_ASSEMBLY_CALLBACK);
extern HRESULT MSI_GetInstallerState(const MSIHANDLE &, enum CA_MIGRATION_MSI_INSTALL_MODE &);
extern HRESULT MSI_EnumComponentFiles(CA_ENM_ASSEMBLY_CALLBACK_INFO *, PCA_ENUM_COMPONENT_FILES_CALLBACK);
extern HRESULT MSI_GetComponentSourceDirectory(const MSIHANDLE &, const MSIHANDLE &, PCWSTR, PWSTR, DWORD);
extern HRESULT MSI_IsTableExist(const MSIHANDLE & hdb, PCWSTR pszTableName, BOOL & fExist);
extern HRESULT Msi_CreateTableIfNotExist(const MSIHANDLE & hdb, PCWSTR pwszTableName, PCWSTR pwszTableSchema, BOOL & fExistAlready);
extern BOOL IsDownlevel();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\inc\sxsutil.h ===
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_INVALID     (0)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST    (1)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY    (2)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY      (3)

#define SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT       (0x00000001)
#define SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH    (0x00000002)
#define SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION    (0x00000004)

extern HRESULT ca_SxspDeleteDirectory(
    const CStringBuffer &dir
    );

extern HRESULT ca_SxspGenerateSxsPath(
    IN DWORD Flags,
    IN ULONG PathType,
    IN const WCHAR *AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT CBaseStringBuffer &PathBuffer
    );

extern HRESULT ca_SxspDetermineAssemblyType(
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    BOOL &fIsWin32,
    BOOL &fIsWin32Policy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\inc\version.h ===
#include <ntverp.h>

#define rmj 2
#define rmm 0
#define rup VER_PRODUCTBUILD
#define rin VER_PRODUCTBUILD_QFE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\mig\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

FUSION_BUILD_TYPE=WIN2000
FUSION_BUILD_LEAF_DIRECTORY=win2000

!include $(PROJECT_ROOT)\win32\fusion\msi\msi.inc

MAJORCOMP=fusion
MINORCOMP=migrate

TARGETNAME=migrate
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=..\migrate.def
DLLENTRY=DllMain

INCLUDES= $(FUSION_MSI_INC_PATH);$(INCLUDES);$(INC_DIR);$(SDK_INC_PATH);$(RES_OBJDIR);$(BUILD_COMMONDIR)
BINPLACE_PLACEFILE=..\placefil.txt

TARGETLIBS= \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\kernel32.lib

USE_MSVCRT=1

SOURCES=..\migrate.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\mig\tests\tests.cpp ===
#include "windows.h"

typedef BOOL (WINAPI * P_MIGRATE_API)();

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    HRESULT         hr = S_OK;

    HMODULE hdll = LoadLibrary("..\\..\\..\\win2000\\obj\\i386\\migrate.dll");
    if (hdll == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    P_MIGRATE_API pfn = GetProcAddress(hdll, "MigrateMSIInstalledWin32Assembly");
    (*pfn)();

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\mig\migrate.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       migrate.cpp
//  xiaoyuw @ 2001/09
//
//--------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>

// migration DLL version information

typedef struct {    
    CHAR CompanyName[256];
    CHAR SupportNumber[256];
    CHAR SupportUrl[256];
    CHAR InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO; 

typedef struct {
    SIZE_T Size;
    PCSTR StaticProductIdentifier;
    UINT DllVersion;
    PINT CodePageArray;
    UINT SourceOs;
    UINT TargetOs;
    PCSTR * NeededFileList;
    PVENDORINFO VendorInfo;
} MIGRATIONINFOA, *PMIGRATIONINFOA;

typedef enum {

    OS_WINDOWS9X = 0,
    OS_WINDOWSNT4X = 1,
    OS_WINDOWS2000 = 2,
    OS_WINDOWSWHISTLER = 3

} OS_TYPES, *POS_TYPES;

PMIGRATIONINFOA g_MigrationInfo;

const char g_szProductId[] = "Microsoft MSI Migration DLL v2.0";
VENDORINFO g_VendorInfo = { "Microsoft", "", "", "" };

const static CHAR pszAsmCache[]  =  "%windir%\\MsiAsmCache";
const static WCHAR pwszAsmCache[]= L"%windir%\\MsiAsmCache\\*.*";

typedef HRESULT (__stdcall *LPDLLGETVERSION)(DLLVERSIONINFO *);

BOOL IsThereAssembliesForMigrate()
{
    TCHAR buf[MAX_PATH];
    DWORD cch;
    BOOL fAssemblyExist = FALSE;

    cch = ExpandEnvironmentStrings(pszAsmCache, buf, MAX_PATH);
    if (( cch == 0 ) || (cch > MAX_PATH))
    {
#if DBG
        MessageBoxA(NULL, "ExpandEnvironmentStrings return 0 or > MAX_PATH", "mig_Error", MB_OK);
#endif
        goto Exit;
    }
    DWORD attrib = GetFileAttributes(buf);
    if ((attrib == INVALID_FILE_ATTRIBUTES) || (!(attrib & FILE_ATTRIBUTE_DIRECTORY)))
    {
#if DBG
        MessageBoxA(NULL, "no MsiAsmCache directory ", "mig_info", MB_OK);
#endif
        goto Exit;
    }
  
    fAssemblyExist = TRUE;

Exit:
    return fAssemblyExist;

}

void DbgPrintMessageBox(PCSTR pszFunc)
{
#if DBG
    MessageBox(NULL, pszFunc, "migrate", MB_OK);
#endif 
}

void DbgPrintMessageBox(PCSTR formatStr, PWSTR para)
{
#if DBG
    CHAR str[3 * MAX_PATH];
    sprintf(str, formatStr, para);
    MessageBox(NULL, str, "migrate", MB_OK);
#endif 
}

void DbgPrintMessageBox(PCSTR formatStr, PWSTR para, DWORD dw)
{
#if DBG
    CHAR str[3 * MAX_PATH];
    sprintf(str, formatStr, para, dw);
    MessageBox(NULL, str, "migrate", MB_OK);
#endif 
}

#include "sxsapi.h"

BOOL IsDotOrDotDot(WCHAR cFileName[])
{
    if ((cFileName[0] == L'.') && (cFileName[1] == L'\0'))
        return TRUE;

    if ((cFileName[0] == L'.') && (cFileName[1] == L'.') && (cFileName[2] == L'\0'))
        return TRUE;
    
    return FALSE;
}

const char szRunOnceMsiAsmCacheName[] = "Cleanup Msi-Installed-Fusion-Win32-Assembly Migration";
const char szRunOnceMsiAsmCacheRegKey[]= "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
const char szRunOnceValueCommandLine[]="rundll32.exe sxs.dll,SxspRunDllDeleteDirectory %S";

LONG MigrateMSIInstalledWin32Assembly()
{
    LONG lResult = ERROR_SUCCESS;    
    HMODULE hSxs = NULL;
    PSXS_INSTALL_W pfnSxsInstallW = NULL;
    PSXS_BEGIN_ASSEMBLY_INSTALL pfnSxsBeginAssemblyInstall = NULL; 
    PSXS_END_ASSEMBLY_INSTALL pfnSxsEndAssemblyInstall = NULL;
    BOOL fSuccess = FALSE;
    PVOID SxsContext = NULL;

    WCHAR AsmDirInAsmCache[MAX_PATH];
    WCHAR Buf[MAX_PATH];
    DWORD cchBuf;    
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW finddata;

    SXS_INSTALLW InstallData = {sizeof(InstallData)};
    SXS_INSTALL_REFERENCEW InstallReference = {sizeof(InstallReference)};

    cchBuf= ExpandEnvironmentStringsW(pwszAsmCache, Buf, MAX_PATH); // including trailing NULL
    if ((cchBuf == 0 ) || (cchBuf > MAX_PATH))
    {            
        DbgPrintMessageBox("::Expand windir\\MsiAsmCache\\*.* return 0 or > MAX_PATH::");
        lResult = GetLastError();
        goto Exit;
    }

#ifdef MSI_MIG_TEST
    hSxs = ::LoadLibraryA("..\\..\\..\\..\\..\\dll\\whistler\\obj\\i386\\sxs.dll");
#else
    hSxs = ::LoadLibraryA("sxs.dll");
#endif
    if ((!hSxs) || (hSxs == INVALID_HANDLE_VALUE))
    {
        DbgPrintMessageBox("::Load Sxs.dll failed::");
        lResult = GetLastError();
        goto Exit;
    }

    pfnSxsInstallW = (PSXS_INSTALL_W)GetProcAddress(hSxs, SXS_INSTALL_W);
    pfnSxsBeginAssemblyInstall = (PSXS_BEGIN_ASSEMBLY_INSTALL)GetProcAddress(hSxs, SXS_BEGIN_ASSEMBLY_INSTALL);
    pfnSxsEndAssemblyInstall = (PSXS_END_ASSEMBLY_INSTALL)GetProcAddress(hSxs, SXS_END_ASSEMBLY_INSTALL);

    if ((pfnSxsInstallW == NULL) || (pfnSxsBeginAssemblyInstall == NULL) || (pfnSxsEndAssemblyInstall == NULL))
    {
        DbgPrintMessageBox("::Find SxsInstall APIs failed::");
        lResult = GetLastError();
        goto Exit;
    }

    //
    // !!!!! below is the code copied From base\ntsetup\syssetup\copy.c
    //
    
    //
    // we do not use INSTALL_RECURSIVELY because the name of directory and structures always like 
    // c:\WINNT\winsxs\x86_blahblah\x86_blahblah.man
    //
    if (!pfnSxsBeginAssemblyInstall(
        SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL
        | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY
        | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING | 
        SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY |
        SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE, // I have to add this flag for old sxs!SxsInstallW parameter check
        NULL,
        NULL, // callback context
        NULL, // impersonation callback
        NULL, // impersonation context
        &SxsContext
        )) 
    {
        DbgPrintMessageBox("::pfnSxsBeginAssemblyInstall failed::");
        lResult = GetLastError();

        goto Exit;
    }

    hFind = FindFirstFileW(Buf, &finddata);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        DbgPrintMessageBox("::FindFirstFileW for MsiAsmCache failed::");
        lResult = GetLastError();

        goto Exit;
    }
    while (1)    {
        if ((wcscmp(finddata.cFileName, L"..") == 0) || (wcscmp(finddata.cFileName, L".") == 0))
            goto GetNext;

        if (!(finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // if it is not a directory, ignore it
            goto GetNext;
        }

        // this must be a subdir of an asm, which is in the format of
        // %windir\MsiAsmCache\x86_ms-sxstest-simple_75e377300ab7b886_1.0.10.0_en_61E9D7DC,
        // otherwise, there is an error;
        // the following calculation is used to decide the directory name. it must be a very long filename but 
        // MAX_PATH should be fine; and since Buf contains "*.*", it should cover the trailing NULL and extra back-slash.
        if ((wcslen(Buf) + wcslen(finddata.cFileName)) > (sizeof(AsmDirInAsmCache) / sizeof(WCHAR)))
        {                       
            DbgPrintMessageBox("::filename %S under MsiAsmCache is too long, will be ignored::", finddata.cFileName);            
            goto GetNext;
        }

        wcscpy(AsmDirInAsmCache, Buf);
        AsmDirInAsmCache[wcslen(Buf) - wcslen(L"*.*")] = L'\0'; // contain a trailing NULL
        wcscat(AsmDirInAsmCache, finddata.cFileName);

        //
        // Set up the reference data to indicate that all of these are OS-installed
        // assemblies.
        //
        ZeroMemory(&InstallReference, sizeof(InstallReference));
        InstallReference.cbSize = sizeof(InstallReference);
        InstallReference.dwFlags = 0;
#ifdef MSI_MIG_TEST
        InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY;
#else
        InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL;
#endif

        //
        // Set up the structure to call off to the installer
        //
        memset(&InstallData, 0, sizeof(InstallData));
        InstallData.cbSize = sizeof(InstallData);
        InstallData.dwFlags =
            SXS_INSTALL_FLAG_REFERENCE_VALID |
            SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
            SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
            SXS_INSTALL_FLAG_CODEBASE_URL_VALID | 
            SXS_INSTALL_FLAG_FROM_DIRECTORY |
            SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE
            ;
        
        InstallData.lpReference = &InstallReference;
        InstallData.lpRefreshPrompt = L"migrated from downlevel, no source";
        InstallData.pvInstallCookie = SxsContext;
        InstallData.lpCodebaseURL = AsmDirInAsmCache;
        InstallData.lpManifestPath = AsmDirInAsmCache;

        fSuccess = pfnSxsInstallW(&InstallData);
        if (fSuccess == FALSE)
        {
            DbgPrintMessageBox("::pfnSxsInstallW failed for %S, ignore the error and just continue::", AsmDirInAsmCache);            
        }else
        {
            DbgPrintMessageBox("::pfnSxsInstallW succeed for %S, Great!!!::", AsmDirInAsmCache);
        }
GetNext:
         if ( FALSE == FindNextFileW(hFind, &finddata))
         {
             if ( GetLastError() == ERROR_NO_MORE_FILES)
                DbgPrintMessageBox("::FindNextFileW ends well ::");            
             else
                DbgPrintMessageBox("::FindNextFileW failed::");

            break;
         }else
         {
             DbgPrintMessageBox("::FindNextFileW find next file::");
         }

    }

    lResult = ERROR_SUCCESS;

    {
    //
    // set RunOnce Key to delete MsiAsmCache Directory
    //
        HKEY hk = NULL;     
        if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRunOnceMsiAsmCacheRegKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hk, NULL))    
        {
            // we do not care it success or fail, we could live with it
            CHAR buf[MAX_PATH * 2]; 
    
            sprintf(buf, szRunOnceValueCommandLine, Buf);

            if ( ERROR_SUCCESS != RegSetValueEx(hk, szRunOnceMsiAsmCacheName, 0, REG_SZ, (CONST BYTE *)buf, strlen(buf) + 1))
            {
                DbgPrintMessageBox("::SetRunOnceKey failed::");
            }
        }

        RegCloseKey(hk);
    }
    
    
Exit:
    if ( SxsContext != NULL)
    {
        pfnSxsEndAssemblyInstall(
                SxsContext,
                fSuccess ? SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT : SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT,
                NULL);
    }

    if ( hSxs != NULL)
        FreeLibrary(hSxs);

    if (hFind != INVALID_HANDLE_VALUE)
        CloseHandle(hFind);

    // return the result from the actual migration call
    return lResult;
}

///////////////////////////////////////////////////////////////////////
//
// API of WIN-NT MIGRATION Dll 
//
///////////////////////////////////////////////////////////////////////
LONG CALLBACK QueryMigrationInfoA(PMIGRATIONINFOA * VersionInfo)
{    
    
    DbgPrintMessageBox("in QueryMigrationInfo");

    if (IsThereAssembliesForMigrate() == FALSE)
    {
        return ERROR_NOT_INSTALLED; // no further migration
    }


    // only work for Win98 and win2k upgrade to winxp !!!
    if (VersionInfo != NULL)
    {
        if (g_MigrationInfo == NULL)
        {
            g_MigrationInfo = (PMIGRATIONINFOA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MIGRATIONINFOA));

            if (g_MigrationInfo == NULL)
                return ERROR_NOT_ENOUGH_MEMORY;

            g_MigrationInfo->Size = sizeof(MIGRATIONINFOA);
            g_MigrationInfo->StaticProductIdentifier = g_szProductId;
            g_MigrationInfo->DllVersion = 200;
            g_MigrationInfo->CodePageArray = NULL;
            g_MigrationInfo->SourceOs = OS_WINDOWS2000;
            g_MigrationInfo->TargetOs = OS_WINDOWSWHISTLER;
            g_MigrationInfo->NeededFileList = NULL;
            g_MigrationInfo->VendorInfo = &g_VendorInfo;
            
            *VersionInfo = g_MigrationInfo;
        }
    }

    return ERROR_SUCCESS;
}

LONG InitializeOnSource()
{
    return ERROR_SUCCESS;
}
///////////////////////////////////////////////////////////////////////
LONG __stdcall InitializeSrcA(LPCSTR WorkingDirectory, LPCSTR SourceDirectories, LPCSTR MediaDirectory, PVOID Reserved)
{
    DbgPrintMessageBox("in InitializeSrcA");
    return InitializeOnSource();
}

/////////////////////////////////////////////////////////////////////////////
LONG CALLBACK GatherUserSettingsA(LPCSTR AnswerFile, HKEY UserRegKey, LPCSTR UserName, LPVOID Reserved)
{
    DbgPrintMessageBox("in GatherUserSettingsA");
    return ERROR_SUCCESS;
}


LONG CALLBACK GatherSystemSettingsA(LPCSTR AnswerFile, LPVOID Reserved)
{
    DbgPrintMessageBox("in GatherSystemSettingsA");
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Initialization routine on WinNT. Just stores of the migration
// working directory.
LONG CALLBACK InitializeDstA(LPCSTR WorkingDirectory, LPCSTR SourceDirectories, LPVOID Reserved)
{
    DbgPrintMessageBox("in InitializeDstA");
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
LONG CALLBACK ApplyUserSettingsA(
    HINF AnswerFileHandle, 
    HKEY UserRegKey, 
    LPCSTR UserName, 
    LPCSTR UserDomain, 
    LPCSTR FixedUserName, 
    LPVOID Reserved)
{
    DbgPrintMessageBox("in ApplyUserSettingsA");
	return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Called once on NT
LONG CALLBACK ApplySystemSettingsA(HINF UnattendInfHandle, LPVOID Reserved)
{
    DbgPrintMessageBox("in ApplySystemSettingsA");
    if (ERROR_SUCCESS != MigrateMSIInstalledWin32Assembly())
    {
        // just display on chk version, no bother to return to setup
        DbgPrintMessageBox("the return value of MigrateMSIInstalledWin32Assembly isnot totally successful.\n");
    }
    return ERROR_SUCCESS;    
}

BOOL
WINAPI
DllMain(
    HINSTANCE hinstDLL,  
    DWORD fdwReason,     
    LPVOID lpvReserved   
    )
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_MigrationInfo = NULL;
        break;
    case DLL_PROCESS_DETACH:
        if (g_MigrationInfo != NULL)
        {
            if (lpvReserved != NULL)
            {
                HeapFree(GetProcessHeap(), 0, g_MigrationInfo);
            }
            g_MigrationInfo = NULL;
        }
        break;
    }

    return TRUE;
}
///////////////////////////////////////////////////////////////////////
//
// API of WIN9X MIGRATION Dll 
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// called by setup to extract migration DLL version and support
// information. 
LONG CALLBACK QueryVersion(LPCSTR *ProductID, LPUINT DllVersion, LPINT *CodePageArray, LPCSTR *ExeNamesBuf, PVENDORINFO *VendorInfo)
{    
    DbgPrintMessageBox("QueryVersion");

    if (IsThereAssembliesForMigrate() == FALSE)
    {
        return ERROR_NOT_INSTALLED; // no further migration
    }

    
    // product ID information
    *ProductID = g_szProductId;
    *DllVersion = 200;

    // DLL is language independent.
    *CodePageArray = NULL;

    // no EXE search is required
    *ExeNamesBuf = NULL;

    // vendor information
    *VendorInfo = &g_VendorInfo;

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
LONG __stdcall Initialize9x(LPCSTR WorkingDirectory, LPCSTR SourceDirectories, LPCSTR MediaDirectory)
{
    DbgPrintMessageBox("Initialize9x");
    return InitializeOnSource();
}

/////////////////////////////////////////////////////////////////////////////
LONG CALLBACK MigrateUser9x(HWND ParentWnd, LPCSTR AnswerFile, HKEY UserRegKey, LPCSTR UserName, LPVOID Reserved)
{
    DbgPrintMessageBox("MigrateUser9x");
    return ERROR_SUCCESS;
}


LONG CALLBACK MigrateSystem9x(HWND ParentWnd, LPCSTR AnswerFile, LPVOID Reserved)
{
    DbgPrintMessageBox("MigrateSystem9x");
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
LONG CALLBACK InitializeNT(LPCWSTR WorkingDirectory, LPCWSTR SourceDirectories, LPVOID Reserved)
{
    DbgPrintMessageBox("InitializeNT");
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
LONG CALLBACK MigrateUserNT(HINF AnswerFileHandle, HKEY UserRegKey, LPCWSTR UserName, LPVOID Reserved)
{
    DbgPrintMessageBox("MigrateUserNT");
    return ERROR_SUCCESS;
}

typedef HRESULT (_stdcall * PFN_MigrateFusionWin32AssemblyToXP)(PCWSTR pszInstallerDir);
///////////////////////////////////////////////////////////////////////
LONG CALLBACK MigrateSystemNT(HINF UnattendInfHandle, LPVOID Reserved)
{
    DbgPrintMessageBox("MigrateSystemNT");    
    if (ERROR_SUCCESS != MigrateMSIInstalledWin32Assembly())
    {
        // just display on chk version, no bother to return to setup
        DbgPrintMessageBox("the return value of MigrateMSIInstalledWin32Assembly isnot totally successful.\n");
    }

    return ERROR_SUCCESS;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\migrate\fusedll\fuseio.cpp ===
//
// copied from fusion\util\io.cpp with minor changes
//
// xiaoyuw@ 09/05/2001
//

#include "stdinc.h"
#include "macros.h"

#include "fusionbuffer.h"
#include "fusionhandle.h"

#include "fuseio.h"

static BOOL
FusionpIsDotOrDotDot(
    PCWSTR str
    )
{
    return ((str[0] == L'.') && ((str[1] == L'\0') || ((str[1] == L'.') && (str[2] == L'\0'))));
}

static BOOL
IsStarOrStarDotStar(
    PCWSTR str
    )
{
    return (str[0] == '*'
        && (str[1] == 0 || (str[1] == '.' && str[2] == '*' && str[3] == 0)));
}


CDirWalk::ECallbackResult
CDirWalk::WalkHelper(
    )
{
    const PCWSTR* fileFilter = NULL;
    BOOL  fGotAll       = FALSE;
    BOOL  fThisIsAll    = FALSE;
    CFindFile hFind;
    SIZE_T directoryLength = m_strParent.Cch();
    ECallbackResult result = eKeepWalking;    

    ::ZeroMemory(&m_fileData, sizeof(m_fileData));
    result |= m_callback(eBeginDirectory, this);
    if (result & (eError | eSuccess))
    {        
        goto Exit;
    }

    if ((result & eStopWalkingFiles) == 0)
    {
        for (fileFilter = m_fileFiltersBegin ; fileFilter != m_fileFiltersEnd ; ++fileFilter)
        {
            //
            // FindFirstFile equates *.* with *, so we do too.
            //
            fThisIsAll = ::IsStarOrStarDotStar(*fileFilter);
            fGotAll = fGotAll || fThisIsAll;
            if (!m_strParent.Win32EnsureTrailingPathSeparator())
                goto Error;
            if (!m_strParent.Win32Append(*fileFilter, (*fileFilter != NULL) ? ::wcslen(*fileFilter) : 0))
                goto Error;
            hFind = ::FindFirstFileW(m_strParent, &m_fileData);
            m_strParent.Left(directoryLength);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                do
                {
                    if (::FusionpIsDotOrDotDot(m_fileData.cFileName))
                        continue;

                    if (!m_strLastObjectFound.Win32Assign(m_fileData.cFileName, ::wcslen(m_fileData.cFileName)))
                    {                        
                        goto Error;
                    }

                    //
                    // we recurse on directories only if we are getting all of them
                    // otherwise we do them afterward
                    //
                    // the order directories are visited is therefore inconsistent, but
                    // most applications should be happy enough with the eEndDirectory
                    // notification (to implement rd /q/s)
                    //
                    if (m_fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        if (fThisIsAll && (result & eStopWalkingDirectories) == 0)
                        {
                            if (!m_strParent.Win32Append("\\", 1))
                            {
                                goto Error;
                            }
                            if (!m_strParent.Win32Append(m_fileData.cFileName, ::wcslen(m_fileData.cFileName)))
                            {   
                                goto Error;
                            }
                            result |= WalkHelper();
                        }
                    }
                    else
                    {
                        if ((result & eStopWalkingFiles) == 0)
                        {                            
                            result |= m_callback(eFile, this);
                        }
                    }
                    m_strParent.Left(directoryLength);
                    if (result & (eError | eSuccess))
                    {
                        goto Exit;
                    }
                    if (fThisIsAll)
                    {
                        if ((result & eStopWalkingDirectories) &&
                            (result & eStopWalkingFiles))
                        {
                            if (!hFind.Win32Close())
                            {                                
                                goto Error;
                            }
                            
                            goto StopWalking;
                        }
                    }
                    else
                    {
                        if (result & eStopWalkingFiles)
                        {
                            if (!hFind.Win32Close())
                            {           
                                goto Error;
                            }
                            
                            goto StopWalking;
                        }
                    }
                } while(::FindNextFileW(hFind, &m_fileData));
                if (::GetLastError() != ERROR_NO_MORE_FILES)
                {
                    goto Error;
                }
                if (!hFind.Win32Close())
                {   
                    goto Error;
                }
            }
        }
    }
StopWalking:;
    //
    // make another pass with * to get all directories, if we haven't already
    //
    if (!fGotAll && (result & eStopWalkingDirectories) == 0)
    {
        if (!m_strParent.Win32Append("\\*", 2))
        {            
            goto Error;
        }
        hFind = ::FindFirstFileW(m_strParent, &m_fileData);
        m_strParent.Left(directoryLength);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (::FusionpIsDotOrDotDot(m_fileData.cFileName))
                    continue;

                if ((m_fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    continue;
                }

                if (!m_strLastObjectFound.Win32Assign(m_fileData.cFileName, ::wcslen(m_fileData.cFileName)))
                {       
                    goto Error;
                }

                if (!m_strParent.Win32Append("\\", 1))
                {   
                    goto Error;
                }
                if (!m_strParent.Win32Append(m_fileData.cFileName, ::wcslen(m_fileData.cFileName)))
                {   
                    goto Error;
                }
                result |= WalkHelper();
                m_strParent.Left(directoryLength);

                if (result & (eError | eSuccess))
                {
                    goto Exit;
                }
                if (result & eStopWalkingDirectories)
                {   
                    goto StopWalkingDirs;
                }
            } while(::FindNextFileW(hFind, &m_fileData));
            if (::GetLastError() != ERROR_NO_MORE_FILES)
            {
                goto Error;
            }
StopWalkingDirs:
            if (!hFind.Win32Close())
            {   
                goto Error;
            }
        }
    }
    ::ZeroMemory(&m_fileData, sizeof(m_fileData));
    result |= m_callback(eEndDirectory, this);
    if (result & (eError | eSuccess))
    {        
        goto Exit;
    }

    result = eKeepWalking;
Exit:
    if ((result & eStopWalkingDeep) == 0)
    {
        result &= ~(eStopWalkingFiles | eStopWalkingDirectories);
    }
    if (result & eError)
    {
        result |= (eStopWalkingFiles | eStopWalkingDirectories | eStopWalkingDeep);
    }
    return result;
Error:
    result |= eError;
    goto Exit;
}

CDirWalk::CDirWalk()
{
    const static PCWSTR defaultFileFilter[] =  { L"*" };

    m_fileFiltersBegin = defaultFileFilter;
    m_fileFiltersEnd = defaultFileFilter + NUMBER_OF(defaultFileFilter);
}

BOOL
CDirWalk::Walk()
{
    BOOL fSuccess = FALSE;
    //
    // Save off the original path length before we go twiddling m_strParent
    //
    m_cchOriginalPath = m_strParent.Cch();

    ECallbackResult result = WalkHelper();
    if (result & eError)
    {        
        if (::GetLastError() == ERROR_SUCCESS) // forget to set lasterror ?            
            ::SetLastError(ERROR_INSTALL_FAILURE);
        goto Exit;        
    }
    fSuccess = TRUE;
Exit:   
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\migrate\fusedll\fuseio.h ===
#ifndef  FUSION_MIGRATION_FUSEIO_H
#define  FUSION_MIGRATION_FUSEIO_H

#include "windows.h"
class CDirWalk
{
public:
    enum ECallbackReason
    {
        eBeginDirectory = 1,
        eFile,
        eEndDirectory
    };

    CDirWalk();

    //
    // the callback cannot reenable what is has disabled
    // perhaps move these to be member data bools
    //
    enum ECallbackResult
    {
        eKeepWalking            = 0x00000000,
        eError                  = 0x00000001,
        eSuccess                = 0x00000002,
        eStopWalkingFiles       = 0x00000004,
        eStopWalkingDirectories = 0x00000008,
        eStopWalkingDeep        = 0x00000010
    };

    //
    // Just filter on like *.dll, in the future you can imagine
    // filtering on attributes like read onlyness, or running
    // SQL queries over the "File System Oledb Provider"...
    //
    // Also, note that we currently do a FindFirstFile/FindNextFile
    // loop for each filter, plus sometimes one more with *
    // to pick up directories. It is probably more efficient to
    // use * and then filter individually but I don't feel like
    // porting over \Vsee\Lib\Io\Wildcard.cpp right now (which
    // was itself ported from FsRtl, and should be in Win32!)
    //
    const PCWSTR*    m_fileFiltersBegin;
    const PCWSTR*    m_fileFiltersEnd;
    CStringBuffer    m_strParent; // set this to the initial directory to walk
    SIZE_T           m_cchOriginalPath;
    WIN32_FIND_DATAW m_fileData; // not valid for directory callbacks, but could be with a little work
    PVOID            m_context;

    CStringBuffer   m_strLastObjectFound;

    ECallbackResult
    (*m_callback)(
        ECallbackReason  reason,
        CDirWalk*        dirWalk
        );

    BOOL
    Walk();

protected:
    ECallbackResult
    WalkHelper();

private:
    CDirWalk(const CDirWalk &); // intentionally not implemented
    void operator =(const CDirWalk &); // intentionally not implemented
};

#define ENUM_BIT_OPERATIONS(e) \
    inline e operator|(e x, e y) { return static_cast<e>(static_cast<INT>(x) | static_cast<INT>(y)); } \
    inline e operator&(e x, e y) { return static_cast<e>(static_cast<INT>(x) & static_cast<INT>(y)); } \
    inline void operator&=(e& x, INT y) { x = static_cast<e>(static_cast<INT>(x) & y); } \
    inline void operator&=(e& x, e y) { x &= static_cast<INT>(y); } \
    inline void operator|=(e& x, INT y) { x = static_cast<e>(static_cast<INT>(x) | y); } \
    inline void operator|=(e& x, e y) { x |= static_cast<INT>(y); } \
    /* maybe more in the future */

ENUM_BIT_OPERATIONS(CDirWalk::ECallbackResult)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dlldatax.c ===
#pragma warning(disable: 4310 4512 4610 4510 4152 4232)

#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\sources.inc ===
FUSION_BUILD_TYPE=WIN
!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

INCLUDES=$(INCLUDES) $(FUSION_PATH)\oa\idl\$(O)

SXS_MERGE_MODULE=sxsoa.msm
SXS_GENERATE_MERGE_MODULE=1
SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP=1
SXS_MERGE_MODULE_LOCATION=msft-windows-sxsoa.fusion
SXS_MERGE_MODULE_GUID={F3A241E3-E671-4046-AFB0-3EEE8DC08F5B}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dll\stdinc.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\migrate\fusedll\fusemig.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    fusemig.cpp

Abstract:

    migration support

Author:

    xiaoyuw wu @ 09/2001

Revision History:

--*/
#include "stdinc.h"
#include "macros.h"
#include "common.h"
#include <msi.h>
#include <Shlwapi.h>

#include "fusionbuffer.h"
#include "fuseio.h"

#define MsiInstallDir L"%windir%\\installer\\"

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  
  DWORD fdwReason,     
  LPVOID lpvReserved   
)
{
    return TRUE;
}

const char g_szMSIUserDataTreeKeyName[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData";
const char g_szMSIW98KeyName[]="Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components\\";
const char g_szComponentKeyName[] = "Components";

BOOL IsMsiFile(PCWSTR filename) 
{
    PWSTR p = NULL;
    p = wcsrchr(filename, L'.');
    if ( p == NULL)
        return FALSE;
    if (_wcsicmp(p, L".msi") == 0)
    {
        //
        // check the existence of the file
        //
        DWORD dwAttribute = GetFileAttributesW(filename);
        
        if ((dwAttribute == (DWORD) -1) || (dwAttribute & FILE_ATTRIBUTE_DIRECTORY)) // odd case
        {
            return FALSE;
        }
        return TRUE;        
    }
    else
        return FALSE;
}
//
// Function 
//  from {AA2C6017-9D29-4CE2-8EC6-23E8E8F3C088} to 7106C2AA92D92EC4E86C328E8E3F0C88, which is 
//      {AA2C6017-9D29-4CE2-8EC6-23E8E8F3C088} compared with 
//      {7106C2AA-92D9-2EC4-E86C-328E8E3F0C88}
//
HRESULT ConvertComponentGUID(PCWSTR pszComponentGUID, PWSTR pszRegKey, DWORD cchRegKey)
{
    HRESULT hr = S_OK;
    PWSTR pp = const_cast<PWSTR>(pszComponentGUID);
    
    if ( cchRegKey < wcslen(pszComponentGUID) - 3)
    {
        SET_HRERR_AND_EXIT(ERROR_INSUFFICIENT_BUFFER);
    }

    ASSERT_NTC(pp[0] == L'{');
    pp++;

    // switch the first 8 digit : switch every 8
    for ( DWORD i = 0; i < 8; i++)
        pszRegKey[i] = pp[7 - i];

    // 1st 4 digits : switch every 4
    pp = pp + 8 + 1; // skip "-"
    for ( i = 0; i < 4; i++)
    {
        pszRegKey[i + 8]= pp[3 - i];
    }

    // 2nd 4 digits : switch every 4
    pp = pp + 4 + 1; // skip "-"
    for ( i = 0; i < 4; i++)
    {
        pszRegKey[i + 8 + 4]= pp[3 - i];
    }

    // 3rd 4 digits : switch every 2
    pp = pp + 4 + 1; // skip "-"    
    for ( i = 0; i < 2; i++)
    {
        pszRegKey[2*i + 8 + 4 + 4]= pp[2*i + 1];
        pszRegKey[2*i + 8 + 4 + 4 + 1]= pp[2*i];
    }

    // for the last 12 digits
    pp = pp + 4 + 1; // skip "-"    
    for (i=0; i<6; i++)
    {                
        pszRegKey[2*i + 8 + 4 + 4 + 4]= pp[2*i + 1];
        pszRegKey[2*i + 8 + 4 + 4 + 4 + 1]= pp[2*i];
    }

    pszRegKey[32] = L'\0';

Exit:
    return hr;
}

HRESULT W98DeleteComponentKeyFromMsiUserData(PCWSTR pszComponentRegKeyName)
{
    HRESULT hr = S_OK;
    CStringBuffer sbRegKey;
    LONG iRet;

    IFFALSE_EXIT(sbRegKey.Win32Assign(g_szMSIW98KeyName, NUMBER_OF(g_szMSIW98KeyName)-1));
    IFFALSE_EXIT(sbRegKey.Win32Append(pszComponentRegKeyName, wcslen(pszComponentRegKeyName)));

    //
    // About RegDeleteKey : 
    // Windows 95/98/Me: The function also deletes all subkeys and values. To delete a key only if the key has no subkeys 
    // or values, use the SHDeleteEmptyKey function. 
    // 
    // Windows NT/2000 or later: The subkey to be deleted must not have subkeys. To delete a key and all its subkeys, you 
    // need to recursively enumerate the subkeys and delete them individually. To recursively delete keys, use the SHDeleteKey 
    // function. 

    iRet = RegDeleteKeyW(HKEY_LOCAL_MACHINE, sbRegKey);
    if (iRet != ERROR_SUCCESS)
    {
        if (iRet == ERROR_FILE_NOT_FOUND) // this RegKey does not exist
        {
            goto Exit;
        }
        else if (iRet == ERROR_ACCESS_DENIED) // have subKeys underneath
        {
            if (SHDeleteKey(HKEY_LOCAL_MACHINE, sbRegKey) == ERROR_SUCCESS)
                goto Exit;
        }

        SET_HRERR_AND_EXIT(::GetLastError());
    }

Exit:
    return hr;
}

HRESULT NtDeleteComponentKeyFromMsiUserData(PCWSTR pszComponentRegKeyName)
{
    HRESULT hr = S_OK;
    CStringBuffer sbRegKey;
    LONG iRet;
    HKEY hkUserData = NULL;
    SIZE_T cchRegKey;
    WCHAR bufSID[128]; //S-1-5-21-2127521184-1604012920-1887927527-88882    
    DWORD cchSID = NUMBER_OF(bufSID);
    DWORD index;

    IFFALSE_EXIT(sbRegKey.Win32Assign(g_szMSIUserDataTreeKeyName, NUMBER_OF(g_szMSIUserDataTreeKeyName)-1));
    IF_NOTSUCCESS_SET_HRERR_EXIT(RegOpenKeyExW(HKEY_LOCAL_MACHINE, sbRegKey, 0, KEY_READ, &hkUserData));
    cchRegKey = sbRegKey.Cch();
    
    index = 0; 
    iRet = RegEnumKeyExW(hkUserData, index, bufSID, &cchSID, NULL, NULL, NULL, NULL);
    
    while ((iRet == ERROR_SUCCESS) || (iRet == ERROR_MORE_DATA))
    {
        sbRegKey.Left(cchRegKey);

        //
        // construct RegKey name of a Component
        // in the format of HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Components\0020F700D33C1D112897000CF42C6133
        //
        IFFALSE_EXIT(sbRegKey.Win32EnsureTrailingPathSeparator());
        IFFALSE_EXIT(sbRegKey.Win32Append(bufSID, cchSID));
        IFFALSE_EXIT(sbRegKey.Win32EnsureTrailingPathSeparator());
        IFFALSE_EXIT(sbRegKey.Win32Append(g_szComponentKeyName, NUMBER_OF(g_szComponentKeyName)-1));
        IFFALSE_EXIT(sbRegKey.Win32EnsureTrailingPathSeparator());
        IFFALSE_EXIT(sbRegKey.Win32Append(pszComponentRegKeyName, wcslen(pszComponentRegKeyName)));

        //
        // About RegDeleteKey : 
        // Windows 95/98/Me: The function also deletes all subkeys and values. To delete a key only if the key has no subkeys 
        // or values, use the SHDeleteEmptyKey function. 
        // 
        // Windows NT/2000 or later: The subkey to be deleted must not have subkeys. To delete a key and all its subkeys, you 
        // need to recursively enumerate the subkeys and delete them individually. To recursively delete keys, use the SHDeleteKey 
        // function. 

        iRet = RegDeleteKeyW(HKEY_LOCAL_MACHINE, sbRegKey);
        if (iRet != ERROR_SUCCESS)
        {
            if (iRet == ERROR_FILE_NOT_FOUND) // this RegKey does not exist
            {
                goto cont;
            }
            else if (iRet == ERROR_ACCESS_DENIED) // have subKeys underneath
            {
                if (SHDeleteKey(HKEY_LOCAL_MACHINE, sbRegKey) == ERROR_SUCCESS)
                    goto cont;
            }

            SET_HRERR_AND_EXIT(::GetLastError());
        }
        
cont:
        index ++;
        cchSID = NUMBER_OF(bufSID);
        iRet = RegEnumKeyExW(hkUserData, index, bufSID, &cchSID, NULL, NULL, NULL, NULL);
        if (cchSID > NUMBER_OF(bufSID))
        {
            SET_HRERR_AND_EXIT(ERROR_INSUFFICIENT_BUFFER);
        }

        if (iRet == ERROR_NO_MORE_ITEMS)
            break;
    }
    if (iRet != ERROR_NO_MORE_ITEMS)
    {
        SET_HRERR_AND_EXIT(::GetLastError());
    }

Exit:
    RegCloseKey(hkUserData);
    return hr;
}

HRESULT DeleteComponentKeyFromMsiUserData(PCWSTR pszComponentRegKeyName)
{    
    HRESULT hr = S_OK;
    if (GetModuleHandleA("w95upgnt.dll") == NULL) // no Freelibrary is needed, ref counter is not changed
    {
        // must be upgration from NT(4.0 or 5)to xp
        hr = NtDeleteComponentKeyFromMsiUserData(pszComponentRegKeyName);
    }
    else
    {
        // must be upgrate from w9x to xp
        hr = W98DeleteComponentKeyFromMsiUserData(pszComponentRegKeyName);
    }

    return hr;
}


// Function:
// (1) open database
// (2) if (this msi contain at least win32 assembly component)
// (3)    get this componentID
// (4)    delete the RegKey from all subtrees under 
// (5) endif
//
HRESULT MigrateSingleFusionWin32AssemblyToXP(PCWSTR filename)
{
    HRESULT hr = S_OK;
    PMSIHANDLE hdb = NULL;
    PMSIHANDLE hView = NULL;
    MSIHANDLE hRecord = NULL;
    WCHAR sqlbuf[CA_MAX_BUF * 2];
    WCHAR szComponentID[CA_MAX_BUF];
    DWORD cchComponentID;    
    WCHAR szComponentRegKey[CA_MAX_BUF];
    DWORD cchComponentRegKey; 
    BOOL fExist;
    ULONG iRet;

    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiOpenDatabaseW(filename, LPCWSTR(MSIDBOPEN_DIRECT), &hdb));
    IFFAILED_EXIT(MSI_IsTableExist(hdb, L"MsiAssembly", fExist));
    if ( fExist == FALSE)
        goto Exit;

    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, ca_sqlQuery[CA_SQL_QUERY_MSIASSEMBLY], &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));

    for (;;)
    {
        //
        // for each entry in MsiAssembly Table
        //
        iRet = MsiViewFetch(hView, &hRecord);
        if (iRet == ERROR_NO_MORE_ITEMS)
            break;
        if (iRet != ERROR_SUCCESS )
            SET_HRERR_AND_EXIT(iRet);

        iRet = MsiRecordGetInteger(hRecord, 1);
        if ( iRet != MSI_FUSION_WIN32_ASSEMBLY)
            continue;

        //
        // get componentID
        //
        cchComponentID = NUMBER_OF(szComponentID);
        IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 3, szComponentID, &cchComponentID));
        MsiCloseHandle(hRecord);

        break;
    }

    //
    // get Component GUID
    //
    swprintf(sqlbuf, ca_sqlQuery[CA_SQL_QUERY_COMPONENT_FOR_COMPONENTGUID], szComponentID);
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiDatabaseOpenViewW(hdb, sqlbuf, &hView));
    IF_NOTSUCCESS_SET_HRERR_EXIT(::MsiViewExecute(hView, 0));
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiViewFetch(hView, &hRecord));
    cchComponentID = NUMBER_OF(szComponentID); // reuse szComponentID
    IF_NOTSUCCESS_SET_HRERR_EXIT(MsiRecordGetStringW(hRecord, 1, szComponentID, &cchComponentID));
       
    //
    // get MSI-ComponentRegKey
    //
    cchComponentRegKey = NUMBER_OF(szComponentRegKey);
    IFFAILED_EXIT(ConvertComponentGUID(szComponentID, szComponentRegKey, cchComponentRegKey));

    // delete MSI-ComponentRegKey from all subtrees of \\install\userdata\user-sid
    IFFAILED_EXIT(DeleteComponentKeyFromMsiUserData(szComponentRegKey));

Exit:
    MsiCloseHandle(hRecord);
    return hr;
}



CDirWalk::ECallbackResult
MsiInstallerDirectoryDirWalkCallback(
    CDirWalk::ECallbackReason   reason,
    CDirWalk*                   dirWalk    
    )
{
    CDirWalk::ECallbackResult result = CDirWalk::eKeepWalking;

    if (reason == CDirWalk::eFile)
    {
        //
        CStringBuffer filename; 

        if (filename.Win32Assign(dirWalk->m_strParent) == FALSE)
        {
            goto Error;
        }
        if (!filename.Win32AppendPathElement(dirWalk->m_strLastObjectFound))
        {
                goto Error;
        }

#if DBG
      ASSERT_NTC(IsMsiFile(filename) == TRUE);
#endif

      if (!SUCCEEDED(MigrateSingleFusionWin32AssemblyToXP(filename)))
      {
          goto Error;
      }
    }
Exit:
    return result;
Error:
    result = CDirWalk::eError;
    goto Exit;
}

HRESULT MsiInstallerDirectoryDirWalk(PCWSTR pszParentDirectory)
{
    HRESULT hr = S_OK;
    CDirWalk dirWalk;    
    const static PCWSTR filters[]={L"*.msi"};
    PWSTR pszParentDir = NULL;
    WCHAR buf[64];
#if DBG
    MessageBox(NULL, "In fusemig.dll", "fusemig", MB_OK);
#endif 

    if (pszParentDirectory == NULL)
    {
        UINT iret = ExpandEnvironmentStringsW(MsiInstallDir, buf, NUMBER_OF(buf));
        if ((iret == 0) || (iret > NUMBER_OF(buf)))
        {
            SET_HRERR_AND_EXIT(::GetLastError());
        }
        pszParentDir = buf;
    }else
    {
        pszParentDir = const_cast<PWSTR>(pszParentDirectory);
    }
   
    dirWalk.m_fileFiltersBegin = filters;
    dirWalk.m_fileFiltersEnd   = filters + NUMBER_OF(filters);
    dirWalk.m_context = NULL;
    dirWalk.m_callback = MsiInstallerDirectoryDirWalkCallback;
    IFFALSE_EXIT(dirWalk.m_strParent.Win32Assign(pszParentDir, wcslen(pszParentDir)));
    IFFALSE_EXIT(dirWalk.m_strParent.Win32RemoveTrailingPathSeparators());
    IFFALSE_EXIT(dirWalk.Walk());
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\migrate\fusedll\test\test.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    test.cpp

Abstract:

    Test Function calls for migration dll

Author:
    Xiaoyu Wu(xiaoyuw) 06-Sept-2001

--*/
#include "stdinc.h"
#include "macros.h"

#include <windows.h>

extern FUSION_HEAP_HANDLE g_hHeap;

typedef HRESULT (_stdcall * PFN_MigrateSingleFusionWin32AssemblyToXP)(PCWSTR filename);
extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    HRESULT         hr = S_OK;
    PFN_MigrateSingleFusionWin32AssemblyToXP pfn = NULL;     

    HMODULE hd = LoadLibrary("..\\..\\..\\obj\\i386\\fusemig.dll");
    if (hd == NULL)
    {
        printf("hi, error to load library\n");
        SET_HRERR_AND_EXIT(::GetLastError());
        goto Exit;
    }
    g_hHeap = (FUSION_HEAP_HANDLE)GetProcessHeap();
    pfn = (PFN_MigrateSingleFusionWin32AssemblyToXP)GetProcAddress(hd, "MsiInstallerDirectoryDirWalk");
    if ( pfn == NULL)
    {
        printf("hi, error to load library\n");
        SET_HRERR_AND_EXIT(::GetLastError());
        goto Exit;
    }
    if (argc >=2)
        IFFAILED_EXIT(pfn(argv[1]));
    else
        IFFAILED_EXIT(pfn(NULL));

Exit:
    FreeLibrary(hd);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dll\dllmain.cpp ===
// ActCtx.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ActCtxps.mk in the project directory.

#include "stdinc.h"
#include "resource.h"
#include <initguid.h>
#include "sxsoa.h"
#include "actctx.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ActCtx, CActCtx)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ACTCTXLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dll\actctx.cpp ===
// CActCtx.cpp : Implementation of CActCtx
#include "stdinc.h"
#include "sxsoa.h"
#include "actctx.h"

#define NUMBER_OF(x) RTL_NUMBER_OF(x)

class CActivation
{
public:
    CActivation(CActCtx &rActCtx, HANDLE hActCtx) : m_rActCtx(rActCtx), m_hActCtx(hActCtx), m_ulpCookie(0) { }
    CActivation(CActCtx &rActCtx) : m_rActCtx(rActCtx), m_hActCtx(NULL), m_ulpCookie(0) { }
    ~CActivation() { if (m_ulpCookie != 0) { (*m_rActCtx.ms_pDeactivateActCtx)(0, m_ulpCookie); } }

    void Attach(HANDLE hActCtx) { _ASSERTE(m_ulpCookie == 0); m_hActCtx = hActCtx; }


    HRESULT Activate()
    {
        if (m_ulpCookie != 0)
            return E_UNEXPECTED;

        if (!(*m_rActCtx.ms_pActivateActCtx)(m_hActCtx, &m_ulpCookie))
            return HRESULT_FROM_WIN32(::GetLastError());

        return NOERROR;
    }

    HRESULT Deactivate()
    {
        ULONG_PTR ulpCookie = m_ulpCookie; // capture

        m_ulpCookie = 0;

        if (ulpCookie == 0)
            return E_UNEXPECTED;

        if (!(*m_rActCtx.ms_pDeactivateActCtx)(0, ulpCookie))
            return HRESULT_FROM_WIN32(::GetLastError());

        return NOERROR;
    }

protected:
    CActCtx &m_rActCtx;
    HANDLE m_hActCtx;
    ULONG_PTR m_ulpCookie;
};

/////////////////////////////////////////////////////////////////////////////
// CActCtx

HINSTANCE CActCtx::ms_hKERNEL32 = NULL;

CActCtx::PFNCreateActCtxW CActCtx::ms_pCreateActCtxW = NULL;
CActCtx::PFNAddRefActCtx CActCtx::ms_pAddRefActCtx = NULL;
CActCtx::PFNReleaseActCtx CActCtx::ms_pReleaseActCtx = NULL;
CActCtx::PFNActivateActCtx CActCtx::ms_pActivateActCtx = NULL;
CActCtx::PFNDeactivateActCtx CActCtx::ms_pDeactivateActCtx = NULL;


HRESULT CActCtx::FetchManifestInfo(ACTCTX_MANIFEST_INFO_TYPE infotype, BSTR *pVal)
{
    HRESULT hr = E_FAIL;
    BSTR bstrResult = NULL;    

    if (pVal != NULL)
        *pVal = NULL;

    if (pVal == NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (infotype == ACTCTX_MANIFEST_FILE)
    {
        bstrResult = ::SysAllocString((m_bstrManifest.m_str == NULL) ? L"" : m_bstrManifest);
    }
    else if (infotype == ACTCTX_MANIFEST_TEXT)
    {
        bstrResult = ::SysAllocString((m_bstrManifestText.m_str == NULL) ? L"" : m_bstrManifestText);
    }
    else if (infotype == ACTCTX_MANIFEST_URL)
    {
        bstrResult = ::SysAllocString((m_bstrManifestURL.m_str == NULL) ? L"" : m_bstrManifestURL);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (bstrResult == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *pVal = bstrResult;
    bstrResult = NULL;

    hr = NOERROR;

Exit:
    if (bstrResult != NULL)
        ::SysFreeString(bstrResult);

    return hr;
}

HRESULT MakeTemporaryFileName(CComBSTR & str)
{
    // generate a temporary filename
    HRESULT hr = E_FAIL;
    BSTR bstrTempFileName = NULL;
    WCHAR TempPath[MAX_PATH];
    WCHAR TempFileName[MAX_PATH];
    if ( 0 == GetTempPathW(MAX_PATH, TempPath))    
        goto SetHrErrorAndExit;    

    if ( 0 == GetTempFileNameW(TempPath, L"sxs", 0, TempFileName))
        goto SetHrErrorAndExit;

    bstrTempFileName = SysAllocString(TempFileName);
    if (bstrTempFileName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    str.Attach(bstrTempFileName);
    bstrTempFileName = NULL;

    hr = S_OK;
    goto Exit;

SetHrErrorAndExit:
    hr = HRESULT_FROM_WIN32(::GetLastError());
Exit:
    if (bstrTempFileName != NULL)
        SysFreeString(bstrTempFileName);
    return hr;
}

HRESULT CActCtx::SetManifestInfo(ACTCTX_MANIFEST_INFO_TYPE infotype, BSTR newVal)
{
    HRESULT hr = E_FAIL;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;
    ACTCTXW acw = { sizeof(acw) };
    CComBSTR bstrTemp;
    CComBSTR bstrManifestFile;
    HANDLE hTempFile = INVALID_HANDLE_VALUE;

    if (newVal == NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (infotype == ACTCTX_MANIFEST_FILE)
    {
        bstrManifestFile.Attach(newVal);
    }
    else if (infotype == ACTCTX_MANIFEST_TEXT)
    {
        DWORD NumberOfBytesWritten;

        hr = MakeTemporaryFileName(bstrManifestFile);
        if (FAILED(hr))
            goto Exit;

        hTempFile = CreateFileW((LPWSTR)bstrManifestFile,  
            GENERIC_READ | GENERIC_WRITE, 
            0,                            // do not share 
            NULL,                         // no security 
            CREATE_ALWAYS,                // overwrite existing file
            FILE_ATTRIBUTE_NORMAL,        // normal file 
            NULL);                        // no attr. template 

        if (hTempFile == INVALID_HANDLE_VALUE) 
            goto SetHrErrorAndExit;

        // "TODO:" or "DO WE NEED TODO?": 
        // check the encoding of the manifest, if it is encoded as "UTF-8", we have to transfer the 
        // textual manifest into byte before writing into a file.
        // be sure that your manifest is UCS-2
        ULONG XML_UCS2_BOM=0xFEFF;
        if ( FALSE == WriteFile(hTempFile, (LPCVOID)&XML_UCS2_BOM, 2, &NumberOfBytesWritten, NULL))    
            goto SetHrErrorAndExit;
        if ( FALSE == WriteFile(hTempFile, (LPCVOID)((LPWSTR)newVal), SysStringByteLen(newVal), &NumberOfBytesWritten, NULL))    
            goto SetHrErrorAndExit;

        if ( FALSE == CloseHandle(hTempFile))
            goto SetHrErrorAndExit;

        hTempFile = INVALID_HANDLE_VALUE;
    }
    else if (infotype == ACTCTX_MANIFEST_URL)
    {
        hr = MakeTemporaryFileName(bstrManifestFile);
        if (FAILED(hr))
        {
            goto Exit;
        }
        if (FAILED(hr = URLDownloadToFileW(NULL, (LPWSTR)newVal, (LPWSTR)bstrManifestFile, 0, NULL)))
            goto Exit;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    
    if (FAILED(hr = this->EnsureInitialized()))
        goto Exit;

    acw.lpSource = bstrManifestFile;

    hActCtx = (*ms_pCreateActCtxW)(&acw);
    if (hActCtx == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    bstrTemp.Attach(::SysAllocString(newVal));
    if (bstrTemp == static_cast<BSTR>(NULL))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    m_cs.Lock();

    if (m_hActCtx != NULL)
        (*ms_pReleaseActCtx)(m_hActCtx);

    m_hActCtx = hActCtx;
    hActCtx = NULL;

    m_bstrManifest.Empty();
    m_bstrManifestURL.Empty();
    m_bstrManifestText.Empty();

    switch (infotype)        
    {
    case ACTCTX_MANIFEST_FILE:        
        m_bstrManifest.Attach(bstrTemp.Detach());
        break;
    case ACTCTX_MANIFEST_TEXT:
        m_bstrManifestText.Attach(bstrTemp.Detach());
        break;
    case ACTCTX_MANIFEST_URL:
        m_bstrManifestURL.Attach(bstrTemp.Detach());
        break;
    default: // impossible path because infotype has been checked at the beginning of the function
        hr = E_INVALIDARG;
        goto Exit;
    }
    m_cs.Unlock();

    hr = NOERROR;
    goto Exit;

SetHrErrorAndExit:
    hr = HRESULT_FROM_WIN32(::GetLastError());
Exit:
    if (hTempFile != INVALID_HANDLE_VALUE)
        CloseHandle(hTempFile);
    
    if (infotype == ACTCTX_MANIFEST_FILE)
        bstrManifestFile.Detach();

    if (hActCtx != NULL && hActCtx != INVALID_HANDLE_VALUE)
        (*ms_pReleaseActCtx)(hActCtx);

    return hr;
}

STDMETHODIMP CActCtx::CreateObject(BSTR bstrObjectReference, VARIANT *pvarLocation, IDispatch **ppObject)
{
    HRESULT hr = E_FAIL;
    CLSID clsid;
    COSERVERINFO csi = { 0 };
    MULTI_QI rgmqi[1];
    ULONG cmqi = 0, imqiIDispatch, i;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;
    CActivation act(*this);
    BSTR bstrLocation = NULL;

    if (ppObject != NULL)
        *ppObject = NULL;

    if (ppObject == NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if ((pvarLocation != NULL) &&
        (pvarLocation->vt != VT_ERROR))
    {
        if (pvarLocation->vt != VT_BSTR)
        {
            hr = E_INVALIDARG;
            goto Exit;
        }

        bstrLocation = pvarLocation->bstrVal;
    }

    if (FAILED(hr = this->EnsureInitialized()))
        goto Exit;

    m_cs.Lock();

    hActCtx = m_hActCtx;
    (*ms_pAddRefActCtx)(hActCtx);

    m_cs.Unlock();

    act.Attach(hActCtx);
    act.Activate();

    if (FAILED(hr = ::CLSIDFromProgID(bstrObjectReference, &clsid)))
        goto Exit;

    if (bstrLocation != NULL)
        csi.pwszName = bstrLocation;

    cmqi = 0;

    _ASSERTE(cmqi < NUMBER_OF(rgmqi));

    rgmqi[cmqi].hr = NOERROR;
    rgmqi[cmqi].pIID = &IID_IDispatch;
    rgmqi[cmqi].pItf = NULL;
    imqiIDispatch = cmqi;

    cmqi++;

    if (FAILED(hr = ::CoCreateInstanceEx(
                        clsid,
                        NULL,
                        CLSCTX_SERVER,
                        &csi,
                        cmqi,
                        rgmqi)))
        goto Exit;

    // See if any of the QIs failed...
    for (i=0; i<cmqi; i++)
    {
        if (FAILED(hr = rgmqi[i].hr))
            goto Exit;
    }

    act.Deactivate();

    *ppObject = static_cast<IDispatch *>(rgmqi[imqiIDispatch].pItf);
    rgmqi[imqiIDispatch].pItf = NULL;

    hr = NOERROR;

Exit:
    for (i=0; i<cmqi; i++)
    {
        if (rgmqi[i].pItf != NULL)
            rgmqi[i].pItf->Release();
    }

    if ((hActCtx != NULL) &&
        (hActCtx != INVALID_HANDLE_VALUE))
        (*ms_pReleaseActCtx)(hActCtx);

    return hr;
}

STDMETHODIMP CActCtx::GetObject(VARIANT *pvarMoniker, VARIANT *pvarProgID, IDispatch **ppIDispatch)
{
    HRESULT hr = E_FAIL;
    CComPtr<IDispatch> srpIDispatch;
    CComPtr<IBindCtx> srpIBindCtx;
    CComPtr<IMoniker> srpIMoniker;
    CComVariant svarProgId;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;
    CActivation act(*this);
    BSTR bstrMoniker = NULL;

    if (ppIDispatch != NULL)
        *ppIDispatch = NULL;

    if (ppIDispatch == NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (FAILED(hr = this->EnsureInitialized()))
        goto Exit;

    if (pvarMoniker != NULL)
    {
        if (pvarMoniker->vt != VT_ERROR)
        {
            if (pvarMoniker->vt != VT_BSTR)
            {
                hr = DISP_E_TYPEMISMATCH;
                goto Exit;
            }
        
            bstrMoniker = pvarMoniker->bstrVal;
        }
    }

    if ((bstrMoniker != NULL) && (bstrMoniker[0] == L'\0'))
        bstrMoniker = NULL;

    m_cs.Lock();

    hActCtx = m_hActCtx;
    (*ms_pAddRefActCtx)(hActCtx);

    m_cs.Unlock();

    act.Attach(hActCtx);
    act.Activate();

    if ((pvarProgID != NULL) && (pvarProgID->vt != VT_ERROR))
    {
        hr = svarProgId.ChangeType(VT_BSTR, pvarProgID);
        if (FAILED(hr))
            goto Exit;

        hr = this->CreateObject(svarProgId.bstrVal, NULL, &srpIDispatch);
        if (FAILED(hr))
            goto Exit;

        if (bstrMoniker != NULL)
        {
            CComPtr<IPersistFile> srpIPersistFile;
            hr = srpIDispatch.QueryInterface(&srpIPersistFile);
            if (FAILED(hr))
                goto Exit;

            hr = srpIPersistFile->Load(bstrMoniker, STGM_READWRITE);
            if (FAILED(hr))
                goto Exit;
        }
    }
    else
    {
        PCWSTR pszColon = NULL;
        ULONG cchEaten;

        if (bstrMoniker == NULL)
        {
            hr = E_INVALIDARG;
            goto Exit;
        }

        hr = ::CreateBindCtx(0, &srpIBindCtx);
        if (FAILED(hr))
            goto Exit;

        pszColon = wcschr(bstrMoniker, L':');
        
        if ((pszColon == NULL) || ((pszColon - bstrMoniker) == 1))
        {
            WCHAR rgwchFullPath[MAX_PATH];

            DWORD dwRet;
            PWSTR pszFilePart;

            dwRet = ::GetFullPathNameW(bstrMoniker, NUMBER_OF(rgwchFullPath), rgwchFullPath, &pszFilePart);
            if (dwRet == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                goto Exit;
            }

            hr = ::MkParseDisplayName(srpIBindCtx, bstrMoniker, &cchEaten, &srpIMoniker);
            if (FAILED(hr))
                goto Exit;
        }
        else
        {
            hr = ::CreateURLMoniker(NULL, bstrMoniker, &srpIMoniker);
            if (FAILED(hr))
                goto Exit;
        }

        hr = srpIMoniker->BindToObject(srpIBindCtx, NULL, IID_IDispatch, (PVOID *) &srpIDispatch);

        if (hr == 0x800C0005)
            hr = MK_E_CANTOPENFILE;

        if (FAILED(hr))
            goto Exit;
    }

    *ppIDispatch = srpIDispatch.Detach();

    act.Deactivate();

    hr = NOERROR;

Exit:
    return hr;
}

template <typename T> static HRESULT LocalGetProcAddress(HINSTANCE hInstance, PCSTR pszFunction, T &rpfn, T pfnDefault)
{
    HRESULT hr = E_FAIL;

    if (rpfn == NULL)
    {
        T pfn = reinterpret_cast<T>(::GetProcAddress(hInstance, pszFunction));

        if (pfn == NULL)
        {
            const DWORD dwLastError = ::GetLastError();

            if (dwLastError != ERROR_PROC_NOT_FOUND)
            {
                hr = HRESULT_FROM_WIN32(dwLastError);
                goto Exit;
            }

            pfn = pfnDefault;
        }

#if defined(_X86_)
        ::InterlockedCompareExchange((LONG *) &rpfn, (LONG) pfn, 0);
#else
        ::InterlockedCompareExchangePointer((PVOID *) &rpfn, pfn, NULL);
#endif
    }

    hr = NOERROR;
Exit:
    return hr;
}


HRESULT CActCtx::EnsureInitialized()
{
    HRESULT hr = E_FAIL;

    // Check last initialized pointer first for early exit
    if (ms_pDeactivateActCtx != NULL)
    {
        hr = NOERROR;
        goto Exit;
    }

    if (ms_hKERNEL32 == NULL)
    {
        HINSTANCE hKERNEL32 = ::GetModuleHandleA("KERNEL32.DLL");
        if (hKERNEL32 == NULL)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            goto Exit;
        }

#if defined(_X86_)
        if (::InterlockedExchange(reinterpret_cast<LONG *>(&ms_hKERNEL32), reinterpret_cast<LONG>(hKERNEL32)) != 0)
#else
        if (::InterlockedExchangePointer(reinterpret_cast<PVOID *>(&ms_hKERNEL32), hKERNEL32) != NULL)
#endif
            ::FreeLibrary(hKERNEL32);
    }

    if (FAILED(hr = ::LocalGetProcAddress(ms_hKERNEL32, "CreateActCtxW", ms_pCreateActCtxW, &CActCtx::fakeCreateActCtxW)))
        goto Exit;

    if (FAILED(hr = ::LocalGetProcAddress(ms_hKERNEL32, "AddRefActCtx", ms_pAddRefActCtx, &CActCtx::fakeAddRefActCtx)))
        goto Exit;

    if (FAILED(hr = ::LocalGetProcAddress(ms_hKERNEL32, "ReleaseActCtx", ms_pReleaseActCtx, &CActCtx::fakeReleaseActCtx)))
        goto Exit;

    if (FAILED(hr = ::LocalGetProcAddress(ms_hKERNEL32, "ActivateActCtx", ms_pActivateActCtx, &CActCtx::fakeActivateActCtx)))
        goto Exit;

    if (FAILED(hr = ::LocalGetProcAddress(ms_hKERNEL32, "DeactivateActCtx", ms_pDeactivateActCtx, &CActCtx::fakeDeactivateActCtx)))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

STDMETHODIMP CActCtx::put_ManifestText(BSTR bstrManifestText)
{
    return SetManifestInfo(ACTCTX_MANIFEST_TEXT, bstrManifestText);
}

STDMETHODIMP CActCtx::put_ManifestURL(BSTR bstrManifestURL)
{
    return SetManifestInfo(ACTCTX_MANIFEST_URL, bstrManifestURL);
}

STDMETHODIMP CActCtx::put_Manifest(BSTR bstrManifestURL)
{
    return SetManifestInfo(ACTCTX_MANIFEST_FILE, bstrManifestURL);
}

STDMETHODIMP CActCtx::get_Manifest(BSTR *pVal)
{
    return FetchManifestInfo(ACTCTX_MANIFEST_FILE, pVal);
}

STDMETHODIMP CActCtx::get_ManifestText(BSTR *pVal)
{
    return FetchManifestInfo(ACTCTX_MANIFEST_TEXT, pVal);
}

STDMETHODIMP CActCtx::get_ManifestURL(BSTR *pVal)
{
    return FetchManifestInfo(ACTCTX_MANIFEST_URL, pVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dll\actctx.h ===
// CActCtx.h : Declaration of the CActCtx

#ifndef __ACTCTX_H_
#define __ACTCTX_H_

#include "resource.h"       // main symbols

class CCS
{
public:
    CCS() { }
    ~CCS() { ::DeleteCriticalSection(&m_cs); }
    HRESULT Initialize() { __try { ::InitializeCriticalSection(&m_cs); } __except ((GetExceptionCode() == STATUS_NO_MEMORY) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) { return E_OUTOFMEMORY; } return NOERROR; }
    void Lock() { ::EnterCriticalSection(&m_cs); }
    void Unlock() { ::LeaveCriticalSection(&m_cs); }
protected:
    CRITICAL_SECTION m_cs;
};

// forward declaration for friendship
class CActivation;

/////////////////////////////////////////////////////////////////////////////
// CActCtx
class ATL_NO_VTABLE CActCtx : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CActCtx, &CLSID_ActCtx>,
    public IDispatchImpl<IActCtx, &IID_IActCtx, &LIBID_ACTCTXLib>
{
    friend CActivation;

public:
    CActCtx()
    {
        m_pUnkMarshaler = NULL;
        m_hActCtx = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_ACTCTX)
DECLARE_NOT_AGGREGATABLE(CActCtx)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CActCtx)
    COM_INTERFACE_ENTRY(IActCtx)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        HRESULT hr = m_cs.Initialize();
        if (FAILED(hr))
            return hr;
        return ::CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// IActCtx
public:
    STDMETHOD(GetObject)(VARIANT *pvarMoniker, VARIANT *pvarProgID, IDispatch **ppIDispatch);
    STDMETHOD(CreateObject)(BSTR ObjectReference, VARIANT *pvarLocation, IDispatch **ppIDispatch);
    STDMETHOD(get_Manifest)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Manifest)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ManifestText)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ManifestText)(/*[in]*/ BSTR bstrTextualManifest);
    STDMETHOD(get_ManifestURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ManifestURL)(/*[in]*/ BSTR bstrURL);

protected:
    typedef enum {
        ACTCTX_MANIFEST_FILE=0,
        ACTCTX_MANIFEST_TEXT,
        ACTCTX_MANIFEST_URL
    }ACTCTX_MANIFEST_INFO_TYPE;

    HRESULT FetchManifestInfo(ACTCTX_MANIFEST_INFO_TYPE infotype, BSTR *pVal);
    HRESULT SetManifestInfo(ACTCTX_MANIFEST_INFO_TYPE infotype, BSTR newVal);
    HRESULT EnsureInitialized();

    static HANDLE WINAPI fakeCreateActCtxW(PCACTCTXW) { return NULL; }
    static VOID WINAPI fakeAddRefActCtx(HANDLE) { }
    static VOID WINAPI fakeReleaseActCtx(HANDLE) { }
    static BOOL WINAPI fakeActivateActCtx(HANDLE, ULONG_PTR *) { return TRUE; }
    static BOOL WINAPI fakeDeactivateActCtx(DWORD, ULONG_PTR) { return TRUE; }

    static HINSTANCE ms_hKERNEL32;

    typedef HANDLE (WINAPI *PFNCreateActCtxW)(PCACTCTXW);
    typedef VOID (WINAPI *PFNAddRefActCtx)(HANDLE);
    typedef VOID (WINAPI *PFNReleaseActCtx)(HANDLE);
    typedef BOOL (WINAPI *PFNActivateActCtx)(HANDLE, ULONG_PTR *);
    typedef BOOL (WINAPI *PFNDeactivateActCtx)(DWORD, ULONG_PTR);

    static PFNCreateActCtxW ms_pCreateActCtxW;
    static PFNAddRefActCtx ms_pAddRefActCtx;
    static PFNReleaseActCtx ms_pReleaseActCtx;
    static PFNActivateActCtx ms_pActivateActCtx;
    static PFNDeactivateActCtx ms_pDeactivateActCtx;

    CCS m_cs;
    CComBSTR m_bstrManifest;
    CComBSTR m_bstrManifestURL;
    CComBSTR m_bstrManifestText;
    HANDLE m_hActCtx;
};

#endif //__ACTCTX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\msi\migrate\migratedll\migrate.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       migrate.cpp
//  xiaoyuw @ 2001/09
//
//--------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>

// migration DLL version information

typedef struct {
    CHAR CompanyName[256];
    CHAR SupportNumber[256];
    CHAR SupportUrl[256];
    CHAR InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

typedef struct {
    SIZE_T Size;
    PCSTR StaticProductIdentifier;
    UINT DllVersion;
    PINT CodePageArray;
    UINT SourceOs;
    UINT TargetOs;
    PCSTR * NeededFileList;
    PVENDORINFO VendorInfo;
} MIGRATIONINFOA, *PMIGRATIONINFOA;

typedef enum {

    OS_WINDOWS9X = 0,
    OS_WINDOWSNT4X = 1,
    OS_WINDOWS2000 = 2,
    OS_WINDOWSWHISTLER = 3

} OS_TYPES, *POS_TYPES;

PMIGRATIONINFOA g_MigrationInfo = NULL;

const char g_szProductId[] = "Microsoft MSI Migration DLL v2.0";
VENDORINFO g_VendorInfo = { "Microsoft", "", "", "" };

// registry keys of note
const char szSideBySideKeyName[] = "Software\\Microsoft\\Windows\\CurrentVersion\\SideBySide";
const char szMigrateStatusKeyName[] = "Software\\Microsoft\\Windows\\CurrentVersion\\SideBySide\\MigrateMsiInstalledAssembly";

const char szRunOnceValueName[] = "Cleanup Msi 2.0 Migration";
const char szRunOnceSetupRegKey[]= "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
const char szRunOnceValueCommandLine[]="reg.exe delete HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SideBySide\\MigrateMsiInstalledAssembly /f";

typedef HRESULT (__stdcall *LPDLLGETVERSION)(DLLVERSIONINFO *);

typedef enum _FUSION_MSI_OS_VERSION
{
    E_OS_UNKNOWN,
    E_WIN95,
    E_WIN_ME,
    E_WIN_NT,
    E_WIN98,
    E_WIN2K,
    E_WHISTLER,
    E_WIN32_OTHERS
} FUSION_MSI_OS_VERSION;

typedef enum _FUSION_MSI_OS_TYPE
{
    E_PERSONAL,
    E_PROFESSIONAL,
    E_DATA_CENTER,
    E_STD_SERVER,
    E_ADV_SERVER,
    E_WORKSTATION,
    E_SERVER
} FUSION_MSI_OS_TYPE;

HRESULT SxspGetOSVersion(FUSION_MSI_OS_VERSION & osv)
{
    HRESULT hr = S_OK;
    OSVERSIONINFO osvi;
    BOOL bOsVersionInfoEx;

    osv = E_OS_UNKNOWN;

    if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )
    {
        // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.

        osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (!GetVersionEx((OSVERSIONINFO *) &osvi))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            goto Exit;
        }
    }

    switch (osvi.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_NT:
            if ( osvi.dwMajorVersion <= 4 )
                osv = E_WIN_NT;
            else if ( osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0 )
                osv = E_WIN2K;
            else if ( osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1 )
                osv = E_WHISTLER;

        case VER_PLATFORM_WIN32_WINDOWS:
            if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)
                osv = E_WIN95;
             else if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 10)
                 osv = E_WIN98;
             else if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)
                 osv = E_WIN_ME;
             break;
        case VER_PLATFORM_WIN32s:
            osv = E_WIN32_OTHERS;
            break;
    }

Exit:
    return hr;
}

BOOL IsMigrationDone()
{
    HKEY hk = NULL;

    LONG iRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMigrateStatusKeyName, 0, KEY_EXECUTE, &hk);
    RegCloseKey(hk);
    if (iRet == ERROR_SUCCESS) // the migration is done already
        return TRUE; // no further migration
    else
        return FALSE;
}
/*
BOOL IsW9xOrNT(FUSION_MSI_OS_VERSION &osv)
{
    osv = E_OS_UNKNOWN;
    if (SUCCEEDED(SxspGetOSVersion(osv)))
    {
        if ((osv != E_WIN98) && (osv != E_WIN2K))
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}
*/
/*
BOOL IsMsi20Installed()
{
    BOOL fInstalled = FALSE;
    HMODULE hMSI = ::LoadLibraryA("MSI");
    if (hMSI)
    {
        LPDLLGETVERSION pfVersion = (LPDLLGETVERSION)::GetProcAddress(hMSI, "DllGetVersion");
        if (pfVersion)
        {
            // MSI detected. Determine version.
            DLLVERSIONINFO VersionInfo;
            VersionInfo.cbSize = sizeof(DLLVERSIONINFO);
            (*pfVersion)(&VersionInfo);

            if (VersionInfo.dwMajorVersion < 2)
            {
                fInstalled = FALSE; // we only deal with Winfuse Assemblise installed using msi2.0.
            }
            else
            {
                fInstalled = TRUE;
            }
        }
        ::FreeLibrary(hMSI);
    }

    return fInstalled;

}
*/
void DbgPrintMessageBox(PCSTR pszFunc)
{
#if DBG
    CHAR str[256];
    sprintf(str, "In %s of migrate.dll", pszFunc);
    MessageBox(NULL, str, "migrate", MB_OK);
#endif
}

typedef HRESULT (_stdcall * PFN_MigrateFusionWin32AssemblyToXP)(PCWSTR pszInstallerDir);
LONG MigrateMSIInstalledWin32Assembly()
{
    LONG lResult = ERROR_SUCCESS;
    PFN_MigrateFusionWin32AssemblyToXP pfMigrateSystemNT;
    HMODULE hNTMig = ::LoadLibraryA("fusemig");
    if (!hNTMig)
    {
        // always return success. Its too late for any meaningful
        // error recovery
        return ERROR_SUCCESS;
    }

    pfMigrateSystemNT = (PFN_MigrateFusionWin32AssemblyToXP)GetProcAddress(hNTMig, "MsiInstallerDirectoryDirWalk");
    if (pfMigrateSystemNT)
    {
        lResult = (pfMigrateSystemNT)(NULL) & 0X0000FFFF;
    }
    FreeLibrary(hNTMig);

    //
    // set the RegKey about the work is done already
    //
    {

        DWORD dwDisposition = 0;
        HKEY hkey = NULL;
        if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, szSideBySideKeyName, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkey, NULL)){ // create or open
            RegCloseKey(hkey);
            HKEY hkey2 = NULL;
            if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, szMigrateStatusKeyName, 0, NULL, 0, KEY_EXECUTE, NULL, &hkey2, NULL)){ // not care it fails or successes
                RegCloseKey(hkey2);
            }
        }
        RegCloseKey(hkey);
    }

    // return the result from the actual migration call
    return lResult;
}


VOID SetRunOnceDeleteMigrationDoneRegKey()
{
    // Create if not exist or just open RegKey : HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce\Setup
    HKEY hk = NULL;
    if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRunOnceSetupRegKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hk, NULL))
    {
        // we do not care it success or fail, we could live with it
        RegSetValueEx(hk, szRunOnceValueName, 0, REG_SZ, (CONST BYTE *)szRunOnceValueCommandLine,
            strlen(szRunOnceValueCommandLine) + 1); // containing the trailing NULL
    }

    RegCloseKey(hk);

    return;
}

///////////////////////////////////////////////////////////////////////
//
// API of WIN-NT MIGRATION Dll
//
///////////////////////////////////////////////////////////////////////
LONG CALLBACK QueryMigrationInfoA(PMIGRATIONINFOA * VersionInfo)
{
    FUSION_MSI_OS_VERSION osv;
    DbgPrintMessageBox("QueryMigrationInfo");

    if (IsMigrationDone())
    {
        return ERROR_NOT_INSTALLED; // no further migration
    }
/*
    if (IsW9xOrNT(osv) == FALSE) // we only work on w9x and win2K
    {
        return ERROR_NOT_INSTALLED; // no further migration
    }
*/
    // only work for Win98 and win2k upgrade to winxp !!!
    if (VersionInfo != NULL)
    {
        if (g_MigrationInfo == NULL)
        {
            g_MigrationInfo = (PMIGRATIONINFOA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MIGRATIONINFOA));

            if (g_MigrationInfo == NULL)
                return ERROR_NOT_ENOUGH_MEMORY;

            g_MigrationInfo->Size = sizeof(MIGRATIONINFOA);
            g_MigrationInfo->StaticProductIdentifier = g_szProductId;
            g_MigrationInfo->DllVersion = 200;
            g_MigrationInfo->CodePageArray = NULL;
            g_MigrationInfo->SourceOs = (osv == E_WIN98 ? OS_WINDOWS9X : OS_WINDOWS2000);
            g_MigrationInfo->TargetOs = OS_WINDOWSWHISTLER;
            g_MigrationInfo->NeededFileList = NULL;
            g_MigrationInfo->VendorInfo = &g_VendorInfo;

            *VersionInfo = g_MigrationInfo;
        }
    }

    return ERROR_SUCCESS;
}

LONG InitializeOnSource()
{
    /*
    // attempt to load MSI.DLL and grab the version. If this fails, MSI is not
    // installed and there is no need for any further migration
    if (IsMsi20Installed())
        return ERROR_SUCCESS;
    else
    {
#if DBG
    MessageBox(NULL, "MSI version of 2.0 or above is NOT installed, QUIT the migration", "migrate", MB_OK);
#endif
        return ERROR_NOT_INSTALLED;
    }
    */
    return ERROR_SUCCESS;
}
///////////////////////////////////////////////////////////////////////
LONG __stdcall InitializeSrcA(LPCSTR WorkingDirectory, LPCSTR SourceDirectories, LPCSTR MediaDirectory, PVOID Reserved)
{
    DbgPrintMessageBox("InitializeSrcA");
    return InitializeOnSource();
}

/////////////////////////////////////////////////////////////////////////////
LONG CALLBACK GatherUserSettingsA(LPCSTR AnswerFile, HKEY UserRegKey, LPCSTR UserName, LPVOID Reserved)
{
    DbgPrintMessageBox("GatherUserSettingsA");
    return ERROR_SUCCESS;
}


LONG CALLBACK GatherSystemSettingsA(LPCSTR AnswerFile, LPVOID Reserved)
{
    DbgPrintMessageBox("GatherSystemSettingsA");
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Initialization routine on WinNT. Just stores of the migration
// working directory.
LONG CALLBACK InitializeDstA(LPCSTR WorkingDirectory, LPCSTR SourceDirectories, LPVOID Reserved)
{
    DbgPrintMessageBox("InitializeDstA");
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
LONG CALLBACK ApplyUserSettingsA(
    HINF AnswerFileHandle,
    HKEY UserRegKey,
    LPCSTR UserName,
    LPCSTR UserDomain,
    LPCSTR FixedUserName,
    LPVOID Reserved)
{
    DbgPrintMessageBox("ApplyUserSettingsA");
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
// Called once on NT
LONG CALLBACK ApplySystemSettingsA(HINF UnattendInfHandle, LPVOID Reserved)
{
    DbgPrintMessageBox("ApplySystemSettingsA");
    LONG lResult = MigrateMSIInstalledWin32Assembly();
    SetRunOnceDeleteMigrationDoneRegKey();

    return lResult;
}

BOOL
WINAPI
DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_MigrationInfo = NULL;
        break;

    case DLL_PROCESS_DETACH:
        if (g_MigrationInfo != NULL)
        {
            if (lpvReserved != NULL)
            {
                HeapFree(GetProcessHeap(), 0, g_MigrationInfo);
            }
            g_MigrationInfo = NULL;
        }
        break;
    }
    return TRUE;
}
///////////////////////////////////////////////////////////////////////
//
// API of WIN9X MIGRATION Dll
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// called by setup to extract migration DLL version and support
// information.
LONG CALLBACK QueryVersion(LPCSTR *ProductID, LPUINT DllVersion, LPINT *CodePageArray,
  LPCSTR *ExeNamesBuf, PVENDORINFO *VendorInfo)
{
    FUSION_MSI_OS_VERSION osv;
    DbgPrintMessageBox("QueryVersion");

    if (IsMigrationDone())
    {
        return ERROR_NOT_INSTALLED; // no further migration
    }
/*
    if (IsW9xOrNT(osv) == FALSE) // we only work on w9x and win2K
    {
        return ERROR_NOT_INSTALLED; // no further migration
    }
*/
    // product ID information
    *ProductID = g_szProductId;
    *DllVersion = 200;

    // DLL is language independent.
    *CodePageArray = NULL;

    // no EXE search is required
    *ExeNamesBuf = NULL;

    // vendor information
    *VendorInfo = &g_VendorInfo;

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
LONG __stdcall Initialize9x(LPCSTR WorkingDirectory, LPCSTR SourceDirectories, LPCSTR MediaDirectory)
{
    DbgPrintMessageBox("Initialize9x");
    return InitializeOnSource();
}

/////////////////////////////////////////////////////////////////////////////
LONG CALLBACK MigrateUser9x(HWND ParentWnd, LPCSTR AnswerFile, HKEY UserRegKey, LPCSTR UserName, LPVOID Reserved)
{
    DbgPrintMessageBox("MigrateUser9x");
    return ERROR_SUCCESS;
}


LONG CALLBACK MigrateSystem9x(HWND ParentWnd, LPCSTR AnswerFile, LPVOID Reserved)
{
    DbgPrintMessageBox("MigrateSystem9x");
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
LONG CALLBACK InitializeNT(LPCWSTR WorkingDirectory, LPCWSTR SourceDirectories, LPVOID Reserved)
{
    DbgPrintMessageBox("InitializeNT");
    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////
LONG CALLBACK MigrateUserNT(HINF AnswerFileHandle, HKEY UserRegKey, LPCWSTR UserName, LPVOID Reserved)
{
    DbgPrintMessageBox("MigrateUserNT");
    return ERROR_SUCCESS;
}

typedef HRESULT (_stdcall * PFN_MigrateFusionWin32AssemblyToXP)(PCWSTR pszInstallerDir);
///////////////////////////////////////////////////////////////////////
LONG CALLBACK MigrateSystemNT(HINF UnattendInfHandle, LPVOID Reserved)
{
    DbgPrintMessageBox("MigrateSystemNT");
    LONG lResult = MigrateMSIInstalledWin32Assembly();
    SetRunOnceDeleteMigrationDoneRegKey();

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ActCtx.rc
//
#define IDS_PROJNAME                    100
#define IDR_ACTCTX                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dll\sxsoai.c ===
typedef int pragma_warning_disable_4206_nonstandard_extension_used_translation_unit_is_empty;
#include "sxsoa_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dll\stdinc.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C91CEDB4_CDFF_4C2E_9D82_E440B931551F__INCLUDED_)
#define AFX_STDAFX_H__C91CEDB4_CDFF_4C2E_9D82_E440B931551F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C91CEDB4_CDFF_4C2E_9D82_E440B931551F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\dll\sxsoapsi.c ===
typedef int pragma_warning_disable_4206_nonstandard_extension_used_translation_unit_is_empty;
#include "sxsoaps_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\ps\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sxsoaps.rc
//
#define IDS_PROJNAME                    100
#define IDR_SXSOAPS                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\ps\sxsoapsp.c ===
#pragma warning(disable: 4310 4512 4610 4510 4152 4232)

#include "sxsoaps_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\oa\ps\sxsoapsi.c ===
#include "sxsoaps_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependentblob.cpp ===
#include "stdinc.h"
#include "lhport.h"
#include "windows.h"
#include "numberof.h"
#include "positionindependentblob.h"
#include "fusionhandle.h"

#undef ASSERT
#undef ASSERT_NTC /* NTC == no trace context */

#if DBG
void AssertFunction(PCSTR s) { ASSERT2_NTC(FALSE, s); }
#define ASSERT(expr) ((expr) ? TRUE : (AssertFunction(#expr),FALSE))
#define ASSERT_NTC(expr) ((expr) ? TRUE : (AssertFunction(#expr),FALSE))
#else
#define ASSERT_NTC(expr) ((expr) ? TRUE : FALSE)
#endif

void *
CPositionIndependentOperatorNew::operator new(
	size_t n,
	CPositionIndependentBlob * Container
    )
{
	return Container->OperatorNew(n);
}

void CPositionIndependentBlob::OutOfMemory()
{
    OutputDebugStringA("SXS_PIBLOB: out of memory\n");
    F::CErr::ThrowWin32(FUSION_WIN32_ALLOCFAILED_ERROR);
}

CPositionIndependentBlob::CPositionIndependentBlob()
{
	ZeroMemory(this, sizeof(*this));
}

CPositionIndependentBlob::~CPositionIndependentBlob()
{
}

void
CPositionIndependentBlob::Alloc(
	CPositionIndependentBlob * Container,
	ULONG NumberOfBytes,
    ULONG * Offset
    )
{
	if (Container != NULL)
    {
		return Container->Alloc(NumberOfBytes, Offset);
    }
	return this->Alloc(NumberOfBytes, Offset);
}

//
// CONSIDER: NtExtendSection for pagefile mappings.
//

BOOL CPositionIndependentBlob::IsPagefileMapping()
{
    return (m_FileHandle == INVALID_HANDLE_VALUE);
}

void GetFirstError(DWORD & FirstError)
{
    if (FirstError == NO_ERROR)
        FirstError = F::GetLastWin32Error();
}

void CPositionIndependentBlob::Free(const BYTE * Pointer)
{
    FN_PROLOG_VOID_THROW

    CBlock InUseBlock;
    InUseBlock.m_Offset = static_cast<ULONG>((Pointer - GetBasePointer()));
    InUseBlock.m_Size = 0;
    CBlockByOffsetSet::iterator InUseByOffsetIterator = m_InUseBlocksSortedByOffset.lower_bound(InUseBlock);
    if (!ASSERT_NTC(InUseByOffsetIterator != m_InUseBlocksSortedByOffset.end()))
    {
        return;
    }
    InUseBlock = *InUseByOffsetIterator;
    m_InUseBlocksSortedByOffset.erase(InUseByOffsetIterator);
    CBlockByOffsetSet::iterator End = m_FreeBlocksSortedByOffset.end();
    CBlockByOffsetSet::iterator PrevFreeBlockIterator = m_FreeBlocksSortedByOffset.lower_bound(InUseBlock);
    CBlockByOffsetSet::iterator NextFreeBlockIterator = m_FreeBlocksSortedByOffset.upper_bound(InUseBlock);
    CBlockByOffsetSet::iterator FreeByOffsetToErase = End;

    CBlock BiggerFreeBlock;
    BiggerFreeBlock.m_Size = InUseBlock.m_Size;

    if (PrevFreeBlockIterator != End && !InUseBlock.Neighbors(*PrevFreeBlockIterator))
        PrevFreeBlockIterator = End;
    if (NextFreeBlockIterator != End && !InUseBlock.Neighbors(*NextFreeBlockIterator))
        NextFreeBlockIterator = End;
    switch (
            (ULONG(PrevFreeBlockIterator != End) << 1) | ULONG(NextFreeBlockIterator != End)
           )
    {
    case 3:
        // freed between two free blocks, merge all three
        const_cast<ULONG&>(PrevFreeBlockIterator->m_Size) += InUseBlock.m_Size;
        const_cast<ULONG&>(PrevFreeBlockIterator->m_Size) += NextFreeBlockIterator->m_Size;
        BiggerFreeBlock = *PrevFreeBlockIterator;
        FreeByOffsetToErase = NextFreeBlockIterator;
        break;
    case 2:
        // freed with a free block to the left, merge with left
        const_cast<ULONG&>(PrevFreeBlockIterator->m_Size) += InUseBlock.m_Size;
        BiggerFreeBlock = *PrevFreeBlockIterator;
        FreeByOffsetToErase = NextFreeBlockIterator;
        break;
    case 1:
        // freed with free block to the right, merge with right
        const_cast<ULONG&>(NextFreeBlockIterator->m_Offset) -= InUseBlock.m_Size;
        const_cast<ULONG&>(NextFreeBlockIterator->m_Size)   += InUseBlock.m_Size;
        BiggerFreeBlock = *NextFreeBlockIterator;
        FreeByOffsetToErase = PrevFreeBlockIterator;
        break;
    case 0:
        // freed between two inuse blocks, no merge
        // BUG Free should not allocate memory. This is avoidable by keeping empty blocks at the ends.
        m_FreeBlocksSortedByOffset.insert(BiggerFreeBlock);
        break;
    }

    if (PrevFreeBlockIterator != End)
        m_FreeBlocksSortedBySize.erase(*PrevFreeBlockIterator);
    if (NextFreeBlockIterator != End)
        m_FreeBlocksSortedBySize.erase(*NextFreeBlockIterator);
    if (FreeByOffsetToErase != End)
        m_FreeBlocksSortedByOffset.erase(FreeByOffsetToErase);

    m_PendingFreeBySize += 1;

    FN_EPILOG_THROW;
}

void CPositionIndependentBlob::RecalculateBlocksBySize()
{
    if (m_PendingFreeBySize == 0)
        return;
    // UNDONE
    m_PendingFreeBySize = 0;
}

void
CPositionIndependentBlob::GetBounds(
    const BYTE * Bounds[2]
    )
{
    FN_PROLOG_VOID_THROW

    Bounds[0] = GetBasePointer();
    Bounds[1] = Bounds[0] + m_AllocatedSize;;

    FN_EPILOG_THROW;
}

void
CPositionIndependentBlob::IsInBlob(
    const BYTE * Data,
    ULONG Size,
    BOOL * IsInBlob
    )
{
    FN_PROLOG_VOID_THROW

    const BYTE * Bounds[2];

    GetBounds(Bounds);
    *IsInBlob = (Data >= Bounds[0] && (Data + Size) < Bounds[1]);

    FN_EPILOG_THROW;
}

void Reserve()
{
    // UNDONE
}

void CPositionIndependentBlob::Alloc(ULONG NumberOfBytes, ULONG * Offset)
{
    FN_PROLOG_VOID_THROW

    CBlock Block;
    Block.m_Offset = 0;
    Block.m_Size = NumberOfBytes;

    RecalculateBlocksBySize();

    CBlockBySizeSet::iterator i = m_FreeBlocksSortedBySize.lower_bound(Block);
    if (i == m_FreeBlocksSortedBySize.end() && m_pmfCompact != NULL)
    {
        RecalculateBlocksBySize();
        i = m_FreeBlocksSortedBySize.lower_bound(Block);
    }
    if (i == m_FreeBlocksSortedBySize.end() && m_pmfCompact != NULL)
    {
        (this->*m_pmfCompact)();
        i = m_FreeBlocksSortedBySize.lower_bound(Block);
    }
    if (i == m_FreeBlocksSortedBySize.end())
    {
        Grow(NumberOfBytes);
        i = m_FreeBlocksSortedBySize.lower_bound(Block);
    }
    if (i == m_FreeBlocksSortedBySize.end())
    {
        OutOfMemory();
        return;
    }
    CBlock Found = *i;
    CBlock FitFound = Found;
    ULONG  RemainderSize = (Found.m_Size - NumberOfBytes);
    FitFound.m_Size = NumberOfBytes;

    //
    // erase before we mess with the ordering (we would create ties otherwise)
    //
    m_FreeBlocksSortedByOffset.erase(*i);
    m_FreeBlocksSortedBySize.erase(i);

    if (RemainderSize != 0)
    {
        CBlockByOffsetSet::iterator End = m_FreeBlocksSortedByOffset.end();
        CBlockByOffsetSet::iterator PrevFreeBlockIterator = m_FreeBlocksSortedByOffset.lower_bound(Found);
        CBlockByOffsetSet::iterator NextFreeBlockIterator = m_FreeBlocksSortedByOffset.upper_bound(Found);

        if (PrevFreeBlockIterator != End && !Found.Neighbors(*PrevFreeBlockIterator))
            PrevFreeBlockIterator = End;
        if (NextFreeBlockIterator != End && !Found.Neighbors(*NextFreeBlockIterator))
            NextFreeBlockIterator = End;
        switch (
                (ULONG(PrevFreeBlockIterator != End) << 1) | ULONG(NextFreeBlockIterator != End)
               )
        {
        case 3:
            ASSERT_NTC(!"Should not be free on both sides of a free.");
            break;
        case 2:
            m_FreeBlocksSortedBySize.erase(*PrevFreeBlockIterator);
            const_cast<ULONG&>(PrevFreeBlockIterator->m_Size) += RemainderSize;
            m_FreeBlocksSortedBySize.insert(*PrevFreeBlockIterator);
            FitFound.m_Offset += RemainderSize;
            break;
        case 1:
            m_FreeBlocksSortedBySize.erase(*NextFreeBlockIterator);
            const_cast<ULONG&>(NextFreeBlockIterator->m_Offset) -= RemainderSize;
            const_cast<ULONG&>(NextFreeBlockIterator->m_Size) += RemainderSize;
            m_FreeBlocksSortedBySize.insert(*NextFreeBlockIterator);
            break;
        case 0:
            break;
        }
    }
    m_InUseBlocksSortedByOffset.insert(FitFound);
    *Offset = FitFound.m_Offset;

    FN_EPILOG_THROW;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependenthashtable.cpp ===
#include "stdinc.h"
#include "lhport.h"
#include "windows.h"
#include "numberof.h"
#include "positionindependenthashtable.h"

void
CPositionIndependentHashTable::Alloc(
    ULONG NumberOfBytes,
    ULONG * Offset
    )
{
	Base::Alloc(NumberOfBytes, Offset);
}

CPositionIndependentHashTable::CPositionIndependentHashTable()
:
	m_NumberOfHashTables(0),
	m_OffsetToHashTables(0)
{
}

void CPositionIndependentHashTable::ThrAddHashTable(
	const CHashTableInit * Init
	)
{
	ThrAddHashTables(1, Init);
}

void CPositionIndependentHashTable::ThrAddHashTables(
	ULONG NumberOfHashTables,
	const CHashTableInit * Inits
	)
{
	CHashTable * PointerToHashTables = 0;

	m_NumberOfHashTables = NumberOfHashTables;
	ULONG SizeOfHashes = NumberOfHashTables * sizeof(*PointerToHashTables);
    ULONG OffsetToHashTables = 0;
    Alloc(SizeOfHashes, &OffsetToHashTables);
	m_OffsetToHashTables = OffsetToHashTables;
	OffsetToPointer(OffsetToHashTables, &PointerToHashTables);

	for ( ULONG HashTableIndex = 0 ; HashTableIndex != NumberOfHashTables ; ++HashTableIndex)
	{
		CHashTableBucket * PointerToBuckets = 0;

		CHashTable * PointerToHashTable = &PointerToHashTables[HashTableIndex];

		PointerToHashTable->m_NumberOfElementsInTable = 0;
		PointerToHashTable->m_Compare = Inits[HashTableIndex].m_Compare;
		PointerToHashTable->m_Hash = Inits[HashTableIndex].m_Hash;

		ULONG NumberOfBuckets = Inits[HashTableIndex].m_NumberOfBuckets;
		PointerToHashTable->m_NumberOfBuckets = NumberOfBuckets;

		ULONG OffsetToBuckets;
        Alloc(NumberOfBuckets * sizeof(*PointerToBuckets), &OffsetToBuckets);
		PointerToHashTable->m_OffsetToBuckets = OffsetToBuckets;
		OffsetToPointer(OffsetToBuckets, &PointerToBuckets);

		for (ULONG BucketIndex = 0 ; BucketIndex != NumberOfBuckets ; ++BucketIndex )
		{
			PointerToBuckets[BucketIndex].m_AllocatedElementsInBucket = 0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependenthashtableaccessor.cpp ===
#include "stdinc.h"
#include "lhport.h"
#include "positionindependenthashtableaccessor.h"

typedef CPositionIndependentHashTable::CHashTable       CHashTable;
typedef CPositionIndependentHashTable::CHashTableBucket CHashTableBucket;

ULONG
CPositionIndependentHashTableAccessor::PointerToOffset(const BYTE * p)
{
    return m_PositionIndependentTable->PointerToOffset(p);
}

CPositionIndependentHashTableAccessor::CPositionIndependentHashTableAccessor(
        CPositionIndependentHashTable * PositionIndependentTable,
        ULONG HashTableIndex
        )
    : m_PositionIndependentTable(PositionIndependentTable),
      m_HashTableIndex(HashTableIndex),
      m_Key(NULL),
      m_PointerToHashTables(NULL),
      m_PointerToBucket(NULL),
      m_KeyHash(0),
      m_KeyIndex(~0UL),
      m_KeyHashIsValid(FALSE)
{ }

void
CPositionIndependentHashTableAccessor::GetPointerToHashTable(CHashTable ** Result)
{
    return this->GetPointerToHashTable(m_HashTableIndex, Result);
}

CHashTable *
CPositionIndependentHashTableAccessor::GetPointerToHashTable()
{
    return this->GetPointerToHashTable(m_HashTableIndex);
}

void
CPositionIndependentHashTableAccessor::GetPointerToHashTable(ULONG HashTableIndex, CHashTable ** Result)
{
    *Result = GetPointerToHashTable(HashTableIndex);
}

CHashTable *
CPositionIndependentHashTableAccessor::GetPointerToHashTable(ULONG HashTableIndex)
{
    if (m_PointerToHashTables == NULL)
    {
        OffsetToPointer(m_PositionIndependentTable->m_OffsetToHashTables, &m_PointerToHashTables);
    }

    return &m_PointerToHashTables[HashTableIndex];
}

BOOL
CPositionIndependentHashTableAccessor::AreKeysEqual(const BYTE * Key1, const BYTE * Key2)
{
    return (*GetPointerToHashTable()->m_Equal.pfn)(Key1, Key2);
}

void
CPositionIndependentHashTableAccessor::GetKeyHashNoCache(const BYTE * Key, ULONG * KeyHash)
{
    *KeyHash = (*GetPointerToHashTable()->m_Hash.pfn)(Key);
}

void
CPositionIndependentHashTableAccessor::GetKeyHash(const BYTE * Key, ULONG * KeyHash)
{
    if (Key == m_Key && m_KeyHashIsValid)
    {
        *KeyHash = m_KeyHash;
        return;
    }

    GetKeyHashNoCache(Key, KeyHash);
    m_PointerToBucket = NULL;
    m_KeyHash = *KeyHash;
    m_Key = Key;
    m_KeyHashIsValid = TRUE;
}

BOOL
CPositionIndependentHashTableAccessor::IsKeyPresent(const BYTE * Key)
{
    BOOL Result = FALSE;
    CHashTable * PointerToHashTable = 0;
	CHashTableBucket * PointerToBucket = 0;
	ULONG Hash = 0;
	ULONG BucketIndex = 0;
	ULONG AllocatedElementsInBucket = 0;
    CHashTableElement * PointerToElements = 0;

	if (IsEmpty())
    {
        Result = FALSE;
        goto Exit;
    }

    GetPointerToHashTable(&PointerToHashTable);
	GetHashTableBucketForKey(Key, &PointerToBucket);
	GetKeyHash(Key, &Hash);
	BucketIndex = (m_KeyHash % PointerToHashTable->m_NumberOfBuckets);

	OffsetToPointer(PointerToHashTable->m_OffsetToBuckets + BucketIndex * sizeof(*PointerToBucket), &PointerToBucket);
	AllocatedElementsInBucket = PointerToBucket->m_AllocatedElementsInBucket;
	if (AllocatedElementsInBucket == 0)
    {
        Result = FALSE;
        goto Exit;
    }

    OffsetToPointer(PointerToBucket->m_OffsetToElements, &PointerToElements);

	for (ULONG IndexIntoBucket = 0 ; IndexIntoBucket != AllocatedElementsInBucket ; ++IndexIntoBucket )
	{
		CHashTableElement * Element = &PointerToElements[IndexIntoBucket];
		if (Element->m_PseudoKey == Hash)
		{
			PBYTE PointerToKey;
			OffsetToPointer(Element->m_OffsetToKey, &PointerToKey);
			if ((*PointerToHashTable->m_Equal.pfn)(Key, PointerToKey))
            {
                Result = TRUE;
                goto Exit;
            }
		}
	}
Exit:
	return Result;
}


void
CPositionIndependentHashTableAccessor::GetHashTableBucketForKey(
    const BYTE * Key,
    CHashTableBucket ** Result
    )
{
    ULONG Hash = 0;
	CHashTable * PointerToHashTable = 0;
	CHashTableBucket * PointerToBucket = 0;
    ULONG BucketIndex = 0;
    ULONG NumberOfElementsInTable = 0;

    *Result = NULL;

    if (Key == m_Key && m_KeyHashIsValid && m_PointerToBucket != NULL)
    {
        *Result = m_PointerToBucket;
        goto Exit;
    }

    if (IsEmpty())
    {
        goto Exit;
    }

    GetKeyHash(Key, &Hash);
	GetPointerToHashTable(&PointerToHashTable);
	NumberOfElementsInTable = PointerToHashTable->m_NumberOfElementsInTable;
	if (NumberOfElementsInTable == 0)
    {
        goto Exit;
    }
	BucketIndex = (Hash % PointerToHashTable->m_NumberOfBuckets);

	OffsetToPointer(PointerToHashTable->m_OffsetToBuckets + BucketIndex * sizeof(*PointerToBucket), &PointerToBucket);

    *Result = PointerToBucket;
    m_PointerToBucket = PointerToBucket;
Exit:
    ;
}

BOOL CPositionIndependentHashTableAccessor::IsEmpty()
{
	if (m_PositionIndependentTable->m_NumberOfHashTables == 0)
		return TRUE;

    if (GetPointerToHashTable()->m_NumberOfElementsInTable == 0)
        return TRUE;

	return FALSE;
}


void
CPositionIndependentHashTableAccessor::GetBounds(
    const BYTE * Bounds[2]
    )
{
    return m_PositionIndependentTable->GetBounds(Bounds);
}

void
CPositionIndependentHashTableAccessor::IsInBlob(
    const BYTE * Pointer,
    ULONG Size,
    BOOL * IsInBlob
    )
{
    return m_PositionIndependentTable->IsInBlob(Pointer, Size, IsInBlob);
}

void
CPositionIndependentHashTableAccessor::SetAt(
    const BYTE *    Key,
    ULONG           KeySize,
    const BYTE *    Value,
    ULONG           ValueSize
    )
{
    FN_PROLOG_VOID_THROW

    CHashTableBucket * Result = 0;
    ULONG Hash = 0;
	CHashTable * PointerToHashTable = 0;
    CHashTableBucket Bucket = { 0 };
	CHashTableBucket * PointerToBucket = 0;
    ULONG BucketIndex = 0;
    ULONG NumberOfElementsInTable = 0;
    ULONG NumberOfBuckets = 0;
    ULONG KeyOffset = 0;
    ULONG ValueOffset = 0;
    BOOL KeyIsInBlob = 0;
    BOOL ValueIsInBlob = 0;
    BYTE * BasePointer = BasePointer = GetBasePointer();
    GetKeyHash(Key, &Hash);
	GetPointerToHashTable(&PointerToHashTable);
	NumberOfElementsInTable = PointerToHashTable->m_NumberOfElementsInTable;
    NumberOfBuckets = PointerToHashTable->m_NumberOfBuckets;

    //
    // Do this before we get buckets.
    //
    IsInBlob(Key, KeySize, &KeyIsInBlob);
    IsInBlob(Value, ValueSize, &ValueIsInBlob);
    if (KeyIsInBlob)
        Key = BasePointer + KeyOffset;
    if (ValueIsInBlob)
        Value = BasePointer + ValueOffset;

    if (NumberOfBuckets == 0)
    {
        GrowNumberOfBuckets(17);
        NumberOfBuckets = PointerToHashTable->m_NumberOfBuckets;

        if (KeyIsInBlob)
            OffsetToPointer(KeyOffset, &Key);
        if (ValueIsInBlob)
            OffsetToPointer(ValueOffset, &Value);
    }
	BucketIndex = (Hash % NumberOfBuckets);
	OffsetToPointer(PointerToHashTable->m_OffsetToBuckets + BucketIndex * sizeof(*PointerToBucket), &PointerToBucket);
    Bucket = *PointerToBucket;
    CHashTableElement * Elements;
    OffsetToPointer(Bucket.m_OffsetToElements, &Elements);

    ULONG FreeElementIndex = 0;
    ULONG FoundElementIndex = 0;
    BOOL  DidFindFreeElement = FALSE;
    BOOL  DidFindElement = FALSE;

    for (ULONG ElementIndex = 0 ; ElementIndex != Bucket.m_AllocatedElementsInBucket; ++ElementIndex)
    {
        if (Elements[ElementIndex].m_InUse)
        {
            if (Hash == Elements[ElementIndex].m_PseudoKey
                && AreKeysEqual(Key, BasePointer + Elements[ElementIndex].m_OffsetToKey))
            {
                FoundElementIndex = ElementIndex;
                DidFindElement = TRUE;
            }
        }
        else if (!DidFindFreeElement)
        {
            FreeElementIndex = ElementIndex;
            DidFindFreeElement = TRUE;
        }
        if (DidFindFreeElement && DidFindElement)
            break;
    }

    ULONG NeededBytes = 0;
    ULONG NeededBlocks = 0;

    ULONG NeededElementBytes = 0;
    if (!DidFindElement && !DidFindFreeElement)
    {
        //
        // REVIEW Should we double, or just add one?
        //
        NeededElementBytes = sizeof(CHashTableElement) * (Bucket.m_AllocatedElementsInBucket + 1);
        NeededBytes += NeededElementBytes;
        NeededBlocks += 1;
    }
    else
    {
        NeededElementBytes = 0;
    }

    ULONG NeededKeyBytes = 0;
    if (KeySize <= sizeof(CHashTableElement().m_SmallKey)
        || KeyIsInBlob
        || DidFindElement
        || (DidFindFreeElement && Elements[FreeElementIndex].m_KeySize >= ValueSize)
        )
    {
        NeededKeyBytes = 0;
    }
    else
    {
        NeededKeyBytes = KeySize;
        NeededBytes += KeySize;
        NeededBlocks += 1;
    }
    ULONG NeededValueBytes = 0;
    if (ValueSize <= sizeof(CHashTableElement().m_SmallValue)
        || ValueIsInBlob
        || (DidFindElement && Elements[FoundElementIndex].m_ValueAllocatedSize >= ValueSize)
        || (DidFindFreeElement && Elements[FreeElementIndex].m_ValueAllocatedSize >= ValueSize)
        )
    {
        NeededValueBytes = 0;

        // NOTE: what about replacement with "equal" values?
    }
    else
    {
        NeededValueBytes = ValueSize;
        NeededBytes += ValueSize;
        NeededBlocks += 1;
    }

    Reserve(NeededBytes, NeededBlocks);

    if (NeededElementBytes != 0)
    {
        ULONG NewElementsOffset;

        Alloc(NeededElementBytes, &NewElementsOffset);

        CopyMemory(BasePointer + NewElementsOffset, Elements, NeededElementBytes - sizeof(CHashTableElement));

        Elements = reinterpret_cast<CHashTableElement*>(BasePointer + NewElementsOffset);
    }


    // undone right here

    FN_EPILOG_THROW;
}

PBYTE
CPositionIndependentHashTableAccessor::GetBasePointer()
{
    return m_PositionIndependentTable->GetBasePointer();
}

void
CPositionIndependentHashTableAccessor::Alloc(ULONG NumberOfBytes, ULONG * Offset)
{
    PBYTE BaseBefore = GetBasePointer();
    m_PositionIndependentTable->Alloc(NumberOfBytes, Offset);
    if (GetBasePointer() != BaseBefore)
    {
        m_PointerToBucket = NULL;
        m_PointerToHashTables = NULL;
        m_PointerToBucket = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependenthashtableiterator.h ===
#pragma once

class CPositionIndependentHashTable;

class CPositionIndependentHashTableIterator
{
public:
    CPositionIndependentHashTableIterator(CPositionIndependentHashTable * = NULL);
    ~CPositionIndependentHashTableIterator();

    void    Reset(CPositionIndependentHashTable * = NULL);

    ULONG GetNumberOfElements();
    bool    GetCurrentElement(PBYTE & Key, PBYTE & Value);
    PBYTE   GetKey();
    PBYTE   GetValue();
    bool    MoveNext();
    bool    MovePrevious();
    bool    RemoveCurrentAndMoveNext();
    bool    RemoveCurrentAndMovePrevious();

//protected:

    typedef CPositionIndependentHashTable::CHashTable           CHashTable;
    typedef CPositionIndependentHashTable::CHashTableBucket     CHashTableBucket;
    typedef CPositionIndependentHashTable::CHashTableElement    CHashTableElement;

    CPositionIndependentHashTable * m_PositionIndependentHashTable;
    CHashTableBucket              * m_PointerToBucket;

    PBYTE                           m_CurrentPosition;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependenthashtable.h ===
#pragma once

#include "positionindependentblob.h"

#include "pshpack8.h"

class CHashTableInit;
class CPositionIndependentHashTable;

typedef int   (__stdcall PFN_COMPARE_FUNCTION)(const BYTE * Key1, const BYTE * Key2);
typedef BOOL  (__stdcall PFN_EQUAL_FUNCTION)(const BYTE * Key1, const BYTE * Key2);
typedef ULONG (__stdcall PFN_HASH_FUNCTION)(const BYTE * Key);

class CPositionIndependentHashTable : public CPositionIndependentBlob
//
// multiple hashes over the same keys/values
//
{
private:
    typedef CPositionIndependentBlob Base;
public:
    CPositionIndependentHashTable();
    ~CPositionIndependentHashTable();

    ULONG   PointerToOffset(const BYTE *);

    ULONG   m_NumberOfHashTables;
    ULONG   m_OffsetToHashTables;  // bytes

    void    Alloc(ULONG NumberOfBytes, ULONG * Offset);

    class CHashTableElement
    {
    public:
        ULONG    m_PseudoKey;       // aka Hash
        ULONG    m_KeySize            : 31;
        ULONG    m_ValueSize          : 31;
        ULONG    m_ValueAllocatedSize : 31;
        ULONG    m_InUse              : 1;
        ULONG    m_Spare              : 3;
        union
        {
            ULONG       m_OffsetToKey;
            ULONGLONG   m_SmallKey;
        };
        union
        {
            ULONG       m_OffsetToValue;
            ULONGLONG   m_SmallValue;
        };
    };

public:
    class CHashTableBucket
    {
    public:
        ULONG   m_AllocatedElementsInBucket;
        ULONG   m_OffsetToElements;
    };

    class CHashTable : public CPositionIndependentOperatorNew
    {
    public:
        CHashTable(CPositionIndependentBlob * Container);

        CFunction<PFN_COMPARE_FUNCTION> m_Compare;
        CFunction<PFN_EQUAL_FUNCTION>   m_Equal;
        CFunction<PFN_HASH_FUNCTION>    m_Hash;
        ULONG                           m_NumberOfBuckets;
        ULONG                           m_NumberOfElementsInTable;
        ULONG                           m_OffsetToBuckets;
    };

    void ThrAddHashTable(const CHashTableInit *);
    void ThrAddHashTables(ULONG NumberOfHashTables, const CHashTableInit *);
};

#include "poppack.h"

class CHashTableInit
{
public:
    ULONG                           m_NumberOfBuckets;
    CFunction<PFN_COMPARE_FUNCTION> m_Compare;
    CFunction<PFN_HASH_FUNCTION>    m_Hash;
    CFunction<PFN_EQUAL_FUNCTION>   m_Equal;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependenthashtableaccessor.h ===
#pragma once

#include "positionindependentblob.h"
#include "positionindependenthashtable.h"

class CPositionIndependentHashTableAccessor
{
private:
    CPositionIndependentHashTableAccessor(const CPositionIndependentHashTableAccessor &);
    void operator=(const CPositionIndependentHashTableAccessor &);
public:

    ~CPositionIndependentHashTableAccessor() { }

    CPositionIndependentHashTableAccessor(
            CPositionIndependentHashTable * PositionIndependentTable = NULL,
            ULONG HashTableIndex = 0
            );

    BYTE Init(
            CPositionIndependentHashTable * PositionIndependentTable,
            ULONG HashTableIndex = 0
            );

    void    GetBounds(const BYTE * Bounds[2]);
    void    IsInBlob(const BYTE * Pointer, ULONG Size, BOOL * IsInBlob);
    BOOL    IsEmpty();
    BOOL    IsKeyPresent(const BYTE * Key);
    void    SetAt(const BYTE * Key, ULONG KeySize, const BYTE * Value, ULONG ValueSize);
    void    GetAt(const BYTE * Key, const BYTE ** Value, ULONG * ValueSize = NULL);
    void    Remove(const BYTE * Key);

    typedef CPositionIndependentHashTable::CHashTable           CHashTable;
    typedef CPositionIndependentHashTable::CHashTableBucket     CHashTableBucket;
    typedef CPositionIndependentHashTable::CHashTableElement    CHashTableElement;

//protected:

    CPositionIndependentHashTable * const   m_PositionIndependentTable;
    CHashTable *                            m_PointerToHashTables;
    const BYTE *                            m_Key;
    CHashTableBucket *                      m_PointerToBucket;
    ULONG                                   m_KeyHash;
    ULONG                                   m_KeyIndex;
    ULONG const                             m_HashTableIndex;
    BOOL                                    m_KeyHashIsValid;

    //const BYTE * OffsetToPointer(ULONG Offset) { return m_PositionIndependentTable->OffsetToPointer(Offset); }
    //template <typename T> void OffsetToPointer(ULONG Offset, T *& Pointer) { m_PositionIndependentTable->OffsetToPointer(Offset, Pointer); }
    template <typename T> void OffsetToPointer(ULONG Offset, T ** Pointer) { m_PositionIndependentTable->OffsetToPointer(Offset, Pointer); }

    ULONG   PointerToOffset(const BYTE * p);
    void PointerToOffset(const BYTE * p, ULONG * Offset) { *Offset = PointerToOffset(p); }

    void    GetHashTableBucketForKey(const BYTE * Key, CHashTableBucket **);

    void    GetKeyHash(const BYTE * Key, ULONG * KeyHash);
    void    GetKeyHashNoCache(const BYTE * Key, ULONG * KeyHash);
    BOOL    AreKeysEqual(const BYTE * Key1, const BYTE * Key2);

    void    GetHashTableBucket(const BYTE * Key, CHashTableBucket **);

    void         GetPointerToHashTable(CHashTable **);
    CHashTable * GetPointerToHashTable();
    void         GetPointerToHashTable(ULONG HashTableIndex, CHashTable **);
    CHashTable * GetPointerToHashTable(ULONG HashTableIndex);

    void    Alloc(ULONG NumberOfBytes, ULONG * Offset);

    void GrowNumberOfBuckets(ULONG NumberOfBuckets);

    PBYTE GetBasePointer();

    void Reserve(ULONG Bytes, ULONG Blocks) { /* UNDONE */ }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependentblob.h ===
#pragma once

#include "lhport.h"
#include "pshpack8.h"

class CPositionIndependentBlob;

template <typename T>
class CFunction
{
public:
    union
    {
        T       * pfn;
        ULONGLONG ull;
    };
};

typedef void (__stdcall * PFN_GROW_FUNCTION)(CPositionIndependentBlob * This);

class CPositionIndependentOperatorNew
{
public:
    void * operator new(size_t n, CPositionIndependentBlob * Container);
};


//
// aka position independent heap, with support for persistance to disk
//
class CPositionIndependentBlob : public CPositionIndependentOperatorNew
{
public:
//protected:
    void OutOfMemory();

public:

    static void ThrowWin32Error(DWORD);

    BOOL IsPagefileMapping();

    union
    {
        ULONGLONG ll;
        CPositionIndependentBlob * m_Container;
    };

    CPositionIndependentBlob();
    ~CPositionIndependentBlob();

    BOOL        Write(HANDLE FileHandle, ULONGLONG Offset);
    BOOL        Read(HANDLE FileHandle, ULONGLONG Offset);

    void GetBounds(const BYTE * Bounds[2]);
    void IsInBlob(const BYTE * Pointer, ULONG Size, BOOL * IsInBlob);

    class CBlock
    {
    public:
        CBlock() : m_Offset(0), m_Size(0) { }

        ULONG m_Offset;
        ULONG m_Size;

        bool operator==(const CBlock & x) const
        {
            if (this == &x)
                return true;
            if (m_Offset != x.m_Offset)
                return false;
            if (m_Size != x.m_Size)
                return false;
            return true;
        }

        typedef std::pair<ULONG, ULONG> CPair;
        class CLessThanByOffset
        {
        public:
            bool operator()(const CBlock & x, const CBlock & y) const
            {
                return CPair(x.m_Offset, x.m_Size) < CPair(y.m_Offset, y.m_Size);
            }
        };

        class CLessThanBySize
        {
        public:
            bool operator()(const CBlock & x, const CBlock & y) const
            {
                return CPair(x.m_Size, x.m_Offset) < CPair(y.m_Size, y.m_Offset);
            }
        };

        static bool Neighbors(const CBlock & x, const CBlock & y)
        {
            if (y.m_Offset + y.m_Size == x.m_Offset)
                return true;
            if (x.m_Offset + x.m_Size == y.m_Offset)
                return true;
            return false;
        }

        bool Neighbors(const CBlock & x) const
        {
            return Neighbors(*this, x);
        }
    };

    union
    {
        struct
        {
            ULONG       m_HeaderSize;
            ULONG       m_HeaderVersion;

            ULONG       m_BitsInPointer;
            BYTE        m_IsBigEndian;
            BYTE        m_Spare1[3];

            union
            {
                ULONGLONG   ll;
                HANDLE      m_FileHandle;
            };
            union
            {
                ULONGLONG   ll;
                HANDLE      m_FileMapping;
            };
            ULONGLONG   m_FileOffset;

            union
            {
                ULONGLONG   m_Base;
                PBYTE       m_BasePointer;
            };

            ULONG       m_AllocatedSize;
            ULONG       m_UsedSize;
            ULONG       m_FreeSize;

            ULONG       m_OffsetToFreeBlocks;
            ULONG       m_NumberOfFreeBlocks;
            CBlock      m_MostRecentlyFreedBlock;
        };
        BYTE Page[0x2000];
    };

    typedef std::set<CBlock, CBlock::CLessThanByOffset> CBlockByOffsetSet;
    typedef std::set<CBlock, CBlock::CLessThanBySize>   CBlockBySizeSet;

    ULONG               m_PendingFreeBySize;
    CBlockByOffsetSet   m_FreeBlocksSortedByOffset;
    CBlockBySizeSet     m_FreeBlocksSortedBySize;
    CBlockByOffsetSet   m_InUseBlocksSortedByOffset;
    
    PBYTE   GetBasePointer();
    void    Alloc(ULONG NumberOfBytes, ULONG * Offset);
    void    Alloc(CPositionIndependentBlob * Container, ULONG NumberOfBytes, ULONG * Offset);
    void    Free(const BYTE * Pointer);
    void    Reserve(ULONG Bytes, ULONG Blocks) { /* UNDONE */ }
    void    Grow(ULONG);

    void RecalculateBlocksBySize(); // protected

    void (CPositionIndependentBlob::*m_pmfCompact)();

    void * OperatorNew(SIZE_T NumberOfBytes)
    {
        void * Pointer = 0;
        ULONG Offset = 0;
        Alloc(static_cast<ULONG>(NumberOfBytes), &Offset);
        OffsetToPointer(Offset, &Pointer);
        return Pointer;
    }

    //PBYTE OffsetToPointer(ULONG Offset) { return m_BasePointer + Offset; }
    //template <typename T> void OffsetToPointer(ULONG Offset, T * & Pointer) { Pointer = reinterpret_cast<T*>(m_Base + static_cast<SIZE_T>(Offset)); }
    template <typename T> void OffsetToPointer(ULONG Offset, T * * Pointer) { *Pointer = reinterpret_cast<T*>(m_Base + static_cast<SIZE_T>(Offset)); }

    template <typename T>
    ULONG PointerToOffset(const T * Pointer)
    {
        return static_cast<ULONG>(reinterpret_cast<PBYTE>(Pointer) - m_BasePointer);
    }
};
#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependentstringpool.cpp ===
#include "stdinc.h"
#include "lhport.h"
#include "positionindependentstringpool.h"
#include "numberof.h"

int __stdcall CPositionIndependentStringPool::Compare(const BYTE * p, const BYTE * q)
{
	return wcscmp(reinterpret_cast<PCWSTR>(p), reinterpret_cast<PCWSTR>(q));
}

int __stdcall CPositionIndependentStringPool::Comparei(const BYTE * p, const BYTE * q)
{
	return _wcsicmp(reinterpret_cast<PCWSTR>(p), reinterpret_cast<PCWSTR>(q));
}

int __stdcall CPositionIndependentStringPool::Equal(const BYTE * p, const BYTE * q)
{
    return Compare(p, q) == 0;
}

int __stdcall CPositionIndependentStringPool::Equali(const BYTE * p, const BYTE * q)
{
    return Comparei(p, q) == 0;
}

ULONG __stdcall CPositionIndependentStringPool::Hash(const BYTE * p)
{
	PCWSTR q = reinterpret_cast<PCWSTR>(p);
	ULONG Hash;
	if (q[0] == 0)
	{
		return 0;
	}
	Hash = (static_cast<ULONG>(q[0]) << 16) | q[1];
	return Hash;
}

ULONG ToUpper(ULONG ch)
{
	if (ch >= 'a' && ch <= 'z')
		return ch - 'a' + 'A';
	return ch;
}

ULONG ToLower(ULONG ch)
{
	if (ch >= 'A' && ch <= 'Z')
		return ch - 'A' + 'a';
	return ch;
}

ULONG __stdcall CPositionIndependentStringPool::Hashi(const BYTE * p)
{
	PCWSTR q = reinterpret_cast<PCWSTR>(p);
	ULONG Hash;
	if (q[0] == 0)
	{
		return 0;
	}
	Hash = (static_cast<ULONG>(ToLower(q[0])) << 16) | ToLower(q[1]);
	return Hash;
}


CPositionIndependentStringPool::CPositionIndependentStringPool()
{
	const static CHashTableInit inits[2] =
    {
        { 17, Comparei, Hashi, Equali },
        { 17, Compare,  Hash,  Equal  },
    };

	m_HashTable.ThrAddHashTables(NUMBER_OF(inits), inits);
}

BOOL
CPositionIndependentStringPool::IsStringPresent(
    PCWSTR Key,
    ECaseSensitivity CaseSensitivity,
    CAddHint * AddHint
    )
{
    CAddHint LocalAddHint;
    if (AddHint == NULL)
        AddHint = &LocalAddHint;
    AddHint->m_Accessors[0].Init(&m_HashTable, 0);
    AddHint->m_Accessors[1].Init(&m_HashTable, 1);

    return AddHint->m_Accessors[CaseSensitivityToInteger(CaseSensitivity)].IsKeyPresent(reinterpret_cast<const BYTE*>(Key));
}

ULONG
CPositionIndependentStringPool::ThrAddIfNotPresent(PCWSTR, ECaseSensitivity eCaseSensitive)
{
    return 0;
}

ULONG
CPositionIndependentStringPool::ThrAdd(CAddHint & )
{
    return 0;
}

PCWSTR
CPositionIndependentStringPool::ThrGetStringAtIndex(ULONG)
{
    return 0;
}

PCWSTR
CPositionIndependentStringPool::ThrGetStringAtOffset(ULONG)
{
    return 0;
}

ULONG
CPositionIndependentStringPool::GetCount()
{
    return 0;
}

BOOL
CPositionIndependentStringPool::ThrPutToDisk(HANDLE FileHandle)
{
    return 0;
}

BOOL
CPositionIndependentStringPool::ThrGetFromDisk(HANDLE FileHandle, ULONGLONG Offset)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\regxmltoblob.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\regtoxml.h ===
#pragma once

//
// Per BryanT, either do not use #import, or checkin what it produces.
//
//#pragma warning(disable:4192) // automatically excluding 'IErrorInfo' while importing type library 'msxml3.dll'
//#import "msxml3.dll"
#include "msxml3.tlh"

namespace F
{

class CRegKey2;

class CRegToXml
{
public:
	void ThrRegToXml();

	int    argc;
	PWSTR* argv;

protected:

    void Usage();

	MSXML2::IXMLDOMDocumentPtr  Document;
    F::CStringBuffer            ValueDataTextBuffer;


    void ThrDumpKey(ULONG Depth, MSXML2::IXMLDOMNodePtr ParentNode, HKEY Key, PCWSTR Name);
    void ThrDumpBuiltinRoot(HKEY PseudoHandle, PCWSTR Name);
    void ThrDumpBuiltinRoots();
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\regtoxml2.h ===
#pragma once

//
// Per BryanT, either do not use #import, or checkin what it produces.
//
//#pragma warning(disable:4192) // automatically excluding 'IErrorInfo' while importing type library 'msxml3.dll'
//#import "msxml3.dll"
#include "fusion_msxml3.tlh"
#include "fusioncoinitialize.h"
#include "filestream.h"
#include "fusionbuffer.h"

namespace F
{

template <typename T>
void ThrCreateInstance(T& t, PCWSTR s)
{
    FN_PROLOG_VOID_THROW

    IFCOMFAILED_EXIT(t.CreateInstance(const_cast<PWSTR>(s)));

    FN_EPILOG_THROW;
}

class CXmlWriter
// It'd be nice to have a class that provided the union of all the member functions
// and forwarded it to the appropriate vtable..
{
public:

    CXmlWriter()
    {
        ThrCreateInstance(this->IMXWriter, L"Msxml2.MXXMLWriter.3.0");
        this->ISAXContentHandler = this->IMXWriter;
    }

    void Release()
    {
        this->IMXWriter.Release();
        this->ISAXContentHandler.Release();
    }

    MSXML2::IMXWriterPtr           IMXWriter;
    MSXML2::ISAXContentHandlerPtr  ISAXContentHandler;
};

class CXmlAttributes
{
public:
    CXmlAttributes()
    {
        ThrCreateInstance(this->IMXAttributes, L"Msxml2.SAXAttributes.3.0");
        this->ISAXAttributes = this->IMXAttributes;
    }

    void Release()
    {
        this->IMXAttributes.Release();
        this->ISAXAttributes.Release();
    }

    MSXML2::IMXAttributesPtr  IMXAttributes;
    MSXML2::ISAXAttributesPtr ISAXAttributes;
};

class CRegKey2;

class CRegToXml2
{
public:
	void ThrRegToXml();

    CRegToXml2(int argc, PWSTR* argv);

   void Release()
   {
       this->Writer.Release();
       this->Attributes.Release();
   }
 
	int    argc;
	PWSTR* argv;

protected:

    void ThrInit(int argc, PWSTR* argv);

    void Usage();

    F::CThrCoInitialize         Coinit;
    CXmlWriter                  Writer;
    CXmlAttributes              Attributes;
    CFileStream                 OutFileStream;
    F::CStringBuffer            ValueDataTextBuffer;
    _bstr_t                     Bstr_name;
    _bstr_t                     Bstr_value;
    _bstr_t                     Bstr_CDATA;
    _bstr_t                     Bstr_data;
    _bstr_t                     Bstr_type;
    _bstr_t                     EmptyBstr;

    void ThrDumpKey(ULONG Depth, HKEY Key, PCWSTR Name);
    void ThrDumpBuiltinRoot(HKEY PseudoHandle, PCWSTR Name);
    void ThrDumpBuiltinRoots();
};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\positionindependentstringpool.h ===
#include "positionindependenthashtable.h"
#include "positionindependenthashtableaccessor.h"

typedef enum ECaseSensitivity
{
	eCaseInsensitive,
	eCaseSensitive
} ECaseSensitivity;

inline ULONG CaseSensitivityToInteger(ECaseSensitivity e) { return static_cast<ULONG>(e); }

class CPositionIndependentStringPool
{
protected:
	CPositionIndependentHashTable m_HashTable;
public:
	CPositionIndependentStringPool();
	~CPositionIndependentStringPool() { }

    //
    // optimize the ispresent + optional add sequence
    //
    class CAddHint
    { 
    private:
        void operator=(const CAddHint&);
        CAddHint(const CAddHint&);
    public:
        CAddHint() { }
        ~CAddHint() { }
        CPositionIndependentHashTableAccessor m_Accessors[2];
    };

	BOOL    IsStringPresent(PCWSTR, ECaseSensitivity eCaseSensitive, CAddHint *  = NULL);
	ULONG   ThrAddIfNotPresent(PCWSTR, ECaseSensitivity eCaseSensitive);
	ULONG   ThrAdd(CAddHint &);

	PCWSTR  ThrGetStringAtIndex(ULONG);
	PCWSTR  ThrGetStringAtOffset(ULONG);

    ULONG   GetCount();

	BOOL    ThrPutToDisk(HANDLE FileHandle);
	BOOL    ThrGetFromDisk(HANDLE FileHandle, ULONGLONG Offset);

    static int      __stdcall  Compare(const BYTE * p, const BYTE * q);
    static int      __stdcall  Comparei(const BYTE * p, const BYTE * q);
    static BOOL     __stdcall  Equal(const BYTE * p, const BYTE * q);
    static BOOL     __stdcall  Equali(const BYTE * p, const BYTE * q);
    static ULONG    __stdcall  Hash(const BYTE * p);
    static ULONG    __stdcall  Hashi(const BYTE * p);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\regtoxml2.cpp ===
/*
This uses SAX2 and MXXMLWriter.
*/
#include "stdinc.h"
#include "lhport.h"
#include "sxshimlib.h"
#include "regtoxml2.h"
#include "fusionhandle.h"
#include "fusionreg.h"
#include "fusionregkey2.h"
#include "fusionregenumvalues.h"
#include "fusionregenumkeys.h"
#include "delayimp.h"
#include "debmacro.h"
#include "numberof.h"

extern "C" { void (__cdecl * _aexit_rtn)(int); }

#define DO(x) x

void F::CRegToXml2::Usage()
{
    fprintf(stderr, "usage : regtoxml.exe configfile.xml outpuutfile.xml\n");
    ::TerminateProcess(::GetCurrentProcess(), ~0u);
}

class CRegToXmlRegistryRoot
{
public:
    HKEY    PseudoHandle;
    PCWSTR  Name;
};

const CRegToXmlRegistryRoot RegistryRoots[] =
{
    { HKEY_LOCAL_MACHINE, L"HKEY_LOCAL_MACHINE" },
    { HKEY_USERS, L"HKEY_USERS" },
    //HKEY_CURRENT_USER, L"HKEY_CURRENT_USER",
    //
    // Danger: The registry is full of symbolic links that are not or are just
    // barely exposed at the Win32 layer. We could discover them, or buildin some
    // knowledge.
    //
};

bool IsPrintable(WCHAR ch)
{
    if (ch == 0)
        return false;
    if (ch >= 'A' && ch <= 'Z')
        return true;
    if (ch >= 'a' && ch <= 'z')
        return true;
    if (ch < 32)
        return false;
    if (ch > 127)
        return false;
    if (ch >= '0' && ch <= '9')
        return true;
    if (wcschr(L" \r\n\t`~!@#$%^&*()_+-=[]{}|;':,./<>?\"\\", ch) != NULL)
        return true;
    return false;
}

void ThrConvertRegistryDataToText(DWORD Type, const BYTE * Data, DWORD Size, F::CBaseStringBuffer & TextBuffer)
{
    FN_PROLOG_VOID_THROW

    const static UNICODE_STRING hex = RTL_CONSTANT_STRING(L"h:");
    const static UNICODE_STRING ascii = RTL_CONSTANT_STRING(L"a:");
    const static UNICODE_STRING unicode = RTL_CONSTANT_STRING(L"u:");

    TextBuffer.Clear();
    switch (Type)
    {
    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_LINK: // UNDONE?
        TextBuffer.ThrAppend(reinterpret_cast<PCWSTR>(Data), Size / sizeof(WCHAR));
        break;

    case REG_DWORD:
    case REG_DWORD_BIG_ENDIAN:
        TextBuffer.ThrFormatAppend(L"0x%lx", *reinterpret_cast<const DWORD*>(Data));
        break;

    case REG_QWORD:
        TextBuffer.ThrFormatAppend(L"0x%I64x", *reinterpret_cast<const ULONGLONG*>(Data));
        break;

    case REG_NONE:
        break;

    default:
        ASSERT(false);
        break;

    case REG_MULTI_SZ: // UNDONE
    case REG_RESOURCE_LIST: // UNDONE?
    case REG_FULL_RESOURCE_DESCRIPTOR: // UNDONE?
    case REG_RESOURCE_REQUIREMENTS_LIST: // UNDONE?
    case REG_BINARY:
        {
            //
            // endeavor to make it more readable/editable
            //
            bool IsAscii = true;
            bool IsUnicode = true;
            ULONG i = 0;
            PCSTR a = reinterpret_cast<PCSTR>(Data);
            PCWSTR w = reinterpret_cast<PCWSTR>(Data);
            ULONG SizeW = Size / sizeof(WCHAR);

            if (Size == 0)
                break;

            for ( i = 0 ; i != Size ; ++i)
            {
                if (!IsPrintable(a[i]))
                {
                    IsAscii = false;
                    break;
                }
            }
            if (!IsAscii && (i % sizeof(WCHAR)) == 0)
            {
                for ( i = 0 ; i != SizeW ; ++i)
                {
                    if (!IsPrintable(w[i]))
                    {
                        IsUnicode = false;
                        break;
                    }
                }
            }
            if (IsAscii)
            {
                STRING s;

                while (Size != 0)
                {
                    s.Buffer = const_cast<PSTR>(a);
                    if (Size >= 0x7000)
                        s.Length = 0x7000;
                    else
                        s.Length = static_cast<USHORT>(Size);
                    Size -= s.Length;
                    a += s.Length;

                    TextBuffer.ThrAppend(ascii.Buffer, s.Length);
                    TextBuffer.ThrFormatAppend(L"%Z", &s);
                }
            }
            else if (IsUnicode)
            {
                TextBuffer.ThrAppend(unicode.Buffer, RTL_STRING_GET_LENGTH_CHARS(&unicode));
                TextBuffer.ThrAppend(w, SizeW);
            }
            else
            {
                TextBuffer.ThrResizeBuffer(2 * Size + RTL_STRING_GET_LENGTH_CHARS(&hex) + 1, /*F::*/ePreserveBufferContents);
                TextBuffer.ThrAppend(hex.Buffer, RTL_STRING_GET_LENGTH_CHARS(&hex));
                for ( i = 0 ; i+15 < Size ; i += 16 )
                {
                    TextBuffer.ThrFormatAppend(
                        L"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                        Data[i  ], Data[i+1], Data[i+2], Data[i+3],
                        Data[i+4], Data[i+5], Data[i+6], Data[i+7],
                        Data[i+8], Data[i+9], Data[i+10], Data[i+11],
                        Data[i+12], Data[i+13], Data[14], Data[i+15]
                        );
                }
                for ( ; i+7 < Size ; i += 8 )
                {
                    TextBuffer.ThrFormatAppend(
                        L"%02x%02x%02x%02x%02x%02x%02x%02x",
                        Data[i  ], Data[i+1], Data[i+2], Data[i+3],
                        Data[i+4], Data[i+5], Data[i+6], Data[i+7]
                        );
                }
                for ( ; i+3 < Size ; i += 4 )
                {
                    TextBuffer.ThrFormatAppend(
                        L"%02x%02x%02x%02x",
                        Data[i], Data[i+1], Data[2], Data[i+3]
                        );
                }
                for ( ; i != Size ; i += 1)
                {
                    TextBuffer.ThrFormatAppend(L"%02x", Data[i]);
                }
            }
        }
        break;
    }
    FN_EPILOG_THROW;
}

const CHAR   IndentBlah[] =
"                                                                                                                      "
"                                                                                                                      ";
const PCSTR Indent = IndentBlah + RTL_NUMBER_OF(IndentBlah) - 1;
#define INDENT 2

void F::CRegToXml2::ThrDumpKey(ULONG Depth, HKEY ParentKey, PCWSTR Name)
{
    FN_PROLOG_VOID_THROW

    PCWSTR TypeAsString = NULL;
    ULONG  PreviousType = 0;
    ULONG  NextType = 0;

    const static UNICODE_STRING key = RTL_CONSTANT_STRING(L"k");
    const static UNICODE_STRING value = RTL_CONSTANT_STRING(L"v");

    //if (Depth < 3)
    //    FusionpDbgPrint("FUSION: %s 1 %s(%ls)\n", Indent - INDENT * Depth, __FUNCTION__, Name);
    //if (Depth > 100)
    //    FUSION_DEBUG_BREAK();

    this->Attributes.IMXAttributes->clear();
    this->Attributes.IMXAttributes->addAttribute(
        EmptyBstr, EmptyBstr, Bstr_name, Bstr_CDATA, _bstr_t(Name));
    this->Writer.ISAXContentHandler->startElement(
        L"", 0, L"", 0, key.Buffer, RTL_STRING_GET_LENGTH_CHARS(&key), this->Attributes.ISAXAttributes);

    for (
        CRegEnumValues EnumValues(ParentKey);
        EnumValues;
        ++EnumValues
        )
    {
        ULONG ZeroSize = 0;

        this->Attributes.IMXAttributes->clear();

        if (EnumValues.GetValueName().Cch() != 0)
            this->Attributes.IMXAttributes->addAttribute(
                EmptyBstr, EmptyBstr, Bstr_name, Bstr_CDATA, _bstr_t(EnumValues.GetValueName()));

        NextType = EnumValues.GetType();
        if (NextType != REG_NONE)
        {
            if (TypeAsString == NULL || NextType != PreviousType)
            {
                IFW32FALSE_EXIT(RegistryTypeDwordToString(NextType, TypeAsString));
                PreviousType = NextType;
                if (   TypeAsString[0] == 'R'
                    && TypeAsString[1] == 'E'
                    && TypeAsString[2] == 'G'
                    && TypeAsString[3] == '_'
                    )
                {
                    TypeAsString += 4;
                }
            }
            this->Attributes.IMXAttributes->addAttribute(
                EmptyBstr, EmptyBstr, Bstr_type, Bstr_CDATA, _bstr_t(TypeAsString));
        }

        if (EnumValues.GetValueDataSize() != 0)
        {
            DO(ThrConvertRegistryDataToText(
                EnumValues.GetType(),
                EnumValues.GetValueData(),
                EnumValues.GetValueDataSize(),
                this->ValueDataTextBuffer
                ));
            if (this->ValueDataTextBuffer.Cch() != 0)
            {
                this->Attributes.IMXAttributes->addAttribute(
                    EmptyBstr, EmptyBstr, Bstr_data, Bstr_CDATA, _bstr_t(this->ValueDataTextBuffer));
            }
        }
        this->Writer.ISAXContentHandler->startElement(
            L"", 0, L"", 0, value.Buffer, RTL_STRING_GET_LENGTH_CHARS(&value), this->Attributes.ISAXAttributes);
        this->Writer.ISAXContentHandler->endElement(
            L"", 0, L"", 0, value.Buffer, RTL_STRING_GET_LENGTH_CHARS(&value));
    }

    //if (Depth < 4)
    //    FusionpDbgPrint("FUSION: %s 2 %s(%ls)\n", Indent - INDENT * Depth, __FUNCTION__, Name);

    for (
        CRegEnumKeys EnumKeys(ParentKey);
        EnumKeys;
        ++EnumKeys
        )
    {
        F::CRegKey2 ChildKey;
        bool fSuccess = false;
        try
        {
            DO(ChildKey.ThrOpen(ParentKey, static_cast<PCWSTR>(EnumKeys)));
            fSuccess = true;
        }
        catch (const CErr & e)
        {
            if (!e.IsWin32Error(ERROR_ACCESS_DENIED))
                throw; // rethrow
        }
        if (fSuccess)
            DO(ThrDumpKey(Depth + 1, ChildKey, static_cast<PCWSTR>(EnumKeys)));
        //if (Depth < 4)
        //    FusionpDbgPrint("FUSION: %s 3 %s(%ls)\n", Indent - INDENT * Depth, __FUNCTION__, Name);
    }

    this->Writer.ISAXContentHandler->endElement(
        L"", 0, L"", 0, key.Buffer, RTL_STRING_GET_LENGTH_CHARS(&key));

    FN_EPILOG_THROW;
}

void F::CRegToXml2::ThrDumpBuiltinRoot(HKEY PseudoHandle, PCWSTR Name)
{
    FN_PROLOG_VOID_THROW

    DO(ThrDumpKey(0, PseudoHandle, Name));

    FN_EPILOG_THROW;
}

void F::CRegToXml2::ThrDumpBuiltinRoots()
{
    ULONG i = 0;

    for ( i = 0 ; i != RTL_NUMBER_OF(RegistryRoots) ; ++i)
    {
        DO(ThrDumpBuiltinRoot(RegistryRoots[i].PseudoHandle, RegistryRoots[i].Name));
    }
}

F::CRegToXml2::CRegToXml2(int argc, PWSTR* argv)
{
    ThrInit(argc, argv);
}

void F::CRegToXml2::ThrInit(int argc, PWSTR* argv)
{
    FN_PROLOG_VOID_THROW

    this->argc = argc;
	this->argv = argv;

    if (this->argc != 3)
    {
        this->Usage();
        return;
    }

    this->Bstr_name   = L"name";
    this->Bstr_value  = L"value";
    this->Bstr_CDATA  = L"CDATA";
    this->Bstr_data   = L"data";
    this->Bstr_type   = L"type";
    this->EmptyBstr   = L"";

    this->Bstr_name   = L"n";
    this->Bstr_value  = L"v";
    this->Bstr_CDATA  = L"CDATA";
    this->Bstr_data   = L"d";
    this->Bstr_type   = L"t";
    this->EmptyBstr   = L"";


    this->Writer.IMXWriter->output = static_cast<IStream*>(&this->OutFileStream);
    this->Writer.IMXWriter->indent = VARIANT_TRUE;

    IFW32FALSE_EXIT(OutFileStream.OpenForWrite(
        argv[2],
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL
        ));

    this->Writer.ISAXContentHandler->startDocument();
    DO(this->ThrDumpBuiltinRoots());
    this->Writer.ISAXContentHandler->endDocument();

    this->Release();

    FN_EPILOG_THROW;
}

extern HMODULE g_hInstance;

int __cdecl wmain(int argc, PWSTR* argv)
{
    /*F::*/g_hInstance = reinterpret_cast<HINSTANCE>(&__ImageBase);
    F::InitializeHeap(g_hInstance);

    {
        F::CRegToXml2 t(argc, argv);
    }

    F::UninitializeHeap();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\regtextfile.h ===
class CFusionInMemoryRegValue
{
public:
    DWORD Type;

    F::CSmallStringBuffer              Name;

    // conceptually a union
    F::CTinyStringBuffer               StringData;
    DWORD                           DwordData;
    F::CByteBuffer                     BinaryData;
    F::CByteBuffer                     ResourceListData;
    CFusionArray<F::CTinyStringBuffer> MultiStringData;

    void TakeValue(CFusionInMemoryRegValue& x);
    BOOL Win32Assign(const CFusionInMemoryRegValue& x);
};

MAKE_CFUSIONARRAY_READY(CFusionInMemoryRegValue, Win32Assign);

class CFusionInMemoryRegKey
{
    //union
    CFusionInMemoryRegKey& Parent;
    HKEY Hkey; // HKLM, HKCU

    COwnedPtrArray<CFusionInMemoryRegKey> ChildKeys;   // make this is hash table
    CFusionArray<CFusionInMemoryRegValue> ChildValues; // make this is hash table
};

class CFusionRegistryTextFile : public CFusionInMemoryRegKey
{
public:
    BOOL Read(PCWSTR);
    void Dump(void) const;
protected:
    BOOL DetermineType(PVOID, SIZE_T cb, PCSTR& a, PCWSTR& w, SIZE_T& cch);
    BOOL ReadA(PCSTR, SIZE_T cch);
    BOOL ReadW(PCWSTR, SIZE_T cch);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\shimexe.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "imagehlp.h"
#include "winthrow.h"
#include "fusionbuffer.h"
#include "sxshimlib.h"
#include "fusionhandle.h"
#include "sxsmain.h"
#include "lhport.h"

void __stdcall ThrowLastError(DWORD error = ::GetLastError())
{
    ::RaiseException(error, 0, 0, NULL);
    //throw HRESULT_FROM_WIN32(error);
}

typedef HANDLE (WINAPI * PFN_CREATEFILEW)(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    );

// This is exported and gets the previous value of CreateFileW.
PFN_CREATEFILEW My2OriginalCreateFileW;

//extern "C" {
HANDLE
WINAPI
My2CreateFileW(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    )
{
    printf("%s\n", __FUNCTION__);
    if (My2OriginalCreateFileW == NULL)
    {
        ::SetLastError(ERROR_INTERNAL_ERROR);
        return INVALID_HANDLE_VALUE;
    }
    return My2OriginalCreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

// This is exported and gets the previous value of CreateFileW.
PFN_CREATEFILEW MyOriginalCreateFileW;

HANDLE
WINAPI
MyCreateFileW(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile
    )
{
    printf("%s\n", __FUNCTION__);
    if (MyOriginalCreateFileW == NULL)
    {
        ::SetLastError(ERROR_INTERNAL_ERROR);
        return INVALID_HANDLE_VALUE;
    }
    return MyOriginalCreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

//}

int ShimExe(int argc, wchar_t** argv)
{
    HMODULE ExeHandle = ::GetModuleHandleW(NULL);

    if (!SxspDllMainOnDemandProcessAttachCalledByExports(ExeHandle, DLL_PROCESS_ATTACH, NULL))
        ThrowLastError();

    SXPE_APPLY_SHIMS_IN  ShimIn  = {sizeof(ShimIn)};
    SXPE_APPLY_SHIMS_OUT ShimOut = {sizeof(ShimOut)};

    ShimIn.DllToRedirectFrom = ExeHandle;
    ShimIn.DllToRedirectTo.DllHandle = ExeHandle;

    ::CreateFileW(0, 0, 0, 0, 0, 0, 0);
    ::MyCreateFileW(0, 0, 0, 0, 0, 0, 0);
    ::My2CreateFileW(0, 0, 0, 0, 0, 0, 0);

    SxPepApplyShims(&ShimIn, &ShimOut);
    ::CreateFileW(0, 0, 0, 0, 0, 0, 0);

    ShimIn.Prefix = "My2";

    SxPepApplyShims(&ShimIn, &ShimOut);
    ::CreateFileW(0, 0, 0, 0, 0, 0, 0);

    //SxPepRevokeShims(ExeHandle);
    //::CreateFileW(0, 0, 0, 0, 0, 0, 0);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\regtoxml.cpp ===
/*
This uses the DOM.
*/
#include "stdinc.h"
#include "lhport.h"
#include "sxshimlib.h"
#include "regtoxml.h"
#include "fusioncoinitialize.h"
#include "fusionhandle.h"
#include "fusionreg.h"
#include "fusionregkey2.h"
#include "fusionregenumvalues.h"
#include "fusionregenumkeys.h"
#include "delayimp.h"
#include "debmacro.h"
#include "fusionbuffer.h"

#define DO(x) x

void F::CRegToXml::Usage()
{
    fprintf(stderr, "usage : regtoxml.exe configfile.xml outpuutfile.xml\n");
    ::TerminateProcess(::GetCurrentProcess(), ~0u);
}

class CRegToXmlRegistryRoot
{
public:
    HKEY    PseudoHandle;
    PCWSTR  Name;
};

const CRegToXmlRegistryRoot RegistryRoots[] =
{
    { HKEY_LOCAL_MACHINE, L"HKEY_LOCAL_MACHINE" },
    //{ HKEY_USERS, L"HKEY_USERS" },
    //HKEY_CURRENT_USER, L"HKEY_CURRENT_USER",
    //
    // Danger: The registry is full of symbolic links that are not or are just
    // barely exposed at the Win32 layer. We could discover them, or buildin some
    // knowledge.
    //
};

_variant_t make_variant(MSXML2::tagDOMNodeType x)
{
    VARIANT v;
    v.vt = VT_I2;
    v.iVal = static_cast<SHORT>(x);
    return v;
}

_variant_t make_variant(const F::CBaseStringBuffer & x)
{
    return static_cast<PCWSTR>(x);
}

void ThrConvertRegistryDataToText(DWORD Type, const BYTE * Data, DWORD Size, F::CBaseStringBuffer & TextBuffer)
{
    FN_PROLOG_VOID_THROW
    TextBuffer.Clear();
    switch (Type)
    {
    case REG_SZ:
        // UNDONE escape quotes
        DO(TextBuffer.ThrAppend(L"\"", 1));
        DO(TextBuffer.ThrAppend(reinterpret_cast<PCWSTR>(Data), Size / sizeof(WCHAR)));
        DO(TextBuffer.ThrAppend(L"\"", 1));
        break;

    default:
        // UNDONE
        break;
    }
    FN_EPILOG_THROW;

}

const CHAR   IndentBlah[] =
"                                                                                                                      "
"                                                                                                                      ";
const PCSTR Indent = IndentBlah + RTL_NUMBER_OF(IndentBlah) - 1;
#define INDENT 2

void F::CRegToXml::ThrDumpKey(ULONG Depth, MSXML2::IXMLDOMNodePtr ParentNode, HKEY ParentKey, PCWSTR Name)
{
    FN_PROLOG_VOID_THROW

    if (Depth < 3)
        FusionpDbgPrint("FUSION: %s 1 %s(%ls)\n", Indent - INDENT * Depth, __FUNCTION__, Name);
    if (Depth > 100)
        FUSION_DEBUG_BREAK();

    {
        MSXML2::IXMLDOMNodePtr ChildNode;
        MSXML2::IXMLDOMElementPtr Element;

        DO(ChildNode = this->Document->createNode(make_variant(MSXML2::NODE_ELEMENT), L"key", L""));
        DO(Element = ChildNode);

        DO(Element->setAttribute(L"name", Name));
        DO(ParentNode->appendChild(ChildNode));

        ParentNode = ChildNode;
    }

    for (
        CRegEnumValues EnumValues(ParentKey);
        EnumValues;
        ++EnumValues
        )
    {
        MSXML2::IXMLDOMNodePtr ChildNode;
        MSXML2::IXMLDOMElementPtr Element;
        PCWSTR TypeAsString = L"";

        DO(ChildNode = this->Document->createNode(make_variant(MSXML2::NODE_ELEMENT), L"value", L""));
        DO(Element = ChildNode);

        DO(Element->setAttribute(L"name", make_variant(EnumValues.GetValueName())));

        IFW32FALSE_EXIT(RegistryTypeDwordToString(EnumValues.GetType(), TypeAsString));
        DO(Element->setAttribute(L"type", TypeAsString));

        DO(ThrConvertRegistryDataToText(
            EnumValues.GetType(),
            EnumValues.GetValueData(),
            EnumValues.GetValueDataSize(),
            this->ValueDataTextBuffer
            ));
        DO(Element->setAttribute(L"data", make_variant(this->ValueDataTextBuffer)));

        DO(ParentNode->appendChild(ChildNode));
    }

    //if (Depth < 4)
    //    FusionpDbgPrint("FUSION: %s 2 %s(%ls)\n", Indent - INDENT * Depth, __FUNCTION__, Name);

    for (
        CRegEnumKeys EnumKeys(ParentKey);
        EnumKeys;
        ++EnumKeys
        )
    {
        F::CRegKey2 ChildKey;
        DO(ChildKey.ThrOpen(ParentKey, static_cast<PCWSTR>(EnumKeys)));
        DO(ThrDumpKey(Depth + 1, ParentNode, ChildKey, static_cast<PCWSTR>(EnumKeys)));
        //if (Depth < 4)
        //    FusionpDbgPrint("FUSION: %s 3 %s(%ls)\n", Indent - INDENT * Depth, __FUNCTION__, Name);
    }

    FN_EPILOG_THROW;
}

void F::CRegToXml::ThrDumpBuiltinRoot(HKEY PseudoHandle, PCWSTR Name)
{
    FN_PROLOG_VOID_THROW

    /*
    F::CRegKey2 Handle;
    HKEY RawHandle = NULL;

    IFREGFAILED_EXIT(::RegOpenKeyExW(PseudoHandle, NULL, 0, KEY_READ, &RawHandle));
    Handle = RawHandle;

    DO(ThrDumpKey(this->Document, Handle, Name));
    */
    DO(ThrDumpKey(0, this->Document, PseudoHandle, Name));

    FN_EPILOG_THROW;
}

void F::CRegToXml::ThrDumpBuiltinRoots()
{
    ULONG i = 0;

    for ( i = 0 ; i != RTL_NUMBER_OF(RegistryRoots) ; ++i)
    {
        DO(ThrDumpBuiltinRoot(RegistryRoots[i].PseudoHandle, RegistryRoots[i].Name));
    }
}

void F::CRegToXml::ThrRegToXml()
{
    //
    // argv[1] guides what we output
    // argv[2] is where we output
    //
    FN_PROLOG_VOID_THROW

    if (argc != 3)
        Usage();

    //F::CFile infile;
    //F::CFile outfile;

    F::CCoInitialize coinit;
	IFW32FALSE_EXIT(coinit.Win32Initialize());

	IFCOMFAILED_EXIT(this->Document.CreateInstance(L"msxml2.domdocument"));
    DO(ThrDumpBuiltinRoots());

    this->Document->save(this->argv[2]);

    FN_EPILOG_THROW;
}

int __cdecl wmain(int argc, PWSTR* argv)
{
    F::g_hInstance = reinterpret_cast<HINSTANCE>(&__ImageBase);
    F::InitializeHeap();

    F::CRegToXml t;
	t.argc = argc;
	t.argv = argv;

	t.ThrRegToXml();

    F::UninitializeHeap();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

FUSION_BUILD_TYPE=WIN
!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

TARGETPATH=obj
DLLDEF=$(O)\$(TARGETNAME).def

USE_VCCOM=1
#USE_ATL=1
USE_MSVCRT=1

INCLUDES=\
 ..; \
$(INCLUDES); \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\inc\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(FUSION_PATH)\sxs; \
 $(FUSION_PATH)\eventlog\$(FUSION_BUILD_LEAF_DIRECTORY)\$(O); \
 
TARGETLIBS= \
 $(TARGETLIBS) \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxsmain.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxs1.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxs2.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)win32oneshot.lib \
 $(FUSION_PATH)\$(O)\win32simplelock.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)utils.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)xmlparser.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)id.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)eventlog.lib \
 $(FUSION_PATH)\$(O)\fusion_uuid.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)xml.lib \
# $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)fusionsetupapi.lib \
 $(FUSION_PATH)\winthrow\$(O)\winthrow.lib \
 $(SDK_LIB_PATH)\noenv.obj \
 $(SDK_LIB_PATH)\noarg.obj \
 $(SDK_LIB_PATH)\msvcrt.lib \
 $(SDK_LIB_PATH)\ntdll.lib \
 $(SDK_LIB_PATH)\uuid.lib \
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\kernl32p.lib \
 $(SDK_LIB_PATH)\advapi32.lib \
 $(SDK_LIB_PATH)\crypt32.lib \
 $(SDK_LIB_PATH)\rpcrt4.lib \
 $(SDK_LIB_PATH)\setupapi.lib \
 $(SDK_LIB_PATH)\imagehlp.lib \
 $(SDK_LIB_PATH)\user32.lib \
 $(SDK_LIB_PATH)\wintrust.lib \
 $(SDK_LIB_PATH)\mpr.lib \
 $(SDK_LIB_PATH)\ole32.lib \
 $(SDK_LIB_PATH)\oleaut32.lib \
 $(SDK_LIB_PATH)\comctl32.lib \

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdinc.h
#PRECOMPILED_OBJ=$(O)\stdinc.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\regtextfile.cpp ===
/*
These strings have no terminal nuls.
To easily form these strings in the VC editor, type the string, then do a regexp search/replace on the
string, replace . with '\0',
*/
const CHAR Regedit4SignatureA[]  = { 'R','E','G','E','D','I','T','4' };
const NativeUnicodeMarker        = 0xFEFF;
const ReversedUnicodeMarker      = 0xFFFE;
const WCHAR Regedit5SignatureW[] = { NativeUnicodeMarker,
                                    'W','i','n','d','o','w','s',' ',
                                    'R','e','g','i','s','t','r','y',' ',
                                    'E','d','i','t','o','r',' ',
                                    'V','e','r','s','i','o','n',' ',
                                    '5','.','0','0'
                                    };

class CFusionStringPoolIndex;
class CFusionStringPool;

class CFusionStringPoolIndex
{
public:
    CFusionStringPoolIndex();
    BOOL Init(CFusionStringPool * Pool);

    int (__cdecl * m_compare)(PCWSTR, PCWSTR); // wcscmp or _wcsicmp

    CFusionArray<ULONG> m_Index;
    CFusionStringPool * m_Pool;
};

class CFusionStringPool
{
public:

    CFusionStringPool();

    BOOL Add(PCWSTR String, ULONG Length, ULONG& Index);

    CFusionArray<ULONG> m_Index;
    CFusionByteBuffer   m_Blob;
    int (__cdecl * m_compare)(PCWSTR, PCWSTR); // wcscmp or _wcsicmp
};

BOOL CFusionStringPool::Add(PCWSTR String, ULONG Length, ULONG& Index)
{
    FN_PROLOG_WIN32

    WCHAR UnicodeNull = 0;
    SIZE_T OldSize = 0;
    ULONG Mono = m_MonotonicIndex.GetSizeAsULONG();
    Index = Mono;
    IFW32FALSE_EXIT(m_MonotonicIndex.Win32SetSize(Mono + 1));
    IFW32FALSE_EXIT(m_Blob.Win32SetSize((OldSize = m_Blob.GetSize()) + Length + sizoef(WCHAR)));
    OldSize *= sizeof(WCHAR);
    Length  *= sizeof(WCHAR);
    CopyMemory(&m_Blob[0] + OldSize, String, Length);
    CopyMemory(&m_Blob[0] + OldSize + Length, &UnicodeNull, sizeof(WCHAR));

    FN_EPILOG;
}

BOOL CFusionStringPool::Optimize()
{
    FN_PROLOG_WIN32

    if (   m_NumberOfStrings == m_NumberOfCaseSensitiveSortedStrings
        && m_NumberOfStrings == m_NumberOfCaseInsensitiveSortedStrings
        )
    {
        FN_SUCCESSFUL_EXIT;
    }

    FN_EPILOG;
}

void CFusionInMemoryRegValue::TakeValue(CFusionInMemoryRegValue& x)
{
    FN_PROLOG_WIN32

    this->m_String.TakeValue(x.m_String);
    this->m_Binary.TakeValue(x.m_Binary);
    this->m_ResourceList.TakeValue(x.m_ResourceList);
    this->m_MultiString.TakeValue(x.m_MultiString);
    this->m_Dword = x.m_Dword;
    this->m_Type = x.m_Type;

    FN_EPILOG
}

BOOL CFusionInMemoryRegValue::Win32Assign(const CFusionInMemoryRegValue& x)
{
    FN_PROLOG_WIN32

    CFusionInMemoryRegValue temp;

    IFW32FALSE_EXIT(Temp.m_String.Win32Assign(x.m_String));
    IFW32FALSE_EXIT(Temp.m_Binary.Win32Assign(x.m_Binary));
    IFW32FALSE_EXIT(Temp.m_ResourceList.Win32Assign(x.m_ResourceList));
    IFW32FALSE_EXIT(Temp.m_MultiString.Win32Assign(x.m_MultiString));
    Temp.m_Dword = x.m_Dword;
    Temp.m_Type = x.m_Type;

    this->TakeValue(Temp);

    FN_EPILOG
}

BOOL g_fBreakOnUnregonizedRegistryFile;

BOOL CFusionRegistryTextFile::DetermineType(PVOID p, SIZE_T n, PCSTR& a, PCWSTR& w, SIZE_T& cch)
// NOTE that like regedit, we don't allow whitespace
{
    FN_PROLOG_WIN32

    a = NULL;
    w = NULL;

    if (n >= sizeof(Regedit5SignatureW)
        && memcmp(p, Regedit5SignatureW, sizeof(Regedit5SignatureW)) == 0)
    {
        *w = p;
        *cch = n / sizeof(*w);
        *w += NUMBER_OF();
        n -= NUMBER_OF(Regedit5SignatureW);
    }
    else
    if (n >= sizeof(Regedit4SignatureA)
        && memcmp(p, Regedit4SignatureA, sizeof(Regedit4SignatureA)) == 0)
    {
        *a = p;
        *cch = n / sizeof(*a);
        *a += NUMBER_OF(Regedit4SignatureA);
        n -= NUMBER_OF();
    }
    else
    {
        FusionpDbgPrint("SXS: Unrecognized registry file, ed g_fBreakOnUnregonizedRegistryFile 1 if reproable.\n");
        if (g_fBreakOnUnregonizedRegistryTextFile)
            FusionpDbgBreak();
        ::FusionpSetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    FN_EPILOG;
}

template <typename T>
void SkipWhitespace(T*& rpt, SIZE_T& rcch, SIZE_T& rlines)
{
    SIZE_T lines = 0;
    SIZE_T cch = rcch;
    T* pt = rpt;

    while (cch != 0)
    {
        switch (*pt)
        {
        default:
            goto Done;
        case ' ':
        case '\t':
            break;
        case '\r':
            if (cch != 1 && *(pt + 1) == '\n')
            {
                --ch;
                ++pt;
            }
            // FALLTHROUGH
        case '\n':
            lines += 1;
            break;
        }
        --ch;
        ++pt;
    }
Done:
    rpt = pt;
    rcch = cch;
    rlines += lines;
}

BOOL CFusionRegistryTextFile::ParseError(PCWSTR, ...)
{
}

template <typename T>
BOOL CFusionRegistryTextFile::VerifyFirstKeyPathElement(const F::CBaseStringBuffer& KeyPath)
{
    const static UNICODE_STRING hkey_local_machine = RTL_CONSTANT_STRING(L"HKEY_LOCAL_MACHINE");
    const static UNICODE_STRING hkey_current_user = RTL_CONSTANT_STRING(L"HKEY_CURRENT_USER");
    const static UNICODE_STRING hkey_classes_root = RTL_CONSTANT_STRING(L"HKEY_CLASSES_ROOT");
    const static UNICODE_STRING hkey_users = RTL_CONSTANT_STRING(L"HKEY_USERS");

    PARAMETER_CHECK(
           ::FusionpEqualStrings(KeyPath, hkey_local_machine, TRUE)
        || ::FusionpEqualStrings(KeyPath, hkey_current_user, TRUE)
        || ::FusionpEqualStrings(KeyPath, hkey_classes_root, TRUE)
        || ::FusionpEqualStrings(KeyPath, hkey_users, TRUE));

    FN_EPILOG
}

template <typename T>
BOOL CFusionRegistryTextFile::ReadKeyPath(T* s, SIZE_T n, F::CBaseStringBuffer& KeyPath)
{
    bool first = true;
    while (n != 0 && *s != ']')
    {
        ReadKeyPathElement();
        if (first)
            VerifyFirstKeyPathElement();
    }
}

template <typename T>
BOOL CFusionRegistryTextFile::ReadMappedGeneric(T* s, SIZE_T n)
{
    SIZE_T line = 1;

    while (n != 0)
    {
        SkipWhitespace(s, n, line);
        if (n == 0) break;
        switch (*s)
        {
        case '[':
            ++s;
            --n;
            ReadKeyPath(s, n);
            break;
        default:
            ParseError(L"invalid char %c, expected '['", *s);
            break;
        }
    }
}

    
BOOL CFusionRegistryTextFile::ReadMappedA(PCSTR s, SIZE_T n)
{
}

BOOL CFusionRegistryTextFile::ReadMappedW(PCWSTR s, SIZE_T n)
{
}

BOOL CFusionRegistryTextFile::Read(PCWSTR FileName)
{
    FN_PROLOG_WIN32
    F::CFile       File;
    F::CFileMapping      FileMapping;
    F::CMappedViewOfFile MappedView;
    ULONGLONG         FileSize = 0;
    PCSTR             FileA = NULL;
    PCWSTR            FileW = NULL;
    SIZE_T            Cch = 0;

    PARAMETER_CHECK(FileName != NULL);
    PARAMETER_CHECK(FileName[0] != 0);
    IFW32FALSE_EXIT(File.Win32CreateFile(FileName, GENERIC_READ | DELETE, FILE_SHARE_READ | FILE_SHARE_DELETE,
            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN));
    IFW32FALSE_EXIT(File.Win32GetFileSize(FileSize));
    PARAMETER_CHECK(FileSize != 0);
    IFW32FALSE_EXIT(FileMapping.Win32CreateFileMapping(FileMapping, PAGE_READONLY);
    IFW32FALSE_EXIT(MappedView.Win32MapViewOfFile(FileMapping, FILE_MAP_READ);
    IFW32FALSE_EXIT(this->DetermineType(MappedView, FileSize, FileSize, FileA, FileW, Cch));
    INTERNAL_ERROR_CHECK(FileA != NULL || FileW != NULL);
    if (FileA != NULL)
        IFW32FALSE_EXIT(this->ReadMappedA(FileA, Cch);
    else if (FileW != NULL)
        IFW32FALSE_EXIT(this->ReadMappedW(FileW, Cch);

    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\stdinc.h ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#define MAXDWORD (~(DWORD)0)
#include "windows.h"
#include "imagehlp.h"
#include "comdef.h"
#include "winthrow.h"
#include <stdio.h>
#include <utility>
#include <set>
#include "fusionbuffer.h"
#include "fusionhandle.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\actctxctb.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    actctxctb.cpp

Abstract:

    Code to manage the list of activation context contributors in sxs.dll.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"

CCriticalSectionNoConstructor g_ActCtxCtbListCritSec;
PACTCTXCTB g_ActCtxCtbListHead;
ULONG g_ActCtxCtbListCount;

BOOL
SxspAddBuiltinActCtxContributor(
    ACTCTXCTB_CALLBACK_FUNCTION CallbackFunction,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    ULONG Format,
    PCWSTR ContributorName
    )
{
    CSmartPtr<ACTCTXCTB> Contrib;
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(
        (Format == ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE) ||
        (Format == ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE) ||
        (Format == 0));
    PARAMETER_CHECK(CallbackFunction != NULL);
    PARAMETER_CHECK(ContributorName != NULL);

    IFW32FALSE_EXIT(Contrib.Win32Allocate(__FILE__, __LINE__));

    Contrib->m_BuiltinContributor = true;
    Contrib->m_CallbackFunction = CallbackFunction;

    if (ExtensionGuid != NULL)
    {
        Contrib->m_ExtensionGuid = *ExtensionGuid;
        Contrib->m_IsExtendedSection = ((Contrib->m_ExtensionGuid != GUID_NULL) != FALSE);
    }
    else
    {
        Contrib->m_ExtensionGuid = GUID_NULL;
        Contrib->m_IsExtendedSection = false;
    }

    IFW32FALSE_EXIT(Contrib->m_ContributorNameBuffer.Win32Assign(ContributorName, ::wcslen(ContributorName)));

    Contrib->m_SectionId = SectionId;
    Contrib->m_Format = Format;
    Contrib->m_RefCount = 1;
    {
        CSxsLockCriticalSection lock(g_ActCtxCtbListCritSec);
        IFW32FALSE_EXIT(lock.Lock());
        Contrib->m_Next = g_ActCtxCtbListHead;
        g_ActCtxCtbListHead = Contrib.Detach();
        g_ActCtxCtbListCount++;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspInitActCtxContributors(
    )
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(g_ActCtxCtbListCritSec.Initialize());

    ASSERT(g_ActCtxCtbListHead == NULL);
    ASSERT(g_ActCtxCtbListCount == 0);

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspAssemblyMetadataContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE,
                L"Builtin Assembly Metadata Contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspDllRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE,
                L"Builtin DLL Redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspWindowClassRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE,
                L"Builtin Window Class Redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspComClassRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE,
                L"Builtin COM Server Redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspComProgIdRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE,
                L"Builtin COM ProgId redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspComTypeLibRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE,
                L"Builtin COM Type Library redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspComInterfaceRedirectionContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
                ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE,
                L"Builtin COM interface redirection contributor"));

    IFW32FALSE_EXIT(::SxspAddBuiltinActCtxContributor(
                &SxspClrInteropContributorCallback,
                NULL,
                ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES,
                ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE,
                L"Builtin NDP surrogate data contributor"));

    FN_EPILOG
}

VOID
SxspUninitActCtxContributors(
    VOID
    )
{
    FN_TRACE();
    PACTCTXCTB pCtb;

    g_ActCtxCtbListCritSec.Destruct();

    pCtb = g_ActCtxCtbListHead;

    while (pCtb != NULL)
    {
        PACTCTXCTB pNext = pCtb->m_Next;
        pCtb->Release();
        pCtb = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\actctxgen.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    actctxgen.cpp

Abstract:

    APIs for generating activation contexts.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    xiaoyuw     09/2000         replace attributes with assembly identity
--*/

#include "stdinc.h"
#include <windows.h>
#include <sxsp.h>
#include <ole2.h>
#include <xmlparser.h>
#include "nodefactory.h"
#include <wchar.h>
#include "filestream.h"
#include "fusionhandle.h"
#include "cteestream.h"
#include "cresourcestream.h"
#include "fusionxml.h"
#include "util.h"
#include "sxsexceptionhandling.h"
#include "csxspreservelasterror.h"
#include "smartptr.h"
#include "cstreamtap.h"
#include "pendingassembly.h"
#include "actctxgenctx.h"

BOOL
SxspFindAssemblyByName(
    PACTCTXGENCTX pActCtxGenCtx,
    PCWSTR AssemblyName,
    SIZE_T AssemblyNameCch,
    PASSEMBLY *AssemblyFound
    );

BOOL
SxspAddAssemblyToActivationContextGenerationContext(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm
    );

_ACTCTXGENCTX::_ACTCTXGENCTX()
:
    m_Contributors(NULL),
    m_ContributorCount(0),
    m_ProcessorArchitecture(0),
    m_LangID(0),
    m_Flags(0),
    m_ManifestOperation(MANIFEST_OPERATION_INVALID),
    m_ManifestOperationFlags(0),
    m_NextAssemblyRosterIndex(1),
    m_fClsidMapInitialized(FALSE),
    m_InitializedContributorCount(0),
    m_NoInherit(false),
    m_pNodeFactory(NULL),
    m_ulFileCount(0),
    m_fAppApplyPublisherPolicy(SXS_PUBLISHER_POLICY_APPLY_DEFAULT),
    m_ApplicationDirectoryHasBeenProbedForLanguageSubdirs(false),
    m_ApplicationDirectoryHasSpecificLanguageSubdir(false),
    m_ApplicationDirectoryHasGenericLanguageSubdir(false),
    m_ApplicationDirectoryHasSpecificSystemLanguageSubdir(false),
    m_ApplicationDirectoryHasGenericSystemLanguageSubdir(false)
{
}

_ACTCTXGENCTX::~_ACTCTXGENCTX()
{
    while (m_InitializedContributorCount)
    {
        m_InitializedContributorCount -= 1;
        CActivationContextGenerationContextContributor *Ctb = &m_Contributors[m_InitializedContributorCount];

        Ctb->Fire_ParseEnded(this, NULL);
        Ctb->Fire_ActCtxGenEnded(this);
    }

    FUSION_DELETE_ARRAY(m_Contributors);
    m_Contributors = NULL;

    m_AssemblyTable.ClearNoCallback();
    m_ComponentPolicyTable.ClearNoCallback();
    m_PendingAssemblyList.Clear(&CPendingAssembly::DeleteYourself);
    m_AssemblyList.Clear(&ASSEMBLY::Release);

    if (m_fClsidMapInitialized)
    {
        m_fClsidMapInitialized = false;
        VERIFY_NTC(m_ClsidMap.Uninitialize());
    }

    FUSION_DELETE_SINGLETON(m_pNodeFactory);
    m_pNodeFactory = NULL;
}

BOOL
SxspInitActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    ULONG ulManifestOperation,
    DWORD dwFlags,
    DWORD dwManifestOperationFlags,
    const CImpersonationData &ImpersonationData,
    USHORT ProcessorArchitecture,
    LANGID LangId,
    ULONG ApplicationDirectoryPathType,
    SIZE_T ApplicationDirectoryCch,
    PCWSTR ApplicationDirectory
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PACTCTXCTB Ctb = NULL;
    CSxsLockCriticalSection lock(g_ActCtxCtbListCritSec);
    CStringBufferAccessor acc; // used for LangID String buffer
    LANGID SystemLangId = ::GetSystemDefaultUILanguage();
    bool fEqual = false;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    PARAMETER_CHECK(
        (ulManifestOperation == SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_PARSE_ONLY) ||
        (ulManifestOperation == SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_GENERATE_ACTIVATION_CONTEXT) ||
        (ulManifestOperation == SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_INSTALL));

    PARAMETER_CHECK(
        (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_NONE) ||
        (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE));

    PARAMETER_CHECK((dwFlags & ~(SXS_GENERATE_ACTCTX_SYSTEM_DEFAULT | SXS_GENERATE_ACTCTX_APP_RUNNING_IN_SAFEMODE)) == 0);
    PARAMETER_CHECK((dwFlags == 0) || (dwFlags == SXS_GENERATE_ACTCTX_SYSTEM_DEFAULT) || (dwFlags == SXS_GENERATE_ACTCTX_APP_RUNNING_IN_SAFEMODE));


    switch (ulManifestOperation)
    {
    case SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_PARSE_ONLY:
        PARAMETER_CHECK(dwManifestOperationFlags == 0);
        break;

    case SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_GENERATE_ACTIVATION_CONTEXT:
        PARAMETER_CHECK(dwManifestOperationFlags == 0);
        break;

    case SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_INSTALL:
        PARAMETER_CHECK(
            (dwManifestOperationFlags & ~(
                MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL |
                MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY |
                MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING |
                MANIFEST_OPERATION_INSTALL_FLAG_ABORT |
                MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY |
                MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
                MANIFEST_OPERATION_INSTALL_FLAG_MOVE |
                MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE |
                MANIFEST_OPERATION_INSTALL_FLAG_FROM_RESOURCE |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_DARWIN |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_MIGRATION |
                MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE |
                MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID |
                MANIFEST_OPERATION_INSTALL_FLAG_REFRESH |
                MANIFEST_OPERATION_INSTALL_FLAG_FROM_CABINET |
                MANIFEST_OPERATION_INSTALL_FLAG_APPLY_PATCHES |
                MANIFEST_OPERATION_INSTALL_FLAG_FORCE_LOOK_FOR_CATALOG |
                MANIFEST_OPERATION_INSTALL_FLAG_COMMIT)) == 0);
        break;
    }

    pActCtxGenCtx->m_ProcessorArchitecture = ProcessorArchitecture;
    pActCtxGenCtx->m_LangID = LangId;
    pActCtxGenCtx->m_SystemLangID = SystemLangId;

    pActCtxGenCtx->m_SpecificLanguage.Clear();

    IFW32FALSE_EXIT(pActCtxGenCtx->m_ApplicationDirectoryBuffer.Win32Assign(ApplicationDirectory, ApplicationDirectoryCch));
    pActCtxGenCtx->m_ApplicationDirectoryPathType = ApplicationDirectoryPathType;

    IFW32FALSE_EXIT(::SxspMapLANGIDToCultures(LangId, pActCtxGenCtx->m_GenericLanguage, pActCtxGenCtx->m_SpecificLanguage));
    IFW32FALSE_EXIT(::SxspMapLANGIDToCultures(SystemLangId, pActCtxGenCtx->m_GenericSystemLanguage, pActCtxGenCtx->m_SpecificSystemLanguage));

    // If these match the user's language, clear them to avoid the probing later on.
    IFW32FALSE_EXIT(pActCtxGenCtx->m_SpecificSystemLanguage.Win32Equals(pActCtxGenCtx->m_SpecificLanguage, fEqual, true));
    if (fEqual)
        pActCtxGenCtx->m_SpecificSystemLanguage.Clear();

    IFW32FALSE_EXIT(pActCtxGenCtx->m_GenericSystemLanguage.Win32Equals(pActCtxGenCtx->m_GenericLanguage, fEqual, true));
    if (fEqual)
        pActCtxGenCtx->m_GenericSystemLanguage.Clear();

    pActCtxGenCtx->m_ImpersonationData = ImpersonationData;
    pActCtxGenCtx->m_ManifestOperation = ulManifestOperation;
    pActCtxGenCtx->m_Flags = dwFlags;
    pActCtxGenCtx->m_ManifestOperationFlags = dwManifestOperationFlags;
    pActCtxGenCtx->m_fAppApplyPublisherPolicy = SXS_PUBLISHER_POLICY_APPLY_DEFAULT;

    IFW32FALSE_EXIT(pActCtxGenCtx->m_AssemblyTable.Initialize());
    IFW32FALSE_EXIT(pActCtxGenCtx->m_ComponentPolicyTable.Initialize());
    IFW32FALSE_EXIT(pActCtxGenCtx->m_ApplicationPolicyTable.Initialize());

    IFW32FALSE_EXIT(pActCtxGenCtx->m_ClsidMap.Initialize());
    pActCtxGenCtx->m_fClsidMapInitialized = TRUE;
    pActCtxGenCtx->m_ClsidMappingContext.Map = &(pActCtxGenCtx->m_ClsidMap);

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(pActCtxGenCtx->m_AssemblyRootDirectoryBuffer));
    pActCtxGenCtx->m_AssemblyRootDirectoryPathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;

    lock.Lock();

    IFALLOCFAILED_EXIT(pActCtxGenCtx->m_Contributors = FUSION_NEW_ARRAY(CActivationContextGenerationContextContributor, g_ActCtxCtbListCount));
    pActCtxGenCtx->m_ContributorCount = g_ActCtxCtbListCount;

    for (
        (pActCtxGenCtx->m_InitializedContributorCount = 0), (Ctb=g_ActCtxCtbListHead);
        (Ctb != NULL) && (pActCtxGenCtx->m_InitializedContributorCount < g_ActCtxCtbListCount);
        (pActCtxGenCtx->m_InitializedContributorCount++), (Ctb = Ctb->m_Next)
        )
    {
        ACTCTXCTB_CBACTCTXGENBEGINNING CBData;

        CBData.Header.Reason = ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING;
        CBData.Header.ExtensionGuid = Ctb->GetExtensionGuidPtr();
        CBData.Header.SectionId = Ctb->m_SectionId;
        CBData.Header.ContributorContext = Ctb->m_ContributorContext;
        CBData.Header.ActCtxGenContext = NULL;
        CBData.Header.ManifestParseContext = NULL;
        CBData.Header.ManifestOperation = ulManifestOperation;
        CBData.Header.ManifestOperationFlags = dwManifestOperationFlags;
        CBData.Header.Flags = dwFlags;
        CBData.Header.pOriginalActCtxGenCtx = pActCtxGenCtx;
        CBData.Header.InstallationContext = &(pActCtxGenCtx->m_InstallationContext);
        CBData.Header.ClsidMappingContext = &(pActCtxGenCtx->m_ClsidMappingContext);
        CBData.ApplicationDirectory = pActCtxGenCtx->m_ApplicationDirectoryBuffer;
        CBData.ApplicationDirectoryCch = pActCtxGenCtx->m_ApplicationDirectoryBuffer.Cch();
        CBData.ApplicationDirectoryPathType = pActCtxGenCtx->m_ApplicationDirectoryPathType;
        CBData.Success = TRUE;

        (*(Ctb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ASSERT(::FusionpGetLastWin32Error() != ERROR_SUCCESS);
            if (::FusionpGetLastWin32Error() == ERROR_SUCCESS)
                ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);

            goto Exit;
        }

        IFW32FALSE_EXIT(pActCtxGenCtx->m_Contributors[pActCtxGenCtx->m_InitializedContributorCount].Initialize(Ctb, CBData.Header.ActCtxGenContext));
    }
    // If the list count is correct, we should be both at the end of the list
    // and at the max index.
    ASSERT(pActCtxGenCtx->m_InitializedContributorCount == g_ActCtxCtbListCount);
    ASSERT(Ctb == NULL);

    qsort(pActCtxGenCtx->m_Contributors, pActCtxGenCtx->m_ContributorCount, sizeof(CActivationContextGenerationContextContributor), &CActivationContextGenerationContextContributor::Compare);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFireActCtxGenEnding(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    for (i=0; i<pActCtxGenCtx->m_InitializedContributorCount; i++)
        IFW32FALSE_EXIT(pActCtxGenCtx->m_Contributors[i].Fire_ActCtxGenEnding(pActCtxGenCtx));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

class CSxspResolvePartialReferenceLocals
{
public:
    CProbedAssemblyInformation TestReference;
    CSmallStringBuffer buffProcessorArchitecture;
};

BOOL
SxspResolvePartialReference(
    DWORD Flags,
    PCASSEMBLY ParsingAssemblyContext,
    PACTCTXGENCTX pActCtxGenCtx,
    const CAssemblyReference &PartialReference,
    CProbedAssemblyInformation &ProbedAssemblyInformation,
    bool &rfFound,
    CSxspResolvePartialReferenceLocals *Locals
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CProbedAssemblyInformation &TestReference = Locals->TestReference;
    CSmallStringBuffer &buffProcessorArchitecture = Locals->buffProcessorArchitecture;
    bool fWildcardedLanguage = false;
    bool fWildcardedProcessorArchitecture = false;
    bool fAutoWow64Probing = false;
    bool fHasPKToken = false;
    bool fFound = false;
    USHORT wCurrentProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
    DWORD dwProbeAssemblyFlags = 0;
    PCWSTR pszOriginalProcessorArchitecture = NULL;
    SIZE_T cchOriginalProcessorArchitecture = 0;
    PCWSTR pszOriginalLanguage = NULL;
    SIZE_T cchOriginalLanguage = 0;

    fHasPKToken = false;
    rfFound = false;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    IFINVALID_FLAGS_EXIT_WIN32(Flags, SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL |
                                      SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_SKIP_WORLDWIDE);

    //
    //  A partial reference needs to have processor architecture, assembly name and
    //  assembly version filled in.  We only probe based on langid.
    //

    // Copy the attributes over...
    IFW32FALSE_EXIT(TestReference.Initialize(PartialReference, pActCtxGenCtx));

    fWildcardedProcessorArchitecture = false;
    fAutoWow64Probing = false;

    // Find out if we're either processing a processorArchitecture="*" bind or
    // if we're supposed to do wow64 probing

    IFW32FALSE_EXIT(PartialReference.IsProcessorArchitectureWildcarded(fWildcardedProcessorArchitecture));

    if (pActCtxGenCtx->m_ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64)
    {
        IFW32FALSE_EXIT(PartialReference.IsProcessorArchitectureX86(fAutoWow64Probing));
    }

    if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
    {
        wCurrentProcessorArchitecture = pActCtxGenCtx->m_ProcessorArchitecture;
        IFW32FALSE_EXIT(::FusionpFormatProcessorArchitecture(wCurrentProcessorArchitecture, buffProcessorArchitecture));
        IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));

        // We do not probe for private wow64 assemblies.
        if (wCurrentProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64)
            dwProbeAssemblyFlags |= CProbedAssemblyInformation::ProbeAssembly_SkipPrivateAssemblies;
    }

    IFW32FALSE_EXIT(PartialReference.GetProcessorArchitecture(pszOriginalProcessorArchitecture, cchOriginalProcessorArchitecture));
    IFW32FALSE_EXIT(PartialReference.GetLanguage(pszOriginalLanguage, cchOriginalLanguage));

TryItAllAgain:

    // Let's try the few languages we can.

    IFW32FALSE_EXIT(PartialReference.IsLanguageWildcarded(fWildcardedLanguage));
    if (!fWildcardedLanguage)
    {
        // If there's no language="*" in the dependency, let's just look for the exact match and
        // call it a day.
        if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
            IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));

        IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eExplicitBind, fFound));

        if ((!fFound) && (fWildcardedProcessorArchitecture || fAutoWow64Probing))
            IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(pszOriginalProcessorArchitecture, cchOriginalProcessorArchitecture));
    }
    else
    {
        // Let's try the user's language...
        if (pActCtxGenCtx->m_SpecificLanguage[0] != L'\0')
        {
            // Since this is the first probe, we don't have to reset to original...
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetLanguage(pActCtxGenCtx->m_SpecificLanguage));
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eSpecificLanguage, fFound));
            if (!fFound)
            {
                if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                    IFW32FALSE_EXIT(
                        TestReference.SetProcessorArchitecture(
                            pszOriginalProcessorArchitecture,
                            cchOriginalProcessorArchitecture));

                IFW32FALSE_EXIT(TestReference.SetLanguage(pszOriginalLanguage, cchOriginalLanguage));
            }
        }

        if (!fFound && (pActCtxGenCtx->m_GenericLanguage[0] != L'\0'))
        {
            // Try the user's slightly more generic version of the language...
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));

            IFW32FALSE_EXIT(TestReference.SetLanguage(pActCtxGenCtx->m_GenericLanguage));

            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eGenericLanguage, fFound));

            if (!fFound)
            {
                if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                    IFW32FALSE_EXIT(
                        TestReference.SetProcessorArchitecture(
                            pszOriginalProcessorArchitecture,
                            cchOriginalProcessorArchitecture));

                IFW32FALSE_EXIT(TestReference.SetLanguage(pszOriginalLanguage, cchOriginalLanguage));
            }
        }

        // Let's try the system's installed language...
        if (!fFound && (pActCtxGenCtx->m_SpecificSystemLanguage[0] != L'\0'))
        {
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetLanguage(pActCtxGenCtx->m_SpecificSystemLanguage));
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eSpecificSystemLanguage, fFound));
            if (!fFound)
            {
                if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                    IFW32FALSE_EXIT(
                        TestReference.SetProcessorArchitecture(
                            pszOriginalProcessorArchitecture,
                            cchOriginalProcessorArchitecture));

                IFW32FALSE_EXIT(TestReference.SetLanguage(pszOriginalLanguage, cchOriginalLanguage));
            }
        }

        if (!fFound && (pActCtxGenCtx->m_GenericSystemLanguage[0] != L'\0'))
        {
            // Try the user's slightly more generic version of the language...
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.SetLanguage(pActCtxGenCtx->m_GenericSystemLanguage));
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eGenericSystemLanguage, fFound));
            if (!fFound)
            {
                if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                    IFW32FALSE_EXIT(
                        TestReference.SetProcessorArchitecture(
                            pszOriginalProcessorArchitecture,
                            cchOriginalProcessorArchitecture));

                IFW32FALSE_EXIT(TestReference.SetLanguage(pszOriginalLanguage, cchOriginalLanguage));
            }
        }

        // If we haven't found a language specific one and the caller did not
        // request us to skip the language-dependent ones, try for a language neutral
        if (!fFound &&
            ((Flags & SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_SKIP_WORLDWIDE) == 0))
        {
            // Try with no language!
            if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            IFW32FALSE_EXIT(TestReference.ClearLanguage());
            IFW32FALSE_EXIT(TestReference.ProbeAssembly(dwProbeAssemblyFlags, pActCtxGenCtx, CProbedAssemblyInformation::eLanguageNeutral, fFound));
            if (!fFound)
            {
                if (fWildcardedProcessorArchitecture || fAutoWow64Probing)
                    IFW32FALSE_EXIT(
                        TestReference.SetProcessorArchitecture(
                            pszOriginalProcessorArchitecture,
                            cchOriginalProcessorArchitecture));

                IFW32FALSE_EXIT(TestReference.SetLanguage(pszOriginalLanguage, cchOriginalLanguage));
            }
        }
    }

    if (!fFound)
    {
        // If we're automatically searching for wow64 assemblies and the processor architecture we just tried
        // was ia32-on-win64, try again with plain PROCESSOR_ARCHITECTURE_INTEL.
        if (fAutoWow64Probing && (wCurrentProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64))
        {
            wCurrentProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
            dwProbeAssemblyFlags &= ~(CProbedAssemblyInformation::ProbeAssembly_SkipPrivateAssemblies);

            IFW32FALSE_EXIT(::FusionpFormatProcessorArchitecture(wCurrentProcessorArchitecture, buffProcessorArchitecture));
            IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            pszOriginalProcessorArchitecture = buffProcessorArchitecture;
            cchOriginalProcessorArchitecture = buffProcessorArchitecture.Cch();
            goto TryItAllAgain;
        }

        // If we're handling a processorArchitecture="*" bind and the current processor architecture hasn't fallen
        // back to PROCESSOR_ARCHITECTURE_UNKNOWN ( == data-only assemblies), fall back now.
        if (fWildcardedProcessorArchitecture && (wCurrentProcessorArchitecture != PROCESSOR_ARCHITECTURE_UNKNOWN))
        {
            wCurrentProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
            // data-only private assemblies cannot be found with processorArchitecture="*"
            dwProbeAssemblyFlags |= CProbedAssemblyInformation::ProbeAssembly_SkipPrivateAssemblies;

            IFW32FALSE_EXIT(::FusionpFormatProcessorArchitecture(wCurrentProcessorArchitecture, buffProcessorArchitecture));
            IFW32FALSE_EXIT(TestReference.SetProcessorArchitecture(buffProcessorArchitecture, buffProcessorArchitecture.Cch()));
            pszOriginalProcessorArchitecture = buffProcessorArchitecture;
            cchOriginalProcessorArchitecture = buffProcessorArchitecture.Cch();
            goto TryItAllAgain;
        }

        // If it wasn't optional, declare an error.
        if ((Flags & SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL) == 0)
        {
            // NTRAID#NTBUG9 - 571854 - 2002/03/26 - xiaoyuw
            // the default value would never get used since GetAssemblyName always reset the input parameter to be NULL;            

            PCWSTR AssemblyName = L"<error retrieving assembly name>";
            SIZE_T AssemblyNameCch = NUMBER_OF(L"<error retrieving assembly name>") - 1;

            TestReference.GetAssemblyName(&AssemblyName, &AssemblyNameCch);

            ::FusionpLogError(
                MSG_SXS_MANIFEST_PARSE_DEPENDENCY,
                CUnicodeString(AssemblyName, AssemblyNameCch),
                CEventLogLastError(ERROR_SXS_ASSEMBLY_NOT_FOUND));

            ORIGINATE_WIN32_FAILURE_AND_EXIT(AssemblyProbingFailed, ERROR_SXS_ASSEMBLY_NOT_FOUND);
        }
    }
    else
        IFW32FALSE_EXIT(ProbedAssemblyInformation.TakeValue(TestReference));

    rfFound = fFound;

    fSuccess = TRUE;

Exit:
    if (!fSuccess)
    {
        CSxsPreserveLastError ple;
        PCWSTR pszAssemblyName = NULL;
        SIZE_T AssemblyNameCch = 0;

        PartialReference.GetAssemblyName(&pszAssemblyName, &AssemblyNameCch);

        ::FusionpLogError(
            MSG_SXS_FUNCTION_CALL_FAIL,
            CEventLogString(L"Resolve Partial Assembly"),
            (pszAssemblyName != NULL) ? CEventLogString(static_cast<PCWSTR>(pszAssemblyName)) : CEventLogString(L"Assembly Name Unknown"),
            CEventLogLastError(ple.LastError()));

        ple.Restore();
    }

    return fSuccess;
}

BOOL
SxspResolvePartialReference(
    DWORD Flags,
    PCASSEMBLY ParsingAssemblyContext,
    PACTCTXGENCTX pActCtxGenCtx,
    const CAssemblyReference &PartialReference,
    CProbedAssemblyInformation &ProbedAssemblyInformation,
    bool &rfFound
    )
{
    FN_PROLOG_WIN32

    CSmartPtr<CSxspResolvePartialReferenceLocals> Locals;

    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));

    IFW32FALSE_EXIT(
        SxspResolvePartialReference(
            Flags,
            ParsingAssemblyContext,
            pActCtxGenCtx,
            PartialReference,
            ProbedAssemblyInformation,
            rfFound,
            Locals
            ));

    FN_EPILOG
}

BOOL
SxspAddManifestToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    CProbedAssemblyInformation &ProbedInformation,
    PASSEMBLY *AssemblyOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY Asm = NULL;
    PCWSTR ProbedAssemblyName = 0;
    SIZE_T ProbedAssemblyNameCch = 0;

    if (AssemblyOut != NULL)
        *AssemblyOut = NULL;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    IFW32FALSE_EXIT(ProbedInformation.GetAssemblyName(&ProbedAssemblyName, &ProbedAssemblyNameCch));

    // NTRAID#NTBUG9 - 571854 - 2002/03/26 - xiaoyuw: 
    // INTERNAL_ERROR_CHECK or ASSERT should be added here

    // INTERNAL_ERROR_CHECK(ProbedAssemblyName != NULL && ProbedAssemblyNameCch != 0);

    // First, let's see if we've already found this assembly.
    IFW32FALSE_EXIT(::SxspFindAssemblyByName(pActCtxGenCtx, ProbedAssemblyName, ProbedAssemblyNameCch, &Asm));
    // Same name... if the metadata is different, we're in trouble.
    if (Asm != NULL)
    {
        BOOL fEqualIdentity;

        // Both identities should be definitions, so no need to set the ref-matches-def flag...
        IFW32FALSE_EXIT(
            ::SxsAreAssemblyIdentitiesEqual(
                SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF,
                Asm->GetAssemblyIdentity(),
                ProbedInformation.GetAssemblyIdentity(),
                &fEqualIdentity));

        if (!fEqualIdentity)
        {
            PCWSTR MP1 = L"<unavailable>";
            PCWSTR MP2 = MP1;

            ProbedInformation.GetManifestPath(&MP1, NULL);
            Asm->m_ProbedAssemblyInformation.GetManifestPath(&MP2, NULL);

            Asm = NULL;
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS.DLL: Failing to add new manifest %S to activation context because it conflicts with existing %S\n", MP1, MP2);
            ORIGINATE_WIN32_FAILURE_AND_EXIT(VersionConflict, ERROR_SXS_VERSION_CONFLICT);
        }
    }

    if (Asm == NULL)
    {
        IFALLOCFAILED_EXIT(Asm = FUSION_NEW_SINGLETON(ASSEMBLY));
        IFW32FALSE_EXIT(::SxspInitAssembly(Asm, ProbedInformation));
        IFW32FALSE_EXIT(::SxspAddAssemblyToActivationContextGenerationContext(pActCtxGenCtx, Asm));
    }

    if (AssemblyOut != NULL)
    {
        *AssemblyOut = Asm;
        Asm = NULL;
    }

    fSuccess = TRUE;

Exit:
    if (Asm != NULL)
        Asm->Release();

    return fSuccess;
}

BOOL
SxspAddAssemblyToActivationContextGenerationContext(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    PARAMETER_CHECK(Asm != NULL);

    // If you hit either of these asserts, either the assembly structure has been trashed or
    // it's already been added to the generation context.
    ASSERT(Asm->m_AssemblyRosterIndex == 0);
    Asm->m_AssemblyRosterIndex = pActCtxGenCtx->m_NextAssemblyRosterIndex++;
    pActCtxGenCtx->m_AssemblyList.AddToTail(Asm);
    Asm->AddRef();
    if (pActCtxGenCtx->m_ManifestOperation != MANIFEST_OPERATION_INSTALL)
    {
        PCWSTR AssemblyName = NULL;
        IFW32FALSE_EXIT(Asm->GetAssemblyName(&AssemblyName, NULL));
        IFW32FALSE_EXIT(pActCtxGenCtx->m_AssemblyTable.Insert(AssemblyName, Asm, ERROR_SXS_DUPLICATE_ASSEMBLY_NAME));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFindAssemblyByName(
    PACTCTXGENCTX pActCtxGenCtx,
    PCWSTR AssemblyName,
    SIZE_T AssemblyNameCch,
    PASSEMBLY *AssemblyOut
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmallStringBuffer AssemblyNameBuffer;
    PASSEMBLY Result = NULL;

    if (AssemblyOut != NULL)
        *AssemblyOut = NULL;

    PARAMETER_CHECK(AssemblyOut != NULL);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    // Unfortunately, we really need the string to be null terminated...
    IFW32FALSE_EXIT(AssemblyNameBuffer.Win32Assign(AssemblyName, AssemblyNameCch));
    AssemblyName = AssemblyNameBuffer;

    IFW32FALSE_EXIT(pActCtxGenCtx->m_AssemblyTable.Find(AssemblyName, Result));

    if (Result != NULL)
        Result->AddRef();

    *AssemblyOut = Result;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspAddRootManifestToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    PCSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    )
{
    FN_PROLOG_WIN32
    CProbedAssemblyInformation AssemblyInfo;

    PARAMETER_CHECK(Parameters != NULL);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

#define IS_NT_DOS_PATH(_x) (IS_PATH_SEPARATOR_U((_x)[0]) && ((_x)[1] == L'?') && ((_x)[2] == L'?') && IS_PATH_SEPARATOR_U((_x)[3]))

    PARAMETER_CHECK((Parameters->AssemblyDirectory == NULL) || (IS_NT_DOS_PATH(Parameters->AssemblyDirectory) == FALSE));
    PARAMETER_CHECK((Parameters->AssemblyDirectory == NULL) || (IS_NT_DOS_PATH(Parameters->AssemblyDirectory) == FALSE));
    PARAMETER_CHECK((Parameters->Manifest.Path == NULL) || (IS_NT_DOS_PATH(Parameters->Manifest.Path) == FALSE));
    PARAMETER_CHECK((Parameters->Policy.Path == NULL) || (IS_NT_DOS_PATH(Parameters->Policy.Path) == FALSE));

    IFW32FALSE_EXIT(AssemblyInfo.Initialize(pActCtxGenCtx));
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestPath(
            ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
            Parameters->Manifest.Path,
            (Parameters->Manifest.Path != NULL) ? ::wcslen(Parameters->Manifest.Path) : 0));
    ASSERT(Parameters->Manifest.Stream != NULL);
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestStream(Parameters->Manifest.Stream));
    IFW32FALSE_EXIT(AssemblyInfo.SetManifestFlags(ASSEMBLY_MANIFEST_FILETYPE_STREAM));

    IFW32FALSE_EXIT(AssemblyInfo.SetPolicyPath(
        ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
        Parameters->Policy.Path,
        (Parameters->Policy.Path != NULL) ? ::wcslen(Parameters->Policy.Path) : 0));
    IFW32FALSE_EXIT(AssemblyInfo.SetPolicyStream(Parameters->Policy.Stream));
    IFW32FALSE_EXIT(AssemblyInfo.SetPolicyFlags(ASSEMBLY_POLICY_FILETYPE_STREAM));

    IFW32FALSE_EXIT(::SxspAddManifestToActCtxGenCtx(pActCtxGenCtx, AssemblyInfo, NULL));

    FN_EPILOG
#undef IS_NT_DOS_PATH
}

BOOL
SxspInitAssembly(
    PASSEMBLY Asm,
    CProbedAssemblyInformation &AssemblyInfo
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(Asm != NULL);

    IFW32FALSE_EXIT(Asm->m_ProbedAssemblyInformation.InitializeTakeValue(AssemblyInfo));
    Asm->m_Incorporated = FALSE;
    Asm->m_ManifestVersionMajor = 0;
    Asm->m_ManifestVersionMinor = 0;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

class CSxspIncorporateAssemblyLocals
{
public:
#if FUSION_XML_TREE
    SXS_XML_STRING LocalStringArray[128];
    PSXS_XML_STRING ActualStringArray;
#endif
    STATSTG statstg;
    ACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    CStringBuffer TextuallyEncodedIdentityBuffer;
    CFileStream ProbeFileTypeStream;
    CFileStream FileStream;
};

BOOL
SxspIncorporateAssembly(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm,
    CSxspIncorporateAssemblyLocals *Locals
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    HRESULT hr = 0;
    ULONG i = 0;
    ACTCTXCTB_ASSEMBLY_CONTEXT &AssemblyContext = Locals->AssemblyContext;
    const bool fInstalling = (pActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_INSTALL);
    ULONG ManifestType = (Asm->m_ProbedAssemblyInformation.GetManifestFlags() & ASSEMBLY_MANIFEST_FILETYPE_MASK);
    CImpersonate impersonate(pActCtxGenCtx->m_ImpersonationData);
    SXS_POLICY_SOURCE s;
#if FUSION_XML_TREE
    PSXS_XML_STRING ActualStringArray = Locals->LocalStringArray;
#endif
    STATSTG &statstg = Locals->statstg;

    // declaration order here is partially deliberate, to control cleanup order.
    // normally, declaration order is determined by not declaring until you have
    // the data to initialize with the ctor, but the use of goto messes that up
    CFileStream &FileStream = Locals->FileStream;
    CSmartPtr<CResourceStream> ResourceStream;
    CSmartPtr<CTeeStreamWithHash> TeeStreamForManifestInstall;

#if FUSION_PRECOMPILED_MANIFEST
    CSmartPtr<CPrecompiledManifestWriterStream> pcmWriterStream;
#endif
    CNodeFactory *pNodeFactory = NULL;
    CSmartRef<IXMLParser> pIXMLParser;
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;

    CStringBuffer &TextuallyEncodedIdentityBuffer = Locals->TextuallyEncodedIdentityBuffer;
    PCWSTR ManifestPath = NULL;

    PARAMETER_CHECK(Asm != NULL);
    PARAMETER_CHECK(!Asm->m_Incorporated);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    // set flags
    AssemblyContext.Flags = 0;
    s = Asm->m_ProbedAssemblyInformation.GetPolicySource();

    if ( s == SXS_POLICY_SYSTEM_POLICY)
        AssemblyContext.Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_ASSEMBLY_POLICY_APPLIED;
    else if (s == SXS_POLICY_ROOT_POLICY)
        AssemblyContext.Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_ROOT_POLICY_APPLIED;

    if (Asm->IsRoot())
        AssemblyContext.Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY;

    if (Asm->m_ProbedAssemblyInformation.IsPrivateAssembly())
        AssemblyContext.Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_IS_PRIVATE_ASSEMBLY;

    if (Asm->m_ProbedAssemblyInformation.GetAssemblyIdentity() != NULL)
    {
        // Convert the identity into a somewhat human-readable form that we can log etc.
        IFW32FALSE_EXIT(
            ::SxspGenerateTextualIdentity(
                0,
                Asm->m_ProbedAssemblyInformation.GetAssemblyIdentity(),
                TextuallyEncodedIdentityBuffer));
        
        AssemblyContext.TextuallyEncodedIdentity = TextuallyEncodedIdentityBuffer;
        AssemblyContext.TextuallyEncodedIdentityCch = TextuallyEncodedIdentityBuffer.Cch();
    }
    else
    {
        AssemblyContext.TextuallyEncodedIdentity = L"<identity unavailable>";
        AssemblyContext.TextuallyEncodedIdentityCch = 22;
    }

    // copy assembly-identity info
    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL, Asm->m_ProbedAssemblyInformation.GetAssemblyIdentity(), &AssemblyIdentity));
    AssemblyContext.AssemblyIdentity = AssemblyIdentity; // assign to pointer-to-const in the struct; can't pass struct member pointer directly

    IFW32FALSE_EXIT(Asm->m_ProbedAssemblyInformation.GetManifestPath(&AssemblyContext.ManifestPath, &AssemblyContext.ManifestPathCch));
    AssemblyContext.ManifestPathType = Asm->GetManifestPathType();
    IFW32FALSE_EXIT(Asm->m_ProbedAssemblyInformation.GetPolicyPath(AssemblyContext.PolicyPath, AssemblyContext.PolicyPathCch));
    AssemblyContext.PolicyPathType = Asm->GetPolicyPathType();
    AssemblyContext.AssemblyRosterIndex = Asm->m_AssemblyRosterIndex;

    if (fInstalling)
    {
        IFW32FALSE_EXIT(TeeStreamForManifestInstall.Win32Allocate(__FILE__, __LINE__));
        AssemblyContext.TeeStreamForManifestInstall = TeeStreamForManifestInstall;
        AssemblyContext.InstallationInfo = pActCtxGenCtx->m_InstallationContext.InstallSource;
        AssemblyContext.SecurityMetaData = pActCtxGenCtx->m_InstallationContext.SecurityMetaData;
        AssemblyContext.InstallReferenceData = pActCtxGenCtx->m_InstallationContext.InstallReferenceData;
#if FUSION_PRECOMPILED_MANIFEST
        IFW32FALSE_EXIT(pcmWriterStream.Win32Allocate(__FILE__, __LINE__);
        AssemblyContext.pcmWriterStream = pcmWriterStream ;
#endif
    }
    else
    {
        AssemblyContext.SecurityMetaData = NULL;
        AssemblyContext.TeeStreamForManifestInstall = NULL;
        AssemblyContext.InstallationInfo = NULL;
#if FUSION_PRECOMPILED_MANIFEST
        AssemblyContext.pcmWriterStream = NULL;
#endif
    }

    if (pActCtxGenCtx->m_pNodeFactory == NULL)
    {
        IFALLOCFAILED_EXIT(pActCtxGenCtx->m_pNodeFactory = new CNodeFactory);
        pActCtxGenCtx->m_pNodeFactory->AddRef(); // faked function
    }
    else
        pActCtxGenCtx->m_pNodeFactory->ResetParseState();

    IFW32FALSE_EXIT(pActCtxGenCtx->m_pNodeFactory->Initialize(pActCtxGenCtx, Asm, &AssemblyContext));
    pNodeFactory = pActCtxGenCtx->m_pNodeFactory;
    ASSERT(pNodeFactory != NULL);

    // Everyone's ready; let's get the XML parser:
    IFW32FALSE_EXIT(::SxspGetXMLParser(IID_IXMLParser, (LPVOID *) &pIXMLParser));
    IFCOMFAILED_EXIT(pIXMLParser->SetFactory(pNodeFactory));

    //
    // open the file or map the resource into memory
    //
    IStream* Stream; // deliberatly not "smart", we don't refcount it
    Stream = NULL;
    { // scope for impersonation for file open

        IFW32FALSE_EXIT(impersonate.Impersonate());

        if (ManifestType == ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT)
        {
            //
            // decide between xml in its own text file or a resource
            // in a "portable executable" by checking for the portable executable
            // signature, "MZ".
            //
            BYTE buffer[2] = {0,0};
            ULONG cbRead = 0;
            CFileStream &ProbeFileTypeStream = Locals->ProbeFileTypeStream;

            IFW32FALSE_EXIT(Asm->m_ProbedAssemblyInformation.GetManifestPath(&ManifestPath, NULL));
            IFW32FALSE_EXIT(
                ProbeFileTypeStream.OpenForRead(
                    ManifestPath,
                    CImpersonationData(),
                    FILE_SHARE_READ,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN));

            IFCOMFAILED_EXIT(ProbeFileTypeStream.Read(buffer, 2, &cbRead));

            if (cbRead != 2)
                ORIGINATE_WIN32_FAILURE_AND_EXIT(ManifestLessThanTwoBytesLong, ERROR_SXS_MANIFEST_FORMAT_ERROR);

            IFW32FALSE_EXIT(ProbeFileTypeStream.Close());

            // MS-DOS stub, Mark Zbikowski
            if (buffer[0] == 'M' && buffer[1] == 'Z')
            {
                // should we do further checking, like that PE\0\0 occurs
                // where the MS-DOS header says it is?
                ManifestType = ASSEMBLY_MANIFEST_FILETYPE_RESOURCE;
            }
            else
            {
                ManifestType = ASSEMBLY_MANIFEST_FILETYPE_FILE;
            }
        }
        switch (ManifestType)
        {
            case ASSEMBLY_MANIFEST_FILETYPE_RESOURCE:
                {
                    if (ManifestPath == NULL)
                        IFW32FALSE_EXIT(Asm->m_ProbedAssemblyInformation.GetManifestPath(&ManifestPath, NULL));
                    IFW32FALSE_EXIT(ResourceStream.Win32Allocate(__FILE__, __LINE__));
                    IFW32FALSE_EXIT(ResourceStream->Initialize(ManifestPath, MAKEINTRESOURCEW(RT_MANIFEST)));
                    Stream = ResourceStream;
                    break;
                }
            case ASSEMBLY_MANIFEST_FILETYPE_FILE:
                {
                    if (ManifestPath == NULL)
                        IFW32FALSE_EXIT(Asm->m_ProbedAssemblyInformation.GetManifestPath(&ManifestPath, NULL));
                    IFW32FALSE_EXIT(
                        FileStream.OpenForRead(
                            ManifestPath,
                            CImpersonationData(),
                            FILE_SHARE_READ,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN));
                    Stream = &FileStream;
                    break;
                }
            case ASSEMBLY_MANIFEST_FILETYPE_STREAM:
                Stream = Asm->m_ProbedAssemblyInformation.GetManifestStream();
                break;
            default:
                ASSERT2(FALSE, "unknown manifest file type");
                break;
        }

        IFW32FALSE_EXIT(impersonate.Unimpersonate());
    }

    //
    // Optionally "tee" the manifest so it gets copied into
    // the store while we read it, buffering until we know where in
    // the store it goes. The manifest itself is not referenced
    // in the manifest.
    //
    if (fInstalling)
    {
        IFW32FALSE_EXIT(TeeStreamForManifestInstall->InitCryptHash(CALG_SHA1));
        TeeStreamForManifestInstall->SetSource(Stream);
        Stream = TeeStreamForManifestInstall;
    }

    //
    // We get E_NOTIMPL on the OutOfProcessMemoryStreams in the AppCompat case.
    //
    IFCOMFAILED_EXIT(((hr = Stream->Stat(&statstg, STATFLAG_NONAME)) != E_NOTIMPL) ? hr : NOERROR);
    if (hr == E_NOTIMPL)
    {
        statstg.mtime.dwLowDateTime = 0;
        statstg.mtime.dwHighDateTime = 0;
    }

    IFW32FALSE_EXIT(
        pNodeFactory->SetParseType(
            XML_FILE_TYPE_MANIFEST,
            Asm->m_ProbedAssemblyInformation.GetManifestPathType(),
            Asm->m_ProbedAssemblyInformation.GetManifestPath(),
            statstg.mtime));

    INTERNAL_ERROR_CHECK(Stream != NULL);

    IFCOMFAILED_EXIT(pIXMLParser->SetInput(Stream));
    IFCOMFAILED_EXIT(pIXMLParser->Run(-1));
    IFW32FALSE_EXIT(FileStream.Close());
  
#if FUSION_PRECOMPILED_MANIFEST
    IFW32FALSE_EXIT((AssemblyContext.pcmWriterStream == NULL) || (pcmWriterStream.Close()));
#endif

    // Tell the contributors we're done parsing this file
    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        IFW32FALSE_EXIT(
            pActCtxGenCtx->m_Contributors[i].Fire_ParseEnding(
                pActCtxGenCtx,
                &AssemblyContext));

#if FUSION_XML_TREE
    // Now let's fill in the document's string table.
    StringTableEntryCount = pNodeFactory->m_ParseTreeStringPool.GetEntryCount() + 1;

    if (StringTableEntryCount > NUMBER_OF(Locals->LocalStringArray))
        IFALLOCFAILED_EXIT(ActualStringArray = FUSION_NEW_ARRAY(SXS_XML_STRING, StringTableEntryCount));

    IFW32FALSE_EXIT(pNodeFactory->m_ParseTreeStringPool.FillInStringArray(StringTableEntryCount, ActualStringArray, EntriesFilledIn));
    // The size should have been an exact match.
    ASSERT(EntriesFilledIn == StringTableEntryCount);

    pNodeFactory->m_XmlDocument.StringCount = EntriesFilledIn;
    pNodeFactory->m_XmlDocument.Strings = ActualStringArray;

    ::SxspDumpXmlTree(0, &(pNodeFactory->m_XmlDocument));

    pNodeFactory->m_XmlDocument.StringCount = 0;
    pNodeFactory->m_XmlDocument.Strings = NULL;

    if (ActualStringArray != Locals->LocalStringArray)
    {
        FUSION_DELETE_ARRAY(ActualStringArray);
        ActualStringArray = NULL;
    }
#endif // FUSION_XML_TREE

    Asm->m_Incorporated = TRUE;
    fSuccess = TRUE;

Exit:
    // And tell them we're done.
    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        pActCtxGenCtx->m_Contributors[i].Fire_ParseEnded(pActCtxGenCtx, &AssemblyContext);

    return fSuccess;
}

BOOL
SxspIncorporateAssembly(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm
    )
{
    FN_PROLOG_WIN32

    CSmartPtr<CSxspIncorporateAssemblyLocals> Locals;

    PARAMETER_CHECK(Asm != NULL);
    PARAMETER_CHECK(!Asm->m_Incorporated);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));

	IFW32FALSE_EXIT(::SxspIncorporateAssembly(pActCtxGenCtx, Asm, Locals));

    FN_EPILOG
}

BOOL
SxspEnqueueAssemblyReference(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY SourceAssembly,
    PCASSEMBLY_IDENTITY Identity,
    bool Optional,
    bool MetadataSatellite
    )
{
	FN_PROLOG_WIN32

    CSmartPtr<CPendingAssembly> PendingAssembly;

    PARAMETER_CHECK(Identity != NULL);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    IFW32FALSE_EXIT(PendingAssembly.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(PendingAssembly->Initialize(SourceAssembly, Identity, Optional, MetadataSatellite));

    pActCtxGenCtx->m_PendingAssemblyList.AddToTail(PendingAssembly.Detach());

	FN_EPILOG
}

class CSxspProcessPendingAssembliesLocals
{
public:

    CSmallStringBuffer buffName;
    CProbedAssemblyInformation MuiAssemblyFound;
    CProbedAssemblyInformation AssemblyFound;
};

BOOL
SxspProcessPendingAssemblies(
    PACTCTXGENCTX pActCtxGenCtx,
    CSxspProcessPendingAssembliesLocals *Locals
    )
{
    FN_PROLOG_WIN32

    CPendingAssembly *EntryToDelete = NULL;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> MuiAssemblyIdentity;

    CDequeIterator<CPendingAssembly, offsetof(CPendingAssembly, m_Linkage)> Iter(&pActCtxGenCtx->m_PendingAssemblyList);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    for (Iter.Reset(); Iter.More(); Iter.Next())
    {
        bool fFound = false;
        CAssemblyReference TargetAssemblyRef;
        CProbedAssemblyInformation &AssemblyFound = Locals->AssemblyFound;
        AssemblyFound.Reinitialize();
        CSmartRef<ASSEMBLY> Assembly;

        if (EntryToDelete != NULL)
        {
            pActCtxGenCtx->m_PendingAssemblyList.Remove(EntryToDelete);
            FUSION_DELETE_SINGLETON(EntryToDelete);
        }

        EntryToDelete = NULL;

        IFW32FALSE_EXIT(AssemblyFound.Initialize(pActCtxGenCtx));
        IFW32FALSE_EXIT(TargetAssemblyRef.Initialize(Iter->GetIdentity()));

        IFW32FALSE_EXIT(
            ::SxspResolvePartialReference(
                Iter->IsOptional() ? SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL : 0,
                Iter->SourceAssembly(),
                pActCtxGenCtx,
                TargetAssemblyRef,
                AssemblyFound,
                fFound));

        INTERNAL_ERROR_CHECK(fFound || Iter->IsOptional());

        if (fFound)
        {
            PCASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
            PCWSTR szLanguage;
            SIZE_T cchLanguage;

            IFW32FALSE_EXIT(::SxspAddManifestToActCtxGenCtx(pActCtxGenCtx, AssemblyFound, &Assembly));

            // Note that AssemblyFound is no longer intact; this is to avoid duplication of
            // the assembly identity inside the SxspAddManifestToActCtxGenCtx() call.

            if (Iter->IsMetadataSatellite())
                Iter->SourceAssembly()->m_MetadataSatelliteRosterIndex = Assembly->m_AssemblyRosterIndex;

            // If it's a worldwide assembly, we want to auto-probe for the MUI assembly
            IFW32FALSE_EXIT(
                ::SxspGetAssemblyIdentityAttributeValue(
                    SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                    Assembly->m_ProbedAssemblyInformation.GetAssemblyIdentity(),
                    &s_IdentityAttribute_language,
                    &szLanguage,
                    &cchLanguage));

            if (cchLanguage == 0)
            {
                CSmallStringBuffer &buffName = Locals->buffName;
                PCWSTR szName;
                SIZE_T cchName;
                CProbedAssemblyInformation &MuiAssemblyFound = Locals->MuiAssemblyFound;
                MuiAssemblyFound.Reinitialize();
                CAssemblyReference MuiAssemblyRef;

                ::SxsDestroyAssemblyIdentity(MuiAssemblyIdentity.Detach());

                IFW32FALSE_EXIT(
                    ::SxsDuplicateAssemblyIdentity(
                        0,
                        Assembly->m_ProbedAssemblyInformation.GetAssemblyIdentity(),      // PCASSEMBLY_IDENTITY Source,
                        &MuiAssemblyIdentity));

                IFW32FALSE_EXIT(
                    ::SxspSetAssemblyIdentityAttributeValue(
                        SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                        MuiAssemblyIdentity,
                        &s_IdentityAttribute_language,
                        L"*",
                        1));

                IFW32FALSE_EXIT(
                    ::SxspGetAssemblyIdentityAttributeValue(
                        0,
                        MuiAssemblyIdentity,
                        &s_IdentityAttribute_name,
                        &szName,
                        &cchName));

                IFW32FALSE_EXIT(buffName.Win32Assign(szName, cchName));
                IFW32FALSE_EXIT(buffName.Win32Append(L".mui", 4));

                IFW32FALSE_EXIT(
                    ::SxspSetAssemblyIdentityAttributeValue(
                        SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                        MuiAssemblyIdentity,
                        &s_IdentityAttribute_name,
                        buffName,
                        buffName.Cch()));

                IFW32FALSE_EXIT(MuiAssemblyFound.Initialize(pActCtxGenCtx));
                IFW32FALSE_EXIT(MuiAssemblyRef.Initialize(MuiAssemblyIdentity));

                IFW32FALSE_EXIT(
                    ::SxspResolvePartialReference(
                        SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL |
                            SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_SKIP_WORLDWIDE,
                        Iter->SourceAssembly(),
                        pActCtxGenCtx,
                        MuiAssemblyRef,
                        MuiAssemblyFound,
                        fFound));

                if (fFound)
                    IFW32FALSE_EXIT(::SxspAddManifestToActCtxGenCtx(pActCtxGenCtx, MuiAssemblyFound, NULL));
            }

        }

        EntryToDelete = Iter;
    }

    if (EntryToDelete != NULL)
    {
        pActCtxGenCtx->m_PendingAssemblyList.Remove(EntryToDelete);
        FUSION_DELETE_SINGLETON(EntryToDelete);
    }

    FN_EPILOG
}

BOOL
SxspProcessPendingAssemblies(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    FN_PROLOG_WIN32

    CSmartPtr<CSxspProcessPendingAssembliesLocals> Locals;

    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(::SxspProcessPendingAssemblies(pActCtxGenCtx, Locals));

    FN_EPILOG
}

BOOL
SxspCloseManifestGraph(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
	FN_PROLOG_WIN32

    CDequeIterator<ASSEMBLY, offsetof(ASSEMBLY, m_Linkage)> Iter(&pActCtxGenCtx->m_AssemblyList);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    // We need to just walk the list of assemblies, incorporating any that aren't already
    // incorporated into the actctx data.  New ones found during incorporation are appended
    // to the end of the list, so we should complete everything with a single walk.
    for (Iter.Reset(); Iter.More(); Iter.Next())
    {
        if (!Iter->m_Incorporated)
        {
            IFW32FALSE_EXIT(::SxspIncorporateAssembly(pActCtxGenCtx, Iter));
        }
        else
        {
            PCWSTR AssemblyName = L"<assembly name unavailable>";
            PCWSTR ManifestPath = L"<manifest path unavailable>";
            Iter->m_ProbedAssemblyInformation.GetAssemblyName(&AssemblyName, NULL);
            Iter->m_ProbedAssemblyInformation.GetManifestPath(&ManifestPath, NULL);
#if DBG
            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INFO, "SXS.DLL: Skipping already incorporated assembly %S (manifest: %S)\n", AssemblyName, ManifestPath);
#endif
        }

        IFW32FALSE_EXIT(::SxspProcessPendingAssemblies(pActCtxGenCtx));
    }

	FN_EPILOG
}

BOOL
SxspBuildActCtxData(
    PACTCTXGENCTX pActCtxGenCtx,
    PHANDLE SectionHandle
    )
{
	FN_PROLOG_WIN32

    CActivationContextGenerationContextContributor *Ctb = NULL;
    SIZE_T SectionTotalSize = 0;
    SIZE_T TotalHeaderSize = 0;
    SIZE_T AssemblyRosterSize = 0;
    ULONG SectionCount = 0;
    ULONG ExtendedSectionCount = 0;
    ULONG NonExtendedSectionCount = 0;
    CSmartArrayPtr<GUID> ExtendedSectionGuids;
    ULONG ExtensionGuidCount = 0;
    PACTIVATION_CONTEXT_DATA ActCtxData = NULL;
    CMappedViewOfFile VoidActCtxData;
    CFileMapping TempMappingHandle;
    BYTE *Cursor = NULL;
    ULONG i;
    CDequeIterator<ASSEMBLY, offsetof(ASSEMBLY, m_Linkage)> AssemblyIter(&pActCtxGenCtx->m_AssemblyList);
    PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY AssemblyRosterEntry = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER AssemblyInformationSection = NULL;  // we use this after the main part of
                                                                                        // processing to fill in the assembly roster
    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    INTERNAL_ERROR_CHECK(pActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);

    // Let's see how big this whole thing is going to be now.

    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
    {
        Ctb = &pActCtxGenCtx->m_Contributors[i];

        IFW32FALSE_EXIT(Ctb->Fire_AllParsingDone(pActCtxGenCtx));
        IFW32FALSE_EXIT(Ctb->Fire_GetSectionSize(pActCtxGenCtx));

        if (Ctb->SectionSize() > ULONG_MAX)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Contributor %S wants more than ULONG_MAX bytes for its section; failing activation context creation.\n",
                Ctb->Name());

            ORIGINATE_WIN32_FAILURE_AND_EXIT(ContributorNeedsMoreThan2ToThe32ndBytes, ERROR_INSUFFICIENT_BUFFER);
        }

        SectionTotalSize += Ctb->SectionSize();

        if (Ctb->SectionSize() != 0)
        {
            SectionCount++;

            if (Ctb->IsExtendedSection())
                ExtendedSectionCount++;
            else
                NonExtendedSectionCount++;
        }
    }

    ASSERT(SectionCount == (ExtendedSectionCount + NonExtendedSectionCount));

    // If we had any extended sections, we need to figure out how many
    // unique extension GUIDs were present.

    ExtensionGuidCount = 0;

    if (ExtendedSectionCount != 0)
    {
        // There may only be one GUID with 1000 instances, but for the sake of
        // simplicity, we'll just allocate an array equal in size to the number
        // of extended sections, and do a linear search to find dups.  This
        // is a clear candidate for rewriting if the extensibility story
        // takes off.  -mgrier 2/24/2000
        IFW32FALSE_EXIT(ExtendedSectionGuids.Win32Allocate(ExtendedSectionCount, __FILE__, __LINE__));
//        IFALLOCFAILED_EXIT(ExtendedSectionGuids = FUSION_NEW_ARRAY(GUID, ExtendedSectionCount));

        for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        {
            Ctb = &pActCtxGenCtx->m_Contributors[i];

            if ((Ctb->SectionSize() != 0) &&
                Ctb->IsExtendedSection())
            {
                ULONG j;

                for (j=0; j<ExtensionGuidCount; j++)
                {
                    if (ExtendedSectionGuids[j] == Ctb->ExtensionGuid())
                        break;
                }

                if (j == ExtensionGuidCount)
                    ExtendedSectionGuids[ExtensionGuidCount++] = Ctb->ExtensionGuid();
            }
        }
    }

    // Figure out the entire size.  SectionTotalSize already includes all the
    // particular data from the sections; now we need to add in space for the
    // headers etc.

    TotalHeaderSize = 0;

    // The header for the whole thing
    TotalHeaderSize += sizeof(ACTIVATION_CONTEXT_DATA);

    if (NonExtendedSectionCount != 0)
    {
        // The header for the default section TOC
        TotalHeaderSize += sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER);
        // The entry for each non-extended section entry in the TOC.  For now we'll
        // just put the entries in whatever order they're in in the contributor list.
        // the code is in place to do the linear searches and we can optimize this
        // later.
        TotalHeaderSize += (sizeof(ACTIVATION_CONTEXT_DATA_TOC_ENTRY) * NonExtendedSectionCount);
    }

    if (ExtensionGuidCount != 0)
    {
        ULONG j;

        // The header for the extension GUID TOC
        TotalHeaderSize += sizeof(ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER);
        // The entry for each extension GUID
        TotalHeaderSize += (sizeof(ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) * ExtensionGuidCount);

        for (j=0; j<ExtensionGuidCount; j++)
        {
            ULONG SectionCountForThisExtension = 0;
            for (j=0; j<pActCtxGenCtx->m_ContributorCount; j++)
            {
                Ctb = &pActCtxGenCtx->m_Contributors[j];

                if ((Ctb->SectionSize() != 0) &&
                    Ctb->IsExtendedSection() &&
                    (Ctb->ExtensionGuid() == ExtendedSectionGuids[j]))
                    SectionCountForThisExtension++;
            }

            TotalHeaderSize += sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER);
            TotalHeaderSize += (sizeof(ACTIVATION_CONTEXT_DATA_TOC_ENTRY) * SectionCountForThisExtension);
        }
    }

    SectionTotalSize += TotalHeaderSize;

    // Allocate space for the assembly roster and the one dead entry at the beginning of the array.
    AssemblyRosterSize =
        sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER)
        + sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY)
        + (sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) * pActCtxGenCtx->m_AssemblyList.GetEntryCount());

    SectionTotalSize += AssemblyRosterSize;

    if (SectionTotalSize > ULONG_MAX)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Total size of activation context exceeds ULONG_MAX; failing activation context creation.\n");

        ORIGINATE_WIN32_FAILURE_AND_EXIT(SectionSizeTotalMoreThan2ToThe32nd, ERROR_INSUFFICIENT_BUFFER);

        goto Exit;
    }

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ACTCTX,
        "SXS.DLL: Creating %lu byte file mapping\n", static_cast<ULONG>(SectionTotalSize));



    IFW32NULL_EXIT(
        TempMappingHandle.Win32CreateFileMapping(
            INVALID_HANDLE_VALUE,       // Pagefile backed section
            PAGE_READWRITE,
            SectionTotalSize));

    IFW32NULL_EXIT(VoidActCtxData.Win32MapViewOfFile(TempMappingHandle, FILE_MAP_WRITE));
    ActCtxData = reinterpret_cast<PACTIVATION_CONTEXT_DATA>(static_cast<PVOID>(VoidActCtxData));

    ActCtxData->Magic = ACTIVATION_CONTEXT_DATA_MAGIC;
    ActCtxData->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA);
    ActCtxData->FormatVersion = ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER;
    ActCtxData->TotalSize = static_cast<ULONG>(SectionTotalSize);
    ActCtxData->Flags = 0;

    if (pActCtxGenCtx->m_NoInherit)
        ActCtxData->Flags |= ACTIVATION_CONTEXT_FLAG_NO_INHERIT;

    Cursor = (BYTE *) (ActCtxData + 1);

    AssemblyRosterHeader = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) Cursor;

    Cursor = (BYTE *) (AssemblyRosterHeader + 1);

    AssemblyRosterHeader->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER);
    AssemblyRosterHeader->HashAlgorithm = FUSION_HASH_ALGORITHM;
    AssemblyRosterHeader->EntryCount = static_cast<ULONG>(pActCtxGenCtx->m_AssemblyList.GetEntryCount() + 1);
    AssemblyRosterHeader->FirstEntryOffset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) ActCtxData));

    AssemblyRosterEntry = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) Cursor;
    Cursor = (BYTE *) (AssemblyRosterEntry + AssemblyRosterHeader->EntryCount);

    // First assembly roster entry is a blank one for index 0
    AssemblyRosterEntry[0].Flags = ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID;
    AssemblyRosterEntry[0].AssemblyNameLength = 0;
    AssemblyRosterEntry[0].AssemblyNameOffset = 0;
    AssemblyRosterEntry[0].PseudoKey = 0;

    // Fill in the roster with bogus data to start with; we'll fill it in for real after
    // we've found the assembly information section.
    for (AssemblyIter.Reset(), i = 1; AssemblyIter.More(); AssemblyIter.Next(), i++)
    {
        AssemblyRosterEntry[i].Flags = ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID;

        if (AssemblyIter->IsRoot())
            AssemblyRosterEntry[i].Flags |= ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT;
    }

    ActCtxData->AssemblyRosterOffset = static_cast<LONG>(((LONG_PTR) AssemblyRosterHeader) - ((LONG_PTR) ActCtxData));

    if (NonExtendedSectionCount != 0)
    {
        PACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = (PACTIVATION_CONTEXT_DATA_TOC_HEADER) Cursor;
        PACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry = (PACTIVATION_CONTEXT_DATA_TOC_ENTRY) (Toc + 1);
        ULONG iEntry = 0;
        ULONG j;
        ULONG LastSectionId;

        Toc->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER);
        Toc->EntryCount = NonExtendedSectionCount;
        Toc->FirstEntryOffset = static_cast<LONG>(((LONG_PTR) Entry) - ((LONG_PTR) ActCtxData));

        Cursor = (BYTE *) (Entry + NonExtendedSectionCount);

        // Since we sorted the providers prior to building the array, we can set the
        // inorder bit so that we at least do a binary search at runtime.
        // We'll assume it's dense also; if we find out that it isn't while we're
        // building, we'll clear the dense bit.
        Toc->Flags = ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER | ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE;

        for (j=0; j<pActCtxGenCtx->m_ContributorCount; j++)
        {
            Ctb = &pActCtxGenCtx->m_Contributors[j];

            LastSectionId = 0;

            if ((Ctb->SectionSize() != 0) &&
                !Ctb->IsExtendedSection())
            {
                if (iEntry != 0)
                {
                    if (Ctb->SectionId() != (LastSectionId + 1))
                        Toc->Flags &= ~ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE;
                }

                LastSectionId = Ctb->SectionId();

                Entry->Id = Ctb->SectionId();
                Entry->Offset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) ActCtxData));
                Entry->Length = static_cast<ULONG>(Ctb->SectionSize());
                Entry->Format = Ctb->SectionFormat();

                IFW32FALSE_EXIT(Ctb->Fire_GetSectionData(pActCtxGenCtx, Cursor));

                // We have special knowledge about the assembly metadata section; we reference it
                // in the assembly roster.
                if (Ctb->SectionId() == ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION)
                    AssemblyInformationSection = (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) Cursor;

                Cursor = (BYTE *) (((ULONG_PTR) Cursor) + Ctb->SectionSize());
                Entry++;
                iEntry++;
            }
        }

        ActCtxData->DefaultTocOffset = static_cast<LONG>(((LONG_PTR) Toc) - ((LONG_PTR) ActCtxData));
    }
    else
        ActCtxData->DefaultTocOffset = 0;

    if (ExtensionGuidCount != 0)
    {
        ULONG j;
        PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER ExtToc = (PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) Cursor;
        PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY ExtTocEntry = (PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (ExtToc + 1);

        Cursor = (BYTE *) (ExtTocEntry + ExtensionGuidCount);

        ExtToc->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER);
        ExtToc->EntryCount = ExtensionGuidCount;
        ExtToc->FirstEntryOffset = static_cast<LONG>(((LONG_PTR) ExtTocEntry) - ((LONG_PTR) ActCtxData));
        ExtToc->Flags = 0;

        for (j=0; j<ExtensionGuidCount; j++)
        {
            ULONG k;
            ULONG SectionCountForThisExtension = 0;
            PACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = (PACTIVATION_CONTEXT_DATA_TOC_HEADER) Cursor;
            PACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry = (PACTIVATION_CONTEXT_DATA_TOC_ENTRY) (Toc + 1);

            ExtTocEntry->ExtensionGuid = ExtendedSectionGuids[i];

            for (k=0; k<pActCtxGenCtx->m_ContributorCount; k++)
            {
                Ctb = &pActCtxGenCtx->m_Contributors[k];

                if ((Ctb->SectionSize() != 0) &&
                    Ctb->IsExtendedSection() &&
                    (Ctb->ExtensionGuid() == ExtendedSectionGuids[j]))
                {
                    SectionCountForThisExtension++;
                }
            }

            Cursor = (BYTE *) (Entry + SectionCountForThisExtension);

            Toc->HeaderSize = sizeof(ACTIVATION_CONTEXT_DATA_TOC_HEADER);
            Toc->EntryCount = SectionCountForThisExtension;
            Toc->FirstEntryOffset = static_cast<LONG>(((LONG_PTR) Entry) - ((LONG_PTR) ActCtxData));
            Toc->Flags = 0;

            for (k=0; k<pActCtxGenCtx->m_ContributorCount; k++)
            {
                Ctb = &pActCtxGenCtx->m_Contributors[k];

                if ((Ctb->SectionSize() != 0) &&
                    Ctb->IsExtendedSection() &&
                    (Ctb->ExtensionGuid() == ExtendedSectionGuids[k]) &&
                    (Ctb->SectionId() != 0) )
                {
                    SIZE_T SectionSize = Ctb->SectionSize();

                    Entry->Id = Ctb->SectionId();
                    Entry->Offset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) ActCtxData));
                    Entry->Length = static_cast<ULONG>(SectionSize);
                    Entry->Format = Ctb->SectionFormat();

                    IFW32FALSE_EXIT(Ctb->Fire_GetSectionData(pActCtxGenCtx, Cursor));

                    Cursor = (BYTE *) (((ULONG_PTR) Cursor) + SectionSize);
                    Entry++;
                }
            }
        }

        ActCtxData->ExtendedTocOffset = static_cast<LONG>(((LONG_PTR) ExtToc) - ((LONG_PTR) ActCtxData));
    }
    else
        ActCtxData->ExtendedTocOffset = 0;

    ASSERT(AssemblyInformationSection != NULL);
    // Go back and fill in the assembly roster...
    if (AssemblyInformationSection != NULL)
    {
        PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY Entries = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY)
            (((ULONG_PTR) AssemblyInformationSection) + AssemblyInformationSection->ElementListOffset);
        LONG_PTR SectionOffset = ((LONG_PTR) AssemblyInformationSection) - ((LONG_PTR) ActCtxData);

        AssemblyRosterHeader->HashAlgorithm = AssemblyInformationSection->HashAlgorithm;
        AssemblyRosterHeader->AssemblyInformationSectionOffset = static_cast<ULONG>(SectionOffset);

        // If there are 3 assemblies, there must be 3 entries in the section and 4 roster entries
        // (counting the bogus entry 0).
        ASSERT(AssemblyInformationSection->ElementCount == (AssemblyRosterHeader->EntryCount - 1));
        if (AssemblyInformationSection->ElementCount != (AssemblyRosterHeader->EntryCount - 1))
        {
            ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
            goto Exit;
        }

        for (i=0; i<AssemblyInformationSection->ElementCount; i++)
        {
            ULONG iRoster = Entries[i].AssemblyRosterIndex;

            ASSERT(iRoster != 0);
            ASSERT(iRoster < AssemblyRosterHeader->EntryCount);

            if ((iRoster == 0) ||
                (iRoster >= AssemblyRosterHeader->EntryCount))
            {
                ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
                goto Exit;
            }

            // Make sure that we're not repeating an index somehow...
            ASSERT(AssemblyRosterEntry[iRoster].Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID);
            if ((AssemblyRosterEntry[iRoster].Flags & ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID) == 0)
            {
                ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
                goto Exit;
            }

            // Turn off the invalid flag...
            AssemblyRosterEntry[iRoster].Flags &= ~ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID;

            // Point to the data already in the string section header
            AssemblyRosterEntry[iRoster].AssemblyNameLength = Entries[i].KeyLength;

            if (Entries[i].KeyOffset != 0)
                AssemblyRosterEntry[iRoster].AssemblyNameOffset = static_cast<LONG>(Entries[i].KeyOffset + SectionOffset);
            else
                AssemblyRosterEntry[iRoster].AssemblyNameOffset = 0;

            AssemblyRosterEntry[iRoster].AssemblyInformationLength = Entries[i].Length;
            AssemblyRosterEntry[iRoster].AssemblyInformationOffset = static_cast<LONG>(Entries[i].Offset + SectionOffset);
            AssemblyRosterEntry[iRoster].PseudoKey = Entries[i].PseudoKey;
        }
    }
    else
    {
        // the assembly metadata section provider should have contributed *something*
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    if (::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_ACTCTX))
    {
        CTinyStringBuffer buffPrefix;
        ::SxspDbgPrintActivationContextData(FUSION_DBG_LEVEL_ACTCTX, ActCtxData, buffPrefix);
    }

    IFW32FALSE_EXIT(VoidActCtxData.Win32Close());
    *SectionHandle = TempMappingHandle.Detach();

	FN_EPILOG
}

CPendingAssembly::CPendingAssembly() :
    m_SourceAssembly(NULL),
    m_Identity(NULL),
    m_Optional(false),
    m_MetadataSatellite(false)
{
}

CPendingAssembly::~CPendingAssembly()
{
    if (m_Identity != NULL)
    {
        ::SxsDestroyAssemblyIdentity(m_Identity);
        m_Identity = NULL;
    }
}

BOOL
CPendingAssembly::Initialize(
    PASSEMBLY Assembly,
    PCASSEMBLY_IDENTITY Identity,
    bool Optional,
    bool MetadataSatellite
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_Identity == NULL);

    PARAMETER_CHECK(Identity != NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, Identity, &m_Identity));
    m_SourceAssembly = Assembly;
    m_Optional = Optional;
    m_MetadataSatellite = MetadataSatellite;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\shims\shimlib.cpp ===
#include "stdinc.h"
#include "lhport.h"
#include "imagehlp.h"
#include "winthrow.h"
#include "fusionbuffer.h"
#include "sxshimlib.h"
#include "fusionhandle.h"
#include <stdio.h>

BOOL
SxspFormatGUID(
    IN const GUID &rGuid,
    IN OUT F::CBaseStringBuffer &rBuffer
    );

//
// Not yet used but I expect either we'll need it, or we'll just not shim msvcrt.dll at all.
// This list is derived from searching public\sdk\inc\crt for "_CRTIMP extern"
//

BOOL
SxpepIsKnownDataSymbol()
{
    return FALSE;
}

//
// arg, the implementation but not the declaration of this was removed..
//
#include "yvals.h"
#pragma warning(disable:4663)
#include <vector>
class CMySmallANSIStringBuffer : public std::vector<char>
{
public:
    CMySmallANSIStringBuffer() { }
    ~CMySmallANSIStringBuffer() { }

    void RemoveTrailingNuls()
    {
        while (this->size() != 0 && this->operator[](this->size() - 1) == 0)
            this->resize(size() - 1);
    }

    BOOL Win32Append(PCSTR s)
    {
        return this->Win32Append(s, ::strlen(s));
    }

    BOOL Win32Append(PCSTR s, SIZE_T i)
    {
        this->RemoveTrailingNuls();
        SIZE_T j = this->size();
        this->resize(j + i + 1);
        CopyMemory(&*begin() + j, s, i);
        this->operator[](i + j) = 0;
        return TRUE;
    }

    BOOL Win32Assign(PCSTR s, SIZE_T i)
    {
        this->clear();
        return this->Win32Append(s, i);
    }

    operator PCSTR()
    {
        this->EnsureTrailingNul();
        return &*begin();
    }

    void EnsureTrailingNul()
    {
        if (this->size() == 0 || this->operator[](size() - 1) != 0)
        {
            this->push_back(0);
        }
    }
};

BOOL
SxPepApplyShims(
    PCSXPE_APPLY_SHIMS_IN  in,
    SXPE_APPLY_SHIMS_OUT* out
    )
{
    FN_PROLOG_WIN32

    ULONG                   Size = 0;
    PIMAGE_SECTION_HEADER   ImportSection = NULL;
    PBYTE                   FromHandle = NULL;
    PIMAGE_NT_HEADERS       FromNtHeader = NULL;
    PCWSTR                  ToPath = NULL;
    PBYTE                   ImportData = NULL;
    DWORD                   OldImportSectionVirtualProtection = 0;
    PCSTR                   ImportDllName = NULL;
    PCSTR*                  ImportFunctionNames = NULL;
    PBYTE*                  ImportFunctionAddresses = NULL;
    CMySmallANSIStringBuffer  PrefixedFunctionName;
    F::CDynamicLinkLibrary     ToHandle;
    SIZE_T                  PrefixLength = 0;

    FromHandle = reinterpret_cast<PBYTE>(in->DllToRedirectFrom);
    FromNtHeader = ImageNtHeaderOrThrow(FromHandle);

    ToPath = in->DllToRedirectTo.Path;
    out->DllToRedirectTo.Path = ToPath;
    ToHandle = in->DllToRedirectTo.DllHandle;
    if (ToHandle == static_cast<HMODULE>(NULL))
    {
        ToHandle = LoadLibraryWOrThrow(ToPath);
    }
    out->DllToRedirectTo.DllHandle = ToHandle;

    ImportData = reinterpret_cast<PBYTE>(ImageDirectoryEntryToDataExOrThrow(
                        FromHandle, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &Size, &ImportSection));
    // ImageDirectoryEntryToDataEx almost never returns the ImportSection.
    if (ImportSection == NULL)
        ImportSection = ImageRvaToSectionOrThrow(FromNtHeader, FromHandle, static_cast<ULONG>(ImportData - FromHandle));
   
    VirtualProtectOrThrow(
        FromHandle + ImportSection->VirtualAddress,
        ImportSection->Misc.VirtualSize,
        PAGE_WRITECOPY,
        &OldImportSectionVirtualProtection
        );
    if (in->Prefix != NULL)
        PrefixLength = ::strlen(in->Prefix);
    for (
        PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(ImportData);
        ImportDescriptor->Characteristics != 0 ;
        ++ImportDescriptor
        )
    {
        PCSTR ImportDllName = reinterpret_cast<PCSTR>(FromHandle + ImportDescriptor->Name);
        printf("%s\n", ImportDllName);
        DWORD* ImportFunctionNames = reinterpret_cast<DWORD*>(FromHandle + ImportDescriptor->OriginalFirstThunk);
        PVOID* ImportFunctionAddresses = reinterpret_cast<PVOID*>(FromHandle + ImportDescriptor->FirstThunk);
        for ( ; *ImportFunctionNames != NULL && *ImportFunctionAddresses != NULL ; ++ImportFunctionNames, ++ImportFunctionAddresses )
        {
            typedef WORD HINT;
            PCSTR NonPrefixedFunctionName = sizeof(HINT) + reinterpret_cast<PCSTR>(FromHandle + *ImportFunctionNames);
            PCSTR PossiblyPrefixedFunctionName = NonPrefixedFunctionName;

            // we should make this available to the shims, like to enable shim chaining
            //PVOID OriginalFunctionAddress = *ImportFunctionAddresses;

            if (PrefixLength != 0)
            {
                IFW32FALSE_EXIT(PrefixedFunctionName.Win32Assign(in->Prefix, PrefixLength));
                IFW32FALSE_EXIT(PrefixedFunctionName.Win32Append(NonPrefixedFunctionName));
                PossiblyPrefixedFunctionName = PrefixedFunctionName;
            }
            PVOID NewFunctionAddress = ::GetProcAddress(ToHandle, PossiblyPrefixedFunctionName);
            if (NewFunctionAddress == NULL)
            {
                printf( "%s%s%s%s not shimmed\n",
                        NonPrefixedFunctionName,
                        PossiblyPrefixedFunctionName != NonPrefixedFunctionName ? "(" : "",
                        PossiblyPrefixedFunctionName != NonPrefixedFunctionName ? PossiblyPrefixedFunctionName : "",
                        PossiblyPrefixedFunctionName != NonPrefixedFunctionName ? ")" : ""
                      );
            }
            else
            {
                PVOID OldAddress = *ImportFunctionAddresses;
                printf("%p.%s.%p shimmed to %ls%s%p.%s.%p\n",
                    in->DllToRedirectFrom,
                    NonPrefixedFunctionName,
                    OldAddress,

                    (ToPath != NULL) ? ToPath : L"",
                    (ToPath != NULL) ? "."    : "",
                    ToHandle,
                    PossiblyPrefixedFunctionName,
                    NewFunctionAddress);
                *ImportFunctionAddresses = NewFunctionAddress;

                //
                // if they have export named <prefix>OriginalFoo, poke
                // it with the old address (we include the prefix so that
                // chaining might work)
                //
                IFW32FALSE_EXIT(PrefixedFunctionName.Win32Assign(in->Prefix, PrefixLength));
                IFW32FALSE_EXIT(PrefixedFunctionName.Win32Append("Original"));
                IFW32FALSE_EXIT(PrefixedFunctionName.Win32Append(NonPrefixedFunctionName));
                PVOID* InformOriginalAddress = reinterpret_cast<PVOID*>(::GetProcAddress(ToHandle, PrefixedFunctionName));
                if (InformOriginalAddress != NULL)
                    *InformOriginalAddress = OldAddress;
            }
        }
    }
    VirtualProtectOrThrow(
        FromHandle + ImportSection->VirtualAddress,
        ImportSection->Misc.VirtualSize,
        OldImportSectionVirtualProtection,
        &OldImportSectionVirtualProtection
        );

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\actctxgenctx.h ===
#if !defined(_FUSION_SXS_ACTCTXGENCTX_H_INCLUDED_)
#define _FUSION_SXS_ACTCTXGENCTX_H_INCLUDED_

#pragma once

#include "fusionbuffer.h"
#include "pendingassembly.h"

typedef struct _ACTCTXGENCTX
{
    _ACTCTXGENCTX();
    ~_ACTCTXGENCTX();

    CActivationContextGenerationContextContributor *m_Contributors;
    ULONG m_ContributorCount;
    USHORT m_ProcessorArchitecture;
    CSmallStringBuffer m_SpecificLanguage;
    CSmallStringBuffer m_GenericLanguage;
    CSmallStringBuffer m_SpecificSystemLanguage;
    CSmallStringBuffer m_GenericSystemLanguage;
    LANGID m_LangID;
    LANGID m_SystemLangID;
    CStringBuffer m_AssemblyRootDirectoryBuffer;
    ULONG m_AssemblyRootDirectoryPathType;
    CStringBuffer m_ApplicationDirectoryBuffer;
    ULONG m_ApplicationDirectoryPathType;
    CImpersonationData m_ImpersonationData;
    DWORD m_Flags; // these are the same flags as ACTCTXCTB_CBHEADER::m_Flags
    ULONG m_ManifestOperation;
    DWORD m_ManifestOperationFlags;
    ACTCTXCTB_INSTALLATION_CONTEXT m_InstallationContext;
    CClsidMap m_ClsidMap;
    ACTCTXCTB_CLSIDMAPPING_CONTEXT m_ClsidMappingContext;
    ULONG m_NextAssemblyRosterIndex;
    BOOL  m_fClsidMapInitialized;
    ULONG m_InitializedContributorCount;
    bool m_NoInherit;
    bool m_ApplicationDirectoryHasBeenProbedForLanguageSubdirs;
    bool m_ApplicationDirectoryHasSpecificLanguageSubdir;
    bool m_ApplicationDirectoryHasGenericLanguageSubdir;
    bool m_ApplicationDirectoryHasSpecificSystemLanguageSubdir;
    bool m_ApplicationDirectoryHasGenericSystemLanguageSubdir;
    ULONG m_ulFileCount;
    SXS_PUBLISHER_POLICY_APPLY m_fAppApplyPublisherPolicy;

    CCaseInsensitiveUnicodeStringPtrTable<ASSEMBLY, CAssemblyTableHelper> m_AssemblyTable;
    CCaseInsensitiveUnicodeStringPtrTable<CPolicyStatement> m_ApplicationPolicyTable;
    CCaseInsensitiveUnicodeStringPtrTable<CPolicyStatement> m_ComponentPolicyTable;
    CDeque<ASSEMBLY, offsetof(ASSEMBLY, m_Linkage)> m_AssemblyList;
    CDeque<CPendingAssembly, offsetof(CPendingAssembly, m_Linkage)> m_PendingAssemblyList;

    CNodeFactory * m_pNodeFactory;

    struct A
    {
        CStringBuffer EncodedPolicyIdentity;
        CStringBuffer CandidatePolicyDirectory;
    } CProbedAssemblyInformationLookForPolicy;

    struct B
    {
        CStringBuffer sbAssemblyDirectory;
        CSmallStringBuffer sbManifestFileName; // rarely used, mainly for system compatible assembly
    } SxsGenerateActivationContextLocals;

private:
    _ACTCTXGENCTX(const _ACTCTXGENCTX &);
    void operator =(const _ACTCTXGENCTX &);
} ACTCTXGENCTX, *PACTCTXGENCTX;

typedef const struct _ACTCTXGENCTX *PCACTCTXGENCTX;

#endif // !defined(_FUSION_SXS_ACTCTXGENCTX_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\actctxgenctxctb.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "actctxgenctxctb.h"
#include "sxsexceptionhandling.h"
#include "actctxgenctx.h"

#define ENSURE_LAST_ERROR_SET() \
do \
    { \
    ASSERT_NTC(::FusionpGetLastWin32Error() != ERROR_SUCCESS); \
    if (::FusionpGetLastWin32Error() == ERROR_SUCCESS) \
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR); \
    } while (0)

/*-----------------------------------------------------------------------------
ACTivation ConTeXt GENneration ConTeXt ConTriButor
-----------------------------------------------------------------------------*/

int
CActivationContextGenerationContextContributor::Compare(
    const void *pelem1,
    const void *pelem2
    )
{
    const CActivationContextGenerationContextContributor *Ctb1 = reinterpret_cast<const CActivationContextGenerationContextContributor *>(pelem1);
    const CActivationContextGenerationContextContributor *Ctb2 = reinterpret_cast<const CActivationContextGenerationContextContributor *>(pelem2);

    if (Ctb1->IsExtendedSection())
    {
        if (!Ctb2->IsExtendedSection())
            return -1;

        // otherwise they're both extended...
        int i = memcmp(Ctb1->m_ActCtxCtb->GetExtensionGuidPtr(), Ctb2->m_ActCtxCtb->GetExtensionGuidPtr(), sizeof(GUID));
        if (i != 0)
            return i;
    }
    else
    {
        if (Ctb2->IsExtendedSection())
            return +1;
    }

    // comparison of unsigned numbers by subtraction does not work,
    // you can cast them to signed first, but this seems cleaner
    const ULONG sectionId1 = Ctb1->m_ActCtxCtb->m_SectionId;
    const ULONG sectionId2 = Ctb2->m_ActCtxCtb->m_SectionId;
    if (sectionId1 < sectionId2)
        return -1;
    if (sectionId1 > sectionId2)
        return +1;

    return 0;
}

CActivationContextGenerationContextContributor::~CActivationContextGenerationContextContributor()
{
    if (m_ActCtxCtb != NULL)
    {
        CSxsPreserveLastError ple;
        m_ActCtxCtb->Release();
        ple.Restore();
    }
}

VOID
CActivationContextGenerationContextContributor::PopulateCallbackHeader(
    ACTCTXCTB_CBHEADER &Header,
    ULONG Reason,
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    Header.Reason = Reason;
    Header.Flags = pActCtxGenCtx->m_Flags;
    Header.ManifestOperation = pActCtxGenCtx->m_ManifestOperation;
    Header.ManifestOperationFlags = pActCtxGenCtx->m_ManifestOperationFlags;
    Header.InstallationContext = &pActCtxGenCtx->m_InstallationContext;
    Header.ClsidMappingContext = &pActCtxGenCtx->m_ClsidMappingContext;
    Header.ExtensionGuid = m_ActCtxCtb->GetExtensionGuidPtr();
    Header.SectionId = m_ActCtxCtb->m_SectionId;
    Header.ContributorContext = m_ActCtxCtb->m_ContributorContext;
    Header.pOriginalActCtxGenCtx = pActCtxGenCtx;
    if (m_ManifestParseContextValid)
        Header.ManifestParseContext = m_ManifestParseContext;
    else
        Header.ManifestParseContext = NULL;
    Header.ActCtxGenContext = m_ActCtxGenContext;
}

BOOL
CActivationContextGenerationContextContributor::Initialize(
    PACTCTXCTB ActCtxCtb,
    PVOID ActCtxGenContext
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_ActCtxCtb == NULL);
    INTERNAL_ERROR_CHECK(m_ActCtxGenContext == NULL);

    PARAMETER_CHECK(ActCtxCtb != NULL);

    ActCtxCtb->AddRef();
    m_ActCtxCtb = ActCtxCtb;

    m_ActCtxGenContext = ActCtxGenContext;
    m_IsExtendedSection = ActCtxCtb->m_IsExtendedSection;

    FN_EPILOG
}

PCWSTR
CActivationContextGenerationContextContributor::Name() const
{
    return m_ActCtxCtb->m_ContributorNameBuffer;
}

const GUID &
CActivationContextGenerationContextContributor::ExtensionGuid() const
{
    return m_ActCtxCtb->m_ExtensionGuid;
}

ULONG
CActivationContextGenerationContextContributor::SectionId() const
{
    return m_ActCtxCtb->m_SectionId;
}

ULONG
CActivationContextGenerationContextContributor::SectionFormat() const
{
    return m_ActCtxCtb->m_Format;
}

BOOL
CActivationContextGenerationContextContributor::Fire_AllParsingDone(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ACTCTXCTB_CBALLPARSINGDONE CBData;

    this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ALLPARSINGDONE, pActCtxGenCtx);

    CBData.Success = TRUE;
    ::FusionpSetLastWin32Error(ERROR_SUCCESS);

    (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

    if (!CBData.Success)
    {
        ENSURE_LAST_ERROR_SET();
        pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        goto Exit;
    }

    FN_EPILOG
}

BOOL
CActivationContextGenerationContextContributor::Fire_GetSectionSize(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ACTCTXCTB_CBGETSECTIONSIZE CBData;

    this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_GETSECTIONSIZE, pActCtxGenCtx);

    CBData.SectionSize = 0;
    CBData.Success = TRUE;
    ::FusionpSetLastWin32Error(ERROR_SUCCESS);

    (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

    if (!CBData.Success)
    {
        ENSURE_LAST_ERROR_SET();
        pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        goto Exit;
    }

    m_SectionSize = CBData.SectionSize;

    FN_EPILOG
}

BOOL
CActivationContextGenerationContextContributor::Fire_GetSectionData(
    PACTCTXGENCTX pActCtxGenCtx,
    PVOID Buffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ACTCTXCTB_CBGETSECTIONDATA CBData;

    this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_GETSECTIONDATA, pActCtxGenCtx);
    CBData.SectionSize = m_SectionSize;
    CBData.SectionDataStart = Buffer;
    CBData.Success = TRUE;
    ::FusionpSetLastWin32Error(ERROR_SUCCESS);

    (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

    if (!CBData.Success)
    {
        ENSURE_LAST_ERROR_SET();
        pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        goto Exit;
    }

    FN_EPILOG
}

BOOL
CActivationContextGenerationContextContributor::Fire_ParseEnding(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if ((m_ActCtxCtb != NULL) &&
        (m_ManifestParseContextValid) &&
        (!m_NoMoreCallbacksThisFile))
    {
        if (m_ManifestParseContextValid)
        {
            ACTCTXCTB_CBPARSEENDING CBData;

            this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_PARSEENDING, pActCtxGenCtx);
            CBData.AssemblyContext = AssemblyContext;
            CBData.Success = TRUE;
            ::FusionpSetLastWin32Error(ERROR_SUCCESS);

            (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

            if (!CBData.Success)
            {
                ENSURE_LAST_ERROR_SET();
                pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
                goto Exit;
            }
        }
    }

    FN_EPILOG
}

VOID
CActivationContextGenerationContextContributor::Fire_ParseEnded(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    FN_TRACE();
    if ((m_ActCtxCtb != NULL) &&
        (m_ManifestParseContextValid) &&
        (!m_NoMoreCallbacksThisFile))
    {
        if (m_ManifestParseContextValid)
        {
            CSxsPreserveLastError ple;
            ACTCTXCTB_CBPARSEENDED CBData;

            this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_PARSEENDED, pActCtxGenCtx);
            CBData.AssemblyContext = AssemblyContext;

            (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

            m_ManifestParseContextValid = FALSE;
            m_ManifestParseContext = NULL;

            ple.Restore();
        }
    }
}

BOOL
CActivationContextGenerationContextContributor::Fire_ActCtxGenEnding(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (m_ActCtxCtb != NULL)
    {
        ACTCTXCTB_CBACTCTXGENENDING CBData;
        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ACTCTXGENENDING, pActCtxGenCtx);
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);
        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);
        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    FN_EPILOG
}

VOID
CActivationContextGenerationContextContributor::Fire_ActCtxGenEnded(
    PACTCTXGENCTX pActCtxGenCtx
    )
{
    FN_TRACE();
    if (m_ActCtxCtb != NULL)
    {
        CSxsPreserveLastError ple;
        ACTCTXCTB_CBACTCTXGENENDED CBData;
        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ACTCTXGENENDED, pActCtxGenCtx);
        CBData.Success = (BOOL) ((LONG_PTR) -1);
        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);
        ASSERT(CBData.Success == (BOOL) ((LONG_PTR) -1));
        m_ActCtxGenContext = NULL;
        ple.Restore();
    }
}

BOOL
CActivationContextGenerationContextContributor::Fire_BeginChildren(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    PCSXS_NODE_INFO NodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBBEGINCHILDREN CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_BEGINCHILDREN, pActCtxGenCtx);
        CBData.AssemblyContext = AssemblyContext;
        CBData.ParseContext = ParseContext;
        CBData.NodeInfo = NodeInfo;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    FN_EPILOG
}

BOOL
CActivationContextGenerationContextContributor::Fire_EndChildren(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    BOOL Empty,
    PCSXS_NODE_INFO NodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBENDCHILDREN CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ENDCHILDREN, pActCtxGenCtx);
        CBData.Empty = Empty;
        CBData.NodeInfo = NodeInfo;
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    FN_EPILOG
}

BOOL
CActivationContextGenerationContextContributor::Fire_ElementParsed(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    USHORT NodeCount,
    PCSXS_NODE_INFO NodeInfo
    )
{
	FN_PROLOG_WIN32

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBELEMENTPARSED CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_ELEMENTPARSED, pActCtxGenCtx);
        CBData.NodeCount = NodeCount;
        CBData.NodeInfo = NodeInfo;
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
			TRACE_WIN32_FAILURE((*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header));
            goto Exit;
        }
    }

    FN_EPILOG
}

BOOL
CActivationContextGenerationContextContributor::Fire_PCDATAParsed(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    const WCHAR *String,
    ULONG Cch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBPCDATAPARSED CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_PCDATAPARSED, pActCtxGenCtx);
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Text = String;
        CBData.TextCch = Cch;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    FN_EPILOG
}

BOOL
CActivationContextGenerationContextContributor::Fire_CDATAParsed(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    const WCHAR *String,
    ULONG Cch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBCDATAPARSED CBData;

        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_CDATAPARSED, pActCtxGenCtx);
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Text = String;
        CBData.TextCch = Cch;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    FN_EPILOG
}

BOOL
CActivationContextGenerationContextContributor::Fire_IdentityDetermined(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_NoMoreCallbacksThisFile)
    {
        ACTCTXCTB_CBIDENTITYDETERMINED CBData;
        this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_IDENTITYDETERMINED, pActCtxGenCtx);
        CBData.AssemblyIdentity = AssemblyIdentity;
        CBData.ParseContext = ParseContext;
        CBData.AssemblyContext = AssemblyContext;
        CBData.Success = TRUE;
        ::FusionpSetLastWin32Error(ERROR_SUCCESS);

        (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

        if (!CBData.Success)
        {
            ENSURE_LAST_ERROR_SET();
            pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
            goto Exit;
        }
    }

    FN_EPILOG
}


BOOL
CActivationContextGenerationContextContributor::Fire_ParseBeginning(
    PACTCTXGENCTX pActCtxGenCtx,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    DWORD FileFlags,
    ULONG ParseType,
    ULONG FilePathType,
    PCWSTR FilePath,
    SIZE_T FilePathCch,
    const FILETIME &FileLastWriteTime,
    ULONG FileFormatVersionMajor,
    ULONG FileFormatVersionMinor,
    ULONG MetadataSatelliteRosterIndex
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ACTCTXCTB_CBPARSEBEGINNING CBData;

    PARAMETER_CHECK(FilePathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);

    INTERNAL_ERROR_CHECK(!m_ManifestParseContextValid);

    this->PopulateCallbackHeader(CBData.Header, ACTCTXCTB_CBREASON_PARSEBEGINNING, pActCtxGenCtx);

    CBData.FileFlags = FileFlags;
    CBData.ParseType = ParseType;
    CBData.AssemblyContext = AssemblyContext;
    CBData.FilePath = FilePath;
    CBData.FilePathCch = FilePathCch;
    CBData.FilePathType = FilePathType;
    CBData.FileLastWriteTime = FileLastWriteTime;
    CBData.FileFormatVersionMajor = FileFormatVersionMajor;
    CBData.FileFormatVersionMinor = FileFormatVersionMinor;
    CBData.MetadataSatelliteRosterIndex = MetadataSatelliteRosterIndex;
    CBData.NoMoreCallbacksThisFile = FALSE;
    CBData.Success = TRUE;

    (*(m_ActCtxCtb->m_CallbackFunction))((PACTCTXCTB_CALLBACK_DATA) &CBData.Header);

    if (!CBData.Success)
    {
        ENSURE_LAST_ERROR_SET();
        pActCtxGenCtx->m_ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        goto Exit;
    }

    m_NoMoreCallbacksThisFile = CBData.NoMoreCallbacksThisFile;
    if (!m_NoMoreCallbacksThisFile)
    {
        // If they set the no more callbacks flag, we don't track the parse context.
        m_ManifestParseContext = CBData.Header.ManifestParseContext;
        m_ManifestParseContextValid = TRUE;
    }
    else
    {
        m_ManifestParseContext = NULL;
        m_ManifestParseContextValid = FALSE;
        // You can't pass back a per-file parsing context if you don't want any more callbacks for this
        // file.
        ASSERT(CBData.Header.ManifestParseContext == NULL);
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\actctxgenctxctb.h ===
#if !defined(_FUSION_SXS_ACTCTXGENCTXCTB_H_INCLUDED_)
#define _FUSION_SXS_ACTCTXGENCTXCTB_H_INCLUDED_

#pragma once

/*-----------------------------------------------------------------------------
ACTivation ConTeXt GENneration ConTeXt ConTriButor
-----------------------------------------------------------------------------*/

#include "sxsp.h"
#include "forwarddeclarations.h"

class CActivationContextGenerationContextContributor
{
public:
    CActivationContextGenerationContextContributor() :
        m_ActCtxCtb(NULL),
        m_ActCtxGenContext(NULL),
        m_ManifestParseContext(NULL),
        m_ManifestParseContextValid(FALSE),
        m_NoMoreCallbacksThisFile(FALSE),
        m_SectionSize(0) { }
    ~CActivationContextGenerationContextContributor();

    BOOL Initialize(PACTCTXCTB ActCtxCtb, PVOID ActCtxGenContext);

    VOID PopulateCallbackHeader(ACTCTXCTB_CBHEADER &Header, ULONG Reason, PACTCTXGENCTX pActCtxGenCtx);

    // comparison function for qsort()
    static int __cdecl Compare(const void *pelem1, const void *pelem2);

    bool IsExtendedSection() const { return m_IsExtendedSection; }
    PCWSTR Name() const;
    const GUID &ExtensionGuid() const;
    ULONG SectionId() const;
    ULONG SectionFormat() const;

    BOOL Fire_ParseBeginning(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        DWORD FileFlags,
        ULONG ParseType,
        ULONG FilePathType,
        PCWSTR FilePath,
        SIZE_T FilePathCch,
        const FILETIME &FileLastWriteTime,
        ULONG FileFormatVersionMajor,
        ULONG FileFormatVersionMinor,
        ULONG MetadataSatelliteRosterIndex
        );
    BOOL Fire_IdentityDetermined(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        PCASSEMBLY_IDENTITY AssemblyIdentity
        );
    BOOL Fire_BeginChildren(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        PCSXS_NODE_INFO NodeInfo
        );
    BOOL Fire_EndChildren(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        BOOL Empty,
        PCSXS_NODE_INFO NodeInfo
        );
    BOOL Fire_ElementParsed(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        USHORT NodeCount,
        PCSXS_NODE_INFO NodeInfo
        );
    BOOL Fire_PCDATAParsed(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        const WCHAR *Text,
        ULONG TextCch
        );
    BOOL Fire_CDATAParsed(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        const WCHAR *Text,
        ULONG TextCch
        );
    BOOL Fire_ParseEnding(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );
    VOID Fire_ParseEnded(
        PACTCTXGENCTX pActCtxGenCtx,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );
    BOOL Fire_AllParsingDone(
        PACTCTXGENCTX pActCtxGenCtx
        );
    BOOL Fire_GetSectionSize(
        PACTCTXGENCTX pActCtxGenCtx
        );
    BOOL Fire_GetSectionData(
        PACTCTXGENCTX pActCtxGenCtx,
        PVOID Buffer
        );

    BOOL Fire_ActCtxGenEnding(
        PACTCTXGENCTX pActCtxGenCtx
        );

    VOID Fire_ActCtxGenEnded(
        PACTCTXGENCTX pActCtxGenCtx
        );

    SIZE_T SectionSize() const { return m_SectionSize; }
    PVOID ActCtxGenContext() const { return m_ActCtxGenContext; }

// protected:
    PVOID m_ManifestParseContext;
    BOOL m_ManifestParseContextValid;
    BOOL m_NoMoreCallbacksThisFile;

protected:
    PACTCTXCTB m_ActCtxCtb;
    PVOID m_ActCtxGenContext;
    SIZE_T m_SectionSize;
    bool m_IsExtendedSection;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\asmmetadata.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    asmmetadata.cpp

Abstract:

    Activation context section contributor for the assembly metadata section.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    xiaoyuw         09/2000     revise with Assembly Identity
    xiaoyuw         10/2000     get rid of initialize-code because constructer has done it
--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

typedef struct _ASSEMBLY_METADATA_ENTRY *PASSEMBLY_METADATA_ENTRY;
typedef struct _ASSEMBLY_METADATA_CONTEXT *PASSEMBLY_METADATA_CONTEXT;

typedef struct _ASSEMBLY_METADATA_ENTRY
{
    _ASSEMBLY_METADATA_ENTRY() :
        AssemblyIdentity(NULL),
        ManifestVersionMajor(0),
        ManifestVersionMinor(0),
        ManifestPathType(ACTIVATION_CONTEXT_PATH_TYPE_NONE),
        PolicyPathType(ACTIVATION_CONTEXT_PATH_TYPE_NONE),
        AssemblyPolicyApplied(FALSE),
        RootPolicyApplied(FALSE),
        IsRootAssembly(FALSE),
        IsPrivateAssembly(FALSE),
        MetadataSatelliteRosterIndex(0),
        AssemblyRosterIndex(0)
        {
            ManifestLastWriteTime.dwLowDateTime = 0;
            ManifestLastWriteTime.dwHighDateTime = 0;
            PolicyLastWriteTime.dwLowDateTime = 0;
            PolicyLastWriteTime.dwHighDateTime = 0;
        }

    ~_ASSEMBLY_METADATA_ENTRY()
    {
        CSxsPreserveLastError ple;
        ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(AssemblyIdentity));
        ple.Restore();
    }

    PCASSEMBLY_IDENTITY AssemblyIdentity; // intermediate data

    ULONG ManifestPathType;
    FILETIME ManifestLastWriteTime;
    ULONG PolicyPathType;
    FILETIME PolicyLastWriteTime;
    BOOL AssemblyPolicyApplied;
    BOOL RootPolicyApplied;
    BOOL IsRootAssembly;
    BOOL IsPrivateAssembly;
    ULONG ManifestVersionMajor;
    ULONG ManifestVersionMinor;
    CSmallStringBuffer AssemblyDirectoryNameBuffer;
    ULONG MetadataSatelliteRosterIndex;
    ULONG AssemblyRosterIndex;
    ULONG FileNum;
    CSmallStringBuffer LanguageBuffer;
    CSmallStringBuffer ManifestPathBuffer;
    CTinyStringBuffer PolicyPathBuffer;

private:
    _ASSEMBLY_METADATA_ENTRY(const _ASSEMBLY_METADATA_ENTRY &);
    void operator =(const _ASSEMBLY_METADATA_ENTRY &);

} ASSEMBLY_METADATA_ENTRY;

typedef struct _ASSEMBLY_METADATA_CONTEXT
{
    _ASSEMBLY_METADATA_CONTEXT() : pLastMetaDataEntry(NULL) { }

    ULONG ApplicationDirectoryPathType;
    PCWSTR ApplicationDirectory;
    SIZE_T ApplicationDirectoryCch;
    PASSEMBLY_METADATA_ENTRY pLastMetaDataEntry;
    CSmartPtr<ASSEMBLY_METADATA_ENTRY> pAppConfigEntry;
} ASSEMBLY_METADATA_CONTEXT;



VOID
__fastcall
SxspAssemblyMetadataContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PSTRING_SECTION_GENERATION_CONTEXT SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    PASSEMBLY_METADATA_ENTRY Entry = NULL;
    CSmartPtr<ASSEMBLY_METADATA_CONTEXT> AssemblyMetadataContext;
    BOOL Found = FALSE;
    PASSEMBLY_IDENTITY TempAssemblyIdentity = NULL;

    if (SSGenContext != NULL)
        AssemblyMetadataContext.AttachNoDelete(reinterpret_cast<PASSEMBLY_METADATA_CONTEXT>(::SxsGetStringSectionGenerationContextCallbackContext(SSGenContext)));

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        {
            PACTCTXCTB_CBACTCTXGENBEGINNING CBData = reinterpret_cast<PACTCTXCTB_CBACTCTXGENBEGINNING>(Data);

            INTERNAL_ERROR_CHECK(AssemblyMetadataContext == NULL);

            CBData->Success = FALSE;

            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                IFW32FALSE_EXIT(AssemblyMetadataContext.Win32Allocate(__FILE__, __LINE__));

                AssemblyMetadataContext->ApplicationDirectory = CBData->ApplicationDirectory;
                AssemblyMetadataContext->ApplicationDirectoryCch = CBData->ApplicationDirectoryCch;
                AssemblyMetadataContext->ApplicationDirectoryPathType = CBData->ApplicationDirectoryPathType;
                AssemblyMetadataContext->pLastMetaDataEntry = NULL;

                IFW32FALSE_EXIT(
                    ::SxsInitStringSectionGenerationContext(
                        &SSGenContext,
                        ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_FORMAT_WHISTLER,
                        TRUE,
                        SxspAssemblyMetadataStringSectionGenerationCallback,
                        AssemblyMetadataContext));

                AssemblyMetadataContext.DetachAndHold();
            }

            CBData->Success = TRUE;
            CBData->Header.ActCtxGenContext = SSGenContext;
            break;
        }

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (SSGenContext != NULL)
            ::SxsDestroyStringSectionGenerationContext(SSGenContext);
        FUSION_DELETE_SINGLETON(AssemblyMetadataContext);
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        {
            PACTCTXCTB_CBACTCTXGENENDED CBData = (PACTCTXCTB_CBACTCTXGENENDED) Data;
            CBData->Success = FALSE;
            if (SSGenContext != NULL)
                IFW32FALSE_EXIT(::SxsDoneModifyingStringSectionGenerationContext(SSGenContext));
            CBData->Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_IDENTITYDETERMINED:
        {
            PACTCTXCTB_CBIDENTITYDETERMINED CBData = (PACTCTXCTB_CBIDENTITYDETERMINED)Data;
            SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT)CBData->Header.ActCtxGenContext;
            SIZE_T cbEncoding = 0;
            CStringBufferAccessor acc;
            CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> pAsmIdentTemp;

            //
            // If we're not generating an actctx, then we don't have to do anything for it.
            //
            if (Data->Header.ManifestOperation != MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                CBData->Success = TRUE;
                FN_SUCCESSFUL_EXIT();
            }

            INTERNAL_ERROR_CHECK(SSGenContext != NULL);

            //
            // Find the last one that was added, and stamp the new assembly identity into it
            //
            if (AssemblyMetadataContext->pLastMetaDataEntry != NULL)
            {
                Entry = AssemblyMetadataContext->pLastMetaDataEntry;
                if (Entry->AssemblyIdentity != NULL)
                {
                    SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(Entry->AssemblyIdentity));
                    Entry->AssemblyIdentity = NULL;
                }

                IFW32FALSE_EXIT(SxsDuplicateAssemblyIdentity(0, CBData->AssemblyIdentity, &pAsmIdentTemp));
                Entry->AssemblyIdentity = pAsmIdentTemp.Detach();

                //
                // Now, if this was the root assembly and there was configuration for it
                //
                if ((AssemblyMetadataContext->pAppConfigEntry != NULL) && Entry->IsRootAssembly)
                {
                    PASSEMBLY_METADATA_ENTRY pAppConfig = AssemblyMetadataContext->pAppConfigEntry;
                    IFW32FALSE_EXIT(Entry->PolicyPathBuffer.Win32Assign(pAppConfig->ManifestPathBuffer));
                    Entry->PolicyLastWriteTime = pAppConfig->ManifestLastWriteTime;
                    Entry->PolicyPathType = pAppConfig->ManifestPathType;
                }
                
                AssemblyMetadataContext->pLastMetaDataEntry = NULL;
            }
            
            CBData->Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        {
            PACTCTXCTB_CBGETSECTIONSIZE CBData = (PACTCTXCTB_CBGETSECTIONSIZE) Data;
            SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) CBData->Header.ActCtxGenContext;
            INTERNAL_ERROR_CHECK(SSGenContext != NULL);
            IFW32FALSE_EXIT(::SxsGetStringSectionGenerationContextSectionSize(SSGenContext, &CBData->SectionSize));
            break;
        }

    case ACTCTXCTB_CBREASON_PARSEBEGINNING:
        {
            Data->ParseBeginning.Success = FALSE;

            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                PCWSTR pszAssemblyName = NULL;
                SIZE_T cchAssemblyName = 0;
                PCASSEMBLY_IDENTITY AssemblyIdentity = Data->ParseBeginning.AssemblyContext->AssemblyIdentity;

                if (AssemblyIdentity != NULL)
                {
                    IFW32FALSE_EXIT(
                        ::SxspGetAssemblyIdentityAttributeValue(
                            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                            AssemblyIdentity,
                            &s_IdentityAttribute_name,
                            &pszAssemblyName,
                            &cchAssemblyName));
                }

                switch (Data->ParseBeginning.ParseType)
                {
                case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
                    if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                    {
                        CSmartPtr<ASSEMBLY_METADATA_ENTRY> AppConfigEntry;                        
                        //PASSEMBLY_METADATA_ENTRY AppConfigEntry;

                        IFW32FALSE_EXIT(AppConfigEntry.Win32Allocate(__FILE__, __LINE__));
                        
                        AppConfigEntry->AssemblyRosterIndex = Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex;
                        AppConfigEntry->ManifestPathType = Data->ParseBeginning.FilePathType;
                        AppConfigEntry->ManifestLastWriteTime = Data->ParseBeginning.FileLastWriteTime;
                        AppConfigEntry->ManifestVersionMajor = Data->ParseBeginning.FileFormatVersionMajor;
                        AppConfigEntry->ManifestVersionMinor = Data->ParseBeginning.FileFormatVersionMinor;
                        AppConfigEntry->MetadataSatelliteRosterIndex = Data->ParseBeginning.MetadataSatelliteRosterIndex;

                        IFW32FALSE_EXIT(AppConfigEntry->ManifestPathBuffer.Win32Assign(
                            Data->ParseBeginning.FilePath,
                            Data->ParseBeginning.FilePathCch));
                        
                        AssemblyMetadataContext->pAppConfigEntry.AttachForDelete(AppConfigEntry.Detach());
                    }

                    break;

                case XML_FILE_TYPE_MANIFEST:
                    {
                        IFW32FALSE_EXIT(
                            ::SxsFindStringInStringSectionGenerationContext(
                                (PSTRING_SECTION_GENERATION_CONTEXT) Data->ParseBeginning.Header.ActCtxGenContext,
                                pszAssemblyName,
                                cchAssemblyName,
                                (PVOID *) &Entry,
                                &Found));

                        if (Found)
                        {
                            // The linkage between the root manifest's policy entry and the actual entry for it
                            // is tenuous since the root policy is parsed before we've started keeping track of
                            // the actual contents of the assembly.  So, we would have previously added it
                            // under XML_FILE_TYPE_APPLICATION_CONFIGURATION, but the code that sets the
                            // AssemblyRosterIndex (way up the call stack) is making a somewhat random assumption
                            // that the root is at roster index 1.  It's a good assumption but conceptually
                            // fragile; thus this assert/internal error report if it fails.
                            INTERNAL_ERROR_CHECK(Entry->AssemblyRosterIndex == Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex);
                        }

                        // Haven't seen it before; allocate it!
                        IFALLOCFAILED_EXIT(Entry = new ASSEMBLY_METADATA_ENTRY);

                        IFW32FALSE_EXIT(
                            ::SxsAddStringToStringSectionGenerationContext(
                                (PSTRING_SECTION_GENERATION_CONTEXT) Data->ParseBeginning.Header.ActCtxGenContext,
                                pszAssemblyName,
                                cchAssemblyName,
                                Entry,
                                Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex,
                                ERROR_SXS_DUPLICATE_ASSEMBLY_NAME));

                        Entry->AssemblyRosterIndex = Data->ParseBeginning.AssemblyContext->AssemblyRosterIndex;

                        IFW32FALSE_EXIT(Entry->ManifestPathBuffer.Win32Assign(Data->ParseBeginning.FilePath, Data->ParseBeginning.FilePathCch));
                        Entry->ManifestPathType = Data->ParseBeginning.FilePathType;

                        // If the assembly has a name, record its directory
                        if (cchAssemblyName != 0)
                        {
                            IFW32FALSE_EXIT(
                                ::SxspGenerateSxsPath(
                                    SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
                                    SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                                    NULL,
                                    0,
                                    Data->ParseBeginning.AssemblyContext->AssemblyIdentity,
                                    NULL,
                                    Entry->AssemblyDirectoryNameBuffer));
                        }

                        Entry->ManifestLastWriteTime = Data->ParseBeginning.FileLastWriteTime;

                        //Entry->Version = Data->ParseBeginning.AssemblyContext->Version;
                        Entry->ManifestVersionMajor = Data->ParseBeginning.FileFormatVersionMajor;
                        Entry->ManifestVersionMinor = Data->ParseBeginning.FileFormatVersionMinor;

                        Entry->MetadataSatelliteRosterIndex = Data->ParseBeginning.MetadataSatelliteRosterIndex;

                    {
                        PCWSTR pszLangID = NULL;
                        SIZE_T CchLangID = 0;

                        // get pointers to LANGID string in AssemblyIdentity
                        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
                                        SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                                        Data->ElementParsed.AssemblyContext->AssemblyIdentity,
                                        &s_IdentityAttribute_language,
                                        &pszLangID, &CchLangID));

                        IFW32FALSE_EXIT(Entry->LanguageBuffer.Win32Assign(pszLangID, CchLangID));
                    }

                        if (Data->ParseBeginning.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_ASSEMBLY_POLICY_APPLIED)
                            Entry->AssemblyPolicyApplied = TRUE;

                        if (Data->ParseBeginning.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_ROOT_POLICY_APPLIED)
                            Entry->RootPolicyApplied = TRUE;

                        if (Data->ParseBeginning.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY)
                            Entry->IsRootAssembly = TRUE;

                        if (Data->ParseBeginning.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_PRIVATE_ASSEMBLY)
                            Entry->IsPrivateAssembly = TRUE;

                        Entry->FileNum = 0;
                        AssemblyMetadataContext->pLastMetaDataEntry = Entry;


                        break;
                    }
                }
            }

            Data->ParseBeginning.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        {
            Data->GetSectionData.Success = FALSE;
            INTERNAL_ERROR_CHECK(SSGenContext != NULL);
            IFW32FALSE_EXIT(
                ::SxsGetStringSectionGenerationContextSectionData(
                    SSGenContext,
                    Data->GetSectionData.SectionSize,
                    Data->GetSectionData.SectionDataStart,
                    NULL));
            Data->GetSectionData.Success = TRUE;
            break;
        }
    }

Exit:
    if (TempAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(TempAssemblyIdentity);
}

BOOL
SxspAssemblyMetadataStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PASSEMBLY_METADATA_CONTEXT GlobalContext = reinterpret_cast<PASSEMBLY_METADATA_CONTEXT>(Context);

    INTERNAL_ERROR_CHECK(GlobalContext != NULL);

    switch (Reason)
    {
    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE) CallbackData;
            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION);

            if (GlobalContext->ApplicationDirectoryCch != 0)
                CBData->DataSize += ((GlobalContext->ApplicationDirectoryCch + 1) * sizeof(WCHAR));

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA) CallbackData;
            PACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION GlobalInfo;
            ULONG BytesLeft = static_cast<ULONG>(CBData->BufferSize);
            ULONG BytesWritten = 0;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION);

            GlobalInfo = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION) CBData->Buffer;
            GlobalInfo->Size = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION);
            GlobalInfo->Flags = 0;
            GlobalInfo->PolicyCoherencyGuid = GUID_NULL;
            GlobalInfo->PolicyOverrideGuid = GUID_NULL;

            GlobalInfo->ApplicationDirectoryLength = 0;
            GlobalInfo->ApplicationDirectoryOffset = 0;

            if (GlobalContext->ApplicationDirectoryCch != 0)
            {
                ULONG BytesNeeded = static_cast<ULONG>((GlobalContext->ApplicationDirectoryCch + 1) * sizeof(WCHAR));

                if (BytesLeft < BytesNeeded)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                memcpy(
                    (GlobalInfo + 1),
                    GlobalContext->ApplicationDirectory,
                    BytesNeeded);

                GlobalInfo->ApplicationDirectoryPathType = GlobalContext->ApplicationDirectoryPathType;
                GlobalInfo->ApplicationDirectoryLength = BytesNeeded - sizeof(WCHAR);
                GlobalInfo->ApplicationDirectoryOffset = sizeof(*GlobalInfo);

                GlobalInfo->Size += BytesNeeded;

                BytesWritten += BytesNeeded;
                BytesLeft -= BytesNeeded;
            }

            CBData->BytesWritten = BytesWritten;

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PASSEMBLY_METADATA_ENTRY Entry = (PASSEMBLY_METADATA_ENTRY) CBData->DataContext;
            FUSION_DELETE_SINGLETON(Entry);
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PASSEMBLY_METADATA_ENTRY Entry = (PASSEMBLY_METADATA_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION);

            if (Entry->AssemblyIdentity != NULL)
            {
                SIZE_T cbEncodedSize = 0;
                SxsComputeAssemblyIdentityEncodedSize(
                    0, 
                    Entry->AssemblyIdentity, 
                    NULL, 
                    SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                    &cbEncodedSize);
                CBData->DataSize += cbEncodedSize;
            }

            SIZE_T Cch;
#define GET_BUFFER_SIZE(Buffer) (((Cch = (Buffer).Cch()) != 0) ? ((Cch + 1) * sizeof(WCHAR)) : 0)
            CBData->DataSize += GET_BUFFER_SIZE(Entry->ManifestPathBuffer);
            CBData->DataSize += GET_BUFFER_SIZE(Entry->PolicyPathBuffer);
            CBData->DataSize += GET_BUFFER_SIZE(Entry->AssemblyDirectoryNameBuffer);
            CBData->DataSize += GET_BUFFER_SIZE(Entry->LanguageBuffer);
#undef GET_BUFFER_SIZE

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PASSEMBLY_METADATA_ENTRY Entry = (PASSEMBLY_METADATA_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Info;

            SIZE_T BytesLeft = (ULONG)(CBData->BufferSize);
            SIZE_T BytesWritten = 0;
            PWSTR StringCursor;
            SIZE_T EncodedIdentityBytesWritten = 0;

            Info = (PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) CBData->Buffer;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION);

            StringCursor = reinterpret_cast<PWSTR>(Info + 1);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION);
            Info->Flags =
                (Entry->IsRootAssembly ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY : 0) |
                (Entry->IsPrivateAssembly ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_PRIVATE_ASSEMBLY : 0) |
                ((Entry->AssemblyPolicyApplied ||
                  Entry->RootPolicyApplied) ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED : 0) |
                (Entry->AssemblyPolicyApplied ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED : 0) |
                (Entry->RootPolicyApplied ? ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED : 0);

            if (Entry->AssemblyIdentity != NULL)
            {
                SIZE_T cbWritten = 0;
                
                IFW32FALSE_EXIT(
                    SxsEncodeAssemblyIdentity(
                        0,
                        Entry->AssemblyIdentity,
                        NULL,
                        SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                        BytesLeft,
                        StringCursor,
                        &cbWritten));

                Info->EncodedAssemblyIdentityOffset = ULONG((PBYTE)StringCursor - (PBYTE)CBData->SectionHeader);
                Info->EncodedAssemblyIdentityLength = ULONG(cbWritten);

                BytesLeft -= cbWritten;
                BytesWritten += cbWritten;
                StringCursor = (PWSTR)(((PBYTE)StringCursor) + cbWritten);
            }
            else
            {
                Info->EncodedAssemblyIdentityOffset = 0;
                Info->EncodedAssemblyIdentityLength = 0;
            }

            IFW32FALSE_EXIT(Entry->ManifestPathBuffer.Win32CopyIntoBuffer(
                &StringCursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->ManifestPathOffset,
                &Info->ManifestPathLength));

            Info->ManifestPathType = Entry->ManifestPathType;
            Info->PolicyPathType = Entry->PolicyPathType;
            Info->ManifestLastWriteTime.LowPart = Entry->ManifestLastWriteTime.dwLowDateTime;
            Info->ManifestLastWriteTime.HighPart = Entry->ManifestLastWriteTime.dwHighDateTime;
            Info->PolicyLastWriteTime.LowPart = Entry->PolicyLastWriteTime.dwLowDateTime;
            Info->PolicyLastWriteTime.HighPart = Entry->PolicyLastWriteTime.dwHighDateTime;

            IFW32FALSE_EXIT(Entry->PolicyPathBuffer.Win32CopyIntoBuffer(
                &StringCursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->PolicyPathOffset,
                &Info->PolicyPathLength));

            IFW32FALSE_EXIT(Entry->AssemblyDirectoryNameBuffer.Win32CopyIntoBuffer(
                &StringCursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->AssemblyDirectoryNameOffset,
                &Info->AssemblyDirectoryNameLength));

            Info->ManifestVersionMajor = Entry->ManifestVersionMajor;
            Info->ManifestVersionMinor = Entry->ManifestVersionMinor;

            Info->MetadataSatelliteRosterIndex = Entry->MetadataSatelliteRosterIndex;
            Info->NumOfFilesInAssembly = Entry->FileNum;

            IFW32FALSE_EXIT(Entry->LanguageBuffer.Win32CopyIntoBuffer(
                &StringCursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->LanguageOffset,
                &Info->LanguageLength));

            CBData->BytesWritten = BytesWritten;
        }

    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cassemblycacheitemstream.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    CAssemblyCacheItemStream.h

Abstract:
    Like a CFileStream (its base) but also implements Commit over
      associated CAssemblyCacheItem. This functionality was
      moved out of CFileStream.

Author:

    Jay Krell (a-JayK, JayKrell) June 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_CASSEMBLYCACHEITEMSTREAM_H_INCLUDED_)
#define _FUSION_SXS_CASSEMBLYCACHEITEMSTREAM_H_INCLUDED_
#pragma once

#include "objidl.h"
#include "sxsasmitem.h"
#include "filestream.h"
#include "smartref.h"

class CAssemblyCacheItem;

class CAssemblyCacheItemStream : public CReferenceCountedFileStream
{
private:
    typedef CReferenceCountedFileStream Base;

public:
    CAssemblyCacheItemStream() : Base()
    {
    }

    ~CAssemblyCacheItemStream()
    {
    }

    STDMETHODIMP Commit(
        DWORD grfCommitFlags
        )
    {
        HRESULT hr = NOERROR;
        FN_TRACE_HR(hr);

        PARAMETER_CHECK(grfCommitFlags == 0);
        IFCOMFAILED_EXIT(Base::Commit(grfCommitFlags));

        hr = NOERROR;
    Exit:
        return hr;
    }

private: // intentionally not implemented
    CAssemblyCacheItemStream(const CAssemblyCacheItemStream&);
    void operator=(const CAssemblyCacheItemStream&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\assemblyreference.h ===
#if !defined(_FUSION_SXS_ASSEMBLYREFERENCE_H_INCLUDED_)
#define _FUSION_SXS_ASSEMBLYREFERENCE_H_INCLUDED_

#pragma once

#include "sxsp.h"
#include "fusionhash.h"

class CAssemblyReference
{
public:
    CAssemblyReference() { Construct(); }
    ~CAssemblyReference() { Destroy(); }
    void Construct();
    void Destroy();

    BOOL TakeValue(CAssemblyReference &r);

public:
    BOOL Initialize();
//  BOOL Initialize(PCWSTR AssemblyName, SIZE_T AssemblyNameCch, const ASSEMBLY_VERSION &rav, LANGID LangId, USHORT ProcessorArchitecture);
    BOOL Initialize(const CAssemblyReference &r); // "copy initializer"
    BOOL Initialize(PCASSEMBLY_IDENTITY Identity);

    bool IsInitialized() const { return m_pAssemblyIdentity != NULL; }

    BOOL Hash(ULONG &rulPseudoKey) const;

    PCASSEMBLY_IDENTITY GetAssemblyIdentity() const { return m_pAssemblyIdentity; }
    BOOL SetAssemblyIdentity(PCASSEMBLY_IDENTITY pAssemblySource); //dupilicate the input parameter
    BOOL SetAssemblyName(PCWSTR AssemblyName, SIZE_T AssemblyNameCch);
    BOOL ClearAssemblyName() ;
    BOOL GetAssemblyName(PCWSTR *Buffer, SIZE_T *Cch) const;

    BOOL GetLanguage(PCWSTR &rString, SIZE_T &rcch) const;
    BOOL SetLanguage(const CBaseStringBuffer &rbuff);
    BOOL SetLanguage(PCWSTR String, SIZE_T Cch);
    BOOL ClearLanguage();
    BOOL IsLanguageWildcarded(bool &rfWildcarded) const;
    BOOL IsProcessorArchitectureWildcarded(bool &rfWildcarded) const;
    BOOL IsProcessorArchitectureX86(bool &rfIsX86) const;
    BOOL GetProcessorArchitecture(PCWSTR &rString, SIZE_T &rcch) const;
    BOOL SetProcessorArchitecture(PCWSTR String, SIZE_T Cch);
    BOOL SetProcessorArchitecture(IN const CBaseStringBuffer &rbuffProcessorArchitecture);
    BOOL GetPublicKeyToken(OUT CBaseStringBuffer *pbuffPublicKeyToken, OUT BOOL &rfHasPublicKeyToken) const;
    BOOL SetPublicKeyToken(IN const CBaseStringBuffer &rbuffPublicKeyToken);
    BOOL SetPublicKeyToken(IN PCWSTR pszPublicKeyToken, IN SIZE_T cchPublicKeyToken);

    BOOL Assign(const CAssemblyReference &r) ;

protected:
    PASSEMBLY_IDENTITY m_pAssemblyIdentity;

private:
    CAssemblyReference(const CAssemblyReference &r); // intentionally unimplemented
    void operator =(const CAssemblyReference &r); // intentionally unimplemented

};

template <> inline BOOL HashTableHashKey<const CAssemblyReference &>(
    const CAssemblyReference &r,
    ULONG &rulPK
    )
{
    return r.Hash(rulPK);
}

template <> inline BOOL HashTableInitializeKey<const CAssemblyReference &, CAssemblyReference>(
    const CAssemblyReference &keyin,
    CAssemblyReference &keystored
    )
{
    return keystored.Initialize(keyin);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\assemblyreference.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    assemblyreference.cpp

Abstract:

    Class the contains all the attributes of an assembly reference.

Author:

    Michael J. Grier (MGrier) 10-May-2000

Revision History:
    xiaoyuw     09/2000     revise the code using Assembly Identity
                            A couple of APIs in this class are kind of out of date, such as GetXXX, SetXXX, XXXSpecified : they
                            are not called at all.
--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsapi.h"
#include "sxsp.h"
#include "assemblyreference.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "fusionparser.h"
#include "fusionheap.h"
#include "sxsexceptionhandling.h"

VOID
CAssemblyReference::Construct()
{
    m_pAssemblyIdentity = NULL;
}

VOID
CAssemblyReference::Destroy()
{
    CSxsPreserveLastError ple;
    ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
    m_pAssemblyIdentity = NULL;
    ple.Restore();
}

BOOL
CAssemblyReference::Initialize()
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity == NULL);

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_REFERENCE, &m_pAssemblyIdentity, 0, NULL));

    FN_EPILOG
}

BOOL
CAssemblyReference::Initialize(
    PCASSEMBLY_IDENTITY Identity
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(Identity != NULL);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity == NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, Identity, &m_pAssemblyIdentity));

    FN_EPILOG
}

BOOL
CAssemblyReference::Initialize(
    const CAssemblyReference &r
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity == NULL);
    INTERNAL_ERROR_CHECK(r.m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            0,                      // DWORD Flags,
            r.m_pAssemblyIdentity,  // PCASSEMBLY_IDENTITY Source,
            &m_pAssemblyIdentity)); //  PASSEMBLY_IDENTITY *Destination

    FN_EPILOG
}

BOOL
CAssemblyReference::Hash(
    ULONG &rulPseudoKey
    ) const
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxsHashAssemblyIdentity(
            0,                      // DWORD dwFlags,
            m_pAssemblyIdentity,    // ASSEMBLY_IDENTITY pAssemblyIdentity,
            &rulPseudoKey));        // ULONG & rfulPseudoKey

    FN_EPILOG
}

BOOL
CAssemblyReference::SetAssemblyName(
    PCWSTR AssemblyNameValue,
    SIZE_T AssemblyNameValueCch
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(AssemblyNameValue != NULL);
    PARAMETER_CHECK(AssemblyNameValueCch != 0);

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_name,
            AssemblyNameValue,
            AssemblyNameValueCch));

    FN_EPILOG
}

// if m_pAssemblyIdentity  is NULL, return TRUE with Cch == 0
BOOL
CAssemblyReference::GetAssemblyName(
    PCWSTR *pAssemblyName,
    SIZE_T *Cch
    ) const
{
    FN_PROLOG_WIN32

    SIZE_T CchTemp = 0;

    if (Cch != NULL)
        *Cch = 0;

    if (pAssemblyName != NULL)
        *pAssemblyName = NULL;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_name,
            pAssemblyName,
            &CchTemp));

    if (Cch != NULL)
        *Cch = CchTemp;

    FN_EPILOG
}

BOOL
CAssemblyReference::TakeValue(
    CAssemblyReference &r
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(r.m_pAssemblyIdentity != NULL);

    if (m_pAssemblyIdentity != NULL)
    {
        SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
        m_pAssemblyIdentity = NULL;
    }

    //
    // ISSUE-2002/05/04-jonwis : I'm not convinced that "take value" should have "copy"
    //      semantics... Isn't that what Assign is for?  "Take value" to me means "steal
    //      their copy, don't allocate more memory."
    //
    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, r.m_pAssemblyIdentity, &m_pAssemblyIdentity));

    FN_EPILOG
}

BOOL CAssemblyReference::ClearAssemblyName()
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxspRemoveAssemblyIdentityAttribute(0, m_pAssemblyIdentity, &s_IdentityAttribute_name));

    FN_EPILOG
}

BOOL
CAssemblyReference::GetLanguage(
    PCWSTR &rString,
    SIZE_T &rCch
    ) const
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_language,
            &rString,
            &rCch));

    FN_EPILOG
}

BOOL
CAssemblyReference::SetLanguage(
    const CBaseStringBuffer &rbuff
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_language,
            rbuff,
            rbuff.Cch()));

    FN_EPILOG
}

BOOL
CAssemblyReference::SetLanguage(
    PCWSTR String,
    SIZE_T Cch
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    PARAMETER_CHECK_INTERNAL((Cch == 0) || (String != NULL));

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_language,
            String,
            Cch));

    FN_EPILOG
}

BOOL
CAssemblyReference::ClearLanguage()
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    IFW32FALSE_EXIT(::SxspRemoveAssemblyIdentityAttribute(SXSP_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS, m_pAssemblyIdentity, &s_IdentityAttribute_language));

    FN_EPILOG
}

BOOL
CAssemblyReference::IsLanguageWildcarded(
    bool &rfWildcarded
    ) const
{
    FN_PROLOG_WIN32

    const WCHAR *Value = NULL;
    SIZE_T Cch = 0;

    rfWildcarded = false;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, m_pAssemblyIdentity, &s_IdentityAttribute_language, &Value, &Cch));

    if (Cch == 1)
    {
        INTERNAL_ERROR_CHECK(Value != NULL);

        if (Value[0] == L'*')
            rfWildcarded = true;
    }

    FN_EPILOG
}

BOOL
CAssemblyReference::IsProcessorArchitectureWildcarded(
    bool &rfWildcarded
    ) const
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    const WCHAR *Value = NULL;
    SIZE_T Cch = 0;

    rfWildcarded = false;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, m_pAssemblyIdentity, &s_IdentityAttribute_processorArchitecture, &Value, &Cch));

    if (Cch == 1)
    {
        INTERNAL_ERROR_CHECK(Value != NULL);

        if (Value[0] == L'*')
            rfWildcarded = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::IsProcessorArchitectureX86(
    bool &rfX86
    ) const
{
    FN_PROLOG_WIN32
    const WCHAR *Value = NULL;
    SIZE_T Cch = 0;

    rfX86 = false;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, m_pAssemblyIdentity, &s_IdentityAttribute_processorArchitecture, &Value, &Cch));

    if (Cch == 3)
    {
        INTERNAL_ERROR_CHECK(Value != NULL);

        if (((Value[0] == L'x') || (Value[0] == L'X')) &&
            (Value[1] == L'8') &&
            (Value[2] == L'6'))
            rfX86 = true;
    }

    FN_EPILOG
}

BOOL
CAssemblyReference::GetProcessorArchitecture(
    PCWSTR &rString,
    SIZE_T &rCch
    ) const
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            &rString,
            &rCch));

    FN_EPILOG
}

BOOL
CAssemblyReference::SetProcessorArchitecture(
    const WCHAR *String,
    SIZE_T Cch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((String != NULL) || (Cch == 0));

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            String,
            Cch));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::SetProcessorArchitecture(
    IN const CBaseStringBuffer &rbuffProcessorArchitecture
    )
{
    return this->SetProcessorArchitecture(rbuffProcessorArchitecture, rbuffProcessorArchitecture.Cch());
}

BOOL
CAssemblyReference::Assign(
    const CAssemblyReference &r
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY IdentityCopy = NULL;

    //INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    INTERNAL_ERROR_CHECK(r.m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, r.m_pAssemblyIdentity, &IdentityCopy));
    ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
    m_pAssemblyIdentity = IdentityCopy;
    
    // NTRAID#NTBUG9 - 571856 - 2002/03/26 - xiaoyuw
    // set NULL to pointer after it is taken over

    // IdentityCopy = NULL;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

//dupilicate the input parameter
BOOL
CAssemblyReference::SetAssemblyIdentity(
    PCASSEMBLY_IDENTITY pAssemblyIdentitySource
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY TempAssemblyIdentity = NULL;

    PARAMETER_CHECK(pAssemblyIdentitySource != NULL);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL); // you should have initialized to start with...

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(
        0,
        pAssemblyIdentitySource,
        &TempAssemblyIdentity));

    ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
    m_pAssemblyIdentity = TempAssemblyIdentity;
    
    // NTRAID#NTBUG9 - 571856 - 2002/03/26 - xiaoyuw
    // set NULL to pointer after it is taken over
    // TempAssemblyIdentity  = NULL;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CAssemblyReference::GetPublicKeyToken(
    CBaseStringBuffer *pbuffPublicKeyToken,
    BOOL &rfHasPublicKeyToken
    ) const
{
    FN_PROLOG_WIN32

    PCWSTR wchString = NULL;
    SIZE_T cchString = NULL;

    rfHasPublicKeyToken = FALSE;

    if (pbuffPublicKeyToken != NULL)
        pbuffPublicKeyToken->Clear();

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_publicKeyToken,
            &wchString,
            &cchString));

    if (cchString != 0)
    {
        rfHasPublicKeyToken = TRUE;
        if (pbuffPublicKeyToken != NULL)
            IFW32FALSE_EXIT(pbuffPublicKeyToken->Win32Assign(wchString, cchString));
    }

    FN_EPILOG
}

BOOL CAssemblyReference::SetPublicKeyToken(
    const CBaseStringBuffer &rbuffPublicKeyToken
    )
{
    return this->SetPublicKeyToken(rbuffPublicKeyToken, rbuffPublicKeyToken.Cch());
}

BOOL CAssemblyReference::SetPublicKeyToken(
    PCWSTR pszPublicKeyToken,
    SIZE_T cchPublicKeyToken
    )
{
    BOOL bSuccess = FALSE;
    FN_TRACE_WIN32( bSuccess );

    PARAMETER_CHECK( (pszPublicKeyToken != NULL ) || ( cchPublicKeyToken == 0 ) );
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            m_pAssemblyIdentity,
            &s_IdentityAttribute_publicKeyToken,
            pszPublicKeyToken,
            cchPublicKeyToken));

    bSuccess = TRUE;
Exit:
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cassemblyrecoveryinfo.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "fusionheap.h"
#include "fusionbuffer.h"
#include "fusionparser.h"
#include "strongname.h"
#include "cassemblyrecoveryinfo.h"
#include "hashfile.h"
#include "fusionhandle.h"
#include "util.h"
#include "sxsp.h"
#include "recover.h"

extern const UNICODE_STRING UnicodeString_URLHEAD_WINSOURCE =
{
    sizeof(URLHEAD_WINSOURCE) - sizeof(URLHEAD_WINSOURCE[0]),
    sizeof(URLHEAD_WINSOURCE),
    const_cast<PWSTR>(URLHEAD_WINSOURCE)
};

class CSxspMapShortNameToAssemblyLocals
{
public:
    CSxspMapShortNameToAssemblyLocals() { }
    ~CSxspMapShortNameToAssemblyLocals() { }

    CSmallStringBuffer  buffManifestName;
    CSmallStringBuffer  buffCatalogName;
    CStringBuffer       buffKeyName;
    CSmallStringBuffer  buffAcquiredShortName;
};

BOOL
pMapShortNameToAssembly(
    IN OUT CBaseStringBuffer &rbuffAssemblyName,
    IN const CRegKey &hkInstallInfoKey,
    OUT CRegKey &hRequestedAsm,
    IN REGSAM rsReadRights = KEY_READ
    )
{
    FN_PROLOG_WIN32

    CSmartPtr<CSxspMapShortNameToAssemblyLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CSmallStringBuffer &buffManifestName = Locals->buffManifestName;
    CSmallStringBuffer &buffCatalogName = Locals->buffCatalogName;

    DWORD dwIndex = 0;
    PCWSTR pszValueName = NULL;

    hRequestedAsm = CRegKey::GetInvalidValue();

    IFW32FALSE_EXIT(buffManifestName.Win32Assign(rbuffAssemblyName));
    IFW32FALSE_EXIT(buffManifestName.Win32Append(L".man", 4));

    IFW32FALSE_EXIT(buffCatalogName.Win32Assign(rbuffAssemblyName));
    IFW32FALSE_EXIT(buffCatalogName.Win32Append(L".cat", 4));

    //
    // Look for this under the CSMD_TOPLEVEL_SHORTNAME first
    //
    for (;;)
    {
        CStringBuffer &buffKeyName = Locals->buffKeyName;
        CSmallStringBuffer &buffAcquiredShortName = Locals->buffAcquiredShortName;
        BOOL fTempBoolean = FALSE;
        CRegKey hAsm;

        buffKeyName.Clear();
        buffAcquiredShortName.Clear();

        IFW32FALSE_EXIT(hkInstallInfoKey.EnumKey(
            dwIndex++,
            buffKeyName,
            NULL,
            &fTempBoolean));

        if (fTempBoolean)
            break;

        IFW32FALSE_EXIT(hkInstallInfoKey.OpenSubKey(hAsm, buffKeyName, rsReadRights));

        //
        // Get the value of the key
        //
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hAsm,
                CSMD_TOPLEVEL_SHORTNAME,
                buffAcquiredShortName));

        //
        // If the key was there to be read:
        //
        if (buffAcquiredShortName.Cch() != 0)
        {
            if (::FusionpEqualStringsI(
                    buffAcquiredShortName,
                    rbuffAssemblyName
                    ))
            {
                IFW32FALSE_EXIT(rbuffAssemblyName.Win32Assign(buffKeyName));
                IFW32FALSE_EXIT(hkInstallInfoKey.OpenSubKey( hRequestedAsm, buffKeyName, rsReadRights ) );
                break;
            }
        }

        //
        // Get the value of the key
        //
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hAsm,
                CSMD_TOPLEVEL_SHORTMANIFEST,
                buffAcquiredShortName));

        //
        // If the key was there to be read:
        //
        if (buffAcquiredShortName.Cch() != 0)
        {
            if (::FusionpEqualStringsI(
                    buffAcquiredShortName,
                    buffManifestName
                    ))
            {
                IFW32FALSE_EXIT(rbuffAssemblyName.Win32Assign(buffKeyName));
                IFW32FALSE_EXIT(hkInstallInfoKey.OpenSubKey(hRequestedAsm, buffKeyName, rsReadRights));
                break;
            }
        }

        //
        // Get the value of the key
        //
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hAsm,
                CSMD_TOPLEVEL_SHORTCATALOG,
                buffAcquiredShortName));

        //
        // If the key was there to be read:
        //
        if (buffAcquiredShortName.Cch() != 0)
        {
            if (::FusionpEqualStringsI(
                    buffAcquiredShortName,
                    buffCatalogName
                    ))
            {
                IFW32FALSE_EXIT(rbuffAssemblyName.Win32Assign(buffKeyName));
                IFW32FALSE_EXIT(hkInstallInfoKey.OpenSubKey(hRequestedAsm, buffKeyName, rsReadRights));
                break;
            }
        }
    }

    FN_EPILOG
}

class CAssemblyRecoveryInfoResolveCDRomURLLocals
{
public:
    CAssemblyRecoveryInfoResolveCDRomURLLocals()
    {
        rgchVolumeName[0] = 0;
        chBuffer[0] = 0;
    }

    ~CAssemblyRecoveryInfoResolveCDRomURLLocals() { }

    CStringBuffer       sbIdentKind, sbIdentData1, sbIdentData2;
    CSmallStringBuffer  buffDriveStrings;
    WCHAR               rgchVolumeName[MAX_PATH];
    CHAR                chBuffer[MAX_PATH];
    CStringBuffer       sbContents;
};

BOOL
CAssemblyRecoveryInfo::ResolveCDRomURL(
    PCWSTR pszSource,
    CBaseStringBuffer &rsbDestination
) const
{
    BOOL                fSuccess = TRUE;
    FN_TRACE_WIN32(fSuccess);

    CStringBufferAccessor acc;
    BOOL                fFoundMedia = FALSE;
    CSmartPtr<CAssemblyRecoveryInfoResolveCDRomURLLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CStringBuffer & sbIdentKind = Locals->sbIdentKind;
    CStringBuffer & sbIdentData1 = Locals->sbIdentData1;
    CStringBuffer & sbIdentData2 = Locals->sbIdentData2;
    CSmallStringBuffer & buffDriveStrings = Locals->buffDriveStrings;
    SIZE_T              HeadLength = 0;
    PCWSTR              wcsCursor = NULL;
    ULONG               ulSerialNumber = 0;
    CDRomSearchType     SearchType = static_cast<CDRomSearchType>(0);

    PARAMETER_CHECK(pszSource != NULL);

    if (!_wcsnicmp(pszSource, URLHEAD_CDROM_TYPE_TAG, URLHEAD_LENGTH_CDROM_TYPE_TAG))
    {
        HeadLength = URLHEAD_LENGTH_CDROM_TYPE_TAG;
        SearchType = CDRST_Tagfile;
    }
    else if (!_wcsnicmp(
                    pszSource,
                    URLHEAD_CDROM_TYPE_SERIALNUMBER,
                    URLHEAD_LENGTH_CDROM_TYPE_SERIALNUMBER))
    {
        HeadLength = URLHEAD_LENGTH_CDROM_TYPE_SERIALNUMBER;
        SearchType = CDRST_SerialNumber;
    }
    else if (!_wcsnicmp(
                    pszSource,
                    URLHEAD_CDROM_TYPE_VOLUMENAME,
                    URLHEAD_LENGTH_CDROM_TYPE_VOLUMENAME))
    {
        HeadLength = URLHEAD_LENGTH_CDROM_TYPE_VOLUMENAME;
        SearchType = CDRST_VolumeName;
    }
    else
    {
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    //
    // Get the type of identifier here, and then move the cursor past them and
    // the slashes in the url.
    //
    IFW32FALSE_EXIT(sbIdentKind.Win32Assign(pszSource, HeadLength));
    pszSource += HeadLength;
    pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());

    //
    // Spin past slashes, assign chunklets
    //
    IFW32FALSE_EXIT(sbIdentData1.Win32Assign(pszSource, wcscspn(pszSource, CUnicodeCharTraits::PathSeparators())));
    pszSource += sbIdentData1.Cch();
    pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());

    //
    // If this is a tagfile, also get another blobbet of data off the string
    //
    if (SearchType == CDRST_Tagfile)
    {
        IFW32FALSE_EXIT(sbIdentData2.Win32Assign(pszSource, wcscspn(pszSource, CUnicodeCharTraits::PathSeparators())));
        pszSource += sbIdentData2.Cch();
        pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());
    }
    else if (SearchType == CDRST_SerialNumber)
    {
        IFW32FALSE_EXIT(CFusionParser::ParseULONG(
            ulSerialNumber,
            sbIdentData1,
            sbIdentData1.Cch(),
            16));
    }

    //
    // Now let's do ... interesting ... things to the CD-roms.
    //
    IFW32FALSE_EXIT(buffDriveStrings.Win32ResizeBuffer(GetLogicalDriveStringsW(0, NULL) + 1, eDoNotPreserveBufferContents));
    acc.Attach(&buffDriveStrings);
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::GetLogicalDriveStringsW(
            static_cast<DWORD>(acc.GetBufferCch()),
            acc));
    acc.Detach();

    wcsCursor = buffDriveStrings;

    //
    // Look at all the found drive letters
    //
    while (wcsCursor && *wcsCursor && !fFoundMedia)
    {
        DWORD dwSerialNumber = 0;
        const DWORD dwDriveType = ::GetDriveTypeW(wcsCursor);

        if (dwDriveType == DRIVE_CDROM)
        {
            //
            // I argue that a failure in GetVolumeInformationW isn't "bad enough"
            // to kill the call to this function.  Instead, it should just skip
            // the check of the failed drive letter, as it does here.
            //
            if(!::GetVolumeInformationW(
                wcsCursor,
                Locals->rgchVolumeName,
                NUMBER_OF(Locals->rgchVolumeName),
                &dwSerialNumber,
                NULL,
                NULL,
                NULL,
                0))
            {
#if DBG
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS.DLL: %s() - Failed getting volume information for drive letter %ls (Win32 Error = %ld), skipping\n",
                    __FUNCTION__,
                    wcsCursor,
                    ::FusionpGetLastWin32Error());
#endif
                continue;
            }


            switch (SearchType)
            {
            case CDRST_Tagfile:
                {
                    CFusionFile     FileHandle;
                    CStringBuffer   &sbContents = Locals->sbContents;
                    DWORD           dwTextLength;

                    if (FileHandle.Win32CreateFile(sbIdentData1, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING))
                    {
                        IFW32FALSE_ORIGINATE_AND_EXIT(
                            ::ReadFile(
                                FileHandle,
                                Locals->chBuffer, NUMBER_OF(Locals->chBuffer),
                                &dwTextLength, NULL));

                        IFW32FALSE_EXIT(sbContents.Win32Assign(Locals->chBuffer, dwTextLength));
                        fFoundMedia = !_wcsnicmp(sbContents, sbIdentData2, sbIdentData2.Cch());
                    }
                }
                break;
            case CDRST_SerialNumber:
                fFoundMedia = (dwSerialNumber == ulSerialNumber);
                break;

            case CDRST_VolumeName:
                fFoundMedia = (::FusionpStrCmpI(Locals->rgchVolumeName, sbIdentData1) == 0);
                break;
            default:
                break;
            }

        }

        if (!fFoundMedia)
            wcsCursor += ::wcslen(wcsCursor) + 1;
    }

    if (fFoundMedia)
    {
        IFW32FALSE_EXIT(rsbDestination.Win32Assign(wcsCursor, ::wcslen(wcsCursor)));
        IFW32FALSE_EXIT(rsbDestination.Win32AppendPathElement(pszSource, ::wcslen(pszSource)));
    }

    fSuccess = TRUE;
Exit:

    //
    // Failure indicated by an empty destination.
    //
    if (!fSuccess)
    {
        rsbDestination.Clear();
    }

    return fSuccess;
}






BOOL
CAssemblyRecoveryInfo::ResolveWinSourceMediaURL(
    PCWSTR  wcsUrlTrailer,
    CBaseStringBuffer &rsbDestination
) const
{
    CStringBuffer buffWindowsInstallSource;

    const static PCWSTR AssemblySourceStrings[] = {
        WINSXS_INSTALL_SVCPACK_REGKEY,
        WINSXS_INSTALL_SOURCEPATH_REGKEY
    };

    SIZE_T          iWhichSource = 0;
    BOOL            fSuccess = TRUE;
    BOOL            fFoundCodebase = FALSE;
    CFusionRegKey   hkSetupInfo;
    DWORD           dwWasFromCDRom = 0;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(wcsUrlTrailer != NULL);

    IFREGFAILED_ORIGINATE_AND_EXIT(
        ::RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            WINSXS_INSTALL_SOURCE_BASEDIR,
            0,
            KEY_READ | FUSIONP_KEY_WOW64_64KEY,
            &hkSetupInfo));

    if (!::FusionpRegQueryDwordValueEx(
            0,
            hkSetupInfo,
            WINSXS_INSTALL_SOURCE_IS_CDROM,
            &dwWasFromCDRom))
    {
        dwWasFromCDRom = 0;
    }

    while (iWhichSource < NUMBER_OF(AssemblySourceStrings))
    {
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hkSetupInfo,
                AssemblySourceStrings[iWhichSource],
                buffWindowsInstallSource));

        //
        // This really _really_ should not be empty.  If it is, then someone
        // went and fiddled with the registry on us.
        //
        ASSERT(buffWindowsInstallSource.Cch() != 0);
        if (buffWindowsInstallSource.Cch() == 0)
        {
            iWhichSource++;
            continue;
        }

        //
        // If this was from a CD, then spin through the list of CD's in the system
        // and see if we can match the codebase against the root dir of the CD
        //
        if (dwWasFromCDRom)
        {
            CSmallStringBuffer      buffDriveStrings;
            CStringBufferAccessor   acc;
            PCWSTR                  pszCursor = NULL;
            DWORD                   dwSize = 0;

            IFW32FALSE_EXIT(
                buffDriveStrings.Win32ResizeBuffer(
                    dwSize = (::GetLogicalDriveStringsW(0, NULL) + 1),
                    eDoNotPreserveBufferContents));

            acc.Attach(&buffDriveStrings);
            ::GetLogicalDriveStringsW(
                static_cast<DWORD>(acc.GetBufferCch()),
                acc);
            acc.Detach();
            pszCursor = buffDriveStrings;
            while (*pszCursor)
            {
                if (::GetDriveTypeW(pszCursor) == DRIVE_CDROM)
                {
                    DWORD dwAttributes;
                    DWORD dwWin32Error;

                    IFW32FALSE_EXIT(rsbDestination.Win32Assign(pszCursor, ::wcslen(pszCursor)));
                    IFW32FALSE_EXIT(rsbDestination.Win32AppendPathElement(wcsUrlTrailer, ::wcslen(wcsUrlTrailer)));

                    IFW32FALSE_EXIT(
                        ::SxspGetFileAttributesW(
                            rsbDestination,
                            dwAttributes,
                            dwWin32Error,
                            4,
                            ERROR_FILE_NOT_FOUND,
                            ERROR_PATH_NOT_FOUND,
                            ERROR_NOT_READY,
                            ERROR_ACCESS_DENIED));

                    if (dwWin32Error == ERROR_SUCCESS)
                    {
                        fFoundCodebase = TRUE;
                        FN_SUCCESSFUL_EXIT();
                    }
                }

                pszCursor += ::wcslen(pszCursor) + 1;
            }
        }
        //
        // This wasn't a CD-rom installation, so prepend the install source path to
        // the string that was passed in.
        //
        else
        {
            IFW32FALSE_EXIT(rsbDestination.Win32Assign(buffWindowsInstallSource, buffWindowsInstallSource.Cch()));
            IFW32FALSE_EXIT(rsbDestination.Win32AppendPathElement(wcsUrlTrailer, ::wcslen(wcsUrlTrailer)));
            bool fExist = false;
            IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY, rsbDestination, fExist));
            if (fExist)
            {
                fFoundCodebase = TRUE;
                fSuccess = TRUE;
                goto Exit;
            }
        }

        iWhichSource++;
    }

    fSuccess = TRUE;
Exit:
    if (!fFoundCodebase)
    {
        rsbDestination.Clear();
    }
    return fSuccess;
}

BOOL
CAssemblyRecoveryInfo::AssociateWithAssembly(
    IN OUT CBaseStringBuffer &rsbSourceAssemblyName,
    bool &rfNoAssembly
    )
{
    //
    // First check the manifest that the assembly came out of.  If it still exists,
    // then nifty, go and load the info from it.  Otherwise, we should look in the
    // registry for information instead.
    //
    FN_PROLOG_WIN32

    CFusionRegKey   hInstallInfoKey;
    CFusionRegKey   hRequestedAsm;

    rfNoAssembly = true;

    //
    // First attempt - try to load it directly off the root installation key.
    //
    if (!m_fLoadedAndReady)
    {
        IFW32FALSE_EXIT(this->Initialize());
        IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0, KEY_READ, hInstallInfoKey));
        IFW32FALSE_EXIT(
            hInstallInfoKey.OpenSubKey(
                hRequestedAsm,
                rsbSourceAssemblyName,
                KEY_READ));

        //
        // This direct entry wasn't found, so let's go see if we can map it back to some
        // other assembly name using the shortname stuff.
        //
        if (hRequestedAsm == CRegKey::GetInvalidValue())
        {
            IFW32FALSE_EXIT(
                ::pMapShortNameToAssembly(
                    rsbSourceAssemblyName,      // if this is a short name of an assembly, this function would set this to be real assembly name if match is found
                    hInstallInfoKey,
                    hRequestedAsm));

            //
            // Still not found? Darn.
            //
            if (hRequestedAsm == CRegKey::GetInvalidValue())
                FN_SUCCESSFUL_EXIT();
        }

        IFW32FALSE_EXIT(this->m_sbAssemblyDirectoryName.Win32Assign(rsbSourceAssemblyName));
        IFW32FALSE_EXIT(this->m_SecurityMetaData.LoadFromRegistryKey(hRequestedAsm));

        this->m_fLoadedAndReady = TRUE;
    }

    //
    // Only set the "no assembly" if we were able to associate (before or
    // above.)
    //
    if ( this->m_fLoadedAndReady )
        rfNoAssembly = false;

    FN_EPILOG
}

BOOL
SxspDetermineCodebaseType(
    IN const CBaseStringBuffer &rcbuffUrlString,
    OUT SxsWFPResolveCodebase &rcbaseType,
    OUT CBaseStringBuffer *pbuffRemainder
    )
{
    FN_PROLOG_WIN32

    PCWSTR pcwszStringTop = rcbuffUrlString;
    SIZE_T cch = rcbuffUrlString.Cch();
    SIZE_T i = 0;
    CSmallStringBuffer buffTemp; // may be used if we mangle the URL text more

    rcbaseType = CODEBASE_RESOLVED_URLHEAD_UNKNOWN;

    if (pbuffRemainder != NULL)
        pbuffRemainder->Clear();

#define ENTRY(_x) { URLHEAD_ ## _x, NUMBER_OF(URLHEAD_ ## _x) - 1, NUMBER_OF(URLHEAD_ ## _x) - 1, CODEBASE_RESOLVED_URLHEAD_ ## _x },

    static const struct
    {
        PCWSTR pszPrefix;
        SIZE_T cchPrefix;
        SIZE_T cchAdvance;
        SxsWFPResolveCodebase cbaseType;
    } s_rgMap[] =
    {
        ENTRY(FILE)
        ENTRY(WINSOURCE)
        ENTRY(CDROM)
        ENTRY(HTTP)
    };

#undef ENTRY

    for (i=0; i<NUMBER_OF(s_rgMap); i++)
    {
        if (_wcsnicmp(pcwszStringTop, s_rgMap[i].pszPrefix, s_rgMap[i].cchPrefix) == 0)
        {
            pcwszStringTop += s_rgMap[i].cchAdvance;
            cch -= s_rgMap[i].cchAdvance;
            rcbaseType = s_rgMap[i].cbaseType;
            break;
        }
    }

    // If there wasn't an entry, we'll assume it's a simple file path.
    if (i == NUMBER_OF(s_rgMap))
    {
        rcbaseType = CODEBASE_RESOLVED_URLHEAD_FILE;
    }
    else
    {
        // If it was a real file: codebase, there's ambiguity about whether there is supposed
        // to be 0, 1, 2 or 3 slashes, so we'll just absorb up to 3 slashes to get to what hopefully
        // is then a local path.  e.g.
        //
        //      file:c:\foo\bar.manifest
        //      file://c:\foo\bar.manifest
        //      file:///c:\foo\bar.manifest
        //
        // all turn into c:\foo\bar.manifest.  The URL standard seems clear that non-absolute
        // URLs are interpreted in the context of their containing document.  In the case
        // of a free-standing codebase, that would seem to mean that the hostname field is
        // required, where the general form is (by my reading):
        //
        //      file:[//[hostname]]/path
        //
        // it kind of makes sense to imagine that file:/c:\foo.manifest is reasonable; the only
        // useful context to get the hostname from is the local machine.  file:///c:\foo.manifest
        // meets the standards for URLs not contained in a web document.  file:c:\foo.manifest
        // also makes sense if you believe the point of the slash is separate the hostname specification
        // from the host-specific part of the URL, since if you're happy omitting the hostname
        // part, there's nothing to separate.  (Note that really file:c:\foo.manifest should
        // be considered relative to the current document since it doesn't have the slash at the
        // front of the name, but even less than we have a current hostname, we certainly
        // don't have a point in the filesystem hierarchy that it makes sense to consider "current".)
        //
        // file://c:\foo\bar.manifest seems to have become popular even though it doesn't
        // have any useful definition in any way shape or form.  The two slashes should indicate
        // that the next thing should be hostname; instead we see c:\
        //
        // That's all just a long-winded justifcation for absorbing up to 3 slashes at the
        // beginning of the remainder of the string.  If there are four or more, we'll let it fail
        // as a bad path later on.
        //
        //  mgrier 6/27/2001

        if (rcbaseType == CODEBASE_RESOLVED_URLHEAD_FILE)
        {
            if ((cch > 0) && (pcwszStringTop[0] == L'/'))
            {
                cch--;
                pcwszStringTop++;
            }
            if ((cch > 0) && (pcwszStringTop[0] == L'/'))
            {
                cch--;
                pcwszStringTop++;
            }
            if ((cch > 0) && (pcwszStringTop[0] == L'/'))
            {
                cch--;
                pcwszStringTop++;
            }
        }
        else if (rcbaseType == CODEBASE_RESOLVED_URLHEAD_HTTP)
        {
            // Hey, on Whistler, we have the WebDAV redirector, so
            // we can turn this URL into a UNC path!
            bool fGeneratedUNCPath = false;

            IFW32FALSE_EXIT(buffTemp.Win32Assign(L"\\\\", 2));

            if (pcwszStringTop[0] == L'/')
            {
                if (pcwszStringTop[1] == L'/')
                {
                    // http:// so far; the next thing must be a hostname!
                    PCWSTR pszSlash = wcschr(pcwszStringTop + 2, L'/');

                    if (pszSlash != NULL)
                    {
                        // //foo/bar  (http: removed earlier...)
                        // pcwszStringTop == [0]
                        // pszSlash == [5]
                        // cch == 9

                        IFW32FALSE_EXIT(buffTemp.Win32Append(pcwszStringTop + 2, (pszSlash - pcwszStringTop) - 3));
                        IFW32FALSE_EXIT(buffTemp.Win32Append(L"\\", 1));
                        IFW32FALSE_EXIT(buffTemp.Win32Append(pszSlash + 1, cch - (pszSlash - pcwszStringTop) - 1));

                        fGeneratedUNCPath = true;
                    }
                }
            }

            if (fGeneratedUNCPath)
            {
                // poof, it's a file path
                pcwszStringTop = buffTemp;
                cch = buffTemp.Cch();
                rcbaseType = CODEBASE_RESOLVED_URLHEAD_FILE;
            }
        }
    }

    if (pbuffRemainder != NULL)
    {
        IFW32FALSE_EXIT(
            pbuffRemainder->Win32Assign(pcwszStringTop, cch));
    }
#if DBG
    {
        CUnicodeString a(rcbuffUrlString, rcbuffUrlString.Cch());
        CUnicodeString b(rcbuffUrlString, (cch <= rcbuffUrlString.Cch()) ? (rcbuffUrlString.Cch() - cch) : 0);
        CUnicodeString c(pcwszStringTop, (cch <= ::wcslen(pcwszStringTop)) ? cch : 0);

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS: %s - split \"%wZ\" into \"%wZ\" and \"%wZ\"\n",
            __FUNCTION__, &a, &b, &c);
    }
#endif

    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::CopyValue(const CAssemblyRecoveryInfo& other)
{
    BOOL bSuccess = FALSE;

    FN_TRACE_WIN32(bSuccess);

    if (&other != this)
    {
        IFW32FALSE_EXIT(m_sbAssemblyDirectoryName.Win32Assign(other.m_sbAssemblyDirectoryName));
        IFW32FALSE_EXIT(m_SecurityMetaData.Initialize(other.m_SecurityMetaData));
        m_fLoadedAndReady = other.m_fLoadedAndReady;
    }

    bSuccess = TRUE;
Exit:
    if ( !bSuccess )
    {
        this->m_fLoadedAndReady = FALSE;
    }

    return bSuccess;
}


BOOL
CAssemblyRecoveryInfo::SetAssemblyIdentity(
    IN PCASSEMBLY_IDENTITY pcidAssembly
    )
{
    FN_PROLOG_WIN32
    CTinyStringBuffer sbTextualEncoding;
    IFW32FALSE_EXIT(::SxspGenerateTextualIdentity(0, pcidAssembly, sbTextualEncoding));
    IFW32FALSE_EXIT( this->SetAssemblyIdentity( sbTextualEncoding ) );

    FN_EPILOG
}

class CAssemblyRecoveryInfoPrepareForWritingLocals
{
public:
    CAssemblyRecoveryInfoPrepareForWritingLocals() { }
    ~CAssemblyRecoveryInfoPrepareForWritingLocals() { }

    CStringBuffer       buffTemp1;
    CStringBuffer       buffTemp2;
    CSmallStringBuffer  buffAsmRoot;
    CStringBuffer       buffManifestPath;
};

BOOL
CAssemblyRecoveryInfo::PrepareForWriting()
{
    FN_PROLOG_WIN32

    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> pIdentity;

    CSmartPtr<CAssemblyRecoveryInfoPrepareForWritingLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CSmallStringBuffer &buffAsmRoot = Locals->buffAsmRoot;
    CStringBuffer &buffTemp1 = Locals->buffTemp1;
    CStringBuffer &buffTemp2 = Locals->buffTemp2;
    const CBaseStringBuffer& OurTextualIdentity = m_SecurityMetaData.GetTextualIdentity();
    BOOL fIsPolicy = FALSE;
    DWORD dwWin32Error = 0;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS.DLL: %s - handling assembly \"%ls\"\n",
        __FUNCTION__,
        static_cast<PCWSTR>(OurTextualIdentity));

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffAsmRoot));
    IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(OurTextualIdentity, &pIdentity));
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(pIdentity, fIsPolicy));

    //
    // It's likely that this short name hasn't been generated yet, mostly because the files
    // may not have been copied around just yet.
    //
    if (this->m_SecurityMetaData.GetInstalledDirShortName().Cch() == 0)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                fIsPolicy ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY | ( fIsPolicy ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : 0 ),
                buffAsmRoot,
                buffAsmRoot.Cch(),
                pIdentity,
                NULL,
                buffTemp2));

        IFW32FALSE_EXIT(
            ::SxspGetShortPathName(
                buffTemp2,
                buffTemp1,
                dwWin32Error,
                4,
                ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND, ERROR_BAD_NET_NAME, ERROR_BAD_NETPATH));

        if (dwWin32Error == ERROR_SUCCESS)
        {
            IFW32FALSE_EXIT(buffTemp1.Win32RemoveTrailingPathSeparators());
            IFW32FALSE_EXIT(buffTemp1.Win32GetLastPathElement(buffTemp2));
            IFW32FALSE_EXIT(m_SecurityMetaData.SetInstalledDirShortName(buffTemp2));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - decided that the short dir name is \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffTemp2));
        }
        else
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - unable to determine short name for \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffTemp2));
        }
    }

    //
    // Get the public key token string
    //
    {
        PCWSTR wchString = NULL;
        SIZE_T cchString = 0;
        CFusionByteArray baStrongNameBits;

        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            pIdentity,
            &s_IdentityAttribute_publicKeyToken,
            &wchString,
            &cchString));

        if (cchString != 0)
        {
            IFW32FALSE_EXIT(::SxspHashStringToBytes(wchString, cchString, baStrongNameBits));
            IFW32FALSE_EXIT(m_SecurityMetaData.SetSignerPublicKeyTokenBits(baStrongNameBits));
        }
    }

    //
    // And now the short name of the manifest and catalog, but only if this
    // isn't a policy
    //
    if (!fIsPolicy)
    {
        CStringBuffer &buffManifestPath = Locals->buffManifestPath;

        IFW32FALSE_EXIT(
            ::SxspCreateManifestFileNameFromTextualString(
                0,
                ( fIsPolicy ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST ),
                buffAsmRoot,
                OurTextualIdentity,
                buffManifestPath));

        // Get the manifest short path first
        IFW32FALSE_EXIT(::SxspGetShortPathName(buffManifestPath, buffTemp1));
        IFW32FALSE_EXIT(buffTemp1.Win32GetLastPathElement(buffTemp2));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS: %s - manifest short path name determined to be \"%ls\"\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffTemp2));

        IFW32FALSE_EXIT(m_SecurityMetaData.SetShortManifestPath(buffTemp2));

        // Then swap extensions, get the catalog short path
        IFW32FALSE_EXIT(
            buffManifestPath.Win32ChangePathExtension(
                FILE_EXTENSION_CATALOG,
                FILE_EXTENSION_CATALOG_CCH,
                eAddIfNoExtension));

        IFW32FALSE_EXIT(::SxspGetShortPathName(buffManifestPath, buffTemp1));
        IFW32FALSE_EXIT(buffTemp1.Win32GetLastPathElement(buffTemp2));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS: %s - catalog short path name determined to be \"%ls\"\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffTemp2));

        IFW32FALSE_EXIT(m_SecurityMetaData.SetShortCatalogPath(buffTemp2));
    }

    FN_EPILOG

}

BOOL
CAssemblyRecoveryInfo::WriteSecondaryAssemblyInfoIntoRegistryKey(
    CRegKey & rhkRegistryNode
    ) const
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(m_SecurityMetaData.WriteSecondaryAssemblyInfoIntoRegistryKey(rhkRegistryNode));

    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::WritePrimaryAssemblyInfoToRegistryKey(
    ULONG Flags,
    CRegKey & rhkRegistryNode
    ) const
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    PARAMETER_CHECK((Flags & ~(SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_TO_REGISTRY_KEY_FLAG_REFRESH)) == 0);
    ULONG Flags2 = 0;

    if (Flags & SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_TO_REGISTRY_KEY_FLAG_REFRESH)
    {
        Flags2 |= SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_INTO_REGISTRY_KEY_FLAG_REFRESH;
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - propping recovery flag to WritePrimaryAssemblyInfoIntoRegistryKey\n",
            __FUNCTION__);
#endif
    }

    IFW32FALSE_EXIT(m_SecurityMetaData.WritePrimaryAssemblyInfoIntoRegistryKey(Flags2, rhkRegistryNode));

    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::OpenInstallationSubKey(
    CFusionRegKey& hkSingleAssemblyInfo,
    DWORD OpenOrCreate,
    DWORD Access)
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffRegKeyName;
    CFusionRegKey hkAllInstallationInfo;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> pAssemblyIdentity;

    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(
        0, 
        OpenOrCreate, 
        hkAllInstallationInfo));

    IFW32FALSE_EXIT( SxspCreateAssemblyIdentityFromTextualString(
        this->m_SecurityMetaData.GetTextualIdentity(),
        &pAssemblyIdentity ) );

    IFW32FALSE_EXIT( ::SxspGenerateSxsPath(
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
        SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
        NULL, 0,
        pAssemblyIdentity,
        NULL,
        buffRegKeyName ) );

    IFW32FALSE_EXIT( hkAllInstallationInfo.OpenSubKey(
        hkSingleAssemblyInfo,
        buffRegKeyName,
        Access,
        0));

    FN_EPILOG
}

VOID
CAssemblyRecoveryInfo::RestorePreviouslyExistingRegistryData()
{
    FN_PROLOG_VOID
    if (m_fHadCatalog)
    {
        CFusionRegKey hkSingleAssemblyInfo;

#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s() - restoring registry data for %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(this->m_SecurityMetaData.GetTextualIdentity()));
#endif

        IFW32FALSE_EXIT(
            this->OpenInstallationSubKey(
                hkSingleAssemblyInfo,
                KEY_CREATE_SUB_KEY, KEY_WRITE | KEY_READ | FUSIONP_KEY_WOW64_64KEY));

        IFW32FALSE_EXIT(
            hkSingleAssemblyInfo.SetValue(
                CSMD_TOPLEVEL_CATALOG,
                static_cast<DWORD>(1)));
    }
    FN_EPILOG
}

BOOL
CAssemblyRecoveryInfo::ClearExistingRegistryData()
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    //
    // Do not be so eager to delete registry metadata, so that
    // an assembly for which refresh failed might succeed if another
    // file change comes in, or sfc /scannow.
    //
    // As well, if a replace-existing install fails, don't destroy
    // the metadata for previously successfully installed instances
    // of the same assembly.
    //
    const static struct
    {
        PCWSTR Data;
        SIZE_T Length;
    }
    DeletableValues[] =
    {
#define ENTRY(x) { x, NUMBER_OF(x) - 1 }
        ENTRY(CSMD_TOPLEVEL_CATALOG),
    };
#undef ENTRY

    static const PCWSTR DeletableKeys[] =
    {
        NULL,
    };

    FN_PROLOG_WIN32


    CFusionRegKey   hkSingleAssemblyInfo;
    IFW32FALSE_EXIT(this->OpenInstallationSubKey(hkSingleAssemblyInfo, KEY_CREATE_SUB_KEY, KEY_WRITE | KEY_READ | FUSIONP_KEY_WOW64_64KEY));

    //
    // We need to delete the installation information for a single assembly - everything
    // this class owns.
    //
    if ( hkSingleAssemblyInfo != CFusionRegKey::GetInvalidValue() )
    {
        ULONG ul = 0;
        //
        // Clear values
        //
        for ( ul = 0; ul < NUMBER_OF(DeletableValues); ul++ )
        {
            DWORD dwWin32Error = NO_ERROR;

            IFW32FALSE_EXIT(
                hkSingleAssemblyInfo.DeleteValue(
                    DeletableValues[ul].Data,
                    dwWin32Error,
                    2,
                    ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND));

            if (dwWin32Error == NO_ERROR
                && !m_fHadCatalog
                && ::FusionpEqualStrings(
                        DeletableValues[ul].Data,
                        DeletableValues[ul].Length,
                        CSMD_TOPLEVEL_CATALOG,
                        NUMBER_OF(CSMD_TOPLEVEL_CATALOG) - 1,
                        FALSE
                        ))
            {
                m_fHadCatalog = true;
            }
        }

        // 
        // Delete eligible keys
        //
        for ( ul = 0; ul < NUMBER_OF(DeletableKeys); ul++ )
        {
            if (DeletableKeys[ul] != NULL && DeletableKeys[ul][0] != L'\0')
            {
                CFusionRegKey hkTempKey;
                IFW32FALSE_EXIT(hkSingleAssemblyInfo.OpenSubKey(hkTempKey, DeletableKeys[ul], KEY_WRITE, 0));
                if ( hkTempKey != CFusionRegKey::GetInvalidValue() )
                {
                    IFW32FALSE_EXIT(hkTempKey.DestroyKeyTree());
                    IFW32FALSE_EXIT(hkSingleAssemblyInfo.DeleteKey(DeletableKeys[ul]));
                }
            }
        }
    }

    FN_EPILOG
}



BOOL
SxspLooksLikeAssemblyDirectoryName(
    const CBaseStringBuffer &rsbSupposedAsmDirectoryName,
    BOOL &rfLooksLikeAssemblyName
    )
/*++
    Most of this was copied directly from SxspParseAssemblyReference, which
    is no longer valid, because it can't know how to turn the string back
    into the actual assembly reference just based on the hash value and
    public key of a string.
--*/
{
    FN_PROLOG_WIN32

    PCWSTR          pszCursor = NULL;
    PCWSTR          wsNextBlock = NULL;
    SIZE_T          cchSegment = 0;
    ASSEMBLY_VERSION Version;
    const WCHAR UNDERSCORE = L'_';
    bool fSyntaxValid = false;
    bool fAttributeValid = false;

    rfLooksLikeAssemblyName = FALSE;

    pszCursor = rsbSupposedAsmDirectoryName;

    //
    // Processor architecture
    //

    if ((wsNextBlock = ::StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = (wsNextBlock - pszCursor)) == 0)
        FN_SUCCESSFUL_EXIT();

    IFW32FALSE_EXIT(::FusionpParseProcessorArchitecture(pszCursor, cchSegment, NULL, fAttributeValid));
    if (!fAttributeValid)
        FN_SUCCESSFUL_EXIT();

    pszCursor = wsNextBlock + 1;

    //
    // Name
    //
    if ((wsNextBlock = StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = wsNextBlock - pszCursor) == 0)
        FN_SUCCESSFUL_EXIT();

    pszCursor = wsNextBlock + 1;

    //
    // Public key string
    //

    if ((wsNextBlock = StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = wsNextBlock - pszCursor) == 0)
        FN_SUCCESSFUL_EXIT();

    if ((::FusionpCompareStrings(
            pszCursor,
            cchSegment,
            SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE,
            NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1,
            true) == 0) ||
        !::SxspIsFullHexString(pszCursor, cchSegment))
        FN_SUCCESSFUL_EXIT();

    pszCursor = wsNextBlock + 1;

    //
    // Version string
    //
    if ((wsNextBlock = StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = wsNextBlock - pszCursor) == 0)
        FN_SUCCESSFUL_EXIT();

    IFW32FALSE_EXIT(CFusionParser::ParseVersion(Version, pszCursor, cchSegment, fSyntaxValid));
    if (!fSyntaxValid)
        FN_SUCCESSFUL_EXIT();

    pszCursor = wsNextBlock + 1;

    //
    // Language ID
    //
    if ((wsNextBlock = ::StringFindChar(pszCursor, UNDERSCORE)) == NULL)
        FN_SUCCESSFUL_EXIT();

    if ((cchSegment = wsNextBlock - pszCursor) == 0)
        FN_SUCCESSFUL_EXIT();

    //
    // BUGBUG (jonwis) - It seems that langids are no longer four-character hex
    // string representations of shorts anymore.  All we're checking at the moment
    // is to see that the string isn't blank.  Is this the Right Thing?
    //
    pszCursor = wsNextBlock + 1;

    //
    // Last block should just be the hash
    //
    if (!::SxspIsFullHexString(pszCursor, ::wcslen(pszCursor)))
        FN_SUCCESSFUL_EXIT();

    // We ran the gauntlet; all the segments of the path look good, let's use it.
    rfLooksLikeAssemblyName = TRUE;

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cmemorystream.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    cmemorystream.cpp

Abstract:

    Minimal implementation of IStream over an array of bytes.

Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#include "stdinc.h"
#include "cmemorystream.h"
#include "sxsexceptionhandling.h"
#if defined(FUSION_WIN)
#include "ntrtlmmapio.h"
#endif

/* aka doesn't make sense aka access denied */
#define NOTIMPL ASSERT_NTC(FALSE) ; return E_NOTIMPL

CMemoryStream::~CMemoryStream()
{
    ASSERT_NTC(m_cRef == 0);
}

ULONG __stdcall CMemoryStream::AddRef()
{
    FN_TRACE_ADDREF(CMemoryStream, m_cRef);
    return ::InterlockedIncrement(&m_cRef);
}

ULONG __stdcall CMemoryStream::Release()
{
    LONG cRef;
    FN_TRACE_RELEASE(CMemoryStream, cRef);

    if ((cRef = ::InterlockedDecrement(&m_cRef)) == 0)
    {
        /*delete this*/;
    }
    return cRef;
}

HRESULT
__stdcall
CMemoryStream::QueryInterface(
    REFIID  iid,
    void **ppvObj
    )
{
    FN_PROLOG_HR

    IUnknown *punk = NULL;
    IUnknown **ppunk = reinterpret_cast<IUnknown **>(ppvObj);
    *ppunk = NULL;
    if (false) { }
#define QI(i) else if (iid == __uuidof(i)) punk = static_cast<i *>(this);
    QI(IUnknown)
    QI(ISequentialStream)
    QI(IStream)
#undef QI
    else
    {
        ORIGINATE_HR_FAILURE_AND_EXIT(CMemoryStream::QueryInterface, E_NOINTERFACE);
    }

    AddRef();
    *ppunk = punk;

    FN_EPILOG
}

HRESULT __stdcall CMemoryStream::Read(void *pv, ULONG cb32, ULONG* pcbRead)
{
    HRESULT hr = NOERROR;
    NTSTATUS Status = STATUS_SUCCESS;

    const BYTE * const pbCurrent = m_pbCurrent; // read this once for near thread safety..
    __int64 cb = cb32;
    __int64 cbBytesRemaining = (m_pbEnd - pbCurrent);

    if (cb > cbBytesRemaining)
        cb = cbBytesRemaining;

#if defined(FUSION_WIN)
    Status = RtlCopyMappedMemory(pv, pbCurrent, static_cast<SIZE_T>(cb));
#else
    CopyMemory(pv, pbCurrent, static_cast<SIZE_T>(cb));
#endif    
    if (!NT_SUCCESS(Status))
    {
        hr = HRESULT_FROM_WIN32(FusionpRtlNtStatusToDosError(Status));

        goto Exit;
    }

    m_pbCurrent = pbCurrent + cb; // write this once for near thread safety..
    *pcbRead = static_cast<ULONG>(cb);


    hr = NOERROR;
Exit:
    return hr;
}

HRESULT __stdcall CMemoryStream::Write(void const *pv, ULONG cb, ULONG* pcbWritten)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::SetSize(ULARGE_INTEGER libNewSize)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::Commit(DWORD grfCommitFlags)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::Revert()
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    NOTIMPL;
}

HRESULT __stdcall CMemoryStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
#if 1
    NOTIMPL;
#else
    we can return size, we can return access==read only
#endif
}

HRESULT __stdcall CMemoryStream::Clone(IStream **ppIStream)
{
    NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cassemblyrecoveryinfo.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    cassemblyrecoveryinfo.h

Abstract:

Author:

Environment:

Revision History:

--*/
#pragma once

class CAssemblyRecoveryInfo;

#include "fusionbuffer.h"
#include "csecuritymetadata.h"

#define WINSXS_INSTALL_SOURCE_BASEDIR    (L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup")
#define WINSXS_INSTALL_SVCPACK_REGKEY    (L"ServicePackSourcePath")
#define WINSXS_INSTALL_SOURCEPATH_REGKEY (L"SourcePath")
#define WINSXS_INSTALL_SOURCE_IS_CDROM   (L"CDInstall")

class CAssemblyRecoveryInfo
{
private:
    CStringBuffer          m_sbAssemblyDirectoryName;
    CSecurityMetaData      m_SecurityMetaData;
    BOOL                   m_fLoadedAndReady;
    bool                   m_fHadCatalog;
    
    BOOL ResolveWinSourceMediaURL(PCWSTR wszSource, CBaseStringBuffer &rsbDestination) const;
    BOOL ResolveCDRomURL(PCWSTR wszSource, CBaseStringBuffer &rsbDestination) const;

    enum CDRomSearchType
    {
        CDRST_Tagfile,
        CDRST_SerialNumber,
        CDRST_VolumeName
    };

public:
    CAssemblyRecoveryInfo()
        : 
          m_fLoadedAndReady(FALSE),
          m_fHadCatalog(false)
    { }

    BOOL Initialize()
    {
        FN_PROLOG_WIN32
        
        m_sbAssemblyDirectoryName.Clear();
        m_fLoadedAndReady = FALSE;
        IFW32FALSE_EXIT( m_SecurityMetaData.Initialize() );

        FN_EPILOG
    }

    const CSecurityMetaData &GetSecurityInformation() const { return m_SecurityMetaData; }
    CSecurityMetaData& GetSecurityInformation() { return m_SecurityMetaData; }

    const CCodebaseInformationList& GetCodeBaseList() const { return m_SecurityMetaData.GetCodeBaseList(); }
//protected:
    CCodebaseInformationList& GetCodeBaseList() { return m_SecurityMetaData.GetCodeBaseList(); }
public:

    //
    // Fill out this object from a registry key
    //
    BOOL AssociateWithAssembly(CBaseStringBuffer &rcbuffLoadFromKeyName, bool &rfNoAssembly);

    //
    // Take an existing value - sort of like "initialize"
    //
    BOOL CopyValue(const CAssemblyRecoveryInfo &rsrc);

    //
    // Cheap, but effective.
    //
    const CBaseStringBuffer &GetAssemblyDirectoryName() const { return m_sbAssemblyDirectoryName; }
    BOOL GetHasCatalog() const                         { return TRUE; }
    BOOL GetInfoPrepared() const                       { return m_fLoadedAndReady; }

    //
    // Setters - useful for registration
    //
    BOOL SetAssemblyIdentity(IN const CBaseStringBuffer &rsb)  { return m_SecurityMetaData.SetTextualIdentity(rsb); }
    BOOL SetAssemblyIdentity( IN PCASSEMBLY_IDENTITY pcidAssembly );

    VOID SetHasCatalog(IN BOOL fHasCatalog)  { }

    //
    // Call this to try and resolve the internally listed codebase against
    // the system and return it into sbFinalCodebase.  Returns TRUE if the
    // operation is successful, not based on whether the codebase is valid.
    //
    BOOL ResolveCodebase(CBaseStringBuffer &rsbFinalCodebase, SxsWFPResolveCodebase &rCodebaseType) const;

    //
    // Last bit of bookkeeping necessary before writing the assembly to disk
    //
    BOOL PrepareForWriting();
    BOOL WriteSecondaryAssemblyInfoIntoRegistryKey(CRegKey & rhkRegistryNode) const;
#define SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_TO_REGISTRY_KEY_FLAG_REFRESH (0x00000001)
    BOOL WritePrimaryAssemblyInfoToRegistryKey(ULONG Flags, CRegKey & rhkRegistryNode) const;
    BOOL ClearExistingRegistryData();
    VOID RestorePreviouslyExistingRegistryData();
    BOOL OpenInstallationSubKey(CFusionRegKey& hkSingleAssemblyInfo, DWORD OpenOrCreate, DWORD Access);

private:
    CAssemblyRecoveryInfo(const CAssemblyRecoveryInfo &);
    void operator =(const CAssemblyRecoveryInfo &);
};

MAKE_CFUSIONARRAY_READY(CAssemblyRecoveryInfo, CopyValue);

/*
These are instantiated (in an unsearchable way) by the URLTAGINFO macro below.
 URLHEAD_WINSOURCE
 URLHEAD_FILE URLHEAD_CDROM
 URLHEAD_TAG
 URLHEAD_CDROM_TYPE_TAG
 URLHEAD_CDROM_TYPE_SERIALNUMBER
 URLHEAD_CDROM_TYPE_VOLUMENAME
*/
extern const UNICODE_STRING UnicodeString_URLHEAD_WINSOURCE;

#define URLTAGINFO( namevalue, str ) \
    __declspec(selectany) extern const WCHAR URLHEAD_ ##namevalue [] = ( str ); \
    static const SIZE_T URLHEAD_LENGTH_ ##namevalue = \
        ( sizeof( URLHEAD_ ##namevalue ) / sizeof( WCHAR ) ) - 1;

//
// Move these to a .cpp file.
//

URLTAGINFO(FILE, L"file:")
URLTAGINFO(CDROM, L"cdrom:")
URLTAGINFO(WINSOURCE, L"x-ms-windows-source:")
//URLTAGINFO(DARWINSOURCE, L"x-ms-darwin-source:")
URLTAGINFO(HTTP, L"http:")

// These things are not URL heads but nonetheless still use the same macro
URLTAGINFO(CDROM_TYPE_TAG, L"tagfile")
URLTAGINFO(CDROM_TYPE_SERIALNUMBER, L"serialnumber")
URLTAGINFO(CDROM_TYPE_VOLUMENAME, L"volumename")

BOOL
SxspLooksLikeAssemblyDirectoryName(
    const CBaseStringBuffer &rsbDoesLookLikeName,
    BOOL &rbLooksLikeAssemblyName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\comclsidmap.h ===
#if !defined(_FUSION_COMCLSIDMAP_H_INCLUDED_)
#define _FUSION_COMCLSIDMAP_H_INCLUDED_

#pragma once

typedef const struct _ACTCTXCTB_ASSEMBLY_CONTEXT *PCACTCTXCTB_ASSEMBLY_CONTEXT;

class CClsidMap
{
public:
    CClsidMap();
    ~CClsidMap();

    BOOL Initialize();
    BOOL Uninitialize();

    BOOL MapReferenceClsidToConfiguredClsid(const GUID *ReferenceClsid, PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext, GUID *ConfiguredClsid, GUID *ImplementedClsid);

private:
    struct LocalMapping
    {
        struct LocalMapping *m_pNext;
        GUID m_ReferenceClsid;
        GUID m_ConfiguredClsid;
        GUID m_ImplementedClsid;
    };

    ULONG m_cLocalMappings;
    LocalMapping *m_pLocalMappingListHead;
};

#endif // !defined(_FUSION_COMCLSIDMAP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cmemorystream.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    cmemorystream.h

Abstract:

    Minimal implementation of IStream over an array of bytes.

Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#pragma once
#include "objidl.h"
#include "fusiontrace.h"

class CMemoryStream : public IStream
{
public:
    CMemoryStream();
    BOOL Initialize(const BYTE*, const BYTE*);
    virtual ~CMemoryStream();

    // IUnknown methods:
    ULONG __stdcall AddRef();
    ULONG __stdcall Release();
    HRESULT __stdcall QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    HRESULT __stdcall Read(void *pv, ULONG cb, ULONG *pcbRead);
    HRESULT __stdcall Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    HRESULT __stdcall Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    HRESULT __stdcall SetSize(ULARGE_INTEGER libNewSize);
    HRESULT __stdcall CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    HRESULT __stdcall Commit(DWORD grfCommitFlags);
    HRESULT __stdcall Revert();
    HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    HRESULT __stdcall Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    HRESULT __stdcall Clone(IStream **ppIStream);

protected:
    LONG        m_cRef;
    const BYTE *m_pbCurrent;
    const BYTE *m_pbBegin;
    const BYTE *m_pbEnd;

private: // intentionally not implemented
    CMemoryStream(const CMemoryStream &r);
    CMemoryStream &operator =(const CMemoryStream &r);
};

inline
CMemoryStream::CMemoryStream(
    )
:
    m_cRef(0),
    m_pbCurrent(NULL),
    m_pbBegin(NULL),
    m_pbEnd(NULL)
{
}

inline
BOOL
CMemoryStream::Initialize(
    const BYTE *pbBegin,
    const BYTE *pbEnd
    )
{
    m_pbBegin = pbBegin;
    m_pbEnd = pbEnd;
    m_pbCurrent = pbBegin;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\comclass.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    comclass.cpp

Abstract:

    Activation context section contributor for COM servers.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(iid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(progid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(proxyStubClsid32);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(runtimeVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(threadingModel);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(tlbid);

#define ALLOCATE_BUFFER_SPACE(_bytesNeeded, _bufferCursor, _bytesLeft, _bytesWritten, _typeName, _ptr) \
do { \
    if (_bytesLeft < (_bytesNeeded)) \
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER); \
    _bytesLeft -= (_bytesNeeded); \
    _bytesWritten += (_bytesNeeded); \
    _ptr = (_typeName) _bufferCursor; \
    _bufferCursor = (PVOID) (((ULONG_PTR) _bufferCursor) + (_bytesNeeded)); \
} while (0)

#define ALLOCATE_BUFFER_SPACE_TYPE(_typeName, _bufferCursor, _bytesLeft, _bytesWritten, _ptr) \
    ALLOCATE_BUFFER_SPACE(sizeof(_typeName), _bufferCursor, _bytesLeft, _bytesWritten, _typeName *, _ptr)


typedef struct _COM_GLOBAL_CONTEXT *PCOM_GLOBAL_CONTEXT;
typedef struct _COM_FILE_CONTEXT *PCOM_FILE_CONTEXT;
typedef struct _COM_SERVER_ENTRY *PCOM_SERVER_ENTRY;

typedef struct _COM_SERVER_ENTRY
{
public:
    _COM_SERVER_ENTRY() { }

    CDequeLinkage m_Linkage;

    PCOM_FILE_CONTEXT m_FileContext;
    GUID m_ReferenceClsid;
    GUID m_ConfiguredClsid;
    GUID m_ImplementedClsid;
    GUID m_TypeLibraryId;
    ULONG m_ThreadingModel;
    CSmallStringBuffer m_ProgIdBuffer;
    CTinyStringBuffer m_TypeNameBuffer;
    CTinyStringBuffer m_ShimNameBuffer;
    CTinyStringBuffer m_RuntimeVersionBuffer;
    ULONG m_ShimType;
    bool m_IsFirstShim;
private:
    _COM_SERVER_ENTRY(const _COM_SERVER_ENTRY &);
    void operator =(const _COM_SERVER_ENTRY &);
} COM_SERVER_ENTRY;

typedef CDeque<COM_SERVER_ENTRY, offsetof(COM_SERVER_ENTRY, m_Linkage)> CComServerDeque;
typedef CDequeIterator<COM_SERVER_ENTRY, offsetof(COM_SERVER_ENTRY, m_Linkage)> CComServerDequeIterator;


typedef struct _COM_FILE_CONTEXT
{
public:
    _COM_FILE_CONTEXT() { }
    ~_COM_FILE_CONTEXT() { m_ServerList.ClearAndDeleteAll(); }


    CDequeLinkage m_Linkage;
    CSmallStringBuffer m_FileNameBuffer;
    CComServerDeque m_ServerList;
    ULONG m_Offset; // populated during section generation
    PCOM_GLOBAL_CONTEXT m_GlobalContext;

private:
    _COM_FILE_CONTEXT(const _COM_FILE_CONTEXT &);
    void operator =(const _COM_FILE_CONTEXT &);
} COM_FILE_CONTEXT;

typedef CDeque<COM_FILE_CONTEXT, offsetof(COM_FILE_CONTEXT, m_Linkage)> CComFileDeque;
typedef CDequeIterator<COM_FILE_CONTEXT, offsetof(COM_FILE_CONTEXT, m_Linkage)> CComFileDequeIterator;

typedef struct _COM_GLOBAL_CONTEXT
{
    _COM_GLOBAL_CONTEXT() { }
    ~_COM_GLOBAL_CONTEXT() { m_FileContextList.ClearAndDeleteAll(); }

    // Temporary holding buffer for the filename until the first COM server entry is
    // found, at which time a COM_FILE_CONTEXT is allocated and the filename moved to it.
    CSmallStringBuffer m_FileNameBuffer;
    CComFileDeque m_FileContextList;
    CTinyStringBuffer m_FirstShimNameBuffer;
    ULONG m_FirstShimNameOffset;
    ULONG m_FirstShimNameLength;

    // When the first clrClass entry is created, its file context is written here for
    // easy access in the future.  It will exist in the normal list of files as well,
    // however, and will get cleaned up when the file list goes away.
    PCOM_FILE_CONTEXT m_MscoreeFileContext;

    struct _CallBackLocalsStruct
    {
        CStringBuffer FileNameBuffer;
        CSmallStringBuffer VersionIndependentComClassIdBuffer;
        CStringBuffer TempBuffer;
        CSmallStringBuffer ProgIdBuffer;
        CSmallStringBuffer RuntimeVersionBuffer;
        CSmallStringBuffer NameBuffer;
    } CallbackLocals;

private:
    _COM_GLOBAL_CONTEXT(const _COM_GLOBAL_CONTEXT &);
    void operator =(const _COM_GLOBAL_CONTEXT &);
} COM_GLOBAL_CONTEXT;


VOID
__fastcall
SxspComClassRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PGUID_SECTION_GENERATION_CONTEXT GSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    CSmartPtr<COM_GLOBAL_CONTEXT> ComGlobalContext;
    ULONG ThreadingModel = 0;
    GUID ReferenceClsid;
    GUID ConfiguredClsid;
    GUID ImplementedClsid;
    GUID TypeLibraryId = GUID_NULL;
    GUID iid;
    bool fFound = false;
    SIZE_T cb = 0;

    if (GSGenContext != NULL)
        ComGlobalContext.AttachNoDelete((PCOM_GLOBAL_CONTEXT) ::SxsGetGuidSectionGenerationContextCallbackContext(GSGenContext));

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(ComGlobalContext == NULL);
        INTERNAL_ERROR_CHECK(GSGenContext == NULL);

        IFW32FALSE_EXIT(ComGlobalContext.Win32Allocate(__FILE__, __LINE__));

        ComGlobalContext->m_FirstShimNameOffset = 0;
        ComGlobalContext->m_FirstShimNameLength = 0;
        ComGlobalContext->m_MscoreeFileContext = NULL;

        IFW32FALSE_EXIT(
            ::SxsInitGuidSectionGenerationContext(
                &GSGenContext,
                ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER,
                &::SxspComClassRedirectionGuidSectionGenerationCallback,
                ComGlobalContext));

        ComGlobalContext.Detach();

        Data->Header.ActCtxGenContext = GSGenContext;
        Data->GenBeginning.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:

        ::SxsDestroyGuidSectionGenerationContext(GSGenContext);
        FUSION_DELETE_SINGLETON(ComGlobalContext.Detach());
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;

        if (GSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingGuidSectionGenerationContext(GSGenContext));

        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        // Someone shouldn't be asking for the section size if this is a parse-only
        // run.  These two asserts should be equivalent...
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionSize(GSGenContext, &Data->GetSectionSize.SectionSize));
        Data->GetSectionSize.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        Data->ElementParsed.Success = FALSE;

        if ((Data->ElementParsed.ParseContext->XMLElementDepth == 2) &&
            (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file") - 1,
                    false) == 0))
        {
            INTERNAL_ERROR_CHECK2(
                ComGlobalContext != NULL,
                "context NULL in callback.");

            CStringBuffer &FileNameBuffer = ComGlobalContext->CallbackLocals.FileNameBuffer;
            SIZE_T cbBytesWritten = 0;

            // capture the name of the file
            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_name,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(FileNameBuffer),
                    &FileNameBuffer,
                    cbBytesWritten,
                    NULL,
                    NULL));

            // If there's no NAME attribute, someone else will puke; we'll handle it
            // gracefully.
            if (fFound || (FileNameBuffer.Cch() == 0))
            {
                IFW32FALSE_EXIT(ComGlobalContext->m_FileNameBuffer.Win32Assign(FileNameBuffer));
            }
        }
        else if (
            (Data->ElementParsed.ParseContext->XMLElementDepth == 3) &&
            (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comClass",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comClass") - 1,
                    false) == 0))
        {
            INTERNAL_ERROR_CHECK2(
                ComGlobalContext != NULL,
                "COM global context NULL while processing comClass tag");

            CSmallStringBuffer &VersionIndependentComClassIdBuffer = ComGlobalContext->CallbackLocals.VersionIndependentComClassIdBuffer;
            VersionIndependentComClassIdBuffer.Clear();
            CSmartPtr<COM_SERVER_ENTRY> Entry;
            CSmartPtr<COM_FILE_CONTEXT> FileContext;
            CStringBuffer &TempBuffer = ComGlobalContext->CallbackLocals.TempBuffer;
            TempBuffer.Clear();
            CSmallStringBuffer &ProgIdBuffer = ComGlobalContext->CallbackLocals.ProgIdBuffer;
            ProgIdBuffer.Clear();

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                    &s_AttributeName_clsid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(VersionIndependentComClassIdBuffer),
                    &VersionIndependentComClassIdBuffer,
                    cb,
                    NULL,
                    0));

            INTERNAL_ERROR_CHECK(fFound);

            IFW32FALSE_EXIT(::SxspParseGUID(VersionIndependentComClassIdBuffer,
                                            VersionIndependentComClassIdBuffer.Cch(),
                                            ReferenceClsid));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_threadingModel,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseThreadingModel(TempBuffer, TempBuffer.Cch(), &ThreadingModel));
            else
                ThreadingModel = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE;

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_progid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(ProgIdBuffer),
                    &ProgIdBuffer,
                    cb,
                    NULL,
                    0));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_tlbid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseGUID(TempBuffer, TempBuffer.Cch(), TypeLibraryId));
            else
                TypeLibraryId = GUID_NULL;

            // That was sufficient if we are generating a context.
            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                BOOL fNewAllocate = FALSE;
                IFW32FALSE_EXIT(Data->Header.ClsidMappingContext->Map->MapReferenceClsidToConfiguredClsid(
                            &ReferenceClsid,
                            Data->ElementParsed.AssemblyContext,
                            &ConfiguredClsid,
                            &ImplementedClsid));

                // See if we already have a file context; if we do not, allocate one.
                if (ComGlobalContext->m_FileNameBuffer.Cch() != 0)
                {
                    IFW32FALSE_EXIT(FileContext.Win32Allocate(__FILE__, __LINE__));
                    fNewAllocate = TRUE;

                    IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign(ComGlobalContext->m_FileNameBuffer));
                    ComGlobalContext->m_FileContextList.AddToHead(FileContext.DetachAndHold());
                    FileContext->m_GlobalContext = ComGlobalContext;
                }
                else
                {
                    CComFileDequeIterator Iter(&ComGlobalContext->m_FileContextList);
                    Iter.Reset();
                    FileContext.AttachNoDelete(Iter);
                }

                ASSERT(FileContext != NULL);

                IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                Entry->m_ShimType = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = TypeLibraryId;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext.DetachAndHold();
                IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32Assign(ProgIdBuffer));

                IFW32FALSE_EXIT(
                    ::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ReferenceClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID));

                FileContext->m_ServerList.AddToHead(Entry.Detach());

                // And we add another, indexed by the configured clsid
                IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = TypeLibraryId;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32Assign(ProgIdBuffer));

                IFW32FALSE_EXIT(
                    ::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ConfiguredClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID));

                FileContext->m_ServerList.AddToHead(Entry.Detach());
            }
        }
        else if (
            (Data->ElementParsed.ParseContext->XMLElementDepth == 3) &&
            (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comInterfaceProxyStub",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comInterfaceProxyStub") - 1,
                    false) == 0))
        {
            INTERNAL_ERROR_CHECK2(
                ComGlobalContext != NULL,
                "COM global context NULL while processing comInterfaceProxyStub tag");

            CSmartPtr<COM_SERVER_ENTRY> Entry;
            CSmartPtr<COM_FILE_CONTEXT> FileContext;
            CStringBuffer &TempBuffer = ComGlobalContext->CallbackLocals.TempBuffer;
            TempBuffer.Clear();

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                    &s_AttributeName_iid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(iid),
                    &iid,
                    cb,
                    &::SxspValidateGuidAttribute,
                    0));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_proxyStubClsid32,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(ReferenceClsid),
                    &ReferenceClsid,
                    cb,
                    &::SxspValidateGuidAttribute,
                    0));

            if (!fFound)
                ReferenceClsid = iid;

            ThreadingModel = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH;

            // That was sufficient if we are generating a context.
            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                IFW32FALSE_EXIT(Data->Header.ClsidMappingContext->Map->MapReferenceClsidToConfiguredClsid(
                            &ReferenceClsid,
                            Data->ElementParsed.AssemblyContext,
                            &ConfiguredClsid,
                            &ImplementedClsid));

                // See if we already have a file context; if we do not, allocate one.
                if (ComGlobalContext->m_FileNameBuffer.Cch() != 0)
                {
                    IFW32FALSE_EXIT(FileContext.Win32Allocate(__FILE__, __LINE__));
                    IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign(ComGlobalContext->m_FileNameBuffer));
                    ComGlobalContext->m_FileContextList.AddToHead(FileContext.DetachAndHold());
                    FileContext->m_GlobalContext = ComGlobalContext;
                }
                else
                {
                    CComFileDequeIterator Iter(&ComGlobalContext->m_FileContextList);
                    Iter.Reset();                    
                    FileContext.AttachNoDelete(Iter);
                }

                INTERNAL_ERROR_CHECK(FileContext != NULL);

                IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                Entry->m_ShimType = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = GUID_NULL;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                Entry->m_ProgIdBuffer.Clear();

                IFW32FALSE_EXIT(
                    ::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ReferenceClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID));

                FileContext->m_ServerList.AddToHead(Entry.Detach());

                // We don't want to delete the FileContext on exit any more if it was newly allocated
                FileContext.DetachAndHold();

                // And we add another, indexed by the configured clsid
                IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = GUID_NULL;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                Entry->m_ProgIdBuffer.Clear();

                IFW32FALSE_EXIT(
                    ::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ConfiguredClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID));

                FileContext->m_ServerList.AddToHead(Entry.Detach());
            }
        }
        else if (
            (Data->ElementParsed.ParseContext->XMLElementDepth == 2) &&
            (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrClass",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrClass") - 1,
                    false) == 0))
        {

            INTERNAL_ERROR_CHECK2(
                ComGlobalContext != NULL,
                "COM global context NULL while processing ndpClass tag");

            CSmallStringBuffer &VersionIndependentComClassIdBuffer = ComGlobalContext->CallbackLocals.VersionIndependentComClassIdBuffer;
            VersionIndependentComClassIdBuffer.Clear();
            CSmartPtr<COM_SERVER_ENTRY> Entry;
            CSmartPtr<COM_FILE_CONTEXT> FileContext;
            CStringBuffer &TempBuffer = ComGlobalContext->CallbackLocals.TempBuffer;
            TempBuffer.Clear();
            CSmallStringBuffer &ProgIdBuffer = ComGlobalContext->CallbackLocals.ProgIdBuffer;
            ProgIdBuffer.Clear();
            CSmallStringBuffer &RuntimeVersionBuffer = ComGlobalContext->CallbackLocals.RuntimeVersionBuffer;
            RuntimeVersionBuffer.Clear();
            CSmallStringBuffer &NameBuffer = ComGlobalContext->CallbackLocals.NameBuffer;
            NameBuffer.Clear();
            bool fIsFirstShim = false;

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                    &s_AttributeName_name,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(NameBuffer),
                    &NameBuffer,
                    cb,
                    NULL,
                    0));

            INTERNAL_ERROR_CHECK(fFound);

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                    &s_AttributeName_clsid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(VersionIndependentComClassIdBuffer),
                    &VersionIndependentComClassIdBuffer,
                    cb,
                    NULL,
                    0));

            INTERNAL_ERROR_CHECK(fFound);

            IFW32FALSE_EXIT(
                ::SxspParseGUID(
                    VersionIndependentComClassIdBuffer,
                    VersionIndependentComClassIdBuffer.Cch(),
                    ReferenceClsid));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_threadingModel,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseThreadingModel(TempBuffer, TempBuffer.Cch(), &ThreadingModel));
            else
                ThreadingModel = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH;

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_progid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(ProgIdBuffer),
                    &ProgIdBuffer,
                    cb,
                    NULL,
                    0));

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_tlbid,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(TempBuffer),
                    &TempBuffer,
                    cb,
                    NULL,
                    0));

            if (fFound)
                IFW32FALSE_EXIT(::SxspParseGUID(TempBuffer, TempBuffer.Cch(), TypeLibraryId));
            else
                TypeLibraryId = GUID_NULL;

            IFW32FALSE_EXIT(
                ::SxspGetAttributeValue(
                    0,
                    &s_AttributeName_runtimeVersion,
                    &Data->ElementParsed,
                    fFound,
                    sizeof(RuntimeVersionBuffer),
                    &RuntimeVersionBuffer,
                    cb,
                    NULL,
                    0));

            // That was sufficient if we are generating a context.
            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                if (ComGlobalContext->m_FirstShimNameBuffer.Cch() == 0)
                {
                    fIsFirstShim = true;
                    IFW32FALSE_EXIT(ComGlobalContext->m_FirstShimNameBuffer.Win32Assign(L"MSCOREE.DLL", 11));
                }
                else
                {
                    IFW32FALSE_EXIT(
                        ComGlobalContext->m_FirstShimNameBuffer.Win32Equals(
                            L"MSCOREE.DLL", 11,
                            fIsFirstShim,
                            true));
                }

                IFW32FALSE_EXIT(
                    Data->Header.ClsidMappingContext->Map->MapReferenceClsidToConfiguredClsid(
                        &ReferenceClsid,
                        Data->ElementParsed.AssemblyContext,
                        &ConfiguredClsid,
                        &ImplementedClsid));

                // If we don't already have a file context for mscoree, then we have to create a new one.
                if (ComGlobalContext->m_MscoreeFileContext == NULL)
                {
                    IFW32FALSE_EXIT(FileContext.Win32Allocate(__FILE__, __LINE__));
                    IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign("mscoree.dll", 11));

                    ComGlobalContext->m_FileContextList.AddToHead(FileContext.DetachAndHold());
                    ComGlobalContext->m_MscoreeFileContext = FileContext;
                    FileContext->m_GlobalContext = ComGlobalContext;
                }
                else
                {
                    FileContext.AttachNoDelete(ComGlobalContext->m_MscoreeFileContext);
                }


                INTERNAL_ERROR_CHECK(FileContext != NULL);

                IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                Entry->m_ShimType = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_CLR_CLASS;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = TypeLibraryId;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32Assign(ProgIdBuffer));
                IFW32FALSE_EXIT(Entry->m_ShimNameBuffer.Win32Assign(L"MSCOREE.DLL", 11));
                IFW32FALSE_EXIT(Entry->m_RuntimeVersionBuffer.Win32Assign(RuntimeVersionBuffer));
                IFW32FALSE_EXIT(Entry->m_TypeNameBuffer.Win32Assign(NameBuffer));
                Entry->m_IsFirstShim = fIsFirstShim;

                IFW32FALSE_EXIT(
                    ::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ReferenceClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID));

                FileContext->m_ServerList.AddToHead(Entry.Detach());

                // We don't need to delete FileContext on exit any more...
                FileContext.DetachAndHold();

                // And we add another, indexed by the configured clsid
                IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                Entry->m_ShimType = ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_CLR_CLASS;
                Entry->m_ReferenceClsid = ReferenceClsid;
                Entry->m_ConfiguredClsid = ConfiguredClsid;
                Entry->m_ImplementedClsid = ImplementedClsid;
                Entry->m_TypeLibraryId = TypeLibraryId;
                Entry->m_ThreadingModel = ThreadingModel;
                Entry->m_FileContext = FileContext;
                IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32Assign(ProgIdBuffer));
                IFW32FALSE_EXIT(Entry->m_ShimNameBuffer.Win32Assign(L"MSCOREE.DLL", 11));
                IFW32FALSE_EXIT(Entry->m_TypeNameBuffer.Win32Assign(NameBuffer));
                IFW32FALSE_EXIT(Entry->m_RuntimeVersionBuffer.Win32Assign(RuntimeVersionBuffer));
                Entry->m_IsFirstShim = fIsFirstShim;

                IFW32FALSE_EXIT(
                    ::SxsAddGuidToGuidSectionGenerationContext(
                        (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                        &ConfiguredClsid,
                        Entry,
                        Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_CLSID));

                FileContext->m_ServerList.AddToHead(Entry.Detach());
            }
        }

        // Everything's groovy!
        Data->ElementParsed.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionData(GSGenContext, Data->GetSectionData.SectionSize, Data->GetSectionData.SectionDataStart, NULL));
        Data->GetSectionData.Success = TRUE;
        break;
    }
Exit:
    ;
}

BOOL
SxspComClassRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PCOM_GLOBAL_CONTEXT ComGlobalContext = (PCOM_GLOBAL_CONTEXT) Context;

    INTERNAL_ERROR_CHECK(CallbackData != NULL);

    switch (Reason)
    {
    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
        {
            INTERNAL_ERROR_CHECK(ComGlobalContext != NULL);

            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE) CallbackData;
            CComFileDequeIterator Iter(&ComGlobalContext->m_FileContextList);

            CBData->DataSize = 0;

            // If we have a mscoree shim, add its size to the user data buffer area.
            if (ComGlobalContext->m_FirstShimNameBuffer.Cch() != 0)
                CBData->DataSize += ((ComGlobalContext->m_FirstShimNameBuffer.Cch() + 1) * sizeof(WCHAR));

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                CBData->DataSize += ((Iter->m_FileNameBuffer.Cch() + 1) * sizeof(WCHAR));
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        {
            INTERNAL_ERROR_CHECK( ComGlobalContext != NULL );

            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA) CallbackData;
            SIZE_T BytesWritten = 0;
            SIZE_T BytesLeft = CBData->BufferSize;
            PWSTR Cursor = (PWSTR) CBData->Buffer;
            CComFileDequeIterator Iter(&ComGlobalContext->m_FileContextList);

            if (ComGlobalContext->m_FirstShimNameBuffer.Cch() != 0)
            {
                IFW32FALSE_EXIT(
                    ComGlobalContext->m_FirstShimNameBuffer.Win32CopyIntoBuffer(
                        &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        CBData->SectionHeader,
                        &ComGlobalContext->m_FirstShimNameOffset,
                        &ComGlobalContext->m_FirstShimNameLength));
            }

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(
                    Iter->m_FileNameBuffer.Win32CopyIntoBuffer(
                        &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        CBData->SectionHeader,
                        &Iter->m_Offset,
                        NULL));                     // the length is tracked elsewhere
            }

            CBData->BytesWritten = BytesWritten;

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            INTERNAL_ERROR_CHECK( ComGlobalContext != NULL );

            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PCOM_SERVER_ENTRY Entry = (PCOM_SERVER_ENTRY) CBData->DataContext;

            if (Entry != NULL)
            {
                if (Entry->m_FileContext != NULL)
                {
                    Entry->m_FileContext->m_ServerList.Remove(Entry);

                    //
                    // If that was the last entry in the file's server list, destroy the
                    // file entry (remove from global context, free
                    //
                    if (Entry->m_FileContext->m_ServerList.IsEmpty())
                    {
                        ComGlobalContext->m_FileContextList.Remove(Entry->m_FileContext);
                        FUSION_DELETE_SINGLETON(Entry->m_FileContext);
                        Entry->m_FileContext = NULL;
                    }
                }

                FUSION_DELETE_SINGLETON(Entry);
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PCOM_SERVER_ENTRY Entry = (PCOM_SERVER_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION);

            if (Entry->m_ProgIdBuffer.Cch() != 0)
                CBData->DataSize += ((Entry->m_ProgIdBuffer.Cch() + 1) * sizeof(WCHAR));

            if (Entry->m_ShimNameBuffer.Cch() != 0)
            {
                CBData->DataSize += sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM);

                if (Entry->m_RuntimeVersionBuffer.Cch() != 0)
                    CBData->DataSize += ((Entry->m_RuntimeVersionBuffer.Cch() + 1) * sizeof(WCHAR));

                if (!Entry->m_IsFirstShim)
                    CBData->DataSize += ((Entry->m_ShimNameBuffer.Cch() + 1) * sizeof(WCHAR));

                if (Entry->m_TypeNameBuffer.Cch() != 0)
                    CBData->DataSize += ((Entry->m_TypeNameBuffer.Cch() + 1) * sizeof(WCHAR));
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PCOM_SERVER_ENTRY Entry = (PCOM_SERVER_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Info;
            PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM ShimInfo = NULL;
            PVOID Cursor = CBData->Buffer;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            ALLOCATE_BUFFER_SPACE_TYPE(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION, Cursor, BytesLeft, BytesWritten, Info);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION);
            Info->Flags = 0;
            Info->ThreadingModel = Entry->m_ThreadingModel;
            Info->ReferenceClsid = Entry->m_ReferenceClsid;
            Info->ConfiguredClsid = Entry->m_ConfiguredClsid;
            Info->ImplementedClsid = Entry->m_ImplementedClsid;
            Info->TypeLibraryId = Entry->m_TypeLibraryId;

            if (Entry->m_ShimNameBuffer.Cch() != 0)
            {
                PWSTR ShimName = NULL;
                SIZE_T OldBytesWritten = BytesWritten;
                SIZE_T ShimDataSize = 0;

                ALLOCATE_BUFFER_SPACE_TYPE(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM, Cursor, BytesLeft, BytesWritten, ShimInfo);

                IFW32FALSE_EXIT(
                    Entry->m_TypeNameBuffer.Win32CopyIntoBuffer(
                        (PWSTR *) &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        ShimInfo,
                        &ShimInfo->TypeOffset,
                        &ShimInfo->TypeLength));

                ShimInfo->ModuleLength = static_cast<ULONG>(Entry->m_FileContext->m_FileNameBuffer.Cch() * sizeof(WCHAR));
                ShimInfo->ModuleOffset = Entry->m_FileContext->m_Offset;

                IFW32FALSE_EXIT(
                    Entry->m_RuntimeVersionBuffer.Win32CopyIntoBuffer(
                        (PWSTR *) &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        ShimInfo,
                        &ShimInfo->ShimVersionOffset,
                        &ShimInfo->ShimVersionLength));

                ShimDataSize = BytesWritten - OldBytesWritten;

                if (Entry->m_IsFirstShim)
                {
                    Info->ModuleOffset = Entry->m_FileContext->m_GlobalContext->m_FirstShimNameOffset;
                    Info->ModuleLength = Entry->m_FileContext->m_GlobalContext->m_FirstShimNameLength;
                }
                else
                {
                    IFW32FALSE_EXIT(
                        Entry->m_ShimNameBuffer.Win32CopyIntoBuffer(
                            (PWSTR *) &Cursor,
                            &BytesLeft,
                            &BytesWritten,
                            CBData->SectionHeader,
                            &Info->ModuleOffset,
                            &Info->ModuleLength));
                }

                ShimInfo->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM);
                ShimInfo->Flags = 0;
                ShimInfo->Type = Entry->m_ShimType;

                ShimInfo->DataLength = 0;
                ShimInfo->DataOffset = 0;

                Info->ShimDataLength = static_cast<ULONG>(ShimDataSize);
                Info->ShimDataOffset = static_cast<ULONG>(((ULONG_PTR) ShimInfo) - ((ULONG_PTR) Info));
            }
            else
            {
                Info->ModuleLength = static_cast<ULONG>(Entry->m_FileContext->m_FileNameBuffer.Cch() * sizeof(WCHAR));
                Info->ModuleOffset = Entry->m_FileContext->m_Offset;
                Info->ShimDataLength = 0;
                Info->ShimDataOffset = 0;
            }

            IFW32FALSE_EXIT(Entry->m_ProgIdBuffer.Win32CopyIntoBuffer(
                (PWSTR *) &Cursor,
                &BytesLeft,
                &BytesWritten,
                Info,
                &Info->ProgIdOffset,
                &Info->ProgIdLength));

            CBData->BytesWritten = BytesWritten;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cominterface.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    cominterface.cpp

Abstract:

    Activation context section contributor for COM interface proxy mapping.

Author:

    Michael J. Grier (MGrier) 28-Mar-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include <stdio.h>
#include "sxsp.h"
#include "sxsidp.h"
#include "fusionparser.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(baseInterface);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(iid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(numMethods);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(proxyStubClsid32);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(tlbid);

/*

<file name="foo.dll">
   <comInterfaceProxyStub iid="{iid}" tlbid="{tlbid}" numMethods="3" baseInterface="{iid}" name="IFoo"/>
</file>

Notice this occurs outside the file block.
<comInterfaceExternalProxyStub
    required iid="{iid}"
    required name="IBar" actually ignored at runtime, other than to verify presence
    optional proxyStubClsid32="{}" defaults to iid
    optional tlbid="{}"
    optional numMethods="123"
    optional baseInterface="{}"
</comInterfaceExternalProxyStub>

*/

typedef struct _IID_ENTRY
{
    _IID_ENTRY() { }
    GUID m_clsid;
    GUID m_iid;
    ULONG m_nMethods;
    GUID m_tlbid;
    GUID m_iidBase;
    CStringBuffer m_buffName;
    bool m_fNumMethodsValid;
    bool m_fBaseInterfaceValid;

private:
    _IID_ENTRY(const _IID_ENTRY &);
    void operator =(const _IID_ENTRY &);
} IID_ENTRY, *PIID_ENTRY;

BOOL
SxspComInterfaceRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

VOID
__fastcall
SxspComInterfaceRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PGUID_SECTION_GENERATION_CONTEXT GSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(GSGenContext == NULL);

        // do everything if we are generating an activation context.
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        {
            IFW32FALSE_EXIT(
                ::SxsInitGuidSectionGenerationContext(
                    &GSGenContext,
                    ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FORMAT_WHISTLER,
                    &::SxspComInterfaceRedirectionGuidSectionGenerationCallback,
                    NULL));

            Data->Header.ActCtxGenContext = GSGenContext;
        }

        Data->GenBeginning.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (GSGenContext != NULL)
            ::SxsDestroyGuidSectionGenerationContext(GSGenContext);
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;

        if (GSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingGuidSectionGenerationContext(GSGenContext));

        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        // Someone shouldn't be asking for the section size if we
        // are not generating an activation context.
        // These two asserts should be equivalent...
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);

        IFW32FALSE_EXIT(
            ::SxsGetGuidSectionGenerationContextSectionSize(
                GSGenContext,
                &Data->GetSectionSize.SectionSize));

        Data->GetSectionSize.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        Data->ElementParsed.Success = FALSE;
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        {
            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssemblyInterface = 1,
                eAssemblyFileComClassInterface = 2,
            };

#define PATH_MAP_ENTRY(_depth, _string, _mv) { (_depth), _string, NUMBER_OF(_string) - 1, (_mv) },

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                PATH_MAP_ENTRY(2, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^comInterfaceExternalProxyStub", eAssemblyInterface)
                PATH_MAP_ENTRY(3, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comInterfaceProxyStub", eAssemblyFileComClassInterface)
            };

#undef PATH_MAP_ENTRY

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->ElementParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR_CHECK2(
                        FALSE,
                        "Invalid mapped value returned from SxspProcessElementPathMap");

                case eAssemblyInterface:
                    {
                        CStringBuffer TempBuffer;
                        GUID iid, tlbid, iidBase, clsid;
                        ULONG nMethods = 0;
                        SIZE_T cb;
                        bool fNumMethodsValid = false;
                        bool fBaseInterfaceValid = false;

                        fFound = false;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_iid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(iid),
                                &iid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_proxyStubClsid32,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(clsid),
                                &clsid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        if (!fFound)
                            clsid = iid;

                        IFW32FALSE_EXIT(::SxspGetAttributeValue(0, &s_AttributeName_numMethods, &Data->ElementParsed, fFound, sizeof(TempBuffer), &TempBuffer, cb, NULL, 0));
                        if (fFound)
                        {
                            IFW32FALSE_EXIT(CFusionParser::ParseULONG(nMethods, TempBuffer, TempBuffer.Cch()));
                            fNumMethodsValid = true;
                        }

                        tlbid = GUID_NULL;
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_tlbid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(tlbid),
                                &tlbid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_baseInterface,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(iidBase),
                                &iidBase,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));
                        if (fFound)
                            fBaseInterfaceValid = true;

                        TempBuffer.Clear();
                        IFW32FALSE_EXIT(::SxspGetAttributeValue(0, &s_AttributeName_name, &Data->ElementParsed, fFound, sizeof(TempBuffer), &TempBuffer, cb, NULL, 0));

                        // Do more work if generating an activation context.
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            CSmartPtr<IID_ENTRY> Entry;

                            IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                            Entry->m_clsid = clsid;
                            Entry->m_tlbid = tlbid;
                            Entry->m_iid = iid;
                            Entry->m_iidBase = iidBase;
                            Entry->m_nMethods = nMethods;
                            Entry->m_fNumMethodsValid = fNumMethodsValid;
                            Entry->m_fBaseInterfaceValid = fBaseInterfaceValid;
                            IFW32FALSE_EXIT(Entry->m_buffName.Win32Assign(TempBuffer));

                            IFW32FALSE_EXIT(
                                ::SxsAddGuidToGuidSectionGenerationContext(
                                    (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                                    &iid,
                                    Entry,
                                    Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                    ERROR_SXS_DUPLICATE_IID));

                            Entry.Detach();
                            
                        }

                        break;
                    }

                case eAssemblyFileComClassInterface:
                    {
                        CStringBuffer TempBuffer;
                        GUID iid, tlbid, iidBase;
                        ULONG nMethods = 0;
                        SIZE_T cb;
                        bool fNumMethodsValid = false;
                        bool fBaseInterfaceValid = false;

                        fFound = false;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_iid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(iid),
                                &iid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(::SxspGetAttributeValue(0, &s_AttributeName_numMethods, &Data->ElementParsed, fFound, sizeof(TempBuffer), &TempBuffer, cb, NULL, 0));
                        if (fFound)
                        {
                            IFW32FALSE_EXIT(CFusionParser::ParseULONG(nMethods, TempBuffer, TempBuffer.Cch()));
                            fNumMethodsValid = true;
                        }

                        tlbid = GUID_NULL;
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_tlbid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(tlbid),
                                &tlbid,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_baseInterface,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(iidBase),
                                &iidBase,
                                cb,
                                &::SxspValidateGuidAttribute,
                                0));
                        if (fFound)
                            fBaseInterfaceValid = true;


                        TempBuffer.Clear();
                        IFW32FALSE_EXIT(::SxspGetAttributeValue(0, &s_AttributeName_name, &Data->ElementParsed, fFound, sizeof(TempBuffer), &TempBuffer, cb, NULL, 0));

                        // Do more work if generating an activation context.
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            CSmartPtr<IID_ENTRY> Entry;

                            IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                            Entry->m_clsid = iid;
                            Entry->m_tlbid = tlbid;
                            Entry->m_iid = iid;
                            Entry->m_iidBase = iidBase;
                            Entry->m_nMethods = nMethods;
                            Entry->m_fNumMethodsValid = fNumMethodsValid;
                            Entry->m_fBaseInterfaceValid = fBaseInterfaceValid;
                            IFW32FALSE_EXIT(Entry->m_buffName.Win32Assign(TempBuffer));

                            IFW32FALSE_EXIT(
                                ::SxsAddGuidToGuidSectionGenerationContext(
                                    (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                                    &iid,
                                    Entry,
                                    Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                    ERROR_SXS_DUPLICATE_IID));

                            Entry.Detach();
                        }

                        break;
                    }
                }
            }
        }

        Data->ElementParsed.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;

        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);

        IFW32FALSE_EXIT(
            ::SxsGetGuidSectionGenerationContextSectionData(
                GSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));

        Data->GetSectionData.Success = TRUE;
        break;
    }
Exit:
    ;
}

BOOL
SxspComInterfaceRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    FN_PROLOG_WIN32

    switch (Reason)
    {
    default:
        break;

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData = (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            CSmartPtr<IID_ENTRY> Entry;
            FUSION_DELETE_SINGLETON((PIID_ENTRY)CBData->DataContext);
            
            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData = (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PIID_ENTRY Entry = (PIID_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION);

            if (Entry != NULL)
            {
                if (Entry->m_buffName.Cch() != 0)
                {
                    CBData->DataSize += ((Entry->m_buffName.Cch() + 1) * sizeof(WCHAR));
                }
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData = (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Info;
            PIID_ENTRY Entry = (PIID_ENTRY) CBData->DataContext;
            PWSTR Cursor;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            Info = (PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION) CBData->Buffer;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION);

            Cursor = (PWSTR) (Info + 1);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION);
            Info->Flags = 0;
            Info->ProxyStubClsid32 = Entry->m_clsid;

            if (Entry->m_fNumMethodsValid)
            {
                Info->Flags |= ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID;
                Info->NumMethods = Entry->m_nMethods;
            }
            else
                Info->NumMethods = 0;

            Info->TypeLibraryId = Entry->m_tlbid;

            if (Entry->m_fBaseInterfaceValid)
            {
                Info->Flags |= ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID;
                Info->BaseInterface = Entry->m_iidBase;
            }
            else
                Info->BaseInterface = GUID_NULL;

            IFW32FALSE_EXIT(
                Entry->m_buffName.Win32CopyIntoBuffer(
                    &Cursor,
                    &BytesLeft,
                    &BytesWritten,
                    Info,
                    &Info->NameOffset,
                    &Info->NameLength));

            CBData->BytesWritten = BytesWritten;
        }
    }


    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\componentpolicytable.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "componentpolicytable.h"

BOOL
CComponentPolicyTableHelper::HashKey(
    PCASSEMBLY_IDENTITY AssemblyIdentity,
    ULONG &rulPseudoKey
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(AssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxsHashAssemblyIdentity(0, AssemblyIdentity, &rulPseudoKey));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CComponentPolicyTableHelper::CompareKey(
    PCASSEMBLY_IDENTITY keyin,
    const PCASSEMBLY_IDENTITY &rkeystored,
    bool &rfMatch
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL fEqual = FALSE;

    rfMatch = false;

    PARAMETER_CHECK(keyin != NULL);
    PARAMETER_CHECK(rkeystored != NULL);

    IFW32FALSE_EXIT(::SxsAreAssemblyIdentitiesEqual(0, keyin, rkeystored, &fEqual));

    if (fEqual)
        rfMatch = true;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CComponentPolicyTableHelper::InitializeKey(
    PCASSEMBLY_IDENTITY keyin,
    PCASSEMBLY_IDENTITY &rkeystored
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;

    rkeystored = NULL;

    PARAMETER_CHECK(keyin != NULL);

    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE,
            keyin,
            &AssemblyIdentity));

    rkeystored = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;
Exit:
    if (AssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(AssemblyIdentity);

    return fSuccess;
}

BOOL
CComponentPolicyTableHelper::InitializeValue(
    CPolicyStatement *vin,
    CPolicyStatement *&rvstored
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(vin != NULL);
    INTERNAL_ERROR_CHECK(rvstored == NULL);

    rvstored = vin;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CComponentPolicyTableHelper::UpdateValue(
    CPolicyStatement *vin,
    CPolicyStatement *&rvstored
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (rvstored != NULL)
        FUSION_DELETE_SINGLETON(rvstored);

    rvstored = vin;

    fSuccess = TRUE;
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\comgoop.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    comgoop.cpp

Abstract:

    Wrapper to create the XML parser that emulates COM activation of the inproc server.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include <sxsp.h>
#include <ole2.h>
#include "xmlparser.hxx"

BOOL
SxspGetXMLParser(
    REFIID riid,
    PVOID *ppvObj
    )
{
    FN_PROLOG_WIN32

    // NTRAID#NTBUG9 - 569466 - 2002/04/25 - Smarter use of COM and the XML parser
    CSmartPtr<XMLParser> pXmlParser;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    PARAMETER_CHECK(ppvObj != NULL);

    IFW32FALSE_EXIT(pXmlParser.Win32Allocate(__FILE__, __LINE__));
    IFCOMFAILED_EXIT(pXmlParser->HrInitialize());
    IFCOMFAILED_EXIT(pXmlParser->QueryInterface(riid, ppvObj));
    pXmlParser.Detach();

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\comclsidmap.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "windows.h"
#include "sxsp.h"
#include "comclsidmap.h"
#include "sxsexceptionhandling.h"

#define CLASS_ID_MAPPINGS_SUBKEY_NAME L"ClassIdMappings\\"

CClsidMap::CClsidMap() :
    m_cLocalMappings(0),
    m_pLocalMappingListHead(NULL)
{
}

CClsidMap::~CClsidMap()
{
}

BOOL
CClsidMap::Initialize()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    fSuccess = TRUE;
// Exit:
    return fSuccess;
}

BOOL
CClsidMap::Uninitialize()
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    LocalMapping *pMapping = m_pLocalMappingListHead;

    while (pMapping != NULL)
    {
        LocalMapping *pNext = pMapping->m_pNext;
        FUSION_DELETE_SINGLETON(pMapping);
        pMapping = pNext;
    }

    fSuccess = TRUE;
//Exit:
    return fSuccess;
}

BOOL
CClsidMap::MapReferenceClsidToConfiguredClsid(
    const GUID *ReferenceClsid,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext,
    GUID *ConfiguredClsid,
    GUID *ImplementedClsid
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    LocalMapping * pMapping = NULL;

    // We're in the unnamed assembly - there can be at most one unnamed assembly, so this
    // must be the root assembly.  We'll look for it in our local map.  If it's not there,
    // we'll just generate a GUID and store it in the map.

    for (pMapping = m_pLocalMappingListHead; pMapping != NULL; pMapping = pMapping->m_pNext)
    {
        if (pMapping->m_ReferenceClsid == *ReferenceClsid)
            break;
    }

    // Not found; create one.
    if (pMapping == NULL)
    {
        CSmartPtr<LocalMapping> Mapping;
        IFW32FALSE_EXIT(Mapping.Win32Allocate(__FILE__, __LINE__));

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INFO, "SXS.DLL: Adding clsid local mapping %p\n", pMapping);
#endif
        Mapping->m_pNext = m_pLocalMappingListHead;
        Mapping->m_ReferenceClsid = *ReferenceClsid;
        Mapping->m_ImplementedClsid = *ReferenceClsid;

        // No ConfiguredClsid... we'll make one up.
        RPC_STATUS st = ::UuidCreate(&Mapping->m_ConfiguredClsid);
        RETAIL_UNUSED(st);
        SOFT_ASSERT((st == RPC_S_OK) ||
                    (st == RPC_S_UUID_LOCAL_ONLY) ||
                    (st == RPC_S_UUID_NO_ADDRESS));

        pMapping = m_pLocalMappingListHead = Mapping.Detach();
        m_cLocalMappings++;
    }

    ASSERT(pMapping != NULL);

    *ConfiguredClsid = pMapping->m_ConfiguredClsid;
    *ImplementedClsid = pMapping->m_ImplementedClsid;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\componentpolicytable.h ===
#if !defined(_FUSION_DLL_WHISTLER_COMPONENTPOLICYTABLE_H_INCLUDED_
#define _FUSION_DLL_WHISTLER_COMPONENTPOLICYTABLE_H_INCLUDED_

#pragma once

#include "fusionhash.h"
#include "policystatement.h"

class CComponentPolicyTableHelper
{
public:
    static BOOL HashKey(PCASSEMBLY_IDENTITY AssemblyIdentity, ULONG &rulPseudoKey);
    static BOOL CompareKey(PCASSEMBLY_IDENTITY keyin, const PCASSEMBLY_IDENTITY &rtkeystored, bool &rfMatch);
    static VOID PreInitializeKey(PCASSEMBLY_IDENTITY &rkey) { rkey = NULL; }
    static VOID PreInitializeValue(CPolicyStatement *&rp) { rp = NULL; }
    static BOOL InitializeKey(PCASSEMBLY_IDENTITY keyin, PCASSEMBLY_IDENTITY &rtkeystored);
    static BOOL InitializeValue(CPolicyStatement * vin, CPolicyStatement * &rvstored);
    static BOOL UpdateValue(CPolicyStatement * vin, CPolicyStatement * &rvstored);
    static VOID FinalizeKey(PCASSEMBLY_IDENTITY &rkeystored) { if (rkeystored != NULL) { ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(rkeystored)); rkeystored = NULL; } }
    static VOID FinalizeValue(CPolicyStatement *&rvstored) { if (rvstored != NULL) { FUSION_DELETE_SINGLETON(rvstored); rvstored = NULL; } }
};

typedef CHashTable<PCASSEMBLY_IDENTITY, PCASSEMBLY_IDENTITY, CPolicyStatement *, CPolicyStatement *, CComponentPolicyTableHelper> CComponentPolicyTable;

#endif // !defined(_FUSION_DLL_WHISTLER_COMPONENTPOLICYTABLE_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cstreamtap.h ===
#if !defined(_FUSION_SXS_CSTREAMTAP_H_INCLUDED_)
#define _FUSION_SXS_CSTREAMTAP_H_INCLUDED_

#pragma once

#include "fusionsha1.h"

class CTeeStreamWithHash : public CTeeStream
{
    CFusionHash m_hCryptHash;
    
    PRIVATIZE_COPY_CONSTRUCTORS(CTeeStreamWithHash);

public:
    CTeeStreamWithHash() { }
    virtual ~CTeeStreamWithHash() { }

    //
    // Actual things that do work
    //
    CFusionHash &GetCryptHash() { return m_hCryptHash; }
    BOOL InitCryptHash( ALG_ID aid ) { return m_hCryptHash.Win32Initialize(aid);}

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * pulMove );
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cresourcestream.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    cresourcestream.cpp

Abstract:

    Minimal implementation of IStream over a Windows PE/COFF resource.

Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#include "stdinc.h"
#include "cresourcestream.h"

static
BOOL
CALLBACK
EnumResourcesCallback(
    HMODULE    hModule,  // module handle
    PCWSTR     lpszType, // resource type
    PWSTR      lpszName, // resource name
    LONG_PTR   lParam    // application-defined parameter
    )
{
    PWSTR *pname = reinterpret_cast<PWSTR *>(lParam);
    if (*pname != NULL)
    {
        ::SetLastError(ERROR_ALREADY_INITIALIZED);
        return FALSE; // terminate the enum process
    }
    *pname = lpszName;

    // we would return FALSE here to stop enumerating, but
    // that causes an overall FALSE from the API (undocumented)
    return TRUE;
}

BOOL
CResourceStream::Initialize(
    PCWSTR file,
    PCWSTR type
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PWSTR name = NULL;
    BOOL fInitializedAlready;
    IFW32FALSE_EXIT(m_buffFilePath.Win32Assign(file, (file != NULL) ? ::wcslen(file) : 0));
    IFW32FALSE_EXIT(m_dll.Win32LoadLibrary(file, LOAD_LIBRARY_AS_DATAFILE));    
    IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS(
        ::EnumResourceNamesW(
            m_dll,
            type,
            &::EnumResourcesCallback,
            reinterpret_cast<LONG_PTR>(&name)),
            (::FusionpGetLastWin32Error() == ERROR_ALREADY_INITIALIZED),
            fInitializedAlready
            );
    IFW32FALSE_EXIT(this->InitializeAlreadyOpen(type, name));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CResourceStream::Initialize(
    PCWSTR file,
    PCWSTR type,
    PCWSTR name,
    WORD   language
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    IFW32FALSE_EXIT(m_buffFilePath.Win32Assign(file, (file != NULL) ? ::wcslen(file) : 0));
    IFW32FALSE_EXIT(m_dll.Win32LoadLibrary(file, LOAD_LIBRARY_AS_DATAFILE));
    IFW32FALSE_EXIT(this->InitializeAlreadyOpen(type, name, language));
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CResourceStream::InitializeAlreadyOpen(
    PCWSTR type,
    PCWSTR name,
    WORD   language
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    HRSRC resource;
    HGLOBAL global;
    const BYTE *pointer;
    DWORD size;

    IFW32NULL_EXIT(resource = ::FindResourceExW(m_dll, type, name, language));
    IFW32NULL_EXIT(global = ::LoadResource(m_dll, resource));
    IFW32NULL_EXIT(pointer = reinterpret_cast<const BYTE *>(::LockResource(global)));
    IFW32ZERO_EXIT(size = ::SizeofResource(m_dll, resource));
    IFW32FALSE_EXIT(Base::Initialize(pointer, pointer + size));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

HRESULT
CResourceStream::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);
    WIN32_FILE_ATTRIBUTE_DATA wfad;

    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(*pstatstg));

    PARAMETER_CHECK(((grfStatFlag & ~(STATFLAG_NONAME)) == 0));
    PARAMETER_CHECK(pstatstg != NULL);

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s() does not handle STATFLAG_NONE; returning E_NOTIMPL.\n", __FUNCTION__);
        hr = E_NOTIMPL;
        goto Exit;
    }

    IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileAttributesExW(m_buffFilePath, GetFileExInfoStandard, &wfad));

    pstatstg->pwcsName = NULL;
    pstatstg->type = STGTY_STREAM;
    INTERNAL_ERROR_CHECK(((ULONG_PTR) m_pbEnd) >= ((ULONG_PTR) m_pbBegin));
    pstatstg->cbSize.LowPart = (ULONG)(((ULONG_PTR) m_pbEnd) - ((ULONG_PTR) m_pbBegin));
    pstatstg->cbSize.HighPart = 0;
    pstatstg->mtime = wfad.ftLastWriteTime;
    pstatstg->ctime = wfad.ftCreationTime;
    pstatstg->atime = wfad.ftLastAccessTime;
    pstatstg->grfMode = STGM_READ | STGM_SHARE_DENY_WRITE;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = GUID_NULL;
    pstatstg->grfStateBits = 0;
    pstatstg->reserved = 0;

    hr = NOERROR;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\csecuritymetadata.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "fusionbuffer.h"
#include "fusionhash.h"
#include "csecuritymetadata.h"
#include "strongname.h"
#include "hashfile.h"

typedef CCaseInsensitiveSimpleUnicodeStringTableIter<CFusionByteArray, CFileHashTableHelper> CFileHashTableIter;

//
// We should try to remove this.
//
BOOL
CFileInformationTableHelper::UpdateValue(
    const CMetaDataFileElement &vin,
    CMetaDataFileElement &stored
)
{
    FN_PROLOG_WIN32
    ASSERT( FALSE );
    FN_EPILOG
}

CMetaDataFileElement::CMetaDataFileElement()
{
}

BOOL
CMetaDataFileElement::WriteToRegistry( CRegKey & hkThisFileNode ) const
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    const CFileHashTable &rfileHashTable = *this;
    CFileHashTableIter TableIterator( const_cast<CFileHashTable&>(rfileHashTable) );

    for ( TableIterator.Reset(); TableIterator.More(); TableIterator.Next() )
    {
        const PCWSTR &rcbuffAlgName = TableIterator.GetKey();
        const CFusionByteArray &rbbuffHashData = TableIterator.GetValue();

        IFW32FALSE_EXIT( hkThisFileNode.SetValue(
            rcbuffAlgName,
            REG_BINARY,
            rbbuffHashData.GetArrayPtr(),
            rbbuffHashData.GetSize() ) );
    }

    FN_EPILOG
}



BOOL
CMetaDataFileElement::ReadFromRegistry(
    CRegKey& hkThisFileNode
    )
{
    /*
        Here we take a few shortcuts.  We know there is a list of "valid" hash
        alg name strings, so we only query for them in the registry.  If anything
        else is in there, then too bad for them.
    */

    FN_PROLOG_WIN32

    DWORD dwIndex = 0;
    DWORD dwLastError = 0;
    CFusionByteArray baHashValue;
    CSmallStringBuffer buffHashAlgName;

    IFW32FALSE_EXIT(baHashValue.Win32Initialize());

    while ( true )
    {
        BOOL fNoMoreItems = FALSE;

        buffHashAlgName.Clear();

        IFW32FALSE_EXIT( ::SxspEnumKnownHashTypes( dwIndex++, buffHashAlgName, fNoMoreItems ) );

        //
        // There's no more hash types to be enumerated...
        //
        if (fNoMoreItems)
            break;

        //
        // Get the hash data out of the registry
        //
        IFW32FALSE_EXIT(
            ::FusionpRegQueryBinaryValueEx(
                FUSIONP_REG_QUERY_BINARY_NO_FAIL_IF_NON_BINARY,
                hkThisFileNode,
                buffHashAlgName,
                baHashValue,
                dwLastError,
                2,
                ERROR_PATH_NOT_FOUND,
                ERROR_FILE_NOT_FOUND));

        //
        // ISSUE: jonwis 3/12/2002 - Someone could put non-binary data here in the registry
        //          and so we'll fail when we try to compare the hash against what's on the
        //          filesystem.  This isn't necessarily bad, since we do compare binary-wise,
        //          but maybe we should validate here to ensure that the type is binary, and
        //          not add the hash data if it isn't.
        //
        if (dwLastError == ERROR_SUCCESS)
            IFW32FALSE_EXIT(this->PutHashData(buffHashAlgName, baHashValue));
    }

    FN_EPILOG
}


BOOL
CMetaDataFileElement::Initialize()
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT( CFileHashTable::Initialize() );
    FN_EPILOG
}

BOOL
CMetaDataFileElement::GetHashDataForKind(
    IN const ALG_ID aid,
    OUT CFusionByteArray& arrHashData,
    OUT BOOL &rfHadSuchData
) const
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffAlgName;

    IFW32FALSE_EXIT( ::SxspHashStringFromAlg(aid, buffAlgName) );
    IFW32FALSE_EXIT( this->GetHashDataForKind( buffAlgName, arrHashData, rfHadSuchData ) );

    FN_EPILOG
}

BOOL
CMetaDataFileElement::GetHashDataForKind(
    IN const CBaseStringBuffer& buffId,
    OUT CFusionByteArray& arrHashData,
    OUT BOOL &rfHadSuchData
) const
{
    // NTRAID#NTBUG9 - 556341 - jonwis - 2002/4/25 - Always set the output param
    FN_PROLOG_WIN32

    CFusionByteArray *pFoundData = NULL;

    rfHadSuchData = FALSE;

    IFW32FALSE_EXIT( arrHashData.Win32Reset() );

    IFW32FALSE_EXIT( this->Find( buffId, pFoundData ) );

    if ( pFoundData != NULL )
    {
        IFW32FALSE_EXIT(pFoundData->Win32Clone(arrHashData));
        rfHadSuchData = TRUE;
    }

    FN_EPILOG
}


BOOL
CMetaDataFileElement::PutHashData(
    IN const ALG_ID aid,
    IN const CFusionByteArray& arrHashData
)
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffTempAlgId;

    IFW32FALSE_EXIT( ::SxspHashStringFromAlg( aid, buffTempAlgId ) );
    IFW32FALSE_EXIT( this->PutHashData( buffTempAlgId, arrHashData ) );

    FN_EPILOG
}

BOOL
CMetaDataFileElement::PutHashData(
    IN const CBaseStringBuffer& buffId,
    IN const CFusionByteArray& arrHashData
)
{
    FN_PROLOG_WIN32

    CFusionByteArray *pStoredValue = NULL;
    BOOL bFound = FALSE;

    IFW32FALSE_EXIT( this->FindOrInsertIfNotPresent(
        buffId,
        arrHashData,
        &pStoredValue,
        &bFound ) );

    if ( bFound )
    {
        ASSERT( pStoredValue != NULL );
        IFW32FALSE_EXIT(arrHashData.Win32Clone(*pStoredValue));
    }

    FN_EPILOG
}




BOOL
CSecurityMetaData::GetFileMetaData(
    const CBaseStringBuffer& buffFileName,
    const CMetaDataFileElement* &pElementData
) const
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT( m_fitFileDataTable.Find(buffFileName, pElementData) );
    FN_EPILOG
}



BOOL
CSecurityMetaData::Initialize()
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(m_cilCodebases.Win32Initialize());
    IFW32FALSE_EXIT(m_baSignerPublicKeyToken.Win32Initialize());
    IFW32FALSE_EXIT(m_baManifestSha1Hash.Win32Initialize());
    IFW32FALSE_EXIT(m_fitFileDataTable.Initialize());
    m_buffShortNameOnDisk.Clear();
    m_buffShortCatalogName.Clear();
    m_buffShortManifestName.Clear();

    FN_EPILOG
}


BOOL
CSecurityMetaData::Initialize(
    const CSecurityMetaData &other
)
{
    FN_PROLOG_WIN32

    //
    // ISSUE: jonwis 3/12/2002 - Ick.  Use 'Win32Assign' to assign from one string to another... Don't
    //          bother doing the cast operator and calling Cch!
    // - PS: This style of doing copying is gross... either make it so that it only takes the
    //          name of the thing to copy, or do the verbose thing of IFW32FALSE_EXIT(...).
    //
#define CLONEFUSIONARRAY( src, dst )  IFW32FALSE_EXIT( (src).Win32Clone(  dst ) )
#define CLONESTRING( dst, src ) IFW32FALSE_EXIT( (dst).Win32Assign( (src), (src).Cch() ) )

    IFW32FALSE_EXIT( this->Initialize() );

    CLONEFUSIONARRAY(other.m_cilCodebases, this->m_cilCodebases);
    CLONEFUSIONARRAY(other.m_baSignerPublicKeyToken, this->m_baSignerPublicKeyToken);
    CLONEFUSIONARRAY(other.m_baManifestSha1Hash, this->m_baManifestSha1Hash);

    CLONESTRING(this->m_buffShortNameOnDisk, other.m_buffShortNameOnDisk);
    CLONESTRING(this->m_buffTextualAssemblyIdentity, other.m_buffTextualAssemblyIdentity);
    CLONESTRING(this->m_buffShortManifestName, other.m_buffShortManifestName);
    CLONESTRING(this->m_buffShortCatalogName, other.m_buffShortCatalogName);

    //
    // Copy file information table over
    //
    {
        CFileInformationTableIter Iter(const_cast<CFileInformationTable&>(other.m_fitFileDataTable));

        for (Iter.Reset(); Iter.More(); Iter.Next())
            IFW32FALSE_EXIT( this->m_fitFileDataTable.Insert( Iter.GetKey(), Iter.GetValue() ) );
    }

    FN_EPILOG
}



BOOL
CSecurityMetaData::AddFileMetaData(
    const CBaseStringBuffer &rbuffFileName,
    CMetaDataFileElement &rElementData,
    CSecurityMetaData::FileAdditionDisposition dispHowToAdd
)
{
    FN_PROLOG_WIN32

    if (dispHowToAdd == CSecurityMetaData::eFailIfAlreadyExists)
    {
        IFW32FALSE_EXIT(m_fitFileDataTable.Insert(rbuffFileName, rElementData));
    }
    else if (dispHowToAdd == CSecurityMetaData::eReplaceIfAlreadyExists)
    {
        bool fAlreadyExists = false;
        IFW32FALSE_EXIT_UNLESS(
            m_fitFileDataTable.Insert(rbuffFileName, rElementData),
            (::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS),
            fAlreadyExists);

        if (fAlreadyExists)
        {
            IFW32FALSE_EXIT(m_fitFileDataTable.Remove(rbuffFileName));
            IFW32FALSE_EXIT(m_fitFileDataTable.Insert(rbuffFileName, rElementData));
        }
    }
    else if (dispHowToAdd == CSecurityMetaData::eMergeIfAlreadyExists)
    {
        IFW32FALSE_EXIT(
            m_fitFileDataTable.InsertOrUpdateIf<CSecurityMetaData>(
                rbuffFileName,
                rElementData,
                this,
                &CSecurityMetaData::MergeFileDataElement));
    }

    FN_EPILOG
}

BOOL
CSecurityMetaData::SetSignerPublicKeyTokenBits(
    const CFusionByteArray & rcbuffSignerPublicKeyBits
    )
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT(rcbuffSignerPublicKeyBits.Win32Clone(this->m_baSignerPublicKeyToken));
    FN_EPILOG
}


//
// ISSUE: jonwis 3/12/2002 - Performance here sucks.  We should look in the file table and get
//          the one that's already present rather than doing a merge... Mostly we're wasting stack,
//          but I'm sure we'd gain something in perf as well.
//
BOOL
CSecurityMetaData::QuickAddFileHash(
    const CBaseStringBuffer &rcbuffFileName,
    ALG_ID aidHashAlg,
    const CBaseStringBuffer &rcbuffHashValue
    )
{
    FN_PROLOG_WIN32

    CMetaDataFileElement Element;
    CFusionByteArray baHashBytes;

    //
    // Build the element
    //
    IFW32FALSE_EXIT(Element.Initialize());
    IFW32FALSE_EXIT(::SxspHashStringToBytes(rcbuffHashValue, rcbuffHashValue.Cch(), baHashBytes));
    IFW32FALSE_EXIT(Element.PutHashData(aidHashAlg, baHashBytes));

    //
    // And merge it in
    //

    IFW32FALSE_EXIT(
        this->AddFileMetaData(
            rcbuffFileName,
            Element,
            eMergeIfAlreadyExists));

    FN_EPILOG
}

BOOL
CSecurityMetaData::WritePrimaryAssemblyInfoIntoRegistryKey(
    ULONG         Flags,
    const CRegKey &rhkRegistryNode
    ) const
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    //
    // ISSUE: jonwis 3/12/2002 - Consider moving hkCodebases into the scope in which
    //          it belongs, and putting the FusionDbgPrintEx's under DBG.
    //
    CRegKey hkFilesKey;
    CRegKey hkCodebases;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS: %s - starting\n",
        __FUNCTION__);

    PARAMETER_CHECK((Flags & ~(SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_INTO_REGISTRY_KEY_FLAG_REFRESH)) == 0);

    IFW32FALSE_EXIT(
        rhkRegistryNode.SetValue(
            CSMD_TOPLEVEL_IDENTITY,
            this->GetTextualIdentity()));

    IFW32FALSE_EXIT( rhkRegistryNode.SetValue(
        CSMD_TOPLEVEL_CATALOG,
        static_cast<DWORD>(1)));

    IFW32FALSE_EXIT( rhkRegistryNode.SetValue(
        CSMD_TOPLEVEL_MANIFESTHASH,
        REG_BINARY,
        this->m_baManifestSha1Hash.GetArrayPtr(),
        this->m_baManifestSha1Hash.GetSize() ) );

    IFW32FALSE_EXIT(
        rhkRegistryNode.OpenOrCreateSubKey(
            hkFilesKey,
            CSMD_TOPLEVEL_FILES,
            KEY_WRITE));

    IFW32FALSE_EXIT(this->WriteFilesIntoKey(hkFilesKey));


    //
    // Write keys into this codebase node
    //
    if ((Flags & SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_INTO_REGISTRY_KEY_FLAG_REFRESH) == 0)
    {
        IFW32FALSE_EXIT(
            rhkRegistryNode.OpenOrCreateSubKey(
                hkCodebases,
                CSMD_TOPLEVEL_CODEBASES,
                KEY_WRITE));

        for (ULONG ulI = 0; ulI < this->m_cilCodebases.GetSize(); ulI++)
        {
            CRegKey hkSingleCodebaseKey;
            const CCodebaseInformation &rcCodebase = m_cilCodebases[ulI];

            // Don't attempt to write blank (Darwin) referenced codebases to the
            // registry.
            if ( rcCodebase.GetReference().Cch() == 0 )
                continue;

            IFW32FALSE_EXIT(
                hkCodebases.OpenOrCreateSubKey(
                    hkSingleCodebaseKey,
                    rcCodebase.GetReference(),
                    KEY_WRITE));

            IFW32FALSE_EXIT(rcCodebase.WriteToRegistryKey(hkSingleCodebaseKey));
        }
    }
#if DBG
    else
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - recovery, not writing codebase and codebase prompt\n",
            __FUNCTION__);
    }
#endif

    FN_EPILOG
}

BOOL
CSecurityMetaData::WriteSecondaryAssemblyInfoIntoRegistryKey(
    const CRegKey &rhkRegistryNode
    ) const
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(rhkRegistryNode.SetValue(CSMD_TOPLEVEL_SHORTNAME, this->GetInstalledDirShortName()));
    IFW32FALSE_EXIT(rhkRegistryNode.SetValue(CSMD_TOPLEVEL_SHORTCATALOG, this->GetShortCatalogPath()));
    IFW32FALSE_EXIT(rhkRegistryNode.SetValue(CSMD_TOPLEVEL_SHORTMANIFEST, this->GetShortManifestPath()));
    IFW32FALSE_EXIT(
        rhkRegistryNode.SetValue(
            CSMD_TOPLEVEL_PUBLIC_KEY_TOKEN,
            REG_BINARY,
            this->m_baSignerPublicKeyToken.GetArrayPtr(),
            this->m_baSignerPublicKeyToken.GetSize()));

    FN_EPILOG
}

BOOL
CSecurityMetaData::WriteFilesIntoKey(
    CRegKey & rhkFilesKey
    ) const
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    CFileInformationTableIter FilesIterator( const_cast<CFileInformationTable&>(m_fitFileDataTable) );
    ULONG uliIndex = 0;

    for ( FilesIterator.Reset(); FilesIterator.More(); FilesIterator.Next() )
    {
        const PCWSTR pcwszFileName = FilesIterator.GetKey();
        const CMetaDataFileElement& rcmdfeFileData = FilesIterator.GetValue();
        CRegKey hkFileSubKey;
        CSmallStringBuffer buffKeySubname;

        //
        // The trick here is that you can't simply create the subkey off this node,
        // as it might be "foo\bar\bas\zip.ding".
        //
        IFW32FALSE_EXIT( buffKeySubname.Win32Format( L"%ld", uliIndex++ ) );
        IFW32FALSE_EXIT( rhkFilesKey.OpenOrCreateSubKey(
            hkFileSubKey,
            buffKeySubname,
            KEY_ALL_ACCESS ) );

        //
        // So instead, we set the default value of the key to be the name of the file.
        //
        IFW32FALSE_EXIT( buffKeySubname.Win32Assign( pcwszFileName, lstrlenW(pcwszFileName) ) );
        IFW32FALSE_EXIT( hkFileSubKey.SetValue(
            NULL,
            buffKeySubname ) );

        IFW32FALSE_EXIT( rcmdfeFileData.WriteToRegistry( hkFileSubKey ) );
    }

    FN_EPILOG
}



/*
[name of full assembly]
    v : Codebase = [meta-url] <string>
    v : Catalog = 1 <dword>
    v : Shortname = [shortname generated during installation] <string>
    v : ManifestHash = [...] <binary>
    v : PublicKeyToken = [...] <binary>
    k : Files
            k : [Filename]
                    v : SHA1 = [...] <binary>
                    v : MD5 = [...] <binary>
            k : [Filename]
            ...
    k : Codebases
            k : [reference-string]
                    v : PromptString = [...] <string>
                    v : Url = [meta-url] <string>
*/

BOOL
CSecurityMetaData::LoadFromRegistryKey(
    const CRegKey &rhkRegistryNode
)
{
    FN_PROLOG_WIN32

    CRegKey hkTempStuff;
    DWORD dwHasCatalog = 0;

    IFW32FALSE_EXIT(
        ::FusionpRegQueryDwordValueEx(
            0,
            rhkRegistryNode,
            CSMD_TOPLEVEL_CATALOG,
            &dwHasCatalog,
            0));

    // NTRAID#NTBUG9 - 556327 - jonwis - 2002/04/25 - Remove this assert, make it deal better with zero values
    ASSERT(dwHasCatalog != 0);

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkRegistryNode,
            CSMD_TOPLEVEL_IDENTITY,
            this->m_buffTextualAssemblyIdentity));

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkRegistryNode,
            CSMD_TOPLEVEL_SHORTNAME,
            this->m_buffShortNameOnDisk));

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkRegistryNode,
            CSMD_TOPLEVEL_SHORTCATALOG,
            this->m_buffShortCatalogName));

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkRegistryNode,
            CSMD_TOPLEVEL_SHORTMANIFEST,
            this->m_buffShortManifestName));

    IFW32FALSE_EXIT(
        ::FusionpRegQueryBinaryValueEx(
            0,
            rhkRegistryNode,
            CSMD_TOPLEVEL_MANIFESTHASH,
            this->m_baManifestSha1Hash));

    IFW32FALSE_EXIT(
        ::FusionpRegQueryBinaryValueEx(
            0,
            rhkRegistryNode,
            CSMD_TOPLEVEL_PUBLIC_KEY_TOKEN,
            this->m_baSignerPublicKeyToken));

    IFW32FALSE_EXIT(rhkRegistryNode.OpenSubKey(hkTempStuff, CSMD_TOPLEVEL_CODEBASES, KEY_READ));

    if (hkTempStuff != CRegKey::GetInvalidValue())
    {
        IFW32FALSE_EXIT(this->LoadCodebasesFromKey(hkTempStuff));
        IFW32FALSE_EXIT(hkTempStuff.Win32Close());
    }

    IFW32FALSE_EXIT( rhkRegistryNode.OpenSubKey(hkTempStuff, CSMD_TOPLEVEL_FILES, KEY_READ));

    if (hkTempStuff != CRegKey::GetInvalidValue())
    {
        IFW32FALSE_EXIT(this->LoadFilesFromKey(hkTempStuff));
        IFW32FALSE_EXIT(hkTempStuff.Win32Close());
    }

    FN_EPILOG
}



BOOL
CSecurityMetaData::LoadFilesFromKey(
    CRegKey &hkTopLevelFileKey
    )
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffNextKeyName;
    DWORD dwIndex = 0;

    while ( true )
    {
        BOOL fNoMoreItems = FALSE;
        CRegKey hkIterator;

        buffNextKeyName.Clear();

        IFW32FALSE_EXIT(hkTopLevelFileKey.EnumKey(
            dwIndex++,
            buffNextKeyName,
            NULL,
            &fNoMoreItems ) );

        if ( fNoMoreItems )
        {
            break;
        }

        IFW32FALSE_EXIT( hkTopLevelFileKey.OpenSubKey(
            hkIterator,
            buffNextKeyName,
            KEY_READ ) );

        if ( hkIterator != CRegKey::GetInvalidValue() )
        {
            CMetaDataFileElement SingleFileElement;
            IFW32FALSE_EXIT( SingleFileElement.Initialize() );
            IFW32FALSE_EXIT( SingleFileElement.ReadFromRegistry( hkIterator ) );

            //
            // Now read the name of the file from the default
            //
            IFW32FALSE_EXIT(
                ::FusionpRegQuerySzValueEx(
                    0,
                    hkIterator,
                    NULL,
                    buffNextKeyName));

            IFW32FALSE_EXIT(this->AddFileMetaData( buffNextKeyName, SingleFileElement));
        }
    }

    FN_EPILOG
}

class CSecurityMetaDataLoadCodebasesFromKeyLocals
{
public:
    CStringBuffer buffKeyNameTemp;
    CCodebaseInformation Codebase;
};

BOOL
CSecurityMetaData::LoadCodebasesFromKey(
    IN CRegKey& hkCodebaseSubkey
    )
{
    FN_PROLOG_WIN32

    DWORD dwMaxKeyLength = 0;
    DWORD dwNextIndex = 0;

    CSmartPtr<CSecurityMetaDataLoadCodebasesFromKeyLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));

    CStringBuffer &buffKeyNameTemp = Locals->buffKeyNameTemp;

    //
    // Find out how big the largest subkey string is, then reset our iterator temp
    // to be that big.
    //
    IFW32FALSE_EXIT(hkCodebaseSubkey.LargestSubItemLengths(&dwMaxKeyLength, NULL));
    IFW32FALSE_EXIT(buffKeyNameTemp.Win32ResizeBuffer(dwMaxKeyLength + 1, eDoNotPreserveBufferContents));

    //
    // Codebases are stored as subkeys and then values under them.
    //
    for (;;)
    {
        BOOL fNoMoreItems = FALSE;

        IFW32FALSE_EXIT(
            hkCodebaseSubkey.EnumKey(
                dwNextIndex++,
                buffKeyNameTemp,
                NULL,
                &fNoMoreItems));

        if (fNoMoreItems)
            break;

        CRegKey hkSingleCodebaseKey;

        IFW32FALSE_EXIT(
            hkCodebaseSubkey.OpenSubKey(
                hkSingleCodebaseKey,
                buffKeyNameTemp,
                KEY_READ));

        if (hkSingleCodebaseKey == CRegKey::GetInvalidValue())
            continue;

        CCodebaseInformation &Codebase = Locals->Codebase;

        IFW32FALSE_EXIT(Codebase.Initialize());
        IFW32FALSE_EXIT(Codebase.SetReference(buffKeyNameTemp));
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s - read codebase %ls %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffKeyNameTemp),
            static_cast<PCWSTR>(Codebase.GetCodebase())
            );
#endif
        IFW32FALSE_EXIT(Codebase.ReadFromRegistryKey(hkSingleCodebaseKey));
        IFW32FALSE_EXIT(this->m_cilCodebases.Win32Append(Codebase));
    }

    FN_EPILOG
}


BOOL
CMetaDataFileElement::Initialize(
    const CMetaDataFileElement &other
    )
{
    FN_PROLOG_WIN32

    // The lack of a const iterator here is disturbing, so I have to const_cast
    // the metadatafileelement
    CFileHashTableIter InputTableIter( const_cast<CMetaDataFileElement&>(other) );

    //
    // Why is this not a bool??
    //
    this->ClearNoCallback();

    for(InputTableIter.Reset(); InputTableIter.More(); InputTableIter.Next())
    {
        IFW32FALSE_EXIT( this->Insert( InputTableIter.GetKey(), InputTableIter.GetValue() ) );
    }

    FN_EPILOG
}

BOOL
CCodebaseInformation::Initialize()
{
    this->m_Codebase.Clear();
    this->m_PromptText.Clear();
    this->m_Reference.Clear();
    this->m_Type = CODEBASE_RESOLVED_URLHEAD_UNKNOWN;
    return TRUE;
}

BOOL
CCodebaseInformation::Initialize(
    const CCodebaseInformation &other
    )
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(this->SetCodebase(other.GetCodebase()));
    IFW32FALSE_EXIT(this->SetPromptText(other.GetPromptText()));
    IFW32FALSE_EXIT(this->SetReference(other.GetReference()));
    this->m_Type = other.m_Type;

    FN_EPILOG
}

BOOL
CCodebaseInformation::WriteToRegistryKey(
    const CRegKey &rhkCodebaseKey
    ) const
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    if (m_PromptText.Cch() != 0)
    {
        IFW32FALSE_EXIT(
            rhkCodebaseKey.SetValue(
                CSMD_CODEBASES_PROMPTSTRING,
                this->m_PromptText));
    }

    IFW32FALSE_EXIT(
        rhkCodebaseKey.SetValue(
            CSMD_CODEBASES_URL,
            this->m_Codebase));

    FN_EPILOG
}


BOOL
CCodebaseInformation::ReadFromRegistryKey(
    const CRegKey &rhkSingleCodebaseKey
    )
{
    FN_PROLOG_WIN32

    //
    // Missing prompt is OK
    //
    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkSingleCodebaseKey,
            CSMD_CODEBASES_PROMPTSTRING,
            m_PromptText));

    //
    // We don't want to fail just because someone messed up the registry...
    //
    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkSingleCodebaseKey,
            CSMD_CODEBASES_URL,
            m_Codebase));

    FN_EPILOG
}

BOOL
CCodebaseInformationList::FindCodebase(
    const CBaseStringBuffer &rbuffReference,
    CCodebaseInformation *&rpCodebaseInformation
    )
{
    FN_PROLOG_WIN32
    bool fMatches = false;
    SIZE_T i = 0;

    rpCodebaseInformation = NULL;

    for (i=0; i < m_cElements; i++)
    {
        IFW32FALSE_EXIT(m_prgtElements[i].GetReference().Win32Equals(rbuffReference, fMatches, true));
        if (fMatches)
            break;
    }

    if (fMatches)
    {
        INTERNAL_ERROR_CHECK(i < m_cElements);
        rpCodebaseInformation = &m_prgtElements[i];
    }

    FN_EPILOG
}

BOOL
CCodebaseInformationList::RemoveCodebase(
    const CBaseStringBuffer &rbuffReference,
    bool &rfRemoved
    )
{
    FN_PROLOG_WIN32
    bool fMatches = false;
    SIZE_T i = 0;

    rfRemoved = false;

    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    for (i=0; i < m_cElements; i++)
    {
        IFW32FALSE_EXIT(m_prgtElements[i].GetReference().Win32Equals(rbuffReference, fMatches, true));
        if (fMatches)
        {
            IFW32FALSE_EXIT(this->Win32Remove(i));
            rfRemoved = true;
            break;
        }
    }

    FN_EPILOG
}

BOOL
SxspValidateAllFileHashes(
    IN const CMetaDataFileElement &rmdfeElement,
    IN const CBaseStringBuffer &rbuffFileName,
    OUT HashValidateResult &rResult
    )
{
    FN_PROLOG_WIN32

    DWORD dwIndex = 0;
    CSmallStringBuffer buffHashName;
    BOOL fAllHashesMatch = TRUE;
    CFusionByteArray baFileHashData;

    rResult = HashValidate_OtherProblems;

    while ( true && fAllHashesMatch )
    {
        BOOL fTemp;
        ALG_ID aid = 0;
        HashValidateResult Results = HashValidate_OtherProblems;

        IFW32FALSE_EXIT(
            ::SxspEnumKnownHashTypes(
                dwIndex++,
                buffHashName,
                fTemp));

        if (fTemp)
            break;

        IFW32FALSE_EXIT( SxspHashAlgFromString( buffHashName, aid ) );

        //
        // Did the file element have this type of hash data in it?
        //
        IFW32FALSE_EXIT( rmdfeElement.GetHashDataForKind(
            buffHashName,
            baFileHashData,
            fTemp ));

        if ( !fTemp )
        {
            continue;
        }

        IFW32FALSE_EXIT( ::SxspVerifyFileHash(
            SVFH_RETRY_LOGIC_SIMPLE,
            rbuffFileName,
            baFileHashData,
            aid,
            Results ) );

        if ( Results != HashValidate_Matches )
        {
            fAllHashesMatch = FALSE;
        }

    }

    if ( fAllHashesMatch )
    {
        rResult = HashValidate_Matches;
    }

    FN_EPILOG
}

BOOL
CSecurityMetaData::RemoveCodebase(
    const CBaseStringBuffer &rbuffReference,
    bool &rfRemoved
    )
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    return m_cilCodebases.RemoveCodebase(rbuffReference, rfRemoved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\comprogid.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    comprogid.cpp

Abstract:

    Activation context section contributor for COM progid mapping.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(progid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(id);

#define STRING_COMMA_AND_LENGTH(x) (x), NUMBER_OF(x)-1

BOOL
SxspComProgIdRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

typedef struct _COM_PROGID_GLOBAL_CONTEXT *PCOM_PROGID_GLOBAL_CONTEXT;
typedef struct _COM_PROGID_SERVER_CONTEXT *PCOM_PROGID_SERVER_CONTEXT;

typedef struct _COM_PROGID_SERVER_CONTEXT
{
    CDequeLinkage m_Linkage;
    GUID m_ConfiguredClsid;
    LONG m_Offset; // offset from section global data - populated during section generation
} COM_PROGID_SERVER_CONTEXT;

typedef CDeque<COM_PROGID_SERVER_CONTEXT, offsetof(COM_PROGID_SERVER_CONTEXT, m_Linkage)> CComProgIdServerDeque;
typedef CDequeIterator<COM_PROGID_SERVER_CONTEXT, offsetof(COM_PROGID_SERVER_CONTEXT, m_Linkage)> CComProgIdServerDequeIterator;

typedef struct _COM_PROGID_GLOBAL_CONTEXT
{
    // Temporary holding buffer for the configured CLSID until the first COM progid entry is
    // found, at which time a COM_PROGID_SERVER_CONTEXT is allocated and the clsid moved to it.
    GUID m_ConfiguredClsid;
    CComProgIdServerDeque m_ServerContextList;

} COM_PROGID_GLOBAL_CONTEXT;

VOID
__fastcall
SxspComProgIdRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PSTRING_SECTION_GENERATION_CONTEXT SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    CSmartPtr<COM_PROGID_GLOBAL_CONTEXT> ComGlobalContext;

    if (SSGenContext != NULL)
        ComGlobalContext.AttachNoDelete((PCOM_PROGID_GLOBAL_CONTEXT) ::SxsGetStringSectionGenerationContextCallbackContext(SSGenContext));

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(ComGlobalContext == NULL);
        INTERNAL_ERROR_CHECK(SSGenContext == NULL);

        IFW32FALSE_EXIT(ComGlobalContext.Win32Allocate(__FILE__, __LINE__));

        ComGlobalContext->m_ConfiguredClsid = GUID_NULL;

        IFW32FALSE_EXIT(
            ::SxsInitStringSectionGenerationContext(
                &SSGenContext,
                ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION_FORMAT_WHISTLER,
                TRUE,
                &::SxspComProgIdRedirectionStringSectionGenerationCallback,
                ComGlobalContext));

        ComGlobalContext.Detach();

        Data->Header.ActCtxGenContext = SSGenContext;
        Data->GenBeginning.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:

        ::SxsDestroyStringSectionGenerationContext(SSGenContext);

        if (ComGlobalContext != NULL)
        {
            ComGlobalContext->m_ServerContextList.ClearAndDeleteAll();
            FUSION_DELETE_SINGLETON(ComGlobalContext.Detach());
        }
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;
        if (SSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingStringSectionGenerationContext(SSGenContext));
        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_PCDATAPARSED:
        {
            Data->PCDATAParsed.Success = FALSE;

            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssemblyFileComclassProgid = 1,
            };

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                { 4, STRING_COMMA_AND_LENGTH(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comClass!urn:schemas-microsoft-com:asm.v1^progid"), eAssemblyFileComclassProgid },
                { 3, STRING_COMMA_AND_LENGTH(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrClass!urn:schemas-microsoft-com:asm.v1^progid"), eAssemblyFileComclassProgid },
            };

            INTERNAL_ERROR_CHECK(SSGenContext != NULL);

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->PCDATAParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));;

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR2_ACTION(MappedValue, "Invalid mapped value returned from SxspProcessElementPathMap()");

                case eAssemblyFileComclassProgid:
                    {
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            CComProgIdServerDequeIterator Iterator;
                            PCOM_PROGID_SERVER_CONTEXT ServerContext = NULL;
                            INTERNAL_ERROR_CHECK(ComGlobalContext != NULL);

                            Iterator.Rebind(&ComGlobalContext->m_ServerContextList);
                            Iterator.Reset();
                            ServerContext = Iterator;

                            INTERNAL_ERROR_CHECK(ServerContext != NULL);
                            IFW32FALSE_EXIT(
                                ::SxsAddStringToStringSectionGenerationContext(
                                    (PSTRING_SECTION_GENERATION_CONTEXT) Data->PCDATAParsed.Header.ActCtxGenContext,
                                    Data->PCDATAParsed.Text,
                                    Data->PCDATAParsed.TextCch,
                                    ServerContext,
                                    Data->PCDATAParsed.AssemblyContext->AssemblyRosterIndex,
                                    ERROR_SXS_DUPLICATE_PROGID));
                        }

                        break;
                    }
                }
            }

            Data->PCDATAParsed.Success = TRUE;

            break;
        }

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        {
            Data->ElementParsed.Success = FALSE;

            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssemblyFileComclass = 1,
            };

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                { 3, STRING_COMMA_AND_LENGTH(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^comClass"), eAssemblyFileComclass },
                { 2, STRING_COMMA_AND_LENGTH(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrClass"), eAssemblyFileComclass },
            };

            INTERNAL_ERROR_CHECK(SSGenContext != NULL);

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->ElementParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR2_ACTION(MappedValue, "Invalid mapped value returned from SxspProcessElementPathMap()");

                case eAssemblyFileComclass:
                    {
                        bool fProgIdFound = false;
                        SIZE_T cb = 0;
                        CSmallStringBuffer VersionIndependentComClassIdBuffer;
                        CSmallStringBuffer ProgIdBuffer;
                        GUID ReferenceClsid, ConfiguredClsid, ImplementedClsid;

                        INTERNAL_ERROR_CHECK(ComGlobalContext != NULL);

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_clsid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(VersionIndependentComClassIdBuffer),
                                &VersionIndependentComClassIdBuffer,
                                cb,
                                NULL,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(
                            ::SxspParseGUID(
                                VersionIndependentComClassIdBuffer,
                                VersionIndependentComClassIdBuffer.Cch(),
                                ReferenceClsid));

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_progid,
                                &Data->ElementParsed,
                                fProgIdFound,
                                sizeof(ProgIdBuffer),
                                &ProgIdBuffer,
                                cb,
                                NULL,
                                0));

                        //
                        // Always create a file context for this file, whether or not we end up with
                        // any progids.
                        //
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            CSmartPtr<COM_PROGID_SERVER_CONTEXT> ServerContext;
                            IFW32FALSE_EXIT(Data->Header.ClsidMappingContext->Map->MapReferenceClsidToConfiguredClsid(
                                        &ReferenceClsid,
                                        Data->ElementParsed.AssemblyContext,
                                        &ConfiguredClsid,
                                        &ImplementedClsid));

                            //
                            // Allocate new, set configured CLSID, and add it to the global list
                            //
                            IFW32FALSE_EXIT(ServerContext.Win32Allocate(__FILE__, __LINE__));

                            ServerContext->m_ConfiguredClsid = ConfiguredClsid;
                            ServerContext->m_Offset = 0;
                            ComGlobalContext->m_ServerContextList.AddToHead(ServerContext.DetachAndHold());

                            // Now, if we found a progid attribute, add it to the ss genctx
                            if (fProgIdFound)
                            {
                                IFW32FALSE_EXIT(::SxsAddStringToStringSectionGenerationContext(
                                            (PSTRING_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                                            ProgIdBuffer,
                                            ProgIdBuffer.Cch(),
                                            ServerContext,
                                            Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                            ERROR_SXS_DUPLICATE_PROGID));
                            }
                        }

                        break;
                    }

                }
            }

            Data->ElementParsed.Success = TRUE;

            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;

        // Someone shouldn't be asking for the section size if we
        // are generating an activation context.
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(SSGenContext != NULL);

        IFW32FALSE_EXIT(
            ::SxsGetStringSectionGenerationContextSectionSize(
                SSGenContext,
                &Data->GetSectionSize.SectionSize));

        Data->GetSectionSize.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;

        INTERNAL_ERROR_CHECK(SSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);

        IFW32FALSE_EXIT(
            ::SxsGetStringSectionGenerationContextSectionData(
                SSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));

        Data->GetSectionData.Success = TRUE;
        break;
    }
Exit:
    ;
}

BOOL
SxspComProgIdRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    FN_PROLOG_WIN32

    PCOM_PROGID_GLOBAL_CONTEXT GlobalContext = (PCOM_PROGID_GLOBAL_CONTEXT) Context;

    switch (Reason)
    {
    default:
        INTERNAL_ERROR_CHECK(FALSE);
        goto Exit; // never hit this line, INTERNAL_ERROR_CHECK would "goto Exit"

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        // do nothing;
        break;

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE) CallbackData;
            CBData->DataSize = sizeof(GUID) * GlobalContext->m_ServerContextList.GetEntryCount();

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA) CallbackData;
            SIZE_T BytesWritten = 0;
            SIZE_T BytesLeft = CBData->BufferSize;
            GUID *Cursor = (GUID *) CBData->Buffer;
            CComProgIdServerDequeIterator Iterator(&GlobalContext->m_ServerContextList);

            INTERNAL_ERROR_CHECK(BytesLeft >= (sizeof(GUID) * GlobalContext->m_ServerContextList.GetEntryCount()));

            for (Iterator.Reset(); Iterator.More(); Iterator.Next())
            {
                Iterator->m_Offset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) CBData->SectionHeader));
                *Cursor++ = Iterator->m_ConfiguredClsid;
                BytesWritten += sizeof(GUID);
                BytesLeft -= sizeof(GUID);
            }

            CBData->BytesWritten = BytesWritten;
            
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION);
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData = (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Info;
            PCOM_PROGID_SERVER_CONTEXT ServerContext = (PCOM_PROGID_SERVER_CONTEXT) CBData->DataContext;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            Info = (PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION) CBData->Buffer;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION))
                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION);
            Info->Flags = 0;
            Info->ConfiguredClsidOffset = ServerContext->m_Offset;

            CBData->BytesWritten = BytesWritten;

            break;
        }
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cresourcestream.h ===
#if !defined(_FUSION_SXS_CRESOURCESTREAM_H_INCLUDED_)
#define _FUSION_SXS_CRESOURCESTREAM_H_INCLUDED_

/*++

Copyright (c) Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Minimal implementation of IStream over a Windows PE/COFF resource.

Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#pragma once
#include "cmemorystream.h"
#include "fusionhandle.h"
#include "sxsp.h"

class CResourceStream :  public CMemoryStream
{
    typedef CMemoryStream Base;
public:
    CResourceStream() { }

    // NOTE the order of type/name is 1) as you might expect 2) consistent with
    // FindResourceEx, 3) INconsistent with FindResource
    // RT_* are actually of type PCWSTR
    BOOL Initialize(PCWSTR file, PCWSTR type, PCWSTR name, WORD language = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    BOOL Initialize(PCWSTR file, PCWSTR type);
    /*
    feel free to add more overloads that take, say
        HMODULE, HRSRC, HGLOBAL
    */

    // Override so that we can get times from the open file...
    HRESULT __stdcall Stat(STATSTG *pstatstg, DWORD grfStatFlag);

    virtual ~CResourceStream() { }

private: // intentionally not implemented
    CResourceStream(const CResourceStream&);
    void operator=(const CResourceStream&);

    BOOL InitializeAlreadyOpen(
        PCWSTR type,
        PCWSTR name,
        LANGID   language = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
        );

    CDynamicLinkLibrary m_dll;
    CStringBuffer m_buffFilePath;
};

#endif // !defined(_FUSION_SXS_CRESOURCESTREAM_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cstreamtap.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "cstreamtap.h"

STDMETHODIMP
CTeeStreamWithHash::Read(
    void* pv,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = E_FAIL;
    FN_TRACE_HR(hr);

    IFCOMFAILED_EXIT( CTeeStream::Read( pv, cb, pcbRead ) );
    IFW32FALSE_EXIT(this->m_hCryptHash.Win32HashData((PBYTE)pv, *pcbRead));

    hr = S_OK;
Exit:
    return hr;
}

STDMETHODIMP
CTeeStreamWithHash::Seek(
    LARGE_INTEGER,
    DWORD,
    ULARGE_INTEGER*
    )
{
    FN_PROLOG_HR
    INTERNAL_ERROR_CHECK2(FALSE, "Don't call Seek on a crypto hash input stream");
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\csecuritymetadata.h ===
/*
Copyright (c) Microsoft Corporation
*/
#pragma once

#include "fusionbuffer.h"

class CAssemblyRecoveryInfo;

enum SxsWFPResolveCodebase
{
    CODEBASE_RESOLVED_URLHEAD_UNKNOWN,
    CODEBASE_RESOLVED_URLHEAD_FILE,
    CODEBASE_RESOLVED_URLHEAD_HTTP,
    CODEBASE_RESOLVED_URLHEAD_WINSOURCE,
    CODEBASE_RESOLVED_URLHEAD_CDROM
};

BOOL
SxspDetermineCodebaseType(
    IN const CBaseStringBuffer &rcbuffUrlString,
    OUT SxsWFPResolveCodebase &rcbaseType,
    OUT CBaseStringBuffer *pbuffRemainder = NULL
    );

//
// no parens on these macros so that you can use them
// in compile-time string concatenation, and parens
// here wouldn't actually help anything
//
#define CSMD_TOPLEVEL_CODEBASE              L"Codebase"
#define CSMD_TOPLEVEL_CATALOG               L"Catalog"
#define CSMD_TOPLEVEL_SHORTNAME             L"ShortName"
#define CSMD_TOPLEVEL_SHORTCATALOG          L"ShortCatalogName"
#define CSMD_TOPLEVEL_SHORTMANIFEST         L"ShortManifestName"
#define CSMD_TOPLEVEL_MANIFESTHASH          L"ManifestSHA1Hash"
#define CSMD_TOPLEVEL_FILES                 L"Files"
#define CSMD_TOPLEVEL_CODEBASES             L"Codebases"
#define CSMD_TOPLEVEL_PUBLIC_KEY_TOKEN      L"PublicKeyToken"
#define CSMD_CODEBASES_PROMPTSTRING         L"Prompt"
#define CSMD_CODEBASES_URL                  L"URL"
#define CSMD_TOPLEVEL_IDENTITY              L"Identity"

typedef CFusionArray<BYTE> CFusionByteArray;
typedef CFusionArray<CStringBuffer> CFusionStringArray;

class CFileInformationTableHelper;
class CFileHashTableHelper;
class CSecurityMetaData;

class CFileHashTableHelper:
    public CCaseInsensitiveSimpleUnicodeStringTableHelper<CFusionByteArray>
{
public:
    static BOOL InitializeValue(const CFusionByteArray &vin, CFusionByteArray &rvstored) 
    { 
        FN_PROLOG_WIN32
        IFW32FALSE_EXIT(vin.Win32Clone(rvstored));
        FN_EPILOG
    }
    
    static BOOL UpdateValue(const CFusionByteArray &vin, CFusionByteArray &rvstored) { return InitializeValue( vin, rvstored ); }
};

typedef CCaseInsensitiveSimpleUnicodeStringTable<CFusionByteArray, CFileHashTableHelper> CFileHashTable;
typedef CCaseInsensitiveSimpleUnicodeStringTableIter<CFusionByteArray, CFileHashTableHelper> CFileHashTableIter;

//
// Contains metadata about a file element.  This is a collection with the name of
// the file and a list (table) of the SHA1 hash elements.
//
class CMetaDataFileElement : CFileHashTable
{
    CMetaDataFileElement( const CMetaDataFileElement& );
    CMetaDataFileElement& operator=( const CMetaDataFileElement& );

    friend CFileInformationTableHelper;
    friend CSecurityMetaData;

    BOOL ReadFromRegistry( CRegKey& hkThisFileNode );
    BOOL WriteToRegistry( CRegKey& hkThisFileNode ) const;
    
public:
    CMetaDataFileElement();

    BOOL Initialize();
    BOOL Initialize( const CMetaDataFileElement& other );

    BOOL GetHashDataForKind( IN const ALG_ID aid, OUT CFusionByteArray& arrHashData, BOOL &bHadSuchData ) const;
    BOOL GetHashDataForKind( IN const CBaseStringBuffer& buffId, OUT CFusionByteArray& arrHashData, BOOL &bHadSuchData ) const;
    BOOL PutHashData( IN const ALG_ID aid, IN const CFusionByteArray& arrHashData );
    BOOL PutHashData( IN const CBaseStringBuffer& buffId, IN const CFusionByteArray& arrHashData );
};


//
// Now another table, this time of file to metadata mappings
//
class CFileInformationTableHelper : 
    public CCaseInsensitiveSimpleUnicodeStringTableHelper<CMetaDataFileElement>
{
public:
    static BOOL InitializeValue( const CMetaDataFileElement &vin, CMetaDataFileElement &stored ) { return stored.Initialize( vin ); }
    static BOOL UpdateValue( const CMetaDataFileElement &vin, CMetaDataFileElement &stored );
};

typedef CCaseInsensitiveSimpleUnicodeStringTable<CMetaDataFileElement, CFileInformationTableHelper> CFileInformationTable;
typedef CCaseInsensitiveSimpleUnicodeStringTableIter<CMetaDataFileElement, CFileInformationTableHelper> CFileInformationTableIter;

class CCodebaseInformation
{
    friend CSecurityMetaData;

public:
    CCodebaseInformation() : m_Type(CODEBASE_RESOLVED_URLHEAD_UNKNOWN) { }

    BOOL Initialize();
    BOOL Initialize(const CCodebaseInformation &other);

    const CBaseStringBuffer& GetCodebase() const { return m_Codebase; }
    BOOL SetCodebase(PCWSTR psz, SIZE_T cch) { return m_Codebase.Win32Assign(psz, cch); }
    BOOL SetCodebase(const CBaseStringBuffer & rsb) { return m_Codebase.Win32Assign(rsb); }

    const CBaseStringBuffer& GetPromptText() const { return m_PromptText; }
    BOOL SetPromptText(PCWSTR psz, SIZE_T cch) { return m_PromptText.Win32Assign(psz, cch); }
    BOOL SetPromptText(const CBaseStringBuffer & rsb) { return m_PromptText.Win32Assign(rsb); }

    const CBaseStringBuffer &GetReference() const { return m_Reference; }
    BOOL SetReference(const CBaseStringBuffer &r) { return m_Reference.Win32Assign(r); }

    BOOL Win32GetType(SxsWFPResolveCodebase& Type) const
    {
        FN_PROLOG_WIN32
        if (m_Type == CODEBASE_RESOLVED_URLHEAD_UNKNOWN)
        {
            IFW32FALSE_EXIT(::SxspDetermineCodebaseType(this->m_Codebase, this->m_Type));
        }
        Type = m_Type ;
        FN_EPILOG
    }

    BOOL SetType( SxsWFPResolveCodebase Type )
    {
        FN_PROLOG_WIN32
        INTERNAL_ERROR_CHECK(m_Type == CODEBASE_RESOLVED_URLHEAD_UNKNOWN);
        this->m_Type = Type;
        FN_EPILOG
    }

protected:
    BOOL WriteToRegistryKey(const CRegKey &rhkCodebaseKey) const;
    BOOL ReadFromRegistryKey(const CRegKey &rhkCodebaseKey);

    CMediumStringBuffer m_Reference;
    CMediumStringBuffer m_Codebase;
    CMediumStringBuffer m_PromptText;
    mutable SxsWFPResolveCodebase m_Type;

private:
    CCodebaseInformation( const CCodebaseInformation& );
    CCodebaseInformation& operator=( const CCodebaseInformation& );

};

MAKE_CFUSIONARRAY_READY(CCodebaseInformation, Initialize);

class CCodebaseInformationList : public CFusionArray<CCodebaseInformation>
{
public:
    BOOL FindCodebase(const CBaseStringBuffer &rbuffReference, CCodebaseInformation *&rpCodebaseInformation);
    BOOL RemoveCodebase(const CBaseStringBuffer &rbuffReference, bool &rfRemoved);
};


class CSecurityMetaData
{
    CCodebaseInformationList m_cilCodebases;
    CFusionByteArray m_baSignerPublicKeyToken;
    CFileInformationTable m_fitFileDataTable;
    CSmallStringBuffer m_buffShortNameOnDisk;
    CFusionByteArray m_baManifestSha1Hash;
    CStringBuffer m_buffTextualAssemblyIdentity;
    CStringBuffer m_buffShortCatalogName;
    CStringBuffer m_buffShortManifestName;

    CSecurityMetaData( const CSecurityMetaData& );
    CSecurityMetaData& operator=( const CSecurityMetaData& );

    //
    // Cheesy, but we always want to merge the two elements if one already exists.
    //
    BOOL MergeFileDataElement( 
        const CMetaDataFileElement &pNewFileDataElement, 
        const CMetaDataFileElement &rpOldFileDataElement, 
        InsertOrUpdateIfDisposition &Disposition ) { Disposition = eUpdateValue; return TRUE; }

    BOOL LoadCodebasesFromKey( CRegKey& hkCodebasesSubkey );
    BOOL LoadFilesFromKey( CRegKey& hkCodebasesSubkey );

    BOOL WriteFilesIntoKey( CRegKey &rhkFilesKey ) const;

public:

    //
    // Get information about a single item
    //
    enum FileAdditionDisposition {
        eFailIfAlreadyExists,
        eReplaceIfAlreadyExists,
        eMergeIfAlreadyExists
    };
    
    BOOL AddFileMetaData( const CBaseStringBuffer& rcbuffFileName, CMetaDataFileElement &rElementData, FileAdditionDisposition dispHowToAdd = eFailIfAlreadyExists );
    BOOL GetFileMetaData( const CBaseStringBuffer& rcbuffFileName, CMetaDataFileElement const* &rpElementData ) const;

    //
    // Full table that we can iterate over
    //
    const CFileInformationTable& GetFileDataTable() const { return m_fitFileDataTable; }

    //
    // Simplify the addition of a hash value
    //
    BOOL QuickAddFileHash( const CBaseStringBuffer& rcbuffFileName, ALG_ID aidHashAlg, const CBaseStringBuffer& rcbuffHashValue );

    //
    // All your codebases are belong to us.
    //
    const CCodebaseInformationList& GetCodeBaseList() const { return m_cilCodebases; }
protected:
    friend CAssemblyRecoveryInfo;
    CCodebaseInformationList& GetCodeBaseList() { return m_cilCodebases; }
public:

    //
    // Short path data
    //
    BOOL SetShortManifestPath(IN const CBaseStringBuffer &rcbuffShortManifestPath) { return m_buffShortManifestName.Win32Assign(rcbuffShortManifestPath); }
    const CBaseStringBuffer &GetShortManifestPath() const { return m_buffShortManifestName; }

    BOOL SetShortCatalogPath(IN const CBaseStringBuffer &rcbuffShortCatalogPath) { return m_buffShortCatalogName.Win32Assign(rcbuffShortCatalogPath); }
    const CBaseStringBuffer &GetShortCatalogPath() const { return this->m_buffShortCatalogName; };

    BOOL AddCodebase(
        const CBaseStringBuffer &rbuffReference, 
        const CBaseStringBuffer &rbuffCodebase,
        const CBaseStringBuffer &rbuffPrompt );
        
    BOOL RemoveCodebase(const CBaseStringBuffer &rbuffReference, bool &rfRemoved);

    //
    // On-disk shortname?
    //
    BOOL SetInstalledDirShortName(const CBaseStringBuffer &rcbuffShortName) { return this->m_buffShortNameOnDisk.Win32Assign(rcbuffShortName); }
    const CBaseStringBuffer &GetInstalledDirShortName() const { return this->m_buffShortNameOnDisk; }

    //
    // Manifest hash?
    //
    BOOL SetManifestHash( const CFusionByteArray &rcbaManifestHash ) { return rcbaManifestHash.Win32Clone(this->m_baManifestSha1Hash); }
    const CFusionByteArray &GetManifestHash() const { return this->m_baManifestSha1Hash; }

    //
    // Identity
    //
    BOOL SetTextualIdentity( const CBaseStringBuffer &rcbuffIdentity ) { return m_buffTextualAssemblyIdentity.Win32Assign(rcbuffIdentity); }
    const CBaseStringBuffer &GetTextualIdentity() const { return this->m_buffTextualAssemblyIdentity; }

    //
    // Signer public key token
    //
    BOOL SetSignerPublicKeyTokenBits( const CFusionByteArray& rcbuffSignerPublicKeyBits );
    const CFusionByteArray& GetSignerPublicKeyTokenBits() const { return m_baSignerPublicKeyToken; }

    //
    // Dummy - Initialize() is what you -really- want.
    //
    CSecurityMetaData() { }

    BOOL Initialize();
    BOOL Initialize(const CSecurityMetaData &other);
    BOOL Initialize(const CBaseStringBuffer &rcbuffTextualIdentity);
    BOOL LoadFromRegistryKey(const CRegKey &rhkRegistryNode);

#define SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_INTO_REGISTRY_KEY_FLAG_REFRESH (0x00000001)

    BOOL WritePrimaryAssemblyInfoIntoRegistryKey(ULONG Flags, const CRegKey &rhkRegistryNode) const;

    BOOL WriteSecondaryAssemblyInfoIntoRegistryKey(const CRegKey &rhkRegistryNode) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\comtypelib.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    comtypelib.cpp

Abstract:

    Activation context section contributor for COM typelib mapping.

Author:

    Michael J. Grier (MGrier) 28-Mar-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include <stdio.h>
#include "sxsp.h"
#include "sxsidp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(tlbid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(version);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(resourceid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(flags);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(helpdir);

/*

<file name="foo.dll">
   <typelib tlbid="{tlbid}" resourceid="5" version="2.5" flags="control,hidden" helpdir="HelpFiles\"/>
   <typelib tlbid="{tlbid}" resourceid="6" version="2.6" flags="control,hidden" helpdir="HelpFiles\"/>
   <comClass .../>
</file>

*/

#define MAP_ENTRY(_x) { L#_x, NUMBER_OF(#_x) - 1, LIBFLAG_F ## _x }
static const struct
{
    PCWSTR Flag;
    SIZE_T FlagCch;
    USHORT FlagValue;
} gs_rgMapLibFlags[] =
{
    // Values taken from the LIBFLAGS enumeration in oaidl.h
    MAP_ENTRY(RESTRICTED),
    MAP_ENTRY(CONTROL),
    MAP_ENTRY(HIDDEN),
    MAP_ENTRY(HASDISKIMAGE),
};

typedef struct _TLB_GLOBAL_CONTEXT *PTLB_GLOBAL_CONTEXT;
typedef struct _TLB_FILE_CONTEXT *PTLB_FILE_CONTEXT;
typedef struct _TLB_ENTRY *PTLB_ENTRY;
typedef  _ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION  _TLB_VERSION;
typedef   ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION   TLB_VERSION;
typedef  PACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION  PTLB_VERSION;
typedef PCACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION PCTLB_VERSION;

typedef struct _TLB_ENTRY
{
    _TLB_ENTRY() : m_ResourceId(0), m_LibraryFlags(0) { }

    CDequeLinkage m_Linkage;

    PTLB_FILE_CONTEXT m_FileContext;
    GUID            m_TypeLibId;
    CStringBuffer   m_HelpDirBuffer;
    TLB_VERSION     m_Version;
    USHORT          m_ResourceId;
    USHORT          m_LibraryFlags;

private:
    _TLB_ENTRY(const _TLB_ENTRY &);
    void operator =(const _TLB_ENTRY &);
} TLB_ENTRY, *PTLB_ENTRY;

typedef CDeque<TLB_ENTRY, offsetof(TLB_ENTRY, m_Linkage)> CTlbEntryDeque;
typedef CDequeIterator<TLB_ENTRY, offsetof(TLB_ENTRY, m_Linkage)> CTlbEntryDequeIterator;


typedef struct _TLB_FILE_CONTEXT
{
    _TLB_FILE_CONTEXT() : m_Offset(0) { }
    ~_TLB_FILE_CONTEXT() { m_Entries.ClearAndDeleteAll(); }

    CDequeLinkage m_Linkage;

    CTlbEntryDeque m_Entries;

    CStringBuffer m_FileNameBuffer;
    ULONG m_Offset; // populated during section generation

private:
    _TLB_FILE_CONTEXT(const _TLB_FILE_CONTEXT &);
    void operator =(const _TLB_FILE_CONTEXT &);
} TLB_FILE_CONTEXT;

typedef CDeque<TLB_FILE_CONTEXT, offsetof(TLB_FILE_CONTEXT, m_Linkage)> CTlbFileContextDeque;
typedef CDequeIterator<TLB_FILE_CONTEXT, offsetof(TLB_FILE_CONTEXT, m_Linkage)> CTlbFileContextDequeIter;

typedef struct _TLB_GLOBAL_CONTEXT
{
    _TLB_GLOBAL_CONTEXT() { }
    ~_TLB_GLOBAL_CONTEXT() { m_FileContextList.ClearAndDeleteAll(); }

    CTlbFileContextDeque m_FileContextList;    
    CStringBuffer m_FileNameBuffer;

private:
    _TLB_GLOBAL_CONTEXT(const _TLB_GLOBAL_CONTEXT &);
    void operator =(const _TLB_GLOBAL_CONTEXT &);
} TLB_GLOBAL_CONTEXT;

BOOL
SxspComTypeLibRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

BOOL
SxspParseTlbVersion(
    PCWSTR String,
    SIZE_T Cch,
    PTLB_VERSION Version
    );

BOOL
SxspFormatTlbVersion(
    const TLB_VERSION *Version,
    CBaseStringBuffer &Buffer
    );

BOOL
SxspParseLibraryFlags(
    PCWSTR String,
    SIZE_T Cch,
    USHORT *LibraryFlags
    );

VOID
__fastcall
SxspComTypeLibRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PGUID_SECTION_GENERATION_CONTEXT SSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    CSmartPtr<TLB_GLOBAL_CONTEXT> TlbGlobalContext;

    if (SSGenContext != NULL)
        TlbGlobalContext.AttachNoDelete((PTLB_GLOBAL_CONTEXT) ::SxsGetGuidSectionGenerationContextCallbackContext(SSGenContext));

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(TlbGlobalContext == NULL);
        INTERNAL_ERROR_CHECK(SSGenContext == NULL);

        // do everything if we are generating an activation context.
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        {
            IFW32FALSE_EXIT(TlbGlobalContext.Win32Allocate(__FILE__, __LINE__));

            IFW32FALSE_EXIT(::SxsInitGuidSectionGenerationContext(
                    &SSGenContext,
                    ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_FORMAT_WHISTLER,
                    &::SxspComTypeLibRedirectionGuidSectionGenerationCallback,
                    TlbGlobalContext));

            TlbGlobalContext.Detach();

            Data->Header.ActCtxGenContext = SSGenContext;
        }

        Data->GenBeginning.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:

        ::SxsDestroyGuidSectionGenerationContext(SSGenContext);
        if (TlbGlobalContext != NULL)
        {
            FUSION_DELETE_SINGLETON(TlbGlobalContext.Detach());
        }
        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        Data->ElementParsed.Success = FALSE;

        if ((Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT) || 
            (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)) // in installcase, the following code would verify the syntax of the manifest file
        {

            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssemblyFile = 1,
                eAssemblyFileTypelib = 2,
            };

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                { 2, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file", NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file") - 1, eAssemblyFile },
                { 3, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^typelib", NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^typelib") - 1, eAssemblyFileTypelib },
            };

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->ElementParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR_CHECK2(
                        FALSE,
                        "Invalid mapped value returned from SxspProcessElementPathMap");

                case eAssemblyFile:
                    {
                        SIZE_T cb = 0;
                        CSmallStringBuffer FileNameBuffer;

                        fFound = false;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_name,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(FileNameBuffer),
                                &FileNameBuffer,
                                cb,
                                NULL,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);
                    
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            INTERNAL_ERROR_CHECK2(
                                TlbGlobalContext != NULL,
                                "COM tlb global context NULL while processing file tag");

                            IFW32FALSE_EXIT(TlbGlobalContext->m_FileNameBuffer.Win32Assign(FileNameBuffer));
                        }

                        break;
                    }

                case eAssemblyFileTypelib:
                    {
                        GUID TypeLibId;
                        CSmallStringBuffer HelpDirBuffer;
                        CSmallStringBuffer TempBuffer;
                        SIZE_T cb = 0;
                        TLB_VERSION Version;
                        USHORT LibraryFlags = 0;
                        USHORT ResourceId = 0;

                        fFound = false;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_tlbid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(TempBuffer),
                                &TempBuffer,
                                cb,
                                NULL,
                                0));
                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(::SxspParseGUID(TempBuffer, TempBuffer.Cch(), TypeLibId));
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_version,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(TempBuffer),
                                &TempBuffer,
                                cb,
                                NULL,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(::SxspParseTlbVersion(TempBuffer, TempBuffer.Cch(), &Version));
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_resourceid,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(TempBuffer),
                                &TempBuffer,
                                cb,
                                NULL,
                                0));

                        if (fFound)
                            IFW32FALSE_EXIT(::SxspParseUSHORT(TempBuffer, TempBuffer.Cch(), &ResourceId));
                        else
                            ResourceId = 1;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_flags,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(TempBuffer),
                                &TempBuffer,
                                cb,
                                NULL,
                                NULL));

                        if (fFound)
                            IFW32FALSE_EXIT(::SxspParseLibraryFlags(TempBuffer, TempBuffer.Cch(), &LibraryFlags));
                        else
                            LibraryFlags = 0;

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_helpdir,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(HelpDirBuffer),
                                &HelpDirBuffer,
                                cb,
                                NULL,
                                0));

                        INTERNAL_ERROR_CHECK(fFound);

                        // Do more work if generating an activation context.
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            CSmartPtr<TLB_FILE_CONTEXT> FileContext;
                            CSmartPtr<TLB_ENTRY> Entry;

                            INTERNAL_ERROR_CHECK2(TlbGlobalContext != NULL, "COM tlb global context NULL while processing comClass tag");

                            // If this is the first <typelib> for the file, create the file context object
                            if (TlbGlobalContext->m_FileNameBuffer.Cch() != 0)
                            {
                                IFW32FALSE_EXIT(FileContext.Win32Allocate(__FILE__, __LINE__));

                                IFW32FALSE_EXIT(FileContext->m_FileNameBuffer.Win32Assign(TlbGlobalContext->m_FileNameBuffer));
                                TlbGlobalContext->m_FileContextList.AddToHead(FileContext.DetachAndHold());
                            }
                            else
                            {
                                CTlbFileContextDequeIter Iter(&TlbGlobalContext->m_FileContextList);
                                INTERNAL_ERROR_CHECK(!TlbGlobalContext->m_FileContextList.IsEmpty());
                                Iter.Reset();
                                FileContext.AttachNoDelete(Iter);
                            }

                            INTERNAL_ERROR_CHECK2(
                                FileContext != NULL,
                                "COM tlb file context NULL while processing typelib tag; we should have failed before getting to the typelib element.");

                            IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

                            Entry->m_FileContext = FileContext;
                            Entry->m_TypeLibId = TypeLibId;
                            Entry->m_Version = Version;
                            Entry->m_ResourceId = ResourceId;
                            Entry->m_LibraryFlags = LibraryFlags;

                            IFW32FALSE_EXIT(Entry->m_HelpDirBuffer.Win32Assign(HelpDirBuffer));

                            IFW32FALSE_EXIT(
                                ::SxsAddGuidToGuidSectionGenerationContext(
                                    (PGUID_SECTION_GENERATION_CONTEXT) Data->ElementParsed.Header.ActCtxGenContext,
                                    &TypeLibId,
                                    Entry,
                                    Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                    ERROR_SXS_DUPLICATE_TLBID));

                            FileContext->m_Entries.AddToHead(Entry.Detach());
                        }

                        break;
                    }
                }
            }

        }
        
        Data->ElementParsed.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;
        if (SSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingGuidSectionGenerationContext(SSGenContext));
        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        // Someone shouldn't be asking for the section size if we
        // are not generating an activation context.
        // These two asserts should be equivalent...
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(SSGenContext != NULL);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionSize(SSGenContext, &Data->GetSectionSize.SectionSize));
        Data->GetSectionSize.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;

        INTERNAL_ERROR_CHECK(SSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);

        IFW32FALSE_EXIT(
            ::SxsGetGuidSectionGenerationContextSectionData(
                SSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));

        Data->GetSectionData.Success = TRUE;
        break;
    }
Exit:
    ;
}

BOOL
SxspComTypeLibRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PTLB_GLOBAL_CONTEXT GlobalContext = (PTLB_GLOBAL_CONTEXT) Context;

    switch (Reason)
    {
    default:
        FN_SUCCESSFUL_EXIT();

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE) CallbackData;
            CTlbFileContextDequeIter Iter(&GlobalContext->m_FileContextList);

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                CBData->DataSize += ((Iter->m_FileNameBuffer.Cch() + 1) * sizeof(WCHAR));
            }

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA) CallbackData;
            SIZE_T BytesWritten = 0;
            SIZE_T BytesLeft = CBData->BufferSize;
            PWSTR Cursor = (PWSTR) CBData->Buffer;
            CTlbFileContextDequeIter Iter(&GlobalContext->m_FileContextList);

            for (Iter.Reset(); Iter.More(); Iter.Next())
            {
                IFW32FALSE_EXIT(
                    Iter->m_FileNameBuffer.Win32CopyIntoBuffer(
                        &Cursor,
                        &BytesLeft,
                        &BytesWritten,
                        CBData->SectionHeader,
                        &Iter->m_Offset,
                        NULL));
            }

            CBData->BytesWritten = BytesWritten;

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PTLB_ENTRY Entry = (PTLB_ENTRY) CBData->DataContext;

            if (Entry != NULL)
            {
                if (Entry->m_FileContext != NULL)
                {
                    //
                    // Remove the entry from its parent file context
                    //
                    Entry->m_FileContext->m_Entries.Remove(Entry);

                    //
                    // If there's nothing left in the file context (refcount 0) then
                    // remove the file context from the global context and
                    // delete it.
                    //
                    if (Entry->m_FileContext->m_Entries.IsEmpty())
                    {
                        GlobalContext->m_FileContextList.Remove(Entry->m_FileContext);
                        FUSION_DELETE_SINGLETON(Entry->m_FileContext);
                    }
                }

                FUSION_DELETE_SINGLETON(Entry);
            }

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PTLB_ENTRY Entry = (PTLB_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION);

            if (Entry != NULL)
            {
                SIZE_T Cch;
#define GET_BUFFER_SIZE(Buffer) (((Cch = (Buffer).Cch()) != 0) ? ((Cch + 1) * sizeof(WCHAR)) : 0)
                CBData->DataSize += GET_BUFFER_SIZE(Entry->m_HelpDirBuffer);
#undef GET_BUFFER_SIZE
            }
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION Info;
            PTLB_ENTRY Entry = (PTLB_ENTRY) CBData->DataContext;
            PTLB_FILE_CONTEXT FileContext = Entry->m_FileContext;
            PWSTR StringCursor;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            Info = (PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION) CBData->Buffer;

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION);

            StringCursor = (PWSTR) (Info + 1);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION);
            Info->Flags = 0;
            Info->NameLength = static_cast<ULONG>((FileContext->m_FileNameBuffer.Cch() + 1) * sizeof(WCHAR));
            Info->NameOffset = FileContext->m_Offset;
            Info->ResourceId = Entry->m_ResourceId;
            Info->LibraryFlags = Entry->m_LibraryFlags;
            Info->Version = Entry->m_Version;

            IFW32FALSE_EXIT(
                Entry->m_HelpDirBuffer.Win32CopyIntoBuffer(
                    &StringCursor,
                    &BytesLeft,
                    &BytesWritten,
                    Info,
                    &Info->HelpDirOffset,
                    &Info->HelpDirLength));

            CBData->BytesWritten = BytesWritten;
        }
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspParseTlbVersion(
    PCWSTR String,
    SIZE_T Cch,
    PTLB_VERSION Version
    )
{
    BOOL fSuccess = FALSE;
    PCWSTR psz = String;
    ULONG cDots = 0;
    USHORT usTemp = 0;
    TLB_VERSION TempVersion;
    PCWSTR pszLast = NULL;

    TempVersion.Major = 0;
    TempVersion.Minor = 0;

    while ((Cch != 0) && (psz[Cch - 1] == L'\0'))
        Cch--;

    // Unfortunately there isn't a StrChrN(), so we'll look for the dots ourselves...
    PCWSTR pszTemp = psz;
    SIZE_T cchLeft = Cch;

    while (cchLeft-- != 0)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'.')
        {
            cDots++;

            if (cDots >= 2)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: Found two or more dots in a TLB version number.\n");

                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
        }
        else if ((wch < L'0') || (wch > L'9'))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Found characters other than . and 0-9 in a TLB version number.\n");
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
    }

    if (cDots < 1)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: No dots found in a TLB version number.\n");
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    pszTemp = psz;
    pszLast = psz + Cch;

    usTemp = 0;
    for (;;)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'.')
            break;

        usTemp = (usTemp * 10) + (wch - L'0');
    }
    TempVersion.Major = usTemp;

    // Now the tricky bit.  We aren't necessarily null-terminated, so we
    // have to just look for hitting the end.
    usTemp = 0;
    while (pszTemp < pszLast)
    {
        WCHAR wch = *pszTemp++;
        usTemp = (usTemp * 10) + (wch - L'0');
    }
    TempVersion.Minor = usTemp;

    *Version = TempVersion;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspFormatTlbVersion(
    const TLB_VERSION *Version,
    CBaseStringBuffer &Buffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    WCHAR rgwchBuffer[sizeof("65535.65535\0")];

#pragma prefast(suppress:53, "We do not depend on _snwprintf null termination here.")
#pragma prefast(suppress:53, "We use the returned length, for efficiency.")

    C_ASSERT(sizeof(Version->Major) == sizeof(unsigned __int16));
    int CchFound = _snwprintf(rgwchBuffer, NUMBER_OF(rgwchBuffer), L"%u.%u", Version->Major, Version->Minor);
    INTERNAL_ERROR_CHECK(CchFound != -1);
    IFW32FALSE_EXIT(Buffer.Win32Assign(rgwchBuffer, CchFound));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspParseLibraryFlags(
    PCWSTR String,
    SIZE_T Cch,
    USHORT *LibraryFlags
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SIZE_T CchThisSegment;
    SIZE_T i = 0;
    USHORT TempFlags = 0;

    if (LibraryFlags != NULL)
        *LibraryFlags = 0;

    while (Cch != 0)
    {
        PCWSTR Comma = wcschr(String, L',');
        if (Comma != NULL)
            CchThisSegment = Comma - String;
        else
            CchThisSegment = Cch;

        for (i=0; i<NUMBER_OF(gs_rgMapLibFlags); i++)
        {
            if (::FusionpCompareStrings(
                        gs_rgMapLibFlags[i].Flag,
                        gs_rgMapLibFlags[i].FlagCch,
                        String,
                        CchThisSegment,
                        true) == 0)
            {
                if ((TempFlags & gs_rgMapLibFlags[i].FlagValue) != 0)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: Redundant type library flags\n");
                    ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                    goto Exit;
                }
                TempFlags |= gs_rgMapLibFlags[i].FlagValue;                
                break;
            }
        }
        if (i == NUMBER_OF(gs_rgMapLibFlags))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Invalid type library flags\n");
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        Cch -= CchThisSegment;
        String += CchThisSegment;

        if (Cch != 0)
        {
            // there must have been a comma there...
            Cch--;
            String++;

            // However, if that was all there was, we have a parse error.
            if (Cch == 0)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: Trailing comma in type library flag string\n");
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
        }
    }

    if (LibraryFlags != NULL)
        *LibraryFlags = TempFlags;

    fSuccess = TRUE;

Exit:
    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\fileoper.h ===
#if !defined(_FUSION_SXS_FILEOPER_H_INCLUDED_)
#define _FUSION_SXS_FILEOPER_H_INCLUDED_

#pragma once

#define SXSP_COPY_FILE_FLAG_REPLACE_EXISTING (0x00000001)
#define SXSP_COPY_FILE_FLAG_COMPRESSION_AWARE (0x00000002)

BOOL
SxspCopyFile(
    DWORD dwFlags,
    PCWSTR pszSource,
    PCWSTR pszDestination
    );

#endif // !defined(_FUSION_SXS_FILEOPER_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\fileoper.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include <stdio.h>
#include <setupapi.h>
#include "fusionhandle.h"
#include "sxspath.h"
#include "sxsapi.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "strongname.h"
#include "fusiontrace.h"

BOOL
SxspCopyFile(
    DWORD dwFlags,
    PCWSTR pszSource,
    PCWSTR pszDestination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL fFileWasInUse = FALSE;
    DWORD dwCopyStyle = 0;

    PARAMETER_CHECK((dwFlags & ~(SXSP_COPY_FILE_FLAG_REPLACE_EXISTING | SXSP_COPY_FILE_FLAG_COMPRESSION_AWARE)) == 0);
    PARAMETER_CHECK(pszSource != NULL);
    PARAMETER_CHECK(pszDestination != NULL);

    {
        // NTRAID#NTBUG9 - 591001 - 2002/03/30 - mgrier - missing return value check
        SetFileAttributesW(pszDestination, 0);
        IFW32FALSE_ORIGINATE_AND_EXIT(
            ::CopyFileW(
                pszSource,
                pszDestination,
                (dwFlags & SXSP_COPY_FILE_FLAG_REPLACE_EXISTING) == 0));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGetFileSize(
    DWORD dwFlags,
    PCWSTR   file,
    ULONGLONG &fileSize
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PWSTR pszActualSource = NULL;

    fileSize = 0;

    PARAMETER_CHECK(file != NULL);
    PARAMETER_CHECK((dwFlags & ~(SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE | SXSP_GET_FILE_SIZE_FLAG_GET_COMPRESSED_SOURCE_SIZE)) == 0);
    PARAMETER_CHECK((dwFlags & SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE) || !(dwFlags & SXSP_GET_FILE_SIZE_FLAG_GET_COMPRESSED_SOURCE_SIZE));

    if (dwFlags & SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE)
    {
        DWORD dwTemp = 0;
        DWORD dwSourceFileSize = 0;
        DWORD dwTargetFileSize = 0;
        UINT uiCompressionType = 0;

        dwTemp = ::SetupGetFileCompressionInfoW(
            file,
            &pszActualSource,
            &dwSourceFileSize,
            &dwTargetFileSize,
            &uiCompressionType);
        if (dwTemp != ERROR_SUCCESS)
        {
            ::SetLastError(dwTemp);
            ORIGINATE_WIN32_FAILURE_AND_EXIT(SetupGetFileCompressionInfoW, dwTemp);
        }

        if (pszActualSource != NULL)
        {
            ::LocalFree((HLOCAL) pszActualSource);
            pszActualSource = NULL;
        }
        if (dwFlags & SXSP_GET_FILE_SIZE_FLAG_GET_COMPRESSED_SOURCE_SIZE)
            fileSize = dwSourceFileSize;
        else
            fileSize = dwTargetFileSize;
    }
    else
    {
        LARGE_INTEGER liFileSize = {0};
        WIN32_FILE_ATTRIBUTE_DATA wfad;

        wfad.nFileSizeLow = 0;
        wfad.nFileSizeHigh = 0;

        IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileAttributesExW(file, GetFileExInfoStandard, &wfad));

        liFileSize.LowPart = wfad.nFileSizeLow;
        liFileSize.HighPart = wfad.nFileSizeHigh;
        fileSize = liFileSize.QuadPart;
    }

    fSuccess = TRUE;
Exit:
    if (pszActualSource != NULL)
    {
        CSxsPreserveLastError ple;
        ::LocalFree((HLOCAL) pszActualSource);
        ple.Restore();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\dumpers.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include <stdio.h>
#include "fusionhandle.h"
#include "sxsapi.h"
#include <limits.h>
typedef const void * PCVOID;

VOID
SxspDbgPrintInstallSourceInfo(
    ULONG Level,
    PSXS_INSTALL_SOURCE_INFO Info,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataTocEntry(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataTocSections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    const GUID *ExtensionGuid,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataTocSection(
    ULONG Level,
    bool fFull,
    PVOID Section,
    SIZE_T Length,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataExtendedTocHeader(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataExtendedTocEntry(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataExtendedTocSections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataExtendedTocEntrySections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextStringSection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextGuidSection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextBinarySection(
    ULONG Level,
    bool fFull,
    PVOID Data,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintAssemblyInformation(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintDllRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintWindowClassRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintCLRSurrogateTable(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintComServerRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintComProgIdRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintTypeLibraryRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintComInterfaceRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    );

VOID
SxspDbgPrintActivationContextDataAssemblyRoster(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxspDbgPrintActivationContextDataTocHeader(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    );

VOID
SxsppDbgPrintActivationContextData(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;

    //
    // ISSUE: jonwis 3/7/2002
    // - Parameter checking of Data is noticably absent.
    // - Lots of unchecked pointer math here.  Not so bad, since this will only
    //   crash user-mode code, and will only allow reads of this process'
    //   memory space, but it's correctness.  Mitgated by this being debugging-
    //   related code only.
    //

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SActivation Context Data %p\n"
            "%S   Magic = 0x%08lx (%lu)\n"
            "%S   HeaderSize = %d (0x%lx)\n"
            "%S   FormatVersion = %d\n",
            PLP, Data,
            PLP, Data->Magic, Data->Magic,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->FormatVersion);

        ::FusionpDbgPrintEx(
            Level,
            "%S   TotalSize = %d (0x%lx)\n"
            "%S   DefaultTocOffset = %d (0x%lx) (-> %p)\n"
            "%S   ExtendedTocOffset = %d (0x%lx) (-> %p)\n",
            PLP, Data->TotalSize, Data->TotalSize,
            PLP, Data->DefaultTocOffset, Data->DefaultTocOffset, (Data->DefaultTocOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            PLP, Data->ExtendedTocOffset, Data->ExtendedTocOffset, (Data->ExtendedTocOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->ExtendedTocOffset));

        ::FusionpDbgPrintEx(
            Level,
            "%S   AssemblyRosterOffset = %d (0x%lx) (-> %p)\n",
            PLP, Data->AssemblyRosterOffset, Data->AssemblyRosterOffset, (Data->AssemblyRosterOffset == 0) ? NULL : (PVOID) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset));
    }
    else
    {
        // !fFull
        ::FusionpDbgPrintEx(
            Level,
            "%SActivation Context Data %p (brief output)\n",
            PLP, Data);
    }

    //
    // ISSUE: jonwis 3/7/2002
    // - Bad bad BAD form.  Use .Win32AppendFill(L' ', 3) instead.
    //
    rbuffPLP.Win32Append(L"   ", 3);

    if (Data->AssemblyRosterOffset != 0)
        ::SxspDbgPrintActivationContextDataAssemblyRoster(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER) (((ULONG_PTR) Data) + Data->AssemblyRosterOffset),
            rbuffPLP);

    if (Data->DefaultTocOffset != 0)
        ::SxspDbgPrintActivationContextDataTocHeader(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            rbuffPLP);

    if (Data->ExtendedTocOffset != 0)
        ::SxspDbgPrintActivationContextDataExtendedTocHeader(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((ULONG_PTR) Data) + Data->ExtendedTocOffset),
            rbuffPLP);

    // That's it for the header information.  Now start dumping the sections...
    if (Data->DefaultTocOffset != 0)
        ::SxspDbgPrintActivationContextDataTocSections(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Data) + Data->DefaultTocOffset),
            NULL,
            rbuffPLP);

    if (Data->ExtendedTocOffset != 0)
        ::SxspDbgPrintActivationContextDataExtendedTocSections(
            Level,
            fFull,
            Data,
            (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER) (((ULONG_PTR) Data) + Data->Extended