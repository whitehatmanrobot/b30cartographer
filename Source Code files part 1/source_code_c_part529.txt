At(0) >= _T('0') ) && ( csEntry.GetAt(0) <= _T('9') ) )
                    {
                      iReturn = ProcessEntry_Entry(hFile, strTheSection.QueryStr() , csEntry);
                    }
                    else
                    {
                      ParseLine.ParseLine(&(g_pTheApp->FuncDict),csEntry.GetBuffer(0) );
                    }

                    strList.GetNext(pos);
                }
            }
        }
        iisDebugOut_End1(_T("ProcessSection"),strTheSection.QueryStr());

        iReturn = TRUE;
    }

    return iReturn;
}


int iOleInitialize(void)
{
    int iBalanceOLE = FALSE;
    HRESULT hInitRes = NULL;

    iisDebugOut_Start((_T("ole32:OleInitialize")));
    hInitRes = OleInitialize(NULL);
    iisDebugOut_End((_T("ole32:OleInitialize")));
    if ( SUCCEEDED(hInitRes) || hInitRes == RPC_E_CHANGED_MODE )
        {
            if ( SUCCEEDED(hInitRes))
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("iOleInitialize: Succeeded: %x.  MakeSure to call OleUninitialize.\n"), hInitRes));
                iBalanceOLE = TRUE;
            }
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("iOleInitialize: Failed 0x%x. RPC_E_CHANGED_MODE\n"), hInitRes));
            }
        }
    else
        {iisDebugOut((LOG_TYPE_ERROR, _T("iOleInitialize: Failed 0x%x.\n"), hInitRes));}

    return iBalanceOLE;
}



void iOleUnInitialize(int iBalanceOLE)
{
    // ----------------------------------------------
    //
    // uninit ole if we need to
    //
    // ----------------------------------------------
    if (iBalanceOLE)
    {
        iisDebugOut_Start(_T("ole32:OleInitialize"),LOG_TYPE_TRACE_WIN32_API);
        OleUninitialize();
        iisDebugOut_End(_T("ole32:OleInitialize"),LOG_TYPE_TRACE_WIN32_API);
    }
    return;
}

BOOL SetupSetDirectoryId_Wrapper(HINF InfHandle,DWORD Id,LPCTSTR Directory)
{
    TCHAR szTempDir[_MAX_PATH];
    BOOL bTempFlag;

    // default it with something
    _tcscpy(szTempDir,Directory);

    if (_tcscmp(szTempDir, _T("")) != 0)
    {
        // Check if the passed in parameter looks like this:
        // %systemroot%\system32\inetsrv or something like that...
        LPTSTR pch = NULL;
        pch = _tcschr( (LPTSTR) Directory, _T('%'));
        if (pch)
        {
            if (!ExpandEnvironmentStrings( (LPCTSTR)Directory, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {_tcscpy(szTempDir,Directory);}
        }

        // Check to see if the old Drive still exists -- it may not because
        // the user could have added/removed a drive so now c:\winnt is really d:\winnt
        if (!IsFileExist(Directory))
        {
            TCHAR szDrive_only[_MAX_DRIVE];
            TCHAR szPath_only[_MAX_PATH];
            _tsplitpath( Directory, szDrive_only, szPath_only, NULL, NULL);

            // See if that drive exists...
            if (!IsFileExist(szDrive_only))
            {
                // the drive doesn't exist.
                // so replace it with the system drive.
                GetSystemDirectory(szTempDir, _MAX_PATH);
                // Get the DriveOnly
                _tsplitpath(szTempDir, szDrive_only, NULL, NULL, NULL);
                // Assemble the full path with the new drive
                _tcscpy(szTempDir, szDrive_only);
                _tcscat(szTempDir, szPath_only);
                // do some extra debug output so we can see what happend.
                iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! Not exist.  Instead use %2!s!\n"), Directory, szTempDir));
            }
        }
    }

    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!d!=%2!s!\n"), Id, szTempDir));
    bTempFlag = SetupSetDirectoryId(InfHandle,Id,szTempDir);

    // check for the alternate .inf file
    if (g_pTheApp->m_hInfHandleAlternate && InfHandle != g_pTheApp->m_hInfHandleAlternate)
    {
        bTempFlag = SetupSetDirectoryId(g_pTheApp->m_hInfHandleAlternate,Id,szTempDir);
    }

    return bTempFlag;
}

BOOL SetupSetStringId_Wrapper(HINF InfHandle,DWORD Id,LPCTSTR TheString)
{
    BOOL bTempFlag;
    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!d!=%2!s!\n"), Id, TheString));

    bTempFlag = SetupSetDirectoryIdEx(InfHandle,Id,TheString,SETDIRID_NOT_FULL_PATH,0,0);
    // check for the alternate .inf file
    if (g_pTheApp->m_hInfHandleAlternate && InfHandle != g_pTheApp->m_hInfHandleAlternate)
    {
        bTempFlag = SetupSetDirectoryIdEx(g_pTheApp->m_hInfHandleAlternate,Id,TheString,SETDIRID_NOT_FULL_PATH,0,0);
    }

    return bTempFlag;
}




//-------------------------------------------------------------------------------------
HRESULT FTestForOutstandingCoInits(void)
{
    HRESULT hInitRes = ERROR_SUCCESS;

#if defined(UNICODE) || defined(_UNICODE)
    // perform a defensive check
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("TestForOutstandingCoInits:...COINIT_MULTITHREADED\n")));
    hInitRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( SUCCEEDED(hInitRes) )
    {
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
        CoUninitialize();
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
    }
    else
    {
        goto FTestForOutstandingCoInits_Exit;
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("TestForOutstandingCoInits:...COINIT_APARTMENTTHREADED\n")));
    hInitRes = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if ( SUCCEEDED(hInitRes) )
    {
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
        CoUninitialize();
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
    }
    else
    {
        goto FTestForOutstandingCoInits_Exit;
    }
#endif

    // it worked out OK
    hInitRes = NOERROR;
    goto FTestForOutstandingCoInits_Exit;

FTestForOutstandingCoInits_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("TestForOutstandingCoInits:...End. Return=0x%x.\n"), hInitRes));
    return hInitRes;
}


void ReturnStringForMetabaseID(DWORD dwMetabaseID, LPTSTR lpReturnString)
{
    switch (dwMetabaseID)
    {
        case IIS_MD_SERVER_BASE:
            _tcscpy(lpReturnString, _T("IIS_MD_SERVER_BASE"));
            break;
        case MD_KEY_TYPE:
            _tcscpy(lpReturnString, _T("MD_KEY_TYPE"));
            break;
        case MD_MAX_BANDWIDTH_BLOCKED:
            _tcscpy(lpReturnString, _T("MD_MAX_BANDWIDTH_BLOCKED"));
            break;
        case MD_SERVER_COMMAND:
            _tcscpy(lpReturnString, _T("MD_SERVER_COMMAND"));
            break;
        case MD_CONNECTION_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_CONNECTION_TIMEOUT"));
            break;
        case MD_MAX_CONNECTIONS:
            _tcscpy(lpReturnString, _T("MD_MAX_CONNECTIONS"));
            break;
        case MD_SERVER_COMMENT:
            _tcscpy(lpReturnString, _T("MD_SERVER_COMMENT"));
            break;
        case MD_SERVER_STATE:
            _tcscpy(lpReturnString, _T("MD_SERVER_STATE"));
            break;
        case MD_SERVER_AUTOSTART:
            _tcscpy(lpReturnString, _T("MD_SERVER_AUTOSTART"));
            break;
        case MD_SERVER_SIZE:
            _tcscpy(lpReturnString, _T("MD_SERVER_SIZE"));
            break;
        case MD_SERVER_LISTEN_BACKLOG:
            _tcscpy(lpReturnString, _T("MD_SERVER_LISTEN_BACKLOG"));
            break;
        case MD_SERVER_LISTEN_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_SERVER_LISTEN_TIMEOUT"));
            break;
        case MD_DOWNLEVEL_ADMIN_INSTANCE:
            _tcscpy(lpReturnString, _T("MD_DOWNLEVEL_ADMIN_INSTANCE"));
            break;
        case MD_LEVELS_TO_SCAN:
            _tcscpy(lpReturnString, _T("MD_LEVELS_TO_SCAN"));
            break;
        case MD_SERVER_BINDINGS:
            _tcscpy(lpReturnString, _T("MD_SERVER_BINDINGS"));
            break;
        case MD_MAX_ENDPOINT_CONNECTIONS:
            _tcscpy(lpReturnString, _T("MD_MAX_ENDPOINT_CONNECTIONS"));
            break;
        case MD_SERVER_CONFIGURATION_INFO:
            _tcscpy(lpReturnString, _T("MD_SERVER_CONFIGURATION_INFO"));
            break;
        case MD_IISADMIN_EXTENSIONS:
            _tcscpy(lpReturnString, _T("MD_IISADMIN_EXTENSIONS"));
            break;
        case IIS_MD_HTTP_BASE:
            _tcscpy(lpReturnString, _T("IIS_MD_HTTP_BASE"));
            break;
        case MD_SECURE_BINDINGS:
            _tcscpy(lpReturnString, _T("MD_SECURE_BINDINGS"));
            break;
        case MD_FILTER_LOAD_ORDER:
            _tcscpy(lpReturnString, _T("MD_FILTER_LOAD_ORDER"));
            break;
        case MD_FILTER_IMAGE_PATH:
            _tcscpy(lpReturnString, _T("MD_FILTER_IMAGE_PATH"));
            break;
        case MD_FILTER_STATE:
            _tcscpy(lpReturnString, _T("MD_FILTER_STATE"));
            break;
        case MD_FILTER_ENABLED:
            _tcscpy(lpReturnString, _T("MD_FILTER_ENABLED"));
            break;
        case MD_FILTER_FLAGS:
            _tcscpy(lpReturnString, _T("MD_FILTER_FLAGS"));
            break;
        case MD_FILTER_DESCRIPTION:
            _tcscpy(lpReturnString, _T("MD_FILTER_DESCRIPTION"));
            break;
        case MD_ADV_NOTIFY_PWD_EXP_IN_DAYS:
            _tcscpy(lpReturnString, _T("MD_ADV_NOTIFY_PWD_EXP_IN_DAYS"));
            break;
        case MD_ADV_CACHE_TTL:
            _tcscpy(lpReturnString, _T("MD_ADV_CACHE_TTL"));
            break;
        case MD_AUTH_CHANGE_FLAGS:
            _tcscpy(lpReturnString, _T("MD_AUTH_CHANGE_FLAGS"));
            break;
        case MD_PROCESS_NTCR_IF_LOGGED_ON:
            _tcscpy(lpReturnString, _T("MD_PROCESS_NTCR_IF_LOGGED_ON"));
            break;
        case MD_FRONTPAGE_WEB:
            _tcscpy(lpReturnString, _T("MD_FRONTPAGE_WEB"));
            break;
        case MD_IN_PROCESS_ISAPI_APPS:
            _tcscpy(lpReturnString, _T("MD_IN_PROCESS_ISAPI_APPS"));
            break;
        case MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS:
            _tcscpy(lpReturnString, _T("MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS"));
            break;
        case MD_APP_FRIENDLY_NAME:
            _tcscpy(lpReturnString, _T("MD_APP_FRIENDLY_NAME"));
            break;
        case MD_APP_ROOT:
            _tcscpy(lpReturnString, _T("MD_APP_ROOT"));
            break;
        case MD_APP_ISOLATED:
            _tcscpy(lpReturnString, _T("MD_APP_ISOLATED"));
            break;
        case MD_APP_WAM_CLSID:
            _tcscpy(lpReturnString, _T("MD_APP_WAM_CLSID"));
            break;
        case MD_APP_PACKAGE_ID:
            _tcscpy(lpReturnString, _T("MD_APP_PACKAGE_ID"));
            break;
        case MD_APP_PACKAGE_NAME:
            _tcscpy(lpReturnString, _T("MD_APP_PACKAGE_NAME"));
            break;
        case MD_APP_OOP_RECOVER_LIMIT:
            _tcscpy(lpReturnString, _T("MD_APP_OOP_RECOVER_LIMIT"));
            break;
        case MD_ADMIN_INSTANCE:
            _tcscpy(lpReturnString, _T("MD_ADMIN_INSTANCE"));
            break;
        case MD_CUSTOM_ERROR_DESC:
            _tcscpy(lpReturnString, _T("MD_CUSTOM_ERROR_DESC"));
            break;
        case MD_CPU_RESET_INTERVAL:
            _tcscpy(lpReturnString, _T("MD_CPU_RESET_INTERVAL"));
            break;
        case MD_MD_SERVER_SS_AUTH_MAPPING:
            _tcscpy(lpReturnString, _T("MD_MD_SERVER_SS_AUTH_MAPPING"));
            break;
        case MD_HC_COMPRESSION_DIRECTORY:
            _tcscpy(lpReturnString, _T("MD_HC_COMPRESSION_DIRECTORY"));
            break;
        case MD_HC_CACHE_CONTROL_HEADER:
            _tcscpy(lpReturnString, _T("MD_HC_CACHE_CONTROL_HEADER"));
            break;
        case MD_HC_EXPIRES_HEADER:
            _tcscpy(lpReturnString, _T("MD_HC_EXPIRES_HEADER"));
            break;
        case MD_HC_DO_DYNAMIC_COMPRESSION:
            _tcscpy(lpReturnString, _T("MD_HC_DO_DYNAMIC_COMPRESSION"));
            break;
        case MD_HC_DO_STATIC_COMPRESSION:
            _tcscpy(lpReturnString, _T("MD_HC_DO_STATIC_COMPRESSION"));
            break;
        case MD_HC_DO_ON_DEMAND_COMPRESSION:
            _tcscpy(lpReturnString, _T("MD_HC_DO_ON_DEMAND_COMPRESSION"));
            break;
        case MD_HC_DO_DISK_SPACE_LIMITING:
            _tcscpy(lpReturnString, _T("MD_HC_DO_DISK_SPACE_LIMITING"));
            break;
        case MD_HC_NO_COMPRESSION_FOR_HTTP_10:
            _tcscpy(lpReturnString, _T("MD_HC_NO_COMPRESSION_FOR_HTTP_10"));
            break;
        case MD_HC_NO_COMPRESSION_FOR_PROXIES:
            _tcscpy(lpReturnString, _T("MD_HC_NO_COMPRESSION_FOR_PROXIES"));
            break;
        case MD_HC_NO_COMPRESSION_FOR_RANGE:
            _tcscpy(lpReturnString, _T("MD_HC_NO_COMPRESSION_FOR_RANGE"));
            break;
        case MD_HC_SEND_CACHE_HEADERS:
            _tcscpy(lpReturnString, _T("MD_HC_SEND_CACHE_HEADERS"));
            break;
        case MD_HC_MAX_DISK_SPACE_USAGE:
            _tcscpy(lpReturnString, _T("MD_HC_MAX_DISK_SPACE_USAGE"));
            break;
        case MD_HC_IO_BUFFER_SIZE:
            _tcscpy(lpReturnString, _T("MD_HC_IO_BUFFER_SIZE"));
            break;
        case MD_HC_COMPRESSION_BUFFER_SIZE:
            _tcscpy(lpReturnString, _T("MD_HC_COMPRESSION_BUFFER_SIZE"));
            break;
        case MD_HC_MAX_QUEUE_LENGTH:
            _tcscpy(lpReturnString, _T("MD_HC_MAX_QUEUE_LENGTH"));
            break;
        case MD_HC_FILES_DELETED_PER_DISK_FREE:
            _tcscpy(lpReturnString, _T("MD_HC_FILES_DELETED_PER_DISK_FREE"));
            break;
        case MD_HC_MIN_FILE_SIZE_FOR_COMP:
            _tcscpy(lpReturnString, _T("MD_HC_MIN_FILE_SIZE_FOR_COMP"));
            break;
        case MD_HC_COMPRESSION_DLL:
            _tcscpy(lpReturnString, _T("MD_HC_COMPRESSION_DLL"));
            break;
        case MD_HC_FILE_EXTENSIONS:
            _tcscpy(lpReturnString, _T("MD_HC_FILE_EXTENSIONS"));
            break;
        case MD_HC_PRIORITY:
            _tcscpy(lpReturnString, _T("MD_HC_PRIORITY"));
            break;
        case MD_HC_DYNAMIC_COMPRESSION_LEVEL:
            _tcscpy(lpReturnString, _T("MD_HC_DYNAMIC_COMPRESSION_LEVEL"));
            break;
        case MD_HC_ON_DEMAND_COMP_LEVEL:
            _tcscpy(lpReturnString, _T("MD_HC_ON_DEMAND_COMP_LEVEL"));
            break;
        case MD_HC_CREATE_FLAGS:
            _tcscpy(lpReturnString, _T("MD_HC_CREATE_FLAGS"));
            break;
        case MD_WIN32_ERROR:
            _tcscpy(lpReturnString, _T("MD_WIN32_ERROR"));
            break;
        case IIS_MD_VR_BASE:
            _tcscpy(lpReturnString, _T("IIS_MD_VR_BASE"));
            break;
        case MD_VR_PATH:
            _tcscpy(lpReturnString, _T("MD_VR_PATH"));
            break;
        case MD_VR_USERNAME:
            _tcscpy(lpReturnString, _T("MD_VR_USERNAME"));
            break;
        case MD_VR_PASSWORD:
            _tcscpy(lpReturnString, _T("MD_VR_PASSWORD"));
            break;
        case MD_VR_PASSTHROUGH:
            _tcscpy(lpReturnString, _T("MD_VR_PASSTHROUGH"));
            break;
        case MD_LOG_TYPE:
            _tcscpy(lpReturnString, _T("MD_LOG_TYPE"));
            break;
        case MD_LOGFILE_DIRECTORY:
            _tcscpy(lpReturnString, _T("MD_LOGFILE_DIRECTORY"));
            break;
        case MD_LOG_UNUSED1:
            _tcscpy(lpReturnString, _T("MD_LOG_UNUSED1"));
            break;
        case MD_LOGFILE_PERIOD:
            _tcscpy(lpReturnString, _T("MD_LOGFILE_PERIOD"));
            break;
        case MD_LOGFILE_TRUNCATE_SIZE:
            _tcscpy(lpReturnString, _T("MD_LOGFILE_TRUNCATE_SIZE"));
            break;
        case MD_LOG_PLUGIN_MOD_ID:
            _tcscpy(lpReturnString, _T("MD_LOG_PLUGIN_MOD_ID"));
            break;
        case MD_LOG_PLUGIN_UI_ID:
            _tcscpy(lpReturnString, _T("MD_LOG_PLUGIN_UI_ID"));
            break;
        case MD_LOGSQL_DATA_SOURCES:
            _tcscpy(lpReturnString, _T("MD_LOGSQL_DATA_SOURCES"));
            break;
        case MD_LOGSQL_TABLE_NAME:
            _tcscpy(lpReturnString, _T("MD_LOGSQL_TABLE_NAME"));
            break;
        case MD_LOGSQL_USER_NAME:
            _tcscpy(lpReturnString, _T("MD_LOGSQL_USER_NAME"));
            break;
        case MD_LOGSQL_PASSWORD:
            _tcscpy(lpReturnString, _T("MD_LOGSQL_PASSWORD"));
            break;
        case MD_LOG_PLUGIN_ORDER:
            _tcscpy(lpReturnString, _T("MD_LOG_PLUGIN_ORDER"));
            break;
        case MD_LOG_PLUGINS_AVAILABLE:
            _tcscpy(lpReturnString, _T("MD_LOG_PLUGINS_AVAILABLE"));
            break;
        case MD_LOGEXT_FIELD_MASK:
            _tcscpy(lpReturnString, _T("MD_LOGEXT_FIELD_MASK"));
            break;
        case MD_LOGEXT_FIELD_MASK2:
            _tcscpy(lpReturnString, _T("MD_LOGEXT_FIELD_MASK2"));
            break;
        case MD_LOGFILE_LOCALTIME_ROLLOVER:
            _tcscpy(lpReturnString, _T("MD_LOGFILE_LOCALTIME_ROLLOVER"));
            break;
        case IIS_MD_LOGCUSTOM_BASE:
            _tcscpy(lpReturnString, _T("IIS_MD_LOGCUSTOM_BASE"));
            break;
        case MD_LOGCUSTOM_PROPERTY_NAME:
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_NAME"));
            break;
        case MD_LOGCUSTOM_PROPERTY_HEADER:
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_HEADER"));
            break;
        case MD_LOGCUSTOM_PROPERTY_ID:
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_ID"));
            break;
        case MD_LOGCUSTOM_PROPERTY_MASK:
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_MASK"));
            break;
        case MD_LOGCUSTOM_PROPERTY_DATATYPE:
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_DATATYPE"));
            break;
        case MD_LOGCUSTOM_SERVICES_STRING:
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_SERVICES_STRING"));
            break;
        case IIS_MD_FTP_BASE:
            _tcscpy(lpReturnString, _T("IIS_MD_FTP_BASE"));
            break;
        case MD_EXIT_MESSAGE:
            _tcscpy(lpReturnString, _T("MD_EXIT_MESSAGE"));
            break;
        case MD_GREETING_MESSAGE:
            _tcscpy(lpReturnString, _T("MD_GREETING_MESSAGE"));
            break;
        case MD_MAX_CLIENTS_MESSAGE:
            _tcscpy(lpReturnString, _T("MD_MAX_CLIENTS_MESSAGE"));
            break;
        case MD_MSDOS_DIR_OUTPUT:
            _tcscpy(lpReturnString, _T("MD_MSDOS_DIR_OUTPUT"));
            break;
        case MD_ALLOW_ANONYMOUS:
            _tcscpy(lpReturnString, _T("MD_ALLOW_ANONYMOUS"));
            break;
        case MD_ANONYMOUS_ONLY:
            _tcscpy(lpReturnString, _T("MD_ANONYMOUS_ONLY"));
            break;
        case MD_LOG_ANONYMOUS:
            _tcscpy(lpReturnString, _T("MD_LOG_ANONYMOUS"));
            break;
        case MD_LOG_NONANONYMOUS:
            _tcscpy(lpReturnString, _T("MD_LOG_NONANONYMOUS"));
            break;
        case MD_ALLOW_REPLACE_ON_RENAME:
            _tcscpy(lpReturnString, _T("MD_ALLOW_REPLACE_ON_RENAME"));
            break;
        case MD_SSL_PUBLIC_KEY:
            _tcscpy(lpReturnString, _T("MD_SSL_PUBLIC_KEY"));
            break;
        case MD_SSL_PRIVATE_KEY:
            _tcscpy(lpReturnString, _T("MD_SSL_PRIVATE_KEY"));
            break;
        case MD_SSL_KEY_PASSWORD:
            _tcscpy(lpReturnString, _T("MD_SSL_KEY_PASSWORD"));
            break;
        case MD_SSL_KEY_REQUEST:
            _tcscpy(lpReturnString, _T("MD_SSL_KEY_REQUEST"));
            break;
        case MD_AUTHORIZATION:
            _tcscpy(lpReturnString, _T("MD_AUTHORIZATION"));
            break;
        case MD_REALM:
            _tcscpy(lpReturnString, _T("MD_REALM"));
            break;
        case MD_HTTP_EXPIRES:
            _tcscpy(lpReturnString, _T("MD_HTTP_EXPIRES"));
            break;
        case MD_HTTP_PICS:
            _tcscpy(lpReturnString, _T("MD_HTTP_PICS"));
            break;
        case MD_HTTP_CUSTOM:
            _tcscpy(lpReturnString, _T("MD_HTTP_CUSTOM"));
            break;
        case MD_DIRECTORY_BROWSING:
            _tcscpy(lpReturnString, _T("MD_DIRECTORY_BROWSING"));
            break;
        case MD_DEFAULT_LOAD_FILE:
            _tcscpy(lpReturnString, _T("MD_DEFAULT_LOAD_FILE"));
            break;
        case MD_CUSTOM_ERROR:
            _tcscpy(lpReturnString, _T("MD_CUSTOM_ERROR"));
            break;
        case MD_FOOTER_DOCUMENT:
            _tcscpy(lpReturnString, _T("MD_FOOTER_DOCUMENT"));
            break;
        case MD_FOOTER_ENABLED:
            _tcscpy(lpReturnString, _T("MD_FOOTER_ENABLED"));
            break;
        case MD_HTTP_REDIRECT:
            _tcscpy(lpReturnString, _T("MD_HTTP_REDIRECT"));
            break;
        case MD_DEFAULT_LOGON_DOMAIN:
            _tcscpy(lpReturnString, _T("MD_DEFAULT_LOGON_DOMAIN"));
            break;
        case MD_LOGON_METHOD:
            _tcscpy(lpReturnString, _T("MD_LOGON_METHOD"));
            break;
        case MD_SCRIPT_MAPS:
            _tcscpy(lpReturnString, _T("MD_SCRIPT_MAPS"));
            break;
        case MD_MIME_MAP:
            _tcscpy(lpReturnString, _T("MD_MIME_MAP"));
            break;
        case MD_ACCESS_PERM:
            _tcscpy(lpReturnString, _T("MD_ACCESS_PERM"));
            break;
        case MD_IP_SEC:
            _tcscpy(lpReturnString, _T("MD_IP_SEC"));
            break;
        case MD_ANONYMOUS_USER_NAME:
            _tcscpy(lpReturnString, _T("MD_ANONYMOUS_USER_NAME"));
            break;
        case MD_ANONYMOUS_PWD:
            _tcscpy(lpReturnString, _T("MD_ANONYMOUS_PWD"));
            break;
        case MD_ANONYMOUS_USE_SUBAUTH:
            _tcscpy(lpReturnString, _T("MD_ANONYMOUS_USE_SUBAUTH"));
            break;
        case MD_DONT_LOG:
            _tcscpy(lpReturnString, _T("MD_DONT_LOG"));
            break;
        case MD_ADMIN_ACL:
            _tcscpy(lpReturnString, _T("MD_ADMIN_ACL"));
            break;
        case MD_SSI_EXEC_DISABLED:
            _tcscpy(lpReturnString, _T("MD_SSI_EXEC_DISABLED"));
            break;
        case MD_DO_REVERSE_DNS:
            _tcscpy(lpReturnString, _T("MD_DO_REVERSE_DNS"));
            break;
        case MD_SSL_ACCESS_PERM:
            _tcscpy(lpReturnString, _T("MD_SSL_ACCESS_PERM"));
            break;
        case MD_AUTHORIZATION_PERSISTENCE:
            _tcscpy(lpReturnString, _T("MD_AUTHORIZATION_PERSISTENCE"));
            break;
        case MD_NTAUTHENTICATION_PROVIDERS:
            _tcscpy(lpReturnString, _T("MD_NTAUTHENTICATION_PROVIDERS"));
            break;
        case MD_SCRIPT_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_SCRIPT_TIMEOUT"));
            break;
        case MD_CACHE_EXTENSIONS:
            _tcscpy(lpReturnString, _T("MD_CACHE_EXTENSIONS"));
            break;
        case MD_CREATE_PROCESS_AS_USER:
            _tcscpy(lpReturnString, _T("MD_CREATE_PROCESS_AS_USER"));
            break;
        case MD_CREATE_PROC_NEW_CONSOLE:
            _tcscpy(lpReturnString, _T("MD_CREATE_PROC_NEW_CONSOLE"));
            break;
        case MD_POOL_IDC_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_POOL_IDC_TIMEOUT"));
            break;
        case MD_ALLOW_KEEPALIVES:
            _tcscpy(lpReturnString, _T("MD_ALLOW_KEEPALIVES"));
            break;
        case MD_IS_CONTENT_INDEXED:
            _tcscpy(lpReturnString, _T("MD_IS_CONTENT_INDEXED"));
            break;
        case MD_CC_NO_CACHE:
            _tcscpy(lpReturnString, _T("MD_CC_NO_CACHE"));
            break;
        case MD_CC_MAX_AGE:
            _tcscpy(lpReturnString, _T("MD_CC_MAX_AGE"));
            break;
        case MD_CC_OTHER:
            _tcscpy(lpReturnString, _T("MD_CC_OTHER"));
            break;
        case MD_REDIRECT_HEADERS:
            _tcscpy(lpReturnString, _T("MD_REDIRECT_HEADERS"));
            break;
        case MD_UPLOAD_READAHEAD_SIZE:
            _tcscpy(lpReturnString, _T("MD_UPLOAD_READAHEAD_SIZE"));
            break;
        case MD_PUT_READ_SIZE:
            _tcscpy(lpReturnString, _T("MD_PUT_READ_SIZE"));
            break;
        case MD_WAM_USER_NAME:
            _tcscpy(lpReturnString, _T("MD_WAM_USER_NAME"));
            break;
        case MD_WAM_PWD:
            _tcscpy(lpReturnString, _T("MD_WAM_PWD"));
            break;
        case MD_SCHEMA_METAID:
            _tcscpy(lpReturnString, _T("MD_SCHEMA_METAID"));
            break;
        case MD_DISABLE_SOCKET_POOLING:
            _tcscpy(lpReturnString, _T("MD_DISABLE_SOCKET_POOLING"));
            break;
        case MD_METADATA_ID_REGISTRATION:
            _tcscpy(lpReturnString, _T("MD_METADATA_ID_REGISTRATION"));
            break;
        case MD_HC_SCRIPT_FILE_EXTENSIONS:
            _tcscpy(lpReturnString, _T("MD_HC_SCRIPT_FILE_EXTENSIONS"));
            break;
        case MD_SHOW_4_DIGIT_YEAR:
            _tcscpy(lpReturnString, _T("MD_SHOW_4_DIGIT_YEAR"));
            break;
        case MD_SSL_USE_DS_MAPPER:
            _tcscpy(lpReturnString, _T("MD_SSL_USE_DS_MAPPER"));
            break;
        case MD_FILTER_ENABLE_CACHE:
            _tcscpy(lpReturnString, _T("MD_FILTER_ENABLE_CACHE"));
            break;
        case MD_USE_DIGEST_SSP:
            _tcscpy(lpReturnString, _T("MD_USE_DIGEST_SSP"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_TIME:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_TIME"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT"));
            break;
        case MD_APPPOOL_MAX_PROCESS_COUNT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_MAX_PROCESS_COUNT"));
            break;
        case MD_APPPOOL_PINGING_ENABLED:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PINGING_ENABLED"));
            break;
        case MD_APPPOOL_IDLE_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_IDLE_TIMEOUT"));
            break;
        case MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_RAPID_F_PROTECTION_ENABLED"));
            break;
        case MD_APPPOOL_SMP_AFFINITIZED:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_SMP_AFFINITIZED"));
            break;
        case MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK"));
            break;
        case MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING"));
            break;
        case MD_APPPOOL_STARTUP_TIMELIMIT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_STARTUP_TIMELIMIT"));
            break;
        case MD_APPPOOL_SHUTDOWN_TIMELIMIT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_SHUTDOWN_TIMELIMIT"));
            break;
        case MD_APPPOOL_PING_INTERVAL:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PING_INTERVAL"));
            break;
        case MD_APPPOOL_PING_RESPONSE_TIMELIMIT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PING_RESPONSE_TIMELIMIT"));
            break;
        case MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION"));
            break;
        case MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH"));
            break;
        case MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_SCHEDULE:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_SCHEDULE"));
            break;
        case MD_APPPOOL_IDENTITY_TYPE:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_IDENTITY_TYPE"));
            break;
        case MD_CPU_ACTION:
            _tcscpy(lpReturnString, _T("MD_CPU_ACTION"));
            break;
        case MD_CPU_LIMIT:
            _tcscpy(lpReturnString, _T("MD_CPU_LIMIT"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_MEMORY:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_MEMORY"));
            break;
        case MD_APP_APPPOOL_ID:
            _tcscpy(lpReturnString, _T("MD_APP_APPPOOL_ID"));
            break;
        case MD_APP_ALLOW_TRANSIENT_REGISTRATION:
            _tcscpy(lpReturnString, _T("MD_APP_ALLOW_TRANSIENT_REGISTRATION"));
            break;
        case MD_APP_AUTO_START:
            _tcscpy(lpReturnString, _T("MD_APP_AUTO_START"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS"));
            break;
        case MD_MAX_GLOBAL_BANDWIDTH:
            _tcscpy(lpReturnString, _T("MD_MAX_GLOBAL_BANDWIDTH"));
            break;
        case MD_GLOBAL_STANDARD_APP_MODE_ENABLED:
            _tcscpy(lpReturnString, _T("MD_GLOBAL_STANDARD_APP_MODE_ENABLED"));
            break;
        case MD_HEADER_WAIT_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_HEADER_WAIT_TIMEOUT"));
            break;
        case MD_MIN_FILE_BYTES_PER_SEC:
            _tcscpy(lpReturnString, _T("MD_MIN_FILE_BYTES_PER_SEC"));
            break;
        case MD_GLOBAL_LOG_IN_UTF_8:
            _tcscpy(lpReturnString, _T("MD_GLOBAL_LOG_IN_UTF_8"));
            break;
        case MD_ASP_ENABLEPARENTPATHS:
            _tcscpy(lpReturnString, _T("MD_ASP_ENABLEPARENTPATHS"));
            break;
        case ASP_MD_SERVER_BASE:
        case MD_ASP_LOGERRORREQUESTS:
        case MD_ASP_SCRIPTERRORSSENTTOBROWSER:
        case MD_ASP_SCRIPTERRORMESSAGE:
        case MD_ASP_SCRIPTFILECACHESIZE:
        case MD_ASP_SCRIPTENGINECACHEMAX:
        case MD_ASP_SCRIPTTIMEOUT:
        case MD_ASP_SESSIONTIMEOUT:
        case MD_ASP_MEMFREEFACTOR:
        case MD_ASP_MINUSEDBLOCKS:
        case MD_ASP_ALLOWSESSIONSTATE:
        case MD_ASP_SCRIPTLANGUAGE:
        case MD_ASP_QUEUETIMEOUT:
        case MD_ASP_ALLOWOUTOFPROCCOMPONENTS:
        case MD_ASP_EXCEPTIONCATCHENABLE:
        case MD_ASP_CODEPAGE:
        case MD_ASP_SCRIPTLANGUAGELIST:
        case MD_ASP_ENABLESERVERDEBUG:
        case MD_ASP_ENABLECLIENTDEBUG:
        case MD_ASP_TRACKTHREADINGMODEL:
        case MD_ASP_ENABLEASPHTMLFALLBACK:
        case MD_ASP_ENABLECHUNKEDENCODING:
        case MD_ASP_ENABLETYPELIBCACHE:
        case MD_ASP_ERRORSTONTLOG:
        case MD_ASP_PROCESSORTHREADMAX:
        case MD_ASP_REQEUSTQUEUEMAX:
        case MD_ASP_ENABLEAPPLICATIONRESTART:
        case MD_ASP_QUEUECONNECTIONTESTTIME:
        case MD_ASP_SESSIONMAX:
            _tcscpy(lpReturnString, _T("MD_ASP_????"));
            break;
        case WAM_MD_SERVER_BASE:
            _tcscpy(lpReturnString, _T("WAM_MD_SERVER_BASE"));
            break;
        default:
            _stprintf(lpReturnString, _T("%d"), dwMetabaseID);
            break;
    }
    return;
}

void SetErrorFlag(char *szFileName, int iLineNumber)
{
    // set flag to say that there was an error!!!
    g_pTheApp->m_bThereWereErrorsChkLogfile = TRUE;
    return;
}

BOOL
IsContinuedLine(BUFFER *pBuff)
{
  LPTSTR szContinueChar;

  if (!pBuff)
  {
    return FALSE;
  }

  szContinueChar = _tcsrchr( (LPTSTR)pBuff->QueryPtr(), '\\' );

  if (!szContinueChar)
  {
    return FALSE;
  }

  while ( ( *szContinueChar) &&
          ( (*szContinueChar == ' ') || (*szContinueChar == '\t') )
        )
  {
    szContinueChar++;
  }

  return (*szContinueChar == '\0');
}

DWORD FillStrListWithListOfSections(IN HINF hFile, CStringList &strList, IN LPCTSTR szSection)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;
    INFCONTEXT Context;
    BUFFER  bBuff;

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
        {
        dwReturn = ERROR_PATH_NOT_FOUND;
        goto FillStrListWithListOfSections_Exit;
        }

    // loop through the items in the section.
    while (b)
    {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        dwRequiredSize = (dwRequiredSize + 1) * sizeof(TCHAR);

        // prepare the buffer to receive the line
        if (dwRequiredSize > bBuff.QuerySize())
        {
          if (!bBuff.Resize( dwRequiredSize ))
          {
            return dwReturn;
          }
        }

        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, (LPTSTR) bBuff.QueryPtr(), bBuff.QuerySize()/sizeof(TCHAR), NULL) == FALSE)
            {
            iisDebugOut((LOG_TYPE_ERROR, _T("FillStrListWithListOfSections %s. Failed on SetupGetLineText.\n"), szSection));
            goto FillStrListWithListOfSections_Exit;
            }

        while ( IsContinuedLine(&bBuff) &&
                SetupFindNextLine(&Context, &Context)
              )
        {
          // get the size of the memory we need for this
          b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

          dwRequiredSize = (dwRequiredSize + 1 + _tcslen((LPTSTR) bBuff.QueryPtr())) * sizeof(TCHAR);
          if ( !bBuff.Resize(dwRequiredSize + 2) )
          {
            return dwReturn;
          }

          if (SetupGetLineText(&Context,
                                NULL,
                                NULL,
                                NULL,
                                (LPTSTR) bBuff.QueryPtr() + _tcslen((LPTSTR) bBuff.QueryPtr()),
                                bBuff.QuerySize()/sizeof(TCHAR)-_tcslen((LPTSTR) bBuff.QueryPtr()),
                                NULL) == FALSE)
          {
            iisDebugOut((LOG_TYPE_ERROR, _T("FillStrListWithListOfSections %s. Failed on SetupGetLineText.\n"), szSection));
            goto FillStrListWithListOfSections_Exit;
          }
        }

        // Add it to the list
        strList.AddTail((LPTSTR) bBuff.QueryPtr());

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);
    }

FillStrListWithListOfSections_Exit:
    return dwReturn;
}


void DisplayStringForMetabaseID(DWORD dwMetabaseID)
{
    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(dwMetabaseID, lpReturnString);
    iisDebugOut((LOG_TYPE_TRACE, _T("%d=%s\n"), dwMetabaseID, lpReturnString));
    return;
}


DWORD WINAPI MessageBoxFreeThread_MTS(LPVOID p)
{
    HRESULT nNetErr = (HRESULT) gTempMTSError.dwErrorCode;
    TCHAR pMsg[_MAX_PATH] = _T("");
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, gTempMTSError.dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0)
    {
        if (nNetErr >= NERR_BASE)
                {
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll)
                        {
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, gTempMTSError.dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    CString csErrorString;
    MyLoadString(IDS_SETUP_ERRORS_ENCOUNTERED_MTS, csErrorString);

    CString csErrArea;
    MyLoadString(gTempMTSError.iMtsThingWeWereDoing, csErrArea);

    CString csTitle;
    MyLoadString(IDS_MTS_ERROR_TITLEBAR, csTitle);

    CString csMsg;
    csMsg.Format(csErrorString, csErrArea);

    CString csErrMsg;
    HandleSpecificErrors(gTempMTSError.dwErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    MyMessageBox(NULL, csErrMsg, csTitle, MB_OK | MB_SETFOREGROUND);

        return 0;
}


DWORD WINAPI MessageBoxFreeThread_IIS(PVOID p)
{
    INT_PTR iStringID = (INT_PTR) p;
    MyMessageBox(NULL, (UINT) iStringID, g_MyLogFile.m_szLogFileName_Full, MB_OK | MB_SETFOREGROUND);
        return 0;
}

void MesssageBoxErrors_IIS(void)
{
    if (g_pTheApp->m_bThereWereErrorsChkLogfile == TRUE)
    {
        int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;

        g_pTheApp->m_bAllowMessageBoxPopups = TRUE;

        DWORD   id;
        INT_PTR iStringID = IDS_SETUP_ERRORS_ENCOUNTERED;

        // show the messagebox display from another thread, so that setup can continue!
        HANDLE  hProc = NULL;
        hProc = CreateThread(NULL, 0, MessageBoxFreeThread_IIS, (PVOID) iStringID, 0, &id);
        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;

        CString csErrMsg;
        TCHAR szErrorString[255] = _T("");
        MyLoadString(IDS_SETUP_ERRORS_ENCOUNTERED, csErrMsg);
        _stprintf(szErrorString, csErrMsg, g_MyLogFile.m_szLogFileName_Full);

        //LogSevInformation           0x00000000
        //LogSevWarning               0x00000001
        //LogSevError                 0x00000002
        //LogSevFatalError            0x00000003
        //LogSevMaximum               0x00000004
        // Write it to the setupapi log file!
        if ( *szErrorString )
        {
          SetupLogError(szErrorString, LogSevError);
        }
    }
    return;
}


void MesssageBoxErrors_MTS(int iMtsThingWeWereDoing, DWORD dwErrorCode)
{
    if (!g_pTheApp->m_bThereWereErrorsFromMTS)
    {
        DWORD   id;
        int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;

        gTempMTSError.iMtsThingWeWereDoing = iMtsThingWeWereDoing;
        gTempMTSError.dwErrorCode = dwErrorCode;

        g_pTheApp->m_bAllowMessageBoxPopups = TRUE;

        // show the messagebox display from another thread, so that setup can continue!
        HANDLE  hProc = NULL;
        hProc = CreateThread(NULL, 0, MessageBoxFreeThread_MTS, 0, 0, &id);

        if ( hProc != NULL )
        {
            CloseHandle( hProc );
        }

        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;

        g_pTheApp->m_bThereWereErrorsFromMTS = TRUE;
    }

    return;
}


void PleaseKillOrStopTheseExeFromRunning(LPCTSTR szModuleWhichIsLocked, CStringList &strList)
{
    if (strList.IsEmpty() == FALSE)
    {
        POSITION pos;
        CString csExeName;
        int nLen = 0;

        TCHAR szReturnedServiceName[_MAX_PATH];

        pos = strList.GetHeadPosition();
        while (pos)
        {
            csExeName = strList.GetAt(pos);
            nLen = 0;
            nLen = csExeName.GetLength();

            if (nLen > 0)
            {
                //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!s! is locking %2!s! service and is locking %3!s!\n"),csExeName, szModuleWhichIsLocked));

                if (TRUE == InetIsThisExeAService(csExeName, szReturnedServiceName))
                {
                    iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! is the %2!s! service and is locking %3!s!.  Let's stop that service.\n"),csExeName,szReturnedServiceName, szModuleWhichIsLocked));

                    // Check if it is the netlogon service, We no don't want to stop this service for sure!!!
                    /*
                    if (_tcsicmp(szReturnedServiceName, _T("NetLogon")) == 0)
                    {
                        // no we do not want to stop this service!!!
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, szModuleWhichIsLocked));
                        break;
                    }
                    */

                    // Don't stop any services which are not win32 services
                    // Don't stop any system services...
                    if (TRUE == IsThisOnNotStopList(g_pTheApp->m_hInfHandle, szReturnedServiceName, TRUE))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, szModuleWhichIsLocked));
                    }
                    else
                    {
                      // add this service to the list of
                      // services we need to restart after setup is done!!
                      ServicesRestartList_Add(szReturnedServiceName);

                      // Check the list of services which we are sure we do not want to stop!

                      // net stop it
                      InetStopService(szReturnedServiceName);
                    }
                    // otherwise go on to the next .exe file
                }
                else
                {
                    // This .exe file is not a Service....
                    // Should we kill it???????

                    if (TRUE == IsThisOnNotStopList(g_pTheApp->m_hInfHandle, csExeName, FALSE))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is locking it. This process should not be killed\n"),csExeName));
                    }
                    else
                    {
                      // Check the list of .exe which we are sure we do not want to kill!
                      iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! is locking %2!s!.  Let's kill that process.\n"),csExeName,szModuleWhichIsLocked));
                      KillProcess_Wrap(csExeName);
                    }
                }
            }
            strList.GetNext(pos);
        }
    }

    return;
}

void ShowIfModuleUsedForThisINFSection(IN HINF hFile, IN LPCTSTR szSection, int iUnlockThem)
{
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;
    CString csFile;

    INFCONTEXT Context;

    TCHAR buf[_MAX_PATH];
    GetSystemDirectory( buf, _MAX_PATH);

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
        {
        goto ShowIfModuleUsedForThisINFSection_Exit;
        }

    // loop through the items in the section.
    while (b)
    {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            goto ShowIfModuleUsedForThisINFSection_Exit;
            }

        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            goto ShowIfModuleUsedForThisINFSection_Exit;
            }

        // Attach the path to the from of this...
        // check in this directory:
        // 1. winnt\system32
        // --------------------------------------

        // may look like this "iisrtl.dll,,4"
        // so get rid of the ',,4'
        LPTSTR pch = NULL;
        pch = _tcschr(szLine, _T(','));
        if (pch) {_tcscpy(pch, _T(" "));}

        // Remove any trailing spaces.
        StripLastBackSlash(szLine);

        // Get the system dir
        csFile = buf;

        csFile = AddPath(csFile, szLine);

        CStringList strList;
        strList.RemoveAll();

        LogProcessesUsingThisModule(csFile, strList);

        // if we're supposed to unlock this file, then
        // we'll try it.
        if (iUnlockThem)
        {
            PleaseKillOrStopTheseExeFromRunning(csFile, strList);
        }

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );
        szLine = NULL;
    }

    // free some memory used for the task list
    FreeTaskListMem();
    UnInit_Lib_PSAPI();

    if (szLine) {GlobalFree(szLine);szLine=NULL;}

ShowIfModuleUsedForThisINFSection_Exit:
    return;
}


void ShowIfModuleUsedForGroupOfSections(IN HINF hFile, int iUnlockThem)
{
    CStringList strList;
    TSTR strTheSection;

    if ( !strTheSection.Copy( _T("VerifyFileSections_Lockable") ) )
    {
      return;
    }

    if (GetSectionNameToDo(hFile, &strTheSection))
    {
        if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, strTheSection.QueryStr()))
        {
            // loop thru the list returned back
            if (strList.IsEmpty() == FALSE)
            {
                POSITION pos;
                CString csEntry;

                pos = strList.GetHeadPosition();
                while (pos)
                {
                    csEntry = strList.GetAt(pos);
                    ShowIfModuleUsedForThisINFSection(hFile, csEntry, iUnlockThem);
                    strList.GetNext(pos);
                }
            }
        }
    }

    return;
}


int ReadGlobalsFromInf(HINF InfHandle)
{
    int iReturn = FALSE;
    INFCONTEXT Context;
    TCHAR szTempString[_MAX_PATH] = _T("");

    //
    // Set the m_csAppName
    //
    if (!SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("AppName"), &Context) )
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupFindFirstLine_Wrapped(SetupInfo, AppName) FAILED")));}
    if (!SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupGetStringField(SetupInfo, AppName) FAILED")));}
    // Set the global.
    g_pTheApp->m_csAppName = szTempString;

    //
    // Set the m_csIISGroupName
    //
    _tcscpy(szTempString, _T(""));
    if (!SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("StartMenuGroupName"), &Context) )
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupFindFirstLine_Wrapped(SetupInfo, StartMenuGroupName) FAILED")));}
    if (!SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupGetStringField(SetupInfo, StartMenuGroupName) FAILED")));}
    g_pTheApp->m_csIISGroupName = szTempString;
    iReturn = TRUE;

    //
    // Get the value of one tick on the progressbar
    //
    g_GlobalTickValue = 1;
    _tcscpy(szTempString, _T(""));
    SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("OneTick"), &Context);
    if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {g_GlobalTickValue = _ttoi(szTempString);}

    //
    // See if we want to fake out setup when it's running in add\remove, to think it's actually guimode
    //
    g_GlobalGuiOverRide = 0;
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("GuiMode"), &Context))
    {
      if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
          {g_GlobalGuiOverRide = _ttoi(szTempString);}
    }


    return iReturn;
}


int CheckIfPlatformMatchesInf(HINF InfHandle)
{
    int iReturn = TRUE;
    INFCONTEXT Context;

    TCHAR szPlatform[_MAX_PATH] = _T("");
    BOOL fPlatform = FALSE;
    int nPlatform = IDS_INCORRECT_PLATFORM;

    if (!SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("Platform"), &Context) )
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupFindFirstLine_Wrapped(SetupInfo, Platform) FAILED")));}
    SetupGetStringField(&Context, 1, szPlatform, _MAX_PATH, NULL);

    // Check if .inf file is for NTS
    if (_tcsicmp(szPlatform, _T("NTS")) == 0)
    {
        if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType != OT_NTW)
            {fPlatform = TRUE;}
        else
        {
            if (g_pTheApp->m_fInvokedByNT)
            {
                iisDebugOut((LOG_TYPE_WARN,   _T("TemporaryHack.  iis.inf=NTS system=NTW, but wait till nt5 fixes. FAIL.\n")));
                g_pTheApp->m_eNTOSType = OT_NTS;
                fPlatform = TRUE;
            }
            else
            {
                nPlatform = IDS_NEED_PLATFORM_NTW;
            }
        }
    }

    // Check if .inf file is for NTW
    if (_tcsicmp(szPlatform, _T("NTW")) == 0)
    {
        if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType == OT_NTW){fPlatform = TRUE;}
        else{nPlatform = IDS_NEED_PLATFORM_NTW;}
    }

    /*
    // Check if .inf file is for Windows 95
    if (_tcsicmp(szPlatform, _T("W95")) == 0)
    {
        if (g_pTheApp->m_eOS == OS_W95){fPlatform = TRUE;}
        else{nPlatform = IDS_NEED_PLATFORM_W95;}
    }
    */

    // If We didn't find the specific platform, then produce error message.
    if (!fPlatform)
    {
        MyMessageBox(NULL, nPlatform, MB_OK | MB_SETFOREGROUND);
        iReturn = FALSE;
    }

    return iReturn;
}


int CheckSpecificBuildinInf(HINF InfHandle)
{
    int iReturn = TRUE;
    INFCONTEXT Context;

    // Check for a specific build of nt5...
    if ( g_pTheApp->m_eOS == OS_NT )
    {
        int iBuildNumRequired = 0;
        TCHAR szBuildRequired[20] = _T("");

        // check for Debug Keyword
        if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("Debug"), &Context) )
            {
            SetupGetStringField(&Context, 1, szBuildRequired, sizeof(szBuildRequired)/sizeof(szBuildRequired[0]), NULL);
            if (IsValidNumber((LPCTSTR)szBuildRequired))
                {
                iBuildNumRequired = _ttoi(szBuildRequired);
                if (iBuildNumRequired >= 1) {g_pTheApp->m_bAllowMessageBoxPopups = TRUE;}
                }
            }

        if (!SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("OSBuildRequired"), &Context) )
            {iisDebugOut((LOG_TYPE_ERROR, _T("SetupFindFirstLine_Wrapped(SetupInfo, OSBuildRequired) FAILED")));}
        else
        {
          SetupGetStringField(&Context, 1, szBuildRequired, 20, NULL);

          // Since this is nt, we should be able to get the build number
          CRegKey regWindowsNT( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),KEY_READ);
          if ( (HKEY)regWindowsNT )
          {
              CString strBuildNumString;
              regWindowsNT.m_iDisplayWarnings = FALSE;
              if (ERROR_SUCCESS == regWindowsNT.QueryValue(_T("CurrentBuildNumber"), strBuildNumString))
              {
                  int iBuildNumOS = 0;
                  if (IsValidNumber((LPCTSTR)strBuildNumString))
                      {iBuildNumOS = _ttoi(strBuildNumString);}
                  iisDebugOut((LOG_TYPE_TRACE, _T("NTCurrentBuildNumber=%d\n"), iBuildNumOS));

                  // We have a build entry.
                  // lets check if it larger than or equal to what the underlying operting system is...
                  if (_tcsicmp(szBuildRequired, _T("")) != 0)
                  {
                      if (IsValidNumber((LPCTSTR)szBuildRequired))
                          {iBuildNumRequired = _ttoi(szBuildRequired);}
                      if ((iBuildNumOS !=0 && iBuildNumRequired !=0) && (iBuildNumOS < iBuildNumRequired))
                      {
                          // They don't have a big enough build num
                          // give the error message.
                          MyMessageBox(NULL, IDS_OS_BUILD_NUM_REQUIREMENT,szBuildRequired, MB_OK | MB_SETFOREGROUND);
                      }
                  }
              }
          }
        }
    }

    return iReturn;
}

int CheckForOldGopher(HINF InfHandle)
{
    int iReturn = TRUE;

    if ( !(g_pTheApp->m_fUnattended) && g_pTheApp->m_eInstallMode == IM_UPGRADE )
    {
        CRegKey regGopher(HKEY_LOCAL_MACHINE, REG_GOPHERSVC,KEY_READ);
        if ( (HKEY)regGopher )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("GopherCurrentlyInstalled=YES")));
            if (g_pTheApp->MsgBox(NULL, IDS_REMOVE_GOPHER, MB_OKCANCEL, FALSE) == IDCANCEL)
            {
                // setup should be terminated.
                iReturn = FALSE;
                goto CheckForOldGopher_Exit;
            }
        }

    }

CheckForOldGopher_Exit:
    return iReturn;
}

// IIS publish the following directories to iis partners products
// Note: Inetpub directory can be customized later, and we'll re-publish
// those affected directories again later.
void SetOCGlobalPrivateData(void)
{
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathInetsrv"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathInetsrv,(g_pTheApp->m_csPathInetsrv.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    CString csPathIISAdmin = g_pTheApp->m_csPathInetsrv + _T("\\iisadmin");
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathIISAdmin"),(PVOID)(LPCTSTR)csPathIISAdmin,(csPathIISAdmin.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    CString csPathIISHelp = g_pTheApp->m_csWinDir + _T("\\Help\\iishelp");
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathIISHelp"),(PVOID)(LPCTSTR)csPathIISHelp,(csPathIISHelp.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathFTPRoot"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathFTPRoot,(g_pTheApp->m_csPathFTPRoot.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathWWWRoot"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathWWWRoot,(g_pTheApp->m_csPathWWWRoot.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathIISSamples"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathIISSamples,(g_pTheApp->m_csPathIISSamples.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    CString csPathScripts = g_pTheApp->m_csPathIISSamples + _T("\\Scripts");
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathScripts"),(PVOID)(LPCTSTR)csPathScripts,(csPathScripts.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("IISProgramGroup"),(PVOID)(LPCTSTR)g_pTheApp->m_csIISGroupName,(g_pTheApp->m_csIISGroupName.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    DWORD dwUpgradeType = (DWORD)(g_pTheApp->m_eUpgradeType);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("UpgradeType"),(PVOID)&dwUpgradeType,sizeof(DWORD),REG_DWORD);

    return;
}

// STDAPI GetCORSystemDirectory(LPWSTR pbuffer, DWORD  cchBuffer, DWORD* dwlength);
typedef HRESULT (*P_GetCORSystemDirectory)(LPWSTR pBuffer, DWORD ccBuffer, DWORD* dwLength);

BOOL GetASPNETSystemDir(LPTSTR lpszDir)
{
    BOOL bRet = FALSE;
    WCHAR wszSystemDir[_MAX_PATH];
    DWORD dwLength;

    P_GetCORSystemDirectory hProcGetSystemPath = NULL;
    _tcscpy(lpszDir,_T(""));

    // try using method#1
    HINSTANCE hMsCoreeDll = LoadLibraryEx(_T("mscoree.dll"), NULL, 0 );
    if (hMsCoreeDll)
    {
        hProcGetSystemPath = (P_GetCORSystemDirectory) GetProcAddress(hMsCoreeDll, "GetCORSystemDirectory");
        if (hProcGetSystemPath)
        {
            // should come back looking like (notice trailing slash):"C:\WINDOWS\Microsoft.NET\Framework\v1.0.3119\"
            HRESULT hRes = (*hProcGetSystemPath)((LPWSTR) wszSystemDir,(DWORD) _MAX_PATH,(DWORD*) &dwLength);
            if (SUCCEEDED(hRes))
            {
                bRet = TRUE;

#if defined(UNICODE) || defined(_UNICODE)
                _tcscpy(lpszDir,wszSystemDir);
#else
                char AsciiProcedureName[_MAX_PATH];
                // convert to ascii
                WideCharToMultiByte( CP_ACP, 0, (LPCWSTR) wszSystemDir, -1, AsciiProcedureName, _MAX_PATH, NULL, NULL );
                _tcscpy(lpszDir,AsciiProcedureName);
#endif
                // Ensure that it ends with a "\"
                LPTSTR pszTempPointer = lpszDir + _tcslen(lpszDir) - 1;
                if (pszTempPointer)
                {
                    if (*pszTempPointer != _T('\\'))
                    {
                        _tcscat(lpszDir, _T("\\"));
                    }
                }
                goto GetASPNETSystemDir_Exit;
            }
        }
    }

    // try using method#2
    if (!bRet)
    {
        CRegKey regKeyPath(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\.NETFramework"),KEY_READ);
        if ((HKEY)regKeyPath)
        {
            CString csPathResult;
            CString csPathVersion;

            // get the path
            // should come back looking like: "C:\WINDOWS\Microsoft.NET\Framework\"
            if (regKeyPath.QueryValue(_T("InstallRoot"), csPathResult) != ERROR_SUCCESS)
            {
                goto GetASPNETSystemDir_Exit;
            }

            // do any expansions if we need to
            if (-1 != csPathResult.Find(_T('%')) )
            {
                // there is a '%' in the string
                TCHAR szTempDir[_MAX_PATH];
                _tcscpy(szTempDir, csPathResult);
                if (ExpandEnvironmentStrings( (LPCTSTR)csPathResult, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                    {
                    csPathResult = szTempDir;
                    }
            }

            //key=HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\policy\v1.0
            //name=3119
            //value=0-3119
            CRegKey regKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\.NETFramework\\policy\\v1.0"),KEY_READ);
            if ((HKEY)regKey)
            {
                // Enum thru the entries in this key
                // since there will be one for every .netframework installation
                // and we want the latest one...
                CRegValueIter regEnum( regKey );
                CString csName, csValue;
                int iTheBiggestNumberYet = 0;
                while ( regEnum.Next( &csName, &csValue ) == ERROR_SUCCESS )
                {
                    if (_ttoi(csName) > iTheBiggestNumberYet)
                    {
                        csPathVersion = csName;
                        iTheBiggestNumberYet = _ttoi(csName);
                    }
                }
            }

            // Append the biggest version number onto the path...
            // so it looks like:"C:\WINDOWS\Microsoft.NET\Framework\v1.0.3119\"

            // Ensure that it ends with a "\"
            LPTSTR pszTempPointer = csPathResult.GetBuffer(_tcslen(csPathResult)) + _tcslen(csPathResult) - 1;
            csPathResult.ReleaseBuffer();
            if (pszTempPointer)
            {
                if (*pszTempPointer != _T('\\'))
                {
                    csPathResult += _T('\\');
                }
            }
            csPathResult = csPathResult + _T("v1.0.") + csPathVersion + _T("\\");
            _tcscpy(lpszDir,csPathResult);
            bRet = TRUE;
        }
    }

    // try getting the filversion of mscoree.dll
    // and using that version to create the path
    if (!bRet)
    {
        TCHAR  szSystemDir[_MAX_PATH];
        TCHAR  szFullPath[_MAX_PATH];
        DWORD  dwMSVer, dwLSVer = 0;
        TCHAR  szLocalizedVersion[100] = _T("");

        // get the c:\winnt\system32 dir
        if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
            {goto GetASPNETSystemDir_Exit;}

        // Tack on the filename
        _stprintf(szFullPath, _T("%s\\mscoree.dll"),szSystemDir);

        // get the fileversion.
        if (TRUE != IsFileExist(szFullPath))
            {goto GetASPNETSystemDir_Exit;}

        MyGetVersionFromFile(szFullPath, &dwMSVer, &dwLSVer, szLocalizedVersion);
        if (dwMSVer != 0)
        {
            // create the path
            // "C:\WINDOWS\Microsoft.NET\Framework\v1.0.3119\"
            if (0 == GetWindowsDirectory(szSystemDir, _MAX_PATH))
                {goto GetASPNETSystemDir_Exit;}

            _stprintf(lpszDir, _T("%s\\Microsoft.NET\\Framework\\v%d.%d.%d\\"),szSystemDir,HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer));
            bRet = TRUE;
        }
    }

GetASPNETSystemDir_Exit:
    if (hMsCoreeDll){FreeLibrary(hMsCoreeDll);}
    return bRet;
}

// UpdateAnonymousUsers
//
// Update the inf, with the correct users for removal.
//
BOOL
UpdateAnonymousUsers( HINF InfHandle )
{
  TSTR  strData;
  TSTR  strPassword;
  TSTR  strAnonymousPrefix;
  BOOL  bGuestIsSet = FALSE;

  if ( !strData.Resize( MAX_PATH ) ||
       !strPassword.Resize( MAX_PATH ) ||
       !strAnonymousPrefix.LoadString( IDS_GUEST_NAME ) )
  {
    return FALSE;
  }

  if ( GetDataFromMetabase(METABASEPATH_WWW_ROOT, MD_ANONYMOUS_USER_NAME, (PBYTE)strData.QueryStr(), strData.QuerySize()))
  {
    // Set WWW Info
    g_pTheApp->m_csWWWAnonyName_Remove = strData.QueryStr();

    if ( g_pTheApp->IsUpgrade() &&
         ( _tcsnicmp( strAnonymousPrefix.QueryStr(),
                      strData.QueryStr(),
                      _tcslen( strAnonymousPrefix.QueryStr() ) ) == 0 ) &&
         GetDataFromMetabase( METABASEPATH_WWW_ROOT, 
                              MD_ANONYMOUS_PWD, 
                              (PBYTE)strPassword.QueryStr(), 
                              strPassword.QuerySize() ) 
       )
    {
      // The username here is the anonymous user, so lets use it, instead of our
      // newly created one (machines names may have changed)
      g_pTheApp->m_csWWWAnonyName = strData.QueryStr();
      g_pTheApp->m_csGuestName = strData.QueryStr();
      g_pTheApp->m_csGuestPassword = strPassword.QueryStr();
      g_pTheApp->m_csWWWAnonyPassword = strPassword.QueryStr();
      bGuestIsSet = TRUE;
    }
  }

  if ( GetDataFromMetabase(_T("LM/MSFTPSVC"), MD_ANONYMOUS_USER_NAME, (PBYTE)strData.QueryStr(), strData.QuerySize()))
  {
    // Set FTP Info
    g_pTheApp->m_csFTPAnonyName_Remove = strData.QueryStr();

    if ( g_pTheApp->IsUpgrade() &&
         ( _tcsnicmp( strAnonymousPrefix.QueryStr(),
                    strData.QueryStr(),
                    _tcslen( strAnonymousPrefix.QueryStr() ) ) == 0 ) &&
         GetDataFromMetabase( _T("LM/MSFTPSVC"), 
                              MD_ANONYMOUS_PWD, 
                              (PBYTE)strPassword.QueryStr(), 
                              strPassword.QuerySize())
        )                      
    {
      // The username here is the anonymous FTP user, so lets use it, instead of our
      // newly created one (machines names may have changed)
      g_pTheApp->m_csFTPAnonyName = strData.QueryStr();
      g_pTheApp->m_csFTPAnonyPassword = strPassword.QueryStr();

      if ( !bGuestIsSet )
      {
        g_pTheApp->m_csGuestName = strData.QueryStr();
        g_pTheApp->m_csGuestPassword = strPassword.QueryStr();
      }
    }
  }

  if ( GetDataFromMetabase(METABASEPATH_WWW_ROOT, MD_WAM_USER_NAME, (PBYTE)strData.QueryStr(), strData.QuerySize()))
  {
    g_pTheApp->m_csWAMAccountName_Remove = strData.QueryStr();
  }

  return TRUE;
}

// this will be called during oc_init
// and right before oc_complete and oc_about_to_commit_queue
void SetDIRIDforThisInf(HINF InfHandle,BOOL bOCInit)
{
    BOOL bTempFlag = FALSE;
    TCHAR szTempDir[_MAX_PATH];

    // set everything if bOCInit is specified.
    // but if it's not specified then
    // set ID's which were not available at oc_init time...
    GetASPNETSystemDir(szTempDir);
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32781, szTempDir);

    if (FALSE == bOCInit)
    {
        g_pTheApp->ReGetMachineAndAccountNames();
            CString csMachineName = g_pTheApp->m_csMachineName.Right(g_pTheApp->m_csMachineName.GetLength() - 2);
        SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 32800, csMachineName);

        UpdateAnonymousUsers( InfHandle );

        if ( _tcsicmp(g_pTheApp->m_csWAMAccountName_Remove, _T("")) == 0)
            {g_pTheApp->m_csWAMAccountName_Remove = g_pTheApp->m_csWAMAccountName;}
        SetupSetStringId_Wrapper(InfHandle, 33004, g_pTheApp->m_csWAMAccountName_Remove);

        if ( _tcsicmp(g_pTheApp->m_csWWWAnonyName_Remove, _T("")) == 0)
            {g_pTheApp->m_csWWWAnonyName_Remove = g_pTheApp->m_csWWWAnonyName;  }
        SetupSetStringId_Wrapper(InfHandle, 33005, g_pTheApp->m_csWWWAnonyName_Remove);

        if ( _tcsicmp(g_pTheApp->m_csWWWAnonyName_Remove, _T("")) == 0)
            {g_pTheApp->m_csFTPAnonyName_Remove = g_pTheApp->m_csFTPAnonyName;}
        SetupSetStringId_Wrapper(InfHandle, 33006, g_pTheApp->m_csFTPAnonyName_Remove);

        SetupSetStringId_Wrapper(InfHandle, 33000, g_pTheApp->m_csGuestName);
        SetupSetStringId_Wrapper(InfHandle, 33002, g_pTheApp->m_csWWWAnonyName);
        SetupSetStringId_Wrapper(InfHandle, 33003, g_pTheApp->m_csFTPAnonyName);
    }
    else
    {
        // Create Directory IDs for the coresponding .inf file
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32768, g_pTheApp->m_csPathInetsrv);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32769, g_pTheApp->m_csPathFTPRoot);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32770, g_pTheApp->m_csPathWWWRoot);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32771, g_pTheApp->m_csPathIISSamples);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32772, g_pTheApp->m_csPathScripts);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32773, g_pTheApp->m_csPathInetpub);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32774, g_pTheApp->m_csPathOldInetsrv);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32780, g_pTheApp->m_csSysDrive);

        if (g_pTheApp->m_eUpgradeType == UT_10_W95)
        {
            bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32775, g_pTheApp->m_csPathOldPWSFiles);
            bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32776, g_pTheApp->m_csPathOldPWSSystemFiles);
        }

        GetJavaTLD(szTempDir);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32778, szTempDir);
        SetupSetDirectoryId_Wrapper(InfHandle, 32777, g_pTheApp->m_csPathProgramFiles);

        SetupSetDirectoryId_Wrapper(InfHandle, 32779, g_pTheApp->m_csPathWebPub);

        if (g_pTheApp->m_eUpgradeType == UT_NONE){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_NONE"));}
        if (g_pTheApp->m_eUpgradeType == UT_351){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_351"));}
        if (g_pTheApp->m_eUpgradeType == UT_10){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_10"));}
        if (g_pTheApp->m_eUpgradeType == UT_20){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_20"));}
        if (g_pTheApp->m_eUpgradeType == UT_30){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_30"));}
        if (g_pTheApp->m_eUpgradeType == UT_40){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_40"));} // can also be from win95
        if (g_pTheApp->m_eUpgradeType == UT_50){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_50"));}
        if (g_pTheApp->m_eUpgradeType == UT_51){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_51"));}
        if (g_pTheApp->m_eUpgradeType == UT_60){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_60"));}
        if (g_pTheApp->m_eUpgradeType == UT_10_W95){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_10_W95"));}

            CString csMachineName = g_pTheApp->m_csMachineName.Right(g_pTheApp->m_csMachineName.GetLength() - 2);
        SetupSetStringId_Wrapper(InfHandle, 32800, csMachineName);
        SetupSetStringId_Wrapper(InfHandle, 32802, _T(""));

        SetupSetStringId_Wrapper(InfHandle, 33000, g_pTheApp->m_csGuestName);
        SetupSetStringId_Wrapper(InfHandle, 33001, g_pTheApp->m_csWAMAccountName);
        SetupSetStringId_Wrapper(InfHandle, 33002, g_pTheApp->m_csWWWAnonyName);
        SetupSetStringId_Wrapper(InfHandle, 33003, g_pTheApp->m_csFTPAnonyName);

        if ( _tcsicmp(g_pTheApp->m_csWAMAccountName_Remove, _T("")) == 0)
            {g_pTheApp->m_csWAMAccountName_Remove = g_pTheApp->m_csWAMAccountName;}
        SetupSetStringId_Wrapper(InfHandle, 33004, g_pTheApp->m_csWAMAccountName_Remove);

        if ( _tcsicmp(g_pTheApp->m_csWWWAnonyName_Remove, _T("")) == 0)
            {g_pTheApp->m_csWWWAnonyName_Remove = g_pTheApp->m_csWWWAnonyName;  }
        SetupSetStringId_Wrapper(InfHandle, 33005, g_pTheApp->m_csWWWAnonyName_Remove);

        if ( _tcsicmp(g_pTheApp->m_csWWWAnonyName_Remove, _T("")) == 0)
            {g_pTheApp->m_csFTPAnonyName_Remove = g_pTheApp->m_csFTPAnonyName;}
        SetupSetStringId_Wrapper(InfHandle, 33006, g_pTheApp->m_csFTPAnonyName_Remove);

        SYSTEM_INFO SystemInfo;
        GetSystemInfo( &SystemInfo );

        TCHAR szSourceCatOSName[20];
        _tcscpy(szSourceCatOSName, _T("\\i386"));
        switch(SystemInfo.wProcessorArchitecture)
        {
          case PROCESSOR_ARCHITECTURE_AMD64:
              _tcscpy(szSourceCatOSName, _T("\\AMD64"));
              break;
    //      case PROCESSOR_ARCHITECTURE_IA64:
    //          _tcscpy(szSourceCatOSName, _T("\\IA64"));
    //          break;
            case PROCESSOR_ARCHITECTURE_INTEL:
                if (IsNEC_98) {_tcscpy(szSourceCatOSName, _T("\\Nec98"));}
                break;
            default:
                break;
        }
        SetupSetStringId_Wrapper(InfHandle, 34000, szSourceCatOSName);
    }

    return;
}

BOOL GetJavaTLD(LPTSTR lpszDir)
{
    CRegKey regKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\JAVA VM"),KEY_READ);
    BOOL bFound = FALSE;
    CString csValue;
    CString csValue2;
    int iWhere = -1;

    if ((HKEY)regKey)
    {
        regKey.m_iDisplayWarnings = FALSE;
        if (regKey.QueryValue(_T("TrustedLibsDirectory"), csValue) == ERROR_SUCCESS) {bFound = TRUE;}
        // Warning: we are expecting something like this = "C:\WINNT\java\trustlib"
        // However, recently 12/18 the nt5 "java vm" setup seems to be hosing and passing us:
        // %systemroot%\java\trustlib

        if (-1 != csValue.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, csValue);
            if (ExpandEnvironmentStrings( (LPCTSTR)csValue, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {
                csValue = szTempDir;
                }
        }
/*
        // if we see %systemroot% in there then, i'm going to substitute WinDir in place of %Systemroot%
        csValue.MakeUpper();
        if (csValue.Find(_T("%SYSTEMROOT%")) != (-1) )
        {
            // We Found the cheesy %systemroot% deal.  Now replace it with the real systemroot
            iWhere = csValue.Find(_T("%SYSTEMROOT%"));
            iWhere = iWhere + _tcslen(_T("%SYSTEMROOT%"));
            csValue2 = g_pTheApp->m_csWinDir + csValue.Right( csValue.GetLength() - (iWhere) );
            csValue = csValue2;
        }
*/
    }

    if (!bFound) {csValue = g_pTheApp->m_csWinDir + _T("\\Java\\TrustLib");}
    _tcscpy(lpszDir, csValue);
    return bFound;
}


void ShowStateOfTheseServices(IN HINF hFile)
{
    CStringList strList;
    DWORD dwStatus;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T(" --- Display status of services which are required for IIS to run --- \n")));

    TSTR strTheSection;

    if ( !strTheSection.Copy( _T("VerifyServices") ) )
    {
      return;
    }

    if (GetSectionNameToDo(hFile, &strTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, strTheSection.QueryStr() ))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos;
            CString csEntry;

            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = strList.GetAt(pos);

                // Display state of this service.
                dwStatus = InetQueryServiceStatus(csEntry);
                switch(dwStatus)
                {
                    case SERVICE_STOPPED:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_STOPPED [%s].\n"), csEntry));
                        break;
                    case SERVICE_START_PENDING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_START_PENDING [%s].\n"), csEntry));
                        break;
                    case SERVICE_STOP_PENDING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_STOP_PENDING [%s].\n"), csEntry));
                        break;
                    case SERVICE_RUNNING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_RUNNING [%s].\n"), csEntry));
                        break;
                    case SERVICE_CONTINUE_PENDING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_CONTINUE_PENDING [%s].\n"), csEntry));
                        break;
                    case SERVICE_PAUSE_PENDING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_PAUSE_PENDING [%s].\n"), csEntry));
                        break;
                    case SERVICE_PAUSED:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_PAUSED [%s].\n"), csEntry));
                        break;
                }

                strList.GetNext(pos);
            }
        }
    }
    }

    return;
}


#define MD_SIGNATURE_STRINGA    "*&$MetaData$&*"
#define MD_SIGNATURE_STRINGW    L##"*&$MetaData$&*"

int IsMetabaseCorrupt(void)
{
    // We've had a problem where sometimes the metabase.bin file
    // gets corrupted and set to only spaces...
    // so this function is here to determine where and when the metabase.bin is hosed!
    int    iTheMetabaseIsCorrupt = FALSE;
    TCHAR  szSystemDir[_MAX_PATH];
    TCHAR  szFullPath[_MAX_PATH];
    HANDLE hReadFileHandle = INVALID_HANDLE_VALUE;
    BYTE   *chBuffer = NULL;
    DWORD   dwSize = 0;
    DWORD   dwWideSignatureLen = 0;
    DWORD   dwAnsiSignatureLen = 0;
    TCHAR buf[MAX_FAKE_METABASE_STRING_LEN];

    // get the c:\winnt\system32 dir
    if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
        {goto IsMetabaseCorrupt_Exit;}

    // Tack on the inf\iis.inf subdir and filename
    _stprintf(szFullPath, _T("%s\\inetsrv\\metabase.bin"),szSystemDir);

        // Check if the file exists
    if (TRUE != IsFileExist(szFullPath))
        {
            iTheMetabaseIsCorrupt = FALSE;
            // this function only works on version less than or equal to iis5
            // since that's the only versions which had a metabase.bin file
            // so just return that the metabase is not corrupt
            goto IsMetabaseCorrupt_Exit;
        }

    // okay, so the metabase.bin file exists...
    // let's open it and see if we can get something out of it.

    //
    // Open the file.
    //
    hReadFileHandle = CreateFile(szFullPath,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
    if (hReadFileHandle == INVALID_HANDLE_VALUE)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: CreateFile on %s failed with 0x%x!\n"),szFullPath,GetLastError()));
        goto IsMetabaseCorrupt_Exit;
    }

    dwSize = GetFileSize(hReadFileHandle, NULL);
    dwWideSignatureLen = sizeof(MD_SIGNATURE_STRINGW);
    dwAnsiSignatureLen = sizeof(MD_SIGNATURE_STRINGA);

    // get the size of the whole file
    //chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwSize+1 );
    if ((dwSize) >= dwWideSignatureLen)
    {
        chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwWideSignatureLen+1);
        dwSize = dwWideSignatureLen+1;
    }
    else
    {
        if ( dwSize >= dwAnsiSignatureLen)
        {
            chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwAnsiSignatureLen+1 );
            dwSize = dwAnsiSignatureLen+1;
        }
        else
        {
            iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: ReadFile on %s.  Not enough data in there! Less than metabase signature len!\n"),szFullPath));
            // Things are not kool
            // This metabase must be hosed!
            iTheMetabaseIsCorrupt = FALSE;
            goto IsMetabaseCorrupt_Exit;
        }
    }

    if (!chBuffer)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: HeapAlloc failed to get %d space.\n"),dwWideSignatureLen+1));
        goto IsMetabaseCorrupt_Exit;
    }

    SetFilePointer(hReadFileHandle,0,0,FILE_BEGIN);

    // kool, try to read the file
    if (0 == ReadFile(hReadFileHandle, chBuffer, dwSize, &dwSize, NULL))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: ReadFile on %s failed with 0x%x!. size=%d\n"),szFullPath,GetLastError(),dwSize));
        goto IsMetabaseCorrupt_Exit;
    }

    //
    // take chBuffer and check if it matches the unicode/ansi signature.
    //
    if (0 == memcmp(MD_SIGNATURE_STRINGW,chBuffer,dwWideSignatureLen))
    {
        // things are kool, and this metabase should not be hosed.
        iTheMetabaseIsCorrupt = FALSE;
        goto IsMetabaseCorrupt_Exit;
    }
    if (0 == memcmp(MD_SIGNATURE_STRINGA,chBuffer,dwAnsiSignatureLen))
    {
        // if not, then check if it matches the ansi signature.
        // things are kool, and this metabase should not be hosed.
        iTheMetabaseIsCorrupt = FALSE;
        goto IsMetabaseCorrupt_Exit;
    }

    // on other check...
    // in iis6 there is a dummy fake metabase.bin put there by setup
    // check if this is that dummy file.
    if (chBuffer)
        {HeapFree(GetProcessHeap(), 0, chBuffer); chBuffer = NULL;}

    memset(buf, 0, _tcslen(buf) * sizeof(TCHAR));
    // this iis.dll is always compiled unicode, so
    // we know that buf is unicode
    if (LoadString((HINSTANCE) g_MyModuleHandle, IDS_FAKE_METABASE_BIN_TEXT, buf, MAX_FAKE_METABASE_STRING_LEN))
    {
        dwSize = _tcslen(buf) * sizeof(TCHAR);
        // add space for the FF and FE bytes
        dwSize = dwSize + 2;

        // open the file
        SetFilePointer(hReadFileHandle,0,0,FILE_BEGIN);

        chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwSize);

        // kool, try to read the file
        if (0 == ReadFile(hReadFileHandle, chBuffer, dwSize, &dwSize, NULL))
        {
            iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: ReadFile on %s failed with 0x%x!. size=%d\n"),szFullPath,GetLastError(),dwSize));
            goto IsMetabaseCorrupt_Exit;
        }

        // check if the input file is unicode
        if (0xFF == chBuffer[0] && 0xFE == chBuffer[1])
        {
            // skip past these characters
            chBuffer++;
            chBuffer++;

            // Compare what you got with what we think is in there
            if (0 == memcmp(buf,chBuffer,dwSize))
            {
                // things are kool, and this metabase should not be hosed.
                chBuffer--;
                chBuffer--;
                iTheMetabaseIsCorrupt = FALSE;
                goto IsMetabaseCorrupt_Exit;
            }
            chBuffer--;
            chBuffer--;
        }
    }

    // if not then, it must be corrupt!
    // Things are not kool
    // This metabase must be hosed!
    iTheMetabaseIsCorrupt = TRUE;
    iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: unable to verify signature in Metabase.bin. Corrupt.\n")));

IsMetabaseCorrupt_Exit:
    if (chBuffer)
        {HeapFree(GetProcessHeap(), 0, chBuffer);}
    if (hReadFileHandle != INVALID_HANDLE_VALUE)
        {CloseHandle(hReadFileHandle);}
    return iTheMetabaseIsCorrupt;
}


void iisDebugOut_Start(TCHAR *pszString, int iLogType)
{
    iisDebugOut((iLogType, _T("%s:Start.\n"),pszString));
    return;
}
void iisDebugOut_Start1(TCHAR *pszString1, TCHAR *pszString2, int iLogType)
{
    iisDebugOut((iLogType, _T("%s:(%s)Start.\n"),pszString1,pszString2));
    return;
}
void iisDebugOut_Start1(TCHAR *pszString1, CString pszString2, int iLogType)
{
    iisDebugOut((iLogType, _T("%s:(%s)Start.\n"),pszString1,pszString2));
    return;
}
void iisDebugOut_End(TCHAR *pszString, int iLogType)
{
    iisDebugOut((iLogType, _T("%s:End.\n"),pszString));
    return;
}
void iisDebugOut_End1(TCHAR *pszString1, TCHAR *pszString2, int iLogType)
{
    iisDebugOut((iLogType, _T("%s(%s):End.\n"),pszString1, pszString2));
    return;
}
void iisDebugOut_End1(TCHAR *pszString1, CString pszString2, int iLogType)
{
    iisDebugOut((iLogType, _T("%s(%s):End.\n"),pszString1,pszString2));
    return;
}


BOOL SetupFindFirstLine_Wrapped(
    IN  HINF        InfHandle,
    IN  LPCTSTR     Section,
    IN  LPCTSTR     Key,          OPTIONAL
    INFCONTEXT *Context
    )
{
    BOOL bReturn = FALSE;
    BOOL bGoGetWhatTheyOriginallyWanted = TRUE;

    // check for the alternate .inf file
    if (g_pTheApp->m_hInfHandleAlternate && InfHandle != g_pTheApp->m_hInfHandleAlternate)
    {
        bReturn = SetupFindFirstLine(g_pTheApp->m_hInfHandleAlternate, Section, Key, Context);
        if (bReturn)
        {
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Using alternate iis.inf section:[%s]"),Section));
            bGoGetWhatTheyOriginallyWanted = FALSE;
        }
    }

    if (bGoGetWhatTheyOriginallyWanted)
        {bReturn = SetupFindFirstLine(InfHandle, Section, Key, Context);}

    return bReturn;
}


int ReadUserConfigurable(HINF InfHandle)
{
    int iReturn = TRUE;
    INFCONTEXT Context;
    TCHAR szTempString[_MAX_PATH] = _T("");
    DWORD dwValue = 0x0;

    DWORD dwSomethingSpecifiedHere = 0;


    //
    // Get the IUSR name
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_NAME))
            {
                g_pTheApp->m_csWWWAnonyName_Unattend = szTempString;
                dwSomethingSpecifiedHere |= USER_SPECIFIED_INFO_WWW_USER_NAME;
                //g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr specified for www\n")));
            }

            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_NAME))
            {
                g_pTheApp->m_csFTPAnonyName_Unattend = szTempString;
                dwSomethingSpecifiedHere |= USER_SPECIFIED_INFO_FTP_USER_NAME;
                //g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr specified for ftp\n")));
            }
        }
    }

/*
    // this stuff should not be configurable from the iis.inf file

    //
    // Get the IUSR password
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_PASS"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csWWWAnonyPassword_Unattend = szTempString;
                    dwSomethingSpecifiedHere |= USER_SPECIFIED_INFO_WWW_USER_PASS;
                    //g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr pass specified for www\n")));
                }
            }

            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csFTPAnonyPassword_Unattend = szTempString;

                    dwSomethingSpecifiedHere |= USER_SPECIFIED_INFO_FTP_USER_PASS;
                    //g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr pass specified for ftp\n")));
                }
            }
        }
    }
*/

    //
    // Get the IUSR name for WWW
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_WWW"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_NAME))
            {
                g_pTheApp->m_csWWWAnonyName_Unattend = szTempString;
                g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr specified for www\n")));
            }
        }
    }

/*
    // this stuff should not be configurable from the iis.inf file

    //
    // Get the IUSR pass for WWW
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_WWW_PASS"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csWWWAnonyPassword_Unattend = szTempString;
                    g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr pass specified for www\n")));
                }
            }
        }
    }
*/
    //
    // Get the IUSR name for FTP
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_FTP"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_NAME))
            {
                g_pTheApp->m_csFTPAnonyName_Unattend = szTempString;
                g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr specified for ftp\n")));
            }
        }
    }

/*
    // this stuff should not be configurable from the iis.inf file

    //
    // Get the IUSR password for FTP
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_FTP_PASS"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csFTPAnonyPassword_Unattend = szTempString;
                    g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr pass specified for ftp\n")));
                }
            }
        }
    }
*/

    //
    // Get the WAM username
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IWAM"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WAM_USER_NAME))
            {
                g_pTheApp->m_csWAMAccountName_Unattend = szTempString;
                g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WAM_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iwam specified for www\n")));
            }
        }
    }

/*
    // this stuff should not be configurable from the iis.inf file
    //

    // Get the WAM password
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IWAM_PASS"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WAM_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csWAMAccountPassword_Unattend = szTempString;
                    g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WAM_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iwam pass specified for www\n")));
                }
            }
        }
    }

*/

    //
    // Get Path for Inetpub
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("PathInetpub"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_PATH_INETPUB))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (IsValidDirectoryName(szTempString))
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("Custom PathInetpub=%s\n"),szTempString));
                        g_pTheApp->m_csPathInetpub = szTempString;
                        g_pTheApp->SetInetpubDerivatives();
                        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_INETPUB;
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_WARN, _T("Custom PathInetpub specified (%s), however path not valid.ignoring unattend value. WARNING.\n"),szTempString));
                    }
                }
            }
        }
    }

    //
    // Get Path for ftp root
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("PathFTPRoot"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_PATH_FTP))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (IsValidDirectoryName(szTempString))
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("Custom PathFTPRoot=%s\n"),szTempString));
                        CustomFTPRoot(szTempString);
                        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_FTP;
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_WARN, _T("Custom PathFTPRoot specified (%s), however path not valid.ignoring unattend value. WARNING.\n"),szTempString));
                    }
                }
            }
        }
    }

    //
    // Get Path for www root
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("PathWWWRoot"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_PATH_WWW))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (IsValidDirectoryName(szTempString))
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("Custom PathWWWRoot=%s\n"),szTempString));
                        CustomWWWRoot(szTempString);
                        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_WWW;
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_WARN, _T("Custom PathWWWRoot specified (%s), however path not valid.ignoring unattend value. WARNING.\n"),szTempString));
                    }
                }
            }
        }
    }

//ReadUserConfigurable_Exit:
    if (dwSomethingSpecifiedHere & USER_SPECIFIED_INFO_WWW_USER_NAME){g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;}
    if (dwSomethingSpecifiedHere & USER_SPECIFIED_INFO_FTP_USER_NAME){g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;}
    if (dwSomethingSpecifiedHere & USER_SPECIFIED_INFO_WWW_USER_PASS){g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;}
    if (dwSomethingSpecifiedHere & USER_SPECIFIED_INFO_FTP_USER_PASS){g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;}
    return iReturn;
}


INT IsThisOnNotStopList(IN HINF hFile, CString csInputName, BOOL bServiceFlag)
{
    INT iReturn = FALSE;
    CStringList strList;
    TSTR strTheSection;

    // if the entry is not a service name,
    // then it must be a process filename,
    // so make sure to get just the end of it
    if (!bServiceFlag)
    {
        TCHAR szJustTheFileName[_MAX_FNAME];
        // make sure to get only just the filename.
        if (TRUE == ReturnFileNameOnly(csInputName, szJustTheFileName))
        {
            csInputName = szJustTheFileName;
        }
    }

    if ( strTheSection.Copy( _T("NonStopList") ) &&
         GetSectionNameToDo(hFile, &strTheSection)
       )
    {
        if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, strTheSection.QueryStr() ))
        {
            // loop thru the list returned back
            if (strList.IsEmpty() == FALSE)
            {
                POSITION pos;
                CString csEntry;

                pos = strList.GetHeadPosition();
                while (pos)
                {
                    csEntry = strList.GetAt(pos);

                    // check if this entry matchs the entry that was passed in...
                    if (_tcsicmp(csEntry, csInputName) == 0)
                    {
                        // it matches so return TRUE;
                        iReturn = TRUE;
                        goto IsThisOnNotStopList_Exit;
                    }

                    strList.GetNext(pos);
                }
            }
        }
    }

IsThisOnNotStopList_Exit:
    return iReturn;
}


HRESULT MofCompile(TCHAR * szPathMofFile)
{
    HRESULT hRes = E_FAIL;
    WCHAR wszFileName[_MAX_PATH];
    IMofCompiler    *pMofComp = NULL;
    WBEM_COMPILE_STATUS_INFO    Info;

    hRes = CoInitialize(NULL);
    if (FAILED(hRes))
    {
        goto MofCompile_Exit;
    }

    hRes = CoCreateInstance( CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *)&pMofComp);
    if (FAILED(hRes))
    {
        goto MofCompile_Exit;
    }

    // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszFileName, szPathMofFile);
#else
    MultiByteToWideChar( CP_ACP, 0, szPathMofFile, -1, wszFileName, _MAX_PATH);
#endif

    pMofComp->CompileFile (
                (LPWSTR) wszFileName,
                NULL,                   // load into namespace specified in MOF file
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                0,                              // no class flags
                0,              // no instance flags
                &Info);

    pMofComp->Release();
    CoUninitialize();

MofCompile_Exit:
        return hRes;
}


DWORD DoesEntryPointExist(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedure)
{
    DWORD dwReturn = ERROR_FILE_NOT_FOUND;
    HINSTANCE hDll = NULL;
    HCRET hProc = NULL;
    TCHAR szDirName[_MAX_PATH], szFilePath[_MAX_PATH];
    _tcscpy(szDirName, _T(""));

        // Check if the file exists
    if (!IsFileExist(lpszDLLFile))
        {
                dwReturn = ERROR_FILE_NOT_FOUND;
        goto DoesEntryPointExist_Exit;
        }

    // Change Directory
    GetCurrentDirectory( _MAX_PATH, szDirName );
    InetGetFilePath(lpszDLLFile, szFilePath);

    // Change to The Drive.
    if (-1 == _chdrive( _totupper(szFilePath[0]) - 'A' + 1 )) {}
    if (SetCurrentDirectory(szFilePath) == 0) {}

    // Try to load the module,dll,ocx.
    hDll = LoadLibraryEx(lpszDLLFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        if (!hDll)
        {
                dwReturn = ERROR_FILE_NOT_FOUND;
        goto DoesEntryPointExist_Exit;
        }

        // Ok module was successfully loaded.  now let's try to get the Address of the Procedure
        // Convert the function name to ascii before passing it to GetProcAddress()
        char AsciiProcedureName[255];
#if defined(UNICODE) || defined(_UNICODE)
    // convert to ascii
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)lpszProcedure, -1, AsciiProcedureName, 255, NULL, NULL );
#else
    // the is already ascii so just copy
    strcpy(AsciiProcedureName, lpszProcedure);
#endif

    // see if the entry point exists...
    hProc = (HCRET)GetProcAddress(hDll, AsciiProcedureName);
        if (!hProc)
        {
                // failed to load,find or whatever this function.
            dwReturn = ERROR_PROC_NOT_FOUND;
        goto DoesEntryPointExist_Exit;
        }
    iisDebugOut((LOG_TYPE_TRACE, _T("DoesEntryPointExist:%s=true\n"),lpszProcedure));
    dwReturn = ERROR_SUCCESS;

DoesEntryPointExist_Exit:
    if (hDll){FreeLibrary(hDll);}
    if (_tcscmp(szDirName, _T("")) != 0){SetCurrentDirectory(szDirName);}
    return dwReturn;
}


void CreateDummyMetabaseBin(void)
{
    TCHAR szFullPath1[_MAX_PATH];
    TCHAR szFullPath2[_MAX_PATH];
    HANDLE hfile = INVALID_HANDLE_VALUE;
    DWORD dwBytesWritten = 0;
    TCHAR buf[MAX_FAKE_METABASE_STRING_LEN];
    BYTE bOneByte = 0;

    // check if there is an existing metabase.bin
    // if there is then rename it to a unique filename.
    // if we cannot rename it because its in use or something, then leave it and get out.
    _stprintf(szFullPath1, _T("%s\\metabase.bin"),g_pTheApp->m_csPathInetsrv);
    if (IsFileExist(szFullPath1))
    {
        // Check to see how big it is.
        DWORD dwFileSize = ReturnFileSize(szFullPath1);
        if (dwFileSize != 0xFFFFFFFF)
        {
            // if it's less than 2k then it must be the fake file already (must be an upgrade)
            // leave it alone and don't replace it with the dummy (since it already is the dummy)
            if (dwFileSize < 2000)
            {
                return;
            }
        }

        int iCount = 0;
        int iFlag = FALSE;
        do
        {
            // check if the new unique file name exists...
            _stprintf(szFullPath2, _T("%s.dfu.%d"),szFullPath1,iCount);
            if (!IsFileExist(szFullPath2))
            {
                iFlag = TRUE;
            }
        } while (iFlag == FALSE && iCount < 9999);

        // this is a unique filename, so let's use it and
        // rename the metabase.bin to it
        if (!MoveFileEx(szFullPath1, szFullPath2, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING))
        {
            // log the failure at least
            iisDebugOut((LOG_TYPE_WARN, _T("CreateDummyMetabaseBin: unable to rename existing metabase.bin file\n")));
            return;
        }

    }

    // Create a unicode text file named metabase.bin
    // and stick some sting into it (from our setup resource)
    // should be localized when localization localizes the iis.dll
    memset(buf, 0, _tcslen(buf) * sizeof(TCHAR));

    // this iis.dll is always compiled unicode, so
    // we know that buf is unicode
    if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_FAKE_METABASE_BIN_TEXT, buf, MAX_FAKE_METABASE_STRING_LEN))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("LoadString(%d) Failed.\n"), IDS_FAKE_METABASE_BIN_TEXT));
        return;
    }
    DeleteFile(szFullPath1);

    // create the new metabase.bin file
    hfile = CreateFile((LPTSTR)szFullPath1, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hfile == INVALID_HANDLE_VALUE)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("CreateDummyMetabaseBin:CreateFile on %s failed with 0x%x!\n"),szFullPath1,GetLastError()));
        return;
    }
    // write a couple of bytes to the beginning of the file say that it's "unicode"
    bOneByte = 0xFF;
    WriteFile(hfile, (LPCVOID) &bOneByte, 1, &dwBytesWritten, NULL);
    bOneByte = 0xFE;
    WriteFile(hfile, (LPCVOID) &bOneByte, 1, &dwBytesWritten, NULL);
    if ( WriteFile( hfile, buf, _tcslen(buf) * sizeof(TCHAR), &dwBytesWritten, NULL ) == FALSE )
    {
        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("WriteFile(%1!s!) Failed.  Error=0x%2!x!.\n"), szFullPath1, GetLastError()));
    }

    CloseHandle(hfile);
    return;
}

//
// Check whether we are running as administrator on the machine
// or not
//
BOOL RunningAsAdministrator()
{
#ifdef _CHICAGO_
    return TRUE;
#else
    BOOL   fReturn = FALSE;
    PSID   psidAdmin;
    DWORD  err;

    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;

    if ( AllocateAndInitializeSid ( &SystemSidAuthority, 2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        if (!CheckTokenMembership( NULL, psidAdmin, &fReturn )) {
            err = GetLastError();
            iisDebugOut((LOG_TYPE_ERROR, _T("CheckTokenMembership failed on err %d.\n"), err));
        }

        FreeSid ( psidAdmin);
    }

    return ( fReturn );
#endif //_CHICAGO_
}


void StopAllServicesRegardless(int iShowErrorsFlag)
{
#ifndef _CHICAGO_
    // important: you must take iis clusters off line before doing anykind of upgrade\installs...
    // but incase the user didn't do this... try to take them off line for the user
        DWORD dwResult = ERROR_SUCCESS;
        dwResult = BringALLIISClusterResourcesOffline();

    if (StopServiceAndDependencies(_T("W3SVC"), FALSE) == FALSE)
    {
        if (iShowErrorsFlag)
        {
            MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("W3SVC"), MB_OK | MB_SETFOREGROUND);
        }
    }

    if (StopServiceAndDependencies(_T("MSFTPSVC"), FALSE) == FALSE)
    {
        if (iShowErrorsFlag)
        {
            MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("MSFTPSVC"), MB_OK | MB_SETFOREGROUND);
        }
    }

    if (StopServiceAndDependencies(_T("IISADMIN"), TRUE) == FALSE)
    {
        if (iShowErrorsFlag)
        {
            MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("IISADMIN"), MB_OK | MB_SETFOREGROUND);
        }
    }

    /*
    DWORD dwStatus = 0;
    dwStatus = InetQueryServiceStatus(_T("MSDTC"));
    if (SERVICE_RUNNING == dwStatus)
    {
        // if the service is running, then let' stop it!
        if (StopServiceAndDependencies(_T("MSDTC"), TRUE) == FALSE)
        {
            if (iShowErrorsFlag){MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("MSDTC"), MB_OK | MB_SETFOREGROUND);}
        }
    }
    */

    /*
    dwStatus = InetQueryServiceStatus(_T("SPOOLER"));
    if (SERVICE_RUNNING == dwStatus)
    {
        // if the service is running, then let' stop it!
        if (StopServiceAndDependencies(_T("SPOOLER"), TRUE) == FALSE)
        {
            if (iShowErrorsFlag){MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("SPOOLER"), MB_OK | MB_SETFOREGROUND);}
        }
    }
    */

#endif

    // kill pwstray.exe in case of IIS4.0 Beta2 upgrade, to release admprox.dll
    HWND hwndTray = NULL;
    hwndTray = FindWindow(PWS_TRAY_WINDOW_CLASS, NULL);
    if ( hwndTray ){::PostMessage( hwndTray, WM_CLOSE, 0, 0 );}

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\ipsec.cpp ===
// to be linked with:
// uuid.lib ole32.lib user32.lib kernel32.lib advapi32.lib wsock32.lib
// iis\svcs\infocomm\rdns\obj\i386\isrdns.lib iis\svcs\lib\i386\tsstr.lib iis\svcs\lib\i386\isdebug.lib


#include "stdafx.h"

#define _RDNS_STANDALONE

#include <winsock2.h>
#include <rdns.hxx>
#include <buffer.hxx>
#include <ole2.h>
#include <iadm.h>
#include <iiscnfg.h>
#include "mdkey.h"
#include "mdentry.h"
#include "helper.h"
#include <inetinfo.h>

extern int g_CheckIfMetabaseValueWasWritten;

#define TIMEOUT_VALUE   5000
//
//  Global Data
//

//
//  The registry parameter key names for the grant list and deny
//  list.  We use the kludgemultisz thing for Chicago
//

#define IPSEC_DENY_LIST             L"Deny IP List"
#define IPSEC_GRANT_LIST            L"Grant IP List"


//
//  Private prototypes.
//

BOOL
DottedDecimalToDword(
    CHAR * * ppszAddress,
    DWORD *  pdwAddress
    );

CHAR *
KludgeMultiSz(
    HKEY hkey,
    LPDWORD lpdwLength
    )
{
    LONG  err;
    DWORD iValue;
    DWORD cchTotal;
    DWORD cchValue;
    CHAR  szValue[MAX_PATH];
    LPSTR lpMultiSz;
    LPSTR lpTmp;
    LPSTR lpEnd;

    //
    //  Enumerate the values and total up the lengths.
    //

    iValue = 0;
    cchTotal = 0;

    for( ; ; )
    {
        cchValue = sizeof(szValue) / sizeof(szValue[0]);

        err = RegEnumValueA( hkey,
                            iValue,
                            szValue,
                            &cchValue,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

        if( err != NO_ERROR )
        {
            break;
        }

        //
        //  Add the length of the value's name, plus one
        //  for the terminator.
        //

        cchTotal += strlen( szValue ) + 1;

        //
        //  Advance to next value.
        //

        iValue++;
    }

    //
    //  Add one for the final terminating NULL.
    //

    cchTotal++;
    *lpdwLength = cchTotal;

    //
    //  Allocate the MULTI_SZ buffer.
    //

    lpMultiSz = (CHAR *) LocalAlloc( LMEM_FIXED, cchTotal * sizeof(CHAR) );

    if( lpMultiSz == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    memset( lpMultiSz, 0, cchTotal * sizeof(CHAR) );

    //
    //  Enumerate the values and append to the buffer.
    //

    iValue = 0;
    lpTmp = lpMultiSz;
    lpEnd = lpMultiSz + cchTotal;

    for( ; ; )
    {
        cchValue = sizeof(szValue)/sizeof(CHAR);

        err = RegEnumValueA( hkey,
                            iValue,
                            szValue,
                            &cchValue,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

        if( err != NO_ERROR )
        {
            break;
        }

        //
        //  Compute the length of the value name (including
        //  the terminating NULL).
        //

        cchValue = strlen( szValue ) + 1;

        //
        //  Determine if there is room in the array, taking into
        //  account the second NULL that terminates the string list.
        //

        if( ( lpTmp + cchValue + 1 ) > lpEnd )
        {
            break;
        }

        //
        //  Append the value name.
        //

        strcpy( lpTmp, szValue );
        lpTmp += cchValue;

        //
        //  Advance to next value.
        //

        iValue++;
    }

    //
    //  Success!
    //

    return (LPSTR)lpMultiSz;

}   // KludgeMultiSz


BOOL
ReadIPList(
    LPWSTR  pszRegKey,
    LPWSTR  pszRegSubKey,
    INETA_IP_SEC_LIST** ppIpSec
    )
/*++
  Description:
    This function reads the IP list from registry location
     specified in the pszRegKey + pszRegSubKey and stores the list in the
     internal list in memory.

     If there are no entries in the registry then this returns
      a NULL IP Security list object.
     If there is a new list, this function also frees the old list
      present in *ppIPSecList

  Arguments:
    pszRegKey - pointer to string containing the registry key
                where pszRegSubKey is located
    pszRegSubKey - pointer to string containing the registry key
                where IP list is stored relative to pszRegKey

  Returns:

    TRUE on success and FALSE on failure
--*/
{
    HKEY    hkey;
    DWORD   dwError;
    BOOL    fReturn = TRUE;
    LPWSTR  pszK;

    *ppIpSec = NULL;

    if ( (pszK = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(pszRegKey)+wcslen(pszRegSubKey)+2)*sizeof(WCHAR))) == NULL )
    {
        return FALSE;
    }

    wcscpy( pszK, pszRegKey );
    wcscat( pszK, L"\\" );
    wcscat( pszK, pszRegSubKey );

    dwError = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            pszK,
                            0,
                            KEY_ALL_ACCESS,
                            &hkey );

    LocalFree( pszK );

    if ( dwError != NO_ERROR) {

        if ( dwError != ERROR_FILE_NOT_FOUND ) {

            // maybe access denied or some other error.

            SetLastError( dwError );
            return (FALSE);
        }

        //
        //  A non-existent key is the same as a blank key
        //

    } else {

        CHAR *              psz;
        CHAR *              pszTmp;
        DWORD               cb;
        DWORD               cEntries = 0;
        INETA_IP_SEC_LIST * pIPSec = NULL;

        psz = pszTmp = KludgeMultiSz( hkey, &cb );

        RegCloseKey( hkey );

        //
        // Count the number of addresses and then add them to the list
        //

        if ( psz != NULL ) {

            for( ; *pszTmp; cEntries++ ) {

                pszTmp += strlen( pszTmp ) + 1;
            }

            pszTmp = psz;

            if ( cEntries > 0) {

                pIPSec = ((INETA_IP_SEC_LIST *)
                          LocalAlloc( LMEM_FIXED,
                                      sizeof(INETA_IP_SEC_LIST) +
                                      cEntries * sizeof(INETA_IP_SEC_ENTRY ))
                          );

                if ( pIPSec == NULL ) {

                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    fReturn = FALSE;
                } else {

                    for( pIPSec->cEntries = 0;
                        *pszTmp;
                        pszTmp += strlen( pszTmp ) + 1
                        ) {

                        if (!DottedDecimalToDword( &pszTmp,
                                                  &pIPSec->aIPSecEntry[pIPSec->cEntries].dwMask ) ||
                            !DottedDecimalToDword( &pszTmp,
                                              &pIPSec->aIPSecEntry[pIPSec->cEntries].dwNetwork )
                            ) {
                        } else {

                            pIPSec->cEntries++;
                        }
                    } // for

                    dwError = NO_ERROR;
                }
            }

            if ( dwError == NO_ERROR) {
                *ppIpSec = pIPSec;
            }

            LocalFree( psz );
        }

        if ( !fReturn) {

            SetLastError( dwError);
        }
    }

    return ( fReturn);
} // IPAccessList::ReadIPList()


BOOL
DottedDecimalToDword(
    CHAR * * ppszAddress,
    DWORD *  pdwAddress )
/*++

Routine Description:

    Converts a dotted decimal IP string to it's network equivalent

    Note: White space is eaten before *pszAddress and pszAddress is set
    to the character following the converted address

Arguments:

    ppszAddress - Pointer to address to convert.  White space before the
        address is OK.  Will be changed to point to the first character after
        the address
    pdwAddress - DWORD equivalent address in network order

    returns TRUE if successful, FALSE if the address is not correct

--*/
{
    CHAR *          psz;
    USHORT          i;
    ULONG           value;
    int             iSum =0;
    ULONG           k = 0;
    UCHAR           Chr;
    UCHAR           pArray[4];

    psz = *ppszAddress;

    //
    //  Skip white space
    //

    while ( *psz && !isdigit( (UCHAR)(*psz) ))
        psz++;

    //
    //  Convert the four segments
    //

    pArray[0] = 0;
    Chr = *psz;

    while ( ( Chr != '\0' ) && (Chr != ' ') )
    {
        if (Chr == '.')
        {
            // be sure not to overflow a byte.
            if (iSum <= 0xFF)
                pArray[k] = (UCHAR)iSum;
            else
                return FALSE;

            // check for too many periods in the address
            if (++k > 3)
                return FALSE;

            pArray[k] = 0;
            iSum = 0;
        }
        else
        {
            Chr = Chr - '0';

            // be sure character is a number 0..9
            if ((Chr < 0) || (Chr > 9))
                return FALSE;

            iSum = iSum*10 + Chr;
        }

        psz++;
        Chr = *psz;
    }

    // save the last sum in the byte and be sure there are 4 pieces to the
    // address
    if ((iSum <= 0xFF) && (k == 3))
        pArray[k] = (UCHAR)iSum;
    else
        return FALSE;

    // now convert to a ULONG, in network order...
    value = 0;

    // go through the array of bytes and concatenate into a ULONG
    for (i=0; i < 4; i++ )
    {
        value = (value << 8) + pArray[i];
    }
    *pdwAddress = htonl( value );

    *ppszAddress = psz;

    return TRUE;
}


BOOL
FillAddrCheckFromIpList(
    BOOL fIsGrant,
    LPINET_INFO_IP_SEC_LIST pInfo,
    ADDRESS_CHECK *pCheck
    )
/*++

Routine Description:

    Fill an access check object from an IP address list from

Arguments:

    fIsGrant - TRUE to access grant list, FALSE to access deny list
    pInfo - ptr to IP address list
    pCheck - ptr to address check object to update

Return:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    x;

    if ( pInfo )
    {
        for ( x = 0 ; x < pInfo->cEntries ; ++x )
        {
            if ( ! pCheck->AddAddr( fIsGrant,
                                    AF_INET,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwMask,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwNetwork ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

DWORD
MigrateServiceIpSec(
    LPWSTR  pszSrvRegKey,
    LPWSTR  pszSrvMetabasePath
    )
{
    INETA_IP_SEC_LIST*  pGrant = NULL;
    INETA_IP_SEC_LIST*  pDeny = NULL;
    ADDRESS_CHECK       acCheck;
    DWORD               err = 0;

    if ( ReadIPList( pszSrvRegKey, IPSEC_GRANT_LIST, &pGrant ) &&
         ReadIPList( pszSrvRegKey, IPSEC_DENY_LIST, &pDeny ) )
    {
        if ( pGrant || pDeny )
        {
            acCheck.BindCheckList( NULL, 0 );

            if ( FillAddrCheckFromIpList( TRUE, pGrant, &acCheck ) &&
                 FillAddrCheckFromIpList( FALSE, pDeny, &acCheck ) )
            {
                CMDKey cmdKey;
                cmdKey.OpenNode(pszSrvMetabasePath);
                if ( (METADATA_HANDLE)cmdKey ) {
                        cmdKey.SetData(
                            MD_IP_SEC,
                            METADATA_INHERIT | METADATA_REFERENCE,
                            IIS_MD_UT_FILE,
                            BINARY_METADATA,
                            acCheck.GetStorage()->GetUsed(),
                            (acCheck.GetStorage()->GetAlloc()
                                          ? acCheck.GetStorage()->GetAlloc() : (LPBYTE)"")
                                      );
                    cmdKey.Close();
                }
            }
        }

        acCheck.UnbindCheckList();
    }
    else
    {
        err = GetLastError();
    }

    if ( pGrant )
    {
        LocalFree( pGrant );
    }

    if ( pDeny )
    {
        LocalFree( pDeny );
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\kill.cpp ===
#include "stdafx.h"
#include <windows.h>
#include <winuserp.h>
#include <winperf.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kill.h"


PUCHAR  g_CommonLargeBuffer = NULL;
ULONG   g_CommonLargeBufferSize = 64*1024;

DWORD
GetTaskListEx(
    PTASK_LIST                          pTask,
    DWORD                               dwNumTasks,
    BOOL                                fThreadInfo,
    DWORD                               dwNumServices,
    const _ENUM_SERVICE_STATUS_PROCESSA* pServiceInfo
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:
    pTask           - Array of TASK_LIST structures to fill.
    dwNumTasks      - Maximum number of tasks that the pTask array can hold.
    fThreadInfo     - TRUE if thread information is desired.
    dwNumServices   - Maximum number of entries in pServiceInfo.
    pServiceInfo    - Array of service status structures to reference
                      for supporting services in processes.

Return Value:

    Number of tasks placed into the pTask array.

--*/
{
#ifndef _CHICAGO_
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo = NULL;
    NTSTATUS                     status;
    ANSI_STRING                  pname;
    PCHAR                        p = NULL;
    
    ULONG                        TotalOffset;
    ULONG                        totalTasks = 0;

retry:

    if (g_CommonLargeBuffer == NULL) 
    {
        g_CommonLargeBuffer = (PUCHAR) VirtualAlloc(NULL,g_CommonLargeBufferSize,MEM_COMMIT,PAGE_READWRITE);
        if (g_CommonLargeBuffer == NULL) 
        {
            return 0;
        }
    }
    status = NtQuerySystemInformation(SystemProcessInformation,g_CommonLargeBuffer,g_CommonLargeBufferSize,NULL);

    if (status == STATUS_INFO_LENGTH_MISMATCH) 
    {
        g_CommonLargeBufferSize += 8192;
        VirtualFree (g_CommonLargeBuffer, 0, MEM_RELEASE);
        g_CommonLargeBuffer = NULL;
        goto retry;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) g_CommonLargeBuffer;
    TotalOffset = 0;
    while (TRUE) 
    {
        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) 
        {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
            if (pname.Buffer) 
            {
                p = strrchr(pname.Buffer,'\\');
                if ( p ) 
                {
                    p++;
                }
                else 
                {
                    p = pname.Buffer;
                }
            }
            else 
            {
                p = "";
            }
        }
        else 
        {
            p = "System Process";
        }

        strncpy( pTask->ProcessName, p, PROCESS_SIZE );
        pTask->ProcessName[ PROCESS_SIZE - 1 ] = '\0';
       
        pTask->flags = 0;
        pTask->dwProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;
        pTask->dwInheritedFromProcessId = (DWORD)(DWORD_PTR)ProcessInfo->InheritedFromUniqueProcessId;
        pTask->CreateTime.QuadPart = (ULONGLONG)ProcessInfo->CreateTime.QuadPart;

        pTask->PeakVirtualSize = ProcessInfo->PeakVirtualSize;
        pTask->VirtualSize = ProcessInfo->VirtualSize;
        pTask->PageFaultCount = ProcessInfo->PageFaultCount;
        pTask->PeakWorkingSetSize = ProcessInfo->PeakWorkingSetSize;
        pTask->WorkingSetSize = ProcessInfo->WorkingSetSize;
        pTask->NumberOfThreads = ProcessInfo->NumberOfThreads;

        if (fThreadInfo) 
        {
            pTask->pThreadInfo = (PTHREAD_INFO) malloc(pTask->NumberOfThreads * sizeof(THREAD_INFO));

            if ( pTask->pThreadInfo ) {

                UINT nThread = pTask->NumberOfThreads;
                PTHREAD_INFO pThreadInfo = pTask->pThreadInfo;
                PSYSTEM_THREAD_INFORMATION pSysThreadInfo =
                    (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

                while (nThread--) {
                    pThreadInfo->ThreadState = pSysThreadInfo->ThreadState;
                    pThreadInfo->UniqueThread = pSysThreadInfo->ClientId.UniqueThread;

                    pThreadInfo++;
                    pSysThreadInfo++;
                }
            }
        }
        else 
        {
            pTask->pThreadInfo = NULL;
        }

        // Initialize the ServiceNames if this task hosts any.
        //
        *pTask->ServiceNames = 0;
        if (dwNumServices)
        {
            // For each service with this process id, append it's service
            // name to the buffer.  Separate each with a comma.
            //
            BOOL    fFirstTime = TRUE;
            DWORD   iSvc;
            size_t  cchRemain = SERVICENAMES_SIZE - 1;
            size_t  cch;

            for (iSvc = 0; iSvc < dwNumServices; iSvc++) {
                if (pTask->dwProcessId == pServiceInfo[iSvc].ServiceStatusProcess.dwProcessId) {
                    cch = strlen(pServiceInfo[iSvc].lpServiceName);

                    if (fFirstTime) {
                        fFirstTime = FALSE;

                        strncpy(
                            pTask->ServiceNames,
                            pServiceInfo[iSvc].lpServiceName,
                            cchRemain);

                        // strncpy may not terminate the string if
                        // cchRemain <= cch so we do it regardless.
                        //
                        pTask->ServiceNames[SERVICENAMES_SIZE - 1] = '\0';
                    } else if (cchRemain > 1) { // ensure room for the comma
                        strncat(
                            pTask->ServiceNames,
                            ",",
                            cchRemain--);

                        strncat(
                            pTask->ServiceNames,
                            pServiceInfo[iSvc].lpServiceName,
                            cchRemain);
                    }

                    // Counts are unsigned so we have to check before
                    // subtracting.
                    //
                    if (cchRemain < cch) {
                        // No more room for any more.
                        break;
                    } else {
                        cchRemain -= cch;
                    }
                }
            }
        }

        pTask++;
        totalTasks++;
        if (totalTasks >= dwNumTasks) 
        {
            break;
        }
        if (ProcessInfo->NextEntryOffset == 0) 
        {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&g_CommonLargeBuffer[TotalOffset];
    }

    return totalTasks;
#else
    return 0;
#endif
}

DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    )
{
    return GetTaskListEx(pTask, dwNumTasks, FALSE, 0, NULL);
}

void FreeTaskListMem(void)
{
    if (g_CommonLargeBuffer)
    {
        VirtualFree (g_CommonLargeBuffer, 0, MEM_RELEASE);
        g_CommonLargeBuffer = NULL;
    }
    return;
}
BOOL DetectOrphans(PTASK_LIST pTask,DWORD dwNumTasks)
{
    DWORD i, j;
    BOOL Result = FALSE;

    for (i=0; i<dwNumTasks; i++) {
        if (pTask[i].dwInheritedFromProcessId != 0) {
            for (j=0; j<dwNumTasks; j++) {
                if (i != j && pTask[i].dwInheritedFromProcessId == pTask[j].dwProcessId) {
                    if (pTask[i].CreateTime.QuadPart <= pTask[j].CreateTime.QuadPart) {
                        pTask[i].dwInheritedFromProcessId = 0;
                        Result = TRUE;
                        }

                    break;
                    }
                }
            }
        }

    return Result;
}

/*++
Routine Description:
    Changes the tlist process's privilige so that kill works properly.
Return Value:
    TRUE             - success
    FALSE            - failure

--*/
BOOL EnableDebugPriv(VOID)
{
    HANDLE hToken;
    LUID DebugValue;
    TOKEN_PRIVILEGES tkp;

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) {
        //printf("OpenProcessToken failed with %d\n", GetLastError());
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depending on the fEnable flag.
    //
    //if (!LookupPrivilegeValue((LPSTR) NULL,SE_DEBUG_NAME,&DebugValue))
    if (!LookupPrivilegeValueA((LPSTR) NULL,"SeDebugPrivilege",&DebugValue))
    {
        //printf("LookupPrivilegeValue failed with %d\n", GetLastError());
        return FALSE;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tkp,
            sizeof(TOKEN_PRIVILEGES),
            (PTOKEN_PRIVILEGES) NULL,
            (PDWORD) NULL)) {
        //
        // The return value of AdjustTokenPrivileges be texted
        //
        //printf("AdjustTokenPrivileges failed with %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL KillProcess(PTASK_LIST tlist,BOOL fForce)
{
    HANDLE            hProcess1 = NULL;
    HANDLE            hProcess2 = NULL;
    HDESK             hdeskSave = NULL;
    HDESK             hdesk = NULL;
    HWINSTA           hwinsta = NULL;
    HWINSTA           hwinstaSave = NULL;

    if (fForce || !tlist->hwnd) {
        hProcess1 = OpenProcess( PROCESS_ALL_ACCESS, FALSE, (DWORD) (DWORD_PTR) tlist->dwProcessId );
        if (hProcess1) 
        {
            hProcess2 = OpenProcess( PROCESS_ALL_ACCESS, FALSE, (DWORD) (DWORD_PTR) tlist->dwProcessId );
            if (hProcess2 == NULL) 
            {
                // clean up memory already allocated
                CloseHandle( hProcess1 );
                return FALSE;
            }

            if (!TerminateProcess( hProcess2, 1 )) 
            {
                CloseHandle( hProcess1 );
                CloseHandle( hProcess2 );
                return FALSE;
            }

            CloseHandle( hProcess1 );
            CloseHandle( hProcess2 );
            return TRUE;
        }
    }

    //
    // save the current windowstation
    //
    hwinstaSave = GetProcessWindowStation();

    //
    // save the current desktop
    //
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // open the windowstation
    //
    hwinsta = OpenWindowStationA( tlist->lpWinsta, FALSE, MAXIMUM_ALLOWED );
    if (!hwinsta) {
        return FALSE;
    }

    //
    // change the context to the new windowstation
    //
    SetProcessWindowStation( hwinsta );

    //
    // open the desktop
    //
    hdesk = OpenDesktopA( tlist->lpDesk, 0, FALSE, MAXIMUM_ALLOWED );
    if (!hdesk) {
        return FALSE;
    }

    //
    // change the context to the new desktop
    //
    SetThreadDesktop( hdesk );

    //
    // kill the process
    //
    PostMessage( (HWND) tlist->hwnd, WM_CLOSE, 0, 0 );

    //
    // restore the previous desktop
    //
    if (hdesk != hdeskSave) {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hdesk );
    }

    //
    // restore the context to the previous windowstation
    //
    if (hwinsta != hwinstaSave) {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    return TRUE;
}


VOID GetWindowTitles(PTASK_LIST_ENUM te)
{
    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    EnumWindowStations( (WINSTAENUMPROC) EnumWindowStationsFunc, (LPARAM)te );
}


/*++
Routine Description:
    Callback function for windowstation enumeration.
Arguments:
    lpstr            - windowstation name
    lParam           - ** not used **
Return Value:
    TRUE  - continues the enumeration
--*/
BOOL CALLBACK EnumWindowStationsFunc(LPSTR lpstr,LPARAM lParam)
{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HWINSTA           hwinsta;
    HWINSTA           hwinstaSave;


    //
    // open the windowstation
    //
    hwinsta = OpenWindowStationA( lpstr, FALSE, MAXIMUM_ALLOWED );
    if (!hwinsta) {
        return FALSE;
    }

    //
    // save the current windowstation
    //
    hwinstaSave = GetProcessWindowStation();

    //
    // change the context to the new windowstation
    //
    SetProcessWindowStation( hwinsta );

    te->lpWinsta = _strdup( lpstr );

    //
    // enumerate all the desktops for this windowstation
    //
    EnumDesktops( hwinsta, (DESKTOPENUMPROC) EnumDesktopsFunc, lParam );

    //
    // restore the context to the previous windowstation
    //
    if (hwinsta != hwinstaSave) {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    //
    // continue the enumeration
    //
    return TRUE;
}


/*++
Routine Description:
    Callback function for desktop enumeration.
Arguments:
    lpstr            - desktop name
    lParam           - ** not used **
Return Value:
    TRUE  - continues the enumeration

--*/
BOOL CALLBACK EnumDesktopsFunc(LPSTR  lpstr,LPARAM lParam)
{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HDESK             hdeskSave;
    HDESK             hdesk;


    //
    // open the desktop
    //
    hdesk = OpenDesktopA( lpstr, 0, FALSE, MAXIMUM_ALLOWED );
    if (!hdesk) {
        return FALSE;
    }

    //
    // save the current desktop
    //
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // change the context to the new desktop
    //
    SetThreadDesktop( hdesk );

    te->lpDesk = _strdup( lpstr );

    //
    // enumerate all windows in the new desktop
    //

    ((PTASK_LIST_ENUM)lParam)->bFirstLoop = TRUE;
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, lParam );

    ((PTASK_LIST_ENUM)lParam)->bFirstLoop = FALSE;
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, lParam );

    //
    // restore the previous desktop
    //
    if (hdesk != hdeskSave) {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hdesk );
    }

    return TRUE;
}


/*++
Routine Description:
    Callback function for window enumeration.
Arguments:
    hwnd             - window handle
    lParam           - pte
Return Value:
    TRUE  - continues the enumeration
--*/
BOOL CALLBACK EnumWindowsProc(HWND hwnd,LPARAM lParam)
{
    DWORD             pid = 0;
    DWORD             i;
    CHAR              buf[TITLE_SIZE];
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    PTASK_LIST        tlist = te->tlist;
    DWORD             numTasks = te->numtasks;


    //
    // Use try/except block when enumerating windows,
    // as a window may be destroyed by another thread
    // when being enumerated.
    //
    //try {
        //
        // get the processid for this window
        //
        if (!GetWindowThreadProcessId( hwnd, &pid )) {
            return TRUE;
        }

        if ((GetWindow( hwnd, GW_OWNER )) ||
            (!(GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)) && te->bFirstLoop) {
            //
            // not a top level window
            //
            return TRUE;
        }

        //
        // look for the task in the task list for this window
        // If this is the second time let invisible windows through if we don't
        // have a window already
        //
        for (i=0; i<numTasks; i++) {
            if (((DWORD) (DWORD_PTR)tlist[i].dwProcessId == pid) && (te->bFirstLoop || (tlist[i].hwnd == 0))) {
                tlist[i].hwnd = hwnd;
                tlist[i].lpWinsta = te->lpWinsta;
                tlist[i].lpDesk = te->lpDesk;
                //
                // we found the task no lets try to get the
                // window text
                //
                if (GetWindowTextA( (HWND) tlist[i].hwnd, buf, sizeof(buf) )) {
                    //
                    // go it, so lets save it
                    //
                    lstrcpyA( tlist[i].WindowTitle, buf );
                }
                break;
            }
        }
    //} except(EXCEPTION_EXECUTE_HANDLER) {
    //}

    //
    // continue the enumeration
    //
    return TRUE;
}


BOOL MatchPattern(PUCHAR String,PUCHAR Pattern)
{
    UCHAR   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = (UCHAR)toupper(c);
                l = 0;
                while ( (p = *Pattern++ ) != '\0' ) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (toupper(c) != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}


struct _ProcessIDStruct
{
    DWORD pid;
    CHAR pname[MAX_PATH];
} g_Arguments[ 64 ];

DWORD g_dwNumberOfArguments;

int _cdecl KillProcessNameReturn0(CHAR *ProcessNameToKill)
{
    DWORD          i, j;
    DWORD          numTasks;
    TASK_LIST_ENUM te;
    int            rval = 0;
    CHAR           tname[PROCESS_SIZE];
    LPSTR          p;
    DWORD          ThisPid;

    BOOL           iForceKill  = TRUE;
    TASK_LIST      The_TList[MAX_TASKS];

    g_dwNumberOfArguments = 0;
    //
    // Get the process name into the array
    //
    g_Arguments[g_dwNumberOfArguments].pid = 0;

    // make sure there is no path specified.
    char pfilename_only[_MAX_FNAME];
    char pextention_only[_MAX_EXT];
    _splitpath( ProcessNameToKill, NULL, NULL, pfilename_only, pextention_only);
    if (pextention_only) {strcat(pfilename_only,pextention_only);}

    if ( strlen(pfilename_only) >= MAX_PATH )
    {
      return ( ERROR_INVALID_PARAMETER );
    }

    // make it uppercase
    lstrcpyA(g_Arguments[g_dwNumberOfArguments].pname, pfilename_only);
    _strupr( g_Arguments[g_dwNumberOfArguments].pname );

    g_dwNumberOfArguments += 1;

    //
    // lets be god
    //
    EnableDebugPriv();

    //
    // get the task list for the system
    //
    numTasks = GetTaskList( The_TList, MAX_TASKS );

    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    te.tlist = The_TList;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    ThisPid = GetCurrentProcessId();

    for (i=0; i<numTasks; i++) {
        //
        // this prevents the user from killing KILL.EXE and
        // it's parent cmd window too
        //
        if (ThisPid == (DWORD) (DWORD_PTR) The_TList[i].dwProcessId) {
            continue;
        }
        if (MatchPattern( (PUCHAR) The_TList[i].WindowTitle, (PUCHAR) "*KILL*" )) {
            continue;
        }

        tname[0] = 0;
        lstrcpyA( tname, The_TList[i].ProcessName );
        p = strchr( tname, '.' );
        if (p) {
            p[0] = '\0';
        }

        for (j=0; j<g_dwNumberOfArguments; j++) {
            if (g_Arguments[j].pname) {
                if (MatchPattern( (PUCHAR) tname, (PUCHAR) g_Arguments[j].pname )) {
                    The_TList[i].flags = TRUE;
                } else if (MatchPattern( (PUCHAR) The_TList[i].ProcessName, (PUCHAR) g_Arguments[j].pname )) {
                    The_TList[i].flags = TRUE;
                } else if (MatchPattern( (PUCHAR) The_TList[i].WindowTitle, (PUCHAR) g_Arguments[j].pname )) {
                    The_TList[i].flags = TRUE;
                }
            } else if (g_Arguments[j].pid) {
                    if ((DWORD) (DWORD_PTR) The_TList[i].dwProcessId == g_Arguments[j].pid) {
                        The_TList[i].flags = TRUE;
                    }
            }
        }
    }

    for (i=0; i<numTasks; i++)
        {
        if (The_TList[i].flags)
            {
            if (KillProcess( &The_TList[i], iForceKill ))
                {
                //printf( "process %s (%d) - '%s' killed\n", The_TList[i].ProcessName,The_TList[i].dwProcessId,The_TList[i].hwnd ? The_TList[i].WindowTitle : "");
                }
            else
                {
                //printf( "process %s (%d) - '%s' could not be killed\n",The_TList[i].ProcessName,The_TList[i].dwProcessId,The_TList[i].hwnd ? The_TList[i].WindowTitle : "");
                rval = 1;
                }
            }
        }

    FreeTaskListMem();

    return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\log.h ===
#include "stdafx.h"
#include "resource.h"

// Stuff for logfile
LPWSTR	MakeWideStrFromAnsi(LPSTR psz);
void	MakePath(LPTSTR lpPath);
void	AddPath(LPTSTR szPath, LPCTSTR szName );
CString AddPath(CString szPath, LPCTSTR szName );

class MyLogFile
{
protected:
	// for our log file
	TCHAR		m_szLogFileName[MAX_PATH];
	BOOL        m_bDisplayTimeStamp;
	BOOL        m_bDisplayPreLineInfo;

	HANDLE  m_hFile;

public:
    TCHAR		m_szLogFileName_Full[MAX_PATH];

    MyLogFile();
    ~MyLogFile();

	TCHAR		m_szLogPreLineInfo[100];
	TCHAR		m_szLogPreLineInfo2[100];
    BOOL        m_bFlushLogToDisk;
	
	int  LogFileCreate(TCHAR * lpLogFileName);
	int  LogFileClose();

	void LogFileTimeStamp();
	void LogFileWrite(TCHAR * pszFormatString, ...);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\kill.h ===
#pragma once

#if defined(__cplusplus)
extern "C" {
#endif

#define MAX_TASKS           256
#define TITLE_SIZE          128
#define PROCESS_SIZE        16
#define SERVICENAMES_SIZE   256

typedef struct _THREAD_INFO {
    ULONG ThreadState;
    HANDLE UniqueThread;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _FIND_MODULE_INFO {
    LPSTR  szModuleToFind;
    LPSTR  szMatchingModuleName;
    BOOL   fFound;
} FIND_MODULE_INFO, *PFIND_MODULE_INFO;


//
// task list structure
//
typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    ULARGE_INTEGER CreateTime;
    BOOL        flags;
    HANDLE      hwnd;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    CHAR        ProcessName[PROCESS_SIZE];
    CHAR        WindowTitle[TITLE_SIZE];
    SIZE_T      PeakVirtualSize;
    SIZE_T      VirtualSize;
    ULONG       PageFaultCount;
    SIZE_T      PeakWorkingSetSize;
    SIZE_T      WorkingSetSize;
    ULONG       NumberOfThreads;
    PTHREAD_INFO pThreadInfo;
    CHAR        ServiceNames[SERVICENAMES_SIZE];
} TASK_LIST, *PTASK_LIST;

typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    BOOL        bFirstLoop;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;


DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

DWORD
GetTaskListEx(
    PTASK_LIST                          pTask,
    DWORD                               dwNumTasks,
    BOOL                                fThreadInfo,
    DWORD                               dwNumServices,
    const ENUM_SERVICE_STATUS_PROCESSA*  pServiceInfo
    );

BOOL
DetectOrphans(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

BOOL
EnableDebugPriv(
    VOID
    );

BOOL
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    );

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    );

BOOL
MatchPattern(
    PUCHAR String,
    PUCHAR Pattern
    );

BOOL
EmptyProcessWorkingSet(
    DWORD pid
    );

void FreeTaskListMem(void);

#if defined(__cplusplus)
}
#endif

int _cdecl KillProcessNameReturn0(CHAR *ProcessNameToKill);
BOOL CALLBACK EnumWindowsProc(HWND hwnd,LPARAM lParam);
BOOL CALLBACK EnumWindowStationsFunc(LPSTR lpstr, LPARAM lParam);
BOOL CALLBACK EnumDesktopsFunc(LPSTR lpstr,LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\log.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "log.h"
#include "acl.hxx"


// critical section needed to safely write to the logfile
CRITICAL_SECTION        critical_section;


//***************************************************************************
//*                                                                         
//* purpose: constructor
//*
//***************************************************************************
MyLogFile::MyLogFile(void)
{
	_tcscpy(m_szLogFileName, _T(""));
	_tcscpy(m_szLogFileName_Full, _T(""));
	_tcscpy(m_szLogPreLineInfo, _T(""));
	_tcscpy(m_szLogPreLineInfo2, _T(""));
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;
    m_bFlushLogToDisk = FALSE;

	m_hFile = NULL;

	// initialize the critical section
	INITIALIZE_CRITICAL_SECTION( &critical_section );
}

//***************************************************************************
//*                                                                         
//* purpose: destructor
//*
//***************************************************************************
MyLogFile::~MyLogFile(void)
{
	DeleteCriticalSection( &critical_section );
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileCreate(TCHAR *lpLogFileName )
{
	int iReturn = FALSE;
  TSTR  strDriveOnly( _MAX_DRIVE );
  TSTR  strPathOnly( MAX_PATH );
  TSTR  strFileNameOnly( MAX_PATH );
  TSTR  strFileNameBackup( MAX_PATH );

	LPWSTR  pwsz = NULL;
  CSecurityDescriptor LogFileSD;

	// because of the global flags and such, we'll make this critical
	EnterCriticalSection( &critical_section );

	if (lpLogFileName == NULL)
	{
    TSTR strModuleFileName;

    if ( !strFileNameOnly.Resize( MAX_PATH ) )
    {
      return FALSE;
    }

		// if a logfilename was not specified then use the module name.
    if (0 == GetModuleFileName(NULL, strModuleFileName.QueryStr(), _MAX_PATH))
    {
      // Use Default Name
      if ( !strFileNameOnly.Copy( _T("iis6.log") ) )
      {
        return FALSE;
      }
    }
    else
    {
		  // get only the filename
		  _tsplitpath( strModuleFileName.QueryStr() , NULL, NULL, strFileNameOnly.QueryStr(), NULL);

		  if ( !strFileNameOnly.Append( _T(".LOG") ) )
      {
        return FALSE;
      }
    }

    _tcsncpy( m_szLogFileName, 
              strFileNameOnly.QueryStr(), 
              sizeof(m_szLogFileName)/sizeof(m_szLogFileName[0]) );
    m_szLogFileName[ ( sizeof(m_szLogFileName) / sizeof(m_szLogFileName[0]) ) - 1 ] = _T('\0');
  }
	else
  {
    _tcsncpy( m_szLogFileName, 
              lpLogFileName,
              sizeof(m_szLogFileName)/sizeof(m_szLogFileName[0]) );
    m_szLogFileName[ ( sizeof(m_szLogFileName) / sizeof(m_szLogFileName[0]) ) - 1 ] = _T('\0');
  }

	if (GetWindowsDirectory(m_szLogFileName_Full, sizeof(m_szLogFileName_Full)/sizeof(m_szLogFileName_Full[0])))
  {
    AddPath(m_szLogFileName_Full, m_szLogFileName);
    if (GetFileAttributes(m_szLogFileName_Full) != 0xFFFFFFFF)
    {
      // there is a current .log file already there.
      // if it is larger than 2megs then rename it.
      DWORD dwSize1 = ReturnFileSize(m_szLogFileName_Full);
      if (dwSize1 == 0xFFFFFFFF || dwSize1 > 2000000)
      {
        // unable to retrieve the size of one of those files
        // or the size is bigger than 2megs.
        // backup the old one.

        // Make a backup of the current log file
			  _tsplitpath( m_szLogFileName_Full, 
                     strDriveOnly.QueryStr(), 
                     strPathOnly.QueryStr(), 
                     strFileNameOnly.QueryStr(), 
                     NULL);

        if (  !strFileNameBackup.Copy( strDriveOnly ) &&
              !strFileNameBackup.Append( strPathOnly ) &&
              !strFileNameBackup.Append( strFileNameOnly ) &&
              !strFileNameBackup.Append( _T(".bak") ) )
        {
          return FALSE;
        }

        SetFileAttributes(strFileNameBackup.QueryStr(), FILE_ATTRIBUTE_NORMAL);
        DeleteFile( strFileNameBackup.QueryStr() );
        if ( MoveFile(m_szLogFileName_Full, strFileNameBackup.QueryStr()) == 0 )
		    {
			    // This failed
          //MyMessageBox(NULL,_T("LogFile MoveFile Failed"),_T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
		    }
      }
    }

#if defined(UNICODE) || defined(_UNICODE)
	  pwsz = m_szLogFileName_Full;
#else
	  pwsz = MakeWideStrFromAnsi( m_szLogFileName_Full);
#endif

    // Create a Security Descriptor with only Administrators and Local System, then open
    // the file with it
    if ( LogFileSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::GROUP_ADMINISTRATORS,
                                              CSecurityDescriptor::ACCESS_FULL,
                                              TRUE,
                                              FALSE ) &&
        LogFileSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::USER_LOCALSYSTEM,
                                              CSecurityDescriptor::ACCESS_FULL,
                                              TRUE,
                                              FALSE )
      )
    {
      // Open existing file or create a new one.
		  m_hFile = CreateFile( m_szLogFileName_Full,
                            GENERIC_READ | GENERIC_WRITE | WRITE_DAC,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            LogFileSD.QuerySA(), //NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

		  if (m_hFile == INVALID_HANDLE_VALUE)
		  {
			  m_hFile = NULL;
			  //MyMessageBox(NULL, _T("Unable to create iis setup log file"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
		  }
		  else 
		  {
        SetFilePointer( m_hFile, NULL, NULL, FILE_END );
			  iReturn = TRUE;
		  }

		  //LogFileTimeStamp();
		  LogFileWrite(_T("LogFile Open. [***** Search on FAIL/MessageBox keywords for failures *****].\r\n"));
    }
  }


	// safe to leave the critical section
	LeaveCriticalSection( &critical_section );

	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileClose(void)
{
	if (m_hFile)
	{
		LogFileWrite(_T("LogFile Close.\r\n"));
		CloseHandle(m_hFile);
    m_hFile = NULL;
		return TRUE;
	}

	return FALSE;
}


//***************************************************************************
//*                                                                         
//* purpose: add stuff to logfile
//*
//***************************************************************************
void MyLogFile::LogFileTimeStamp()
{
  SYSTEMTIME  SystemTime;

  GetLocalTime(&SystemTime);
  m_bDisplayTimeStamp = FALSE;
  m_bDisplayPreLineInfo = FALSE;

  LogFileWrite(_T("[%d/%d/%d %d:%d:%d]\r\n"),SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
  m_bDisplayTimeStamp = TRUE;
  m_bDisplayPreLineInfo = TRUE;
}


//***************************************************************************
//*                                                                         
//* purpose: 
//* 
//***************************************************************************
#define LOG_STRING_LEN 1000
void MyLogFile::LogFileWrite(TCHAR *pszFormatString, ...)
{
    if (m_hFile)
    {
       // because of the global flags and such, we'll make this critical
       EnterCriticalSection( &critical_section );

       va_list args;
       TCHAR pszFullErrMsg[ LOG_STRING_LEN ];
       char  pszFullErrMsgA[ LOG_STRING_LEN ];
       strcpy(pszFullErrMsgA, "");

       DWORD dwBytesWritten = 0;

       if (_tcslen(pszFormatString) > LOG_STRING_LEN)
       {
         // this will overrun our buffer, just get out
         goto MyLogFile_LogFileWrite_Exit;
       }

       __try
       {
           va_start(args, pszFormatString);
           if (!_vsntprintf(pszFullErrMsg, LOG_STRING_LEN, pszFormatString, args))
           {
             goto MyLogFile_LogFileWrite_Exit;
           }

           // Null terminate just incase _vsntprintf did not
           pszFullErrMsg[ LOG_STRING_LEN - 1 ] = '\0';

            va_end(args);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            goto MyLogFile_LogFileWrite_Exit;
        }

        if (*pszFullErrMsg)
        {
#if defined(UNICODE) || defined(_UNICODE)
	// convert to ascii then write to stream
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)pszFullErrMsg, -1, pszFullErrMsgA, LOG_STRING_LEN, NULL, NULL );
#else
	// the is already ascii so just copy the pointer
	strcpy(pszFullErrMsgA,pszFullErrMsg);
#endif

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayTimeStamp == TRUE)
			{
				// Get timestamp
				SYSTEMTIME  SystemTime;
				GetLocalTime(&SystemTime);
				char szDateandtime[50];
				sprintf(szDateandtime,"[%d/%d/%d %d:%d:%d] ",SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
				// Write time to stream
				if (m_hFile) {WriteFile(m_hFile,szDateandtime,strlen(szDateandtime),&dwBytesWritten,NULL);}
			}

			char szPrelineWriteString[100];
			char szPrelineWriteString2[100];

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayPreLineInfo == TRUE)
			{
				if (_tcscmp(m_szLogPreLineInfo,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo, -1, szPrelineWriteString, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString, m_szLogPreLineInfo);
#endif
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString,strlen(szPrelineWriteString),&dwBytesWritten,NULL);}
				}

				if (_tcscmp(m_szLogPreLineInfo2,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo2, -1, szPrelineWriteString2, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString2, m_szLogPreLineInfo2);
#endif
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString2,strlen(szPrelineWriteString2),&dwBytesWritten,NULL);}
				}
			}

			// if it does not end if '\r\n' then make one.
			int nLen = strlen(pszFullErrMsgA);

			if ( ( nLen >=1 ) &&
           ( nLen < ( sizeof(pszFullErrMsgA) - sizeof("\r\n") ) ) &&
           ( pszFullErrMsgA[nLen-1] != '\n' )
         )
      {
        strcat(pszFullErrMsgA, "\r\n");
      }
			else
			{
				if ( ( nLen >= 2 ) &&
             ( nLen < ( sizeof(pszFullErrMsgA) - sizeof("\r\n") ) ) &&
             ( pszFullErrMsgA[nLen-2] != '\r' ) 
           )
        {
					char * pPointer = NULL;
					pPointer = pszFullErrMsgA + (nLen-1);
					strcpy(pPointer, "\r\n");
        }
			}


			// Write Regular data to stream
			if (m_hFile) 
      {
        WriteFile(m_hFile,pszFullErrMsgA,strlen(pszFullErrMsgA),&dwBytesWritten,NULL);
        // since setup can get the rug pulled out from under it from anything
        // make sure the file is flushed to disk
        if (m_bFlushLogToDisk)
        {
            FlushFileBuffers(m_hFile);
        }
      } // if m_hFile
    }
  } // if m_hFile

MyLogFile_LogFileWrite_Exit:
		// safe to leave the critical section
		LeaveCriticalSection( &critical_section );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\lsakeys.h ===
#ifndef _LSAKEYS_H_
#define _LSAKEYS_H_

#ifndef _CHICAGO_

// This class is to help setup retrieve the old-style LSA keys and convert them
// into the new MetaData keys.

// error codes
enum {
	KEYLSA_SUCCESS = 0,
	KEYLSA_INVALID_VERSION,
	KEYLSA_NO_MORE_KEYS,
	KEYLSA_UNABLE_TO_OPEN_POLICY
	};


// Note: once you call LoadFirstKey, there is an open LSA policy until the object is deleted.
// This is done for speed purposes. So if you don't want the policy hanging around, don't
// keep the object around.

class CLSAKeys : public CObject
	{
	public:

	// construction
	CLSAKeys();
	~CLSAKeys();

	// loading the keys
	// LoadFirstKey loads the first key on the specified target machine. Until
	// this method is called, the data values in the object are meaningless
	DWORD	LoadFirstKey( PWCHAR pszwTargetMachine );

	// LoadNextKey loads the next key on the target machine specified in LoadFirstKey
	// LoadNextKey automatically cleans up the memory used by the previous key.
	DWORD	LoadNextKey();

	// DeleteAllLSAKeys deletes ALL remenents of the LSA keys in the Metabase.
	// (not including, of course anything written out there in the future as part
	// of some backup scheme when uninstalling). Call this only AFTER ALL the keys
	// have been converted to the metabase. They will no longer be there after
	// this routine is used.
	DWORD DeleteAllLSAKeys();

	// the data values that are to be filled in.
	// The public portion of the key - may be NULL and zero size
	DWORD	m_cbPublic;
	PVOID	m_pPublic;

	// the private portion of the key
	DWORD	m_cbPrivate;
	PVOID	m_pPrivate;

	// the password
	DWORD	m_cbPassword;
	PVOID	m_pPassword;

	// the certificate request - may be NULL and zero size
	DWORD	m_cbRequest;
	PVOID	m_pRequest;


	// the friendly name
	CHAR m_szFriendlyName[256];

	// the name that should be given to the metabase object for this key
	CHAR	m_szMetaName[256];

	private:
	// clean up the currently loaded key
	void UnloadKey();

	// delete utilities
	DWORD DeleteKMKeys();
	DWORD DeleteServerKeys();

	// LSA Utility routines
	HANDLE	HOpenLSAPolicy( PWCHAR pszwServer, DWORD *pErr );
	BOOL	FCloseLSAPolicy( HANDLE hPolicy, DWORD *pErr );

	BOOL	FStoreLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, void* pvData, WORD cbData, DWORD *pErr );
	PLSA_UNICODE_STRING	FRetrieveLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, DWORD *pErr );

	void	DisposeLSAData( PVOID pData );

	// the handle to the LSA policy
	HANDLE	m_hPolicy;

	// index of the current key
	DWORD	m_iKey;
	};

#endif //_CHICAGO_
#endif //_LSAKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\lsakeys.cpp ===
// This class is to help setup retrieve the old-style LSA keys and convert them
// into the new MetaData keys.
// created by BoydM 4/2/97

#include "stdafx.h"
#include "LSAKeys.h"

#ifndef _CHICAGO_

// it is assumed that #include "ntlsa.h" is included in stdafx.h

#define KEYSET_LIST				L"W3_KEY_LIST"
#define KEYSET_PUB_KEY			L"W3_PUBLIC_KEY_%s"
#define KEYSET_PRIV_KEY			L"W3_PRIVATE_KEY_%s"
#define KEYSET_PASSWORD			L"W3_KEY_PASSWORD_%s"
#define KEYSET_DEFAULT			L"Default"

#define	KEY_NAME_BASE			"W3_KEYMAN_KEY_"
#define	KEY_LINKS_SECRET_W		L"W3_KEYMAN_LINKS"
#define	KEYMAN_LINK_DEFAULT		"DEFAULT"
#define KEY_VERSION		0x102				// version we are converting from

#define	MDNAME_INCOMPLETE	"incomplete"
#define	MDNAME_DISABLED		"disabled"
#define	MDNAME_DEFAULT		"default"
#define	MDNAME_PORT			":443"			// use the default SSL port

//----------------------------------------------------------------------
// construction
CLSAKeys::CLSAKeys():
		m_cbPublic(0),
		m_pPublic(NULL),
		m_cbPrivate(0),
		m_pPrivate(NULL),
		m_cbPassword(0),
		m_pPassword(NULL),
		m_cbRequest(0),
		m_pRequest(NULL),
		m_hPolicy(NULL)
	{
	}

//----------------------------------------------------------------------
CLSAKeys::~CLSAKeys()
	{
	DWORD	err;

	// clear out the last loaded key
	UnloadKey();

	// if it is opehn, close the LSA policy
	if ( m_hPolicy )
		FCloseLSAPolicy( m_hPolicy, &err );
	};

//----------------------------------------------------------------------
// clean up the currently loaded key
void CLSAKeys::UnloadKey()
	{
	// unload the public key
	if ( m_cbPublic && m_pPublic )
		{
		GlobalFree( m_pPublic );
		m_cbPublic = 0;
		m_pPublic = NULL;
		}

	// unload the private key
	if ( m_cbPrivate && m_pPrivate )
		{
		GlobalFree( m_pPrivate );
		m_cbPrivate = 0;
		m_pPrivate = NULL;
		}

	// unload the password
	if ( m_cbPassword && m_pPassword )
		{
		GlobalFree( m_pPassword );
		m_cbPassword = 0;
		m_pPassword = NULL;
		}

	// unload the key request
	if ( m_cbRequest && m_pRequest )
		{
		GlobalFree( m_pRequest );
		m_cbRequest = 0;
		m_pRequest = NULL;
		}
	
	// empty the strings too
	m_szFriendlyName[0] = 0;
	m_szMetaName[0] = 0;
	}


//----------------------------------------------------------------------
// DeleteAllLSAKeys deletes ALL remenents of the LSA keys in the Metabase.
// (not including, of course anything written out there in the future as part
// of some backup scheme when uninstalling). Call this only AFTER ALL the keys
// have been converted to the metabase. They will no longer be there after
// this routine is used.
// NOTE: this also blows away any really-old KeySet keys because they look
// like the KeyMan keys. And we have to kill both the keyset keys and the
// generic storage used by the server.
DWORD CLSAKeys::DeleteAllLSAKeys()
	{
	DWORD	err;

	// first, delete the KeyManager type keys.
	err = DeleteKMKeys();
	if ( err != KEYLSA_SUCCESS )
		return err;

	// second, delete the keyset style keys. - this also removes the ones
	// that the server uses and any keyset keys.
	return DeleteServerKeys();
	}

//----------------------------------------------------------------------
DWORD CLSAKeys::DeleteKMKeys()
	{
	PCHAR				pName = (PCHAR)GlobalAlloc( GPTR, MAX_PATH+1 );
	PWCHAR				pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
	PLSA_UNICODE_STRING	pLSAData;
	DWORD				err;

	if ( !pName || !pWName )
		return ERROR_NOT_ENOUGH_MEMORY;

	// reset the index so we get the first key
	m_iKey = 0;

	// loop through the keys, deleting each in turn
	while( TRUE )
		{
		// increment the index
		m_iKey++;

		// build the key secret name
		sprintf( pName, "%s%d", KEY_NAME_BASE, m_iKey );
		// unicodize the name
		MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pName, -1, pWName, MAX_PATH+1 );

		// get the secret
		pLSAData = FRetrieveLSASecret( m_hPolicy, pWName, &err );
		// if we don't get the secret, exit
		if ( !pLSAData )
			{
			break;
			}

		// The secret is there. Clean up first
		DisposeLSAData( pLSAData );

		// now delete the secret
		FStoreLSASecret( m_hPolicy, pWName, NULL, 0, &err );
		};

	return KEYLSA_SUCCESS;
	}

//----------------------------------------------------------------------
DWORD CLSAKeys::DeleteServerKeys()
	{
	DWORD				err;
	PLSA_UNICODE_STRING	pLSAData;

	// get the secret list of keys
	pLSAData = FRetrieveLSASecret( m_hPolicy, KEYSET_LIST, &err );

	// if we get lucky, there won't be any keys to get rid of
	if ( !pLSAData )
		return KEYLSA_SUCCESS;

	// allocate the name buffer
	PWCHAR	pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
	ASSERT( pWName );
	if ( !pWName )
		{
		return 0xFFFFFFFF;
		}

	// No such luck. Now we have to walk the list and delete all those secrets
	WCHAR*	pszAddress = (WCHAR*)(pLSAData->Buffer);
	WCHAR*	pchKeys;

	// loop the items in the list, deleting the associated items
	while( ( pchKeys = wcschr(pszAddress, L',') ) != NULL )
		{
		// ignore empty segments
		if ( *pszAddress != L',' )
			{
			*pchKeys = L'\0';

			// Nuke the secrets, one at a time
			swprintf( pWName, KEYSET_PUB_KEY, pszAddress );
			FStoreLSASecret( m_hPolicy, pWName, NULL, 0, &err );

			swprintf( pWName, KEYSET_PRIV_KEY, pszAddress );
			FStoreLSASecret( m_hPolicy, pWName, NULL, 0, &err );

			swprintf( pWName, KEYSET_PASSWORD, pszAddress );
			FStoreLSASecret( m_hPolicy, pWName, NULL, 0, &err );
			}

		// increment the pointers
		pchKeys++;
		pszAddress = pchKeys;
		}

	// delete the list key itself
	FStoreLSASecret( m_hPolicy, KEYSET_LIST, NULL, 0, &err );

	// free the buffer for the names
	GlobalFree( (HANDLE)pWName );

	// free the info we originally retrieved from the secret
	if ( pLSAData )
		DisposeLSAData( pLSAData );

	// return success
	return KEYLSA_SUCCESS;
	}


//----------------------------------------------------------------------
// loading the keys
// LoadFirstKey loads the first key on the specified target machine. Until
// this method is called, the data values in the object are meaningless
// this method works by preparing the list of keys to load. Then it calls
// LoadNextKey to start the process
// Unfortunately, the whole process of saving keys in the LSA registry was a bit
// of a mess because they all had to be on the same level.
DWORD CLSAKeys::LoadFirstKey( PWCHAR pszwTargetMachine )
	{
	DWORD	err;

	// open the policy on the target machine being administered
	m_hPolicy = HOpenLSAPolicy( pszwTargetMachine, &err );
	if ( !m_hPolicy ) return KEYLSA_UNABLE_TO_OPEN_POLICY;

	// tell it to load the first key. The first key's index is actually 1, 
	// but LoadNextKey impliess that it is ++LoadNextKey, so start it at 0
	m_iKey = 0;

	// load that first key and return the response
	return LoadNextKey();
	}


//----------------------------------------------------------------------
// LoadNextKey loads the next key on the target machine specified in LoadFirstKey
// LoadNextKey automatically cleans up the memory used by the previous key.
DWORD CLSAKeys::LoadNextKey()
	{
	// the very first thing we do is - get rid of any previously loaded key
	UnloadKey();

	PCHAR				pName = (PCHAR)GlobalAlloc( GPTR, MAX_PATH+1 );
	PWCHAR				pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
	PLSA_UNICODE_STRING	pLSAData = NULL;
	DWORD				err = 0xFFFFFFFF;

	PUCHAR				pSrc;
	WORD				cbSrc;
	DWORD				dword, version, i;
	DWORD				cbChar;
	PUCHAR				p;

	CHAR				szIPAddress[256];
	BOOL				fDefault;

	if ( !pName || !pWName )
		return err;

	// increment the index so we get the next key
	m_iKey++;

	// build the key secret name
	sprintf( pName, "%s%d", KEY_NAME_BASE, m_iKey );
	// unicodize the name
	MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pName, -1, pWName, MAX_PATH+1 );

	// get the secret
	pLSAData = FRetrieveLSASecret( m_hPolicy, pWName, &err );
	// if we don't get the secret, exit with the error
	if ( !pLSAData )
		{
		err = KEYLSA_NO_MORE_KEYS;
		goto cleanup;
		}


	// we have the data from the secret. Now we parse it out into the components we desire
	// this probably could have been done cleaner the first time - but now it doesn't matter
	// anyway because the MetaBase takes care of storing all the individual pieces of info
	// anyway. It should also be way faster too.
	// This part of the routine is pretty much lifted out of CW3Key::InitializeFromPointer
	// from the w3key.dll. The appropriate sections have been either commented out or changed.

	pSrc = (PUCHAR)pLSAData->Buffer;
	cbSrc = pLSAData->Length;
	cbChar = sizeof(TCHAR);
	p = pSrc;

//========================== start from CW3Key::InitializeFromPointer

	ASSERT(pSrc && cbSrc);

	// get the version of the data - just put it into dword for now
	version = *((UNALIGNED DWORD*)p);
	// check the version for validity
//	if ( version > KEY_VERSION )
//		{
//		return FALSE;
//		}
	p += sizeof(DWORD);

	// anything below version 0x101 is BAD. Do not accept it
	if ( version < 0x101 )
		{
		err = KEYLSA_INVALID_VERSION;
		goto cleanup;
		}
	
	// get the bits and the complete flag
	// no longer used
	p += sizeof(DWORD);
	p += sizeof(BOOL);
	ASSERT( p < (pSrc + cbSrc) );

	// get the reserved dword - (acutally, just skip over it)
	p += sizeof(DWORD);

	// now the strings......
	// for each string, first get the size of the string, then the data from the string

	// get the reserved string - (actually, just skip over it)
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	p += dword;

	// get the name
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	strcpy( m_szFriendlyName, (PCHAR)p );
	p += dword;
	ASSERT( p < (pSrc + cbSrc) );

	// get the password
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	// if there is no password, don't worry, just skip it
	if ( dword )
		{
		// make a new pointer for it
		m_cbPassword = dword;
		m_pPassword = (PVOID)GlobalAlloc( GPTR, m_cbPassword );
		if ( !m_pPassword )
			{
			err = 0xFFFFFFFF;
			goto cleanup;
			}
		// put in the private key
		CopyMemory( m_pPassword, p, m_cbPassword );

		p += dword;
		ASSERT( p < (pSrc + cbSrc) );
		}

	// get the organization
	// no longer used - skip the DN info
	for ( i = 0; i < 6; i++ )
		{
		dword = *((UNALIGNED DWORD*)p);
		p += sizeof(DWORD);
		p += dword;
		ASSERT( p < (pSrc + cbSrc) );
		}

	// get the ip addres it is attached to
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
//	szIPAddress = p;
	strcpy( szIPAddress, (PCHAR)p );
	p += dword;
	ASSERT( p < (pSrc + cbSrc) );

	// get the default flag
	fDefault = *((UNALIGNED BOOL*)p);
	p += sizeof(BOOL);

	// now put get the number of bytes in the private key
	m_cbPrivate = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	ASSERT( p < (pSrc + cbSrc) );

	// make a new pointer for it
	m_pPrivate = (PVOID)GlobalAlloc( GPTR, m_cbPrivate );
	if ( !m_pPrivate )
		{
		err = 0xFFFFFFFF;
		goto cleanup;
		}

	// put in the private key
	CopyMemory( m_pPrivate, p, m_cbPrivate );
	p += m_cbPrivate;
	ASSERT( p < (pSrc + cbSrc) );


	// now put get the number of bytes in the certificate
	m_cbPublic = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	ASSERT( p < (pSrc + cbSrc) );

	// only make a certificate pointer if m_cbCertificate is greater than zero
	m_pPublic = NULL;
	if ( m_cbPublic )
		{
		m_pPublic = (PVOID)GlobalAlloc( GPTR, m_cbPublic );
		if ( !m_pPublic )
			{
			err = 0xFFFFFFFF;
			goto cleanup;
			}

		// put in the private key
		CopyMemory( m_pPublic, p, m_cbPublic );
		p += m_cbPublic;
		if ( version >= KEY_VERSION ) {
			ASSERT( p < (pSrc + cbSrc) );
        } else {
			ASSERT( p == (pSrc + cbSrc) );
        }
		}

	// added near the end
	if ( version >= KEY_VERSION )
		{
		// now put get the number of bytes in the certificte request
		m_cbRequest = *((UNALIGNED DWORD*)p);
		p += sizeof(DWORD);
		ASSERT( p < (pSrc + cbSrc) );

		// only make a certificate pointer if m_cbCertificate is greater than zero
		m_pRequest = NULL;
		if ( m_cbRequest )
			{
			m_pRequest = (PVOID)GlobalAlloc( GPTR, m_cbRequest );
			if ( !m_pRequest )
				{
				err = 0xFFFFFFFF;
				goto cleanup;
				}

			// put in the private key
			CopyMemory( m_pRequest, p, m_cbRequest );
			p += m_cbRequest;
			ASSERT( p < (pSrc + cbSrc) );
			}
		}
	else
		{
		m_cbRequest = 0;
		m_pRequest = NULL;
		}
//========================== end from CW3Key::InitializeFromPointer

	// now we figure out the appropriate metabase name for this key
	// this isn't too bad. If the targets a specific address, then the title
	// is the in the form of {IP}:{PORT}. Since there were no ports in the old
	// version, we will assume an appropriate default number. If it is the
	// default key, then the name is "default". If it is a disabled key, then
	// the name is "disabled". If it is an incomplete key, then the name is
	// "incomplete". Of course, it takes a little logic to tell the difference
	// between some of these.

	// first, see if it is an incomplete key. - test for the public portion
	if ( !m_pPublic )
		{
		// there may be multiple incomplete keys, so make sure they have unique names
//		m_szMetaName.Format( _T("%s%d"), MDNAME_INCOMPLETE, m_iKey );
		sprintf( m_szMetaName, "%s%d", MDNAME_INCOMPLETE, m_iKey );
		}
	// now test if it is the default key
	else if ( fDefault )
		{
//		m_szMetaName = MDNAME_DEFAULT;
		strcpy( m_szMetaName, MDNAME_DEFAULT );
		}
	// test for a disabled key
	else if ( szIPAddress[0] == 0 )
		{
		// there may be multiple disabled keys, so make sure they have unique names
//		m_szMetaName.Format( _T("%s%d"), MDNAME_DISABLED, m_iKey );
		sprintf( m_szMetaName, "%s%d", MDNAME_DISABLED, m_iKey );
		}
	else
		{
		// it is a regular old IP targeted key
//		m_szMetaName = szIPAddress;
		// add on the default port specification
//		m_szMetaName += MDNAME_PORT;
//		sprintf( m_szMetaName, "%s%s", szIPAddress, MDNAME_PORT );
        strcpy(m_szMetaName, szIPAddress);
		}

	// free the buffers
cleanup:
	GlobalFree( (HANDLE)pName );
	GlobalFree( (HANDLE)pWName );
	if ( pLSAData )
		DisposeLSAData( pLSAData );

	return err;
	}


//============================================= LSA Utility routines

//-------------------------------------------------------------
// pass in a NULL pszwServer name to open the local machine
HANDLE	CLSAKeys::HOpenLSAPolicy( WCHAR *pszwServer, DWORD *pErr )
	{
	NTSTATUS				ntStatus;
	LSA_OBJECT_ATTRIBUTES	objectAttributs;
	LSA_HANDLE				hPolicy;
	LSA_UNICODE_STRING		unicodeServer;

  if ( ( wcslen(pszwServer) * sizeof(WCHAR) ) >= MAXUSHORT )
  {
    return NULL;
  }

	// prepare the object attributes
	InitializeObjectAttributes( &objectAttributs, NULL, 0L, NULL, NULL );

	// prepare the lsa_unicode name of the server
	if ( pszwServer )
		{
		unicodeServer.Buffer = pszwServer;
		unicodeServer.Length = (USHORT) ( wcslen(pszwServer) * sizeof(WCHAR) );
		unicodeServer.MaximumLength = unicodeServer.Length + sizeof(WCHAR);
		}


	// attempt to open the policy
	ntStatus = LsaOpenPolicy( pszwServer ? &unicodeServer : NULL,
						&objectAttributs, POLICY_ALL_ACCESS, &hPolicy );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return NULL;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return hPolicy;
	}


//-------------------------------------------------------------
BOOL	CLSAKeys::FCloseLSAPolicy( HANDLE hPolicy, DWORD *pErr )
	{
	NTSTATUS				ntStatus;

	// close the policy
	ntStatus = LsaClose( hPolicy );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return FALSE;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return TRUE;
}

//-------------------------------------------------------------
// passing NULL in for pvData deletes the secret
BOOL	CLSAKeys::FStoreLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, void* pvData, WORD cbData, DWORD *pErr )
	{
	LSA_UNICODE_STRING		unicodeSecretName;
	LSA_UNICODE_STRING		unicodeData;
	NTSTATUS				ntStatus;
	
	// make sure we have a policy and a secret name
	if ( !hPolicy || 
       !pszwSecretName || 
       ( ( wcslen(pszwSecretName) * sizeof(WCHAR) ) >= MAXUSHORT )
     )
		{
		  *pErr = 1;
		  return FALSE;
		}

	// prepare the lsa_unicode name of the server
	unicodeSecretName.Buffer = pszwSecretName;
	unicodeSecretName.Length = (USHORT) wcslen(pszwSecretName) * sizeof(WCHAR);
	unicodeSecretName.MaximumLength = unicodeSecretName.Length + sizeof(WCHAR);

	// prepare the unicode data record
	if ( pvData )
		{
		unicodeData.Buffer = (WCHAR*)pvData;
		unicodeData.Length = cbData;
		unicodeData.MaximumLength = cbData;
		}

	// it is now time to store the secret
	ntStatus = LsaStorePrivateData( hPolicy, &unicodeSecretName, pvData ? &unicodeData : NULL );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return FALSE;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return TRUE;
	}

//-------------------------------------------------------------
// passing NULL in for pvData deletes the secret
PLSA_UNICODE_STRING	CLSAKeys::FRetrieveLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, DWORD *pErr )
{
	LSA_UNICODE_STRING		unicodeSecretName;
	LSA_UNICODE_STRING*		pUnicodeData = NULL;
	NTSTATUS				ntStatus;
	
	// make sure we have a policy and a secret name
	if ( !hPolicy || 
       !pszwSecretName ||
       ( ( wcslen( pszwSecretName ) * sizeof(WCHAR) ) >= MAXUSHORT )
     )
		{
		  *pErr = 1;
		  return FALSE;
		}

	// prepare the lsa_unicode name of the server
	unicodeSecretName.Buffer = pszwSecretName;
	unicodeSecretName.Length = (USHORT) wcslen(pszwSecretName) * sizeof(WCHAR);
	unicodeSecretName.MaximumLength = unicodeSecretName.Length + sizeof(WCHAR);

	// it is now time to store the secret
	ntStatus = LsaRetrievePrivateData( hPolicy, &unicodeSecretName, &pUnicodeData );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return NULL;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return pUnicodeData;
	}

//-------------------------------------------------------------
void CLSAKeys::DisposeLSAData( PVOID pData )
	{
	PLSA_UNICODE_STRING pDataLSA = (PLSA_UNICODE_STRING)pData;
	if ( !pDataLSA || !pDataLSA->Buffer ) return;
	GlobalFree(pDataLSA);
	}

#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\lockdown.cxx ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        lockdown.cxx

   Abstract:

        Upgrade old IIS Lockdown Wizard Settings to whatever
        is appropriate in IIS6

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       May 2002: Created

--*/

#include "stdafx.h"
#include "acl.hxx"
#include "restrlst.hxx"
#include "lockdown.hxx"
#include "reg.hxx"

// IsWebDavDisabled
//
// This checks to see if WebDav was disabled on IIS 5.0.   The way
// this was done, was by removing acl's on the file, so the webserver
// could not load the file.
// This will not only check, but it will restore the ACL's so the file
// can be replaced on upgrade.
//
// Parameters:
//   pbWasDisabled - [out] Was the file disabled before or not
//
// Return
//   TRUE - Success checking
//   FALSE - Failed to check
BOOL 
IsWebDavDisabled( LPBOOL pbWasDisabled )
{
  CSecurityDescriptor SD;
  BOOL                bAreAclsSupported;
  TSTR_PATH           strHttpExtPath;
  ACCESS_MASK         AccessMask;

  if ( !strHttpExtPath.Copy( g_pTheApp->m_csPathInetsrv ) ||
       !strHttpExtPath.PathAppend( g_OurExtensions[EXTENSION_WEBDAV].szFileName ) )
  {
    // Failed to construct path
    return FALSE;
  }

  if ( !CSecurityDescriptor::DoesFileSystemSupportACLs( strHttpExtPath.QueryStr(),
                                                        &bAreAclsSupported ) )
  {
    // Failure
    return FALSE;
  }
  else
  {
    if ( !bAreAclsSupported )
    {
      // Since ACL's are not supported, lets just exit
      *pbWasDisabled = FALSE;
      return TRUE;
    }
  }

  if ( !SD.GetSecurityInfoOnFile( strHttpExtPath.QueryStr() ) ||
       !SD.QueryEffectiveRightsForTrustee( CSecurityDescriptor::GROUP_USERS,
                                           &AccessMask ) )
  {
    // Failed to query access
    // It is possible that the file is not even on the system
    // so just return that it is not disables
    *pbWasDisabled = FALSE;
    return TRUE;
  }

  // Was file disabled to be loaded?
  *pbWasDisabled = ( AccessMask & ACTRL_FILE_EXECUTE ) == 0;

  if ( *pbWasDisabled )
  {
    // Lets restore ACL, so we can upgrade it
    // Copy ACL's from that of inetsrv directory to dll, since it has been acl'd down
    if ( !SD.GetSecurityInfoOnFile( g_pTheApp->m_csPathInetsrv.GetBuffer(0) ) ||
         !SD.SetSecurityInfoOnFile( strHttpExtPath.QueryStr(), TRUE ) )
    {
      return FALSE;
    }
  }

  return TRUE;
}

// IsWebDavDisabledViaRegistry
//
// Is WebDav disabled in the registry?
//
// Parameters:
//   pbWasDisabled - [out] Was the file disabled before or not
//
// Return
//   TRUE - Success checking
//   FALSE - Failed to check
BOOL
IsWebDavDisabledViaRegistry( LPBOOL pbWasDisabled )
{
  CRegValue Value;
  CRegistry Registry;

  *pbWasDisabled = FALSE;

  if ( !Registry.OpenRegistry( HKEY_LOCAL_MACHINE,
                               REG_WWWPARAMETERS,
                               KEY_READ | KEY_WRITE ) )
  {
    // Failed to open WWW Node
    // We will consider this success, since the node might not exist.
    return TRUE;
  }

  if ( Registry.ReadValue( REGISTRY_WWW_DISABLEWEBDAV_NAME,
                           Value ) )
  {
    // Successfully read value
    *pbWasDisabled = *( (LPDWORD) Value.m_buffData.QueryPtr() ) != 0;
  }

  Registry.DeleteValue( REGISTRY_WWW_DISABLEWEBDAV_NAME );

  return TRUE;
}

// DisableWebDavInRestrictionList
//
// Lockdown access the the HttpExtension Dll.  That this meands is that
// we free up the ACL on the file, and deny it through the 
// WebSvcRestrictionList
//
BOOL 
DisableWebDavInRestrictionList()
{
  CRestrictionList    RestrictionList;
  CSecurityDescriptor SD;
  TSTR                strDescription;
  TSTR_PATH           strHttpExtPath;

  if ( !strHttpExtPath.Copy( g_pTheApp->m_csPathInetsrv ) ||
       !strHttpExtPath.PathAppend( g_OurExtensions[EXTENSION_WEBDAV].szFileName ) )
  {
    // Failed to construct path
    return FALSE;
  }

  // Update Metabas
  if ( !strDescription.LoadString( g_OurExtensions[EXTENSION_WEBDAV].dwProductName ) ||
       !RestrictionList.InitMetabase() ||
       !RestrictionList.LoadCurrentSettings() ||
       !RestrictionList.UpdateItem( strHttpExtPath.QueryStr(),
                                    g_OurExtensions[EXTENSION_WEBDAV].szNotLocalizedGroupName,
                                    strDescription.QueryStr(),
                                    FALSE,                        // DENY
                                    g_OurExtensions[EXTENSION_WEBDAV].bUIDeletable ) ||
       !RestrictionList.SaveSettings() )
  {
    // Failed to update metabase
    return FALSE;
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\massupdt.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        massupdt.cpp

   Abstract:

        functions to udpate bunches of properties at once

   Author:

        Boyd Multerer (boydm)

   Project:

        IIS Setup

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include <iis64.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "strfn.h"
#include "mdkey.h"
#include "mdentry.h"
#include "massupdt.h"


//============================================================
// first the Abstract CMassPropertyUpdater class


//============================================================
//=================== CMassPropertyUpdater ===================
//============================================================

//------------------------------------------------------------
CMassPropertyUpdater::CMassPropertyUpdater(
        DWORD dwMDIdentifier,
        DWORD dwMDDataType ) :
    m_dwMDIdentifier( dwMDIdentifier ),
    m_dwMDDataType( dwMDDataType )
{
}

//------------------------------------------------------------
CMassPropertyUpdater::~CMassPropertyUpdater()
{
}

//------------------------------------------------------------
HRESULT CMassPropertyUpdater::Update(
        LPCTSTR strStartNode,
        BOOL fStopOnErrors          OPTIONAL )
{
    HRESULT         hRes;
    CString         szPath;
    POSITION        pos;
    LPWSTR          pwstr;

    // start by getting the list of nodes with script maps on them
    // first open the node that we will start searching on
    hRes = OpenNode( strStartNode );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMassPropertyUpdater::Update()-OpenNode failed. err=%x.\n"), hRes));
        return hRes;
    }

    // get the sub-paths that have the data on them
    hRes = GetDataPaths( m_dwMDIdentifier, m_dwMDDataType, m_pathList );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMassPropertyUpdater::Update()-GetDataPaths failed. err=%x.\n"), hRes));
        goto cleanup;
    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = m_pathList.GetHeadPosition();
    while ( NULL != pos )
    {
        // get the next path in question
        szPath = m_pathList.GetNext( pos );

        // make a special case of the "/" path
        if ( szPath == _T("/") )
            szPath.Empty();

        // drat. ANSI stuff is a mess so deal with it here
#ifdef UNICODE
        pwstr = (LPWSTR)(LPCTSTR)szPath;
#else
        pwstr = AllocWideString( szPath );
#endif

        // operate on it
        hRes = UpdateOne( pwstr );

#ifndef UNICODE
        FreeMem( pwstr );
#endif

        // if we are stopping of failures, then check
        if ( FAILED(hRes) )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMassPropertyUpdater::Update():FAILED: update path =%s.\n"), szPath));

        //if requested to stop the loop, then do so
        if ( fStopOnErrors )
            break;
        }
    }

    // cleanup - close the node once and for all
cleanup:
    Close();

    // return the answer
    return hRes;
}



//============================================================
//==================== CInvertScriptMaps =====================
//============================================================

//------------------------------------------------------------
HRESULT CInvertScriptMaps::UpdateOne( LPWSTR strPath )
{
    HRESULT         hRes;
    POSITION        pos;
    POSITION        posCurrent;
    CString         szMap;

    DWORD dwattributes = 0;

    CStringList cslScriptMaps;

    // get the full script map in question.
    hRes = GetMultiSzAsStringList (
        m_dwMDIdentifier,
        &m_dwMDDataType,
        &dwattributes,
        cslScriptMaps,
        strPath );

    
    //iisDebugOut((LOG_TYPE_ERROR, _T("CInvertScriptMaps::UpdateOne() GetMultiSzAsStringList. Attrib=0x%x.\n"), dwattributes));

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CInvertScriptMaps::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    // HACK. The first thing we need to do is make sure we haven't already inverted this script
    // map during a previous build-to-build upgrade. If we invert it twice, then we are back
    // to an exclusion list and that would not be desirable. The way to detect this is to see
    // if the GET verb is listed for the ASP script map or not. If it is there, then it has been
    // inverted. This will only be a problem when doing build-to-build upgrades in IIS5.
    pos = cslScriptMaps.GetHeadPosition();
    while ( NULL != pos )
    {
        // get the next path in question
        szMap = cslScriptMaps.GetNext( pos );

        // if it is the .asp scriptmap, then finish the test
        if ( szMap.Left(4) == _T(".asp") )
        {
            if ( szMap.Find(_T("GET")) >= 0 )
            {
                return ERROR_SUCCESS;
            }
            else
            {
                break;
            }
        }

    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = cslScriptMaps.GetHeadPosition();
    while ( NULL != pos )
    {
        // store the current position
        posCurrent = pos;

        // get the next path in question
        szMap = cslScriptMaps.GetNext( pos );

        // operate on it
        hRes = InvertOneScriptMap( szMap );

        // if that worked, put it back in place
        if ( SUCCEEDED(hRes) )
        {
            cslScriptMaps.SetAt ( posCurrent, szMap );
        }
    }

    //iisDebugOut((LOG_TYPE_ERROR, _T("CInvertScriptMaps::UpdateOne() SetMultiSzAsStringList. Attrib=0x%x.\n"), dwattributes));

    // Put it back.
    hRes = SetMultiSzAsStringList (
        m_dwMDIdentifier,
        m_dwMDDataType,
        dwattributes,
        cslScriptMaps,
        strPath );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CInvertScriptMaps::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    return hRes;
}


//------------------------------------------------------------
HRESULT CInvertScriptMaps::InvertOneScriptMap( CString& csMap )
{
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CInvertScriptMaps::InvertOneScriptMap():%s.start.\n"), csMap));
    // the script mapping is yet another list. This time seperated
    // by commas. The first 4 items are standard and don't get messed
    // with. The n last items are all verbs that need to be inverted.
    int             numParts;
    int             numVerbs;

    CStringList   cslMapParts;
    CStringList   cslVerbs;
    CString         szComma = _T(",");
    CString         szVerb;

    POSITION        posMap;
    POSITION        posVerb;

    // break the source map into a string list
    numParts = ConvertSepLineToStringList(
        csMap,
        cslMapParts,
        szComma
        );

    CString szAllVerbs;
    if (!GetScriptMapAllInclusionVerbs(szAllVerbs))
        {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetScriptMapAllInclusionVerbs():FAIL.WARNING.UseDefaults\n")));
        szAllVerbs = SZ_INVERT_ALL_VERBS;
        }
    

    // start by making a string list with all the verbs to invert against
    numVerbs = ConvertSepLineToStringList(
        SZ_INVERT_ALL_VERBS,
        cslVerbs,
        szComma
        );

    // start with the 3rd indexed item in the source list. This should be the
    // first verb in the old "exclusion" list. Then use it and scan
    // the new "Inclusion" list of verbs. If it is there, rememove it.
    posMap = cslMapParts.FindIndex( 3 );
    while ( NULL != posMap )
    {
        // set to the next verb in the map list
        szVerb = cslMapParts.GetNext( posMap );

        // make sure the verb is normalized to capitals and
        // no whitespace before or after
        szVerb.MakeUpper();
        szVerb.TrimLeft();
        szVerb.TrimRight();

        // try to find the verb in the invertion list
        posVerb = cslVerbs.Find( szVerb );

        // if we found it, remove it
        if ( NULL != posVerb )
        {
            cslVerbs.RemoveAt( posVerb );
        }
    }

    // strip all the verbs off the source list
    while ( cslMapParts.GetCount() > 3 )
    {
        cslMapParts.RemoveTail();
    }

    // combine the lists
    cslMapParts.AddTail( &cslVerbs );    

    // put it back into the comma list
    ConvertStringListToSepLine(
        cslMapParts,
        csMap,
        szComma
        );

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CInvertScriptMaps::InvertOneScriptMap():%s.End.\n"), csMap));
    return ERROR_SUCCESS;
}



//============================================================
//================= CIPSecPhysicalPathFixer ==================
//============================================================


//------------------------------------------------------------
CPhysicalPathFixer::CPhysicalPathFixer( CString& szOldSysPath, CString &szNewSysPath ):
        CMassPropertyUpdater(0, 0),     // bad values on purpose - see Update below...
        m_szOldSysPath( szOldSysPath ),
        m_szNewSysPath( szNewSysPath )
{
    m_szOldSysPath.MakeUpper();
}

//------------------------------------------------------------
HRESULT CPhysicalPathFixer::Update( LPCTSTR strStartNode, BOOL fStopOnErrors )
{
    HRESULT hRes;

    // vrpath -- should we do this too? yes.
    m_dwMDIdentifier = MD_VR_PATH;
    m_dwMDDataType = STRING_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    // inproc isapi apps.
    m_dwMDIdentifier = MD_IN_PROCESS_ISAPI_APPS;
    m_dwMDDataType = MULTISZ_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    // prepare and update the scriptmappings multi sz strings
    m_dwMDIdentifier = MD_SCRIPT_MAPS;
    m_dwMDDataType = MULTISZ_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    // prepare to update the FilterImagePath multi sz strings
    m_dwMDIdentifier = MD_FILTER_IMAGE_PATH;
    m_dwMDDataType = STRING_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    // prepare to update the FilterImagePath multi sz strings
    m_dwMDIdentifier = MD_LOGFILE_DIRECTORY;
    m_dwMDDataType = EXPANDSZ_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    return hRes;
}

//MD_FILTER_LOAD_ORDER
// in process isapi apps
// custom errors


//------------------------------------------------------------
HRESULT CPhysicalPathFixer2::Update( LPCTSTR strStartNode, BOOL fStopOnErrors )
{
    HRESULT hRes;
    // prepare and update the scriptmappings multi sz strings
    m_dwMDIdentifier = MD_CUSTOM_ERROR;
    m_dwMDDataType = MULTISZ_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    return hRes;
}


//------------------------------------------------------------
HRESULT CPhysicalPathFixer::UpdateOne( LPWSTR strPath )
{
    HRESULT hRes = 0xFFFFFFFF;

    if ( m_dwMDDataType == STRING_METADATA )
    {
        hRes = UpdateOneSTRING_DATA( strPath );
    }
    else if ( m_dwMDDataType == MULTISZ_METADATA )
    {
        hRes = UpdateOneMULTISZ_DATA( strPath );
    }
    else if ( m_dwMDDataType == EXPANDSZ_METADATA )
    {
        hRes = UpdateOneSTRING_DATA_EXPAND( strPath );
    }

    return hRes;
}

//------------------------------------------------------------
HRESULT CPhysicalPathFixer::UpdateOneMULTISZ_DATA( LPWSTR strPath )
{
    HRESULT         hRes;
    POSITION        pos;
    POSITION        posCurrent;
    CString         csPath;

    CStringList     cslPaths;
    BOOL            fSomethingChanged = FALSE;

    DWORD dwattributes = 0;

    // get the full script map in question.
    hRes = GetMultiSzAsStringList (
        m_dwMDIdentifier,
        &m_dwMDDataType,
        &dwattributes,
        cslPaths,
        strPath );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = cslPaths.GetHeadPosition();
    while ( NULL != pos )
    {
        // store the current position
        posCurrent = pos;

        // get the next path in question
        csPath = cslPaths.GetNext( pos );

        // operate on it
        hRes = UpdateOnePath( csPath );

        // if that worked, put it back in place
        if ( SUCCEEDED(hRes) )
        {
            cslPaths.SetAt ( posCurrent, csPath );
            fSomethingChanged = TRUE;
        }
        // if there was nothing to update..
        if (hRes == 0xFFFFFFFF)
            {hRes = ERROR_SUCCESS;}
    }

    // Put it back. - unless nothing changed
    if ( fSomethingChanged )
    {
        hRes = SetMultiSzAsStringList (
            m_dwMDIdentifier,
            m_dwMDDataType,
            dwattributes,
            cslPaths,
            strPath );
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
            return hRes;
        }
    }

    return hRes;
}


//------------------------------------------------------------
HRESULT CPhysicalPathFixer::UpdateOneSTRING_DATA_EXPAND( LPWSTR strPath )
{
    HRESULT         hRes;
    CString         csPath;
    BOOL            fSomethingChanged = FALSE;

    // get the full script map in question.
    hRes = GetStringAsCString (
        m_dwMDIdentifier,
        m_dwMDDataType,
        NULL,
        csPath,
        strPath,
        1);
    
    if ( MD_ERROR_DATA_NOT_FOUND == hRes)
    {
        hRes = ERROR_SUCCESS;
        return hRes;
    }

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("GetStringAsCString:Read.%S\n"), csPath));

    // operate on it
    hRes = UpdateOnePath( csPath );

    // if that worked, put it back in place
    if ( SUCCEEDED(hRes) )
    {
        fSomethingChanged = TRUE;
    }

    // if there was nothing to update..
    if (hRes == 0xFFFFFFFF)
        {hRes = ERROR_SUCCESS;}

    // Put it back. - unless nothing changed
    if ( fSomethingChanged )
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("GetStringAsCString:write.%S\n"), csPath));
        hRes = SetCStringAsString (
            m_dwMDIdentifier,
            m_dwMDDataType,
            NULL,
            csPath,
            strPath,
            1);
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
            return hRes;
        }
    }

    return hRes;
}

//------------------------------------------------------------
HRESULT CPhysicalPathFixer::UpdateOneSTRING_DATA( LPWSTR strPath )
{
    HRESULT         hRes;
    CString         csPath;
    BOOL            fSomethingChanged = FALSE;

    // get the full script map in question.
    hRes = GetStringAsCString (
        m_dwMDIdentifier,
        m_dwMDDataType,
        NULL,
        csPath,
        strPath,
        0);

    if ( MD_ERROR_DATA_NOT_FOUND == hRes)
    {
        hRes = ERROR_SUCCESS;
        return hRes;
    }

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }


    // operate on it
    hRes = UpdateOnePath( csPath );

    // if that worked, put it back in place
    if ( SUCCEEDED(hRes) )
    {
        fSomethingChanged = TRUE;
    }

    // if there was nothing to update..
    if (hRes == 0xFFFFFFFF)
        {hRes = ERROR_SUCCESS;}

    // Put it back. - unless nothing changed
    if ( fSomethingChanged )
    {
        hRes = SetCStringAsString (
            m_dwMDIdentifier,
            m_dwMDDataType,
            NULL,
            csPath,
            strPath,
            0);
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
            return hRes;
        }
    }

    return hRes;
}

//------------------------------------------------------------
// note: returns 0xFFFFFFFF if nothing changed
HRESULT CPhysicalPathFixer::UpdateOnePath( CString& csPath )
{
    // buffer the incoming string and make it upper case for the find
    CString csUpper = csPath;
    csUpper.MakeUpper();


    // first, find the old syspath in the csPath
    int iOldPath = csUpper.Find( m_szOldSysPath );

    // if it wasn't there, then return with 0xFFFFFFFF
    if ( iOldPath == -1 )
    {
        return 0xFFFFFFFF;
    }

    // the plan is the build a new string from the old one.
    CString csNewPath;

    // start by copying everything to the left of the substring
    csNewPath = csPath.Left( iOldPath );

    // now add to it the new path
    csNewPath += m_szNewSysPath;

    // now add to that the rest of the string
    csNewPath += csPath.Right( csPath.GetLength() - (iOldPath + m_szOldSysPath.GetLength()) );

    // finally, put the new string into place
    csPath = csNewPath;

    return 0;
}



//============================================================
//==================== CIPSecRefBitAdder =====================
//============================================================

//------------------------------------------------------------
//MD_IP_SEC, BINARY_METADATA
// Unfortunately, at this time there is no way to directly manipulate the
// attribuites on a property in the metabase without reading in
// the actual property data. This could be made much simpler if a IADM level
// method to do this is added to the metabase interface at some point in the
// future.
HRESULT CIPSecRefBitAdder::UpdateOne( LPWSTR strPath )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;


    // get the ipsec data. The loop accounts for a buffer that is too small...
    DWORD  dwMDBufferSize = 1024;
    PWCHAR pwchBuffer = NULL;
    do
    {
        if ( pwchBuffer )
        {
            delete pwchBuffer;
            pwchBuffer = NULL;
        }

        pwchBuffer = new WCHAR[dwMDBufferSize];
        if (pwchBuffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // prepare the metadata parameter block
        MD_SET_DATA_RECORD(&mdrData, MD_IP_SEC, 0,
                IIS_MD_UT_FILE, BINARY_METADATA, dwMDBufferSize, pwchBuffer);

        // make the call to get the data
        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetData(
            m_hKey,
            strPath,
            &mdrData,
            &dwMDBufferSize
            );
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point we can check to see if the reference bit is part of the attributes.
        // if it is, then we can just clean up. If it isn't, we should add it and write it
        // back out.
        if ( (mdrData.dwMDAttributes & METADATA_REFERENCE) == 0 )
        {
            // the attributes flag is not set. Set it.
            mdrData.dwMDAttributes |= METADATA_REFERENCE;

            // write it back out to the metabase
            hRes = m_pcCom->SetData(
                m_hKey,
                strPath,
                &mdrData
                );
        }
    }

    // clean up
    if ( pwchBuffer )
        delete pwchBuffer;

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecRefBitAdder::UpdateOne() failed. err=%x.\n"), hRes));
    }

    return hRes;
}



//============================================================
//==================== CFixCustomErrors ======================
//============================================================

HRESULT CustomErrorProcessOneLine(CString& csInputOneBlobEntry)
{
    HRESULT hReturn = E_FAIL;
    CStringList cslBlobEntryParts;
    CString csComma = _T(",");

    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szPath_only2[_MAX_PATH];
    TCHAR szFilename_only[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    CString csFilePath;
    CString csFilePathNew;
    CString csFilePath2;

    CString csEntry;
    CString csEntry0;
    CString csEntry1;
    CString csEntry2;
    CString csEntry3;

    TCHAR szNewFileName[_MAX_PATH];

    POSITION pos;
    
    //"500,15,FILE,D:\WINNT\help\iisHelp\common\500-15.htm" 
    //"500,100,URL,/iisHelp/common/500-100.asp"

    // break the source map into a string list
    ConvertSepLineToStringList(csInputOneBlobEntry,cslBlobEntryParts,csComma);

    // we now have the cstringlist. Loop through the list
    // which should look like this:
    // 0:500
    // 1:15
    // 2:FILE
    // 3:D:\WINNT\help\iisHelp\common\500-15.htm
    pos = cslBlobEntryParts.GetHeadPosition();
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}

    // 0:500
    csEntry = cslBlobEntryParts.GetAt(pos);
    csEntry0 = csEntry;
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}

    // 1:15
    cslBlobEntryParts.GetNext(pos);
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}
    csEntry = cslBlobEntryParts.GetAt(pos);
    csEntry1 = csEntry;
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}
    
    // 2:FILE
    // Check to make sure this is the "file" type 
    // that we will act upon.  if it's not then get out
    cslBlobEntryParts.GetNext(pos);
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}
    csEntry = cslBlobEntryParts.GetAt(pos);
    if ( csEntry.Left(4) != _T("FILE") )
        {goto CustomErrorProcessOneLine_Exit;}
    csEntry2 = csEntry;

    // 3:D:\WINNT\help\iisHelp\common\500-15.htm
    cslBlobEntryParts.GetNext(pos);
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}
    csEntry = cslBlobEntryParts.GetAt(pos);
    csEntry3 = csEntry;

    // KOOL, this is one we need to process.
    // D:\WINNT\help\iisHelp\common\500-15.htm

    // Get the filename
    // Trim off the filename and return only the path
    _tsplitpath(csEntry, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

    // Check if the path points to the old place...
    csFilePath.Format(_T("%s\\help\\common\\fakefile"), g_pTheApp->m_csWinDir);
    _tsplitpath( csFilePath, NULL, szPath_only2, NULL, NULL);
    if (_tcsicmp(szPath_only, szPath_only2) != 0)
    {
        // nope this one does not point to the old place so we can get out
        goto CustomErrorProcessOneLine_Exit;
    }

    // yes, it points to the old place.
    // let's see if it exists in the new place first...
    csFilePathNew.Format(_T("%s\\help\\iishelp\\common"), g_pTheApp->m_csWinDir);
    csFilePath.Format(_T("%s\\%s%s"), csFilePathNew, szFilename_only, szFilename_ext_only);
    if (IsFileExist(csFilePath)) 
    {
        // yes, it does, then let's replace it.
        csInputOneBlobEntry.Format(_T("%s,%s,%s,%s\\%s%s"), csEntry0, csEntry1, csEntry2, csFilePathNew, szFilename_only, szFilename_ext_only);
        // return
        hReturn = ERROR_SUCCESS;
        goto CustomErrorProcessOneLine_Exit;
    }

    // no it does not exist...
    // see if there is a *.bak file with that name...
    csFilePath2 = csFilePath;
    csFilePath2 += _T(".bak");
    if (IsFileExist(csFilePath2)) 
    {
        // yes, it does, then let's replace it.
        csInputOneBlobEntry.Format(_T("%s,%s,%s,%s\\%s%s.bak"), csEntry0, csEntry1, csEntry2, csFilePathNew, szFilename_only, szFilename_ext_only);
        // return
        hReturn = ERROR_SUCCESS;
        goto CustomErrorProcessOneLine_Exit;
    }

    // They must be pointing to some other file which we don't have.
    // let's try to copy the old file from the old directory...

    // rename file to *.bak and move it to the new location..
    _stprintf(szNewFileName, _T("%s\\%s%s"), csFilePathNew, szFilename_only, szFilename_ext_only);
    // move it
    if (IsFileExist(csEntry3))
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("CustomErrorProcessOneLine: MoveFileEx:%s,%s.\n"),csEntry3, szNewFileName));
        if (MoveFileEx(csEntry3, szNewFileName, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING))
        {
            // yes, it does, then let's replace it.
            csInputOneBlobEntry.Format(_T("%s,%s,%s,%s"), csEntry0, csEntry1, csEntry2, szNewFileName);
            hReturn = ERROR_SUCCESS;
        }
        // we were not able to move it so don't make it poiint to the new place.
    }
    else
    {
        // Check if the file was renamed...
        // rename file to *.bak and move it to the new location..
        _stprintf(szNewFileName, _T("%s\\%s%s.bak"), csFilePathNew, szFilename_only, szFilename_ext_only);
        // yes, it does, then let's replace it.
        if (IsFileExist(szNewFileName))
        {
            csInputOneBlobEntry.Format(_T("%s,%s,%s,%s"), csEntry0, csEntry1, csEntry2, szNewFileName);
            hReturn = ERROR_SUCCESS;
        }
        else
        {
            // they must be pointing to some other file which we don't install.
            // so don't change this entry...
        }
    }

CustomErrorProcessOneLine_Exit:
    if (hReturn == ERROR_SUCCESS)
        {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CustomErrorProcessOneLine:End.value=%s.\n"),csInputOneBlobEntry));
        }
    return hReturn;
}


//------------------------------------------------------------
HRESULT CFixCustomErrors::UpdateOne( LPWSTR strPath )
{
    HRESULT hRes = ERROR_SUCCESS;
    POSITION        pos;
    POSITION        posCurrent;
    CString         szMap;

    DWORD dwattributes = 0;

    CStringList cslScriptMaps;

    //iisDebugOut((LOG_TYPE_TRACE, _T("CFixCustomErrors::UpdateOne() %s.\n"), strPath));

    CString csTheNode;
    csTheNode = _T("LM/W3SVC");
    csTheNode += strPath;

    // get the full script map in question.
    hRes = GetMultiSzAsStringList (
        m_dwMDIdentifier,
        &m_dwMDDataType,
        &dwattributes,
        cslScriptMaps,
        strPath );
    
    //iisDebugOut((LOG_TYPE_TRACE, _T("CFixCustomErrors::UpdateOne() GetMultiSzAsStringList. Attrib=0x%x.\n"), dwattributes));

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CFixCustomErrors::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = cslScriptMaps.GetHeadPosition();
    while ( NULL != pos )
    {
        // store the current position
        posCurrent = pos;

        // get the next path in question
        szMap = cslScriptMaps.GetNext( pos );

        // print it out to the screen for debug purposes
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CFixCustomErrors::UpdateOne().Data=%s.\n"), szMap));

        // operate on it
        hRes = CustomErrorProcessOneLine( szMap );

        // if that worked, put it back in place
        if ( SUCCEEDED(hRes) ){cslScriptMaps.SetAt ( posCurrent, szMap );}
    }

    //iisDebugOut((LOG_TYPE_ERROR, _T("CFixCustomErrors::UpdateOne() SetMultiSzAsStringList. Attrib=0x%x.\n"), dwattributes));

    // Put it back.
    hRes = SetMultiSzAsStringList (
        m_dwMDIdentifier,
        m_dwMDDataType,
        dwattributes,
        cslScriptMaps,
        strPath );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CFixCustomErrors::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    return hRes;
}






HRESULT CEnforceMaxConnection::UpdateOne( LPWSTR strPath )
{
    HRESULT hRes = 0xFFFFFFFF;
    iisDebugOut((LOG_TYPE_ERROR, _T("CEnforceMaxConnection::UpdateOne(%s).start\n"), strPath));

    DWORD theDword;
    BOOL  fSomethingChanged = FALSE;

    if ( m_dwMDDataType == DWORD_METADATA )
    {
        // Get the value into a dword
        // get the full script map in question.
        hRes = GetDword(m_dwMDIdentifier,m_dwMDDataType,NULL,theDword,strPath);
        if ( MD_ERROR_DATA_NOT_FOUND == hRes)
        {
            hRes = ERROR_SUCCESS;
            return hRes;
        }

        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CEnforceMaxConnection::UpdateOne()-GetDword failed. err=%x.\n"), hRes));
            return hRes;
        }

        if (theDword > 10)
        {
            theDword = 10;
            fSomethingChanged = TRUE;
        }
        else
        {
            hRes = ERROR_SUCCESS;
        }
                  

        // Put it back. - unless nothing changed
        if ( fSomethingChanged )
        {
            //hRes = SetDword(m_dwMDIdentifier,m_dwMDDataType,NULL,theDword,strPath);
            if ( FAILED(hRes) )
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CEnforceMaxConnection::UpdateOne()-GetDword failed. err=%x.\n"), hRes));
                return hRes;
            }
        }
    }
    else
    {
        hRes = ERROR_SUCCESS;
    }

    iisDebugOut((LOG_TYPE_ERROR, _T("CEnforceMaxConnection::UpdateOne(%s).End.ret=0x%x\n"), strPath,hRes));
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\massupdt.h ===
#ifndef _MASSUPDT_H_
#define _MASSUPDT_H_


//---------------------------------------------------------------
// Abstract class for mass property updates
class CMassPropertyUpdater : public CMDKey
{
public:
    CMassPropertyUpdater(DWORD dwMDIdentifier, DWORD dwMDDataType );
    ~CMassPropertyUpdater();

    // pass in the starting node
    virtual HRESULT Update( LPCTSTR strStartNode, BOOL fStopOnErrors = FALSE );

protected:
    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath ) = 0;

    DWORD       m_dwMDIdentifier;
    DWORD       m_dwMDDataType;

    CStringList m_pathList;
};


//---------------------------------------------------------------
class CInvertScriptMaps : public CMassPropertyUpdater
{
public:
    CInvertScriptMaps():
        CMassPropertyUpdater(MD_SCRIPT_MAPS, MULTISZ_METADATA) {;}
    ~CInvertScriptMaps() {;}

protected:
    #define SZ_INVERT_ALL_VERBS  _T("OPTIONS,GET,HEAD,POST,PUT,DELETE,TRACE")

    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
    HRESULT InvertOneScriptMap( CString& csMap );
};


//---------------------------------------------------------------
class CIPSecRefBitAdder : public CMassPropertyUpdater
{
public:
    CIPSecRefBitAdder():
        CMassPropertyUpdater(MD_IP_SEC, BINARY_METADATA) {;}
    ~CIPSecRefBitAdder() {;}

protected:
    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
};


//---------------------------------------------------------------
// use this one for c:\windows\system type paths
class CPhysicalPathFixer : public CMassPropertyUpdater
{
public:
    CPhysicalPathFixer( CString& szOldSysPath, CString &szNewSysPath );
    ~CPhysicalPathFixer() {;}

    void SetPaths( CString& szOldSysPath, CString &szNewSysPath )
    { m_szOldSysPath = szOldSysPath; m_szNewSysPath = szNewSysPath; }

    // pass in the starting node
    virtual HRESULT Update( LPCTSTR strStartNode, BOOL fStopOnErrors = FALSE );

protected:
    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
    HRESULT UpdateOneMULTISZ_DATA( LPWSTR strPath );
    HRESULT UpdateOneSTRING_DATA( LPWSTR strPath );
    HRESULT UpdateOneSTRING_DATA_EXPAND( LPWSTR strPath );

    HRESULT UpdateOnePath( CString& csPath );

    // instance variables
    CString     m_szOldSysPath;
    CString     m_szNewSysPath;
};

//---------------------------------------------------------------
// use this one for c:\windows type paths
class CPhysicalPathFixer2 : public CPhysicalPathFixer
{
public:
    CPhysicalPathFixer2( CString& szOldSysPath, CString &szNewSysPath ):
      CPhysicalPathFixer( szOldSysPath , szNewSysPath )
      {;}
    ~CPhysicalPathFixer2() {;}

    // pass in the starting node
    virtual HRESULT Update( LPCTSTR strStartNode, BOOL fStopOnErrors = FALSE );
};



//---------------------------------------------------------------
class CFixCustomErrors : public CMassPropertyUpdater
{
public:
    CFixCustomErrors():
        CMassPropertyUpdater(MD_CUSTOM_ERROR, MULTISZ_METADATA) {;}
    ~CFixCustomErrors() {;}

protected:

    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
};



//---------------------------------------------------------------
class CEnforceMaxConnection : public CMassPropertyUpdater
{
public:
    CEnforceMaxConnection():
        CMassPropertyUpdater(MD_MAX_CONNECTIONS, DWORD_METADATA) {;}
    ~CEnforceMaxConnection() {;}

protected:

    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
};




#endif //_MASSUPDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\mdacl.h ===
#include "stdafx.h"

DWORD AddUserToMetabaseACL(CString csKeyPath, LPTSTR szUserToAdd, DWORD dwAccessMask = 0x00 );
DWORD AddUserToMetabaseACL_Rec(CString csKeyPath, LPTSTR szUserToAdd, DWORD dwAccessMask = 0x00 );
BOOL  IsLocalAccount(LPCTSTR pAccnt, DWORD *dwErr );
int IsDomainSpecifiedOtherThanLocalMachine(LPCTSTR pDomainUserName);
#ifndef _CHICAGO_
    int CreateIUSRAccount(CString csUsername, CString csPassword, INT* piNewlyCreatedUser);
    int CreateIWAMAccount(CString csUsername, CString csPassword, INT* piNewlyCreatedUser);

    DWORD MigrateServiceIpSec(LPWSTR  pszSrvRegKey,LPWSTR  pszSrvMetabasePath);
    BOOL  CleanAdminACL(SECURITY_DESCRIPTOR *pSD);
    void  FixAdminACL(LPTSTR szKeyPath);
    DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryone);
    DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag);
    DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath);
    DWORD WriteSessiontoMetaBase(LPCTSTR szKeyPath);

    BOOL AddUserAccessToSD(IN  PSECURITY_DESCRIPTOR pSd,IN  PSID pSid,IN  DWORD  NewAccess,IN  UCHAR TheAceType,OUT PSECURITY_DESCRIPTOR *ppSdNew);
    void DumpAdminACL(HANDLE hFile,PSECURITY_DESCRIPTOR pSD);
#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\mdacl.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include <aclapi.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "log.h"
#include "mdkey.h"
#include "dcomperm.h"
#include "other.h"
#include "mdacl.h"
#include <sddl.h>       // ConvertSidToStringSid

extern int g_GlobalDebugCrypto;

#ifndef _CHICAGO_

BOOL CleanAdminACL(SECURITY_DESCRIPTOR *pSD)
{
    // iisDebugOut((LOG_TYPE_TRACE, _T("CleanAdminACL(): Start.\n")));
    BOOL fSetData = FALSE;
    BOOL b= FALSE, bDaclPresent = FALSE, bDaclDefaulted = FALSE;;
    PACL pDacl = NULL;
    LPVOID pAce = NULL;
    int i = 0;
    ACE_HEADER *pAceHeader;
    ACCESS_MASK dwOldMask, dwNewMask,  dwExtraMask, dwMask;

    dwMask = (MD_ACR_READ |
            MD_ACR_WRITE |
            MD_ACR_RESTRICTED_WRITE |
            MD_ACR_UNSECURE_PROPS_READ |
            MD_ACR_ENUM_KEYS |
            MD_ACR_WRITE_DAC);

    b = GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pDacl, &bDaclDefaulted);
    if (NULL == pDacl)
    {
        return FALSE;
    }
    if (b) {
        //iisDebugOut((LOG_TYPE_TRACE, _T("CleanAdminACL:ACE count: %d\n"), (int)pDacl->AceCount));
        for (i=0; i<(int)pDacl->AceCount; i++) {
            b = GetAce(pDacl, i, &pAce);
            if (b) {
                pAceHeader = (ACE_HEADER *)pAce;
                switch (pAceHeader->AceType) {
                case ACCESS_ALLOWED_ACE_TYPE:
                    dwOldMask = ((ACCESS_ALLOWED_ACE *)pAce)->Mask;
                    dwExtraMask = dwOldMask & (~dwMask);
                    if (dwExtraMask) {
                        fSetData = TRUE;
                        dwNewMask = dwOldMask & dwMask;
                        ((ACCESS_ALLOWED_ACE *)pAce)->Mask = dwNewMask;
                    }
                    break;
                case ACCESS_DENIED_ACE_TYPE:
                    dwOldMask = ((ACCESS_DENIED_ACE *)pAce)->Mask;
                    dwExtraMask = dwOldMask & (~dwMask);
                    if (dwExtraMask) {
                        fSetData = TRUE;
                        dwNewMask = dwOldMask & dwMask;
                        ((ACCESS_DENIED_ACE *)pAce)->Mask = dwNewMask;
                    }
                    break;
                case SYSTEM_AUDIT_ACE_TYPE:
                    dwOldMask = ((SYSTEM_AUDIT_ACE *)pAce)->Mask;
                    dwExtraMask = dwOldMask & (~dwMask);
                    if (dwExtraMask) {
                        fSetData = TRUE;
                        dwNewMask = dwOldMask & dwMask;
                        ((SYSTEM_AUDIT_ACE *)pAce)->Mask = dwNewMask;
                    }
                    break;
                default:
                    break;
                }
            } else {
                //iisDebugOut((LOG_TYPE_TRACE, _T("CleanAdminACL:GetAce:err=%x\n"), GetLastError()));
            }
        }
    } else {
        //iisDebugOut((LOG_TYPE_TRACE, _T("CleanAdminACL:GetSecurityDescriptorDacl:err=%x\n"), GetLastError()));
    }

    //iisDebugOut_End(_T("CleanAdminACL"),LOG_TYPE_TRACE);
    return (fSetData);
}

void FixAdminACL(LPTSTR szKeyPath)
{
    // iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("FixAdminACL Path=%1!s!. Start.\n"), szKeyPath));
    BOOL bFound = FALSE, b = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    CString csName, csValue;
    PBYTE pData;
    int BufSize;
    SECURITY_DESCRIPTOR *pSD;

    cmdKey.OpenNode(szKeyPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound && (cbLen > 0))
        {
            if ( ! (bufData.Resize(cbLen)) )
            {
                cmdKey.Close();
                return;  // insufficient memory
            }
            else
            {
                pData = (PBYTE)(bufData.QueryPtr());
                BufSize = cbLen;
                cbLen = 0;
                bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
            }
        }
        cmdKey.Close();

        if (bFound && (dType == BINARY_METADATA))
        {
            pSD = (SECURITY_DESCRIPTOR *)pData;

            b = CleanAdminACL(pSD);
            if (b)
            {
                // need to reset the data
                DWORD dwLength = GetSecurityDescriptorLength(pSD);
                cmdKey.OpenNode(szKeyPath);
                if ( (METADATA_HANDLE)cmdKey )
                {
                    cmdKey.SetData(MD_ADMIN_ACL,METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA,dwLength,(LPBYTE)pSD);
                    cmdKey.Close();
                }
            }
        }
    }

    //iisDebugOut_End1(_T("FixAdminACL"),szKeyPath,LOG_TYPE_TRACE);
    return;
}

#endif //_CHICAGO_

#ifndef _CHICAGO_
DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount)
{
    iisDebugOut_Start1(_T("SetAdminACL"), szKeyPath, LOG_TYPE_TRACE);

    int iErr=0;
    DWORD dwErr=0;

    DWORD dwRetCode = ERROR_SUCCESS;
    BOOL b = FALSE;
    DWORD dwLength = 0;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    PACL pACLNew = NULL;
    DWORD cbACL = 0;
    PSID pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (!pSD)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:LocalAlloc FAILED.out of memory. GetLastError()= 0x%x\n"), ERROR_NOT_ENOUGH_MEMORY));
        dwRetCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    iErr = InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
    if (iErr == 0)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:InitializeSecurityDescriptor FAILED.  GetLastError()= 0x%x\n"), GetLastError() ));
        dwRetCode = GetLastError() != ERROR_SUCCESS ? GetLastError() : ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    // Get Local Admins Sid
    dwErr = GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:GetPrincipalSID(Administrators) FAILED.  Return Code = 0x%x\n"), dwErr));
        dwRetCode = dwErr;
        goto Cleanup;
    }

    // Get everyone Sid
    dwErr = GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:GetPrincipalSID(Everyone) FAILED.  Return Code = 0x%x\n"), dwErr));
        dwRetCode = dwErr;
        goto Cleanup;
    }

    // Calculate the length needed for the ACL
    cbACL = sizeof(ACL) + (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD));

    if ( dwAccessForEveryoneAccount != 0x00 )
    {
      // Add room for everyone ACL
      cbACL += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD);
    }

    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if ( !pACLNew )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:pACLNew LocalAlloc(LPTR,  FAILED. size = %u GetLastError()= 0x%x\n"), cbACL, GetLastError()));
        dwRetCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!InitializeAcl(pACLNew, cbACL, ACL_REVISION))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:InitializeAcl FAILED.  GetLastError()= 0x%x\n"), GetLastError));
        dwRetCode = GetLastError() != ERROR_SUCCESS ? GetLastError() : ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,(MD_ACR_READ |MD_ACR_WRITE |MD_ACR_RESTRICTED_WRITE |MD_ACR_UNSECURE_PROPS_READ |MD_ACR_ENUM_KEYS |MD_ACR_WRITE_DAC),pAdminsSID))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:AddAccessAllowedAce(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), GetLastError));
        dwRetCode = GetLastError() != ERROR_SUCCESS ? GetLastError() : ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( dwAccessForEveryoneAccount != 0x00 )
    {
      if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,dwAccessForEveryoneAccount,pEveryoneSID))
      {
          iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:AddAccessAllowedAce(pEveryoneSID) FAILED.  GetLastError()= 0x%x\n"), GetLastError()));
          dwRetCode = GetLastError() != ERROR_SUCCESS ? GetLastError() : ERROR_OUTOFMEMORY;
          goto Cleanup;
      }
    }

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:SetSecurityDescriptorDacl(pACLNew) FAILED.  GetLastError()= 0x%x\n"), GetLastError()));
        dwRetCode = GetLastError() != ERROR_SUCCESS ? GetLastError() : ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:SetSecurityDescriptorOwner(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), GetLastError()));
        dwRetCode = GetLastError() != ERROR_SUCCESS ? GetLastError() : ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:SetSecurityDescriptorGroup(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), GetLastError()));
        dwRetCode = GetLastError() != ERROR_SUCCESS ? GetLastError() : ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    // Security descriptor blob must be self relative
    b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:GlobalAlloc FAILED. cboutpSD = %u  GetLastError()= 0x%x\n"), cboutpSD, GetLastError()));
        dwRetCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    b = MakeSelfRelativeSD( pSD, outpSD, &cboutpSD );
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:MakeSelfRelativeSD() FAILED. cboutpSD = %u GetLastError()= 0x%x\n"),cboutpSD, GetLastError()));
        dwRetCode = GetLastError() != ERROR_SUCCESS ? GetLastError() : ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if (outpSD)
    {
        if (IsValidSecurityDescriptor(outpSD))
        {
            // Apply the new security descriptor to the metabase
            iisDebugOut_Start(_T("SetAdminACL:Write the new security descriptor to the Metabase"),LOG_TYPE_TRACE);
            iisDebugOut((LOG_TYPE_TRACE, _T("SetAdminACL:  At this point we have already been able to write basic entries to the metabase, so...")));
            iisDebugOut((LOG_TYPE_TRACE, _T("SetAdminACL:  If this has a problem then there is a problem with setting up encryption for the metabase (Crypto).")));
            //DoesAdminACLExist(szKeyPath);

            if (g_GlobalDebugCrypto == 2)
            {
                // if we want to call this over and over...
                do
                {
                    dwRetCode = WriteSDtoMetaBase(outpSD, szKeyPath);
                    if (FAILED(dwRetCode))
                    {
                        OutputDebugString(_T("\nCalling WriteSDtoMetaBase again...Set iis!g_GlobalDebugCrypto to 0 to stop looping on failure."));
                        OutputDebugString(_T("\nSet iis!g_GlobalDebugCrypto to 0 to stop looping on crypto failure.\n"));
                    }
                } while (FAILED(dwRetCode) && g_GlobalDebugCrypto == 2);
            }
            else
            {
                dwRetCode = WriteSDtoMetaBase(outpSD, szKeyPath);
            }
            //DoesAdminACLExist(szKeyPath);
            iisDebugOut_End(_T("SetAdminACL:Write the new security descriptor to the Metabase"),LOG_TYPE_TRACE);
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:IsValidSecurityDescriptor.4.SelfRelative(%u) FAILED!"),outpSD));
        }
    }

    if (outpSD){GlobalFree(outpSD);outpSD=NULL;}
  
Cleanup:
  // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
  if (pAdminsSID){FreeSid(pAdminsSID);}
  if (pEveryoneSID){FreeSid(pEveryoneSID);}
  if (pSD){LocalFree((HLOCAL) pSD);}
  if (pACLNew){LocalFree((HLOCAL) pACLNew);}
  iisDebugOut_End1(_T("SetAdminACL"),szKeyPath,LOG_TYPE_TRACE);
  return (dwRetCode);
}


DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag)
{
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;
    LogHeapState(FALSE, __FILE__, __LINE__);

	do
	{
		dwReturn = SetAdminACL(szKeyPath, dwAccessForEveryoneAccount);
        LogHeapState(FALSE, __FILE__, __LINE__);
		if (FAILED(dwReturn))
		{
			if (bDisplayMsgOnErrFlag == TRUE)
			{
                iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				case IDIGNORE:
					dwReturn = ERROR_SUCCESS;
					goto SetAdminACL_wrap_Exit;
				case IDABORT:
					dwReturn = ERROR_OPERATION_ABORTED;
					goto SetAdminACL_wrap_Exit;
				case IDRETRY:
					break;
				default:
					break;
				}
			}
			else
			{
				// return whatever err happened
				goto SetAdminACL_wrap_Exit;
			}
		}
                                    else
                                    {
                                                      break;
                                    } 
	} while ( FAILED(dwReturn) );

SetAdminACL_wrap_Exit:
	return dwReturn;
}

#endif


#ifndef _CHICAGO_
DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath)
{
    iisDebugOut_Start(_T("WriteSDtoMetaBase"), LOG_TYPE_TRACE);
    DWORD dwReturn = ERROR_ACCESS_DENIED;
    DWORD dwLength = 0;
    DWORD dwMDFlags = 0;
    CMDKey cmdKey;
    HRESULT hReturn = E_FAIL;
    int iSavedFlag = 0;
        
    dwMDFlags = METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA;
    iSavedFlag = g_GlobalDebugCrypto;

    if (!outpSD)
    {
        dwReturn = ERROR_INVALID_SECURITY_DESCR;
        goto WriteSDtoMetaBase_Exit;
    }

    // Apply the new security descriptor to the metabase
    dwLength = GetSecurityDescriptorLength(outpSD);

    // open the metabase
    // stick it into the metabase.  warning those hoses a lot because
    // it uses encryption.  rsabase.dll

    // Check for special debug flag in metabase to break right before this call!
    if (g_GlobalDebugCrypto != 0)
    {
        // special flag to say... hey "stop setup so that the crypto team can debug they're stuff"
        iisDebugOut((LOG_TYPE_TRACE, _T("Breakpoint enabled thru setup (to debug crypto api). look at debugoutput.")));
        OutputDebugString(_T("\n\nBreakpoint enabled thru setup (to debug crypto api)"));
        OutputDebugString(_T("\n1.in this process:"));
        OutputDebugString(_T("\n  set breakpoint on admwprox!IcpGetContainerHelper"));
        OutputDebugString(_T("\n  set breakpoint on advapi32!CryptAcquireContextW"));
        OutputDebugString(_T("\n  IcpGetKeyHelper will call CryptAcquireContext and try to open an existing key container,"));
        OutputDebugString(_T("\n  if it doesn't exist it will return NTE_BAD_KEYSET, and IcpGetContainerHelper will try to create the container."));
        OutputDebugString(_T("\n2.in the inetinfo process:"));
        OutputDebugString(_T("\n  set breakpoint on admwprox!IcpGetContainerHelper"));
        OutputDebugString(_T("\n  set breakpoint on advapi32!CryptAcquireContextW\n"));
    }

    hReturn = cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        TCHAR szErrorString[50];
        iisDebugOut((LOG_TYPE_TRACE, _T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), dwdata = %d; outpSD = %x, Start\n"), dwLength, (DWORD_PTR) outpSD ));
        if (g_GlobalDebugCrypto != 0)
        {
            OutputDebugString(_T("\nCalling SetData....\n"));
            DebugBreak();
        }
        dwReturn = cmdKey.SetData(MD_ADMIN_ACL,dwMDFlags,IIS_MD_UT_SERVER,BINARY_METADATA,dwLength,(LPBYTE)outpSD);
        if (FAILED(dwReturn))
        {
           iisDebugOut((LOG_TYPE_ERROR, _T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), FAILED. Code=0x%x.End.\n"), dwReturn));
           if (g_GlobalDebugCrypto != 0)
            {
               _stprintf(szErrorString, _T("\r\nSetData Failed. code=0x%x\r\n\r\n"), dwReturn);
               OutputDebugString(szErrorString);
            }
 
        }
        else
        {
            dwReturn = ERROR_SUCCESS;
            iisDebugOut((LOG_TYPE_TRACE, _T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), Success.End.\n")));
            if (g_GlobalDebugCrypto != 0)
            {
               _stprintf(szErrorString, _T("\r\nSetData Succeeded. code=0x%x\r\n\r\n"), dwReturn);
               OutputDebugString(szErrorString);
            }
        }
        cmdKey.Close();
    }
    else
    {
        dwReturn = hReturn;
    }
   
WriteSDtoMetaBase_Exit:
    g_GlobalDebugCrypto = iSavedFlag;
    iisDebugOut((LOG_TYPE_TRACE, _T("WriteSDtoMetaBase:End.  Return=0x%x"), dwReturn));
    return dwReturn;
}

DWORD WriteSessiontoMetaBase(LPCTSTR szKeyPath)
{
    iisDebugOut_Start(_T("WriteSessiontoMetaBase"), LOG_TYPE_TRACE);
    DWORD dwReturn = ERROR_ACCESS_DENIED;
    CMDKey cmdKey;
    HRESULT hReturn = E_FAIL;
    
    hReturn = cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        dwReturn = cmdKey.SetData(9999,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA,0,(LPBYTE)"");
        if (FAILED(dwReturn))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("WriteSessiontoMetaBase:cmdKey():SetData(), FAILED. Code=0x%x.End.\n"), dwReturn));
        }
        else
        {
            dwReturn = ERROR_SUCCESS;
            iisDebugOut((LOG_TYPE_TRACE, _T("WriteSessiontoMetaBase:cmdKey():SetData(), Success.End.\n")));
        }
        cmdKey.Close();
    }
    else
    {
        dwReturn = hReturn;
    }
   
    iisDebugOut((LOG_TYPE_TRACE, _T("WriteSessiontoMetaBase:End.  Return=0x%x"), dwReturn));
    return dwReturn;
}
#endif

//----------------------------------------------------------------------------
// Test if the given account name is an account on the local machine or not.
//----------------------------------------------------------------------------
BOOL IsLocalAccount(LPCTSTR pAccnt, DWORD *dwErr )
    {
    BOOL        fIsLocalAccount = FALSE;
    CString     csDomain, csComputer;
    DWORD       cbDomain = 0;

    PSID         pSid = NULL;
    DWORD        cbSid = 0;
    SID_NAME_USE snu;

    // get the computer name
    cbDomain = _MAX_PATH;
    GetComputerName(
        csComputer.GetBuffer( cbDomain ), // address of name buffer
        &cbDomain                         // address of size of name buffer
        );
    csComputer.ReleaseBuffer();
    cbDomain = 0;

    // have security look up the account name and get the domain name. We dont' care about
    // the other stuff it can return, so pass in nulls
    BOOL fLookup = LookupAccountName(
        NULL,                       // address of string for system name
        pAccnt,                     // address of string for account name
        NULL,                       // address of security identifier
        &cbSid,                     // address of size of security identifier
        NULL,// address of string for referenced domain
        &cbDomain,                  // address of size of domain string
        &snu                        // address of SID-type indicator
        );

    // check the error - it should be insufficient buffer
    *dwErr = GetLastError();
    if (*dwErr != ERROR_INSUFFICIENT_BUFFER)
        return FALSE;

    // allocate the sid
    pSid = (PSID) malloc (cbSid);
    if (!pSid )
        {
        *dwErr = GetLastError();
        return FALSE;
        }

    // do the real lookup
    fLookup = LookupAccountName (NULL,pAccnt,pSid,&cbSid,csDomain.GetBuffer(cbDomain+2),&cbDomain,&snu);
    csDomain.ReleaseBuffer();

    // free the pSid we allocated above and set the final error code
    *dwErr = GetLastError();
    free( pSid );
    pSid = NULL;

    // compare the domain to the machine name, if it is the same, then set the sub auth
    if ( fLookup && (csDomain.CompareNoCase(csComputer) == 0) )
        fIsLocalAccount = TRUE;

    // return the answer
    return fIsLocalAccount;
    }


// pDomainUserName can be one of the following:
//
// domainname\username       <-- this function returns true
// computername\username     <-- this function returns false
// username                  <-- this function returns false
//
int IsDomainSpecifiedOtherThanLocalMachine(LPCTSTR pDomainUserName)
{
    int iReturn = TRUE;
    TCHAR szTempDomainUserName[_MAX_PATH];
    iisDebugOut_Start1(_T("IsDomainSpecifiedOtherThanLocalMachine"),pDomainUserName);

    CString     csComputer;
    DWORD       cbDomain = 0;

    // Make a copy to be sure not to move the pointer around.
    _tcscpy(szTempDomainUserName, pDomainUserName);
    
    // Check if there is a "\" in there.
    LPTSTR pch = NULL;
    pch = _tcschr(szTempDomainUserName, _T('\\'));
    if (!pch) 
        {
        // no '\' found so, they must be specifying only the username, return false
        iReturn = FALSE;
        goto IsDomainSpecifiedOtherThanLocalMachine_Exit;
        }

    // We have at least a '\' in there, so set default return to true.
    // let's check if the name is the local computername!

    // get the computer name
    cbDomain = _MAX_PATH;
    if (0 == GetComputerName(csComputer.GetBuffer( cbDomain ),&cbDomain) )
    {
        // failed to get computername so, let's bail
        iReturn = TRUE;
        csComputer.ReleaseBuffer();
        goto IsDomainSpecifiedOtherThanLocalMachine_Exit;
    }
    csComputer.ReleaseBuffer();
    cbDomain = 0;

    // trim off the '\' character to leave just the domain\computername so we can check against it.
    *pch = _T('\0');
    
    // Compare the domainname with the computername
    // if they match then it's the local system account.
    iReturn = TRUE;
    iisDebugOut((LOG_TYPE_TRACE, _T("IsDomainSpecifiedOtherThanLocalMachine(): %s -- %s.\n"), szTempDomainUserName, csComputer));
    if (  0 == csComputer.CompareNoCase(szTempDomainUserName) )
    {
        // The domain name and the computername are the same.
        // it is the same place.
        iReturn = FALSE;
    }

IsDomainSpecifiedOtherThanLocalMachine_Exit:
    iisDebugOut((LOG_TYPE_TRACE, _T("IsDomainSpecifiedOtherThanLocalMachine():%s.End.Ret=%d.\n"), pDomainUserName,iReturn));
    return iReturn;
}



#ifndef _CHICAGO_
void DumpAdminACL(HANDLE hFile,PSECURITY_DESCRIPTOR pSD)
{
    BOOL b= FALSE, bDaclPresent = FALSE, bDaclDefaulted = FALSE;;
    PACL pDacl = NULL;
    ACCESS_ALLOWED_ACE* pAce;

    iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:Start\n")));

    b = GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pDacl, &bDaclDefaulted);
    if (NULL == pDacl)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:No Security.\n")));
        return;
    }
    if (b) 
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:ACE count: %d\n"), (int)pDacl->AceCount));

        // get dacl length  
        DWORD cbDacl = pDacl->AclSize;
        // now check if SID's ACE is there  
        for (int i = 0; i < pDacl->AceCount; i++)  
        {
            if (!GetAce(pDacl, i, (LPVOID *) &pAce))
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:GetAce failed with 0x%x\n"),GetLastError()));
            }

		    if (IsValidSid(   (PSID) &(pAce->SidStart)   ) )
		    {
			    LPTSTR pszSid;

                LPCTSTR ServerName = NULL; // local machine
                DWORD cbName = UNLEN+1;
                TCHAR ReferencedDomainName[200];
                DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
                SID_NAME_USE sidNameUse = SidTypeUser;
                TCHAR szUserName[UNLEN + 1];

                // dump out the sid in string format
			    if (ConvertSidToStringSid(  (PSID) &(pAce->SidStart)  , &pszSid))
			    {
                    _tcscpy(szUserName, _T("(unknown...)"));
                    if (LookupAccountSid(ServerName, (PSID) &(pAce->SidStart), szUserName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
                    {
                        // Get the rights for this user.
                        // pAce->Mask
                        DWORD dwBytesWritten = 0;
                        TCHAR szBuf[UNLEN+1 + 20 + 20];
                        memset(szBuf, 0, _tcslen(szBuf) * sizeof(TCHAR));

                        /*
                        typedef struct _ACCESS_ALLOWED_ACE {
                            ACE_HEADER Header;
                            ACCESS_MASK Mask;
                            ULONG SidStart;
                        } ACCESS_ALLOWED_ACE;

                        typedef struct _ACE_HEADER {
                            UCHAR AceType;
                            UCHAR AceFlags;
                            USHORT AceSize;
                        } ACE_HEADER;
                        typedef ACE_HEADER *PACE_HEADER;

                          typedef ULONG ACCESS_MASK;
                        */
                        _stprintf(szBuf, _T("%s,%s,0x%x,0x%x,0x%x,0x%x\r\n"), 
                            szUserName,
                            pszSid,
                            pAce->Header.AceType,
                            pAce->Header.AceFlags,
                            pAce->Header.AceSize,
                            pAce->Mask
                            );

                        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
                        {
                            if (WriteFile(hFile, szBuf, _tcslen(szBuf) * sizeof(TCHAR), &dwBytesWritten, NULL ) == FALSE )
                                {iisDebugOut((LOG_TYPE_WARN, _T("WriteFile Failed=0x%x.\n"), GetLastError()));}
                        }
                        else
                        {
                            // echo to logfile
                            iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:Sid[%i]=%s,%s,0x%x,0x%x,0x%x,0x%x\n"),i,
                                pszSid,
                                szUserName,
                                pAce->Header.AceType,
                                pAce->Header.AceFlags,
                                pAce->Header.AceSize,
                                pAce->Mask
                                ));
                        }
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:Sid[%i]=%s='%s'\n"),i,pszSid,szUserName));
                    }

                    
				    LocalFree(LocalHandle(pszSid));
			    }
		    }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:IsVAlidSid failed with 0x%x\n"),GetLastError()));
            }
        }
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:End\n")));
    return;
}
#endif

DWORD MDDumpAdminACL(CString csKeyPath)
{
    DWORD dwReturn = ERROR_ACCESS_DENIED;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    PSECURITY_DESCRIPTOR pOldSd = NULL;

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound)
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("MDDumpAdminACL():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                }
            }
        }
        cmdKey.Close();

        if (bFound)
        {
            // dump out the info
            // We've got the acl
            pOldSd = (PSECURITY_DESCRIPTOR) pData;
            if (IsValidSecurityDescriptor(pOldSd))
            {
#ifndef _CHICAGO_
                DumpAdminACL(INVALID_HANDLE_VALUE,pOldSd);
                dwReturn = ERROR_SUCCESS;
#endif
            }
        }
        else
        {
            dwReturn = ERROR_PATH_NOT_FOUND;
        }
    }
    return dwReturn;
}

// function: AddUserToMetabaseACL_Rec
//
// Add a user to a metabase acl recursively.  This will add them 
// directly to the location you specify, and then to any other
// location that is a child of it, that has an ACL set
//
DWORD AddUserToMetabaseACL_Rec(CString csKeyPath, LPTSTR szUserToAdd, DWORD dwAccessMask )
{
  CMDKey      cmdKey;
  DWORD       dwRet;
  CStringList AclList;
  POSITION    pos;
  CString     csPath;
  CString     csFullPath;
  CString     csNewPath;

  dwRet = AddUserToMetabaseACL( csKeyPath, szUserToAdd, dwAccessMask );

  if ( dwRet != ERROR_SUCCESS )
  {
    // Failed, so lets exit
    return dwRet;
  }

  if ( FAILED( cmdKey.OpenNode(csKeyPath) ) ||
       FAILED( cmdKey.GetDataPaths( MD_ADMIN_ACL,
                                    BINARY_METADATA,
                                    AclList ) )
     )
  {
    return ERROR_ACCESS_DENIED;
  }

  // Close Metabase
  cmdKey.Close();

  pos = AclList.GetHeadPosition();

  while ( NULL != pos )
  {
    csPath = AclList.GetNext( pos );

    if ( ( _tcscmp( csPath.GetBuffer(0), _T("/") ) == 0 ) ||
         ( _tcsnicmp( csPath.GetBuffer(0), 
                      METABASEPATH_SCHEMA, 
                      _tcslen( METABASEPATH_SCHEMA ) ) == 0 )
       )
    {
      // If we are at the root of where we set it, then skip this one,
      // since this is already set.  Or if we are in the schema, it
      // should not be changed
      continue;
    }

    if ( _tcscmp( csKeyPath.GetBuffer(0), _T("/") ) == 0 )
    {
      // If the root of the acl we are at is the root, then don't
      // add '/' to it, since it already starts with a '/'
      csFullPath = csPath;
    }
    else
    {
      csFullPath = csKeyPath + csPath;
    }

    dwRet = AddUserToMetabaseACL( csFullPath, szUserToAdd, dwAccessMask );

    if ( dwRet != ERROR_SUCCESS )
    {
      return dwRet;
    }
  }

  return dwRet;
}

DWORD AddUserToMetabaseACL(CString csKeyPath, LPTSTR szUserToAdd, DWORD dwAccessMask )
{
    DWORD dwReturn = ERROR_ACCESS_DENIED;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    PSECURITY_DESCRIPTOR pOldSd = NULL;
    PSECURITY_DESCRIPTOR pNewSd = NULL;

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound)
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("AddUserToMetabaseACL():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                }
            }
        }

        cmdKey.Close();

        if (bFound)
        {
            // We've got the acl
            // so now we want to add a user to it.
            pOldSd = (PSECURITY_DESCRIPTOR) pData;
            if (IsValidSecurityDescriptor(pOldSd))
            {
                PSID principalSID = NULL;
                BOOL bWellKnownSID = FALSE;

                if ( dwAccessMask == 0x00 )
                {
                  // If accessmask is not set, then lets set it
                  dwAccessMask = ( MD_ACR_READ |
				   MD_ACR_WRITE |
				   MD_ACR_RESTRICTED_WRITE |
				   MD_ACR_UNSECURE_PROPS_READ |
				   MD_ACR_ENUM_KEYS |
				   MD_ACR_WRITE_DAC );
                }

                // Get the SID for the certain string (administrator or everyone or whoever)
                dwReturn = GetPrincipalSID(szUserToAdd, &principalSID, &bWellKnownSID);
                if (dwReturn != ERROR_SUCCESS)
                    {
                    iisDebugOut((LOG_TYPE_WARN, _T("AddUserToMetabaseACL:GetPrincipalSID(%s) FAILED.  Error()= 0x%x\n"), szUserToAdd, dwReturn));
                    return dwReturn;
                    }

#ifndef _CHICAGO_
                if (FALSE == AddUserAccessToSD(pOldSd,principalSID,dwAccessMask,ACCESS_ALLOWED_ACE_TYPE,&pNewSd))
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("AddUserToMetabaseACL:AddUserAccessToSD FAILED\n")));
                    return dwReturn;
                }
                if (pNewSd)
                {
                    // We have a new self relative SD
                    // lets write it to the metabase.
                    if (IsValidSecurityDescriptor(pNewSd))
                    {
                       dwReturn = WriteSDtoMetaBase(pNewSd, csKeyPath);
                    }
                }
#endif
            }
        }
        else
        {
            dwReturn = ERROR_PATH_NOT_FOUND;
        }

    }

    if (pNewSd){GlobalFree(pNewSd);}
    iisDebugOut((LOG_TYPE_TRACE, _T("AddUserToMetabaseACL():End.  Return=0x%x.\n"), dwReturn));
    return dwReturn;
}




DWORD DoesAdminACLExist(CString csKeyPath)
{
    DWORD dwReturn = FALSE;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (bFound)
        {
            dwReturn = TRUE;
        }
        else
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("DoesAdminACLExist():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                    if (bFound)
                    {
                        dwReturn = TRUE;
                    }
                }
            }
        }

        cmdKey.Close();
    }

    if (dwReturn != TRUE)
    {
        //No the acl Does not exist
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("DoesAdminACLExist():End.  Return=0x%x.\n"), dwReturn));
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\mdkey.cpp ===
// MdKey.cpp

#include "stdafx.h"

#define INITGUID
#define _WIN32_DCOM
#undef DEFINE_GUID      // Added for NT5 migration
#include <ole2.h>
#include <coguid.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "iwamreg.h"
#include "strfn.h"

#define TIMEOUT_VALUE 5000

INT_PTR CALLBACK pSecureRetryIgnoreAllDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
extern BOOL g_bGlobalWriteUnSecuredIfFailed_All;

CMDKey::CMDKey():
    m_cCoInits(0)
{
    m_pcCom = NULL;
    m_hKey = NULL;
    _tcscpy(m_szCurrentNodeName, _T(""));
}

CMDKey::~CMDKey()
{
    this->Close();

    // while there are outstanding coinits, close them
    while ( m_cCoInits > 0 && !(m_cCoInits < 0) )
        DoCoUnInit();
}

HRESULT CMDKey::DoCoInitEx()
{
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // track our calls to coinit
    if ( SUCCEEDED(hRes) )
    {
        m_cCoInits++;
    }

    return hRes;
}

void CMDKey::DoCoUnInit()
{
    HRESULT hRes = NOERROR;

    // if there are outstanding coinits, uninit one
    if ( m_cCoInits > 0 )
    {
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
        CoUninitialize();
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
        m_cCoInits--;
    }

    // we shouldn't ever have a negative count. But just in case...
    ASSERT( m_cCoInits >= 0 );
    if ( m_cCoInits < 0 )
    {
        // something is seriously wrong here. Prevent looping
        // by going straight to zero, and write an error to the log.
        m_cCoInits = 0;
        iisDebugOut((LOG_TYPE_WARN, _T("WARNING: CoInits in mdkey have gone negative")));
    }
}

// function: EnumKeys 
// 
// Enumerates the keys under the node that is open
//
// Parameters:
//   pchMDName - The resulting name of the key enumeated
//   dwIndex - Index of Item to enumerate
//   pszSubKeyPath - The subkey of the item to open
BOOL
CMDKey::EnumKeys( LPWSTR pchMDName, DWORD dwIndex, LPTSTR pszSubKeyPath )
{
    WCHAR szSubKeyPath[_MAX_PATH] = L"";

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(szSubKeyPath, pszSubKeyPath);
#else
    if ( MultiByteToWideChar( CP_ACP, 0, pszSubKeyPath, -1, szSubKeyPath, _MAX_PATH) == 0 )
    {
        return FALSE;
    }
#endif

    return SUCCEEDED( m_pcCom->EnumKeys(m_hKey, szSubKeyPath, pchMDName, dwIndex) );
}

HRESULT CMDKey::OpenNode(LPCTSTR pchSubKeyPath, BOOL bSupressErrorMessage )
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];

    pszFailedAPI = NULL;

    _tcscpy(m_szCurrentNodeName, pchSubKeyPath);

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) 
    {
        *szSubKeyPath = L'\0';
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = DoCoInitEx();
    if ( FAILED(hRes) && !bSupressErrorMessage )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx() failed, hRes=%x\n"), hRes));
    }

    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    if ( FAILED(hRes) ) 
    {
      if ( !bSupressErrorMessage )
      {
        MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
      }
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if ( FAILED(hRes) ) 
        {
          if ( !bSupressErrorMessage )
          {
            MyMessageBox(NULL, _T("CoCreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
          }
        }
        else 
        {
            _tcscpy(m_szCurrentNodeName, pchSubKeyPath);
            hRes = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
            if ( FAILED(hRes)) 
            {
                if ( ( hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND) ) && !bSupressErrorMessage ) 
                {
                    MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                }
            }
            else 
            {
                b = TRUE;
            }
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    if (!b) {this->Close();}
    return hRes;
}

HRESULT CMDKey::CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];

    _tcscpy(m_szCurrentNodeName, pchSubKeyPath);

    pszFailedAPI = NULL;

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) 
    {
        *szSubKeyPath = L'\0';
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx() failed, hRes=%x\n"), hRes));
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().Start.")));
    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().End.")));
    if (FAILED(hRes)) 
    {
        MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            MyMessageBox(NULL, _T("CreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
        }
        else 
        {
            _tcscpy(m_szCurrentNodeName, pchSubKeyPath);
            hRes = m_pcCom->OpenKey(hKeyBase,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
            if (FAILED(hRes)) 
            {
                if (hRes == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) 
                {
                    METADATA_HANDLE RootHandle;
                    _tcscpy(m_szCurrentNodeName, pchSubKeyPath);
                    hRes = m_pcCom->OpenKey(hKeyBase,L"",METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&RootHandle);
                    hRes = m_pcCom->AddKey(RootHandle, szSubKeyPath);
                    if (FAILED(hRes)) 
                    {
                        MyMessageBox(NULL, _T("AddKey"), hRes, MB_OK | MB_SETFOREGROUND);
                    }
                    hRes = m_pcCom->CloseKey(RootHandle);
                    if (FAILED(hRes)) 
                    {
                        MyMessageBox(NULL, _T("CloseKey of the AddKey"), hRes, MB_OK | MB_SETFOREGROUND);
                    }
                    else 
                    {
                        // open it again to set m_hKey
                        _tcscpy(m_szCurrentNodeName, pchSubKeyPath);
                        hRes = m_pcCom->OpenKey(hKeyBase,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
                        if (FAILED(hRes)) 
                        {
                            MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                        }
                        else 
                        {
                            b = TRUE;
                        }
                    }
                }
                else 
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("calling OpenKey()...failed....something other than ERROR_PATH_NOT_FOUND\n")));
                    MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                }
            }
            else 
            {
                b = TRUE;
            } // end of OpenKey
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    if (!b) {this->Close();}

    return hRes;
}

HRESULT CMDKey::ForceWriteMetabaseToDisk()
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    m_pcCom = NULL;

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx() failed, hRes=%x\n"), hRes));
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().Start.")));
    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().End.")));
    if (FAILED(hRes)) 
    {
        MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            MyMessageBox(NULL, _T("CoCreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
        }
        else 
        {
            if (m_pcCom) 
            {
                hRes = m_pcCom->SaveData();
                iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::ForceWriteMetabaseToDisk():Return=0x%x.\n"),hRes));
            }
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    return hRes;
}

HRESULT CMDKey::Close()
{
    HRESULT hRes = ERROR_SUCCESS;
    if (m_pcCom) 
    {
        if (m_hKey){hRes = m_pcCom->CloseKey(m_hKey);}
        hRes = m_pcCom->Release();
    }
    DoCoUnInit();
    m_pcCom = NULL;
    m_hKey = NULL;
    _tcscpy(m_szCurrentNodeName, _T(""));

    return hRes;
}

BOOL CMDKey::IsEmpty( PWCHAR pszSubString )
{
    int ReturnIndex;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    HRESULT hRes = ERROR_SUCCESS;
    UCHAR ReturnBuf[256];

    for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;
    
    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
    hRes = m_pcCom->EnumData(m_hKey, pszSubString, &mdrData, 0, &dwRequiredDataLen);
    if (FAILED(hRes)) 
    {
        if(hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS) || hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) ) 
        {
            return TRUE;
        }
        else 
        {
            MyMessageBox(NULL, _T("EnumData"), hRes, MB_OK | MB_SETFOREGROUND);
        }
    }
    return (hRes != ERROR_SUCCESS);
}

int CMDKey::GetNumberOfSubKeys( PWCHAR pszSubString )
{
    int i=0;
    HRESULT hRes = ERROR_SUCCESS;
    WCHAR NameBuf[METADATA_MAX_NAME_LEN];
    while (hRes == ERROR_SUCCESS) 
    {
        hRes = m_pcCom->EnumKeys(m_hKey, pszSubString, NameBuf, i++);
    }
    if (hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
    {
        return (--i);
    }
    else 
    {
        MyMessageBox(NULL, _T("EnumKeys"), hRes, MB_OK | MB_SETFOREGROUND);
        return (0);
    }
}

#if !defined(UNICODE) && !defined(_UNICODE)

void MyMultiByteToWideChar( char *sData, WCHAR *wData, int cbBufSize, BOOL fMultiSZ)
{
    MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
    while (fMultiSZ) 
    {
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        while (*wData++);
        if (*sData)
        {
            MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
        }
        else 
        {
            *wData = L'\0';
            break;
        }
    }
    return;
}

void MyWideCharToMultiByte( WCHAR *wData, char *sData, int cbBufSize, BOOL fMultiSZ)
{
    WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
    while (fMultiSZ) 
    {
        while (*wData++);
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        if (*wData)
        {
            WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
        }
        else 
        {
            *sData = '\0';
            break;
        }
    }
    return;
}

#endif      // not unicode

HRESULT CMDKey::SetData(DWORD id,DWORD attr,DWORD uType,DWORD dType,DWORD cbLen, LPBYTE pbData,PWCHAR pszSubString )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    BUFFER bufData;
    WCHAR *pData = (WCHAR *)pbData;
    int iPlsDoNoEncryption = FALSE;

    switch (dType) 
    {
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            pData = (WCHAR *)pbData;
#else
            if ( ! (bufData.Resize(cbLen * sizeof(WCHAR))) )
            {
                // insufficient memory
                iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetData() failed to allocate memory.\n")));
                hRes = RETURNCODETOHRESULT(GetLastError());
                goto SetData_Exit;
            }

            pData = (WCHAR *)(bufData.QueryPtr());
            MyMultiByteToWideChar( (LPTSTR)pbData, pData, cbLen, FALSE);
            cbLen = cbLen * sizeof(WCHAR);
#endif
            break;

        case MULTISZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            pData = (WCHAR *)pbData;
#else
            if ( ! (bufData.Resize(cbLen * sizeof(WCHAR))) )
            {
                // insufficient memory
                iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetData() failed to allocate memory.\n")));
                hRes = RETURNCODETOHRESULT(GetLastError());
                goto SetData_Exit;
            }
            pData = (WCHAR *)(bufData.QueryPtr());
            MyMultiByteToWideChar( (LPTSTR)pbData, pData, cbLen, TRUE );
            cbLen = cbLen * sizeof(WCHAR);
#endif
            break;

        default:
            break;

    }

    //DisplayStringForMetabaseID(id);
    //_tcscpy(m_szCurrentNodeName, _T(""));

    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(id, lpReturnString);
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("CMDKey::SetData[%s:%d:%s].\n"), m_szCurrentNodeName, id, lpReturnString));

    MD_SET_DATA_RECORD(&mdrData, id, attr, uType, dType, cbLen, (LPBYTE)pData);
    hRes = m_pcCom->SetData(m_hKey, pszSubString, &mdrData);

    if (FAILED(hRes))
    {
        // Check if it failed...
        // if it failed and the METADATA_SECURE flag is set, then
        // check if we can retry without the METADATA_SECURE flag!
        if ( attr & METADATA_SECURE )
        {
            if (TRUE == g_bGlobalWriteUnSecuredIfFailed_All)
            {
                iPlsDoNoEncryption = TRUE;
            }
            else
            {
                if (TRUE == DialogBoxParam((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDD_ENCRYPTED_WRITE_ERROR_DIALOG), NULL, pSecureRetryIgnoreAllDlgProc, (LPARAM)hRes))
                {
                    iPlsDoNoEncryption = TRUE;
                }
            }

            if (TRUE == iPlsDoNoEncryption)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetData() failed on a encrypt entry.  try to write it out unencrypted.\n")));
                attr &= ~METADATA_SECURE;
                MD_SET_DATA_RECORD(&mdrData, id, attr, uType, dType, cbLen, (LPBYTE)pData);
                hRes = m_pcCom->SetData(m_hKey, pszSubString, &mdrData);
                if (FAILED(hRes))
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetData() failed on write on encrypt entry as unencrypted.\n")));
                }
                else
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::SetData() success on write on encrypt entry as unencrypted.\n")));
                }
                // set the attr back to what it was
                attr &= ~METADATA_SECURE;
            }
        }
    }
    goto SetData_Exit;

SetData_Exit:
    if (FAILED(hRes)) 
    {
        MyMessageBox(NULL, IDS_SETDATA_ERROR, (int) hRes, MB_OK | MB_SETFOREGROUND);
    }
    return hRes;
}

BOOL CMDKey::GetData(DWORD id,DWORD *pdwAttr,DWORD *pdwUType,DWORD *pdwDType,DWORD *pcbLen,LPBYTE pbData,DWORD BufSize,LPCWSTR pszSubString )
{
    return GetData(id,pdwAttr,pdwUType,pdwDType,pcbLen,pbData,BufSize,0,0,0,pszSubString);
}

BOOL
CMDKey::GetData(CMDValue &Value, DWORD dwId, LPCWSTR pszSubString )
{
    DWORD       dwAttr;
    DWORD       dwUType;
    DWORD       dwDType;
    DWORD       cbLen = 0;
    BUFFER      bufData;

    if (!GetData(dwId,&dwAttr,&dwUType,&dwDType,&cbLen,(LPBYTE) bufData.QueryPtr(),bufData.QuerySize(),0,0,0,pszSubString))
    {
        // Resize to Accomodate the big value
        if (!bufData.Resize(cbLen))
        {
            return FALSE;
        }

        if (!GetData(dwId,&dwAttr,&dwUType,&dwDType,&cbLen,(LPBYTE) bufData.QueryPtr(),bufData.QuerySize(),0,0,0,pszSubString))
        {
            // Even with the new size buffer we could not retrieve the value
            return FALSE;
        }    
    }

    return ( Value.SetValue(dwId,dwAttr,dwUType,dwDType,cbLen,(LPVOID) bufData.QueryPtr()) );
}

BOOL
CMDKey::SetData(CMDValue &Value, DWORD dwId, PWCHAR pszSubString )
{
  return SUCCEEDED( SetData(dwId,
                    Value.GetAttributes(),
                    Value.GetUserType(),
                    Value.GetDataType(),
                    Value.GetDataLen(),
                    (LPBYTE) Value.GetData(),
                    pszSubString ) );
}

// Note: only use to access the AnonyName and AnonyPassword,
// buffer size 256 is big enough here
BOOL CMDKey::GetData(DWORD id,DWORD *pdwAttr,DWORD *pdwUType,DWORD *pdwDType,DWORD *pcbLen,LPBYTE pbData,DWORD  BufSize,DWORD  dwAttributes,DWORD  dwUType,DWORD  dwDType,LPCWSTR pszSubString )
{
    BOOL fReturn = FALSE;
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    LPBYTE ReturnBuf=NULL;
    int ReturnBufSize;

    // if we are just trying to get the size of the field, just do that.
    if ( !pbData || (BufSize == 0) )
    {
        MD_SET_DATA_RECORD(&mdrData, id, dwAttributes, dwUType, dwDType, 0, NULL);
        hRes = m_pcCom->GetData(m_hKey, pszSubString, &mdrData, &dwRequiredDataLen);
        *pcbLen = dwRequiredDataLen;
        fReturn = (hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER));
        goto GetData_Exit;
    }

#if defined(UNICODE) || defined(_UNICODE)
    ReturnBufSize = BufSize;
#else
    ReturnBufSize = 2 * BufSize;
#endif
    ReturnBuf = (LPBYTE)LocalAlloc(LPTR, ReturnBufSize);
    if (!ReturnBuf)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetData() failed to allocate memory.\n")));
        ReturnBuf = NULL;
        goto GetData_Exit;
    }

    //DisplayStringForMetabaseID(id);

    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(id, lpReturnString);
    iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::GetData[%s:%d:%s].\n"), m_szCurrentNodeName, id, lpReturnString));

    MD_SET_DATA_RECORD(&mdrData, id, dwAttributes, dwUType, dwDType, ReturnBufSize, (PBYTE) ReturnBuf);
    hRes = m_pcCom->GetData(m_hKey, pszSubString, &mdrData, &dwRequiredDataLen);
    if (FAILED(hRes)) 
    {
        if (hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) 
        {
#if defined(UNICODE) || defined(_UNICODE)
            *pcbLen = dwRequiredDataLen;
#else
            *pcbLen = dwRequiredDataLen / 2;
#endif
        }
        else 
        {
            *pcbLen = 0;
            if ( (hRes != RETURNCODETOHRESULT(MD_ERROR_DATA_NOT_FOUND) ) &&
                 (hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND) )
               )
            {
                MyMessageBox(NULL, IDS_GETDATA_ERROR, (int) hRes, MB_OK | MB_SETFOREGROUND);
            }
        }
        goto GetData_Exit;
    }

    // --------
    // We have successfully retrieved the data at this point
    // --------
    *pdwAttr = mdrData.dwMDAttributes;
    *pdwUType = mdrData.dwMDUserType;
    *pdwDType = mdrData.dwMDDataType;
    *pcbLen = mdrData.dwMDDataLen; // number of SBCS chars + ending \0
    switch (*pdwDType) 
    {
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
#else
            *pcbLen = (*pcbLen) / sizeof(WCHAR);
            WideCharToMultiByte(CP_ACP,0,(WCHAR *)(mdrData.pbMDData),-1,(LPSTR)pbData,*pcbLen, NULL, NULL);
#endif
            fReturn = TRUE;
            break;
        case MULTISZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
#else
            *pcbLen = (*pcbLen) / sizeof(WCHAR);
            MyWideCharToMultiByte((WCHAR *)(mdrData.pbMDData),(LPSTR)pbData, *pcbLen, TRUE);
#endif
            fReturn = TRUE;
            break;
        default:
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
            fReturn = TRUE;
            break;
    }

GetData_Exit:
    if(ReturnBuf) {LocalFree(ReturnBuf);}
    return fReturn;
}

HRESULT CMDKey::DeleteData(DWORD id, DWORD dType, PWCHAR pszSubString)
{
    HRESULT hRes = ERROR_SUCCESS;

    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(id, lpReturnString);
    iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::DeleteData[%s:%d:%s].\n"), m_szCurrentNodeName, id, lpReturnString));

    hRes = m_pcCom->DeleteData(m_hKey, pszSubString, id, dType);
    return hRes;
}

HRESULT CMDKey::DeleteNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    WCHAR szSubKeyPath[_MAX_PATH];

    if ( pchSubKeyPath && (*pchSubKeyPath) ) 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH );
#endif

        iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::DeleteNode[%s:%s].\n"), m_szCurrentNodeName, szSubKeyPath));
        hRes = m_pcCom->DeleteKey(m_hKey, szSubKeyPath);
    }

    return hRes;
}

CMDKeyIter::CMDKeyIter(CMDKey &cmdKey)
{
    m_hKey = cmdKey.GetMDKeyHandle();
    m_pcCom = cmdKey.GetMDKeyICOM();

    m_dwBuffer = _MAX_PATH;

    Reset();

    m_pBuffer = new WCHAR [m_dwBuffer];
}

CMDKeyIter::~CMDKeyIter()
{
    delete [] m_pBuffer;
}

LONG CMDKeyIter::Next(CString *pcsName, PWCHAR pwcsSubString)
{
    TCHAR tchData[_MAX_PATH];
    HRESULT hRes = ERROR_SUCCESS;
    hRes = m_pcCom->EnumKeys(m_hKey, pwcsSubString, m_pBuffer, m_index);
    if (FAILED(hRes)) 
    {
        return 1;
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(tchData, m_pBuffer);
#else
        WideCharToMultiByte(CP_ACP,0,m_pBuffer,-1,(LPSTR)tchData,_MAX_PATH, NULL, NULL);
#endif
        *pcsName = tchData;
        m_index++;
        return 0;
    }
}

int CreateInProc(LPCTSTR lpszPath, int iUseOOPPool)
{
    int iReturn = FALSE;
    TCHAR lpszKeyPath[_MAX_PATH];
    WCHAR wchKeyPath[_MAX_PATH];
    HRESULT         hr = NOERROR;
    IWamAdmin2*        pIWamAdmin = NULL;

    DWORD dwAppMode = eAppRunInProc;

    if (iUseOOPPool) {dwAppMode = eAppRunOutProcInDefaultPool;}

    if (lpszPath[0] == _T('/')) 
    {
        _tcscpy(lpszKeyPath, lpszPath);
    }
    else 
    {
        lpszKeyPath[0] = _T('/');
        _tcscpy(_tcsinc(lpszKeyPath), lpszPath);
    }

    if (lpszKeyPath[(_tcslen(lpszKeyPath)-1)] != _T('/')) {_tcscat(lpszKeyPath, _T("/"));}

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wchKeyPath, lpszKeyPath);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpszKeyPath, -1, (LPWSTR)wchKeyPath, _MAX_PATH);
#endif

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().Start.")));
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().End.")));

    if (FAILED(hr))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateInProc: CoInitializeEx() failed, hr=%x\n"), hr));
        MesssageBoxErrors_MTS(IDS_MTS_DOING_CREATEINPROC,hr);
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().Start.")));
    hr = CoCreateInstance(CLSID_WamAdmin,NULL,CLSCTX_SERVER,IID_IWamAdmin2,(void **)&pIWamAdmin);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().End.")));
    if (SUCCEEDED(hr))
    {
        hr = pIWamAdmin->AppCreate2(wchKeyPath, dwAppMode);
        pIWamAdmin->Release();
        if (FAILED(hr)) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Create in-proc(type=%d) app on path %s failed, err=%x.\n"), dwAppMode, lpszKeyPath, hr));
            MyMessageBox(NULL, _T("CreateInProc:Error Creating Transaction Server InProc App."), hr, MB_OK | MB_SETFOREGROUND);
            MesssageBoxErrors_MTS(IDS_MTS_DOING_CREATEINPROC,hr);
        }
        else
        {
            iReturn = TRUE;
        }
    }
    else 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to CoCreateInstance of WamAdmin object. err=%x.\n"), hr));
        MyMessageBox(NULL, _T("CreateInProc:CoCreateInstance"), hr, MB_OK | MB_SETFOREGROUND);
        MesssageBoxErrors_MTS(IDS_MTS_DOING_CREATEINPROC,hr);
    }

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
    CoUninitialize();
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));

    return iReturn;
}

void CreateInProc_Wrap(LPCTSTR lpszPath, int iUseOOPPool)
{
    BOOL bDisplayMsgOnErrFlag = TRUE;
    int iReturn = FALSE;
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	do
	{
		iisDebugOut((LOG_TYPE_TRACE, _T("CreateInProc_Wrap(): %s\n"), lpszPath));
        
        iReturn = CreateInProc(lpszPath, iUseOOPPool);
		if (iReturn == TRUE)
		{
			break;
		}
		else
		{
			if (bDisplayMsgOnErrFlag == TRUE)
			{
				iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				case IDIGNORE:
					iReturn = TRUE;
					goto CreateInProc_Wrap_Exit;
				case IDABORT:
					iReturn = FALSE;
					goto CreateInProc_Wrap_Exit;
				case IDRETRY:
					break;
				default:
					break;
				}
			}
			else
			{
				// return whatever err happened
				goto CreateInProc_Wrap_Exit;
			}

		}
	} while (iReturn  != TRUE);

CreateInProc_Wrap_Exit:
	return;
}

void DeleteInProc(LPCTSTR lpszPath)
{
    TCHAR lpszKeyPath[_MAX_PATH];
    WCHAR wchKeyPath[_MAX_PATH];
    HRESULT         hr = NOERROR;
    IWamAdmin*        pIWamAdmin = NULL;

    iisDebugOut((LOG_TYPE_TRACE, _T("DeleteInProc():Start.%s\n"), lpszPath));
    

    if (lpszPath[0] == _T('/')) 
    {
        _tcscpy(lpszKeyPath, lpszPath);
    }
    else 
    {
        lpszKeyPath[0] = _T('/');
        _tcscpy(_tcsinc(lpszKeyPath), lpszPath);
    }

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wchKeyPath, lpszKeyPath);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpszKeyPath, -1, (LPWSTR)wchKeyPath, _MAX_PATH);
#endif

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().Start.")));
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().End.")));
    if (FAILED(hr))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("DeleteInProc: CoInitializeEx() failed, hr=%x\n"), hr));
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().Start.")));
    hr = CoCreateInstance(CLSID_WamAdmin,NULL,CLSCTX_SERVER,IID_IWamAdmin,(void **)&pIWamAdmin);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().End.")));
    if (SUCCEEDED(hr))
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("DeleteInProc():Calling AppDelete now.%s\n"), lpszKeyPath));
        hr = pIWamAdmin->AppDelete(wchKeyPath, TRUE);
        pIWamAdmin->Release();
        if (FAILED(hr))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Delete in-proc app on path %s failed, err=%x.\n"), lpszKeyPath, hr));
        }
    }
    else 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("DeleteInProc:CoCreateInstance() failed. err=%x.\n"), hr));
    }

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
    CoUninitialize();
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));

    iisDebugOut_End1(_T("DeleteInProc"),(LPTSTR) lpszPath,LOG_TYPE_TRACE);
    return;
}

INT_PTR CALLBACK pSecureRetryIgnoreAllDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hTextWording = NULL;
    CString csErrMsg;
    HRESULT hErrorCode;
    TCHAR pMsg[_MAX_PATH] = _T("");
    HRESULT nNetErr;
    DWORD dwFormatReturn = 0;

    switch (msg)
    {
        case WM_INITDIALOG:
			uiCenterDialog(hDlg);
            hTextWording = GetDlgItem(hDlg, IDC_STATIC2);

            hErrorCode = (HRESULT) lParam;
            nNetErr = (HRESULT) hErrorCode;
            dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, hErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
            if ( dwFormatReturn == 0) 
            {
                if (nNetErr >= NERR_BASE) 
		        {
                    HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
                    if (hDll) 
			        {
                        dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, hErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                        FreeLibrary(hDll);
                    }
                }
            }

            if (dwFormatReturn) {csErrMsg.Format(_T("0x%x=%s"), hErrorCode, pMsg);}
            else{csErrMsg.Format(_T("%s\n\nErrorCode=0x%x."), hErrorCode);}
           
            SetWindowText(hTextWording, csErrMsg);
            UpdateWindow(hDlg);
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                    EndDialog(hDlg, (int)wParam);
                    return FALSE;
                case IDRETRY:
                    EndDialog(hDlg, (int)wParam);
                    return FALSE;
                    break;
                case IDWRITEUNENCRYPTED:
                    EndDialog(hDlg, (int)wParam);
                    return TRUE;
                    break;
                case IDWRITEUNENCRYPTEDALL:
                    g_bGlobalWriteUnSecuredIfFailed_All = TRUE;
                    EndDialog(hDlg, (int)wParam);
                    return TRUE;
                    break;
            }
            break;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
// get a multi-sz data block and immediately parse it into a CStringList
HRESULT CMDKey::GetMultiSzAsStringList (
    DWORD dwMDIdentifier,
    DWORD *uType,
    DWORD *attributes,
    CStringList& szStrList,
    LPCWSTR pszSubString         OPTIONAL )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: GetMultiSzAsStringList on unopened node.%s\n"), _T("")));
        return -1;
    }


    // get the paths. The loop accounts for a buffer that is too small...
    DWORD  dwMDBufferSize = 1024;
    PWCHAR pwchBuffer = NULL;
    do
    {
        if ( pwchBuffer )
        {
            delete pwchBuffer;
            pwchBuffer = NULL;
        }

        pwchBuffer = new WCHAR[dwMDBufferSize];
        if (pwchBuffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // prepare the metadata parameter block
        MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, *attributes,
                *uType, MULTISZ_METADATA, dwMDBufferSize, pwchBuffer);

        // make the call to get the data
        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetData(
            m_hKey,
            pszSubString,
            &mdrData,
            &dwMDBufferSize
            );

        // Set the attributes return.
        *attributes = mdrData.dwMDAttributes;
        *uType = mdrData.dwMDUserType;
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point, we have the data we want. Time to convert it into a CString list.
        if (pwchBuffer)
        {
            // to make prefix stop yelling at me
            if (pwchBuffer[0])
            {
                ConvertWDoubleNullListToStringList(pwchBuffer, szStrList);
            }
        }
    }

    // clean up
    if ( pwchBuffer )
        delete pwchBuffer;

    if ( FAILED(hRes) )
    {
      if (hRes != MD_ERROR_DATA_NOT_FOUND)
      {
        iisDebugOut((LOG_TYPE_WARN, _T("CMDKey::GetMultiSzAsStringList() failed. err=%x.\n"), hRes));
      }
    }

    return hRes;
}

//-----------------------------------------------------------------------------
// take a CStringList and set it into metadata as a multi-sz
HRESULT CMDKey::SetMultiSzAsStringList (
    DWORD dwMDIdentifier,
    DWORD uType,
    DWORD attributes,
    CStringList& szStrList,
    PWCHAR pszSubString         OPTIONAL )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: SetMultiSzAsStringList on unopened node.%s\n"), _T("")));
        return -1;
    }


    DWORD  dwMDBufferSize = 0;
    PWCHAR pwchBuffer = NULL;

    // convert the cstringlist into a wide multisz data block.
    hRes = ConvertStringListToWDoubleNullList(
        szStrList,
        dwMDBufferSize,
        pwchBuffer
        );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: SetMultiSzAsStringList Convert to null list.%x\n"), hRes));
        return hRes;
    }

    // the buffer is expressed in wide characters. Change it to bytes...
    dwMDBufferSize *= sizeof(WCHAR);

    // prepare the metadata parameter block
    MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, attributes,
            uType, MULTISZ_METADATA, dwMDBufferSize, pwchBuffer);

    // make the call to get the data
    hRes = m_pcCom->SetData(
        m_hKey,
        pszSubString,
        &mdrData
        );

    // clean up
    FreeMem( pwchBuffer );

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetMultiSzAsStringList()-SetData failed. err=%x.\n"), hRes));
    }

    return hRes;
}

//-----------------------------------------------------------------------------
// get all the sub keys that have a certain property on them and return the
// sub-paths in a cstring list object. The cstring list should be instantiated
// by the caller and deleted by the same.
HRESULT CMDKey::GetDataPaths( 
    DWORD dwMDIdentifier,
    DWORD dwMDDataType,
    CStringList& szPathList,
    PWCHAR pszSubString )
{
    HRESULT hRes = ERROR_SUCCESS;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: GetDataPaths on unopened node.%s\n"), _T("")));
        return -1;
    }

    // get the paths. The loop accounts for a buffer that is too small...
    DWORD  dwMDBufferSize = 512;
    PWCHAR pwchBuffer = NULL;
    do
    {
        if ( pwchBuffer )
        {
            delete pwchBuffer;
            pwchBuffer = NULL;
        }

        pwchBuffer = new WCHAR[dwMDBufferSize];
        if (pwchBuffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetDataPaths(
            m_hKey,
            pszSubString,
            dwMDIdentifier,
            dwMDDataType,
            dwMDBufferSize,
            pwchBuffer,
            &dwMDBufferSize
            );
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point, we have the data we want. Time to convert it into a CString list.
        ConvertWDoubleNullListToStringList(pwchBuffer, szPathList);
    }

    // clean up
    if ( pwchBuffer )
        delete pwchBuffer;

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetDataPaths() failed. err=%x.\n"), hRes));
    }

    return hRes;
}

//-----------------------------------------------------------------------------
// get a multi-sz data block and immediately parse it into a CStringList
HRESULT CMDKey::GetStringAsCString (
    DWORD dwMDIdentifier,
    DWORD uType,
    DWORD attributes,
    CString& szStr,
    PWCHAR pszSubString OPTIONAL,
    int iStringType OPTIONAL)
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: GetStringAsCString on unopened node.%s\n"), _T("")));
        return -1;
    }

    // get the string. The loop accounts for a buffer that is too small...
    DWORD  dwMDBufferSize = 255;
    PWCHAR pwchBuffer = NULL;
    do
    {
        if ( pwchBuffer )
        {
            delete pwchBuffer;
            pwchBuffer = NULL;
        }

        pwchBuffer = new WCHAR[dwMDBufferSize + 1];
        ZeroMemory( pwchBuffer, (dwMDBufferSize + 1) * sizeof(WCHAR) );
        if (pwchBuffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // prepare the metadata parameter block
        MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, attributes,
                uType, STRING_METADATA, dwMDBufferSize, pwchBuffer);

        // make the call to get the data
        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetData(
            m_hKey,
            pszSubString,
            &mdrData,
            &dwMDBufferSize
            );
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point, we have the data we want. Time to convert it into a CString.
        szStr = pwchBuffer;
    }

    // clean up
    if ( pwchBuffer )
        delete pwchBuffer;

    if ( FAILED(hRes) && !MD_ERROR_DATA_NOT_FOUND)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetStringAsCString() failed. err=%x.\n"), hRes));
    }

    return hRes;
}

//-----------------------------------------------------------------------------
// take a CStringList and set it into metadata as a multi-sz
HRESULT CMDKey::SetCStringAsString (
    DWORD dwMDIdentifier,
    DWORD uType,
    DWORD attributes,
    CString& szStr,
    PWCHAR pszSubString OPTIONAL,
    int iStringType OPTIONAL)
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: SetCStringAsString on unopened node.%s\n"), _T("")));
        return -1;
    }

    DWORD  dwMDBufferSize = 0;
    PWCHAR pwchBuffer = NULL;

    // convert the cstring into a wide string data block.
    pwchBuffer = AllocWideString( (LPCTSTR)szStr );

    // Calculate the size of the buffer in bytes, not wide characters....
    dwMDBufferSize = (szStr.GetLength() + 1) * sizeof(WCHAR);

    // prepare the metadata parameter block
    MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, attributes,
            uType, STRING_METADATA, dwMDBufferSize, pwchBuffer);

    // make the call to get the data
    hRes = m_pcCom->SetData(
        m_hKey,
        pszSubString,
        &mdrData
        );

    // clean up
    FreeMem( pwchBuffer );

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetCStringAsString()-SetData failed. err=%x.\n"), hRes));
    }

    return hRes;
}

HRESULT CMDKey::GetDword(
    DWORD dwMDIdentifier,
    DWORD uType,
    DWORD attributes,
    DWORD& MyDword,
    PWCHAR pszSubString OPTIONAL
    )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD   dwMDBufferSize = 255;
    LPBYTE  Buffer = NULL;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: GetDword on unopened node.\n")));
        return -1;
    }

    // get the data. The loop accounts for a buffer that is too small...
    do
    {
        if ( Buffer )
        {
            delete Buffer;
            Buffer = NULL;
        }

        Buffer = (LPBYTE)LocalAlloc(LPTR, dwMDBufferSize);
        if (Buffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // prepare the metadata parameter block
        MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, attributes, uType, DWORD_METADATA, dwMDBufferSize, Buffer);

        // make the call to get the data
        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetData(m_hKey,pszSubString,&mdrData,&dwMDBufferSize);
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point, we have the data we want. Time to convert it into a dword.
        MyDword = (DWORD) *mdrData.pbMDData;
    }
    
    // clean up
    if ( Buffer )
        LocalFree(Buffer);

    if ( FAILED(hRes) && !MD_ERROR_DATA_NOT_FOUND)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetDword() failed. err=%x.\n"), hRes));
    }

    return hRes;
}


HRESULT CMDKey::RenameNode(LPCTSTR pszMDPath,LPCTSTR pszMDNewName)
{
    HRESULT hRes = ERROR_SUCCESS;
    if (m_pcCom) 
    {
        WCHAR wszPath1[_MAX_PATH];
        WCHAR wszPath2[_MAX_PATH];
        
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(wszPath1, pszMDPath);
        _tcscpy(wszPath2, pszMDNewName);
#else
        MultiByteToWideChar( CP_ACP, 0, pszMDPath, -1, wszPath1, _MAX_PATH);
        MultiByteToWideChar( CP_ACP, 0, pszMDNewName, -1, wszPath2, _MAX_PATH);
#endif
        hRes = m_pcCom->RenameKey(m_hKey,wszPath1,wszPath2);
        if ( FAILED(hRes) && !MD_ERROR_DATA_NOT_FOUND)
        {
            iisDebugOut((LOG_TYPE_WARN, _T("CMDKey::RenameNode(%s,%s) failed. err=%x.\n"), pszMDPath,pszMDNewName,hRes));
        }
   }
    return hRes;
};

// function: CreateABO
//
// Create an ABO object to use.  If this is called and succeeds, 
// you must call CloseABO
//
HRESULT
CMDKey::CreateABO( IMSAdminBase **ppcABO )
{
  HRESULT         hRes = ERROR_SUCCESS;
  IClassFactory   *pcsfFactory = NULL;

  hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

  if ( FAILED(hRes) )
  {
    return hRes;
  }

  hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);

  if ( SUCCEEDED(hRes) ) 
  {
    hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) ppcABO );
    pcsfFactory->Release();
  }

  if ( FAILED( hRes ) )
  {
    CoUninitialize();
  }

  return hRes;
}

// function: CloseABO
//
// Close the ABO object
//
void
CMDKey::CloseABO( IMSAdminBase *pcABO )
{
  ASSERT( pcABO != NULL );

  pcABO->Release();

  CoUninitialize();
}

// Backup
//
// Backup the metabase without a password
//
BOOL 
CMDKey::Backup( LPWSTR szBackupName,
                DWORD  dwVersion,
                DWORD  dwFlags )
{
  BOOL            bRet = FALSE;
  IMSAdminBase    *pcABO;

  if ( FAILED( CreateABO( &pcABO ) ) )
  {
    // Failed to create ABO
    return FALSE;
  }

  bRet = SUCCEEDED( pcABO->Backup( szBackupName, dwVersion, dwFlags ) );

  CloseABO( pcABO );

  return bRet;
}

// DeleteBackup
//
// Delete a backup
//
BOOL 
CMDKey::DeleteBackup( LPWSTR szBackupName,
                      DWORD  dwVersion /* = MD_BACKUP_HIGHEST_VERSION */ )
{
  BOOL            bRet = FALSE;
  IMSAdminBase    *pcABO;

  if ( FAILED( CreateABO( &pcABO ) ) )
  {
    // Failed to create ABO
    return FALSE;
  }

  bRet = SUCCEEDED( pcABO->DeleteBackup( szBackupName, dwVersion ) );

  CloseABO( pcABO );

  return bRet;
}

CMDValue::CMDValue()
    :
    m_dwId(0),
    m_dwAttributes(0),
    m_dwUserType(0),
    m_dwDataType(0),
    m_cbDataLen(0)
{

}

CMDValue::~CMDValue()
{

}

// function: CMDValue::SetValue
//
// Set the value of the class to what the pointer points to
//
DWORD 
CMDValue::SetValue(DWORD dwId,
                    DWORD dwAttributes,
                    DWORD dwUserType,
                    DWORD dwDataType,
                    DWORD cbDataLen,
                    LPVOID pbData)
{
    if ( cbDataLen > m_bufData.QuerySize() )
    {
        if (!m_bufData.Resize(cbDataLen))
        {
            // Failed to Resize Data
            return FALSE;
        }
    }

    memcpy( m_bufData.QueryPtr(), pbData, cbDataLen );

    m_dwId = dwId;
    m_dwAttributes = dwAttributes;
    m_dwUserType = dwUserType;
    m_dwDataType = dwDataType;
    m_cbDataLen = cbDataLen;

    return TRUE;
}

// function: CMDValue::SetValue
//
// Set the value of the class the value of the string.  So if
// dwDataType is DWORD, we must first convert to DWORD before
// Setting the value
//
DWORD 
CMDValue::SetValue(DWORD dwId,
                    DWORD dwAttributes,
                    DWORD dwUserType,
                    DWORD dwDataType,
                    DWORD cbDataLen,
                    LPTSTR szDataString)
{
    if (dwDataType == DWORD_METADATA)
    {
        DWORD dwValue;

        dwValue = _ttoi(szDataString);

        return SetValue(dwId, dwAttributes, dwUserType, dwDataType, sizeof(DWORD), (LPVOID) &dwValue);
    }

    return SetValue(dwId, dwAttributes, dwUserType, dwDataType, cbDataLen, (LPVOID) szDataString);
}

// function: SetValue
//
// Set the value to a DWORD
//
DWORD 
CMDValue::SetValue(DWORD dwId,
                   DWORD dwAttributes,
                   DWORD dwUserType,
                   DWORD dwValue)
{
  return SetValue( dwId,
                   dwAttributes,
                   dwUserType,
                   DWORD_METADATA,      // Data Type
                   sizeof( DWORD ),     // Size
                   (LPVOID) &dwValue ); // Data
}

BOOL  
CMDValue::IsEqual(DWORD dwDataType, DWORD cbDataLen, LPVOID pbData)
{
    if ( (dwDataType != m_dwDataType) ||
         ( cbDataLen != m_cbDataLen )
         )
    {
        return FALSE;
    }

    return ( memcmp(pbData,m_bufData.QueryPtr(),cbDataLen) == 0 );
}

BOOL  
CMDValue::IsEqual(DWORD dwDataType, DWORD cbDataLen, DWORD dwData)
{
    return IsEqual(dwDataType,cbDataLen,(LPVOID) &dwData);
}

// function: AddNode
//
// Add a node in the metabase
//
HRESULT 
CMDKey::AddNode( LPWSTR szNodeName )
{
  return m_pcCom->AddKey( m_hKey, szNodeName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\metabase.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        metabase.cxx

   Abstract:

        Class that is used to modify the metabase

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       June 2001: Created

--*/

#include "stdafx.h"
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "mdentry.h"
#include "metabase.hxx"
#include "iiscnfg.h"
#include "strfn.h"

// function: GetSizeBasedOnMetaType
//
// Returns the DataSize for an object based on its type
//
DWORD 
CMetaBase::GetSizeBasedOnMetaType(DWORD dwDataType,LPTSTR szString)
{
    DWORD dwRet = 0;

    switch (dwDataType)
    {
        case DWORD_METADATA:
            dwRet = 4;
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            if (szString == NULL)
            {
                dwRet = 0;
            }
            else
            {
                dwRet = (_tcslen((LPTSTR)szString) + 1) * sizeof(TCHAR);
            }
            break;
        case MULTISZ_METADATA:
            if (szString == NULL)
            {
                dwRet = 0;
            }
            else
            {
                dwRet = GetMultiStrSize((LPTSTR)szString) * sizeof(TCHAR);
            }
            break;
        case BINARY_METADATA:
            break;
    }

    return dwRet;
}

// function: FindStringinMultiSz
//
// Finds a string inside of a MultiSz
//
// Parameters:
//   szMultiSz - The MultiSz to search
//   szSearchString - The String to find
//
// Return:
//   True - It was found
//   False - It was not found
BOOL  
CMetaBase::FindStringinMultiSz(LPTSTR szMultiSz, LPTSTR szSearchString)
{
  LPTSTR szSearchCurrent;

  do
  {
    szSearchCurrent = szSearchString;
    while ( ( *szMultiSz != '\0' ) &&
            ( *szSearchCurrent != '\0' ) &&
            ( *szMultiSz == *szSearchCurrent ))
    {
      // While the strings are the same, and they do not hit a null terminator
      szMultiSz++;
      szSearchCurrent++;
    }

    if ( ( *szMultiSz == '\0' ) &&
         ( *szMultiSz == *szSearchCurrent ) 
         )
    {
      // The strings matched
      return TRUE;
    }

    while ( *szMultiSz != '\0' )
    {
      // Go to the end of this string
      szMultiSz++;
    }

    // Step right past the string terminator
    szMultiSz++;
  } while (*szMultiSz);

  return FALSE;
}

// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CMetaBase_SetValue::VerifyParameters(CItemList &ciParams)
{
  if ( ( ( ciParams.GetNumberOfItems() == 7 ) ||
         ( ( ciParams.GetNumberOfItems() == 8 ) && ciParams.IsNumber(7)  )
       )
        &&
       ciParams.IsNumber(1) &&
       ciParams.IsNumber(2) &&
       ciParams.IsNumber(3) &&
       ciParams.IsNumber(4) &&
       ciParams.IsNumber(5)
     )
  {
    return TRUE;
  }

  return FALSE;
}

// funtion: DoInternalWork
//
// Set a value in the metabase
//
// Parameters:
//   ciList - Parameters for OpenNode, they are the following:
//     0 -Location
//     1- Id
//     2- Inheritable
//     3- UserType
//     4- DataType
//     5- Len
//     6- Value
//     7- bDontReplace - Should we replace the value if one already exists?  (default==false)
BOOL
CMetaBase_SetValue::DoInternalWork(CItemList &ciParams)
{
  CMDKey      cmdKey;
  CMDValue    cmdMetaValue;
  DWORD       dwSize = ciParams.GetNumber(5);
  BOOL        bRet = TRUE;

  if ( FAILED(cmdKey.OpenNode(ciParams.GetItem(0) ) ) )
  {
    // Could not open the key, so we fail
    return FALSE;
  }

  if (dwSize == 0)
  {
    dwSize = GetSizeBasedOnMetaType(ciParams.GetNumber(4),ciParams.GetItem(6));
  }

  if ( ( ciParams.GetNumberOfItems() == 8 ) && ( ciParams.GetNumber(7) == 1 ) )
  {
    // Make sure the value does not exist yet, because we don't want to replace the old one
    bRet = !cmdKey.GetData( cmdMetaValue, ciParams.GetNumber(1) );
  }

  if ( bRet )
  {
    // Set the value for this node
    cmdMetaValue.SetValue(ciParams.GetNumber(1),
                          ciParams.GetNumber(2),
                          ciParams.GetNumber(3),
                          ciParams.GetNumber(4),
                          dwSize,
                          (LPTSTR) ciParams.GetItem(6));

    bRet = cmdKey.SetData(cmdMetaValue, ciParams.GetNumber(1));
  }

  cmdKey.Close();

  return bRet;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CMetaBase_SetValue::GetMethodName()
{
  return _T("Metabase_SetValue");
}

// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CMetaBase_DelIDOnEverySite::VerifyParameters(CItemList &ciParams)
{
  if ( ( ciParams.GetNumberOfItems() == 2 ) &&
         ciParams.IsNumber(0) &&
         ciParams.IsNumber(1)
     )
  {
    return TRUE;
  }

  return FALSE;
}

// funtion: DoInternalWork
//
// Set a value in the metabase
//
// Parameters:
//   ciList - Parameters for OpenNode, they are the following:
//     0 - Id
//     1 - Metabase Data Type
BOOL
CMetaBase_DelIDOnEverySite::DoInternalWork(CItemList &ciParams)
{
  CMDKey      cmdKey;
  DWORD       dwId   = ciParams.GetNumber(0);
  DWORD       dwType = ciParams.GetNumber(1);
  BOOL        bRet;
  CStringList cslpathList;
  POSITION    pos;
  CString     csPath;
  WCHAR       wchKeyPath[_MAX_PATH];
  LPWSTR      szwKeyPath = wchKeyPath;
  CString     csBasePath = _T("LM/W3SVC");

  if ( FAILED( cmdKey.OpenNode( csBasePath ) ) )
  {
    // Could not open the key, so we fail
    return FALSE;
  }

  // get datapaths on the specified ID.
  if (FAILED( cmdKey.GetDataPaths( dwId, dwType, cslpathList) ))
  {
    // Could not GetDataPaths for this value
    return FALSE;
  }

  // close it so that we can open the various
  // other nodes that returned and delete the values from them
  cmdKey.Close();

  pos = cslpathList.GetHeadPosition();
  while ( NULL != pos )
  {
    bRet = TRUE;
    csPath = cslpathList.GetNext( pos );
    //iisDebugOut((LOG_TYPE_TRACE,_T("%s"),csPath));

#if defined(UNICODE) || defined(_UNICODE)
    szwKeyPath = csPath.GetBuffer(0);
#else
    if (MultiByteToWideChar(CP_ACP, 0, (LPCSTR)csPath.GetBuffer(0), -1, (LPWSTR)wchKeyPath, _MAX_PATH)==0)
    {
      // We could not convert the string to wide, so lets skip this one
      continue;
    }
#endif

    // make a special case of the "/" path
    if ( wcscmp( szwKeyPath, L"/" ) != 0 )
    {
        //iisDebugOut((LOG_TYPE_TRACE,_T("%s -- del"),csPath));
        CString csNewPath;
        csNewPath = csBasePath + szwKeyPath;

        if ( SUCCEEDED(cmdKey.OpenNode(csNewPath) ) )
        {
            if ( FAILED(cmdKey.DeleteData(dwId, dwType) ) )
            {
                // i guess we don't need to report it..
            }
            cmdKey.Close();
        }

    }
  }

  return bRet;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CMetaBase_DelIDOnEverySite::GetMethodName()
{
  return _T("CMetaBase_DelIDOnEverySite");
}

// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CMetaBase_IsAnotherSiteonPort80::VerifyParameters(CItemList &ciParams)
{
  return ( ciParams.GetNumberOfItems() == 0 );
}

// function: FindSiteUsing80
//
// Find a Site that is using port80
//
// Parameters:
//   cmdKey - The key to the metabase node
//   dwId - The id of the item to find.
//
// Return
//   TRUE - It has been found
//   FALSE - It has not been found
BOOL
CMetaBase_IsAnotherSiteonPort80::SearchMultiSzforPort80(CMDKey &cmdKey, DWORD dwId)
{
  CStringList     cslpathList;
  POSITION        pos;
  CString         csPath;
  CMDValue        cmdValue;
  WCHAR           wchKeyPath[_MAX_PATH];
  LPWSTR          szwKeyPath = wchKeyPath;

  if (FAILED( cmdKey.GetDataPaths( dwId, MULTISZ_METADATA, cslpathList) ))
  {
    // Could not GetDataPaths for this value
    return FALSE;
  }

  pos = cslpathList.GetHeadPosition();

  while ( NULL != pos )
  {
    csPath = cslpathList.GetNext( pos );

#if defined(UNICODE) || defined(_UNICODE)
    szwKeyPath = csPath.GetBuffer(0);
#else
    if (MultiByteToWideChar(CP_ACP, 0, (LPCSTR)csPath.GetBuffer(0), -1, (LPWSTR)wchKeyPath, _MAX_PATH)==0)
    {
      // We could not convert the string to wide, so lets skip this one
      continue;
    }
#endif

    if ( ( wcscmp( szwKeyPath, L"/1/" ) != 0 ) &&
         ( cmdKey.GetData( cmdValue, dwId, szwKeyPath ) )  &&
         ( cmdValue.GetDataType() == MULTISZ_METADATA ) &&
         ( FindStringinMultiSz( (LPTSTR) cmdValue.GetData(), _T(":80:") ) ) 
       ) 
    {
      if ( ( !cmdKey.GetData( cmdValue, MD_SERVER_AUTOSTART, szwKeyPath ) ) ||
           ( !cmdValue.IsEqual( DWORD_METADATA, 4, (DWORD) 0 ) )
         )
      {
        // If GetData failed, or it succedded and the value is not 0, then we
        // have found a match.
        return TRUE;
        break;
      }
    }
  }

  return FALSE;
}

// function: IsAnotherSiteonPort80
//
// Reports back whether another site besides /W3SVC/1 is configured to bind to port 80
// AND has AutoStart set to True
// 
// Parameters 
//   None
//
// Return
//   TRUE - Another site is running on port 80
//   FALSE - No other site is running on port 80
BOOL
CMetaBase_IsAnotherSiteonPort80::DoInternalWork(CItemList &ciList)
{
  BOOL        bRet = FALSE;
  CMDKey      cmdKey;

  if ( FAILED( cmdKey.OpenNode( _T("LM/W3SVC") ) ) )
  {
    // Could not open the w3svc node
    return FALSE;
  }

  if ( SearchMultiSzforPort80( cmdKey, MD_SERVER_BINDINGS) ||
       SearchMultiSzforPort80( cmdKey, MD_SECURE_BINDINGS)
     )
  {
    bRet = TRUE;
  }

  cmdKey.Close();

  return bRet;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CMetaBase_IsAnotherSiteonPort80::GetMethodName()
{
  return _T("Metabase_IsAnotherSiteonPort80");
}


// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CMetaBase_VerifyValue::VerifyParameters(CItemList &ciParams)
{
  if ( ( ciParams.GetNumberOfItems() == 5 ) &&
         ciParams.IsNumber(1) &&
         ciParams.IsNumber(2)
     )
  {
    return TRUE;
  }

  return FALSE;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CMetaBase_VerifyValue::GetMethodName()
{
  return _T("Metabase_VerifyValue");
}

// function: VerifyValue::DoWork
//
// Verify that the value in the particular metabase location, matches the
// value in param[4].  If it does, return true.
// 
// Parameters 
//   0 - Metabase Location
//   1 - Metabase Id
//   2 - Metabase Data Type
//   3 - Data Length = 0 (default value is 0 (must calculate))
//   4 - Metabase Value
//
// Return
//   TRUE - The values match
//   FALSE - The values do not match
BOOL
CMetaBase_VerifyValue::DoInternalWork(CItemList &ciList)
{
  CMDKey      cmdKey;
  CMDValue    cmdValue;
  DWORD       dwSize = ciList.GetNumber(3);
  BOOL        bRet = FALSE;

  if ( FAILED( cmdKey.OpenNode( ciList.GetItem(0) ) ) )
  {
    // Could not open the w3svc node
    return FALSE;
  }

  if (dwSize == 0)
  {
    dwSize = GetSizeBasedOnMetaType(ciList.GetNumber(2),ciList.GetItem(4));
  }

  if ( cmdKey.GetData( cmdValue, ciList.GetNumber(1) ) )
  {
    if ( ( ( ciList.GetNumber(2) == DWORD_METADATA ) &&
           ( cmdValue.IsEqual( ciList.GetNumber(2), dwSize, (DWORD) ciList.GetNumber(4) ) )
         ) ||
         ( ( ciList.GetNumber(2) != DWORD_METADATA ) &&
           ( cmdValue.IsEqual( ciList.GetNumber(2), dwSize, (LPVOID) ciList.GetItem(4) ) )
         ) 
       )
    {
      bRet = TRUE;
    }
  }

  cmdKey.Close();

  return bRet;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CMetaBase_ImportRestrictionList::GetMethodName()
{
  return _T("Metabase_ImportRestrictionList");
}

// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CMetaBase_ImportRestrictionList::VerifyParameters(CItemList &ciParams)
{
  return ( (ciParams.GetNumberOfItems() == 3) &&
           ( ciParams.IsNumber(1) )
         );
}

// function: CreateMultiSzFromList
//
// Create a MultiSz from a List of comman delim items.  So, take
// <deny/allow>,<CGI Executable>,<CGI Executable>,...  (ie. "0","c:\inetpub\scripts\mycgi.exe","c:\inetpub\scripts\pagecount.exe")
// and convert to 
// <0/1>\0<CGI Executable>\0<CGI Executable>\0\0       (ie. 0\0c:\inetpub\scripts\mycgi.exe\0c:\inetpub\scripts\pagecount.exe\0\0)
//
// Parameters:
//   pBuff      [out] - BUFFER class that is used to store the multisz
//   pdwRetSize [out] - The size of the multisz that was created (in Bytes, not chars)
//   szItems    [in]  - List of Items to put in MultiSz
//   cDelimeter [in[  - The delimeter for the list
//
// Return Values
//   TRUE - Successfull
//   FALSE - It failed to construct MultiSz
BOOL 
CMetaBase_ImportRestrictionList::CreateMultiSzFromList(BUFFER *pBuff, DWORD *pdwRetSize, LPTSTR szItems, TCHAR cDelimeter)
{
  LPTSTR  szSource;
  LPTSTR  szDest;
  BOOL    bInQuotes = FALSE;

  // Fail if we don't have a string, or can not get a big enought buffer
  if ( ( !szItems ) ||
       ( !pBuff->Resize( ( _tcslen( szItems ) + 2 )  * sizeof(TCHAR) ) )  // Add 2, one for string term, and one for multisz term
    )
  {
    return FALSE;
  }

  szSource = szItems;
  szDest = (LPTSTR) pBuff->QueryPtr();

  while ( *szSource )
  {
    if ( *szSource == '"' )
    {
      bInQuotes = !bInQuotes;
    }
    else if ( ( *szSource == cDelimeter ) && !bInQuotes )
      {
        if ( ( szDest != pBuff->QueryPtr() ) &&
             ( *(szDest - 1) != '\0')
           )
        {
          *szDest = '\0';
          szDest++;
        }
      }
      else
        {
          *szDest = *szSource;
          szDest++;
        }

    szSource++;
  }

  // Lets make sure that the last string was terminated.
  if ( ( szDest != pBuff->QueryPtr() ) &&
       ( *(szDest - 1) != '\0')
     )
  {
    // Terminate last string
    *szDest = '\0';
    szDest++;
  }

  // Terminate MultiSz, and calc length
  *szDest++ = '\0';
  *pdwRetSize = (DWORD) (DWORD_PTR) (((LPBYTE) szDest) - ((LPBYTE) pBuff->QueryPtr()));

  return TRUE;
}

BOOL 
CMetaBase_ImportRestrictionList::ExpandEnvVar(BUFFER *pBuff)
{
  BUFFER buffOriginal;
  DWORD  dwLength;

  if ( _tcsstr( (LPTSTR) pBuff->QueryPtr(), _T("%") ) == NULL )
  {
    // There are no environment variables, so we can return
    return TRUE;
  }

  if ( !buffOriginal.Resize( pBuff->QuerySize() ) )
  {
    // Could not resize oringal big enough
    return FALSE;
  }
  memcpy(buffOriginal.QueryPtr(), pBuff->QueryPtr(), pBuff->QuerySize());

  dwLength = ExpandEnvironmentStrings( (LPTSTR) buffOriginal.QueryPtr(), NULL, 0);

  if ( ( dwLength == 0 ) ||
       ( !pBuff->Resize( dwLength * sizeof(TCHAR) ) )
     )
  {
    // Something failed in ExpandEnvironmentStrings
    return FALSE;
  }

  dwLength = ExpandEnvironmentStrings( (LPTSTR) buffOriginal.QueryPtr(), (LPTSTR) pBuff->QueryPtr() , pBuff->QuerySize() );

  if ( (dwLength != 0) && (dwLength <= pBuff->QuerySize() ) )
  {
    // It worked
    return TRUE;
  }

  return FALSE;
}

// function: DoInternalWork
//
// Import the RestrictionList
//
// Parameters:
//   0 - The name of the item in the inf
//   1 - The id
//   2 - The Default value (MultiSz with ';' as seperator)
//
BOOL
CMetaBase_ImportRestrictionList::DoInternalWork(CItemList &ciParams)
{
  CMDKey      cmdKey;
  CMDValue    cmdMetaValue;
  BUFFER      buffImportList;
  DWORD       dwImportList;
  LPTSTR      szList = NULL;
  INFCONTEXT  Context;
  BOOL        bRet = FALSE;
  BOOL        bForceSetting = FALSE;

  if (g_pTheApp->m_fUnattended)
  {
    // If unattended, then look in unattend file for correct line
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, UNATTEND_FILE_SECTION, ciParams.GetItem(0), &Context) ) 
    {
      DWORD dwRequiredSize = 0;
      BUFFER buffUnattend;
      BUFFER buffUnattendExpanded;

      if ( SetupGetLineText( &Context, INVALID_HANDLE_VALUE, NULL, NULL, NULL, 0, &dwRequiredSize) )
      {
        if ( ( buffUnattend.Resize( ( dwRequiredSize + 1 ) * sizeof(TCHAR) ) ) &&
             ( SetupGetLineText( &Context, INVALID_HANDLE_VALUE, NULL, NULL, (LPTSTR) buffUnattend.QueryPtr(), buffUnattend.QuerySize()/sizeof(TCHAR), NULL) ) &&
             ( ExpandEnvVar( &buffUnattend ) ) &&
             ( CreateMultiSzFromList( &buffImportList, &dwImportList, (LPTSTR) buffUnattend.QueryPtr(), RESTRICTIONLIST_DELIMITER ) )
           )
        {
          szList = (LPTSTR) buffImportList.QueryPtr();
          bForceSetting = TRUE;
        }
      }
    }
  }

  if ( !szList )
  {
    // If it could not be retrieved, set it to the default.
    if ( ( buffImportList.Resize(( _tcslen( ciParams.GetItem(2) ) + 2 )  * sizeof(TCHAR) ) ) && 
         ( CreateMultiSzFromList( &buffImportList, &dwImportList, ciParams.GetItem(2), RESTRICTIONLIST_DELIMITER) )
       )
    {
      szList = (LPTSTR) buffImportList.QueryPtr();
    }
  }

  if ( szList == NULL )
  {
    return FALSE;
  }

  // Set Value
  if ( FAILED(cmdKey.OpenNode( _T("LM/W3SVC") ) ) )
  {
    // Could not open the key, so we fail
    return FALSE;
  }

  if ( bForceSetting ||
       !cmdKey.GetData(cmdMetaValue, ciParams.GetNumber(1) )
     )
  {
    // Set the value for this node
    if ( cmdMetaValue.SetValue( ciParams.GetNumber(1),      // ID
                                0x0,                        // Attributes (Not inheritable)
                                IIS_MD_UT_SERVER,           // UType
                                MULTISZ_METADATA,           // DType
                                dwImportList,               // Size
                                (LPTSTR) szList)
       )
    {
      bRet = cmdKey.SetData(cmdMetaValue, ciParams.GetNumber(1));
    }
  }

  cmdKey.Close();

  return bRet;
}

// function: GetMethodName
//
// Return the Method Name for this Class
//
LPTSTR
CMetaBase_UpdateCustomDescList::GetMethodName()
{
  return _T("Metabase_UpdateCustomDescList");
}

// function: VerifyParameters
//
// Verify the parameters are correct
//
BOOL
CMetaBase_UpdateCustomDescList::VerifyParameters(CItemList &ciParams)
{
  return ( (ciParams.GetNumberOfItems() == 3) &&
           ( ciParams.IsNumber(1) )
         );
}

// function: CreateMultiSzFromList
//
// Create a MultiSz from a List of comman delim items.  So, take
// <deleteable/not deleteable>,<description>,<filepath>,...  (ie. "1","asp scripts","c:\winnt\system32\inetsrv\asp.dll")
// and convert to 
// <0/1>\0<description>\0<filepath>\0\0       (ie. 1\0asp scripts\0c:\winnt\system32\inetsrv\asp.dll\0\0)
//
// Parameters:
//   pBuff      [out] - BUFFER class that is used to store the multisz
//   pdwRetSize [out] - The size of the multisz that was created (in Bytes, not chars)
//   szItems    [in]  - List of Items to put in MultiSz
//   cDelimeter [in[  - The delimeter for the list
//
// Return Values
//   TRUE - Successfull
//   FALSE - It failed to construct MultiSz
BOOL 
CMetaBase_UpdateCustomDescList::CreateMultiSzFromList(BUFFER *pBuff, DWORD *pdwRetSize, LPTSTR szItems, TCHAR cDelimeter)
{
  LPTSTR  szSource;
  LPTSTR  szDest;
  BOOL    bInQuotes = FALSE;

  // Fail if we don't have a string, or can not get a big enought buffer
  if ( ( !szItems ) ||
       ( !pBuff->Resize( ( _tcslen( szItems ) + 2 )  * sizeof(TCHAR) ) )  // Add 2, one for string term, and one for multisz term
    )
  {
    return FALSE;
  }

  szSource = szItems;
  szDest = (LPTSTR) pBuff->QueryPtr();

  while ( *szSource )
  {
    if ( *szSource == '"' )
    {
      bInQuotes = !bInQuotes;
    }
    else if ( ( *szSource == cDelimeter ) && !bInQuotes )
      {
        if ( ( szDest != pBuff->QueryPtr() ) &&
             ( *(szDest - 1) != '\0')
           )
        {
          *szDest = '\0';
          szDest++;
        }
      }
      else
        {
          *szDest = *szSource;
          szDest++;
        }

    szSource++;
  }

  // Lets make sure that the last string was terminated.
  if ( ( szDest != pBuff->QueryPtr() ) &&
       ( *(szDest - 1) != '\0')
     )
  {
    // Terminate last string
    *szDest = '\0';
    szDest++;
  }

  // Terminate MultiSz, and calc length
  *szDest++ = '\0';
  *pdwRetSize = (DWORD) (DWORD_PTR) (((LPBYTE) szDest) - ((LPBYTE) pBuff->QueryPtr()));

  return TRUE;
}

BOOL 
CMetaBase_UpdateCustomDescList::ExpandEnvVar(BUFFER *pBuff)
{
  BUFFER buffOriginal;
  DWORD  dwLength;

  if ( _tcsstr( (LPTSTR) pBuff->QueryPtr(), _T("%") ) == NULL )
  {
    // There are no environment variables, so we can return
    return TRUE;
  }

  if ( !buffOriginal.Resize( pBuff->QuerySize() ) )
  {
    // Could not resize oringal big enough
    return FALSE;
  }
  memcpy(buffOriginal.QueryPtr(), pBuff->QueryPtr(), pBuff->QuerySize());

  dwLength = ExpandEnvironmentStrings( (LPTSTR) buffOriginal.QueryPtr(), NULL, 0);

  if ( ( dwLength == 0 ) ||
       ( !pBuff->Resize( dwLength * sizeof(TCHAR) ) )
     )
  {
    // Something failed in ExpandEnvironmentStrings
    return FALSE;
  }

  dwLength = ExpandEnvironmentStrings( (LPTSTR) buffOriginal.QueryPtr(), (LPTSTR) pBuff->QueryPtr() , pBuff->QuerySize()/sizeof(TCHAR) );

  if ( (dwLength != 0) && 
       (dwLength <= ( pBuff->QuerySize()/sizeof(TCHAR) ) ) )
  {
    // It worked
    return TRUE;
  }

  return FALSE;
}

// function: DoInternalWork
//
// Import the RestrictionList
//
// Parameters:
//   0 - The name of the item in the inf
//   1 - The id
//   2 - The Default value (MultiSz with ';' as seperator)
//
BOOL
CMetaBase_UpdateCustomDescList::DoInternalWork(CItemList &ciParams)
{
  CMDKey      cmdKey;
  CMDValue    cmdMetaValue;
  BUFFER      buffMyList;
  DWORD       dwMyList;
  LPTSTR      szList = NULL;
  INFCONTEXT  Context;
  BOOL        bRet = FALSE;
  BOOL        bForceSetting = FALSE;

  if (g_pTheApp->m_fUnattended)
  {
    // If unattended, then look in unattend file for correct line
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, UNATTEND_FILE_SECTION, ciParams.GetItem(0), &Context) ) 
    {
      DWORD dwRequiredSize = 0;
      BUFFER buffUnattend;
      BUFFER buffUnattendExpanded;

      if ( SetupGetLineText( &Context, INVALID_HANDLE_VALUE, NULL, NULL, NULL, 0, &dwRequiredSize) )
      {
        if ( ( buffUnattend.Resize( ( dwRequiredSize + 1 ) * sizeof(TCHAR) ) ) &&
             ( SetupGetLineText( &Context, INVALID_HANDLE_VALUE, NULL, NULL, (LPTSTR) buffUnattend.QueryPtr(), buffUnattend.QuerySize()/sizeof(TCHAR), NULL) ) &&
             ( ExpandEnvVar( &buffUnattend ) ) &&
             ( CreateMultiSzFromList( &buffMyList, &dwMyList, (LPTSTR) buffUnattend.QueryPtr(), CUSTOMDESCLIST_DELIMITER ) )
           )
        {
          szList = (LPTSTR) buffMyList.QueryPtr();
          bForceSetting = TRUE;
        }
      }
    }
  }

  if ( !szList )
  {
    // If it could not be retrieved, set it to the default.
    if ( ( buffMyList.Resize(( _tcslen( ciParams.GetItem(2) ) + 2 )  * sizeof(TCHAR) ) ) && 
         ( CreateMultiSzFromList( &buffMyList, &dwMyList, ciParams.GetItem(2), CUSTOMDESCLIST_DELIMITER) )
       )
    {
      szList = (LPTSTR) buffMyList.QueryPtr();
    }
  }

  if ( szList == NULL )
  {
    return FALSE;
  }

  // Set Value
  if ( FAILED(cmdKey.OpenNode( _T("LM/W3SVC") ) ) )
  {
    // Could not open the key, so we fail
    return FALSE;
  }

  // See if there is an existing value...
  // if there is then update the value with this one...
  // otherwise set it.

  CStringList cslMyNewAdditions;
  if (ERROR_SUCCESS != ConvertDoubleNullListToStringList(szList,cslMyNewAdditions,-1))
  {
    bForceSetting = TRUE;
  }
   
  // get the data
  DWORD dwAttributes = 0;
  DWORD dwMDDataType = MULTISZ_METADATA;
  CStringList cslMyOriginalList;
  if (bForceSetting || FAILED(cmdKey.GetMultiSzAsStringList(ciParams.GetNumber(1),&dwMDDataType,&dwAttributes,cslMyOriginalList)))
  {
    // do a fresh entry...
    // Set the value for this node
    if ( cmdMetaValue.SetValue(ciParams.GetNumber(1),     // ID
                              0x0,                        // Attributes (Not inheritable)
                              IIS_MD_UT_SERVER,           // UType
                              MULTISZ_METADATA,           // DType
                              dwMyList,               // Size
                              (LPTSTR) szList)
     )
    {
      bRet = cmdKey.SetData(cmdMetaValue, ciParams.GetNumber(1));
    }

  }
  else
  {
    // able to get it...so let's update it.
    // loop thru it and see if our entry is already in it...
    CString csNewEntryPart1;
    CString csNewEntryPart2;
    CString csNewEntryPart3;
    CString csExistingFilePath;
    BOOL bItsInTheListAlready = FALSE;
    BOOL bSomethingChanged = FALSE;

    POSITION pos = cslMyNewAdditions.GetHeadPosition();
    POSITION pos2 = NULL;
    while (pos)
    {
      bItsInTheListAlready = FALSE;

      // get the next value
      csNewEntryPart1 = cslMyNewAdditions.GetNext(pos);
      if (!pos){break;}
      csNewEntryPart2 = cslMyNewAdditions.GetNext(pos);
      if (!pos){break;}
      csNewEntryPart3 = cslMyNewAdditions.GetNext(pos);

      // see if this value is in our list...
      pos2 = cslMyOriginalList.GetHeadPosition();
      while (pos2)
      {
        // get the next value
        cslMyOriginalList.GetNext(pos2);
        if (!pos2){break;}
        csExistingFilePath = cslMyOriginalList.GetNext(pos2);
        if (!pos2){break;}

        // compare with other value 
        //iisDebugOut((LOG_TYPE_TRACE,_T("UpdateCustomDescList:%s,%s"),csNewEntryPart2,csExistingFilePath));
        if (0 == _tcsicmp(csNewEntryPart2,csExistingFilePath))
        {
          // it's found in there!
          bItsInTheListAlready = TRUE;
          break;
        }
        cslMyOriginalList.GetNext(pos2);
      }

      if (FALSE == bItsInTheListAlready)
      {
        // Add it to the end of the list
        cslMyOriginalList.AddTail(csNewEntryPart1);
        cslMyOriginalList.AddTail(csNewEntryPart2);
        cslMyOriginalList.AddTail(csNewEntryPart3);
        bSomethingChanged = TRUE;
      }
    }

    if (TRUE == bSomethingChanged)
    {
      bRet = FALSE;
      if (ERROR_SUCCESS == cmdKey.SetMultiSzAsStringList(ciParams.GetNumber(1),MULTISZ_METADATA,0x0,cslMyOriginalList))
      {
        bRet = TRUE;
      }
    }
  }

  cmdKey.Close();
  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\mdkey.h ===
#ifndef _MDKEY_H_
#define _MDKEY_H_


class CMDValue
{
protected:
    DWORD m_dwId;
    DWORD m_dwAttributes;
    DWORD m_dwUserType;
    DWORD m_dwDataType;
    DWORD m_cbDataLen;
    BUFFER m_bufData;

public:
    CMDValue();
    ~CMDValue();
    DWORD SetValue(DWORD dwId,
                    DWORD dwAttributes,
                    DWORD dwUserType,
                    DWORD dwDataType,
                    DWORD dwDataLen,
                    LPVOID pbData);
    DWORD SetValue(DWORD dwId,
                    DWORD dwAttributes,
                    DWORD dwUserType,
                    DWORD dwDataType,
                    DWORD dwDataLen,
                    LPTSTR szDataString);
    DWORD SetValue(DWORD dwId,
                   DWORD dwAttributes,
                   DWORD dwUserType,
                   DWORD dwValue);

    DWORD GetId()                       { return m_dwId; }
    DWORD GetAttributes()               { return m_dwAttributes; }
    DWORD GetUserType()                 { return m_dwUserType; }
    DWORD GetDataType()                 { return m_dwDataType; }
    DWORD GetDataLen()                  { return m_cbDataLen; }
    PVOID GetData()                     { return m_bufData.QueryPtr(); }
    void  SetAttributes(DWORD dwAttrib) { m_dwAttributes = dwAttrib; }
    BOOL  IsEqual(DWORD dwDataType, DWORD cbDataLen, LPVOID pbData);
    BOOL  IsEqual(DWORD dwDataType, DWORD cbDataLen, DWORD dwData);
                    
};

class CMDKey : public CObject
{
protected:
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    LPTSTR pszFailedAPI;

public:
    CMDKey();
    ~CMDKey();

    TCHAR  m_szCurrentNodeName[_MAX_PATH];

    // allow CMDKey to be used where type METADATA_HANDLE is required
    operator METADATA_HANDLE () {return m_hKey;}
    METADATA_HANDLE GetMDKeyHandle() {return m_hKey;}
    IMSAdminBase *GetMDKeyICOM() {return m_pcCom;}

    // open an existing MD key
    HRESULT OpenNode(LPCTSTR pchSubKeyPath, BOOL bSupressErrorMessage = FALSE);
    // to open an existing MD key, or create one if doesn't exist
    HRESULT CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath);
    // close node opened/created by OpenNode() or CreateNode()
    HRESULT Close();

    // Add a node
    HRESULT AddNode( LPWSTR szNodeName );

    HRESULT ForceWriteMetabaseToDisk();
    
    HRESULT DeleteNode(LPCTSTR pchSubKeyPath);

    BOOL IsEmpty( PWCHAR pszSubString = L"" );
    int GetNumberOfSubKeys( PWCHAR pszSubString = L"" );

    // get all the sub keys that have a certain property on them and return the
    // sub-paths in a cstring list object. The cstring list should be instantiated
    // by the caller and deleted by the same.
    HRESULT GetDataPaths( 
        DWORD dwMDIdentifier,
        DWORD dwMDDataType,
        CStringList& szPathList,
        PWCHAR pszSubString = L"" );

    HRESULT GetMultiSzAsStringList (
        DWORD dwMDIdentifier,
        DWORD *uType,
        DWORD *attributes,
        CStringList& szStrList,
        LPCWSTR pszSubString = L"" );

    HRESULT SetMultiSzAsStringList (
        DWORD dwMDIdentifier,
        DWORD uType,
        DWORD attributes,
        CStringList& szStrList,
        PWCHAR pszSubString = L"" );


    HRESULT GetStringAsCString (
        DWORD dwMDIdentifier,
        DWORD uType,
        DWORD attributes,
        CString& szStrList,
        PWCHAR pszSubString = L"",
        int iStringType = 0);

    HRESULT SetCStringAsString (
        DWORD dwMDIdentifier,
        DWORD uType,
        DWORD attributes,
        CString& szStrList,
        PWCHAR pszSubString = L"",
        int iStringType = 0);

    HRESULT GetDword(
        DWORD dwMDIdentifier,
        DWORD uType,
        DWORD attributes,
        DWORD& MyDword,
        PWCHAR pszSubString = L"");

    HRESULT SetData(
        DWORD id,
        DWORD attr,
        DWORD uType,
        DWORD dType,
        DWORD cbLen,
        LPBYTE pbData,
        PWCHAR pszSubString = L"" );

    BOOL GetData(DWORD id,
        DWORD *pdwAttr,
        DWORD *pdwUType,
        DWORD *pdwDType,
        DWORD *pcbLen,
        LPBYTE pbData,
        DWORD BufSize,
        LPCWSTR pszSubString = L"" );

    BOOL GetData(DWORD id,
        DWORD *pdwAttr,
        DWORD *pdwUType,
        DWORD *pdwDType,
        DWORD *pcbLen,
        LPBYTE pbData,
        DWORD BufSize,
        DWORD  dwAttributes,
        DWORD  dwUType,
        DWORD  dwDType,
        LPCWSTR pszSubString = L"" );

    BOOL EnumKeys( LPWSTR pchMDName, 
        DWORD dwIndex, 
        LPTSTR pszSubKeyPath = _T("") );

    HRESULT DeleteData(DWORD id, DWORD dType, PWCHAR pszSubString = L"" );

    HRESULT RenameNode(LPCTSTR pszMDPath,LPCTSTR pszMDNewName);

    BOOL GetData(CMDValue &Value,
                DWORD id,
                LPCWSTR pszSubString = L"" );

    BOOL SetData(CMDValue &Value,
                DWORD id,
                PWCHAR pszSubString = L"" );

    static BOOL Backup( LPWSTR szBackupName,
                        DWORD  dwVersion,
                        DWORD  dwFlags );

    static BOOL DeleteBackup( LPWSTR szBackupName,
                              DWORD  dwVersion = MD_BACKUP_HIGHEST_VERSION );
private:

    HRESULT DoCoInitEx();
    void DoCoUnInit();
    static HRESULT CreateABO( IMSAdminBase **ppcABO );
    static void    CloseABO( IMSAdminBase *pcABO );

    // a count of the calls to coinit
    INT m_cCoInits;
};

class CMDKeyIter : public CObject
{
protected:
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    LPWSTR m_pBuffer;
    DWORD m_dwBuffer;

public:
    CMDKeyIter(CMDKey &cmdKey);
    ~CMDKeyIter();

    LONG Next(CString *pcsName, PWCHAR pwcsSubString = L"");

    void Reset() {m_index = 0;}


    DWORD m_index;
};

#endif // _MDKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\mdentry.h ===
#ifndef _MDENTRY_H_
#define _MDENTRY_H_

#define METABASE_USE_DEFAULT      0xFFFFFFFF

class CDWord : public CObject
{
protected:
    DWORD m_dwData;

public:
    CDWord(DWORD dwData) { m_dwData = dwData; }
    ~CDWord() {};

    operator DWORD () { return m_dwData; }
};

// fMigrate, fKeepOldReg, hRegRootKey, szRegSubKey, szRegValueName, 
// szMDPath, dwMDId, dwMDAttr, dwMDuType, dwMDdType, dwMDDataLen, szMDData 

typedef struct _MDEntry {
    LPTSTR szMDPath;
    DWORD dwMDIdentifier;
    DWORD dwMDAttributes;
    DWORD dwMDUserType;
    DWORD dwMDDataType;
    DWORD dwMDDataLen;
    LPBYTE pbMDData;
} MDEntry;

DWORD atodw(LPCTSTR lpszData);
BOOL SplitLine(LPTSTR szLine, INT iExpectedNumOfFields);
INT  GetMDEntryFromInfLine(LPTSTR szLine, MDEntry *pMDEntry);
int  WWW_Upgrade_RegToMetabase(HINF hInf);
int  FTP_Upgrade_RegToMetabase(HINF hInf);
void CreateWWWVRMap(CMapStringToOb *pMap);
void CreateFTPVRMap(CMapStringToOb *pMap);
void EmptyMap(CMapStringToOb *pMap);
void AddVRootsToMD(LPCTSTR szSvcName);
void AddVRMapToMD(LPCTSTR szSvcName, CMapStringToOb *pMap);
int  GetPortNum(LPCTSTR szSvcName);
void ApplyGlobalToMDVRootTree(CString csKeyPath, CMapStringToString *pGlobalObj);

void AddMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP, UINT nProgressBarTextWebInstance);
void CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP);
void SplitVRString(CString csValue, LPTSTR szPath, LPTSTR szUserName, DWORD *pdwPerm);
UINT GetInstNumber(LPCTSTR szMDPath, UINT i);
int  MigrateInfSectionToMD(HINF hInf, LPCTSTR szSection);

BOOL CreateMimeMapFromRegistry(CMapStringToString *pMap);
BOOL CreateMimeMapFromInfSection(CMapStringToString *pMap, HINF hFile, LPCTSTR szSection);
void ReadMimeMapFromInfSection(CMapStringToString *pMap, HINF hFile, LPCTSTR szSection, BOOL fAction);

void SetLogPlugInOrder(LPCTSTR lpszSvc);

DWORD GetSizeBasedOnMetaType(DWORD dwDataType,LPTSTR szString);
BOOL MDEntry_MoveValue(LPTSTR szLine);

void ReadMultiSZFromInfSection(CString *pcsMultiSZ, HINF hFile, LPCTSTR szSection);
void ReadMimeMapFromMetabase(CMapStringToString *pMap);
void IntegrateNewErrorsOnUpgrade( IN HINF hFile, IN LPCTSTR szSection );

BOOL ConfirmLocalHost(LPCTSTR lpszVirtServer);
void RemoveCannotDeleteVR( LPCTSTR pszService );

void UpdateVDCustomErrors();
DWORD UpgradeCryptoKeys(void);

DWORD SetMDEntry(MDEntry *pMDEntry);
DWORD SetMDEntry_NoOverWrite(MDEntry *pMDEntry);
DWORD SetMDEntry_Wrap(MDEntry *pMDEntry);

void  UpgradeFilters(CString csTheSection);
DWORD VerifyMD_Filters_WWW(TSTR &strTheSection);
DWORD WriteToMD_Filters_WWW(TSTR &strTheSection);
DWORD WriteToMD_Filters_List_Entry(CString csOrder);

DWORD WriteToMD_Filter_Entry(CString csFilter_Name, CString csFilter_Path);

BOOL VerifyMD_InProcessISAPIApps_WWW(IN LPCTSTR szSection);
DWORD WriteToMD_InProcessISAPIApps_WWW(IN LPCTSTR szSection);
DWORD WriteToMD_ISAPI_Entry( TSTR_MSZ &mstrInprocIsapiList );


DWORD WriteToMD_NTAuthenticationProviders_WWW(void);
DWORD VerifyMD_NTAuthenticationProviders_WWW(void);
DWORD WriteToMD_NTAuthenticationProviders_WWW(CString);
DWORD WriteToMD_Capabilities(LPCTSTR lpszSvc);

UINT  AddVirtualServer( LPCTSTR szSvcName, UINT i, CMapStringToString *pObj, CString& csRoot, CString& csIP);
void  CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP, UINT nProgressBarTextWebInstance);
int   VerifyVRoots(LPCTSTR szSvcName);
DWORD WriteToMD_CertMapper(CString csKeyPath);
DWORD WriteToMD_AdminInstance(CString csKeyPath,CString& csInstNumber);
DWORD WriteToMD_Authorization(CString csKeyPath, DWORD dwValue);
DWORD WriteToMD_IIsWebServerInstance_WWW(CString csKeyPath);
DWORD WriteToMD_NotDeleteAble(CString csKeyPath);
DWORD WriteToMD_ServerSize(CString csKeyPath);
DWORD WriteToMD_ServerComment(CString csKeyPath, UINT iCommentID);
DWORD WriteToMD_ServerBindings_HTMLA(CString csKeyPath, UINT iPort);
DWORD HandleSecurityTemplates(LPCTSTR szSvcName);
DWORD WriteToMD_IPsec_GrantByDefault(CString csKeyPath);
DWORD WriteToMD_HttpExpires(CString csData);
DWORD WriteToMD_AnonymousOnly_FTP(CString csKeyPath);
DWORD WriteToMD_AllowAnonymous_FTP(CString csKeyPath);

DWORD WriteToMD_AnonymousUserName_FTP(int iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere);
DWORD WriteToMD_AnonymousUserName_WWW(int iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere);

int   AddRequiredISAPI(CStringArray& arrayName,CStringArray& arrayPath,IN LPCTSTR szSection);

BOOL  ChkMdEntry_Exist(MDEntry *pMDEntry);
DWORD WriteToMD_IWamUserName_WWW(void);
DWORD WriteToMD_CustomError_Entry(CString csKeyPath, CString csCustomErrorDelimitedList);
BOOL  VerifyCustomErrors_WWW(CString csKeyPath);
void  MoveOldHelpFilesToNewLocation(void);
DWORD DeleteMDEntry(MDEntry *pMDEntry);
void  WriteToMD_ForceMetabaseToWriteToDisk(void);
void  VerifyMD_DefaultLoadFile_WWW(IN LPCTSTR szSection, CString csKeyPath);
INT Register_iis_www_handleScriptMap(void);
DWORD DoesAdminACLExist(CString csKeyPath);

int ReOrderFiltersSpecial(int nArrayItems, CStringArray& arrayName, CString& csOrder);
void AddFilter1ToFirstPosition(CString& csOrder,LPTSTR szFilter1);
void AddFilter1AfterFilter2(CString& csOrder,LPTSTR szFilter1,LPTSTR szFilter2);
void GetScriptMapListFromClean(ScriptMapNode *pList, IN LPCTSTR szSection);
int RemoveMetabaseFilter(TCHAR * szFilterName, int iRemoveMetabaseNodes);

DWORD WriteToMD_IDRegistration(CString csKeyPath);
DWORD WriteToMD_AspCodepage(CString csKeyPath, DWORD dwValue, int iOverWriteAlways);
DWORD WriteToMD_HttpCustom(CString csKeyPath, CString csData, int iOverWriteAlways);
DWORD WriteToMD_EnableParentPaths_WWW(CString csKeyPath, BOOL bEnableFlag);

void  EnforceMaxConnections(void);
DWORD WriteToMD_DwordEntry(CString csKeyPath,DWORD dwID,DWORD dwAttrib,DWORD dwUserType,DWORD dwTheData,INT iOverwriteFlag);
int RemoveIncompatibleMetabaseFilters(LPTSTR szSectionName,int iRemoveMetabaseNodes);

DWORD WriteToMD_RootKeyType(void);
DWORD MDDumpAdminACL(CString csKeyPath);

int DoesAppIsolatedExist(CString csKeyPath);
HRESULT WINAPI Add_WWW_VDirW(WCHAR * pwszMetabasePath, WCHAR * pwszVDirName,WCHAR * pwszPhysicalPath, DWORD dwPermissions, DWORD iApplicationType);
HRESULT WINAPI Add_WWW_VDirA(CHAR * pwszMetabasePath, CHAR * pwszVDirName,CHAR * pwszPhysicalPath, DWORD dwPermissions, DWORD iApplicationType);
HRESULT WINAPI Remove_WWW_VDirW(WCHAR * pwszMetabasePath, WCHAR * pwszVDirName);
HRESULT WINAPI Remove_WWW_VDirA(CHAR * pwszMetabasePath, CHAR * pwszVDirName);
HRESULT AddVirtualDir(IMSAdminBase *pIMSAdminBase,WCHAR * pwszMetabasePath,WCHAR * pwszVDir,WCHAR * pwszPhysicalPath, DWORD dwPermissions, INT iApplicationType);
HRESULT RemoveVirtualDir(IMSAdminBase *pIMSAdminBase,WCHAR * wszMetabaseKey,WCHAR * wszVDir);

#endif // _MDENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\mdentry.cpp ===
#include "stdafx.h"

#include <ole2.h>
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "lsaKeys.h"

#undef MAX_SERVICE_NAME_LEN
#include "elem.h"
#include "mdentry.h"
#include "mdacl.h"
#include "inetinfo.h"
#include <iis64.h>

#include "inetcom.h"
#include "logtype.h"
#include "ilogobj.hxx"
#include "log.h"
#include "sslkeys.h"
#include "massupdt.h"
#include "strfn.h"
#include "svc.h"
#include "setpass.h"
#include "dcomperm.h"
#include "wolfpack.h"
#include "parse.hxx"

#define MAX_FIELDS  12
#define FIELD_SEPERATOR   _T("\t")

#define MDENTRY_FROMINFFILE_FAILED  0
#define MDENTRY_FROMINFFILE_DO_ADD  1
#define MDENTRY_FROMINFFILE_DO_DEL  2
#define MDENTRY_FROMINFFILE_DO_NOTHING  3

MDEntry s_gMetabaseTypes[] = {
  // Path   Type Identifies   Attributes    User Type             Data Type               Len   Default Value
  { NULL,   MD_KEY_TYPE,      0,            IIS_MD_UT_SERVER,     STRING_METADATA,        0,    NULL }
};

// These must be global because that's how they passed around
LPTSTR g_field[MAX_FIELDS];
LPBYTE g_pbData = NULL;

int g_CheckIfMetabaseValueWasWritten = FALSE;

// function: GetDefaultAttributes
//
// Get the default attributes for a given property.  This is so that
// we do not have to set the usertype, and attributes everytime we
// want to create a property
//
// Parameters:
//   dwID     [in]  - The id of the property
//   sMDEntry [out] - The structure filled with the right parameters
//
// Return:
//   TRUE - Succeeded
//   FALSE - Failed to find defaults
BOOL
GetDefaultAttributes(DWORD dwId, MDEntry *pMdEntry)
{
  DWORD   dwCurrent = 0;
  DWORD   dwMax = sizeof(s_gMetabaseTypes)/sizeof(s_gMetabaseTypes[0]);
  BOOL    bFound = FALSE;
  MDEntry *pCurrentEntry;

  // Initialize it to start
  pMdEntry->szMDPath = NULL;
  pMdEntry->dwMDIdentifier = dwId;
  pMdEntry->dwMDAttributes = METABASE_USE_DEFAULT;
  pMdEntry->dwMDUserType = METABASE_USE_DEFAULT;
  pMdEntry->dwMDDataType = METABASE_USE_DEFAULT;
  pMdEntry->dwMDDataLen = 0;
  pMdEntry->pbMDData = NULL;

  while ( dwCurrent < dwMax )
  {
    pCurrentEntry = &( s_gMetabaseTypes[dwCurrent] );

    if ( pCurrentEntry->dwMDIdentifier == dwId )
    {
      pMdEntry->szMDPath          = pCurrentEntry->szMDPath;
      pMdEntry->dwMDAttributes    = pCurrentEntry->dwMDAttributes;
      pMdEntry->dwMDUserType      = pCurrentEntry->dwMDUserType;
      pMdEntry->dwMDDataType      = pCurrentEntry->dwMDDataType;
      pMdEntry->dwMDDataLen       = pCurrentEntry->dwMDDataLen;
      pMdEntry->pbMDData          = pCurrentEntry->pbMDData;
      break;
    }

    dwCurrent++;
  }

  ASSERT(bFound);

  return bFound;
}

// function: WriteDefaultValue
//
// Write a default value to the metabase.  This means that if it already exists
// we will NOT overite it.
//
// Parameters:
//   szPath - The path where it will be set
//   dwID - The ID of the property
//   szValue - The value
//   dwAttributes - The attributes, if not specified, the default is taken
//   dwUserType - The user type, if not specified, the default is taken
//   dwDataType - The data type, if not specified, the default is taken
//
// Return Value
//   TRUE - Successfully set
//   FALSE - Failed to set value
//
BOOL
WriteDefaultValue(LPTSTR szPath,
                            DWORD dwId,
                            LPTSTR szValue,
                            DWORD dwAttributes = METABASE_USE_DEFAULT,
                            DWORD dwUserType = METABASE_USE_DEFAULT,
                            DWORD dwDataType = METABASE_USE_DEFAULT)
{
  CMDKey    cmdKey;
  MDEntry   mdEntry;

  // Load defaults from table
  if ( !GetDefaultAttributes( dwId, &mdEntry ) )
  {
    return FALSE;
  }

  mdEntry.szMDPath = szPath;

  if ( szValue != NULL )
  {
    mdEntry.dwMDDataLen = ( _tcslen( szValue ) + 1 ) * sizeof(TCHAR);
    mdEntry.pbMDData = (LPBYTE) szValue;
  }

  if ( dwAttributes != METABASE_USE_DEFAULT )
  {
    mdEntry.dwMDAttributes = dwAttributes;
  }

  if ( dwUserType != METABASE_USE_DEFAULT )
  {
    mdEntry.dwMDUserType = dwUserType;
  }

  if ( dwDataType != METABASE_USE_DEFAULT )
  {
    mdEntry.dwMDUserType = dwDataType;
  }

  // Check and make sure all the fields are valid
  ASSERT( mdEntry.szMDPath != NULL);
  ASSERT( mdEntry.dwMDDataLen != 0 );
  ASSERT( mdEntry.pbMDData != NULL );
  ASSERT( mdEntry.dwMDAttributes != METABASE_USE_DEFAULT );
  ASSERT( mdEntry.dwMDUserType != METABASE_USE_DEFAULT );
  ASSERT( mdEntry .dwMDUserType != METABASE_USE_DEFAULT );

  return SetMDEntry_Wrap( &mdEntry );
}

HRESULT WINAPI Add_WWW_VDirA(CHAR * pszMetabasePath, CHAR * pszVDirName, CHAR * pszPhysicalPath, DWORD dwPermissions, DWORD iApplicationType)
{
    HRESULT hr = ERROR_BAD_PATHNAME;
    WCHAR wszMetabasePath[_MAX_PATH];
    WCHAR wszVDirName[_MAX_PATH];
    WCHAR wszPhysicalPath[_MAX_PATH];
    INT i = 0;

    // check to make sure it's not larger than max_length!
    if (strlen(pszMetabasePath) > _MAX_PATH){goto Add_WWW_VDirA_Exit;}
    if (strlen(pszVDirName) > _MAX_PATH){goto Add_WWW_VDirA_Exit;}
    if (strlen(pszPhysicalPath) > _MAX_PATH){goto Add_WWW_VDirA_Exit;}

    // convert it to unicode then call the wide function
    memset( (PVOID)wszMetabasePath, 0, sizeof(wszMetabasePath));
    memset( (PVOID)wszVDirName, 0, sizeof(wszVDirName));
    memset( (PVOID)wszPhysicalPath, 0, sizeof(wszPhysicalPath));
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszMetabasePath, -1, (LPWSTR)wszMetabasePath, _MAX_PATH);
    if (i <= 0) {goto Add_WWW_VDirA_Exit;}
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszVDirName, -1, (LPWSTR)wszVDirName, _MAX_PATH);
    if (i <= 0) {goto Add_WWW_VDirA_Exit;}
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszPhysicalPath, -1, (LPWSTR)wszPhysicalPath, _MAX_PATH);
    if (i <= 0) {goto Add_WWW_VDirA_Exit;}

    hr = Add_WWW_VDirW(wszMetabasePath, wszVDirName, wszPhysicalPath,dwPermissions, iApplicationType);

Add_WWW_VDirA_Exit:
    return hr;
}

HRESULT WINAPI Remove_WWW_VDirA(CHAR * pszMetabasePath, CHAR * pszVDirName)
{
    HRESULT hr = ERROR_BAD_PATHNAME;
    WCHAR wszMetabasePath[_MAX_PATH];
    WCHAR wszVDirName[_MAX_PATH];
    INT i = 0;

    // check to make sure it's not larger than max_length!
    if (strlen(pszMetabasePath) > _MAX_PATH){goto Remove_WWW_VDirA_Exit;}
    if (strlen(pszVDirName) > _MAX_PATH){goto Remove_WWW_VDirA_Exit;}

    // convert it to unicode then call the wide function
    memset( (PVOID)wszMetabasePath, 0, sizeof(wszMetabasePath));
    memset( (PVOID)wszVDirName, 0, sizeof(wszVDirName));
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszMetabasePath, -1, (LPWSTR)wszMetabasePath, _MAX_PATH);
    if (i <= 0) {goto Remove_WWW_VDirA_Exit;}
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszVDirName, -1, (LPWSTR)wszVDirName, _MAX_PATH);
    if (i <= 0) {goto Remove_WWW_VDirA_Exit;}

    hr = Remove_WWW_VDirW(wszMetabasePath, wszVDirName);

Remove_WWW_VDirA_Exit:
    return hr;
}


HRESULT WINAPI Add_WWW_VDirW(WCHAR * pwszMetabasePath, WCHAR * pwszVDirName, WCHAR * pwszPhysicalPath, DWORD dwPermissions, DWORD iApplicationType)
{
    HRESULT hr = ERROR_BAD_PATHNAME;
    IMSAdminBase *pIMSAdminBase = NULL;

    // check to make sure it's not larger than max_length!
    if ((wcslen(pwszMetabasePath) * sizeof(WCHAR))  > _MAX_PATH){goto Add_WWW_VDirW_Exit2;}
    if ((wcslen(pwszVDirName) * sizeof(WCHAR)) > _MAX_PATH){goto Add_WWW_VDirW_Exit2;}
    if ((wcslen(pwszPhysicalPath) * sizeof(WCHAR)) > _MAX_PATH){goto Add_WWW_VDirW_Exit2;}

    // only allow this if they are running as admin.
    hr = ERROR_ACCESS_DENIED;
    if (!RunningAsAdministrator())
    {
        goto Add_WWW_VDirW_Exit;
    }

    // if the service doesn't exist, then
    // we don't have to do anyting
    if (CheckifServiceExist(_T("IISADMIN")) != 0 )
    {
        hr = ERROR_SERVICE_DOES_NOT_EXIST;
        goto Add_WWW_VDirW_Exit;
    }

    hr = E_FAIL;
#ifndef _CHICAGO_
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    hr = CoInitialize(NULL);
#endif
    // no need to call uninit
    if( FAILED (hr)) {goto Add_WWW_VDirW_Exit2;}
    hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **) & pIMSAdminBase);
    if(FAILED (hr))
        {goto Add_WWW_VDirW_Exit;}

    hr = AddVirtualDir( pIMSAdminBase, pwszMetabasePath, pwszVDirName, pwszPhysicalPath, dwPermissions, iApplicationType);
    if(SUCCEEDED(hr))
        {hr = pIMSAdminBase->SaveData();}

    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

Add_WWW_VDirW_Exit:
    CoUninitialize();
Add_WWW_VDirW_Exit2:
    return hr;
}

HRESULT WINAPI Remove_WWW_VDirW(WCHAR * pwszMetabasePath, WCHAR * pwszVDirName)
{
    HRESULT hr = ERROR_BAD_PATHNAME;
    IMSAdminBase *pIMSAdminBase = NULL;

    // check to make sure it's not larger than max_length!
    if ((wcslen(pwszMetabasePath) * sizeof(WCHAR))  > _MAX_PATH){goto Remove_WWW_VDirW_Exit2;}
    if ((wcslen(pwszVDirName) * sizeof(WCHAR)) > _MAX_PATH){goto Remove_WWW_VDirW_Exit2;}

    // only allow this if they are running as admin.
    hr = ERROR_ACCESS_DENIED;
    if (!RunningAsAdministrator())
    {
        goto Remove_WWW_VDirW_Exit;
    }

    // if the service doesn't exist, then
    // we don't have to do anyting
    if (CheckifServiceExist(_T("IISADMIN")) != 0 )
    {
        hr = ERROR_SUCCESS;
        goto Remove_WWW_VDirW_Exit2;
    }

    hr = E_FAIL;
#ifndef _CHICAGO_
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    hr = CoInitialize(NULL);
#endif
    // no need to call uninit
    if( FAILED (hr)) {goto Remove_WWW_VDirW_Exit2;}

    hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **) & pIMSAdminBase);
    if( FAILED (hr))
        {goto Remove_WWW_VDirW_Exit;}

    hr = RemoveVirtualDir(pIMSAdminBase, pwszMetabasePath, pwszVDirName);
    if(SUCCEEDED(hr))
        {hr = pIMSAdminBase->SaveData();}

    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
Remove_WWW_VDirW_Exit:
    CoUninitialize();
Remove_WWW_VDirW_Exit2:
    return hr;
}


// Split a line of entry into iExpectedNumOfFields g_fields for MDEntry datatype
BOOL SplitLine(LPTSTR szLine, INT iExpectedNumOfFields)
{
    int i = 0;
    TCHAR *token = NULL;

    token = _tcstok(szLine, FIELD_SEPERATOR);
    while (token && i < iExpectedNumOfFields)
    {
        g_field[i++] = token;
        token = _tcstok(NULL, FIELD_SEPERATOR);
    }

    if (i == iExpectedNumOfFields)
        return TRUE;
    else
        return FALSE;
}

// Split a line of entry into iExpectedNumOfFields g_fields for MDEntry datatype
BOOL SplitLineCommaDelimited(LPTSTR szLine, INT iExpectedNumOfFields)
{
    int i = 0;
    TCHAR *token;
    token = _tcstok(szLine, _T(","));
    while (token && i < iExpectedNumOfFields)
    {
        g_field[i++] = token;
        token = _tcstok(NULL, _T(","));
    }
    if (i == iExpectedNumOfFields)
        return TRUE;
    else
        return FALSE;
}

DWORD GetSizeBasedOnMetaType(DWORD dwDataType,LPTSTR szString)
{
    DWORD dwRet = 0;

    switch (dwDataType)
    {
        case DWORD_METADATA:
            dwRet = 4;
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            if (szString == NULL)
            {
                dwRet = 0;
            }
            else
            {
                dwRet = (_tcslen((LPTSTR)szString) + 1) * sizeof(TCHAR);
            }
            break;
        case MULTISZ_METADATA:
            if (szString == NULL)
            {
                dwRet = 0;
            }
            else
            {
                dwRet = GetMultiStrSize((LPTSTR)szString) * sizeof(TCHAR);
            }
            break;
        case BINARY_METADATA:
            break;
    }

    return dwRet;
}

// function: MDEntry_Process
//
// The prupose of this function, is to read in a location and value from
// the inf file, if the location in the metabase equals that value, then
// change it to the new value.
// The main use of this function is to change values that we might of set
// incorrectly before.
//
// Format:
//  g_field[0] = "2"
//  g_field[1] = Location
//  g_field[2] = ID
//  g_field[3] = DataType
//  g_field[4] = DataSize
//  g_field[5] = Old Value (if this matches the metabase, we will replace with new value)
//  g_field[6] = Inheritable
//  g_field[7] = UserType
//  g_field[8] = DataType
//  g_field[9] = Length
//  g_field[10] = Value
//
// Return:
//   TRUE - Processed line fine
//   FALSE - Error Occurred
BOOL MDEntry_Process(LPTSTR szLine)
{
    CMDKey      cmdKey;
    CMDValue    cmdMetaValue;
    DWORD       dwSize;
    DWORD       dwDataType;

    // Split the line into the difference fields
    if (!SplitLine(szLine, 11))
    {
        return FALSE;
    }

    // Open the Node
    if ( FAILED(cmdKey.OpenNode(g_field[1]) ) )
    {
        return FALSE;
    }

    // Retrieve Value
    if ( !cmdKey.GetData(cmdMetaValue, _ttoi(g_field[2])) )
    {
        return FALSE;
    }

    dwDataType = _ttoi(g_field[3]);
    dwSize = _ttoi(g_field[4]);

    if (dwSize == 0)
    {
        dwSize = GetSizeBasedOnMetaType(dwDataType, g_field[5]);
    }

    if ( dwDataType == DWORD_METADATA )
    {
        if ( !cmdMetaValue.IsEqual(dwDataType,dwSize, _ttoi(g_field[5])) )
        {
            // The values did not match
            return TRUE;
        }
    }
    else
    {
        if ( !cmdMetaValue.IsEqual(dwDataType,dwSize,g_field[5]) )
        {
            // The values did not match
            return TRUE;
        }
    }

    dwSize = _ttoi(g_field[9]);

    if (dwSize == 0)
    {
        dwSize = GetSizeBasedOnMetaType(dwDataType, g_field[10]);
    }

    // At this point, we know that the values matched, so lets replace with the new value.
    if ( dwDataType == DWORD_METADATA )
    {
        DWORD dwValue = _ttoi(g_field[10]);

        cmdKey.SetData(_ttoi(g_field[2]),atodw(g_field[6]),_ttoi(g_field[7]),_ttoi(g_field[8]),dwSize,(LPBYTE) &dwValue);
    }
    else
    {
        cmdKey.SetData(_ttoi(g_field[2]),atodw(g_field[6]),_ttoi(g_field[7]),_ttoi(g_field[8]),dwSize,(LPBYTE) g_field[10]);
    }

    cmdKey.Close();

    return TRUE;
}

// function: MDEntry_MoveValue
//
// The prupose of this function, is to move a value set in the metabase from one location
// to another.  If that value does not exist, then we set a new value for it.
//
// Format:
//  g_field[0] = "3"
//  g_field[1] = Old Location
//  g_field[2] = Old ID
//  g_field[3] = New Location
//  g_field[4] = New ID
//  g_field[5] = Inheritable (Hex)
//  g_field[6] = UserType
//  g_field[7] = DataType
//  g_field[8] = Length
//  g_field[9] = Value (if none was detected before)
//
// Return:
//   TRUE - Processed line fine
//   FALSE - Error Occurred
BOOL MDEntry_MoveValue(LPTSTR szLine)
{
    CMDKey      cmdKey;
    CMDValue    cmdMetaValue;
    CMDValue    cmdDummyValue;
    DWORD       dwSize;
    BOOL        fRet = TRUE;

    // Split the line into the difference fields
    if (!SplitLine(szLine, 10))
    {
        return FALSE;
    }

    dwSize = _ttoi(g_field[8]);

    if (dwSize == 0)
    {
        dwSize = GetSizeBasedOnMetaType(_ttoi(g_field[7]), g_field[9]);
    }

    // First set the value that we are changing the data to
    cmdMetaValue.SetValue(_ttoi(g_field[4]),atodw(g_field[5]),_ttoi(g_field[6]),_ttoi(g_field[7]),dwSize,(LPTSTR) g_field[9]);

    // Open the Retrieve from Node
    if ( SUCCEEDED(cmdKey.OpenNode(g_field[1]) ) )
    {
        // Retrieve the old Value
        if ( cmdKey.GetData(cmdMetaValue, _ttoi(g_field[2])) )
        {
            // Delete Old Value if it exists
            if (FAILED(cmdKey.DeleteData(_ttoi(g_field[2]), ALL_METADATA)))
            {
                fRet = FALSE;
            }
        }

        cmdKey.Close();
    }

    // Open the node to Set
    if ( FAILED(cmdKey.OpenNode(g_field[3]) ) )
    {
        return FALSE;
    }

    // Set New Value (at this point cmdMetaValue, is either the value we orinally set, or
    // the value that was retrieved from the old location)
    if ( !cmdKey.GetData(cmdDummyValue, _ttoi(g_field[4])) )
    {
        if (!cmdKey.SetData(cmdMetaValue, _ttoi(g_field[4])))
        {
            fRet = FALSE;
        }
    }

    cmdKey.Close();

    return fRet;
}

INT GetMDEntryFromInfLineEx(LPTSTR szLine, MDEntry *pMDEntry)
{
    INT iTemp  = MDENTRY_FROMINFFILE_DO_ADD;
    INT iReturn = MDENTRY_FROMINFFILE_FAILED;

    if (!SplitLine(szLine, 8)){goto GetMDEntryFromInfLineEx_Exit;}

    if ( _tcscmp(g_field[0], _T("-1")) != 0)
    {
        if ( _tcscmp(g_field[0], _T("-0")) != 0)
        {
            goto GetMDEntryFromInfLineEx_Exit;
        }
        else
        {
            iTemp = MDENTRY_FROMINFFILE_DO_DEL;
        }
    }

    pMDEntry->szMDPath = g_field[1];
    pMDEntry->dwMDIdentifier = _ttoi(g_field[2]);
    pMDEntry->dwMDAttributes = atodw(g_field[3]);
    pMDEntry->dwMDUserType = _ttoi(g_field[4]);
    pMDEntry->dwMDDataType = _ttoi(g_field[5]);
    pMDEntry->dwMDDataLen = _ttoi(g_field[6]);

    switch ( pMDEntry->dwMDDataType )
    {
        case DWORD_METADATA:
            {
                *(DWORD *)g_pbData = atodw(g_field[7]);
                pMDEntry->pbMDData = g_pbData;
                break;
            }
        case MULTISZ_METADATA:
            {
                CString csMultiSZ;
                int nLen = 0;
                ReadMultiSZFromInfSection(&csMultiSZ, g_pTheApp->m_hInfHandle, g_field[7]);
                nLen = csMultiSZ.GetLength();

                HGLOBAL hBlock = NULL;
                hBlock = GlobalAlloc(GPTR, (nLen+1)*sizeof(TCHAR));
                if (hBlock)
                {
                    TCHAR *p = (LPTSTR)hBlock;
                    memcpy((LPVOID)hBlock, (LPVOID)(LPCTSTR)csMultiSZ, (nLen+1)*sizeof(TCHAR));
                    while (*p)
                    {
                        if (*p == _T('|'))
                            *p = _T('\0');
                        p = _tcsinc(p);
                    }
                    pMDEntry->pbMDData = (LPBYTE)hBlock;
                }
                else
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("GetMDEntryFromInfLine.1.Failed to allocate memory.\n")));
                    pMDEntry->dwMDDataLen = 0;
                    pMDEntry->pbMDData = NULL;
                    goto GetMDEntryFromInfLineEx_Exit;
                }
                break;
            }
        default:
            {
                // treat the whole thing as string
                pMDEntry->pbMDData = (LPBYTE)g_field[7];
                break;
            }
    }

    switch (pMDEntry->dwMDDataType)
    {
        case DWORD_METADATA:
            pMDEntry->dwMDDataLen = 4;
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            pMDEntry->dwMDDataLen = (_tcslen((LPTSTR)pMDEntry->pbMDData) + 1) * sizeof(TCHAR);
            break;
        case MULTISZ_METADATA:
            pMDEntry->dwMDDataLen = GetMultiStrSize((LPTSTR)pMDEntry->pbMDData) * sizeof(TCHAR);
            break;
        case BINARY_METADATA:
            break;
    }
    iReturn = iTemp;

GetMDEntryFromInfLineEx_Exit:
    return iReturn;
}

// Fill in the structure of MDEntry
INT GetMDEntryFromInfLine(LPTSTR szLine, MDEntry *pMDEntry)
{
    INT iReturn = MDENTRY_FROMINFFILE_FAILED;
    BOOL fMigrate;
    BOOL fKeepOldReg;
    HKEY hRegRootKey;
    LPTSTR szRegSubKey;
    LPTSTR szRegValueName;

    // Check if the first character is = "-1"
    // if it is then do the special metabase slam deal none of this
    // upgrade and look up registry junk, just slam the data into the metabase.
    if (szLine[0] == _T('-') && szLine[1] == _T('1'))
    {
        iReturn = GetMDEntryFromInfLineEx(szLine, pMDEntry);
        goto GetMDEntryFromInfLine_Exit;
    }
    if (szLine[0] == _T('-') && szLine[1] == _T('0'))
    {
        iReturn = GetMDEntryFromInfLineEx(szLine, pMDEntry);
        goto GetMDEntryFromInfLine_Exit;
    }
    if (szLine[0] == _T('2') )
    {
        MDEntry_Process(szLine);
        return MDENTRY_FROMINFFILE_DO_NOTHING;
    }
    if (szLine[0] == _T('3') )
    {
        MDEntry_MoveValue(szLine);
        return MDENTRY_FROMINFFILE_DO_NOTHING;
    }

    if (!SplitLine(szLine, 12))
        return FALSE;

    if ( _tcscmp(g_field[0], _T("1")) == 0)
        fMigrate = (g_pTheApp->m_eUpgradeType == UT_10_W95 || g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30);
    else
        fMigrate = FALSE;

    if ( _tcscmp(g_field[1], _T("1")) == 0)
        fKeepOldReg = TRUE;
    else
        fKeepOldReg = FALSE;

    if (_tcsicmp(g_field[2], _T("HKLM")) == 0) {hRegRootKey = HKEY_LOCAL_MACHINE;}
    else if (_tcsicmp(g_field[2], _T("HKCR")) == 0) {hRegRootKey = HKEY_CLASSES_ROOT;}
    else if (_tcsicmp(g_field[2], _T("HKCU")) == 0) {hRegRootKey = HKEY_CURRENT_USER;}
    else if (_tcsicmp(g_field[2], _T("HKU")) == 0) {hRegRootKey = HKEY_USERS;}
    else {hRegRootKey = HKEY_LOCAL_MACHINE;}

    szRegSubKey = g_field[3];
    szRegValueName = g_field[4];

    pMDEntry->szMDPath = g_field[5];
    pMDEntry->dwMDIdentifier = _ttoi(g_field[6]);
    pMDEntry->dwMDAttributes = atodw(g_field[7]);
    pMDEntry->dwMDUserType = _ttoi(g_field[8]);
    pMDEntry->dwMDDataType = _ttoi(g_field[9]);
    pMDEntry->dwMDDataLen = _ttoi(g_field[10]);

    switch ( pMDEntry->dwMDDataType )
    {
        case DWORD_METADATA:
            {
                *(DWORD *)g_pbData = atodw(g_field[11]);
                pMDEntry->pbMDData = g_pbData;
                break;
            }
        case MULTISZ_METADATA:
            {
                CString csMultiSZ;
                int nLen = 0;
                ReadMultiSZFromInfSection(&csMultiSZ, g_pTheApp->m_hInfHandle, g_field[11]);
                nLen = csMultiSZ.GetLength();

                HGLOBAL hBlock = NULL;
                hBlock = GlobalAlloc(GPTR, (nLen+1)*sizeof(TCHAR));
                if (hBlock)
                {
                    TCHAR *p = (LPTSTR)hBlock;
                    memcpy((LPVOID)hBlock, (LPVOID)(LPCTSTR)csMultiSZ, (nLen+1)*sizeof(TCHAR));
                    while (*p)
                    {
                        if (*p == _T('|'))
                            *p = _T('\0');
                        p = _tcsinc(p);
                    }
                    pMDEntry->pbMDData = (LPBYTE)hBlock;
                }
                else
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("GetMDEntryFromInfLine.1.Failed to allocate memory.\n")));
                    pMDEntry->dwMDDataLen = 0;
                    pMDEntry->pbMDData = NULL;
                    goto GetMDEntryFromInfLine_Exit;
                }
                break;
            }
        default:
            {
                // treat the whole thing as string
                pMDEntry->pbMDData = (LPBYTE)g_field[11];
                break;
            }
    }

    // migrate if necessary
    if (fMigrate)
    {
        HKEY hKey = NULL;
        LONG err = ERROR_SUCCESS;
        DWORD dwType = 0;
        DWORD cbData = sizeof(g_pbData);
        err = RegOpenKeyEx(hRegRootKey, szRegSubKey, 0, KEY_ALL_ACCESS, &hKey);
        if ( err == ERROR_SUCCESS )
        {
            err = RegQueryValueEx(hKey, szRegValueName, NULL, &dwType, g_pbData, &cbData);
            if (err == ERROR_MORE_DATA)
            {
                free(g_pbData);
                g_pbData = NULL;
                g_pbData = (LPBYTE)malloc(cbData);
                if (!g_pbData)
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("GetMDEntryFromInfLine.2.Failed to allocate memory.\n")));
                    err = E_FAIL;
                }
                else
                {
                    err = RegQueryValueEx(hKey, szRegValueName, NULL, &dwType, g_pbData, &cbData);
                }
            }
            if ( err == ERROR_SUCCESS)
            {
                if (_tcsicmp(szRegValueName, _T("MaxConnections")) == 0)
                {
                    if (*(DWORD *)g_pbData == 0x186a0) {*(DWORD *)g_pbData = 0x77359400;}
                }
                pMDEntry->pbMDData = g_pbData;
                pMDEntry->dwMDDataLen = cbData;
            }

            if (fKeepOldReg == FALSE) {err = RegDeleteValue(hKey, szRegValueName);}
            RegCloseKey(hKey);
        }
    }
    else if (fKeepOldReg == FALSE)
    {
        HKEY hKey = NULL;
        LONG err = ERROR_SUCCESS;
        DWORD dwType = 0;
        DWORD cbData = sizeof(g_pbData);
        err = RegOpenKeyEx(hRegRootKey, szRegSubKey, 0, KEY_ALL_ACCESS, &hKey);
        if ( err == ERROR_SUCCESS )
        {
            err = RegDeleteValue(hKey, szRegValueName);
            RegCloseKey(hKey);
        }
    }

    switch (pMDEntry->dwMDDataType)
    {
        case DWORD_METADATA:
            pMDEntry->dwMDDataLen = 4;
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            pMDEntry->dwMDDataLen = (_tcslen((LPTSTR)pMDEntry->pbMDData) + 1) * sizeof(TCHAR);
            break;
        case MULTISZ_METADATA:
            pMDEntry->dwMDDataLen = GetMultiStrSize((LPTSTR)pMDEntry->pbMDData) * sizeof(TCHAR);
            break;
        case BINARY_METADATA:
            break;
    }
    iReturn = MDENTRY_FROMINFFILE_DO_ADD;

GetMDEntryFromInfLine_Exit:
    return iReturn;
}


DWORD WriteToMD_AdminInstance(CString csKeyPath,CString& csInstNumber)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ADMIN_INSTANCE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csInstNumber.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csInstNumber;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_VRootPath(CString csKeyPath, CString csPath, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/something
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_VR_PATH;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csPath.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csPath;
    //dwReturn = SetMDEntry_Wrap(&stMDEntry);
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }

    return dwReturn;
}

DWORD WriteToMD_AccessPerm(CString csKeyPath, DWORD dwRegularPerm, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/something
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ACCESS_PERM;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwRegularPerm;
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    return dwReturn;
}

DWORD WriteToMD_SSLPerm(CString csKeyPath, DWORD dwSSLPerm, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SSL_ACCESS_PERM;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwSSLPerm;
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    return dwReturn;
}


DWORD WriteToMD_Authorization(CString csKeyPath, DWORD dwValue)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // MD_AUTH_ANONYMOUS
    // MD_AUTH_BASIC
    // MD_AUTH_NT

    // LM/W3SVC/1/ROOT/
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_AUTHORIZATION;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwValue;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_DirBrowsing_WWW(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_DIRECTORY_BROWSING;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);

    // default
    dwData = MD_DIRBROW_SHOW_DATE |
        MD_DIRBROW_SHOW_TIME |
        MD_DIRBROW_SHOW_SIZE |
        MD_DIRBROW_SHOW_EXTENSION |
        MD_DIRBROW_LONG_DATE |
        MD_DIRBROW_LOADDEFAULT |
        MD_DIRBROW_ENABLED;

    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_VRUserName(CString csKeyPath, CString csUserName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_VR_USERNAME;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csUserName.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csUserName;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_VRPassword(CString csKeyPath, CString csPassword)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_VR_PASSWORD;
    stMDEntry.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csPassword.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csPassword;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_IIsWebVirtualDir(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    csKeyType = _T("IIsWebVirtualDir");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_IIsFtpVirtualDir(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    csKeyType = _T("IIsFtpVirtualDir");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_IIsWebServerInstance_WWW(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    csKeyType = _T("IIsWebServer");
    //  LM/W3SVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_IIsFtpServerInstance_FTP(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    csKeyType = _T("IIsFtpServer");
    //  LM/FTP/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_AnonymousUserName_FTP(int iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    int iOverWriteName = TRUE;
    int iOverWritePass = TRUE;

    CMDKey cmdKey;
    MDEntry stMDEntry;
    MDEntry stMDEntry_Pass;

    // Add the anonymous user name
    stMDEntry.szMDPath = _T("LM/MSFTPSVC");
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_USER_NAME;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (g_pTheApp->m_csFTPAnonyName.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)g_pTheApp->m_csFTPAnonyName;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("FTP Anonymous usrname=%s.\n"), g_pTheApp->m_csFTPAnonyName));

    // add anonymous password
    stMDEntry_Pass.szMDPath = _T("LM/MSFTPSVC");
    stMDEntry_Pass.dwMDIdentifier = MD_ANONYMOUS_PWD;
    stMDEntry_Pass.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
    stMDEntry_Pass.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry_Pass.dwMDDataType = STRING_METADATA;
    stMDEntry_Pass.dwMDDataLen = (g_pTheApp->m_csFTPAnonyPassword.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry_Pass.pbMDData = (LPBYTE)(LPCTSTR)g_pTheApp->m_csFTPAnonyPassword;
    // make sure and delete it first
    // DeleteMDEntry(&stMDEntry_Pass);

    if (iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere)
    {
        iOverWriteName = FALSE;
        iOverWritePass = FALSE;
        if (ChkMdEntry_Exist(&stMDEntry))
        {
            iOverWriteName = TRUE;
        }
        if (ChkMdEntry_Exist(&stMDEntry_Pass))
        {
            iOverWritePass = TRUE;
        }
    }

    // --------------------------------------------------
    // always overwrite, we may have changed the password
    // important: Set the username and the password on a single open and close!
    // --------------------------------------------------
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)stMDEntry.szMDPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        if (iOverWriteName)
        {
            dwReturnTemp = ERROR_SUCCESS;
            dwReturnTemp = cmdKey.SetData(stMDEntry.dwMDIdentifier,stMDEntry.dwMDAttributes,stMDEntry.dwMDUserType,stMDEntry.dwMDDataType,stMDEntry.dwMDDataLen,stMDEntry.pbMDData);
            if (FAILED(dwReturnTemp))
            {
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry.dwMDIdentifier, dwReturnTemp));
                dwReturn = dwReturnTemp;
            }
        }


        if (iOverWritePass)
        {
            dwReturnTemp = ERROR_SUCCESS;
            dwReturnTemp = cmdKey.SetData(stMDEntry_Pass.dwMDIdentifier,stMDEntry_Pass.dwMDAttributes,stMDEntry_Pass.dwMDUserType,stMDEntry_Pass.dwMDDataType,stMDEntry_Pass.dwMDDataLen,stMDEntry_Pass.pbMDData);
            if (FAILED(dwReturnTemp))
            {
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry_Pass.dwMDIdentifier, dwReturnTemp));
                dwReturn = dwReturnTemp;
            }
        }
        cmdKey.Close();
    }

    return dwReturn;
}



DWORD WriteToMD_AnonymousUserName_WWW(int iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    CMDKey cmdKey;
    MDEntry stMDEntry;
    MDEntry stMDEntry_Pass;

    int iOverWriteName = TRUE;
    int iOverWritePass = TRUE;

    // add anonymous username
    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_USER_NAME;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (g_pTheApp->m_csWWWAnonyName.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)g_pTheApp->m_csWWWAnonyName;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("WWW Anonymous usrname=%s.\n"), g_pTheApp->m_csWWWAnonyName));

    // add anonymous password
    stMDEntry_Pass.szMDPath = _T("LM/W3SVC");
    stMDEntry_Pass.dwMDIdentifier = MD_ANONYMOUS_PWD;
    stMDEntry_Pass.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
    stMDEntry_Pass.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry_Pass.dwMDDataType = STRING_METADATA;
    stMDEntry_Pass.dwMDDataLen = (g_pTheApp->m_csWWWAnonyPassword.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry_Pass.pbMDData = (LPBYTE)(LPCTSTR)g_pTheApp->m_csWWWAnonyPassword;
    // make sure and delete it first
    // DeleteMDEntry(&stMDEntry_Pass);

    if (iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere)
    {
        iOverWriteName = FALSE;
        iOverWritePass = FALSE;
        if (ChkMdEntry_Exist(&stMDEntry))
        {
            iOverWriteName = TRUE;
        }
        if (ChkMdEntry_Exist(&stMDEntry_Pass))
        {
            iOverWritePass = TRUE;
        }
    }

    // --------------------------------------------------
    // always overwrite, we may have changed the password
    // important: Set the username and the password on a single open and close!
    // --------------------------------------------------
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)stMDEntry.szMDPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        if (iOverWriteName)
        {
            dwReturnTemp = ERROR_SUCCESS;
            dwReturnTemp = cmdKey.SetData(stMDEntry.dwMDIdentifier,stMDEntry.dwMDAttributes,stMDEntry.dwMDUserType,stMDEntry.dwMDDataType,stMDEntry.dwMDDataLen,stMDEntry.pbMDData);
            if (FAILED(dwReturnTemp))
            {
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry.dwMDIdentifier, dwReturnTemp));
                dwReturn = dwReturnTemp;
            }
        }

        if (iOverWritePass)
        {
            dwReturnTemp = ERROR_SUCCESS;
            dwReturnTemp = cmdKey.SetData(stMDEntry_Pass.dwMDIdentifier,stMDEntry_Pass.dwMDAttributes,stMDEntry_Pass.dwMDUserType,stMDEntry_Pass.dwMDDataType,stMDEntry_Pass.dwMDDataLen,stMDEntry_Pass.pbMDData);
            if (FAILED(dwReturnTemp))
            {
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry_Pass.dwMDIdentifier, dwReturnTemp));
                dwReturn = dwReturnTemp;
            }
        }
        cmdKey.Close();
    }

    return dwReturn;
}


DWORD WriteToMD_AnonymousUseSubAuth_FTP(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    // if not PDC, BDC, SamNT, Win95
    stMDEntry.szMDPath = _T("LM/MSFTPSVC");
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_USE_SUBAUTH;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    if ((g_pTheApp->m_csFTPAnonyName).CompareNoCase(g_pTheApp->m_csGuestName) == 0)
        dwData = 0x1;
    else
        dwData = 0x0;
    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}

// This is the same as
//   enable password synchronization
DWORD WriteToMD_AnonymousUseSubAuth_WWW(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    // if not PDC, BDC, SamNT, Win95
    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_USE_SUBAUTH;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);

    // set the sub authority bit on whether or not the anonymous name is an account
    // on this local machine, or whether it is a domain account somewhere.
    // if ((g_pTheApp->m_csWWWAnonyName).CompareNoCase(g_pTheApp->m_csGuestName) == 0)
    DWORD dwErr;
    if ( IsLocalAccount(g_pTheApp->m_csWWWAnonyName, &dwErr) )
    {
        dwData = 0x1;
    }
    else
    {
        dwData = 0x0;
    }

    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_GreetingMessage_FTP(void)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    CRegKey regFTPParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters"), KEY_READ);

    CStringList csGreetingsList;
    int nLen = 0;
    HGLOBAL hBlock = NULL;
    regFTPParam.QueryValue(_T("GreetingMessage"), csGreetingsList);
    if (csGreetingsList.IsEmpty() == FALSE)
    {
        POSITION pos = NULL;
        CString csGreetings;
        LPTSTR p;

        pos = csGreetingsList.GetHeadPosition();
        while (pos)
        {
            csGreetings = csGreetingsList.GetAt(pos);

            if ( !csGreetings.IsEmpty() )
            {
              nLen += csGreetings.GetLength() + 1;
              iisDebugOut((LOG_TYPE_TRACE, _T("pos=%x, greeting=%s, nLen=%d\n"), pos, csGreetings, nLen));
            }

            csGreetingsList.GetNext(pos);
        }
        nLen++;

        hBlock = GlobalAlloc(GPTR, nLen * sizeof(TCHAR));
        if (!hBlock)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_GreetingMessage_FTP.1.Failed to allocate memory.\n")));
            return ERROR_OUTOFMEMORY;
        }

        p = (LPTSTR)hBlock;
        pos = csGreetingsList.GetHeadPosition();
        while (pos)
        {
            csGreetings = csGreetingsList.GetAt(pos);

            if ( !csGreetings.IsEmpty() )
            {
              _tcscpy(p, csGreetings);
              p = _tcsninc(p, csGreetings.GetLength())+1;
              iisDebugOut((LOG_TYPE_TRACE, _T("pos=%x, greeting=%s\n"), pos, csGreetings));
            }

            csGreetingsList.GetNext(pos);
        }
        *p = _T('\0');
        p = _tcsinc(p);

        stMDEntry.szMDPath = _T("LM/MSFTPSVC");
        stMDEntry.dwMDIdentifier = MD_GREETING_MESSAGE;
        stMDEntry.dwMDAttributes = METADATA_INHERIT;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = MULTISZ_METADATA;
        stMDEntry.dwMDDataLen = nLen * sizeof(TCHAR);
        stMDEntry.pbMDData = (LPBYTE)hBlock;
        dwReturn = SetMDEntry_Wrap(&stMDEntry);
    }

    if (stMDEntry.pbMDData)
    {
        GlobalFree(stMDEntry.pbMDData);
        stMDEntry.pbMDData = NULL;
    }

    return dwReturn;
}



DWORD WriteToMD_ServerBindings_HTMLA(CString csKeyPath, UINT iPort)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    TCHAR szData[_MAX_PATH];
    memset( (PVOID)szData, 0, sizeof(szData));
    _stprintf(szData, _T(":%d:"), iPort);

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_BINDINGS;
    stMDEntry.dwMDAttributes = 0;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = GetMultiStrSize(szData) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)szData;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}






DWORD WriteToMD_ServerBindings(LPCTSTR szSvcName, CString csKeyPath, CString csIP)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    int nPort = 0;

    HGLOBAL hBlock = NULL;
    hBlock = GlobalAlloc(GPTR, _MAX_PATH * sizeof(TCHAR));
    if (!hBlock)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_ServerBindings.Failed to allocate memory.\n")));
        return ERROR_OUTOFMEMORY;
    }

    //  LM/W3SVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_BINDINGS;
    stMDEntry.dwMDAttributes = 0;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;

    nPort = GetPortNum(szSvcName);
    if (csIP.Compare(_T("null")) == 0)
        _stprintf((LPTSTR)hBlock, _T(":%d:"), nPort);
    else
        _stprintf((LPTSTR)hBlock, _T("%s:%d:"), csIP, nPort);

    stMDEntry.dwMDDataLen = GetMultiStrSize((LPTSTR)hBlock) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)hBlock;
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (stMDEntry.pbMDData)
    {
        GlobalFree(stMDEntry.pbMDData);
        stMDEntry.pbMDData = NULL;
    }

    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}





DWORD WriteToMD_SecureBindings(CString csKeyPath, CString csIP)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    HGLOBAL hBlock = NULL;
    hBlock = GlobalAlloc(GPTR, _MAX_PATH * sizeof(TCHAR));
    if (!hBlock)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_SecureBindings.Failed to allocate memory.\n")));
        return ERROR_OUTOFMEMORY;
    }

    //  LM/W3SVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SECURE_BINDINGS;
    stMDEntry.dwMDAttributes = 0;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    if (csIP.Compare(_T("null"))==0)
        _tcscpy((LPTSTR)hBlock, _T(":443:"));
    else
        _stprintf((LPTSTR)hBlock, _T("%s:443:"), csIP);
    stMDEntry.dwMDDataLen = GetMultiStrSize((LPTSTR)hBlock) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)hBlock;
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (stMDEntry.pbMDData)
    {
        GlobalFree(stMDEntry.pbMDData);
        stMDEntry.pbMDData = NULL;
    }

    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}

DWORD WriteToMD_ServerSize(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    DWORD dwServerSize = 0x1;

    //  LM/W3SVC/N
    //  LM/MSFTPSVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_SIZE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwServerSize;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}



DWORD WriteToMD_NotDeleteAble(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;

    return dwReturn;
}

DWORD WriteToMD_ServerComment(CString csKeyPath, UINT iCommentID)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    CString csDefaultSite;

    MyLoadString(IDS_DEFAULT_WEB_SITE, csDefaultSite);
    if (iCommentID)
    {
        MyLoadString(iCommentID, csDefaultSite);
    }

    //  LM/W3SVC/N
    //  LM/MSFTPSVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_COMMENT;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csDefaultSite.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csDefaultSite;
    dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_DefaultSiteAndSize(CString csKeyPath)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    UINT iCommentID = IDS_DEFAULT_WEB_SITE;

    // Get Resource ID
    if (csKeyPath.Find(_T("W3SVC")) != -1)
        iCommentID = IDS_DEFAULT_WEB_SITE;
    else
        iCommentID = IDS_DEFAULT_FTP_SITE;

    dwReturnTemp = WriteToMD_ServerComment(csKeyPath, iCommentID);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    dwReturnTemp = WriteToMD_ServerSize(csKeyPath);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    if (g_pTheApp->m_eNTOSType == OT_NTW)
    {
        dwReturnTemp = WriteToMD_NotDeleteAble(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}
    }

    return dwReturn;
}


DWORD WriteToMD_CertMapper(CString csKeyPath)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;
    CString csKeyType;
    CString csKeyPath2;

    csKeyPath2 = csKeyPath;
    csKeyPath2 += _T("/IIsCertMapper");

    //  LM/W3SVC/N/IIsCertMapper
    csKeyType = _T("IIsCertMapper");

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath2;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}

//
// Returns the amount of filters that iis5 needs
//
int AddRequiredFilters(TSTR &strTheSection, CStringArray& arrayName,CStringArray& arrayPath)
{
    iisDebugOut_Start(_T("AddRequiredFilters"),LOG_TYPE_TRACE);

    int c = 0;
    CString csName = _T("");
    CString csPath = _T("");
    TSTR    strTheTempSection;
    CStringList strList;

    iisDebugOut((LOG_TYPE_TRACE, _T("ProcessFilters:%s\n"),strTheSection.QueryStr() ));

    if ( strTheTempSection.Copy( strTheSection ) &&
         GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheTempSection )
       )
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, strTheTempSection.QueryStr() ))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);
                // Split into name, and value. look for ","
                int i;
                i = csEntry.ReverseFind(_T(','));
                if (i != -1)
                {
                    int len =0;
                    len = csEntry.GetLength();
                    csPath = csEntry.Right(len - i - 1);
                    csName = csEntry.Left(i);

                    // only add the filter if the file exists..
                    // Check if exists..
                    if (IsFileExist(csPath))
                    {
                        // Add it to our array...
                        iisDebugOut((LOG_TYPE_TRACE, _T("Add filter Entry:%s:%s\n"),csName, csPath));
                        arrayName.Add(csName);
                        arrayPath.Add(csPath);
                        c++;
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("Missing Filter:Cannot Find:%s:%s\n"),csName, csPath));
                    }
                }

                strList.GetNext(pos);
            }
        }
    }
    }

    iisDebugOut_End(_T("AddRequiredFilters"),LOG_TYPE_TRACE);
    return c;
}


DWORD WriteToMD_Filters_WWW(TSTR &strTheSection)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    CString csKeyType;

    CString csPath = _T("");

    int c = 0;
    int j = 0, k=0;
    CStringArray arrayName, arrayPath;
    CString csName, csFilterDlls;

    CRegKey regWWWParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"), KEY_READ);

    // Add Required Filters to the arrayName
    c = AddRequiredFilters( strTheSection, arrayName, arrayPath);

    // Look thru the registry and
    // find the users filters -- grab then and stick them into our
    // big array of filters...
    if ( (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30) && (HKEY)regWWWParam )
    {
        if ( regWWWParam.QueryValue(_T("Filter Dlls"), csFilterDlls) == ERROR_SUCCESS )
        {
            csFilterDlls.TrimLeft();
            csFilterDlls.TrimRight();
            csFilterDlls.MakeLower();
            if (!(csFilterDlls.IsEmpty()))
            {
                CString csTemp;

                while (csFilterDlls.IsEmpty() == FALSE)
                {
                    j = csFilterDlls.Find(_T(','));
                    if ( j != -1 )
                    {
                        // means more than 1 item
                        csTemp = csFilterDlls.Mid(0, j); // retrieve the first one
                        csFilterDlls = csFilterDlls.Mid(j+1);
                        csFilterDlls.TrimLeft();
                    }
                    else
                    { // has only one item
                        csTemp = csFilterDlls.Mid(0);
                        csFilterDlls.Empty();
                    }

                    csPath = csTemp;
                    // get the filename of this dll, i.e., <path>\f1.dll ==> f1
                    j = csTemp.ReverseFind(_T('\\'));
                    j = (j==-1) ? 0 : j+1; // move j to the first char of the pure filename

                    // change csTemp = f1.dll
                    csTemp = csTemp.Mid(j);

                    j = csTemp.Find(_T('.'));
                    csName = (j==-1) ? csTemp : csTemp.Mid(0, j);

                    // add to arrary, avoid redundency
                    for (k=0; k<c; k++)
                    {
                        if (csName.Compare((CString)arrayName[k]) == 0)
                            break;
                    }
                    if (k==c)
                    {
                        arrayName.Add(csName);
                        arrayPath.Add(csPath);
                        c++;
                    }
                }
            }
        }
    }

    // make sure there are entries to write out...
    if (arrayName.GetSize() > 0)
    {
        // if we are upgrading from Beta3 we need to take care to add the new filters to
        // the existing ones that are in the metabase. - boydm
        CString csOrder;                            // cstrings initialize to empty
        // now the array is ready to use, and it has at least 2 items
        csOrder = (CString)arrayName[0];
        for (k=1; k<c; k++)
            {
            csOrder += _T(",");
            csOrder += arrayName[k];
            }

        // now we have csOrder=f1,f2,f3,sspifilt
        // About KeyType
        dwReturnTemp = WriteToMD_Filters_List_Entry(csOrder);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        CString csMDPath;
        for (k=0; k<c; k++)
        {
            dwReturnTemp = WriteToMD_Filter_Entry((CString) arrayName[k], (CString) arrayPath[k]);
            if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}
        }
    }

    return dwReturn;
}

#ifndef _CHICAGO_
// UNDONE: WE NEED TO DO ERROR CHECKING HERE!!!!!!!!!!!!!
DWORD UpgradeCryptoKeys_WWW(void)
{
    DWORD dwReturn = ERROR_PATH_NOT_FOUND;
    if ( g_pTheApp->m_eOS != OS_W95 )
    {
        // if upgrading iis 2 or 3, then the keys are stored in the LSA/Registry.
        if (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30 )
        {
            // prepare the machine name
            WCHAR wchMachineName[UNLEN + 1];
            memset( (PVOID)wchMachineName, 0, sizeof(wchMachineName));
#if defined(UNICODE) || defined(_UNICODE)
            wcsncpy(wchMachineName, g_pTheApp->m_csMachineName, UNLEN);
#else
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)g_pTheApp->m_csMachineName, -1, (LPWSTR)wchMachineName, UNLEN);
#endif
            // upgrade the keys
            UpgradeLSAKeys( wchMachineName );

            dwReturn = ERROR_SUCCESS;
        }

        // if upgrading iis 4, then the keys are stored in the metabase
        if (!g_pTheApp->m_bWin95Migration)
        {
            if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
            {
                Upgradeiis4Toiis5MetabaseSSLKeys();
                dwReturn = ERROR_SUCCESS;
            }
        }
    }
    return dwReturn;
}
#endif //_CHICAGO_


// add pSrc on top of pDest
void Merge2IPNodes(CMapStringToString *pSrc, CMapStringToString *pDest)
{
    CString csName, csSrcValue, csDestValue;
    POSITION pos = pSrc->GetStartPosition();
    while (pos)
    {
        pSrc->GetNextAssoc(pos, csName, csSrcValue);
        if (pDest->Lookup(csName, csDestValue) == FALSE)
        {
            // add this new value to pDest
            pDest->SetAt(csName, csSrcValue);
        }
    }
    return;
}

/*
Logic:
1. Create pNew, which contains new vroots except the home root
2. Get pMap from registry in Upgrade case, or pMap is empty in Fresh case.
3. If pMap is empty, add home root into pNews, set pMap to contain null==>pNew. goto 8.
4. If pMap is not empty and nullNode exists, Merge nullNode into pNew. goto 6.
5. If pMap is not empty and nullNode does not exist, goto 6.
6. Merge pNew onto each ipNodes in the pMap
7. For nullNode in pMap, if there is no / (home root) exists, delete this nullNode from the pMap.
8. Done.
*/
void CreateWWWVRMap(CMapStringToOb *pMap)
{
    CString name, value;
    CMapStringToString *pNew;

    {
        pNew = new CMapStringToString;

        // only create new scripts directories if this is either new or maintenance. If we were to
        // create it here on an upgrade, it replaces the user's old scripts directory. - Actually
        // this is only true if the user's old script directory has different capitalization than
        // what is listed below. This is because the merge routine that mushes together the pNew
        // and pMap lists is case sensitive. The old ones are usually "Scripts" with a capital S.
		/*
        if ( (g_pTheApp->m_eInstallMode == IM_FRESH)||(g_pTheApp->m_eInstallMode == IM_MAINTENANCE) )
            {
            name = _T("/scripts");
            value.Format(_T("%s,,%x"), g_pTheApp->m_csPathScripts, MD_ACCESS_EXECUTE);
            value.MakeLower();
            pNew->SetAt(name, value);
            }
		*/

		// Create the scripts dir always.
        // HANDLED in the inf file in iis6
        /*
        name = _T("/scripts");
        value.Format(_T("%s,,%x"), g_pTheApp->m_csPathScripts, MD_ACCESS_EXECUTE);
        value.MakeLower();
        pNew->SetAt(name, value);
        */
/*
        name = _T("/iishelp");
        value.Format(_T("%s\\Help\\iishelp,,%x"), g_pTheApp->m_csWinDir, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
        value.MakeLower();
        pNew->SetAt(name, value);
*/
	// bug # 123133	iis5.1 Remove samples from install
        // name = _T("/iissamples");
        // value.Format(_T("%s,,%x"), g_pTheApp->m_csPathIISSamples, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
        // value.MakeLower();
        // pNew->SetAt(name, value);

		/*
		removed per bug#197982 8/11/98
		The decision was made NOT to setup the IISADMPWD vdir.
		can you pls still copy the files but not set up the vdir?
        if (g_pTheApp->m_eOS != OS_W95)
        {
            name = _T("/iisadmpwd");
            value.Format(_T("%s\\iisadmpwd,,%x"), g_pTheApp->m_csPathInetsrv, MD_ACCESS_EXECUTE);
            value.MakeLower();
            pNew->SetAt(name, value);
        }
		*/

/*
        // actually this was removed per bug318938
        // --------------------------------
        // handled in the inf file for iis6
        // --------------------------------
        // Add the msadc virtual root

        // Get the path for msadc...
        // C:\Program Files\Common Files\system\msadc
        CString csCommonFilesPath;
        csCommonFilesPath = g_pTheApp->m_csSysDrive + _T("\\Program Files\\Common Files");
        CRegKey regCurrentVersion(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion"), KEY_READ);
        if ( (HKEY)regCurrentVersion )
        {
            if (regCurrentVersion.QueryValue(_T("CommonFilesDir"), csCommonFilesPath) != 0)
            {
                csCommonFilesPath = g_pTheApp->m_csSysDrive + _T("\\Program Files\\Common Files");
            }
            else
            {
                if (-1 != csCommonFilesPath.Find(_T('%')) )
                {
                    // there is a '%' in the string
                    TCHAR szTempDir[_MAX_PATH];
                    _tcscpy(szTempDir, csCommonFilesPath);
                    if (ExpandEnvironmentStrings( (LPCTSTR)csCommonFilesPath, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                        {
                        csCommonFilesPath = szTempDir;
                        }
                }
            }
        }
		SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32777, g_pTheApp->m_csPathProgramFiles);

        CString csCommonFilesPath2;
        csCommonFilesPath2 = AddPath(csCommonFilesPath, _T("System\\msadc"));

        name = _T("/msadc");
        value.Format(_T("%s,,%x"), csCommonFilesPath2, MD_ACCESS_READ | MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT);
        value.MakeLower();
        pNew->SetAt(name, value);
*/

    }

    if (g_pTheApp->m_eUpgradeType == UT_10_W95 || g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        CElem elem;
        elem.ReadRegVRoots(REG_WWWVROOTS, pMap);

        // check to see if pMap contains a null node (default website). If there is no default
        // node, then add one with nothing in it. This will later be merged with the pNew map - boydm
        CMapStringToString *pNullNode;
        if ( !pMap->Lookup(_T("null"),(CObject*&)pNullNode) )
        {
            // there is no node in the map that corresponds to the default website. We must create
            // one at this point and add it to the list
            pNullNode = new CMapStringToString;

            if (pNullNode)
            {
                // add the home root to the new null node
                name = _T("/");
                value.Format(_T("%s,,%x"), g_pTheApp->m_csPathWWWRoot, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
                value.MakeLower();
                pNullNode->SetAt(name, value);

                // add it to the pMap
                pMap->SetAt(_T("null"), pNullNode);
            }
        }

        if (pMap->IsEmpty())
            {iisDebugOut((LOG_TYPE_TRACE, _T("UpgradeVDirs:No VDirs To Upgrade\n")));}
    }

    if ( pMap->IsEmpty() )
    {
        // we don't need to add a default website when
        // add home root to pNew, set pMap to contain null==>pNew. Done.
        name = _T("/");
        value.Format(_T("%s,,%x"), g_pTheApp->m_csPathWWWRoot, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
        value.MakeLower();
        pNew->SetAt(name, value);
        pMap->SetAt(_T("null"), pNew);
    }
    else
    {
        CMapStringToString *pNullObj;
        CString csIP;
        CMapStringToString *pObj;
        POSITION pos = NULL;

        // if there is a default website in the map, add all the "standard" new virtual
        // directories to it.
        if (pMap->Lookup(_T("null"), (CObject*&)pNullObj))
        {
            // add nullNode contents into pNew
            Merge2IPNodes(pNullObj, pNew);
        }

        // add pNew to each ipNodes in the pMap
        pos = pMap->GetStartPosition();
        while (pos)
        {
            pMap->GetNextAssoc(pos, csIP, (CObject*&)pObj);
            Merge2IPNodes(pNew, pObj);
            pMap->SetAt(csIP, pObj);
        }
/*
#ifdef 0        // boydm - we don't know why it would do this.
        // delete the nullNode if it doesn't contain home root
        if (pMap->Lookup(_T("null"), (CObject*&)pNullObj)) {
            if (pNullObj->Lookup(_T("/"), value) == FALSE) {
                // delete this nullNode from pMap
                delete pNullObj;
                pMap->RemoveKey(_T("null"));
            }
        }
#endif
*/
    }

    return;
}

void CreateFTPVRMap(CMapStringToOb *pMap)
{
    CString name, value;
    CMapStringToString *pNew;

    pNew = new CMapStringToString;

    if (g_pTheApp->m_eUpgradeType == UT_10_W95 || g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        CElem elem;
        elem.ReadRegVRoots(REG_FTPVROOTS, pMap);
    }

    if ( pMap->IsEmpty() )
    {
        // add home root to pNew, set pMap to contain null==>pNew. Done.
        name = _T("/");
        value.Format(_T("%s,,%x"), g_pTheApp->m_csPathFTPRoot, MD_ACCESS_READ);
        value.MakeLower();
        pNew->SetAt(name, value);
        pMap->SetAt(_T("null"), pNew);
    }
    else
    {
        CMapStringToString *pNullObj;
        CString csIP;
        CMapStringToString *pObj;
        POSITION pos = NULL;

        if (pMap->Lookup(_T("null"), (CObject*&)pNullObj))
        {
            // add nullNode contents into pNew
            Merge2IPNodes(pNullObj, pNew);
        }

        // add pNew to each ipNodes in the pMap
        pos = pMap->GetStartPosition();
        while (pos)
        {
            pMap->GetNextAssoc(pos, csIP, (CObject*&)pObj);
            Merge2IPNodes(pNew, pObj);
            pMap->SetAt(csIP, pObj);
        }

        // delete the nullNode if it doesn't contain home root
        if (pMap->Lookup(_T("null"), (CObject*&)pNullObj))
        {
            if (pNullObj->Lookup(_T("/"), value) == FALSE)
            {
                // delete this nullNode from pMap
                delete pNullObj;
                pMap->RemoveKey(_T("null"));
            }
        }
    }

    return;
}


void EmptyMap(CMapStringToOb *pMap)
{
    POSITION pos = pMap->GetStartPosition();
    while (pos)
    {
        CString csKey;
        CMapStringToString *pObj;
        pMap->GetNextAssoc(pos, csKey, (CObject*&)pObj);
        delete pObj;
    }
    pMap->RemoveAll();
}


void DumpVRootList(CMapStringToOb *pMap)
{
    /*
    CMapStringToString *pGlobalObj;
    if (pMap->Lookup(_T("null"), (CObject*&)pGlobalObj))
    {
        POSITION pos = pGlobalObj->GetStartPosition();
        while (pos)
        {
            CString csValue;
            CString csName;
            pGlobalObj->GetNextAssoc(pos, csName, csValue);
            // dump out the vroots...
            iisDebugOut((LOG_TYPE_TRACE, _T("DumpVRootList: Virtual Root to create():%s=%s\n")));
         }
    }
    */

    CString csIP;
    CMapStringToString *pObj;
    //
    // loop though the virtual servers...
    //
    POSITION pos0 = pMap->GetStartPosition();
    while (pos0)
    {
        csIP.Empty();
        pMap->GetNextAssoc(pos0, csIP, (CObject*&)pObj);

        POSITION pos1 = pObj->GetStartPosition();
        while (pos1)
        {
            CString csValue;
            CString csName;
            pObj->GetNextAssoc(pos1, csName, csValue);

            // dump out the vroots...
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("DumpVRootList: ip=%s:VRoot to create:%s=%s\n"), csIP, csName, csValue));
        }
    }

    return;
}

void SsyncVRoots(LPCTSTR szSvcName, CMapStringToOb *pMap)
{
    CString csParam = _T("System\\CurrentControlSet\\Services\\");
    csParam += szSvcName;
    csParam += _T("\\Parameters");

    CRegKey regParam(HKEY_LOCAL_MACHINE, csParam);
    if ((HKEY)regParam)
    {
        // remove the old virtual roots key
        regParam.DeleteTree(_T("Virtual Roots"));
/*
        CMapStringToString *pGlobalObj;
        if (pMap->Lookup(_T("null"), (CObject*&)pGlobalObj)) {
            // recreate the key
            CRegKey regVRoots(_T("Virtual Roots"), (HKEY)regParam);
            if ((HKEY)regVRoots) {
                POSITION pos = pGlobalObj->GetStartPosition();
                while (pos) {
                    CString csValue;
                    CString csName;
                    pGlobalObj->GetNextAssoc(pos, csName, csValue);
                    regVRoots.SetValue(csName, csValue);
                }
            }
        }
*/
    }
}

void AddVRootsToMD(LPCTSTR szSvcName)
{
    iisDebugOut_Start(_T("AddVRootsToMD"),LOG_TYPE_TRACE);

    CMapStringToOb Map;

    if (_tcsicmp(szSvcName, _T("W3SVC")) == 0)
    {
        CreateWWWVRMap(&Map);
    }

    if (_tcsicmp(szSvcName, _T("MSFTPSVC")) == 0)
    {
        CreateFTPVRMap(&Map);
    }

    //Display Virtuall roots which we should create!!!
    DumpVRootList(&Map);

    // all ssyncvroots seems to do is delete the old vroots from the registry, if there are any
    SsyncVRoots(szSvcName, &Map);

    // This actually takes the virtual website and root map
    // built in CreateWWWVRMap and applies it to the metabase
    AddVRMapToMD(szSvcName, &Map);

    EmptyMap(&Map);

    iisDebugOut_End(_T("AddVRootsToMD"),LOG_TYPE_TRACE);
    return;
}


// This routine scans through the virtual web sites and adds them to the metabase
// boydm - I removed much of the guts of this routine and put it into AddVirtualServer above.
// This allows me to treat the null node specially in order to guarantee it goes on site 1
void AddVRMapToMD(LPCTSTR szSvcName, CMapStringToOb *pMap)
{
    UINT i = 1;  // instance number is in range of 1 - 4 billion
    CString csRoot = _T("LM/");
    csRoot += szSvcName; //  "LM/W3SVC"
    csRoot.MakeUpper();
    CMapStringToString *pObj = NULL;
    CString csIP;

    // look for the null node. If it is there, then that is the default server.
    // we must add that one first so that it is virtual server number 1
    if ( pMap->Lookup(_T("null"),(CObject*&)pObj) )
        {
        // set the ip string to null
        csIP = _T("null");

        // add the virtual server
        // make sure to specify site #1 !!!
        i = AddVirtualServer( szSvcName, 1, pObj, csRoot, csIP) + 1;

        // remove the null mapping list from the main mapping object
        if ( pMap->RemoveKey( _T("null") ) )
            {
            // clean it up from memory too
            delete pObj;
            pObj = NULL;
            }
        }

    // loop though the rest of the virtual servers and add them as well
    POSITION pos0 = pMap->GetStartPosition();
    while (pos0)
    {
        csIP.Empty();
        pMap->GetNextAssoc(pos0, csIP, (CObject*&)pObj);

        // get the next unused instance number and add from there...
        i = GetInstNumber(csRoot, i);

        // add the virtual server
        i = AddVirtualServer( szSvcName, i, pObj, csRoot, csIP) + 1;
    }
}

int GetPortNum(LPCTSTR szSvcName)
{
    CString csPath = _T("SYSTEM\\CurrentControlSet\\Control\\ServiceProvider\\ServiceTypes\\");
    csPath += szSvcName;

    DWORD dwPort = 0;
    if (_tcsicmp(szSvcName, _T("W3SVC")) == 0) {dwPort = 80;}
    if (_tcsicmp(szSvcName, _T("MSFTPSVC")) == 0) {dwPort = 21;}

    CRegKey regKey(HKEY_LOCAL_MACHINE, csPath, KEY_READ);
    if ( (HKEY)regKey )
    {
        regKey.QueryValue(_T("TcpPort"), dwPort);
    }
    return (int)dwPort;
}

// if not exist, create it; else, return immediately
void AddMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP, UINT nProgressBarTextWebInstance)
{
    CString csPath = csKeyPath;
    CMDKey cmdKey;

    csPath += _T("/Root");
    if (csName.Compare(_T("/")) != 0)
        csPath += csName;   // LM/W3SVC/N//iisadmin

    cmdKey.OpenNode(csPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        cmdKey.Close();
    }
    else
    {
        CreateMDVRootTree(csKeyPath, csName, csValue, pszIP, nProgressBarTextWebInstance);
    }
    return;
}


int SetVRootPermissions_w3svc(CString csKeyPath, LPTSTR szPath, DWORD *pdwPerm)
{
    int iReturn = TRUE;
    DWORD dwPerm;
    dwPerm = *pdwPerm;
    if (csKeyPath.Find(_T("W3SVC")) != -1)
    {
        iisDebugOut_Start1(_T("SetVRootPermissions_w3svc"), csKeyPath, LOG_TYPE_TRACE);

        // if this is www, and it is because of the above test, then we always
        // turn on the MD_ACCESS_SCRIPT flag if MD_ACCESS_EXECUTE is on. This
        // fixes a Upgrade from IIS3 problem - boydm
        if ( dwPerm & MD_ACCESS_EXECUTE )
        {
            dwPerm |= MD_ACCESS_SCRIPT;
        }

        // add MD_ACCESS_SCRIPT to wwwroot
        if (csKeyPath.Right(4) == _T("ROOT"))
        {
            dwPerm |= MD_ACCESS_SCRIPT;
        }

        // reset /iisadmin path, add more Permission
        if (csKeyPath.Right(8) == _T("IISADMIN"))
        {
            CString csPath = g_pTheApp->m_csPathInetsrv;
            csPath += _T("\\iisadmin");
            _tcscpy(szPath, csPath);
            if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType != OT_NTW)
            {
                dwPerm |= MD_ACCESS_SCRIPT | MD_ACCESS_READ;
            }
            else
            {
                dwPerm |= MD_ACCESS_SCRIPT | MD_ACCESS_READ | MD_ACCESS_NO_REMOTE_READ | MD_ACCESS_NO_REMOTE_SCRIPT;
            }
        }

        *pdwPerm = dwPerm;
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("SetVRootPermissions_w3svc:(%s),return=0x%x.\n"), csKeyPath, dwPerm));
    return iReturn;
}

/*
[/W3SVC/1/ROOT]
     AccessPerm                    : [IF]    (DWORD)  0x201={Read Script}
     6039                          : [IF]    (DWORD)  0x1={1}
     VrPath                        : [IF]    (STRING) "c:\inetpub\wwwroot"
     KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
[/W3SVC/1/ROOT/IISADMIN]
      AccessPerm                    : [IF]    (DWORD)  0x201={Read Script}
      Authorization                 : [IF]    (DWORD)  0x4={NT}
      VrPath                        : [IF]    (STRING) "C:\WINNT\System32\inetsrv\iisadmin"
      KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
      IpSec                         : [IRF]   (BINARY) 0x18 00 00 80 20 00 00 80 3c 00 00 80 44 00 00 80 01 00 00 00 4c 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 02 00 00 00 02 00 00 00 04 00 00 00 00 00 00 00 4c 00 00 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff 7f 00 00 01
      CustomError                   : [IF]    (MULTISZ) "400,*,FILE,C:\WINNT\help\iisHelp\common\400.htm" "401,1,FILE,C:\WINNT\help\iisHelp\common\401-1.htm" "401,2,FILE,C:\WINNT\help\iisHelp\common\401-2.htm" "401,3,FILE,C:\WINNT\help\iisHelp\common\401-3.htm" "401,4,FILE,C:\WINNT\help\iisHelp\common\401-4.htm" "401,5,FILE,C:\WINNT\help\iisHelp\common\401-5.htm" "403,1,FILE,C:\WINNT\help\iisHelp\common\403-1.htm" "403,2,FILE,C:\WINNT\help\iisHelp\common\403-2.htm" "403,3,FILE,C:\WINNT\help\iisHelp\common\403-3.htm" "403,4,FILE,C:\WINNT\help\iisHelp\common\403-4.htm" "403,5,FILE,C:\WINNT\help\iisHelp\common\403-5.htm" "403,7,FILE,C:\WINNT\help\iisHelp\common\403-7.htm" "403,8,FILE,C:\WINNT\help\iisHelp\common\403-8.htm" "403,9,FILE,C:\WINNT\help\iisHelp\common\403-9.htm" "403,10,FILE,C:\WINNT\help\iisHelp\common\403-10.htm" "403,11,FILE,C:\WINNT\help\iisHelp\common\403-11.htm" "403,12,FILE,C:\WINNT\help\iisHelp\common\403-12.htm" "404,*,FILE,C:\WINNT\help\iisHelp\common\404b.htm" "405,*,FILE,C:\WINNT\help\iisHelp\common\405.htm" "406,*,FILE,C:\WINNT\help\iisHelp\common\406.htm" "407,*,FILE,C:\WINNT\help\iisHelp\common\407.htm" "412,*,FILE,C:\WINNT\help\iisHelp\common\412.htm" "414,*,FILE,C:\WINNT\help\iisHelp\common\414.htm" "500,12,FILE,C:\WINNT\help\iisHelp\common\500-12.htm" "500,13,FILE,C:\WINNT\help\iisHelp\common\500-13.htm" "500,15,FILE,C:\WINNT\help\iisHelp\common\500-15.htm" "500,100,URL,/help/common/500-100.asp" "403,6,FILE,C:\WINNT\help\iishelp\common\htmla.htm"
[/W3SVC/1/ROOT/IISSAMPLES]
      AccessPerm                    : [IF]    (DWORD)  0x201={Read Script}
      VrPath                        : [IF]    (STRING) "c:\inetpub\iissamples"
      KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
[/W3SVC/1/ROOT/IISHELP]
      AccessPerm                    : [IF]    (DWORD)  0x201={Read Script}
      VrPath                        : [IF]    (STRING) "c:\winnt\help\iishelp"
      KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
      CustomError                   : [IF]    (MULTISZ) "400,*,FILE,C:\WINNT\help\iisHelp\common\400.htm" "401,1,FILE,C:\WINNT\help\iisHelp\common\401-1.htm" "401,2,FILE,C:\WINNT\help\iisHelp\common\401-2.htm" "401,3,FILE,C:\WINNT\help\iisHelp\common\401-3.htm" "401,4,FILE,C:\WINNT\help\iisHelp\common\401-4.htm" "401,5,FILE,C:\WINNT\help\iisHelp\common\401-5.htm" "403,1,FILE,C:\WINNT\help\iisHelp\common\403-1.htm" "403,2,FILE,C:\WINNT\help\iisHelp\common\403-2.htm" "403,3,FILE,C:\WINNT\help\iisHelp\common\403-3.htm" "403,4,FILE,C:\WINNT\help\iisHelp\common\403-4.htm" "403,5,FILE,C:\WINNT\help\iisHelp\common\403-5.htm" "403,6,FILE,C:\WINNT\help\iisHelp\common\403-6.htm" "403,7,FILE,C:\WINNT\help\iisHelp\common\403-7.htm" "403,8,FILE,C:\WINNT\help\iisHelp\common\403-8.htm" "403,9,FILE,C:\WINNT\help\iisHelp\common\403-9.htm" "403,10,FILE,C:\WINNT\help\iisHelp\common\403-10.htm" "403,11,FILE,C:\WINNT\help\iisHelp\common\403-11.htm" "403,12,FILE,C:\WINNT\help\iisHelp\common\403-12.htm" "405,*,FILE,C:\WINNT\help\iisHelp\common\405.htm" "406,*,FILE,C:\WINNT\help\iisHelp\common\406.htm" "407,*,FILE,C:\WINNT\help\iisHelp\common\407.htm" "412,*,FILE,C:\WINNT\help\iisHelp\common\412.htm" "414,*,FILE,C:\WINNT\help\iisHelp\common\414.htm" "500,12,FILE,C:\WINNT\help\iisHelp\common\500-12.htm" "500,13,FILE,C:\WINNT\help\iisHelp\common\500-13.htm" "500,15,FILE,C:\WINNT\help\iisHelp\common\500-15.htm" "500,100,URL,/help/common/500-100.asp" "404,*,FILE,C:\WINNT\help\iishelp\common\404.htm"
[/W3SVC/1/ROOT/SCRIPTS]
      AccessPerm                    : [IF]    (DWORD)  0x204={Execute Script}
      VrPath                        : [IF]    (STRING) "c:\inetpub\scripts"
      KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
*/
void CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP, UINT nProgressBarTextWebInstance)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("CreateMDVRootTree():Start.%s.%s.%s.%s.\n"),csKeyPath,csName,csValue,pszIP));
    int iOverwriteAlways = TRUE;
    int iThisIsAnIISDefaultApp = FALSE;
    int iCreateAnApplicationForThis = FALSE;
    CMDKey cmdKey;
    CString csKeyPath_Copy;

    TCHAR szPath[_MAX_PATH], szUserName[_MAX_PATH];
    DWORD dwPerm, dwRegularPerm, dwSSLPerm;

    csKeyPath += _T("/Root");
    if (csName.Compare(_T("/")) != 0)
    {
        csKeyPath += csName;   // LM/W3SVC/N/Root/iisadmin
    }
    csKeyPath.MakeUpper();


    // let the user know what is going on which this vroot!
    UINT SvcId;
    SvcId = IDS_ADD_SETTINGS_FOR_WEB_2;
    if ( csKeyPath.Find(_T("MSFTPSVC")) != -1 ) {SvcId = IDS_ADD_SETTINGS_FOR_FTP_2;}

    //
    // see if we can create the node.  if we can't then return!
    //
    csKeyPath_Copy = csKeyPath;

    // Make it look good.
    if (csKeyPath.Right(8) == _T("IISADMIN"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 8);
        csKeyPath_Copy += _T("IISAdmin");
    }
    if (csKeyPath.Right(6) == _T("WEBPUB"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 6);
        csKeyPath_Copy += _T("Webpub");
    }

    if (csKeyPath.Right(10) == _T("IISSAMPLES"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 10);
        csKeyPath_Copy += _T("IISSamples");
    }

    if (csKeyPath.Right(7) == _T("IISHELP"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 7);
        csKeyPath_Copy += _T("IISHelp");
    }
    if (csKeyPath.Right(7) == _T("SCRIPTS"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 7);
        csKeyPath_Copy += _T("Scripts");
    }

    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, csKeyPath_Copy);
    if ( !(METADATA_HANDLE)cmdKey )
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateMDVRootTree():CreateNode %s.FAILED.\n"),csKeyPath_Copy));
        return;
    }
    cmdKey.Close();

    //
    // Get the virtual root data
    //
    memset( (PVOID)szPath, 0, sizeof(szPath));
    memset( (PVOID)szUserName, 0, sizeof(szUserName));
    SplitVRString(csValue, szPath, szUserName, &dwPerm);

    //
    // Set KeyType
    //
    if ( csKeyPath.Find(_T("W3SVC")) != -1 )
        WriteToMD_IIsWebVirtualDir(csKeyPath);
    else
        WriteToMD_IIsFtpVirtualDir(csKeyPath);

    //
    // Will return szPath and dwPerm.
    // Get the permissions
    //
    SetVRootPermissions_w3svc(csKeyPath, szPath, &dwPerm);

    //
    // Set The path of the virtual root.
    //
    // if this is the Default VRoot then, don't overwrite it if already there!!!
    //
    iOverwriteAlways = TRUE;
    if (csName.Compare(_T("/")) == 0) {iOverwriteAlways = FALSE;}
    WriteToMD_VRootPath(csKeyPath, szPath, iOverwriteAlways);

    //
    // Set regular permissions
    //
    dwRegularPerm = dwPerm & MD_NONSSL_ACCESS_MASK;
    dwSSLPerm = dwPerm & MD_SSL_ACCESS_MASK;
    // do not overwrite if the value is already there!
    WriteToMD_AccessPerm(csKeyPath, dwRegularPerm, FALSE);

    //
    // Set ssl permissions
    //
    // Do, not overwrite if the value is already there!
    //
    if (dwSSLPerm && (csKeyPath.Find(_T("W3SVC")) != -1))
    {
        WriteToMD_SSLPerm(csKeyPath, dwSSLPerm, FALSE);
    }

    //
    // iif iisadmin then set Authorization
    //
    if (csKeyPath.Right(8) == _T("IISADMIN"))
    {
        if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType != OT_NTW)
        {
            WriteToMD_Authorization(csKeyPath, MD_AUTH_NT);
        }

        // bug#340576
        // removed per bug#340576
        // should look like this: LM/W3SVC/N/Root/iisadmin
        //WriteToMD_AspCodepage(csKeyPath, 65001, FALSE);

        // bug#356345
        WriteToMD_EnableParentPaths_WWW(csKeyPath, TRUE);
    }

    //
    // if /IISHELP then make sure this is off bug356345
    //
    if (csKeyPath.Right(7) == _T("IISHELP"))
    {
        WriteToMD_EnableParentPaths_WWW(csKeyPath, FALSE);
    }

    //
    // if /IISSAMPLES then set dirbrowsing on.
    //
    if (csKeyPath.Right(10) == _T("IISSAMPLES"))
    {
        WriteToMD_DirBrowsing_WWW(csKeyPath);
    }

    // If username is something,
    // then let's get the password and save it to the metabase
    if (szUserName[0] != _T('\0'))
    {
        // do have username and path is UNC
        WriteToMD_VRUserName(csKeyPath, szUserName);

#ifndef _CHICAGO_
        CString csRoot;
        TCHAR szRootPassword[_MAX_PATH] = _T("");
        BOOL b;

        // if this is for the w3svc server...
        if (csKeyPath.Find(_T("W3SVC")) != -1)
        {
            if (!pszIP || !(*pszIP) || !(_tcsicmp(pszIP, _T("null"))))
            {
                // first, try <vroot>
                csRoot = csName;
                b = GetRootSecret(csRoot, _T("W3_ROOT_DATA"), szRootPassword);
                if (!b || !(*szRootPassword))
                {
                    // second, try <vroot>,
                    csRoot = csName + _T(",");
                    b = GetRootSecret(csRoot, _T("W3_ROOT_DATA"), szRootPassword);
                    if (!b)
                        *szRootPassword = _T('\0');
                }
            }
            else
            {
                csRoot = csName + _T(",");
                csRoot += pszIP;
                b = GetRootSecret(csRoot, _T("W3_ROOT_DATA"), szRootPassword);
                if (!b)
                    *szRootPassword = _T('\0');
            }
        }

        // if this is for the ftp server...
        if (csKeyPath.Find(_T("MSFTPSVC")) != -1)
        {
            if (!pszIP || !(*pszIP) || !(_tcsicmp(pszIP, _T("null"))))
            {
                // first, try <vroot>
                csRoot = csName;
                b = GetRootSecret(csRoot, _T("FTPD_ROOT_DATA"), szRootPassword);
                if (!b || !(*szRootPassword))
                {
                    // second, try <vroot>,
                    csRoot = csName + _T(",");
                    b = GetRootSecret(csRoot, _T("FTPD_ROOT_DATA"), szRootPassword);
                    if (!b)
                        *szRootPassword = _T('\0');
                }
            }
            else
            {
                csRoot = csName + _T(",");
                csRoot += pszIP;
                b = GetRootSecret(csRoot, _T("FTPD_ROOT_DATA"), szRootPassword);
                if (!b)
                    *szRootPassword = _T('\0');
            }
        }

        // if we have a password, then write it out
        if (*szRootPassword)
        {
            WriteToMD_VRPassword(csKeyPath, szRootPassword);
        }
#endif
    }


    //
    // If this is the W3svc service then
    // Create an Inprocess application for Certain Virtual Roots.
    //
    if (csKeyPath.Find(_T("W3SVC")) != -1)
    {
        CString csVirtualRootName;
        csVirtualRootName = csKeyPath;
        iCreateAnApplicationForThis = FALSE;
        iThisIsAnIISDefaultApp = FALSE;

        // maintain backward compatibility
        // Any vroot with execute permissions is an application
        if ((g_pTheApp->m_eInstallMode == IM_UPGRADE) && (dwPerm & MD_ACCESS_EXECUTE))
        {
            // Set this to true so that this previous iis application will
            // be created as an com+ applicaton
            iCreateAnApplicationForThis = TRUE;

            // but if this is the msadc vroot then don't set as an application
            // removed per bug 340993 make RDS vroot run oop
            //if (csKeyPath.Right(5) == _T("MSADC")) {iCreateAnApplicationForThis = FALSE;}
        }


        // on a fresh install MSADC needs to be it's owned pooled application
        // on an upgrade just leave it alone.
        if (csKeyPath.Right(5) == _T("MSADC")) {csVirtualRootName = csKeyPath.Right(5); iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        // if these are our paths then createinproc them
        if (csKeyPath.Right(4) == _T("ROOT")) {csVirtualRootName = csKeyPath.Right(4); iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (csKeyPath.Right(8) == _T("IISADMIN")) {csVirtualRootName = csKeyPath.Right(8);iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (csKeyPath.Right(6) == _T("WEBPUB")) {csVirtualRootName = csKeyPath.Right(6);iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (csKeyPath.Right(10) == _T("IISSAMPLES")) {csVirtualRootName = csKeyPath.Right(10);iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (csKeyPath.Right(7) == _T("IISHELP")) {csVirtualRootName = csKeyPath.Right(7);iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (TRUE == iCreateAnApplicationForThis)
        {
            // If this is an upgrade from a previous iis which has a metabase, then
            // Upgrades should leave in-process apps, in-process.
            // Including default sites because they might be running ISAPIs.
            if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
            {
                // Since this upgrade already has a metabase,
                // Leave the default applications and other user
                // applications the way they already are

                // check to see if the appID property exists...
                // if it doesn't then set the property
                if (FALSE == DoesAppIsolatedExist(csKeyPath))
                {
                    // there is no app isolated on this node.
                    iisDebugOut((LOG_TYPE_WARN, _T("No AppIsolated specified for (%s)\n"),csKeyPath));
                }
                else
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("AppIsolated exists for (%s)\n"),csKeyPath));
                }
            }
            else
            {
                if (iThisIsAnIISDefaultApp)
                {
                    // create an inprocess application which uses the OOP Pool
                    // Use The pool since these are "our" vdirs
                    CreateInProc_Wrap(csKeyPath, TRUE);
                }
                else
                {
                    // create an in process application
                    // upgraded iis 2.0/3.0 asp vdirs should
                    // be using this since they were all in-proc in iis 2.0/3.0
                    CreateInProc_Wrap(csKeyPath, FALSE);
                }
            }
        }

        /* Bug114531: no need to add scriptmap under /iisHelp
        if (csKeyPath.Right(7) == _T("IISHELP")) {
            // add script map
            ScriptMapNode ScriptMapList = {0};
            // make it a sentinel
            ScriptMapList.next = &ScriptMapList;
            ScriptMapList.prev = &ScriptMapList;

            GetScriptMapListFromMetabase(&ScriptMapList);
            WriteScriptMapListToMetabase(&ScriptMapList, (LPTSTR)(LPCTSTR)csKeyPath, MD_SCRIPTMAPFLAG_SCRIPT | MD_SCRIPTMAPFLAG_CHECK_PATH_INFO);

            FreeScriptMapList(&ScriptMapList);
        }
        */
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("CreateMDVRootTree():End.%s.%s.%s.%s.\n"),csKeyPath,csName,csValue,pszIP));
}


void SplitVRString(CString csValue, LPTSTR szPath, LPTSTR szUserName, DWORD *pdwPerm)
{
    // csValue should be in format of "<path>,<username>,<perm>"
    // with one exception: IISv1.0 has format of "<Path>"
    CString csPath, csUserName, csPerm;
    int len, i;

    csValue.TrimLeft();
    csValue.TrimRight();
    csPath = _T("");
    csUserName = _T("");
    csPerm = _T("");
    *pdwPerm = 0;

    i = csValue.ReverseFind(_T(','));
    if (i != -1)
    {
        len = csValue.GetLength();
        csPerm = csValue.Right(len - i - 1);
        csValue = csValue.Left(i);

        *pdwPerm = atodw((LPCTSTR)csPerm);

        i = csValue.ReverseFind(_T(','));
        if (i != -1)
        {
            len = csValue.GetLength();
            csUserName = csValue.Right(len - i - 1);
            csPath = csValue.Left(i);
        }
    }
    else
    {
        // assume it is the format of "<Path>"
        csPath = csValue;
    }
    _tcscpy(szPath, (LPCTSTR)csPath);
    _tcscpy(szUserName, (LPCTSTR)csUserName);

    return;
}



// loop thru the metabase
// and look for the next instance number which is not used!
// return that.  "i" is at least = 1.
UINT GetInstNumber(LPCTSTR szMDPath, UINT i)
{
    TCHAR Buf[10];
    CString csInstRoot, csMDPath;
    CMDKey cmdKey;

    csInstRoot = szMDPath;
    csInstRoot += _T("/");

    _itot(i, Buf, 10);
    csMDPath = csInstRoot + Buf;
    cmdKey.OpenNode(csMDPath);
    while ( (METADATA_HANDLE)cmdKey )
    {
        cmdKey.Close();
        _itot(++i, Buf, 10);
        csMDPath = csInstRoot + Buf;
        cmdKey.OpenNode(csMDPath);
    }
    return (i);
}

BOOL ChkMdEntry_Exist(MDEntry *pMDEntry)
{
    BOOL    bReturn = FALSE;
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    MDEntry MDEntryTemp;

    MDEntryTemp.szMDPath =  pMDEntry->szMDPath;

    //_tcscpy(MDEntryTemp.szMDPath,pMDEntry->szMDPath);
    MDEntryTemp.dwMDIdentifier = pMDEntry->dwMDIdentifier;
    MDEntryTemp.dwMDAttributes = pMDEntry->dwMDAttributes;
    MDEntryTemp.dwMDUserType = pMDEntry->dwMDUserType;
    MDEntryTemp.dwMDDataType = pMDEntry->dwMDDataType;
    MDEntryTemp.dwMDDataLen = pMDEntry->dwMDDataLen;
    MDEntryTemp.pbMDData = NULL;

    // if the attributes = METADATA_INHERIT
    // then let's just make sure that we check using the METADATA_NO_ATTRIBUTES deal.
    if (MDEntryTemp.dwMDAttributes == METADATA_INHERIT)
    {
        MDEntryTemp.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    }

    // Check if this is for the  binary type
    if (MDEntryTemp.dwMDDataType == BINARY_METADATA)
    {
        BOOL bFound = FALSE;
        DWORD attr, uType, dType, cbLen;
        CMDKey cmdKey;
        BUFFER bufData;
        PBYTE pData;
        int BufSize;

        cmdKey.OpenNode((LPCTSTR) MDEntryTemp.szMDPath);
        if ( (METADATA_HANDLE) cmdKey )
        {
            pData = (PBYTE)(bufData.QueryPtr());
            BufSize = bufData.QuerySize();
            cbLen = 0;
            bFound = cmdKey.GetData(MDEntryTemp.dwMDIdentifier, &attr, &uType, &dType, &cbLen, pData, BufSize);
            if (bFound)
            {
                bReturn = TRUE;
            }
            else
            {
                if (cbLen > 0)
                {
                    if ( ! (bufData.Resize(cbLen)) )
                    {
                        iisDebugOut((LOG_TYPE_ERROR, _T("ChkMdEntry_Exist():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                    }
                    else
                    {
                        pData = (PBYTE)(bufData.QueryPtr());
                        BufSize = cbLen;
                        cbLen = 0;
                        //bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                        bFound = cmdKey.GetData(MDEntryTemp.dwMDIdentifier, &attr, &uType, &dType, &cbLen, pData, BufSize);
                        if (bFound)
                        {
                            bReturn = TRUE;
                        }
                        else
                        {
                            // No the acl Does not exist!
                        }
                    }
                }
                else
                {
                    // No the acl Does not exist!
                }
            }

            cmdKey.Close();
        }
    }
    else
    {
        // Check the metabase and see if the big Key /LM/W3SVC is there
        cmdKey.OpenNode((LPCTSTR) MDEntryTemp.szMDPath);
        if ( (METADATA_HANDLE)cmdKey )
        {
            // Check to see if our little Identifier is there.
            //DWORD dwAttr = METADATA_INHERIT;
            //DWORD dwUType = IIS_MD_UT_SERVER;
            //DWORD dwDType = MULTISZ_METADATA;
            //DWORD dwLength = 0;
            DWORD dwAttr = MDEntryTemp.dwMDAttributes;
            DWORD dwUType = MDEntryTemp.dwMDUserType;
            DWORD dwDType = MDEntryTemp.dwMDDataType;
            DWORD dwLength = 0;

            // we need to start this process by getting the existing multisz data from the metabase
            // first, figure out how much memory we will need to do this
            cmdKey.GetData( MDEntryTemp.dwMDIdentifier,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,MDEntryTemp.dwMDAttributes,MDEntryTemp.dwMDUserType,MDEntryTemp.dwMDDataType);

            // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
            // passing in a null ponter of 0 size in order to get the length of the data, it will always
            // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
            // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
            // in again.
            TCHAR*      pOurBuffer;
            DWORD       cbBuffer = dwLength;

            // This GetData call is supposed to return back the size of the string we're supposed to alloc.
            // if the string is "Test", then since it's unicode the return would be ((4+1)*2) = 10.
            // if the string is " ", then it would be (1+1)*2=4
            // it should never be something as small as 2.
            /*
            if (cbBuffer <= 2)
            {
                if (dwDType == STRING_METADATA || dwDType == EXPANDSZ_METADATA)
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("ChkMdEntry_Exist[%s:%d].requested size of this property reported back=%2.  which is too small for a string.\n"), MDEntryTemp.szMDPath, MDEntryTemp.dwMDIdentifier, cbBuffer));
                }
            }
            */

            // allocate the space, if it fails, we fail
            // note that GPTR causes it to be initialized to zero
            pData = GlobalAlloc( GPTR, cbBuffer );
            if ( !pData )
                {
                iisDebugOut((LOG_TYPE_ERROR, _T("ChkMdEntry_Exist(%d). Failed to allocate memory.\n"), MDEntryTemp.dwMDIdentifier));
                // We Failed to allocate memory
                cmdKey.Close();
                goto ChkMdEntry_Exist_Exit;
                }
            pOurBuffer = (TCHAR*)pData;

            // now get the data from the metabase
            int iTemp = FALSE;
            iTemp = cmdKey.GetData( MDEntryTemp.dwMDIdentifier,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,MDEntryTemp.dwMDAttributes,MDEntryTemp.dwMDUserType,MDEntryTemp.dwMDDataType);
            if (iTemp)
            {
                // if we have successfully retrieved the data, then we don't need to overwrite it!
                bReturn = TRUE;
            }
            cmdKey.Close();
        }
    }

ChkMdEntry_Exist_Exit:
    if (pData){GlobalFree(pData);pData=NULL;}
    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(MDEntryTemp.dwMDIdentifier, lpReturnString);
    if (bReturn)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("ChkMdEntry_Exist[%s:%d:%s]. Exists.\n"), MDEntryTemp.szMDPath, MDEntryTemp.dwMDIdentifier, lpReturnString));
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("ChkMdEntry_Exist[%s:%d:%s]. Not Exists.\n"), MDEntryTemp.szMDPath, MDEntryTemp.dwMDIdentifier, lpReturnString));
    }
    return bReturn;
}


DWORD SetMDEntry_Wrap(MDEntry *pMDEntry)
{
    DWORD  dwReturn = ERROR_SUCCESS;
    int iFoundFlag = FALSE;

    CString csKeyPath = pMDEntry->szMDPath;

    ACTION_TYPE atWWWorFTPorCORE;
    if (csKeyPath.Find(_T("W3SVC")) == -1)
    {
        iFoundFlag = TRUE;
        atWWWorFTPorCORE = GetSubcompAction(_T("iis_www"), FALSE);
    }

    if (iFoundFlag != TRUE)
    {
        if (csKeyPath.Find(_T("MSFTPSVC")) == -1)
        {
            iFoundFlag = TRUE;
            atWWWorFTPorCORE = GetSubcompAction(_T("iis_ftp"), FALSE);
        }
    }

    if (iFoundFlag != TRUE)
    {
        iFoundFlag = TRUE;
        atWWWorFTPorCORE = GetSubcompAction(_T("iis_core"), FALSE);
    }

    if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
        dwReturn = SetMDEntry_NoOverWrite(pMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry(pMDEntry);
    }

    return dwReturn;
}

DWORD DeleteMDEntry(MDEntry *pMDEntry)
{
    CMDKey cmdKey;
    DWORD  dwReturn = ERROR_SUCCESS;

    // Check if it exists first...
    if (ChkMdEntry_Exist(pMDEntry))
    {
        cmdKey.OpenNode((LPCTSTR) pMDEntry->szMDPath);
        if ( (METADATA_HANDLE)cmdKey )
        {
            // Delete the data
            dwReturn = cmdKey.DeleteData(pMDEntry->dwMDIdentifier, pMDEntry->dwMDDataType);
            cmdKey.Close();
        }
    }

    if (FAILED(dwReturn))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("DeleteMDEntry(%d).FAILED.\n"), pMDEntry->dwMDIdentifier));
    }
    return dwReturn;
}



DWORD SetMDEntry(MDEntry *pMDEntry)
{
    CMDKey cmdKey;
    DWORD  dwReturn = ERROR_SUCCESS;

    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)pMDEntry->szMDPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        dwReturn = ERROR_SUCCESS;
        dwReturn = cmdKey.SetData(pMDEntry->dwMDIdentifier,pMDEntry->dwMDAttributes,pMDEntry->dwMDUserType,pMDEntry->dwMDDataType,pMDEntry->dwMDDataLen,pMDEntry->pbMDData);
        // output what we set to the log file...
        if (FAILED(dwReturn))
        {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), pMDEntry->dwMDIdentifier, dwReturn));
        }
        cmdKey.Close();
    }

    if (g_CheckIfMetabaseValueWasWritten == TRUE)
    {
        // Check if the entry now exists....
        if (!ChkMdEntry_Exist(pMDEntry))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry(%d). Entry which we were supposed to write, does not exist! FAILURE.\n"), pMDEntry->dwMDIdentifier));
        }
    }

    return dwReturn;
}


//  -------------------------------------------
//  MDEntry look something like this:
//
//  stMDEntry.szMDPath = _T("LM/W3SVC");
//  stMDEntry.dwMDIdentifier = MD_NTAUTHENTICATION_PROVIDERS;
//  stMDEntry.dwMDAttributes = METADATA_INHERIT;
//  stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
//  stMDEntry.dwMDDataType = STRING_METADATA;
//  stMDEntry.dwMDDataLen = (csData.GetLength() + 1) * sizeof(TCHAR);
//  stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csData;
//  -------------------------------------------
DWORD SetMDEntry_NoOverWrite(MDEntry *pMDEntry)
{
    DWORD  dwReturn = ERROR_SUCCESS;
    if (ChkMdEntry_Exist(pMDEntry))
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("SetMDEntry_NoOverWrite:SetData(%d). Do not overwrite entry.\n"), pMDEntry->dwMDIdentifier));
    }
    else
    {
        dwReturn = SetMDEntry(pMDEntry);
    }
    return dwReturn;
}


int MigrateInfSectionToMD(HINF hFile, LPCTSTR szSection)
{
    iisDebugOut_Start1(_T("MigrateInfSectionToMD"),(LPTSTR) szSection, LOG_TYPE_TRACE);

    int iReturn = FALSE;
    MDEntry stMDEntry;
    LPTSTR szLine = NULL;
    DWORD dwLineLen = 0, dwRequiredSize;
    INT iType = 0;

    BOOL b = FALSE;

    INFCONTEXT Context;

    if ((g_pbData = (LPBYTE)malloc(1024)) == NULL)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.1.Failed to allocate memory.\n"), szSection));
        // failed to malloc
        goto MigrateInfSectionToMD_Exit;
    }

    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.FailedSetupFindFirstLine call.\n"), szSection));
        // failed the SetupFindFirstLine call
        goto MigrateInfSectionToMD_Exit;
    }

    if ( ( szLine = (LPTSTR)calloc(1024, sizeof(TCHAR)) ) != NULL )
    {
        dwLineLen = 1024;
    }
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.2.Failed to allocate memory.\n"), szSection));
        // failed something
        goto MigrateInfSectionToMD_Exit;
    }

    while (b)
    {
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize > dwLineLen)
        {
            free(szLine);
            szLine = NULL;
            if ( ( szLine = (LPTSTR)calloc(dwRequiredSize, sizeof(TCHAR)) ) != NULL )
            {
                dwLineLen = dwRequiredSize;
            }
            else
            {
                // failed something
                iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.3.Failed to allocate memory.\n"), szSection));
                goto MigrateInfSectionToMD_Exit;
            }
        }

        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.3.Failed SetupGetLineText call.\n"), szSection));
            // failed SetupGetLineText call
            goto MigrateInfSectionToMD_Exit;
        }

        if ( ( ( *szLine >= 'a' ) && ( *szLine <= 'z') ) ||
             ( ( *szLine >= 'A' ) && ( *szLine <= 'Z') )
           )
        {
          CParse ParseLine;

          ParseLine.ParseLine(&(g_pTheApp->FuncDict),szLine);
        }
        else
        {
            iType = GetMDEntryFromInfLine(szLine, &stMDEntry);
            if ( MDENTRY_FROMINFFILE_FAILED != iType )
                {
                    if (MDENTRY_FROMINFFILE_DO_DEL == iType)
                    {
                        DeleteMDEntry(&stMDEntry);
                    }
                    else
                        if (MDENTRY_FROMINFFILE_DO_ADD == iType)
                        {
                            SetMDEntry_Wrap(&stMDEntry);
                        }
                    // We had success in setting the key
                    iReturn = TRUE;
                }
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.3.Failed GetMDEntryFromInfLine call.\n"), szSection));
            }
        }

        b = SetupFindNextLine(&Context, &Context);
    }

MigrateInfSectionToMD_Exit:
    if (szLine) {free(szLine);szLine=NULL;}
    if (g_pbData){free(g_pbData);g_pbData=NULL;}
    iisDebugOut_End1(_T("MigrateInfSectionToMD"),(LPTSTR) szSection,LOG_TYPE_TRACE);
    return iReturn;
}

/*
#define METADATA_INHERIT                0x00000001
IIS_MD_UT_SERVER    1
DWORD_METADATA      1

1   0   HKLM    System\CurrentControlSet\Services\W3SVC\Parameters  MaxConnections
LM/W3SVC    1014    1   1   1   4   20
*/

void DumpMimeMap(CMapStringToString *mimeMap)
{
    POSITION pos = NULL;
    CString csName;
    CString csValue;

    pos = mimeMap->GetStartPosition();
    while (pos)
    {
        mimeMap->GetNextAssoc(pos, csName, csValue);

        // output
        iisDebugOut((LOG_TYPE_WARN, _T("DumpMimeMap:%s=%s\n"), csName, csValue));
    }
}

void InstallMimeMap()
{
    CMapStringToString mimeMap;
    TSTR strTheSection;

    if ( g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        CreateMimeMapFromRegistry(&mimeMap);
    }
    else
    {
        if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
        {
            ReadMimeMapFromMetabase(&mimeMap);
        }
    }

    if ( strTheSection.Copy( _T("MIMEMAP") ) &&
         GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection )
       )
    {
        ReadMimeMapFromInfSection(&mimeMap, g_pTheApp->m_hInfHandle, strTheSection.QueryStr() , TRUE);
    }

    // DumpMimeMap(&mimeMap);

    if (mimeMap.IsEmpty() == FALSE)
    {
        // install it into the metabase

        // first construct the MULTISZ string
        BUFFER bufData;
        DWORD cbBufLen;
        BYTE *pData;

        cbBufLen = bufData.QuerySize();
        pData = (BYTE *) (bufData.QueryPtr());
        ZeroMemory( pData, cbBufLen );

        LPTSTR p = (LPTSTR)pData;
        CString csName, csValue, csString;
        DWORD cbRequiredLen, cbIncreasedLen;
        DWORD cbDataLen = 0;

        POSITION pos = NULL;
        pos = mimeMap.GetStartPosition();
        while (pos)
        {
             mimeMap.GetNextAssoc(pos, csName, csValue);
             csString.Format(_T(".%s,%s"), csName, csValue);
             cbIncreasedLen = csString.GetLength()*sizeof(TCHAR) + 1*sizeof(TCHAR);
             cbRequiredLen = cbDataLen + cbIncreasedLen + 1 * sizeof(TCHAR);
             if (cbRequiredLen > cbBufLen)
             {
                 if (bufData.Resize(cbRequiredLen))
                 {
                     cbBufLen = bufData.QuerySize();

                     // move the pointer to the end
                     pData = (BYTE *)(bufData.QueryPtr());
                     p = (LPTSTR)(pData + cbDataLen);

//                   p = _tcsninc(p, cbDataLen / sizeof(TCHAR));
                 }
                 else
                 {
                     // insufficient buffer
                     return;
                 }
             }
             _tcscpy(p, csString);
             p += csString.GetLength() + 1;
             cbDataLen += cbIncreasedLen;
        }
        *p = _T('\0');
        p = _tcsinc(p);
        cbDataLen += sizeof(TCHAR);

        CMDKey cmdKey;
        cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, _T("LM/MimeMap"));
        if ( (METADATA_HANDLE)cmdKey )
        {
            cmdKey.SetData(MD_MIME_MAP,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA,cbDataLen,(LPBYTE)pData );

            CString csKeyType = _T("IIsMimeMap");
            cmdKey.SetData(MD_KEY_TYPE,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA,(csKeyType.GetLength() + 1) * sizeof(TCHAR),(LPBYTE)(LPCTSTR)csKeyType );

            cmdKey.Close();
        }
    }

    CRegKey regInetinfoParam(HKEY_LOCAL_MACHINE, REG_INETINFOPARAMETERS);
    if ( (HKEY)regInetinfoParam )
    {
        regInetinfoParam.DeleteTree(_T("MimeMap"));
    }

    return;
}

void ReadMimeMapFromMetabase(CMapStringToString *pMap)
{
    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    LPTSTR p, rest, token;
    CString csName, csValue;
    PBYTE pData;
    int BufSize;

    cmdKey.OpenNode(_T("LM/MimeMap"));
    if ( (METADATA_HANDLE)cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_MIME_MAP, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound && (cbLen > 0))
        {
            if ( ! (bufData.Resize(cbLen)) )
            {
                cmdKey.Close();
                return;  // insufficient memory
            }
            else
            {
                pData = (PBYTE)(bufData.QueryPtr());
                BufSize = cbLen;
                cbLen = 0;
                bFound = cmdKey.GetData(MD_MIME_MAP, &attr, &uType, &dType, &cbLen, pData, BufSize);
            }
        }
        cmdKey.Close();

        if (bFound && (dType == MULTISZ_METADATA))
        {
            p = (LPTSTR)pData;
            while (*p)
            {
                rest = _tcsninc(p, _tcslen(p))+1;
                p = _tcsinc(p); // bypass the first dot
                token = _tcstok(p, _T(","));
                if (token)
                {
                    csName = token;
                    token = _tcstok(NULL, _T(","));
                    csValue = token;
                    pMap->SetAt(csName, csValue);
                }
                p = rest; // points to the next string
            }
        }
    }

    return;
}

BOOL CreateMimeMapFromRegistry(CMapStringToString *pMap)
{
    // make sure we start from an empty Map
    pMap->RemoveAll();

    CRegKey regMimeMap(HKEY_LOCAL_MACHINE, REG_MIMEMAP, KEY_READ);

    if ( (HKEY)regMimeMap )
    {
        CRegValueIter regEnum( regMimeMap );
        CString csName, csValue;

        while ( regEnum.Next( &csName, &csValue ) == ERROR_SUCCESS )
        {
            TCHAR szLine[_MAX_PATH];
            LPTSTR token;
            _tcscpy(szLine, csName);
            token = _tcstok(szLine, _T(","));
            if (token)
            {
                csValue = token;
                csValue.TrimLeft();
                csValue.TrimRight();
                // get rid of the leftside double-quotes
                if (csValue.Left(1) == _T("\""))
                {
                    csValue = csValue.Mid(1);
                }

                token = _tcstok(NULL, _T(","));
                if (token)
                    csName = token;
                else
                    csName = _T("");

                // get rid of the surrounding double-quotes
                csName.TrimLeft();
                csName.TrimRight();

               if (csName.IsEmpty() == FALSE)
               {
                    pMap->SetAt(csName, csValue);
               }
            }
        }
    }

    return (!(pMap->IsEmpty()));
}

BOOL CreateMimeMapFromInfSection(CMapStringToString *pMap, HINF hFile, LPCTSTR szSection)
{
    // make sure we start from an empty Map
    pMap->RemoveAll();
    ReadMimeMapFromInfSection(pMap, hFile, szSection, TRUE);
    return (!(pMap->IsEmpty()));
}


// mime map in inf file should look something like this:
//
// [MIMEMAP]
// "text/html,htm,,h"
// "image/gif,gif,,g"
// "image/jpeg,jpg,,:"
// "text/plain,txt,,0"
// "text/html,html,,h"
// "image/jpeg,jpeg,,:"
// "image/jpeg,jpe,,:"
// "image/bmp,bmp,,:"
// "application/octet-stream,*,,5"
// "application/pdf,pdf,,5"
// "application/octet-stream,bin,,5"
//
void ReadMimeMapFromInfSection(CMapStringToString *pMap, HINF hFile, LPCTSTR szSection, BOOL fAction)
{
    LPTSTR szLine;
    BOOL b = FALSE;
    DWORD dwLineLen = 0, dwRequiredSize;
    CString csTempString;

    INFCONTEXT Context;
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if ( ( szLine = (LPTSTR)calloc(1024, sizeof(TCHAR)) ) != NULL )
        dwLineLen = 1024;
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("ReadMimeMapFromInfSection.1.Failed to allocate memory.\n")));
        return;
    }

    while (b)
    {
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize > dwLineLen)
        {
            free(szLine);
            szLine = NULL;
            if ( ( szLine = (LPTSTR)calloc(dwRequiredSize, sizeof(TCHAR)) ) != NULL )
                dwLineLen = dwRequiredSize;
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("ReadMimeMapFromInfSection.2.Failed to allocate memory.\n")));
                return;
            }
        }
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL))
        {
            CString csName, csValue;
            LPTSTR token;
            token = _tcstok(szLine, _T(","));
            if (token)
            {
                // "text/html,htm,,h"
                // csValue=text/html
                // ===========
                csValue = token;
                csValue.TrimLeft();
                csValue.TrimRight();
                // get rid of the leftside double-quotes
                if (csValue.Left(1) == _T("\""))
                    csValue = csValue.Mid(1);
                /*
                if (csName.Right(1) == _T("\""))
                    csName = csName.Left(csName.GetLength() - 1);
                 */

                // "text/html,htm,,h"
                // name=htm
                // ===========
                token = _tcstok(NULL, _T(","));
                if (token)
                    csName = token;
                else
                    csName = _T("");

                // get rid of the surrounding double-quotes
                csName.TrimLeft();
                csName.TrimRight();
                /*
                if (csName.Left(1) == _T("\""))
                    csName = csName.Mid(1);
                if (csName.Right(1) == _T("\""))
                    csName = csName.Left(csName.GetLength() - 1);
                */
                if (csName.IsEmpty() == FALSE)
                {
                    if (fAction)
                    {
                        // Check if this extension already exists in the list.
                        // if it does then don't overwrite it.
                        if (0 == pMap->Lookup( csName, csTempString) )
                        {
                            // otherwise add new extensions
                            pMap->SetAt(csName, csValue);
                        }
                    }
                    else
                    {
                        // remove old extensions
                        pMap->RemoveKey(csName);
                    }
                }
            }
        }

        b = SetupFindNextLine(&Context, &Context);
    }

    if (szLine) {free(szLine);szLine=NULL;}
    return;
}

void ReadMultiSZFromInfSection(CString *pcsMultiSZ, HINF hFile, LPCTSTR szSection)
{
    LPTSTR szLine;
    BOOL b = FALSE;
    DWORD dwLineLen = 0, dwRequiredSize;

    INFCONTEXT Context;
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if ( ( szLine = (LPTSTR)calloc(1024, sizeof(TCHAR)) ) != NULL )
        dwLineLen = 1024;
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("ReadMultiSZFromInfSection.1.Failed to allocate memory.\n")));
        return;
    }
    while (b)
    {
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize > dwLineLen)
        {
            free(szLine);
            szLine=NULL;
            if ( ( szLine = (LPTSTR)calloc(dwRequiredSize, sizeof(TCHAR)) ) != NULL )
                dwLineLen = dwRequiredSize;
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("ReadMultiSZFromInfSection.2.Failed to allocate memory.\n")));
                return;
            }
        }
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL))
        {
            _tcscat(szLine, _T("|"));
            (*pcsMultiSZ) += szLine;
        }

        b = SetupFindNextLine(&Context, &Context);
    }

    if (szLine) {free(szLine);szLine=NULL;}
    if (pcsMultiSZ->IsEmpty()) {(*pcsMultiSZ) = _T("|");}
    return;
}

void SetLogPlugInOrder(LPCTSTR lpszSvc)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;

    DWORD dwLogType;
    DWORD dwLogFileTruncateSize = 0x1400000;
    CString csLogPlugInOrder;
    DWORD dwLogFilePeriod;
    DWORD extField = 0;

#ifndef _CHICAGO_
    dwLogType = MD_LOG_TYPE_ENABLED;
    csLogPlugInOrder = EXTLOG_CLSID;
    dwLogFilePeriod = MD_LOGFILE_PERIOD_DAILY;
    extField = DEFAULT_EXTLOG_FIELDS | EXTLOG_WIN32_STATUS;
#else   // CHICAGO
    //
    // win95
    //
    dwLogType = MD_LOG_TYPE_DISABLED;
    csLogPlugInOrder = NCSALOG_CLSID;
    dwLogFilePeriod = MD_LOGFILE_PERIOD_MONTHLY;
#endif // _CHICAGO_

    if (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        CString csParam = _T("System\\CurrentControlSet\\Services");
        csParam += _T("\\");
        csParam += lpszSvc;
        csParam += _T("\\Parameters");
        CRegKey regParam(csParam, HKEY_LOCAL_MACHINE);
        if ((HKEY)regParam)
        {
            DWORD dwType, dwFormat;
            regParam.QueryValue(_T("LogFilePeriod"), dwLogFilePeriod);
            regParam.QueryValue(_T("LogFileTruncateSize"), dwLogFileTruncateSize);
            if (regParam.QueryValue(_T("LogType"), dwType) == ERROR_SUCCESS)
            {
                switch (dwType)
                {
                    case INET_LOG_TO_SQL:
                        csLogPlugInOrder = ODBCLOG_CLSID;
                        break;
                    case INET_LOG_TO_FILE:
                        if (regParam.QueryValue(_T("LogFileFormat"), dwFormat) == ERROR_SUCCESS)
                        {
                            switch (dwFormat)
                            {
                                case INET_LOG_FORMAT_NCSA:
                                    csLogPlugInOrder = NCSALOG_CLSID;
                                    break;
                                case INET_LOG_FORMAT_INTERNET_STD:
                                    csLogPlugInOrder = ASCLOG_CLSID;
                                    break;
                                default:
                                    break;
                            }
                        }
                        break;
                    case INET_LOG_DISABLED:
                        dwLogType = MD_LOG_TYPE_DISABLED;
                        break;
                    default:
                        break;
                }
            }
            //delete LogFilePeriod, LogFileFormat, LogType
            regParam.DeleteValue(_T("LogFilePeriod"));
            regParam.DeleteValue(_T("LogFileTruncateSize"));
            regParam.DeleteValue(_T("LogFileFormat"));
            regParam.DeleteValue(_T("LogType"));
        }
    }

    if ((dwLogFilePeriod >= MD_LOGFILE_PERIOD_DAILY) && (dwLogFileTruncateSize > 0x1400000) ) {dwLogFileTruncateSize = 0x1400000;}

    MDEntry stMDEntry;

    //
    // set LogType, LogPluginOrder, LogFilePeriod in the metabase
    //
    CString csKeyPath = _T("LM/");
    csKeyPath += lpszSvc;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_LOG_TYPE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwLogType;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_LOG_PLUGIN_ORDER;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csLogPlugInOrder.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csLogPlugInOrder;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_LOGFILE_PERIOD;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwLogFilePeriod;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_LOGFILE_TRUNCATE_SIZE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwLogFileTruncateSize;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    if ( extField != 0 )
    {
        stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
        stMDEntry.dwMDIdentifier = MD_LOGEXT_FIELD_MASK;
        stMDEntry.dwMDAttributes = METADATA_INHERIT;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = DWORD_METADATA;
        stMDEntry.dwMDDataLen = sizeof(DWORD);
        stMDEntry.pbMDData = (LPBYTE)&extField;
        dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}
    }
    return;
}


//------------------------------------------------------------------------------------
// make sure that virtual server 1 can be accessed by local host. This involves reading in
// the existing bindings. Then, if it is all unassigned we are OK. If 127.0.0.1 is there
// we are OK. Otherwise, we need to add 127.0.0.1:80
BOOL ConfirmLocalHost(LPCTSTR lpszVirtServer)
{
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    TCHAR*  pNext;
    BOOL    bReturn;
    CString csBinding;
    CString cs;

    CString csLocalHost = _T("127.0.0.1:80:");

    // open the key to the virtual server, which is what is passed in as a parameter
    cmdKey.OpenNode( lpszVirtServer );
    // test for success.
    if ( (METADATA_HANDLE)cmdKey == NULL ){return FALSE;}

    DWORD dwAttr = METADATA_INHERIT;
    DWORD dwUType = IIS_MD_UT_SERVER;
    DWORD dwDType = MULTISZ_METADATA;
    DWORD dwLength = 0;

    // we need to start this process by getting the existing multisz data from the metabase
    // first, figure out how much memory we will need to do this
    cmdKey.GetData( MD_SERVER_BINDINGS,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_SERVER,MULTISZ_METADATA);

    // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
    // passing in a null ponter of 0 size in order to get the length of the data, it will always
    // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
    // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
    // in again.
    TCHAR*      pBindings;
    DWORD       cbBuffer = dwLength;

    // add enough space to the allocated space that we can just append the string
    cbBuffer += (csLocalHost.GetLength() + 4) * sizeof(WCHAR);
    dwLength = cbBuffer;

    // allocate the space, if it fails, we fail
    // note that GPTR causes it to be initialized to zero
    pData = GlobalAlloc( GPTR, cbBuffer );
    if ( !pData )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("ConfirmLocalHost.Failed to allocate memory.\n")));
        cmdKey.Close();
        goto cleanup;
        }
    pBindings = (TCHAR*)pData;

    // now get the data from the metabase
    bReturn = cmdKey.GetData( MD_SERVER_BINDINGS,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_INHERIT,IIS_MD_UT_SERVER,MULTISZ_METADATA );

    // if we have successfully retrieved the existing bindings, then we need to scan them
    // to see if we are already covered
    if (bReturn)
        {
        // got the existing bindings, scan them now - pBindings will be pointing at the second end \0
        // when it is time to exit the loop.
        while ( *pBindings )
            {
            csBinding = pBindings;

            // if the first character of the binding is a ':' then we are all done because it is "All Unassigned"
            if ( csBinding[0] == _T(':') )
                goto cleanup;

            // if the binding is for localhost, then we are done
            if ( csBinding.Left(9) == _T("127.0.0.1") )
                goto cleanup;

            // increment pBindings to the next string
            pBindings = _tcsninc( pBindings, _tcslen(pBindings))+1;
            }
        }

    // append our new error to the end of the list. The value pErrors should be pointing
    // to the correct location to copy it in to
    _tcscpy( pBindings, csLocalHost );

    // calculate the correct data length for this thing
    // get the location of the end of the multisz
    pNext = _tcsninc( pBindings, _tcslen(pBindings))+2;
    // Get the length of the data to copy
    cbBuffer = DIFF((PBYTE)pNext - (PBYTE)pData);

    // write the new errors list back out to the metabase
    cmdKey.SetData(MD_SERVER_BINDINGS,0,IIS_MD_UT_SERVER,MULTISZ_METADATA,cbBuffer,(PUCHAR)pData);

    // close the key
cleanup:
    cmdKey.Close();

    // clean up
    if (pData){GlobalFree(pData);pData=NULL;}

    // the only time it should return FALSE is if it can't open the key
    return TRUE;
}


//------------------------------------------------------------------------------------
// Beta 3 server set the MD_NOT_DELETABLE property on the default website and the administration website.
// remove it. It should only be set now on the default website for the NTW platform. This routine scans
// all the virtual websites and attempts to delete the MD_NOT_DELETABLE property. This should only be
// called on the NTS platform during an upgrade
// pszService       string representing the service being operated on. ex:  "W3SVC"
//
// Actually, now I'm only going to bother checking instances 1 and 2. These are the only ones that would
// have this value set on them anyway and we can save a lot of time by not checking them all. - boydm
void RemoveCannotDeleteVR( LPCTSTR )
{
}


//------------------------------------------------------------------------------------
// IntegrateNewErrorsOnUpgrade_WWW
// This routine finds the new custom errors and error messages that are being integrated
// into an upgrade and adds them to the existing errors. This code should not be called
// for a fresh install. The plan is to read each new error from the appropriate INF section
// then call a helper routine to add it only if it does not already exist. The use can always
// add these things by hand, and if they have done so, we don't want to override their good work.
// Note: the "g_field" variable is a global declared at the top of this file.
//
// hFile        Handle to the INF file
// szSection    name of section containing the error to integrate - usually "UPGRADE_ERRORS"
//
void IntegrateNewErrorsOnUpgrade_WWW( IN HINF hFile, IN LPCTSTR szSection )
{
    iisDebugOut_Start(_T("IntegrateNewErrorsOnUpgrade_WWW"),LOG_TYPE_TRACE);

    DWORD dwReturn = ERROR_SUCCESS;
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;

    INFCONTEXT Context;
    if( g_pTheApp->m_eInstallMode != IM_UPGRADE )
        {
        iisDebugOut((LOG_TYPE_WARN, _T("WARNING: IntegrateNewErrorsOnUpgrade_WWW called on FRESH install")));
        dwReturn = ERROR_SUCCESS;
        goto IntegrateNewErrorsOnUpgrade_WWW_Exit;
        }

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to find INF section %s for upgrading errors"), szSection));
        dwReturn = ERROR_PATH_NOT_FOUND;
        goto IntegrateNewErrorsOnUpgrade_WWW_Exit;
        }

    // loop through the items in the section.
    while (b)
    {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to allocate buffer of %u bytes - upgrade errors"), dwRequiredSize));
            dwReturn = ERROR_OUTOFMEMORY;
            goto IntegrateNewErrorsOnUpgrade_WWW_Exit;
            }

        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to get the next INF line - upgrade errors")));
            dwReturn = ERROR_PATH_NOT_FOUND;
            goto IntegrateNewErrorsOnUpgrade_WWW_Exit;
            }

        // split the line into its component parts
        if ( SplitLine(szLine, 5) )
            {
            // the first two g_fields are dwords. Must convert them before using them
            DWORD   dwError = _ttoi(g_field[0]);
            DWORD   dwSubCode = _ttoi(g_field[1]);

            // the last g_field is a flag for overwriting existing errors
            BOOL    fOverwrite = _ttoi(g_field[4]);

            // call the helper function that integrates the custom error
            AddCustomError(dwError, dwSubCode, g_field[2], g_field[3], fOverwrite );
            }
        else
            {
            // failed to split the line
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to split upgrade error INF line - %s"), szLine));
            dwReturn = ERROR_INVALID_DATA;
            }

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        if (szLine)
        {
            GlobalFree(szLine);
            szLine = NULL;
        }
    }

IntegrateNewErrorsOnUpgrade_WWW_Exit:
    if (szLine){GlobalFree(szLine);szLine=NULL;}
    // let someone watching the debug out put window know it is done
    iisDebugOut_End(_T("IntegrateNewErrorsOnUpgrade_WWW"),LOG_TYPE_TRACE);
    return;
}




int WWW_Upgrade_RegToMetabase(HINF hInf)
{
    iisDebugOut_Start(_T("WWW_Upgrade_RegToMetabase"),LOG_TYPE_TRACE);

    int iReturn = FALSE;
    ACTION_TYPE atCORE = GetIISCoreAction(FALSE);

    // upgrade the script map

    Register_iis_www_handleScriptMap();

    // ================
    //
    // LM/W3SVC/InProcessIsapiApps
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok.  no isapi apps are listed in the registry, so there is nothing to upgrade.
    // upgrade 4     = User may have added other isapi apps.
    //                  We need to make sure that
    //                  a. the ones we are installing get put there
    //                  b. that we keep the other isapi apps which the user has already installed
    // ================
    // for now, let's just ignore if iis40 upgrade
    if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
        // Added for nt5
        TSTR strTheSection;

        if ( strTheSection.Copy( _T("InProc_ISAPI_Apps") ) &&
             GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
           )
        {
            VerifyMD_InProcessISAPIApps_WWW( strTheSection.QueryStr() );
        }

    }
    else
    {
        TSTR strTheSection;

        if ( strTheSection.Copy( _T("InProc_ISAPI_Apps") ) &&
             GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
           )
        {
            WriteToMD_InProcessISAPIApps_WWW( strTheSection.QueryStr() );
        }
    }
    AdvanceProgressBarTickGauge();


    // ================
    //
    // LM/W3SVC/NTAuthenticationProviders
    //
    // fresh = ok, do not need to write
    // reinstall = ok, do not need to write
    // upgrade 1,2,3 = ok, do not need to write
    // upgrade 4     = user may have other authentication protocols.  if they have ntlm, then we need
    //                 to change that to Negotiate,NTLM because that is the new "NTLM" after IIS 4
    // ================
    if ( g_pTheApp->GetUpgradeVersion() == 4 )
      {
        // For IIS4 users, make sure that they have NTLM and Netgotiate
        VerifyMD_NTAuthenticationProviders_WWW();
      }

    // ================
    //
    // LM/W3SVC/IpSec
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  does nothing and leaves whatever the user already had!
    // ================
#ifndef _CHICAGO_
    if (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        MigrateServiceIpSec(L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters",L"LM/W3SVC" );
        CRegKey regWWWParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"));
        if (regWWWParam)
        {
            regWWWParam.DeleteTree(_T("Deny IP List"));
            regWWWParam.DeleteTree(_T("Grant IP List"));
        }
    }
#endif //_CHICAGO_
    if ( (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30))
    {
        CRegKey regWWWParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"));
        if (regWWWParam)
        {
            regWWWParam.DeleteValue(_T("AnonymousUserName"));
            regWWWParam.DeleteValue(_T("NTAuthenticationProviders"));
            regWWWParam.DeleteValue(_T("Filter Dlls"));
            regWWWParam.DeleteValue(_T("SecurePort"));
        }
    }
    AdvanceProgressBarTickGauge();


    // If we are upgrading from a K2 beta, then we do not want to mess around with the virtual roots. Just
    // use the existing ones. The only exception is that we need to make sure local host can reach on the
    // default website so that the index server documentation works.

    // ================
    //
    // LM/W3SVC/LogType
    // LM/W3SVC/LogPluginOrder
    // LM/W3SVC/LogFilePeriod
    // LM/W3SVC/LogFileTruncateSize
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff.
    // ================
    SetLogPlugInOrder(_T("W3SVC"));
    AdvanceProgressBarTickGauge();

    // ================
    // This needs to be done before the virtual roots get moved into the metabase.
    // ================
    if (!g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
#ifndef _CHICAGO_
        Upgrade_WolfPack();
#endif //_CHICAGO_
    }
    AdvanceProgressBarTickGauge();

    // ================
    // LM/W3SVC/CustomError
    // LM/W3SVC/Info/CustomErrorDesc
    // LM/W3SVC/n/Root/iisamples/exair/CustomError
    // LM/W3SVC/n/Root/iisamples/iisadmin/CustomError
    // LM/W3SVC/n/Root/iisamples/iishelp/CustomError
    //
    // fresh = ok.
    // reinstall = ok
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff.  in otherwords -- SetDataNoOverwrite!
    // ================
    if ( g_pTheApp->m_eInstallMode == IM_UPGRADE )
    {
        // go back again and integrate and final new custom errors into the upgraded errors.
        // Only do this on an upgrade.

        TSTR strTheSection;

        if ( strTheSection.Copy( _T("UPGRADE_ERRORS") ) &&
             GetSectionNameToDo(hInf, &strTheSection)
           )
        {
            IntegrateNewErrorsOnUpgrade_WWW( hInf, strTheSection.QueryStr() );
        }

        // This moves error pages (ie 404.htm) from \help\common to \help\iishelp\common, and updates metabase paths for IIS4
        if ( g_pTheApp->GetUpgradeVersion() == 4 )
        {
            MoveOldHelpFilesToNewLocation();

            HRESULT         hRes;
            CFixCustomErrors CustomErrFix;
            hRes = CustomErrFix.Update(_T("LM/W3SVC"));
            if (FAILED(hRes))
                {iisDebugOut((LOG_TYPE_WARN, _T("CustomErrFix.Update():FAILED= %x.\n"),hRes));}
        }
    }
    AdvanceProgressBarTickGauge();

#ifndef _CHICAGO_
    //
    // upgrade the cryptographic server keys.
    // either from the registry or metabase to the pstores.
    //
    UpgradeCryptoKeys_WWW();
    AdvanceProgressBarTickGauge();
#endif //_CHICAGO_

    iisDebugOut_End(_T("WWW_Upgrade_RegToMetabase"),LOG_TYPE_TRACE);
    return iReturn;
}



int FTP_Upgrade_RegToMetabase(HINF hInf)
{
    int iReturn = FALSE;
    iisDebugOut_Start(_T("FTP_Upgrade_RegToMetabase"),LOG_TYPE_TRACE);

    ACTION_TYPE atCORE = GetIISCoreAction(TRUE);

    AdvanceProgressBarTickGauge();

#ifndef _CHICAGO_
    // ================
    //
    // LM/MSFTPSVC/IpSec
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  does nothing and leaves whatever the user already had!
    // ================
    if (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        MigrateServiceIpSec(L"SYSTEM\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters",L"LM/MSFTPSVC" );
        CRegKey regFTPParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters"));
        regFTPParam.DeleteTree(_T("Deny IP List"));
        regFTPParam.DeleteTree(_T("Grant IP List"));
    }
#endif //_CHICAGO_


    // ================
    //
    // LM/MSFTPSVC/MD_GREETING_MESSAGE
    //
    // fresh = ok.  do nothing.
    // reinstall = ok. do nothing.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = do nothing
    // ================
    if ( (g_pTheApp->m_eUpgradeType == UT_10_W95 || g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30) )
    {
        CRegKey regFTPParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters"));
        if (regFTPParam)
        {
            WriteToMD_GreetingMessage_FTP();
            regFTPParam.DeleteValue(_T("GreetingMessage"));
            regFTPParam.DeleteValue(_T("AnonymousUserName"));
        }
    }
    AdvanceProgressBarTickGauge();

    // ================
    //
    // LM/MSFTPSVC/LogType
    // LM/MSFTPSVC/LogPluginOrder
    // LM/MSFTPSVC/LogFilePeriod
    // LM/MSFTPSVC/LogFileTruncateSize
    //
    // LM/MSFTPSVC/Capabilities
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff.  in otherwords -- SetDataNoOverwrite!
    // ================
    SetLogPlugInOrder(_T("MSFTPSVC"));
    AdvanceProgressBarTickGauge();


    iisDebugOut_End(_T("FTP_Upgrade_RegToMetabase"),LOG_TYPE_TRACE);
    iReturn = TRUE;
    return iReturn;
}




// Open the metabase and loop thru all the filters which are in there,
// make sure they contain the filters we require for nt5
DWORD VerifyMD_Filters_WWW(TSTR &strTheSection)
{
    iisDebugOut_Start(_T("VerifyMD_Filters_WWW"),LOG_TYPE_TRACE);

    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    CString csKeyType;
    CString csOrder;

    int bFound = FALSE;
    int c = 0;
    int k = 0;

    INT     i, nArrayItems;
    BOOL    fAddComma = FALSE;
    CMDKey  cmdKey;
    BOOL    bReturn;

    CStringArray arrayName, arrayPath;
    CStringArray arrayName_New, arrayPath_New;

    // Add Required Filters to the arrayName
    c = AddRequiredFilters(strTheSection, arrayName, arrayPath);

    // set aside the number of array items
    nArrayItems = (INT)arrayName.GetSize();

    // leave if it is empty
    if ( nArrayItems == 0 ) {goto VerifyMD_Filters_WWW_Exit;}

    // zero out the order string
    csOrder.Empty();

    // open the key to the virtual server, which is what is passed in as a parameter
    cmdKey.OpenNode( _T("LM/W3SVC/Filters") );
    // test for success.
    if ( (METADATA_HANDLE)cmdKey )
    {
        DWORD dwAttr = METADATA_NO_ATTRIBUTES;
        DWORD dwUType = IIS_MD_UT_SERVER;
        DWORD dwDType = STRING_METADATA;
        DWORD dwLength = 0;

        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA);

        // give the buffer some head space
        // dwLength += 2;
        bReturn = FALSE;
        if (dwLength > 0)
        {
            // now get the real data from the metabase
            bReturn = cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csOrder.GetBuffer( dwLength ),dwLength,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA );
            csOrder.ReleaseBuffer();
        }

        // the data doesn't get written out here, so close the metabase key
        cmdKey.Close();

        // if reading the value from the metabase didn't work, zero out the string
        if ( !bReturn )
            {csOrder.Empty();}
    }

    // if there is something in the order string from the upgrade, then we need to start adding commas
    if ( !csOrder.IsEmpty() )
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("VerifyMD_Filters_WWW():Start. %s.\n"),csOrder));
        fAddComma = TRUE;
    }

    // Do special re-arranging for
    // sspifilt and compression filter
    ReOrderFiltersSpecial(nArrayItems, arrayName, csOrder);

    for ( i = 0; i < nArrayItems; i++ )
    {
        // if the name in the array is already in the filter order list,
        // then continue to the next one
        CString csOrderUpper;
        CString csUpperValue;

        csOrderUpper = csOrder;
        csOrderUpper.MakeUpper();
        csOrderUpper.TrimLeft();
        csOrderUpper.TrimRight();

        csUpperValue = arrayName[i];
        csUpperValue.MakeUpper();
        csUpperValue.TrimLeft();
        csUpperValue.TrimRight();

        // Always, Add this entry to the list of new filters to add!!
        // This is because ReOrderFiltersSpecial() may add Compress or sspifilt to the csOrder
       arrayName_New.Add(arrayName[i]);
       arrayPath_New.Add(arrayPath[i]);

        if ( csOrderUpper.Find( csUpperValue ) >= 0 )
        {
            // this entry is already in the csOrderlist so lets not add it again.
            continue;
        }

        // the name is not alreay in the list. Unless this is the first one to be added, insert
        // a comma to seperate the list, then add the file name
        if ( fAddComma )
        {
            csOrder += _T(',');
        }

        // Add this entry to our list!
        csOrder +=arrayName[i];

        // once we've added one, we know we always need to adde a comma from now on
        fAddComma = TRUE;
    }

    nArrayItems = (INT)arrayName_New.GetSize();

    // always write out the loadorder list.
    WriteToMD_Filters_List_Entry(csOrder);

    // leave if it is empty
    if ( nArrayItems == 0 ) {goto VerifyMD_Filters_WWW_Exit;}

    for (k=0; k<nArrayItems; k++)
    {
        WriteToMD_Filter_Entry(arrayName_New[k], arrayPath_New[k]);
    }


VerifyMD_Filters_WWW_Exit:
    iisDebugOut_End1(_T("VerifyMD_Filters_WWW"),csOrder,LOG_TYPE_TRACE);
    return dwReturn;
}


DWORD WriteToMD_Filters_List_Entry(CString csOrder)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    // Add this entry to the metabase!
    csKeyType = _T("IIsFilters");
    stMDEntry.szMDPath = _T("LM/W3SVC/Filters");
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    // now we have csOrder=f1,f2,f3,sspifilt
    stMDEntry.szMDPath = _T("LM/W3SVC/Filters");
    stMDEntry.dwMDIdentifier = MD_FILTER_LOAD_ORDER;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csOrder.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csOrder;

    // always overwrite, we may have added new filters
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}


DWORD WriteToMD_Filter_Entry(CString csFilter_Name, CString csFilter_Path)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csMDPath;
    CString csKeyType;

    csMDPath = _T("LM/W3SVC/Filters/") + (CString)csFilter_Name;

    // Set Entry for the Filter
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csMDPath;
    stMDEntry.dwMDIdentifier = MD_FILTER_IMAGE_PATH;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = ((csFilter_Path).GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)(csFilter_Path);
    // always overwrite, we may have added new filters
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    // Set KeyType
    csKeyType = _T("IIsFilter");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csMDPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    // always overwrite, we may have added new filters
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}


DWORD WriteToMD_InProcessISAPIApps_WWW(IN LPCTSTR szSection)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    CStringArray arrayName, arrayPath;
    int nArrayItems = 0;
    int i;
    TSTR_MSZ mstrInProcList;

    // Add Required Filters to the arrayName
    AddRequiredISAPI(arrayName, arrayPath, szSection);
    // set aside the number of array items
    nArrayItems = (int)arrayName.GetSize();
    // leave if it is empty
    if ( nArrayItems == 0 ) {goto WriteToMD_InProcessISAPIApps_WWW_Exit;}

    for ( i = 0; i < nArrayItems; i++ )
    {
        if ( !mstrInProcList.Add( arrayPath[i].GetBuffer(0) ) )
        {
          goto WriteToMD_InProcessISAPIApps_WWW_Exit;
        }
    }

    // write it to the metabase
    WriteToMD_ISAPI_Entry( mstrInProcList );

WriteToMD_InProcessISAPIApps_WWW_Exit:
    return dwReturn;
}


//
// Returns the amount of entries that we added.
//
int AddRequiredISAPI(CStringArray& arrayName,CStringArray& arrayPath, IN LPCTSTR szSection)
{
    iisDebugOut_Start(_T("AddRequiredISAPI"),LOG_TYPE_TRACE);

    int c = 0;
    CString csName = _T("");
    CString csPath = _T("");

    CStringList strList;

    TSTR strTheSection;

    if ( strTheSection.Copy( szSection ) &&
         GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
       )
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, strTheSection.QueryStr() ))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);
                // Split into name, and value. look for ","
                int i;
                i = csEntry.ReverseFind(_T(','));
                if (i != -1)
                {
                    int len =0;
                    len = csEntry.GetLength();
                    csPath = csEntry.Right(len - i - 1);
                    csName = csEntry.Left(i);

                    // Add it to our array...
                    iisDebugOut((LOG_TYPE_TRACE, _T("Add isapi Entry:%s:%s\n"),csName, csPath));
                    arrayName.Add(csName);
                    arrayPath.Add(csPath);
                    c++;
                }

                strList.GetNext(pos);
            }
        }
    }
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("AddRequiredISAPI:End.Return=%d\n"),c));
    return c;
}


DWORD WriteToMD_ISAPI_Entry( TSTR_MSZ &mstrInprocIsapiList )
{
    MDEntry stMDEntry;

    // write the new errors list back out to the metabase
    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_IN_PROCESS_ISAPI_APPS;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = mstrInprocIsapiList.QueryLen() * sizeof(WCHAR);
    stMDEntry.pbMDData = (LPBYTE) mstrInprocIsapiList.QueryMultiSz();

    return SetMDEntry(&stMDEntry);
}



// loop thru the isapi apps and make sure the required ones are there.
BOOL VerifyMD_InProcessISAPIApps_WWW(IN LPCTSTR szSection)
{
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    BOOL    bReturn = FALSE;
    CString csOneBlobEntry;
    CString cs;
    int c = 0;
    TSTR_MSZ mstrInProcList;
    CMDValue cmdInProcList;

    int iISAPIPath_NewlyAdded_Count = 0;

    int i, nArrayItems;

    int iPleaseCloseTheMetabase = FALSE;

    TCHAR*      pBlobEntry = NULL;
    DWORD       cbBuffer = 0;

    CStringArray arrayName, arrayPath;

    // open the key
    cmdKey.OpenNode(_T("LM/W3SVC"));
    // test for success.
    if ( (METADATA_HANDLE)cmdKey == NULL )
    {
        // i could not open the key
        // maybe there is nothing there.
        // this must be a fresh install.
        WriteToMD_InProcessISAPIApps_WWW(szSection);
        goto VerifyMD_InProcessISAPIApps_WWW_Exit;
    }
    iPleaseCloseTheMetabase = TRUE;

    // Add Required Filters to the arrayName
    c = AddRequiredISAPI(arrayName, arrayPath, szSection);
    // set aside the number of array items
    nArrayItems = (int)arrayName.GetSize();
    // leave if it is empty
    if ( nArrayItems == 0 ) {goto VerifyMD_InProcessISAPIApps_WWW_Exit;}

    // Initialize Value
    if ( !cmdInProcList.SetValue( MD_IN_PROCESS_ISAPI_APPS,
                                  METADATA_INHERIT,
                                  IIS_MD_UT_SERVER,
                                  MULTISZ_METADATA,
                                  sizeof( _T("\0\0") ),
                                  _T("\0\0") ) )
    {
      iisDebugOut((LOG_TYPE_ERROR, _T("VerifyMD_InProcessISAPIApps_WWW.1.Failed to allocate memory.\n")));
      goto VerifyMD_InProcessISAPIApps_WWW_Exit;
    }

    // Retrieve Value from metabase
    if ( cmdKey.GetData( cmdInProcList, MD_IN_PROCESS_ISAPI_APPS ) )
    {
      if ( ( cmdInProcList.GetDataType() != MULTISZ_METADATA ) ||
           ( !mstrInProcList.Copy( (LPTSTR) cmdInProcList.GetData() ) )
         )
      {
        iisDebugOut((LOG_TYPE_ERROR, _T("VerifyMD_InProcessISAPIApps_WWW.2.Failed to allocate memory.\n")));
        goto VerifyMD_InProcessISAPIApps_WWW_Exit;
      }
    }

    // close the handle to the metabase so that we can
    // open it to write the stuff out later!
    cmdKey.Close();
    iPleaseCloseTheMetabase = FALSE;

    // now loop thru this list
    // and check if our isapi dll's are in this list.
    // if they are not, then we add them to the end.
    iISAPIPath_NewlyAdded_Count = 0;
    for ( i = 0; i < nArrayItems; i++ )
    {
        // if the name in the array is already in the filter order list,
        // then continue to the next one
        if ( mstrInProcList.IsPresent( arrayPath[i].GetBuffer(0) ) )
        {
          // Skip this one
          continue;
        }

        if ( !mstrInProcList.Add( arrayPath[i].GetBuffer(0) ) )
        {
          iisDebugOut((LOG_TYPE_ERROR, _T("VerifyMD_InProcessISAPIApps_WWW.3.Failed to add item to list.\n")));
          goto VerifyMD_InProcessISAPIApps_WWW_Exit;
        }

        iISAPIPath_NewlyAdded_Count++;
    }

    // If we added any new entries to the metabase
    // the let's write out the new block of data, otherwise let's get out.
    if (iISAPIPath_NewlyAdded_Count > 0)
    {
        WriteToMD_ISAPI_Entry( mstrInProcList );
    }


VerifyMD_InProcessISAPIApps_WWW_Exit:
    // close the key
    if (TRUE == iPleaseCloseTheMetabase){cmdKey.Close();}
    if (pData){GlobalFree(pData);pData=NULL;}

    // the only time it should return FALSE is if it can't open the key
    return TRUE;
}




DWORD WriteToMD_NTAuthenticationProviders_WWW(CString csData)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    // Upgrade 4.0 comment --> Replace any NTLM with Negotiate,NTLM
    stMDEntry.szMDPath = _T("LM/W3SVC");
    //stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_NTAUTHENTICATION_PROVIDERS;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csData.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csData;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}


// Open the metabase and loop thru all the entries which are in there,
// make sure they contain the entries we require for nt5
DWORD VerifyMD_NTAuthenticationProviders_WWW(void)
{
    iisDebugOut_Start(_T("VerifyMD_NTAuthenticationProviders_WWW"),LOG_TYPE_TRACE);

    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    CString csKeyType;
    CString csOrder;
    int c = 0;
    int k = 0;

    BOOL    fAddComma = FALSE;
    CMDKey  cmdKey;
    BOOL    bReturn;

    int bFound_Negotiate = FALSE;
    int bFound_NTLM = FALSE;

    int j = 0;
    int iPleaseWriteOutTheEntry = FALSE;

    cmdKey.OpenNode( _T("LM/W3SVC") );
    // test for success.
    if ( (METADATA_HANDLE)cmdKey )
    {
        DWORD dwAttr = METADATA_INHERIT;
        DWORD dwUType = IIS_MD_UT_FILE;
        DWORD dwDType = STRING_METADATA;
        DWORD dwLength = 0;

        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        cmdKey.GetData( MD_NTAUTHENTICATION_PROVIDERS,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA);

        // give the buffer some head space
        // dwLength += 2;

        bReturn = FALSE;
        if (dwLength > 0)
        {
            // now get the real data from the metabase
            bReturn = cmdKey.GetData( MD_NTAUTHENTICATION_PROVIDERS,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csOrder.GetBuffer( dwLength ),dwLength,METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA );
            csOrder.ReleaseBuffer();
        }

        // the data doesn't get written out here, so close the metabase key
        cmdKey.Close();

        // if reading the value from the metabase didn't work, zero out the string
        if ( !bReturn ){csOrder.Empty();}
    }

    // if there is something in the order string from the upgrade, then we need to start adding commas
    if ( !csOrder.IsEmpty() ){fAddComma = TRUE;}

    // search for negotiate.
    // if it is there then set flag.
    if ( csOrder.Find( _T("Negotiate") ) >= 0 ) {bFound_Negotiate = TRUE;}
    if ( csOrder.Find( _T("NTLM") ) >= 0 ) {bFound_NTLM = TRUE;}

    if (bFound_Negotiate && bFound_NTLM)
    {
        // The entries already exist. so exit
        goto VerifyMD_NTAuthenticationProviders_WWW_Exit;
    }

    if (bFound_NTLM)
    {
        // we found NTLM
        // check if Negotiate is in there.
        // So let's add it to the end
        if (!bFound_Negotiate)
        {
            // no Negotiate entry, add both NTLM and Negotiate in place of NTLM!
            // Find where NTLM exists and stick Negotiate in front of it!
            // testing,NTLM,somethingelse
            j = csOrder.Find(_T(','));
            if ( j != -1 )
            {
                CString csLeftSide;
                CString csRightSide;

                j = csOrder.Find(_T("NTLM"));
                // means more than 1 item
                csLeftSide = csOrder.Mid(0, j);
                csRightSide = csOrder.Mid(j+4);
                csOrder = csLeftSide;
                csOrder += _T("Negotiate,NTLM");
                csOrder += csRightSide;
            }
            else
            {
                csOrder = _T("Negotiate,NTLM");
            }
            iPleaseWriteOutTheEntry = TRUE;
        }
    }
    else
    {
        // That means we didn't find NTLM
        // So let's add it to the end
        if (fAddComma) {csOrder += _T(',');}
        if (bFound_Negotiate)
        {
            iPleaseWriteOutTheEntry = TRUE;
            // negotiate already exists, so just add NTLM entry to the end of the list.
            csOrder += _T("NTLM");
        }
        else
        {
            // No NTLM and No Negotiate, add them both.
            iPleaseWriteOutTheEntry = TRUE;
            csOrder += _T("Negotiate,NTLM");
        }
    }

    if (TRUE == iPleaseWriteOutTheEntry)
    {
        dwReturn = WriteToMD_NTAuthenticationProviders_WWW(csOrder);
    }

    goto VerifyMD_NTAuthenticationProviders_WWW_Exit;

VerifyMD_NTAuthenticationProviders_WWW_Exit:
    iisDebugOut_End(_T("VerifyMD_NTAuthenticationProviders_WWW"),LOG_TYPE_TRACE);
    return dwReturn;
}


void AddSpecialCustomErrors(IN HINF hFile,IN LPCTSTR szSection,IN CString csKeyPath,IN BOOL fOverwrite)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("AddSpecialCustomErrors():Start.%s:%s.\n"),szSection,csKeyPath));
    // open the .inf file and get the infsection
    // read that section and add it to the custom errors at the csKeypath.
    CStringList strList;
    CString csTheSection = szSection;

    CString csTemp;
    DWORD   dwErrorCode;
    INT     iErrorSubCode;

    if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;

            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = strList.GetAt(pos);

                // at this point csEntry should look like this:
                // 500,100,URL,/iisHelp/common/500-100.asp

                // parse the line.

                // get the first error ID code
                csTemp = csEntry.Left( csEntry.Find(_T(',')) );
                csEntry = csEntry.Right( csEntry.GetLength() - (csTemp.GetLength() +1) );
                _stscanf( csTemp, _T("%d"), &dwErrorCode );

                // get the second code
                csTemp = csEntry.Left( csEntry.Find(_T(',')) );
                csEntry = csEntry.Right( csEntry.GetLength() - (csTemp.GetLength() +1) );
                if ( csTemp == _T('*') )
                    iErrorSubCode = -1;
                else
                    _stscanf( csTemp, _T("%d"), &iErrorSubCode );

                // Get the next whole string
                csTemp = csEntry;

                // Addthe new error code.
                AddCustomError(dwErrorCode, iErrorSubCode, csTemp, csKeyPath, fOverwrite);

                // get the next error
                strList.GetNext(pos);
            }
        }
    }
    iisDebugOut_End1(_T("AddSpecialCustomErrors"),csKeyPath,LOG_TYPE_TRACE);
    return;
}


// given a pointer to a map for a single virtual website, this routine creates its vitual directories - BOYDM
// szSvcName            the name of the server - W3SVC or MSFTPSVC
// i                    the virtual server number
// pObj                 the map for the virtual server's directories
// szVirtServerPath     the path to the node we are creating. example:   LM/W3SVC/1
//
// returns the value of n, which is used to then increment i

// ****** warning ****** This does not necessarily start from #1 !!! ******
// will get the next open virtual server number and add from there.
UINT AddVirtualServer(LPCTSTR szSvcName, UINT i, CMapStringToString *pObj, CString& csRoot, CString& csIP)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("AddVirtualServer():Start.%s.%d.%s.%s.\n"),szSvcName,i,csRoot,csIP));
    CMDKey cmdKey;
    TCHAR Buf[10];
    UINT SvcId;

    // convert the virtual server number to a string
    _itot(i, Buf, 10);

    // Default the progress text to the web server
    SvcId = IDS_ADD_SETTINGS_FOR_WEB_1;
    if (_tcsicmp(szSvcName, _T("MSFTPSVC")) == 0) {SvcId = IDS_ADD_SETTINGS_FOR_FTP_1;}
    // Display the Current Site number so the user knows what we are doing

    CString csKeyPath = csRoot;
    csKeyPath += _T("/");
    csKeyPath += Buf; //  "LM/W3SVC/n"
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, csKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) {cmdKey.Close();}
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("AddVirtualServer():CreateNode %s. FAILED.\n"),csKeyPath));
        return i;
    }

    //
    // /W3SVC/1/IIsWebServer
    //
    if (csRoot.Find(_T("W3SVC")) != -1)
    {
        WriteToMD_IIsWebServerInstance_WWW(csKeyPath);
    }
    else
    {
        WriteToMD_IIsFtpServerInstance_FTP(csKeyPath);
    }

    // for W3SVC or MSFTPSVC
    //
    // /W3SVC/1/ServerBindings
    // /MSFTPSVC/1/ServerBindings
    //
    WriteToMD_ServerBindings(szSvcName, csKeyPath, csIP);

    // About Default Site and Server Size
    if (csIP.Compare(_T("null"))==0)
    {
        // for W3SVC or MSFTPSVC
        //"LM/W3SVC/N/ServerSize"
        //"LM/W3SVC/N/ServerComment"
        //
        //"LM/MSFTPSVC/N/ServerSize"
        //"LM/MSFTPSVC/N/ServerComment"
        WriteToMD_DefaultSiteAndSize(csKeyPath);

        if (csRoot.Find(_T("W3SVC")) != -1)
        {
            // Do only for wwww server!
            TSTR strTheSection;

            if ( strTheSection.Copy( _T("DefaultLoadFile") ) &&
                 GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
               )
            {
                VerifyMD_DefaultLoadFile_WWW(strTheSection.QueryStr() , csKeyPath);
            }
	        // Check if the defaultload.asp file exists...
            // Add the auth for a certain file...
            CString csVrootPlusFileName;
            csVrootPlusFileName.Format(_T("%s\\%s"), g_pTheApp->m_csPathWWWRoot, _T("localstart.asp"));
            if (IsFileExist(csVrootPlusFileName))
            {
                csVrootPlusFileName = csKeyPath;
	            csVrootPlusFileName += _T("/ROOT/localstart.asp");
                WriteToMD_Authorization(csVrootPlusFileName, MD_AUTH_NT | MD_AUTH_BASIC);
            }
        }
    }

    //
    // Loop thru the Virtual Dirs
    //
    POSITION pos1 = pObj->GetStartPosition();
    TCHAR szSpecialSection[200];
    CString csFullKeyPath;
    while (pos1)
    {
        CString csValue;
        CString csName;
        pObj->GetNextAssoc(pos1, csName, csValue);
        //
        // Create Virtual Root Tree
        //
        // CreateMDVRootTree(LM/W3SVC/1, /, "<path>,<username>,<perm>", "null", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /IISADMIN, "<path>,<username>,<perm>", "122.255.255.255", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /IISSAMPLES, "<path>,<username>,<perm>", "122.255.255.255", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /IISHELP, "%s\\Help\\iishelp,,%x", "122.255.255.255", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /SCRIPTS, "<path>,<username>,<perm>", "122.255.255.255", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /IISADMPWD, "<path>,<username>,<perm>", "122.255.255.255", nProgressBarTextWebInstance)
        //
        // Will create:
        // /=          /W3SVC/1/ROOT
        // IISADMIN=   /W3SVC/1/ROOT/IISADMIN
        // IISSAMPLES= /W3SVC/1/ROOT/IISSAMPLES
        // IISHELP=    /W3SVC/1/ROOT/IISHELP
        // SCRIPTS=    /W3SVC/1/ROOT/SCRIPTS
        // IISADMPWD=  /W3SVC/1/ROOT/IISADMPWD
        CreateMDVRootTree(csKeyPath, csName, csValue, csIP, i);

        if (csRoot.Find(_T("W3SVC")) != -1)
        {
            if (csName == _T("/"))
                {csFullKeyPath = csKeyPath + _T("/ROOT");}
            else
                {csFullKeyPath = csKeyPath + _T("/ROOT") + csName;}

            // Add Special Custom errors for this vroot
            // AddSpecialCustomErrors(g_pTheApp->m_hInfHandle, _T("CUSTOMERROR_ALL_DEFAULT_VDIRS"), csFullKeyPath, TRUE);

            // Add Special Custom errors for this certain vroot
            _stprintf(szSpecialSection, _T("CUSTOMERROR_%s"), csName);
            AddSpecialCustomErrors(g_pTheApp->m_hInfHandle, szSpecialSection, csFullKeyPath, TRUE);
        }

        AdvanceProgressBarTickGauge();
    }

    if (csRoot.Find(_T("W3SVC")) != -1)
    {
        // if this is for the web server
        WriteToMD_CertMapper(csKeyPath);
    }

    //AdvanceProgressBarTickGauge();

    // return the value of i so that it can be incremented
    iisDebugOut((LOG_TYPE_TRACE, _T("AddVirtualServer():End.%s.%d.%s.%s.\n"),szSvcName,i,csRoot,csIP));
    return i;
}



// The list will be filled with every instance we care to look at:
// We should now loop thru the list and make sure that we have all the required fields.
// csMDPath = like LM/W3SVC/N
int VerifyVRoots_W3SVC_n(CString csMDPath)
{
    int iReturn = FALSE;
    iisDebugOut_Start(_T("VerifyVRoots_W3SVC_n"), LOG_TYPE_TRACE);

    /*
    [/W3SVC/1]
        ServerSize                    : [IS]    (DWORD)  0x1={Medium}
        ServerComment                 : [IS]    (STRING) "Default Web Site"
        KeyType                       : [S]     (STRING) "IIsWebServer"
        ServerBindings                : [IS]    (MULTISZ) ":80:"
        SecureBindings                : [IS]    (MULTISZ) ":443:"
    */
    WriteToMD_IIsWebServerInstance_WWW(csMDPath);
    WriteToMD_DefaultSiteAndSize(csMDPath);
    if (csMDPath.CompareNoCase(_T("LM/W3SVC/1")) == 0)
    {
        // if this is the default web site then it's get's special consideration
        WriteToMD_ServerBindings(_T("W3SVC"), csMDPath, _T("null"));
    }
    else
    {
        // how do i get the csIP???
        // for other W3SVC/2 sites???

    }

    iisDebugOut_End(_T("VerifyVRoots_W3SVC_n"),LOG_TYPE_TRACE);
    return iReturn;
}


DWORD WriteToMD_Capabilities(LPCTSTR lpszSvc)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwCapabilities = 0;

    // Set the capability type - default to win95
    // Set odbc on if server...
    dwCapabilities = IIS_CAP1_W95;
    if (g_pTheApp->m_eNTOSType == OT_PDC_OR_BDC){dwCapabilities = IIS_CAP1_NTS; dwCapabilities |= IIS_CAP1_ODBC_LOGGING;}
    if (g_pTheApp->m_eNTOSType == OT_NTW){dwCapabilities = IIS_CAP1_NTW;}
    if (g_pTheApp->m_eNTOSType == OT_NTS){dwCapabilities = IIS_CAP1_NTS; dwCapabilities |= IIS_CAP1_ODBC_LOGGING;}

    // LM/MSFTPSVC
    // LM/W3SVC
    CString csKeyPath = _T("LM/");
    csKeyPath += lpszSvc;
    csKeyPath += _T("/Info");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_CAPABILITIES;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwCapabilities;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


// loop thru the metabase
// and look for the next instance number which is not used!
// return that.  "i" is at least = 1.
int VerifyVRoots(LPCTSTR szSvcName)
{
    iisDebugOut_Start(_T("VerifyVRoots"), LOG_TYPE_TRACE);

    CString csRoot = _T("LM/");
    csRoot += szSvcName; //  "LM/W3SVC"

    TCHAR Buf[10];
    CString csInstRoot, csMDPath;
    CMDKey cmdKey;

    CStringList strListInstance;

    int i = 1;

    // Loop thru every instance of
    // the servers "LM/W3SVC/N"
    csInstRoot = csRoot;
    csInstRoot += _T("/");

    _itot(i, Buf, 10);
    csMDPath = csInstRoot + Buf;
    cmdKey.OpenNode(csMDPath);
    while ( (METADATA_HANDLE)cmdKey )
    {
        cmdKey.Close();
        _itot(++i, Buf, 10);
        csMDPath = csInstRoot + Buf;
        cmdKey.OpenNode(csMDPath);
        if ((METADATA_HANDLE) cmdKey)
        {
            // Add it to our list of our nodes!
            strListInstance.AddTail(csMDPath);
        }
    }

    if (strListInstance.IsEmpty() == FALSE)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("************** Loop START **************")));
        POSITION pos = NULL;
        CString csEntry;
        pos = strListInstance.GetHeadPosition();
        while (pos)
        {
            csEntry = strListInstance.GetAt(pos);
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!s!\n"), csEntry));
            if (_tcsicmp(szSvcName, _T("W3SVC")) == 0)
            {
                VerifyVRoots_W3SVC_n(csEntry);
            }

            strListInstance.GetNext(pos);
        }
        iisDebugOut((LOG_TYPE_TRACE, _T("************** Loop END **************")));
    }

    iisDebugOut_End(_T("VerifyVRoots"),LOG_TYPE_TRACE);
    return TRUE;
}


DWORD HandleSecurityTemplates(LPCTSTR szSvcName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    CString csKeyType;
    CString csKeyPath;
    UINT iComment = IDS_TEMPLATE_PUBLIC_WEB_SITE;

    DWORD dwRegularPerm;

    if (_tcsicmp(szSvcName, _T("W3SVC")) == 0)
    {
        //
        // do www regular
        //
        dwRegularPerm = MD_ACCESS_SCRIPT | MD_ACCESS_READ;
        csKeyPath = _T("LM/W3SVC/Info/Templates/Public Web Site");

        iComment = IDS_TEMPLATE_PUBLIC_WEB_SITE;
        dwReturn = WriteToMD_ServerComment(csKeyPath, iComment);

        dwReturnTemp = WriteToMD_IIsWebServerInstance_WWW(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        csKeyPath = _T("LM/W3SVC/Info/Templates/Public Web Site/Root");

        dwReturnTemp = WriteToMD_IIsWebVirtualDir(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        dwReturnTemp = WriteToMD_AccessPerm(csKeyPath, dwRegularPerm, TRUE);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        dwReturnTemp = WriteToMD_Authorization(csKeyPath, MD_AUTH_ANONYMOUS);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        WriteToMD_IPsec_GrantByDefault(csKeyPath);

        //
        // do www secure site
        //
        dwRegularPerm = MD_ACCESS_SCRIPT | MD_ACCESS_READ;
        csKeyPath = _T("LM/W3SVC/Info/Templates/Secure Web Site");

        iComment = IDS_TEMPLATE_PUBLIC_SECURE_SITE;
        dwReturn = WriteToMD_ServerComment(csKeyPath, iComment);

        dwReturnTemp = WriteToMD_IIsWebServerInstance_WWW(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        csKeyPath = _T("LM/W3SVC/Info/Templates/Secure Web Site/Root");

        dwReturnTemp = WriteToMD_IIsWebVirtualDir(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        dwReturnTemp = WriteToMD_AccessPerm(csKeyPath, dwRegularPerm, TRUE);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        dwReturnTemp = WriteToMD_Authorization(csKeyPath, MD_AUTH_MD5 | MD_AUTH_NT | MD_AUTH_BASIC);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        WriteToMD_IPsec_GrantByDefault(csKeyPath);

    }
    else
    {
        //
        // do ftp site
        //

        dwRegularPerm = MD_ACCESS_READ;
        csKeyPath = _T("LM/MSFTPSVC/Info/Templates/Public FTP Site");

        iComment = IDS_TEMPLATE_PUBLIC_FTP_SITE;
        dwReturn = WriteToMD_ServerComment(csKeyPath, iComment);

        dwReturnTemp = WriteToMD_IIsFtpServerInstance_FTP(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        csKeyPath = _T("LM/MSFTPSVC/Info/Templates/Public FTP Site/Root");

        dwReturnTemp = WriteToMD_IIsFtpServerInstance_FTP(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        dwReturnTemp = WriteToMD_AccessPerm(csKeyPath, dwRegularPerm, TRUE);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        csKeyPath = _T("LM/MSFTPSVC/Info/Templates/Public FTP Site");

        dwReturnTemp = WriteToMD_AllowAnonymous_FTP(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        dwReturnTemp = WriteToMD_AnonymousOnly_FTP(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        WriteToMD_IPsec_GrantByDefault(csKeyPath);
    }

    iisDebugOut_End(_T("HandleSecurityTemplates"),LOG_TYPE_TRACE);
    return dwReturn;
}

DWORD WriteToMD_IPsec_GrantByDefault(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/MSFTPSVC
    // LM/W3SVC
    // cmdKey.SetData(MD_IP_SEC,METADATA_INHERIT | METADATA_REFERENCE,IIS_MD_UT_FILE,BINARY_METADATA,acCheck.GetStorage()->GetUsed(),(acCheck.GetStorage()->GetAlloc()? acCheck.GetStorage()->GetAlloc() : (LPBYTE)""));
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_IP_SEC;
    stMDEntry.dwMDAttributes = METADATA_INHERIT | METADATA_REFERENCE;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = BINARY_METADATA;
    stMDEntry.dwMDDataLen = 0;
    stMDEntry.pbMDData = (LPBYTE)"";

    // we know we are tryint to write nothing, so make sure
    // we don't try to retrieve nothing from it.
    //int iBeforeValue = FALSE;
    //iBeforeValue = g_CheckIfMetabaseValueWasWritten;
    //g_CheckIfMetabaseValueWasWritten = FALSE;
    dwReturn = SetMDEntry(&stMDEntry);
    // Set the flag back after calling the function
    //g_CheckIfMetabaseValueWasWritten = iBeforeValue;

    return dwReturn;
}


DWORD WriteToMD_HttpExpires(CString csData)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_HTTP_EXPIRES;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csData.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csData;
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}




DWORD WriteToMD_AllowAnonymous_FTP(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ALLOW_ANONYMOUS;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    dwData = 0x1;
    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_AnonymousOnly_FTP(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_ONLY;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    dwData = 0x1;
    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_IWamUserName_WWW(void)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    CMDKey cmdKey;
    MDEntry stMDEntry;
    MDEntry stMDEntry_Pass;

    // the username
    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_WAM_USER_NAME;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (g_pTheApp->m_csWAMAccountName.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR) g_pTheApp->m_csWAMAccountName;

    // the password
    stMDEntry_Pass.szMDPath = _T("LM/W3SVC");
    stMDEntry_Pass.dwMDIdentifier = MD_WAM_PWD;
    stMDEntry_Pass.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
    stMDEntry_Pass.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry_Pass.dwMDDataType = STRING_METADATA;
    stMDEntry_Pass.dwMDDataLen = (g_pTheApp->m_csWAMAccountPassword.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry_Pass.pbMDData = (LPBYTE)(LPCTSTR) g_pTheApp->m_csWAMAccountPassword;
    // make sure and delete it first
    // DeleteMDEntry(&stMDEntry_Pass);

    // --------------------------------------------------
    // always overwrite, we may have changed the password
    // important: Set the username and the password on a single open and close!
    // --------------------------------------------------
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)stMDEntry.szMDPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        dwReturnTemp = ERROR_SUCCESS;
        dwReturnTemp = cmdKey.SetData(stMDEntry.dwMDIdentifier,stMDEntry.dwMDAttributes,stMDEntry.dwMDUserType,stMDEntry.dwMDDataType,stMDEntry.dwMDDataLen,stMDEntry.pbMDData);
        if (FAILED(dwReturnTemp))
        {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry.dwMDIdentifier, dwReturnTemp));
            dwReturn = dwReturnTemp;
        }

        dwReturnTemp = ERROR_SUCCESS;
        dwReturnTemp = cmdKey.SetData(stMDEntry_Pass.dwMDIdentifier,stMDEntry_Pass.dwMDAttributes,stMDEntry_Pass.dwMDUserType,stMDEntry_Pass.dwMDDataType,stMDEntry_Pass.dwMDDataLen,stMDEntry_Pass.pbMDData);
        if (FAILED(dwReturnTemp))
        {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry_Pass.dwMDIdentifier, dwReturnTemp));
            dwReturn = dwReturnTemp;
        }

        cmdKey.Close();
    }

    return dwReturn;
}


// loop thru the custom errors and make sure they point to the right place
BOOL VerifyCustomErrors_WWW(CString csKeyPath)
{
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    BOOL    bReturn = FALSE;
    CString csOneBlobEntry;
    TCHAR   szOneBlobEntry2[_MAX_PATH + 20];
    CString csCustomErrorEntry;
    int c = 0;

    int iCustomErrorEntryCount = 0;
    int iCustomErrorUpdatedCount = 0;
    int iPleaseCloseTheMetabase = FALSE;

    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szPath_only2[_MAX_PATH];
    TCHAR szFilename_only[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    DWORD dwAttr;
    DWORD dwUType;
    DWORD dwDType;
    DWORD dwLength;

    TCHAR*      pBlobEntry = NULL;
    DWORD       cbBuffer = 0;

    // open the key
    cmdKey.OpenNode(csKeyPath);
    // test for success.
    if ( (METADATA_HANDLE)cmdKey == NULL )
    {
        // if could not open the key maybe there is nothing there.
        goto VerifyCustomErrors_WWW_Exit;
    }
    iPleaseCloseTheMetabase = TRUE;


    dwAttr = METADATA_INHERIT;
    dwUType = IIS_MD_UT_FILE;
    dwDType = MULTISZ_METADATA;
    dwLength = 0;

    // we need to start this process by getting the existing multisz data from the metabase
    // first, figure out how much memory we will need to do this

    // make sure METADATA_INHERIT is NOT set!
    // otherwise becaues the entry exists at the root, we'll always get it.
    cmdKey.GetData(MD_CUSTOM_ERROR,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,MULTISZ_METADATA);

    // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
    // passing in a null ponter of 0 size in order to get the length of the data, it will always
    // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
    // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
    // in again.
    cbBuffer = dwLength;

    // allocate the space, if it fails, we fail
    // note that GPTR causes it to be initialized to zero
    pData = GlobalAlloc( GPTR, cbBuffer );
    if ( !pData )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("VerifyCustomErrors_WWW.1.Failed to allocate memory.\n")));
        goto VerifyCustomErrors_WWW_Exit;
        }
    pBlobEntry = (TCHAR*)pData;

    // now get the data from the metabase
    iCustomErrorEntryCount = 0;
    bReturn = cmdKey.GetData(MD_CUSTOM_ERROR,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,MULTISZ_METADATA );
    // loop thru this list and add it to our array of entries.
    if (bReturn)
    {
        // got the entry, scan them now - pBlobEntry will be pointing at the second end \0
        // when it is time to exit the loop.
        csCustomErrorEntry = _T("");
        while ( *pBlobEntry )
            {
            csOneBlobEntry = pBlobEntry;
            _tcscpy(szOneBlobEntry2, csOneBlobEntry);

            // Grab the blob entry and make sure that it points to the new location.
            //"500,15,FILE,D:\WINNT\help\iisHelp\common\500-15.htm"
            //"500,100,URL,/iisHelp/common/500-100.asp"
            if ( SplitLineCommaDelimited(szOneBlobEntry2, 4) )
                {

                // Check if this is for a file type:
                if (_tcsicmp(g_field[2], _T("FILE")) == 0)
                    {
                        // Get the filename
                        // Trim off the filename and return only the path
                        _tsplitpath( g_field[3], szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

                        // Check if the path points to the old place...
                        CString     csFilePath;
                        csFilePath.Format(_T("%s\\help\\common\\file"), g_pTheApp->m_csWinDir);
                        _tsplitpath( csFilePath, NULL, szPath_only2, NULL, NULL);

                        if (_tcsicmp(szPath_only, szPath_only2) == 0)
                        {
                            // yes, it points to the old place.
                            // let's see if it exists in the new place first....
                            CString csFilePathNew;
                            csFilePathNew.Format(_T("%s\\help\\iishelp\\common"), g_pTheApp->m_csWinDir);
                            csFilePath.Format(_T("%s\\%s%s"), csFilePathNew, szFilename_only, szFilename_ext_only);
                            if (IsFileExist(csFilePath))
                            {
                                // yes, it does, then let's replace it.
                                csOneBlobEntry.Format(_T("%s,%s,%s,%s\\%s%s"), g_field[0], g_field[1], g_field[2], csFilePathNew, szFilename_only, szFilename_ext_only);
                                iCustomErrorUpdatedCount++;
                            }
                            else
                            {
                                // no it does not exist...
                                // see if there is a *.bak file with that name...
                                CString csFilePath2;
                                csFilePath2 = csFilePath;
                                csFilePath2 += _T(".bak");
                                if (IsFileExist(csFilePath2))
                                {
                                    // yes, it does, then let's replace it.
                                    csOneBlobEntry.Format(_T("%s,%s,%s,%s\\%s%s.bak"), g_field[0], g_field[1], g_field[2], csFilePathNew, szFilename_only, szFilename_ext_only);
                                    iCustomErrorUpdatedCount++;
                                }
                                else
                                {
                                    // They must be pointing to some other file which we don't have.
                                    // let's try to copy the old file from the old directory...
                                    TCHAR szNewFileName[_MAX_PATH];
                                    // rename file to *.bak and move it to the new location..
                                    _stprintf(szNewFileName, _T("%s\\%s%s"), csFilePathNew, szFilename_only, szFilename_ext_only);
                                    // move it
                                    if (IsFileExist(csFilePath))
                                    {
                                        if (MoveFileEx( g_field[3], szNewFileName, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING))
                                        {
                                            // yes, it does, then let's replace it.
                                            csOneBlobEntry.Format(_T("%s,%s,%s,%s"), g_field[0], g_field[1], g_field[2], szNewFileName);
                                            iCustomErrorUpdatedCount++;
                                        }
                                    }
                                    else
                                    {
                                        // Check if the file was renamed...
                                        TCHAR szNewFileName[_MAX_PATH];
                                        // rename file to *.bak and move it to the new location..
                                        _stprintf(szNewFileName, _T("%s\\%s%s.bak"), csFilePathNew, szFilename_only, szFilename_ext_only);
                                        // yes, it does, then let's replace it.
                                        if (IsFileExist(szNewFileName))
                                        {
                                            csOneBlobEntry.Format(_T("%s,%s,%s,%s"), g_field[0], g_field[1], g_field[2], szNewFileName);
                                            iCustomErrorUpdatedCount++;
                                        }
                                        else
                                        {
                                            // they must be pointing to some other file which we don't install.
                                            // so don't change this entry...
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            else
                {
                // failed to split the line
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to split upgrade error INF line - %s"), szOneBlobEntry2));
                }

            // append on the "|" which we'll convert to a null later
            csCustomErrorEntry += csOneBlobEntry + _T("|");
            iCustomErrorEntryCount++;

            // increment pBlobEntry to the next string
            pBlobEntry = _tcsninc( pBlobEntry, _tcslen(pBlobEntry))+1;
            }

        // add the terminating second "|" character
        csCustomErrorEntry +=_T("|");
    }
    // close the handle to the metabase so that we can
    // open it to write the stuff out later!
    cmdKey.Close();
    iPleaseCloseTheMetabase = FALSE;

    // If we added any new entries to the metabase
    // the let's write out the new block of data, otherwise let's get out.
    if (iCustomErrorUpdatedCount > 0)
    {
        WriteToMD_CustomError_Entry(csKeyPath,csCustomErrorEntry);
    }

VerifyCustomErrors_WWW_Exit:
    // close the key
    if (TRUE == iPleaseCloseTheMetabase){cmdKey.Close();}
    if (pData){GlobalFree(pData);pData=NULL;}
    // the only time it should return FALSE is if it can't open the key
    return TRUE;
}

/*
"400,*,FILE,D:\WINNT\help\common\400.htm"
"401,1,FILE,D:\WINNT\help\common\401-1.htm"
"401,2,FILE,D:\WINNT\help\common\401-2.htm"
"401,3,FILE,D:\WINNT\help\common\401-3.htm"
"401,4,FILE,D:\WINNT\help\common\401-4.htm"
"401,5,FILE,D:\WINNT\help\common\401-5.htm"
"403,1,FILE,D:\WINNT\help\common\403-1.htm"
"403,2,FILE,D:\WINNT\help\common\403-2.htm"
"403,3,FILE,D:\WINNT\help\common\403-3.htm"
 "403,4,FILE,D:\WINNT\help\common\403-4.htm"
 "403,5,FILE,D:\WINNT\help\common\403-5.htm"
 "403,6,FILE,D:\WINNT\help\common\403-6.htm"
 "403,7,FILE,D:\WINNT\help\common\403-7.htm"
 "403,8,FILE,D:\WINNT\help\common\403-8.htm"
 "403,9,FILE,D:\WINNT\help\common\403-9.htm"
 "403,10,FILE,D:\WINNT\help\common\403-10.htm"
 "403,11,FILE,D:\WINNT\help\common\403-11.htm"
 "403,12,FILE,D:\WINNT\help\common\403-12.htm"
 "404,*,FILE,D:\WINNT\help\common\404b.htm"
 "405,*,FILE,D:\WINNT\help\common\405.htm"
 "406,*,FILE,D:\WINNT\help\common\406.htm"
 "407,*,FILE,D:\WINNT\help\common\407.htm"
 "412,*,FILE,D:\WINNT\help\common\412.htm"
 "414,*,FILE,D:\WINNT\help\common\414.htm"
 "403,13,FILE,D:\WINNT\help\iisHelp\common\403-13.htm"
 "403,15,FILE,D:\WINNT\help\iisHelp\common\403-15.htm"
 "403,16,FILE,D:\WINNT\help\iisHelp\common\403-16.htm"
 "403,17,FILE,D:\WINNT\help\iisHelp\common\403-17.htm"
 "500,12,FILE,D:\WINNT\help\iisHelp\common\500-12.htm"
 "500,13,FILE,D:\WINNT\help\iisHelp\common\500-13.htm"
 "500,15,FILE,D:\WINNT\help\iisHelp\common\500-15.htm"
 "500,100,URL,/iisHelp/common/500-100.asp"
*/
DWORD WriteToMD_CustomError_Entry(CString csKeyPath, CString csCustomErrorDelimitedList)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    MDEntry stMDEntry;

    HGLOBAL hBlock = NULL;

    int nCustomErrorLength;
    nCustomErrorLength = csCustomErrorDelimitedList.GetLength() * sizeof(TCHAR);
    hBlock = GlobalAlloc(GPTR, nCustomErrorLength + sizeof(TCHAR));
    if (!hBlock)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_CustomError_Entry.Failed to allocate memory.\n")));
        return ERROR_OUTOFMEMORY;
    }

    TCHAR *p = (LPTSTR)hBlock;
    memcpy((LPVOID)hBlock, (LPVOID)(LPCTSTR)csCustomErrorDelimitedList, nCustomErrorLength + sizeof(TCHAR));

    //  replace all '|' which a null
    while (*p)
    {
        if (*p == _T('|'))
        {
            *p = _T('\0');
        }
        p = _tcsinc(p);
    }

    // write the new errors list back out to the metabase
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_CUSTOM_ERROR;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = nCustomErrorLength;
    stMDEntry.pbMDData = (LPBYTE)hBlock;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    if (hBlock){GlobalFree(hBlock);hBlock=NULL;}
    return dwReturn;
}

void MoveOldHelpFilesToNewLocation(void)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindFileData;
    TCHAR szDirNameTemp[_MAX_PATH];
    TSTR_PATH strTempHelpHTMFilesDir1;
    TSTR_PATH strTempHelpHTMFilesDir2;

    if ( !strTempHelpHTMFilesDir1.RetrieveWindowsDir() ||
         !strTempHelpHTMFilesDir1.PathAppend( _T("help\\common") ) ||
         !strTempHelpHTMFilesDir2.RetrieveWindowsDir() ||
         !strTempHelpHTMFilesDir2.PathAppend( _T("help\\iishelp\\common") ) )
    {
        return;
    }

    // Check if the old directory exists...
    if (!IsFileExist( strTempHelpHTMFilesDir1.QueryStr() ))
    {
        return;
    }

    // The old directory does exist..
    // let's rename all the files to *.bak, then move them over.
    // *.htm to *.htm.bak
    // *.asp to *.asp.bak
    // *.asa to *.asa.bak
    // *.inc to *.inc.bak
    //
    // 1st let's delete any *.bak files they may already have...
    //DeleteFilesWildcard(szTempHelpHTMFilesDir1, _T("*.bak"));

    // ok, this is a directory,
    // so tack on the *.* deal
    _stprintf(szDirNameTemp, _T("%s\\*.*"), strTempHelpHTMFilesDir1.QueryStr() );
    hFile = FindFirstFile(szDirNameTemp, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, let's check if it's one of the ones we care about.
                        TCHAR szFilename_ext_only[_MAX_EXT];
                        _tsplitpath( FindFileData.cFileName, NULL, NULL, NULL, szFilename_ext_only);
                        int iYesFlag = FALSE;

                        if (szFilename_ext_only)
                        {
                            if ( _tcsicmp(szFilename_ext_only, _T(".htm")) == 0) {iYesFlag = TRUE;}
                            if ( _tcsicmp(szFilename_ext_only, _T(".html")) == 0) {iYesFlag = TRUE;}
                            if ( _tcsicmp(szFilename_ext_only, _T(".asp")) == 0) {iYesFlag = TRUE;}
                            if ( _tcsicmp(szFilename_ext_only, _T(".asa")) == 0) {iYesFlag = TRUE;}
                            if ( _tcsicmp(szFilename_ext_only, _T(".inc")) == 0) {iYesFlag = TRUE;}

                            if (TRUE == iYesFlag)
                            {
                                TCHAR szOldFileName[_MAX_PATH];
                                TCHAR szNewFileName[_MAX_PATH];
                                // rename to filename.*.bak
                                _stprintf(szOldFileName, _T("%s\\%s"), strTempHelpHTMFilesDir1.QueryStr(), FindFileData.cFileName);
                                // rename file to *.bak and move it to the new location..
                                _stprintf(szNewFileName, _T("%s\\%s.bak"), strTempHelpHTMFilesDir2.QueryStr() , FindFileData.cFileName);
                                // move it
                                MoveFileEx( szOldFileName, szNewFileName, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING);
                            }
                        }
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) )
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return;
}


void WriteToMD_ForceMetabaseToWriteToDisk(void)
{
    if (CheckifServiceExist(_T("IISADMIN")) == 0 )
    {
        CMDKey cmdKey;
        cmdKey.ForceWriteMetabaseToDisk();

        //cmdKey.OpenNode(_T("/"));
        //if ( (METADATA_HANDLE)cmdKey )
        //{
        //    cmdKey.ForceWriteMetabaseToDisk();
        //    cmdKey.Close();
        //}
    }
    return;
}


DWORD WriteToMD_DefaultLoadFile(CString csKeyPath,CString csData)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    //stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR) csKeyPath;

    stMDEntry.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csData.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csData;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}


//
// Returns the amount of entries that we added.
//
int AddRequiredDefaultLoad(CStringArray& arrayName,IN LPCTSTR szSection)
{
    int c = 0;
    CStringList strList;

    TSTR strTheSection;

    if ( strTheSection.Copy( szSection ) &&
         GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
       )
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, strTheSection.QueryStr() ))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;

            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);

                // Add it to our array...
                // iisDebugOut((LOG_TYPE_TRACE, _T("Add default load Entry:%s:%s\n"),csName, csPath));
                arrayName.Add(csEntry);
                c++;

                strList.GetNext(pos);
            }
        }
    }
    }

    return c;
}


void VerifyMD_DefaultLoadFile_WWW(IN LPCTSTR szSection, CString csKeyPath)
{
    iisDebugOut_Start(_T("VerifyMD_DefaultLoadFile_WWW"), LOG_TYPE_TRACE);

    CMDKey cmdKey;
    BOOL bReturn = FALSE;
    BOOL fAddComma = FALSE;
    int i = 0;

    CStringArray arrayDefaultValues;
    int nArrayItems = 0;

    CString csFinalEntryToWrite;

    int iNewlyAdded_Count = 0;

    // open the key
    // cmdKey.OpenNode(_T("LM/W3SVC"));
    cmdKey.OpenNode(csKeyPath);

    // test for success.
    if ( (METADATA_HANDLE)cmdKey )
    {
        DWORD dwAttr = METADATA_INHERIT;
        DWORD dwUType = IIS_MD_UT_FILE;
        DWORD dwDType = STRING_METADATA;
        DWORD dwLength = 0;
        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        cmdKey.GetData( MD_DEFAULT_LOAD_FILE,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA);
        if (dwLength > 0)
        {
            // now get the real data from the metabase
            bReturn = cmdKey.GetData( MD_DEFAULT_LOAD_FILE,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csFinalEntryToWrite.GetBuffer( dwLength ),dwLength,METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA );
            csFinalEntryToWrite.ReleaseBuffer();
        }
        // the data doesn't get written out here, so close the metabase key
        cmdKey.Close();
        // if reading the value from the metabase didn't work, zero out the string
        if ( !bReturn ){csFinalEntryToWrite.Empty();}
    }
    // if there is something in the order string from the upgrade, then we need to start adding commas
    if ( !csFinalEntryToWrite.IsEmpty() )
    {
        fAddComma = TRUE;
        iisDebugOut((LOG_TYPE_TRACE, _T("VerifyMD_DefaultLoadFile_WWW:InitialEntry=%s.\n"),csFinalEntryToWrite));
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("VerifyMD_DefaultLoadFile_WWW:InitialEntry=None.\n")));
    }

    // Add Required Filters to the arrayDefaultValues
    AddRequiredDefaultLoad(arrayDefaultValues, szSection);
    nArrayItems = (int)arrayDefaultValues.GetSize();
    if ( nArrayItems == 0 ) {goto VerifyMD_DefaultLoadFile_WWW_Exit;}

    // now loop thru this list
    // and check if our isapi dll's are in this list.
    // if they are not, then we add them to the end.
    iNewlyAdded_Count = 0;
    for ( i = 0; i < nArrayItems; i++ )
    {
        // if the name in the array is already in the filter order list,
        // then continue to the next one
        if ( csFinalEntryToWrite.Find( arrayDefaultValues[i] ) >= 0 )
            {continue;}

        if (fAddComma == TRUE){csFinalEntryToWrite += _T(",");}
        else{fAddComma = TRUE;}

        // Add this entry to our list!
        csFinalEntryToWrite += arrayDefaultValues[i];

        iNewlyAdded_Count++;
    }

    // If we added any new entries to the metabase
    // the let's write out the new block of data, otherwise let's get out.
    if (iNewlyAdded_Count > 0)
    {
        WriteToMD_DefaultLoadFile(csKeyPath,csFinalEntryToWrite);
        iisDebugOut((LOG_TYPE_TRACE, _T("VerifyMD_DefaultLoadFile_WWW:NewEntry=%s.\n"),csFinalEntryToWrite));
    }

VerifyMD_DefaultLoadFile_WWW_Exit:
    iisDebugOut_End(_T("VerifyMD_DefaultLoadFile_WWW"),LOG_TYPE_TRACE);
    return;
}


INT Register_iis_www_handleScriptMap()
{
    int iReturn = TRUE;
    HRESULT         hRes;

    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"),FALSE);

    ScriptMapNode ScriptMapList = {0};
    // make it a sentinel
    ScriptMapList.next = &ScriptMapList;
    ScriptMapList.prev = &ScriptMapList;
    if (atWWW == AT_INSTALL_FRESH || atWWW == AT_INSTALL_REINSTALL)
    {
        GetScriptMapListFromClean(&ScriptMapList, _T("ScriptMaps_CleanList"));
    }
    if (atWWW == AT_INSTALL_UPGRADE)
    {
        switch (g_pTheApp->m_eUpgradeType)
        {
            case UT_50:
            case UT_51:
            case UT_60:
                //GetScriptMapListFromClean(&ScriptMapList, _T("ScriptMaps_CleanList"));
		GetScriptMapListFromMetabase(&ScriptMapList, g_pTheApp->m_eUpgradeType);
                break;
            case UT_40:
                GetScriptMapListFromMetabase(&ScriptMapList, g_pTheApp->m_eUpgradeType);
                break;
            case UT_10_W95:
            case UT_351:
            case UT_10:
            case UT_20:
            case UT_30:
            default:
                GetScriptMapListFromRegistry(&ScriptMapList);
                break;
        }
    }
    WriteScriptMapListToMetabase(&ScriptMapList, _T("LM/W3SVC"), MD_SCRIPTMAPFLAG_SCRIPT);

    if (atWWW == AT_INSTALL_UPGRADE)
    {
        //DumpScriptMapList();

        if ( g_pTheApp->GetUpgradeVersion() <= 4 )
        {
          // only invert the script map verbs if it is from 4.0 or before.
          // The reason is because 4.0 had an exclusion list, NOT inclusion list like 5 and 6
          // invert the script map verbs
          CInvertScriptMaps   inverter;
          hRes = inverter.Update( _T("LM/W3SVC") );
          if ( FAILED(hRes) )
          {
              iisDebugOut((LOG_TYPE_ERROR, _T("inverter.Update():FAILED Invert script map verbs =%x.\n"),hRes));
          }
        }

        // fix the IPSec reference bit flags
        CIPSecRefBitAdder   refFixer;
        hRes = refFixer.Update( _T("LM/W3SVC") );
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("refFixer.Update(): FAILED Fix IPSEC ref flag =%x.\n"),hRes));
        }
        //DumpScriptMapList();
    }

    //
    // Whack the old Script Map RegKey
    //
    CRegKey regMachine = HKEY_LOCAL_MACHINE;
    CRegKey regWWWParam( REG_WWWPARAMETERS, regMachine );
    if ((HKEY) regWWWParam ) {regWWWParam.DeleteTree(_T("Script Map"));}

    FreeScriptMapList(&ScriptMapList);
    return iReturn;
}

int ReOrderFiltersSpecial(int nArrayItems,CStringArray& arrayName,CString& csOrder)
{
    int bFound = FALSE;
    int i = 0;
    CString csOrderTemp;
    CString csOrderTemp2;

    CStringList     cslStringListTemp;
    CString         csOneEntry;
    POSITION        pos;
    int             numInList;

    // make a copy of string we'll be working with
    csOrderTemp = csOrder;


    // scan through the list of filters we want to add/makesureisthere.

    //
    //       SPECIAL HANDLING FOR SSPIFILT
    //
    // if we want to add the sspifilt then apply these rules:
    //	  if sspifilt is on the list then just leave it there.
    //	  if sspifilt is not on the list then stick it in first position.
    //
    bFound = FALSE;
    for ( i = 0; i < nArrayItems; i++ )
    {
        if (_tcsicmp(arrayName[i], _T("SSPIFILT")) == 0)
            {bFound = TRUE;}
    }
    // we found sspifilt in the value's list that we want to add
    if (bFound)
    {
        csOrderTemp2 = csOrderTemp;
        csOrderTemp2.MakeUpper();
        csOrderTemp2.TrimLeft();
        csOrderTemp2.TrimRight();

        // now check if it's in the existing users list.
        if ( csOrderTemp2.Find( _T("SSPIFILT") ) >= 0 )
        {
            // yes, it's already there. just leave it there.
        }
        else
        {
            // changes csOrderTemp
            AddFilter1ToFirstPosition(csOrderTemp, _T("sspifilt"));
        }
    }

    //       SPECIAL HANDLING FOR Compression FILTER
    //
    // if we want to add the Compression filter then apply these rules:
    //	 if compression is on the list, then just make sure it's after sspifilt.  (re-order they're existing loadorder)
    //	 if compression is not on the list then stick it after sspifilt. (insert it in the existing list)
    //
    bFound = FALSE;
    for ( i = 0; i < nArrayItems; i++ )
    {
        if (_tcsicmp(arrayName[i], _T("COMPRESSION")) == 0)
            {bFound = TRUE;}
    }
    // we found compression in the value's list that we want to add
    if (bFound)
    {
        // now check if it's in the existing users list.
        csOrderTemp2 = csOrderTemp;
        csOrderTemp2.MakeUpper();
        csOrderTemp2.TrimLeft();
        csOrderTemp2.TrimRight();
        if ( csOrderTemp2.Find( _T("COMPRESSION") ) >= 0 )
        {
            // Make sure it's after sspifilt!
            // yucky!

            // 1. check if it's already after sspifilt.
            //    a. if it is cool, get out.
            //    b. if not then reorder it so that it is
            CString csOrderTemp2 = csOrderTemp;
            csOrderTemp2.MakeUpper();
            csOrderTemp2.TrimLeft();
            csOrderTemp2.TrimRight();

            int numInList1 = csOrderTemp2.Find(_T("COMPRESSION"));
            int numInList2 = csOrderTemp2.Find(_T("SSPIFILT"));
            if (numInList2 != -1)
            {
                if (numInList1 < numInList2)
                {
                    // if compression is before sspifilt, then we'll have to remove it
                    numInList = ConvertSepLineToStringList(csOrderTemp,cslStringListTemp,_T(","));
                    bFound = FALSE;
                    pos = cslStringListTemp.GetHeadPosition();
                    while (pos)
                    {
                        csOneEntry = cslStringListTemp.GetAt(pos);
                        csOneEntry.TrimLeft();
                        csOneEntry.TrimRight();
                        // Does this contain sspifilt?
                        if (_tcsicmp(csOneEntry, _T("COMPRESSION")) == 0)
                        {
                            // Here it is, let's delete it.
                            if ( NULL != pos )
                                {cslStringListTemp.RemoveAt(pos);}
                            // break out of the loop
                            bFound = TRUE;
                            break;
                        }
                        // get the next one
                        cslStringListTemp.GetNext(pos);
                    }
                    if (bFound)
                    {
                        // convert the stringlist back into the comma delimited cstring.
                        ConvertStringListToSepLine(cslStringListTemp,csOrderTemp,_T(","));
                    }

                    // loop thru and add Compression after sspifilt
                    //it is not in the users list, let's stick it after sspifilt.
                    AddFilter1AfterFilter2(csOrderTemp, _T("Compression"), _T("sspifilt"));
                }
            }
            else
            {
                // sspifilt was not found.
                //it is not in the users list, let's stick it in the first position.
                // changes csOrderTemp
                AddFilter1ToFirstPosition(csOrderTemp, _T("sspifilt"));
            }
        }
        else
        {
            // it is not in the users list, let's stick it after sspifilt.
            // check if sspifilt already exists..
            AddFilter1AfterFilter2(csOrderTemp, _T("Compression"), _T("sspifilt"));
        }
    }

    csOrder = csOrderTemp;
    return TRUE;
}

void AddFilter1ToFirstPosition(CString& csOrder,LPTSTR szFilter1)
{
    CString csNewOrder;

    //it is not in the users list, let's stick it in the first position.
    csNewOrder = szFilter1;
    if (!csOrder.IsEmpty())
    {
        csNewOrder += _T(",");
        csNewOrder += csOrder;
    }
    // set it back to csOrderTemp
    csOrder = csNewOrder;
}

void AddFilter1AfterFilter2(CString& csOrder,LPTSTR szFilter1,LPTSTR szFilter2)
{
    int bFound = FALSE;
    CStringList     cslStringListTemp;
    CString         csOneEntry;
    POSITION        pos;
    int             numInList;

    CString csOrderTemp;
    CString csNewOrder;

    csOrderTemp = csOrder;

    // we have already determined that filter1 is not in the list
    // add filter1 after filter2.

    // split up the comma delimited csOrder entry into string list.
    numInList = ConvertSepLineToStringList(csOrderTemp,cslStringListTemp,_T(","));

    bFound = FALSE;
    pos = cslStringListTemp.GetHeadPosition();
    while (pos)
    {
        csOneEntry = cslStringListTemp.GetAt(pos);
        csOneEntry.TrimLeft();
        csOneEntry.TrimRight();

        // Does this contain filter#2?
        if (_tcsicmp(csOneEntry, szFilter2) == 0)
        {
            // Here it is, so insert compression after this one...
            cslStringListTemp.InsertAfter(pos, (CString) szFilter1);
            // break out of the loop
            bFound = TRUE;
            break;
        }

        // get the next one
        cslStringListTemp.GetNext(pos);
    }
    if (bFound)
    {
        // convert the stringlist back into the comma delimited cstring.
        ConvertStringListToSepLine(cslStringListTemp,csOrderTemp,_T(","));
    }
    else
    {
        // we didn't find sspifilt,
        //it is not in the users list, let's stick it in the first position.
        csNewOrder = szFilter2;
        csNewOrder += _T(",");
        csNewOrder += szFilter1;

        if (!csOrderTemp.IsEmpty())
        {
            csNewOrder += _T(",");
            csNewOrder += csOrderTemp;
        }
        // set it back to csOrderTemp
        csOrderTemp = csNewOrder;
    }

    csOrder = csOrderTemp;
    return;
}

int GetScriptMapAllInclusionVerbs(CString &csTheVerbList)
{
    int iReturn = FALSE;
    int c = 0;
    CStringArray arrayName;
    CStringList strList;
    TSTR        strTheSection;

    if ( strTheSection.Copy( _T("ScriptMaps_All_Included_Verbs") ) &&
         GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
       )
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, strTheSection.QueryStr() ))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            pos = strList.GetHeadPosition();
            if (pos)
            {
                // Set it to the 1st value in the list and that's all
                csTheVerbList = strList.GetAt(pos);

                iReturn = TRUE;
            }
       }
    }
    }

    return iReturn;
}



void GetScriptMapListFromClean(ScriptMapNode *pList, IN LPCTSTR szSection)
{
    iisDebugOut_Start1(_T("GetScriptMapListFromClean"), (LPTSTR) szSection, LOG_TYPE_TRACE);

    CString csExtention = _T("");
    CString csBinaryPath = _T("");
    CString csVerbs = _T("");
    CStringList strList;
    TSTR strTheSection;

    ScriptMapNode *pNode;

    if ( strTheSection.Copy( szSection ) &&
         GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
       )
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, strTheSection.QueryStr() ))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            int numParts;
            CString     csEntry;
            CStringList cslEntryList;
            CString     szDelimiter = _T("|");
            CString     csTemp;
            DWORD       dwFlags;
            POSITION    posEntryList;

            POSITION pos = NULL;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);

                // entry should look something like this.
                //.asp|c:\winnt\system32\inetsrv\asp.dll|GET,HEAD,POST,TRACE

                // break into a string list
                numParts = ConvertSepLineToStringList(csEntry,cslEntryList,szDelimiter);

                posEntryList = cslEntryList.FindIndex(0);
                if (NULL != posEntryList)
                {
                    csExtention = cslEntryList.GetNext( posEntryList );
                    // no whitespace before or after
                    csExtention.TrimLeft();
                    csExtention.TrimRight();
                }
                if (NULL != posEntryList)
                {
                    csBinaryPath = cslEntryList.GetNext( posEntryList );
                    // no whitespace before or after
                    csBinaryPath.TrimLeft();
                    csBinaryPath.TrimRight();
                }
                if (NULL != posEntryList)
                {
                    csVerbs = cslEntryList.GetNext( posEntryList );
                    // make sure the verb is normalized to capitals and
                    // no whitespace before or after
                    csVerbs.MakeUpper();
                    csVerbs.TrimLeft();
                    csVerbs.TrimRight();
                }

                dwFlags = 0;

                // Check to see if there is a additional flag that will be used for the script map.
                if (NULL != posEntryList)
                {
                    csTemp = cslEntryList.GetNext( posEntryList );
                    // make sure there are no whitespaces before or after
                    csTemp.TrimLeft();
                    csTemp.TrimRight();

                    if (!csTemp.IsEmpty())
                    {
                        dwFlags = atodw(csTemp.GetBuffer(1));
                    }
                }

                // Add this script map to our list.
                if (csExtention && csBinaryPath)
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("GetScriptMapListFromClean(%s).entry=%s|%s|%s.\n"),szSection, csExtention,csBinaryPath,csVerbs));
                    pNode = AllocNewScriptMapNode((LPTSTR)(LPCTSTR) csExtention, (LPTSTR)(LPCTSTR) csBinaryPath, MD_SCRIPTMAPFLAG_SCRIPT | dwFlags, (LPTSTR)(LPCTSTR) csVerbs);
                    InsertScriptMapList(pList, pNode, TRUE);
                }

                strList.GetNext(pos);
            }
        }
    }
    }

    iisDebugOut_End1(_T("GetScriptMapListFromClean"),szSection,LOG_TYPE_TRACE);
    return;
}


DWORD WriteToMD_IDRegistration(CString csKeyPath)
{
    iisDebugOut_Start1(_T("WriteToMD_IDRegistration"), csKeyPath, LOG_TYPE_TRACE);

    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    TSTR strTheSection;
    CStringList strList;
    TCHAR szData[_MAX_PATH];

    memset( (PVOID)szData, 0, sizeof(szData));

    //_tcscpy(szData, _T("0-65535;Microsoft Reserved|65536-524288;Microsoft IIS Admin Objects Reserved"));

    if ( strTheSection.Copy( _T("IIS_Metabase_IDRegistration") ) &&
         GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
       )
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, strTheSection.QueryStr() ))
    {
        _tcscpy(szData, _T(""));

        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            int c = 0;
            POSITION pos = NULL;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);

                iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_IDRegistration().csEntry=%s.\n"),csEntry));

                // concatenate to our big string
                if (c > 0){_tcscat(szData, _T("|"));}
                _tcscat(szData, csEntry);

                // increment the counter
                c++;
                strList.GetNext(pos);
            }
        }
    }
    }

    if (szData)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_IDRegistration().Data=%s.\n"),szData));

        TCHAR *p = (LPTSTR) szData;
        while (*p)
        {
            //  replace all '|' with a null
            if (*p == _T('|'))
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_IDRegistration().Data[...]=%c.\n"),*p));
                *p = _T('\0');
            }
            p = _tcsinc(p);
        }

        stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
        stMDEntry.dwMDIdentifier = MD_METADATA_ID_REGISTRATION;
        stMDEntry.dwMDAttributes = METADATA_INHERIT;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = MULTISZ_METADATA;
        stMDEntry.dwMDDataLen = GetMultiStrSize(szData) * sizeof(TCHAR);
        stMDEntry.pbMDData = (LPBYTE)szData;
        dwReturn = SetMDEntry_Wrap(&stMDEntry);
    }

    iisDebugOut_End1(_T("WriteToMD_IDRegistration"),csKeyPath,LOG_TYPE_TRACE);
    return dwReturn;
}




DWORD WriteToMD_AspCodepage(CString csKeyPath, DWORD dwValue, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/2/ROOT
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ASP_CODEPAGE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = ASP_MD_UT_APP;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwValue;
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_AspCodepage:%s:%d:%d.\n"),csKeyPath, dwValue, iOverWriteAlways));
    return dwReturn;
}


//     HttpCustom                    : [IF]    (MULTISZ) "Content-Type: Text/html; Charset=UTF-8"
DWORD WriteToMD_HttpCustom(CString csKeyPath, CString csData, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    TCHAR szData[_MAX_PATH];
    memset( (PVOID)szData, 0, sizeof(szData));
    _stprintf(szData, _T("%s"), csData);

    // LM/W3SVC/2/ROOT
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_HTTP_CUSTOM;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = GetMultiStrSize(szData) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)szData;
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_HttpCustom:%s:%s:%d.\n"),csKeyPath, csData, iOverWriteAlways));
    return dwReturn;
}


DWORD WriteToMD_EnableParentPaths_WWW(CString csKeyPath, BOOL bEnableFlag)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ASP_ENABLEPARENTPATHS;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = ASP_MD_UT_APP;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    // turn it on
    if (bEnableFlag)
    {
        dwData = 0x1;
    }
    else
    {
        dwData = 0x0;
    }
    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


void EnforceMaxConnections(void)
{
    // if this is not workstation then get out.
    if (g_pTheApp->m_eNTOSType == OT_NTW)
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("EnforceMaxConnections: Start.\n")));
        HRESULT hRes;
        CEnforceMaxConnection MaxConnectionEnforcer;

        // loop thru the metabase and get all places where MaxConnections is found.
        // if these are larger than 10 then set it to 10.
        iisDebugOut((LOG_TYPE_TRACE, _T("EnforceMaxConnections: Before.\n")));
        hRes = MaxConnectionEnforcer.Update(_T("LM/W3SVC"));
        if (FAILED(hRes))
            {iisDebugOut((LOG_TYPE_WARN, _T("EnforceMaxConnections.Update(LM/W3SVC):FAILED= %x.\n"),hRes));}

        hRes = MaxConnectionEnforcer.Update(_T("LM/MSFTPSVC"));
        if (FAILED(hRes))
            {iisDebugOut((LOG_TYPE_WARN, _T("EnforceMaxConnections.Update(LM/MSFTPSVC):FAILED= %x.\n"),hRes));}

        //iisDebugOut((LOG_TYPE_TRACE, _T("EnforceMaxConnections: End.\n")));
    }
    return;
}

DWORD WriteToMD_DwordEntry(CString csKeyPath,DWORD dwID,DWORD dwAttrib,DWORD dwUserType,DWORD dwTheData,INT iOverwriteFlag)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwCopyOfTheData = dwTheData;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = dwID;
    stMDEntry.dwMDAttributes = dwAttrib;
    stMDEntry.dwMDUserType = dwUserType;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwCopyOfTheData;
    if (iOverwriteFlag)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    return dwReturn;
}

#define REASONABLE_TIMEOUT 1000

HRESULT
RemoveVirtualDir(
    IMSAdminBase *pIMSAdminBase,
    WCHAR * pwszMetabasePath,
    WCHAR * pwszVDir
)
{
    METADATA_HANDLE hMetabase = NULL;
    HRESULT hr = E_FAIL;

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         pwszMetabasePath,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    if( FAILED( hr )) {
        iisDebugOut((LOG_TYPE_ERROR, _T("RemoveVirtualDir:FAILED 0x%x\n"),hr));
        return hr;
    }

    // We don't check the return value since the key may already
    // not exist and we could get an error for that reason.
    pIMSAdminBase->DeleteKey( hMetabase, pwszVDir );
    pIMSAdminBase->CloseKey( hMetabase );
    return hr;
}


HRESULT
AddVirtualDir(
    IMSAdminBase *pIMSAdminBase,
    WCHAR * pwszMetabasePath,
    WCHAR * pwszVDir,
    WCHAR * pwszPhysicalPath,
    DWORD dwPermissions,
    INT   iApplicationType
)
{
    HRESULT hr;
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    WCHAR   szTempPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen = 0;
    DWORD   dwAccessPerm = 0;
    METADATA_RECORD mr;

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         pwszMetabasePath,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    // Create the key if it does not exist.
    if( FAILED( hr )) {goto AddVirtualDir_Exit;}

    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szTempPath );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szTempPath);

    // see if MD_VR_PATH exists.
    hr = pIMSAdminBase->GetData( hMetabase, pwszVDir, &mr, &dwMDRequiredDataLen );
    if( FAILED( hr ))
    {
        if( hr == MD_ERROR_DATA_NOT_FOUND || HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND )
        {

            // Write both the key and the values if GetData() failed with any of the two errors.

            pIMSAdminBase->AddKey( hMetabase, pwszVDir );

            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = METADATA_INHERIT;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = (wcslen(pwszPhysicalPath) + 1) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(pwszPhysicalPath);

            // Write MD_VR_PATH value
            hr = pIMSAdminBase->SetData( hMetabase, pwszVDir, &mr );
        }
    }

    // set the key type to say this is a www vdir!
    if(SUCCEEDED(hr))
    {
        PWCHAR  szKeyType = IIS_CLASS_WEB_VDIR_W;

        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szKeyType);

        // Write value
        hr = pIMSAdminBase->SetData( hMetabase, pwszVDir, &mr );
    }

    // set access permissions
    if (dwPermissions != -1)
    {
        if(SUCCEEDED(hr))
        {
            dwAccessPerm = dwPermissions;

            mr.dwMDIdentifier = MD_ACCESS_PERM;
            mr.dwMDAttributes = METADATA_INHERIT;    // Make it inheritable so all subdirectories will have the same rights.
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = DWORD_METADATA;
            mr.dwMDDataLen    = sizeof(DWORD);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);

            // Write MD_ACCESS_PERM value
            hr = pIMSAdminBase->SetData( hMetabase, pwszVDir, &mr );
        }
    }

    // if all that succeeded, then try to create the application, if they wanted one
    if (iApplicationType != -1)
    {
        if(SUCCEEDED(hr))
        {
            // Create the path
            // create an in process application
            CString csThePath;
            csThePath = pwszMetabasePath;
            csThePath += _T('/');
            csThePath += pwszVDir;

            if (iApplicationType == 1)
            {
                CreateInProc(csThePath, FALSE);
            }
            else
            {
                // create a pooled application
                CreateInProc(csThePath, TRUE);
            }
        }
    }

    pIMSAdminBase->CloseKey( hMetabase );

AddVirtualDir_Exit:
    if FAILED(hr)
        {iisDebugOut((LOG_TYPE_ERROR, _T("AddVirtualDir:FAILED 0x%x\n"),hr));}
    return hr;
}

int RemoveMetabaseFilter(TCHAR * szFilterName, int iRemoveMetabaseNodes)
{
    iisDebugOut_Start(_T("RemoveMetabaseFilter"),LOG_TYPE_TRACE);
    int iReturn = FALSE;
    CString csOrder;
    CString csLookingFor;
    CMDKey  cmdKey;

    // zero out the order string
    csOrder.Empty();

    // open the key to the virtual server, which is what is passed in as a parameter
    cmdKey.OpenNode( _T("LM/W3SVC/Filters") );
    if ( (METADATA_HANDLE)cmdKey )
    {
		BOOL    bReturn;
        DWORD dwAttr = METADATA_NO_ATTRIBUTES;
        DWORD dwUType = IIS_MD_UT_SERVER;
        DWORD dwDType = STRING_METADATA;
        DWORD dwLength = 0;

        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA);

        // give the buffer some head space
        // dwLength += 2;
        bReturn = FALSE;
        if (dwLength > 0)
        {
            // now get the real data from the metabase
            bReturn = cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csOrder.GetBuffer( dwLength ),dwLength,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA );
            csOrder.ReleaseBuffer();
        }

        // the data doesn't get written out here, so close the metabase key
        cmdKey.Close();

        // if reading the value from the metabase didn't work, zero out the string
        if ( !bReturn )
            {csOrder.Empty();}
    }

    // if there is something in the order string from the upgrade
	// then we need to look thru it
    if ( !csOrder.IsEmpty() )
    {
		csOrder.MakeLower();
        csLookingFor = szFilterName;
        csLookingFor.MakeLower();
		if (csOrder.Find(csLookingFor) != -1)
		{
			CStringList     cslStringListTemp;
			CString         csOneEntry;
			POSITION        pos;
			int             numInList;
			int             bFound;

			numInList = ConvertSepLineToStringList(csOrder,cslStringListTemp,_T(","));
			bFound = FALSE;
			pos = cslStringListTemp.GetHeadPosition();
			while (pos)
			{
                csOneEntry = cslStringListTemp.GetAt(pos);
				csOneEntry.TrimLeft();
				csOneEntry.TrimRight();
				// Does this contain our filter?
				if (_tcsicmp(csOneEntry, szFilterName) == 0)
				{
					// Here it is, let's delete it.
					if ( NULL != pos )
						{
                        cslStringListTemp.RemoveAt(pos);
                        }
					// break out of the loop
					bFound = TRUE;
					break;
				}
				// get the next one
				cslStringListTemp.GetNext(pos);
			}

			// if we found and deleted it then
			// go and write out the new string!
			if (bFound)
			{
				// convert the stringlist back into the comma delimited cstring.
				ConvertStringListToSepLine(cslStringListTemp,csOrder,_T(","));
				// write it out
				WriteToMD_Filters_List_Entry(csOrder);
			}
		}
    }

	if (iRemoveMetabaseNodes)
	{
		// let's remove the metabase node as well!

		// delete the metabase node.
		if (CheckifServiceExist(_T("IISADMIN")) == 0 )
		{

			cmdKey.OpenNode(_T("LM/W3SVC/Filters"));
			if ( (METADATA_HANDLE)cmdKey )
			{
				cmdKey.DeleteNode(szFilterName);
				cmdKey.Close();
			}
		}
	}


//RemoveMetabaseFilter_Exit:
    iisDebugOut_End1(_T("RemoveMetabaseFilter"),csOrder,LOG_TYPE_TRACE);
	return iReturn;
}


int GetIncompatibleFilters(LPTSTR szTheSection, CStringArray& arrayName,CStringArray& arrayPath)
{
    int c = 0;
    CString csName = _T("");
    CString csPath = _T("");
    TSTR    strTheSection;

    CStringList strList;

    iisDebugOut((LOG_TYPE_TRACE, _T("ProcessFilters:%s\n"),szTheSection));
    if ( strTheSection.Copy( szTheSection ) &&
         GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
       )
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, strTheSection.QueryStr() ))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);
                // Split into name, and value. look for ","
                int i;
                i = csEntry.ReverseFind(_T(','));
                if (i != -1)
                {
                    int len =0;
                    len = csEntry.GetLength();
                    csPath = csEntry.Right(len - i - 1);
                    csName = csEntry.Left(i);

                    // Add it to our array...
                    arrayName.Add(csName);
                    arrayPath.Add(csPath);
                    c++;
                }
                else
                {
                    // Add it to our array...
                    arrayName.Add(csEntry);
                    arrayPath.Add(csEntry);
                    c++;
                }

                strList.GetNext(pos);
            }
        }
    }
    }
    return c;
}

BOOL IsStringInArray(CString csItem, CStringArray &arrayInput)
{
    BOOL bReturn = FALSE;
    int nArrayItems = (int) arrayInput.GetSize();

    if (nArrayItems <= 0)
    {
        goto IsCStringInArray_Exit;
    }

    // Does this contain our filtername?
    for (int iCount=0; iCount<nArrayItems; iCount++)
	{
        if (_tcsicmp(csItem, arrayInput[iCount]) == 0)
        {
            // we found the entry
            bReturn =  TRUE;
            goto IsCStringInArray_Exit;
        }
    }
    bReturn = FALSE;

IsCStringInArray_Exit:
    return bReturn;
}

int RemoveIncompatibleMetabaseFilters(LPTSTR szSectionName,int iRemoveMetabaseNodes)
{
    DWORD dwReturn = ERROR_SUCCESS;
    CMDKey cmdKey;
    int iBadFiltersCount=0,iCount=0;
    CString csOrder;
    CString csOneEntry;
    CString csRemovedFilters;
    CStringList cslStringListTemp;
    CStringArray arrayName, arrayPath;
    BOOL bFound = FALSE;
    POSITION pos1,pos2 = NULL;
    INT     nArrayItems;

	BOOL  bReturn = FALSE;
	DWORD dwAttr = METADATA_NO_ATTRIBUTES;
	DWORD dwUType = IIS_MD_UT_SERVER;
	DWORD dwDType = STRING_METADATA;
	DWORD dwLength = 0;

    iisDebugOut_Start(_T("RemoveIncompatibleMetabaseFilters"),LOG_TYPE_TRACE);

    // Add Required Filters to the arrayName
    csOrder.Empty();
    iBadFiltersCount = GetIncompatibleFilters( szSectionName, arrayName, arrayPath);
    nArrayItems = (INT)arrayName.GetSize();
    if (nArrayItems <= 0)
    {
        goto RemoveIncompatibleMetabaseFilters_Exit;
    }

	// open the existing key in the metabase and get that value
	cmdKey.OpenNode( _T("LM/W3SVC/Filters") );
	if ( !(METADATA_HANDLE)cmdKey )
	{
		goto RemoveIncompatibleMetabaseFilters_Exit;
	}

	// we need to start this process by getting the existing multisz data from the metabase
	// first, figure out how much memory we will need to do this
	cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA);
	bReturn = FALSE;
	if (dwLength > 0)
	{
		// now get the real data from the metabase
		bReturn = cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csOrder.GetBuffer( dwLength ),dwLength,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA );
		csOrder.ReleaseBuffer();
	}
	cmdKey.Close();
	if ( !bReturn )
	{
		csOrder.Empty();
		goto RemoveIncompatibleMetabaseFilters_Exit;
	}

	// if there is nothing in order then get out
    if ( csOrder.IsEmpty() )
    {
        goto RemoveIncompatibleMetabaseFilters_Exit;
    }

    // split up the comma delimited csOrder entry into string list.
	bFound = FALSE;
    ConvertSepLineToStringList(csOrder,cslStringListTemp,_T(","));

    for( pos1 = cslStringListTemp.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
    {
        csOneEntry = cslStringListTemp.GetNext(pos1);
        csOneEntry.TrimLeft();
        csOneEntry.TrimRight();
        // Does this contain our filtername?
        if (TRUE == IsStringInArray(csOneEntry,arrayName))
        {
            csRemovedFilters += _T(',') + csOneEntry;
            cslStringListTemp.RemoveAt(pos2);
            bFound = TRUE;
        }
    }

    // now we have csOrder=f1,f2,f3,sspifilt
    if (bFound)
    {
        if (cslStringListTemp.IsEmpty())
        {
            // hardcode this entry in
            csOrder = _T(" ");
            dwReturn = WriteToMD_Filters_List_Entry(csOrder);
        }
        else
        {
            // convert the stringlist back into the comma delimited cstring.
            ConvertStringListToSepLine(cslStringListTemp,csOrder,_T(","));

            dwReturn = WriteToMD_Filters_List_Entry(csOrder);
        }
	    if (iRemoveMetabaseNodes)
	    {
            if (ERROR_SUCCESS == dwReturn)
            {
		        // let's remove the metabase node as well!
		        // delete the metabase node.
		        if (CheckifServiceExist(_T("IISADMIN")) == 0 )
		        {
                    int i = 0;
                    // loop thru the list of bad filters to remove and remove them.
                    i = csRemovedFilters.ReverseFind(_T(','));
                    while (i != -1)
                    {
                        int len = csRemovedFilters.GetLength();
                        csOneEntry = csRemovedFilters.Right(len - i - 1);

                        if (_tcsicmp(csOneEntry, _T("")) != 0)
                        {
			                cmdKey.OpenNode(_T("LM/W3SVC/Filters"));
			                if ( (METADATA_HANDLE)cmdKey )
			                {
				                cmdKey.DeleteNode(csOneEntry);
				                cmdKey.Close();
			                }
                        }
                        csRemovedFilters = csRemovedFilters.Left(i);
                        i = csRemovedFilters.ReverseFind(_T(','));
                    }
		        }
            }
        }
    }

RemoveIncompatibleMetabaseFilters_Exit:
    iisDebugOut_End(_T("RemoveIncompatibleMetabaseFilters"),LOG_TYPE_TRACE);
    return dwReturn;
}

int DoesAppIsolatedExist(CString csKeyPath)
{
    int iReturn = false;
    MDEntry stMDEntry;
    DWORD dwValue = 0;

    // LM/W3SVC/1/ROOT/something
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_APP_ISOLATED;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_WAM;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwValue;

    if (ChkMdEntry_Exist(&stMDEntry))
    {
        iReturn = TRUE;
    }
    return iReturn;
}


DWORD WriteToMD_RootKeyType(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;
    CString csKeyPath = _T("/");

    csKeyType = _T("IIS_ROOT");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


void UpgradeFilters(CString csTheSection)
{
    TSTR  strTheSection;

    if ( g_pTheApp->m_bUpgradeTypeHasMetabaseFlag &&
         strTheSection.Copy( csTheSection )
       )
    {
        VerifyMD_Filters_WWW( strTheSection );
    }
    else
    {
        WriteToMD_Filters_WWW( strTheSection );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\oldcode.cpp ===
//
// checker.h <start>
//
#include <lmaccess.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmerr.h>

#define SECURITY_WIN32
#define ISSP_LEVEL  32
#define ISSP_MODE   1
#include <sspi.h>


#ifndef _CHICAGO_
    int CheckConfig_DoIt(HWND hDlg, CStringList &strListOfWhatWeDid);
    BOOL ValidatePassword(IN LPCWSTR UserName,IN LPCWSTR Domain,IN LPCWSTR Password);
#endif
DWORD WINAPI ChkConfig_MessageDialogThread(void *p);
INT_PTR CALLBACK ChkConfig_MessageDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
void CheckConfig(void);
int g_BigCancel = FALSE;
//
// checker.h  <end>
//

#ifndef _CHICAGO_
BOOL ValidatePassword(IN LPCWSTR UserName,IN LPCWSTR Domain,IN LPCWSTR Password)
/*++
Routine Description:
    Uses SSPI to validate the specified password
Arguments:
    UserName - Supplies the user name
    Domain - Supplies the user's domain
    Password - Supplies the password
Return Value:
    TRUE if the password is valid.
    FALSE otherwise.
--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ClientCredHandle;
    CredHandle ServerCredHandle;
    BOOL ClientCredAllocated = FALSE;
    BOOL ServerCredAllocated = FALSE;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    TCHAR TargetName[100];
    SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;
    BOOL Validated = FALSE;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( _T("NTLM"), &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    _T("NTLM"),
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    _T("NTLM"),
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }

    ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT;

    InitStatus = InitializeSecurityContext(
                    &ClientCredHandle,
                    NULL,               // No Client context yet
                    NULL,
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(InitStatus) ) {
        goto error_exit;
    }

    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    &ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(AcceptStatus) ) {
        goto error_exit;
    }

    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            goto error_exit;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( !NT_SUCCESS(SecStatus) ) {
            goto error_exit;
        }

        if (AcceptStatus != STATUS_SUCCESS) {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( !NT_SUCCESS(SecStatus) ) {
                goto error_exit;
            }
            Validated = TRUE;

        }

    }

error_exit:
    if (ServerCredAllocated) {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated) {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(Validated);
}
#endif

DWORD WINAPI ChkConfig_MessageDialogThread(void *p)
{
    HWND hDlg = (HWND)p;
	int iReturn = TRUE;
    CStringList strWhatWeDidList;
    CString csBigString;

	SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Scanning..."));

    // call our function
#ifndef _CHICAGO_
    CheckConfig_DoIt(hDlg, strWhatWeDidList);
#endif

    // check for cancellation
    if (g_BigCancel == TRUE) goto ChkConfig_MessageDialogThread_Cancelled;

	SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Completed."));

	// Hide the Search window
	ShowWindow(hDlg, SW_HIDE);

    // Loop thru the what we did list and display the messages:
    //strWhatWeDidList
    if (strWhatWeDidList.IsEmpty() == FALSE)
    {
        POSITION pos = NULL;
        CString csEntry;
        pos = strWhatWeDidList.GetHeadPosition();
        while (pos) 
        {
            csEntry = strWhatWeDidList.GetAt(pos);
            //iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s!\n"), csEntry));
            csBigString = csBigString + csEntry;
            csBigString = csBigString + _T("\n");

            strWhatWeDidList.GetNext(pos);
        }
    }
    else
    {
        csBigString = _T("No changes.");
    }

    TCHAR szBiggerString[_MAX_PATH];
    _stprintf(szBiggerString, _T("Changes:\n%s"), csBigString);

	MyMessageBox((HWND) GetDesktopWindow(), szBiggerString, _T("Check Config Done"), MB_OK);

ChkConfig_MessageDialogThread_Cancelled:
	PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0);
	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose: display the wait dailog and spawn thread to do stuff
//*
//***************************************************************************
INT_PTR CALLBACK ChkConfig_MessageDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static HANDLE  hProc = NULL;
    DWORD   id;

    switch (uMsg)
    {
        case WM_INITDIALOG:
			uiCenterDialog(hDlg);
            hProc = CreateThread(NULL, 0, ChkConfig_MessageDialogThread, (LPVOID)hDlg, 0, &id);
            if (hProc == NULL)
            {
				MyMessageBox((HWND) GetDesktopWindow(), _T("Failed to CreateThread MessageDialogThread.\n"), MB_ICONSTOP);
                EndDialog(hDlg, -1);
            }
            UpdateWindow(hDlg);
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDOK:
                case IDCANCEL:
					g_BigCancel = TRUE;
                    EndDialog(hDlg, (int)wParam);
                    return TRUE;
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

void CheckConfig(void)
{
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("CheckConfig:"));
	DWORD err = FALSE;
    
	// Search for the ie setup program
	g_BigCancel = FALSE;
	if (-1 == DialogBox((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDD_DIALOG_MSG), NULL, ChkConfig_MessageDialogProc))
		{
        GetErrorMsg(GetLastError(), _T(": on CheckConfig"));
        }

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
	return;
}


//
//  Function will open the metabase and check the iusr_ and iwam_ usernames.  
//  it will check if the names are still valid and if the passwords are still valid.
//
#ifndef _CHICAGO_
#define CheckConfig_DoIt_log _T("CheckConfig_DoIt")
int CheckConfig_DoIt(HWND hDlg, CStringList &strListOfWhatWeDid)
{
    int iReturn = FALSE;
    iisDebugOut_Start(CheckConfig_DoIt_log,LOG_TYPE_PROGRAM_FLOW);

    TCHAR szAnonyName_WAM[_MAX_PATH];
    TCHAR szAnonyPass_WAM[LM20_PWLEN+1];
    TCHAR szAnonyName_WWW[_MAX_PATH];
    TCHAR szAnonyPass_WWW[LM20_PWLEN+1];
    TCHAR szAnonyName_FTP[_MAX_PATH];
    TCHAR szAnonyPass_FTP[LM20_PWLEN+1];
    int iGotName_WWW = FALSE;
    int iGotPass_WWW = FALSE;
    int iGotName_WAM = FALSE;
    int iGotPass_WAM = FALSE;
    int iGotName_FTP = FALSE;
    int iGotPass_FTP = FALSE;

    INT iUserWasNewlyCreated = 0;

    TCHAR szEntry[_MAX_PATH];

    // Call CreatePassword to fill
    LPTSR pszPassword = NULL;
    pszPassword = CreatePassword(LM20_PWLEN+1);
    if (!pszPassword)
    {
        goto CheckConfig_DoIt_Exit;
    }

    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Checking for IISADMIN Service..."));

    if (CheckifServiceExist(_T("IISADMIN")) != 0 ) 
    {
        // the iisadmin service does not exist
        // so there is no way we can do anything with the metabase.
        goto CheckConfig_DoIt_Exit;
    }

    //
    // Get the WAM username and password
    //
    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Lookup iWam username..."));
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/W3SVC"), MD_WAM_USER_NAME, (PBYTE)szAnonyName_WAM, _MAX_PATH))
        {iGotName_WAM = TRUE;}
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/W3SVC"), MD_WAM_PWD, (PBYTE)szAnonyPass_WAM, _MAX_PATH))
        {iGotPass_WAM = TRUE;}

    //
    // Get the WWW username and password
    //
    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Lookup iUsr username..."));
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/W3SVC"), MD_ANONYMOUS_USER_NAME, (PBYTE)szAnonyName_WWW, _MAX_PATH))
        {iGotName_WWW = TRUE;}
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/W3SVC"), MD_ANONYMOUS_PWD, (PBYTE)szAnonyPass_WWW, _MAX_PATH))
        {iGotPass_WWW = TRUE;}

    //
    // Get the FTP username and password
    //
    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Lookup iUsr (ftp) username..."));
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/MSFTPSVC"), MD_ANONYMOUS_USER_NAME, (PBYTE)szAnonyName_FTP, _MAX_PATH))
        {iGotName_FTP = TRUE;}
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/MSFTPSVC"), MD_ANONYMOUS_PWD, (PBYTE)szAnonyPass_FTP, _MAX_PATH))
        {iGotPass_FTP = TRUE;}

    // Now check if the actual user accounts actually exist....
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (iGotName_WAM)
    {
        // check if username is blank
        if (szAnonyName_WAM)
        {
            // Check if this user actually exists...
            SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Checking if Wam user exists..."));
            if (IsUserExist(szAnonyName_WAM))
            {
                // Fine, the user exists.... let's validate the password too

                // Let's validate that the user has at least the appropriate rights...
                if (iGotPass_WAM)
                {
                    ChangeUserPassword((LPTSTR) szAnonyName_WAM, (LPTSTR) szAnonyPass_WAM);
                }
            }
            else
            {
                if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
                // the user does not exist, so let's create it
                SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Creating Wam Account..."));

                // Add it if it is not already there.
                _stprintf(szEntry,_T("Created the iwam_ account = %s."),szAnonyName_WAM);
                if (TRUE != IsThisStringInThisCStringList(strListOfWhatWeDid, szEntry))
                    {strListOfWhatWeDid.AddTail(szEntry);}
                if (iGotPass_WAM)
                {
                    // We were able to get the password from the metabase
                    // so lets create the user with that password
                    CreateIWAMAccount(szAnonyName_WAM,szAnonyPass_WAM,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_WAM"),szAnonyName_WAM);
                    }
                }
                else
                {
                    // we were not able to get the password from the metabase
                    // so let's just create one and write it back to the metabase
                    CreateIWAMAccount(szAnonyName_WAM,pszPassword,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_WAM"),szAnonyName_WAM);
                    }
                    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;

                    // write it to the metabase.
                    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Writing Wam Account to Metabase..."));
                    g_pTheApp->m_csWAMAccountName = szAnonyName_WAM;
                    g_pTheApp->m_csWAMAccountPassword = pszPassword;
                    WriteToMD_IWamUserName_WWW();
                }

                // Do Dcomcnfg?????
            }
        }
    }


    // Now check if the actual user accounts actually exist....
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (iGotName_WWW)
    {
        // check if username is blank
        if (szAnonyName_WWW)
        {
            // Check if this user actually exists...
            SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Checking if iUsr user exists..."));
            if (IsUserExist(szAnonyName_WWW))
            {
                // Fine, the user exists.... let's validate the password too

                // Let's validate that the user has at least the appropriate rights...
                if (iGotPass_WWW)
                {
                    ChangeUserPassword((LPTSTR) szAnonyName_WWW, (LPTSTR) szAnonyPass_WWW);
                }
            }
            else
            {
                if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
                // the user does not exist, so let's create it
                SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Creating iUsr Account..."));
                // Add it if it is not already there.
                _stprintf(szEntry,_T("Created the iusr_ account = %s."),szAnonyName_WWW);
                if (TRUE != IsThisStringInThisCStringList(strListOfWhatWeDid, szEntry))
                    {strListOfWhatWeDid.AddTail(szEntry);}

                if (iGotPass_WWW)
                {
                    // We were able to get the password from the metabase
                    // so lets create the user with that password
                    CreateIUSRAccount(szAnonyName_WWW,szAnonyPass_WWW,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),szAnonyName_WWW);
                    }
                }
                else
                {
                    // see if we can enumerate thru the lower nodes to find the password??????

                    // check if maybe the ftp stuff has the password there????

                    // we were not able to get the password from the metabase
                    // so let's just create one and write it back to the metabase
                    CreateIUSRAccount(szAnonyName_WWW,pszPassword,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),szAnonyName_WWW);
                    }
                    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;

                    // write it to the metabase.
                    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Writing iUsr Account to Metabase..."));
                    g_pTheApp->m_csWWWAnonyName = szAnonyName_WAM;
                    g_pTheApp->m_csWWWAnonyPassword = pszPassword;
                    WriteToMD_AnonymousUserName_WWW(FALSE);
                }

                // Do Dcomcnfg?????
            }
        }
    }

    // Now check if the actual user accounts actually exist....
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (iGotName_FTP)
    {
        // check if username is blank
        if (szAnonyName_FTP)
        {
            // Check if this user actually exists...
            SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Checking if iUsr (ftp) user exists..."));
            if (IsUserExist(szAnonyName_FTP))
            {
                // Fine, the user exists.... let's validate the password too

                // Let's validate that the user has at least the appropriate rights...
                if (iGotPass_FTP)
                {
                    ChangeUserPassword((LPTSTR) szAnonyName_FTP, (LPTSTR) szAnonyPass_FTP);
                }
            }
            else
            {
                SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Creating iUsr (ftp) Account..."));
                if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;

                // Add it if it is not already there.
                _stprintf(szEntry,_T("Created the iusr_ account = %s."),szAnonyName_FTP);
                if (TRUE != IsThisStringInThisCStringList(strListOfWhatWeDid, szEntry))
                    {strListOfWhatWeDid.AddTail(szEntry);}

                // the user does not exist, so let's create it
                if (iGotPass_FTP)
                {
                    // We were able to get the password from the metabase
                    // so lets create the user with that password
                    CreateIUSRAccount(szAnonyName_FTP,szAnonyPass_FTP,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_FTP"),szAnonyName_FTP);
                    }
                }
                else
                {
                    // see if we can enumerate thru the lower nodes to find the password??????

                    // check if maybe the www stuff has the password there????

                    // we were not able to get the password from the metabase
                    // so let's just create one and write it back to the metabase
                    CreateIUSRAccount(szAnonyName_FTP,pszPassword,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_FTP"),szAnonyName_FTP);
                    }
                    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;

                    // write it to the metabase.
                    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Writing iUsr (ftp) Account to Metabase..."));
                    g_pTheApp->m_csFTPAnonyName = szAnonyName_WAM;
                    g_pTheApp->m_csFTPAnonyPassword = pszPassword;
                    WriteToMD_AnonymousUserName_FTP(FALSE);
                }

                // Do Dcomcnfg?????
            }
        }
    }

    // If we did anything, then popup a messagebox to the user
    // about the warnings: changes....

CheckConfig_DoIt_Exit:
    if (pszPassword) {GlobalFree(pszPassword);pszPassword = NULL;}
    iisDebugOut_End(CheckConfig_DoIt_log,LOG_TYPE_PROGRAM_FLOW);
    return iReturn;
}
#endif

const TCHAR REG_MTS_INSTALLED_KEY1[] = _T("SOFTWARE\\Microsoft\\Transaction Server\\Setup(OCM)");
const TCHAR REG_MTS_INSTALLED_KEY2[] = _T("SOFTWARE\\Microsoft\\Transaction Server\\Setup");
int ReturnTrueIfMTSInstalled(void)
{
    int iReturn = TRUE;

    if (!g_pTheApp->m_fInvokedByNT)
    {
        int bMTSInstalledFlag = FALSE;
        CRegKey regMTSInstalledKey1( HKEY_LOCAL_MACHINE, REG_MTS_INSTALLED_KEY1, KEY_READ);
        CRegKey regMTSInstalledKey2( HKEY_LOCAL_MACHINE, REG_MTS_INSTALLED_KEY2, KEY_READ);

        if ( (HKEY)regMTSInstalledKey1 ) {bMTSInstalledFlag = TRUE;}
        if ( (HKEY)regMTSInstalledKey2 ) {bMTSInstalledFlag = TRUE;}
        if (bMTSInstalledFlag == TRUE)
        {
            // check if we can get to the MTS catalog object
            if (NOERROR != DoesMTSCatalogObjectExist())
            {
                bMTSInstalledFlag = FALSE;
                iReturn = FALSE;
                MyMessageBox(NULL, IDS_MTS_INCORRECTLY_INSTALLED, MB_OK | MB_SETFOREGROUND);
                goto ReturnTrueIfMTSInstalled_Exit;
            }
        }

        if (bMTSInstalledFlag != TRUE)
        {
            iReturn = FALSE;
            MyMessageBox(NULL, IDS_MTS_NOT_INSTALLED, MB_OK | MB_SETFOREGROUND);
            goto ReturnTrueIfMTSInstalled_Exit;
        }
    }

ReturnTrueIfMTSInstalled_Exit:
    return iReturn;
}


#ifndef _CHICAGO_
/*===================================================================
DoGoryCoInitialize

  Description:
     CoInitialize() of COM is extremely funny function. It can fail
     and respond with S_FALSE which is to be ignored by the callers!
     On other error conditions it is possible that there is a threading
     mismatch. Rather than replicate the code in multiple places, here
     we try to consolidate the functionality in some rational manner.


  Arguments:
     None

  Returns:
     HRESULT = NOERROR on (S_OK & S_FALSE)
      other errors if any failure
===================================================================*/
HRESULT DoGoryCoInitialize(void)
{
    HRESULT hr;

    // do the call to CoInitialize()
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().Start.")));
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().End.")));
    //
    // S_FALSE and S_OK are success.  Everything else is a failure and you don't need to call CoUninitialize.
    //
    if ( S_OK == hr || S_FALSE == hr) 
        {
            //
            // It is okay to have failure (S_FALSE) in CoInitialize()
            // This error is to be ignored and balanced with CoUninitialize()
            //  We will reset the hr so that subsequent use is rational
            //
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("DoGoryCoInitialize found duplicate CoInitialize\n")));
            hr = NOERROR;
        }
    else if (FAILED (hr)) 
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("DoGoryCoInitialize found Failed error 0x%x\n"), hr));
        }

    return ( hr);
}
#endif // _CHICAGO_



HRESULT DoesMTSCatalogObjectExist(void)
{
    HRESULT hr = NOERROR;
#ifndef _CHICAGO_
    ICatalog*             m_pCatalog = NULL;
    ICatalogCollection* m_pPkgCollection = NULL;

    hr = DoGoryCoInitialize();
    if ( FAILED(hr)) {return ( hr);}

    // Create instance of the catalog object
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().Start.")));
    hr = CoCreateInstance(CLSID_Catalog, NULL, CLSCTX_SERVER, IID_ICatalog, (void**)&m_pCatalog);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().End.")));
    if (FAILED(hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to CoCreateInstance of Catalog Object.,hr = %08x\n"), hr));
    }
    else 
    {
        BSTR  bstr;
        //
        // Get the Packages collection
        //
        bstr = SysAllocString(L"Packages");
        if (bstr)
        {
            hr = m_pCatalog->GetCollection(bstr, (IDispatch**)&m_pPkgCollection);
            FREEBSTR(bstr);
            if (FAILED(hr)) 
                {
                iisDebugOut((LOG_TYPE_ERROR, _T("m_pCatalog(%08x)->GetCollection() failed, hr = %08x\n"), m_pCatalog, hr));
                }
            else
                {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("m_pCatalog(%08x)->GetCollection() Succeeded!, hr = %08x\n"), m_pCatalog, hr));
                //DBG_ASSERT( m_pPkgCollection != NULL);
                }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("m_pCatalog(%08x)->GetCollection() failed.  out of memory!\n"), m_pCatalog));
        }
            
    }

    if (m_pPkgCollection != NULL ) 
    {
        RELEASE(m_pPkgCollection);
        m_pPkgCollection = NULL;
    }

    if (m_pCatalog != NULL ) 
    {
        RELEASE(m_pCatalog);
        m_pCatalog = NULL;
    }

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
    CoUninitialize();
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
#endif // _CHICAGO_
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\other.h ===
#include "stdafx.h"

void  MyGetVersionFromFile(LPCTSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, LPTSTR pszReturnLocalizedVersion);
BOOL  MyGetDescriptionFromFile(LPCTSTR lpszFilename, LPTSTR pszReturnDescription);
// used for grabbing arch type info out of a file
VOID  DumpFileArchInfo(LPCTSTR Filename,PVOID View,DWORD Length,TCHAR *ReturnString);
TCHAR *MachineToString(DWORD Machine);
TCHAR *StripLastBackSlash(TCHAR * i_szDir);
void  DisplayVerOnCurrentModule();

DWORD LogPendingReBootOperations(void);
int   LogEnumServicesStatus(void);
DWORD LogHeapState(BOOL bLogSuccessStateToo, char *szFileName, int iLineNumber);
int   LogFileVersion(IN LPCTSTR lpszFullFilePath, INT bShowArchType);
BOOL  LogFilesInThisDir(LPCTSTR szDirName);
void  LogFileVersions_System32(void);
void  LogFileVersions_Inetsrv(void);
DWORD LogFileVersionsForThisINFSection( IN HINF hFile, IN LPCTSTR szSection );
void  LogCurrentProcessIDs(void);
VOID  LogFileArchType(LPCTSTR filename, TCHAR * ReturnMachineType);
void  LogCheckIfTempDirWriteable(void);
void  LogAllProcessDlls(void);
void  LogProcessesUsingThisModule(LPCTSTR szModuleNameToLookup, CStringList &strList);
#ifndef _CHICAGO_
    void LogProcessesUsingThisModuleW(LPCTSTR szModuleNameToLookup, CStringList &strList);
#else
    void LogProcessesUsingThisModuleA(LPCTSTR szModuleNameToLookup, CStringList &strList);
#endif

void LogThisProcessesDLLs(void);
#ifndef _CHICAGO_
    void LogThisProcessesDLLsW(void);
#else
    void LogThisProcessesDLLsA(void);
#endif

void LogFileVersionsForGroupOfSections(IN HINF hFile);

DWORD LogFileVersionsForCopyFiles(IN HINF hFile, IN LPCTSTR szSection);
void UnInit_Lib_PSAPI(void);
BOOL  IsProcessUsingThisModule(LPWSTR lpwsProcessName,DWORD dwProcessId,LPWSTR ModuleName);
DWORD WINAPI FindProcessByNameW(const WCHAR * pszImageName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\other.cpp ===
#include "stdafx.h"
#include "lzexpand.h"
#include <loadperf.h>
#include <ole2.h>
#include <iis64.h>
#include "iadmw.h"
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "dcomperm.h"
#include "log.h"
#include "kill.h"
#include "svc.h"
#include "other.h"


extern OCMANAGER_ROUTINES gHelperRoutines;
extern int g_GlobalDebugLevelFlag;
extern int g_GlobalDebugCallValidateHeap;

// stuff for finding out architecture type of a file
#define IMAGE_BASE_TO_DOS_HEADER(b) ((PIMAGE_DOS_HEADER)(b))
#define IMAGE_BASE_TO_NT_HEADERS(b) ((PIMAGE_NT_HEADERS)( (DWORD_PTR)(b) + ((PIMAGE_DOS_HEADER)(b))->e_lfanew ))
#define IMAGE_BASE_TO_FILE_HEADER(b) ((PIMAGE_FILE_HEADER)( &IMAGE_BASE_TO_NT_HEADERS(b)->FileHeader ))

//
// PSAPI.DLL
//
HINSTANCE g_hInstLib_PSAPI = NULL;
// PSAPI.DLL "EnumProcessModules"
typedef BOOL  (WINAPI *PfnEnumProcessModules)(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
BOOL  (WINAPI *g_lpfEnumProcessModules)(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
// PSAPI.DLL "GetModuleFileNameExA","GetModuleFileNameExW"
typedef BOOL  (WINAPI *PfnGetModuleFileNameEx)(HANDLE hProcess, HMODULE lphModule, LPTSTR lpFileName, DWORD dwSize);
BOOL  (WINAPI *g_lpfGetModuleFileNameEx)(HANDLE hProcess, HMODULE lphModule, LPTSTR lpFileName, DWORD dwSize);


DWORD LogHeapState(BOOL bLogSuccessStateToo, char *szFileName, int iLineNumber)
{
    DWORD dwReturn = ERROR_OUTOFMEMORY;

    if (!g_GlobalDebugCallValidateHeap)
    {
        // don't even call RtlValidateHeap
        dwReturn = ERROR_SUCCESS;
        return dwReturn;
    }

#ifndef _CHICAGO_
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ntdll:RtlProcessHeap().Start.")));
    if ( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) )
    {
        // HEAP IS GOOD
        dwReturn = ERROR_SUCCESS;
	    if (bLogSuccessStateToo) {iisDebugOut((LOG_TYPE_TRACE, _T("RtlValidateHeap(): Good.\n")));}
    }
    else
    {
#if defined(UNICODE) || defined(_UNICODE)
        LPWSTR  pwsz = NULL;
        pwsz = MakeWideStrFromAnsi(szFileName);
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RtlValidateHeap(): Corrupt!!! %1!s!:Line %2!d!.  FAILURE!\n"), pwsz, iLineNumber));

        if (pwsz)
        {
            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ntdll:CoTaskMemFree().Start.")));
            CoTaskMemFree(pwsz);
            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ntdll:CoTaskMemFree().End.")));
        }
#else
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RtlValidateHeap(): Corrupt!!! %1!s!:Line %2!d!.  FAILURE!\n"), szFileName, iLineNumber));
#endif
    }
#endif
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ntdll:RtlProcessHeap().End.")));
    return dwReturn;
}


DWORD LogPendingReBootOperations(void)
// Returns !ERROR_SUCCESS if there are reboot operations which
// need to get taken are of before we can run setup.
{
	DWORD dwReturn = ERROR_SUCCESS;
    CString csFormat, csMsg;

    // If any of the services that we install
    // is in the funky state = ERROR_SERVICE_MARKED_FOR_DELETE
    // That means that the user needs to reboot before we can
    // reinstall the service!  otherwise setup will be hosed!

    int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
    g_pTheApp->m_bAllowMessageBoxPopups = TRUE;


#ifndef _CHICAGO_
    // Check if the HTTP drive is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("HTTP")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("SPUD"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

    // Check if the spud driver is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("SPUD")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("SPUD"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

    // Check if the iisadmin service is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("IISADMIN")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("IISADMIN"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

    // Check if the W3SVC service is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("W3SVC")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("W3SVC"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

    // Check if the MSFTPSVC service is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("MSFTPSVC")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("MSFTPSVC"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

#endif //_CHICAGO_

    g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;

	return dwReturn;
}

// Get the .inf section.  which has the file names
// get the corresponding directory
// print out the file date and versions of these files.
DWORD LogFileVersionsForThisINFSection(IN HINF hFile, IN LPCTSTR szSection)
{
    DWORD dwReturn = ERROR_SUCCESS;
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;
    CString csFile;

    INFCONTEXT Context;

    TCHAR buf[_MAX_PATH];
    GetSystemDirectory( buf, _MAX_PATH);

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
        {
        dwReturn = !ERROR_SUCCESS;
        goto LogFileVersionsForThisINFSection_Exit;
        }

    // loop through the items in the section.
    while (b) {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            goto LogFileVersionsForThisINFSection_Exit;
            }

        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            goto LogFileVersionsForThisINFSection_Exit;
            }

        // Attach the path to the from of this...
        // check in this directory:
        // 1. winnt\system32
        // --------------------------------------

        // may look like this "iisrtl.dll,,4"
        // so get rid of the ',,4'
        LPTSTR pch = NULL;
        pch = _tcschr(szLine, _T(','));
        if (pch) {_tcscpy(pch, _T(" "));}

        // Remove any trailing spaces.
        StripLastBackSlash(szLine);

        // Get the system dir
        csFile = buf;

        csFile = AddPath(csFile, szLine);

        LogFileVersion(csFile, TRUE);

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );
        szLine = NULL;
    }
    if (szLine) {GlobalFree(szLine);szLine=NULL;}


LogFileVersionsForThisINFSection_Exit:
    return dwReturn;
}

int LogFileVersion(IN LPCTSTR lpszFullFilePath, INT bShowArchType)
{
    int iReturn = FALSE;
    DWORD  dwMSVer, dwLSVer;

    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    SYSTEMTIME st;
    TCHAR szDate[40];
    TCHAR szTime[20];
    TCHAR szLocalizedVersion[100] = _T("");
    TCHAR szFileAttributes[20] = _T("----");
    DWORD dwFileSize = 0;

    BOOL bThisIsABinary = FALSE;
    BOOL bGotTime = FALSE;
    BOOL bGotFileSize = FALSE;

    if (!(lpszFullFilePath))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("LogFileVersion(string fullfilepath, int showarchtype).  Invalid Parameter.")));
        return iReturn;
    }

    __try
    {
        if (IsFileExist(lpszFullFilePath))
        {
            TCHAR szExtensionOnly[_MAX_EXT] = _T("");
            _tsplitpath(lpszFullFilePath, NULL, NULL, NULL, szExtensionOnly);

            // Get version info for dll,exe,ocx only
            if (_tcsicmp(szExtensionOnly, _T(".exe")) == 0){bThisIsABinary=TRUE;}
            if (_tcsicmp(szExtensionOnly, _T(".dll")) == 0){bThisIsABinary=TRUE;}
            if (_tcsicmp(szExtensionOnly, _T(".ocx")) == 0){bThisIsABinary=TRUE;}

            // If this is the metabase.bin file then show the filesize!
            if (_tcsicmp(szExtensionOnly, _T(".bin")) == 0)
            {
                dwFileSize = ReturnFileSize(lpszFullFilePath);
                if (dwFileSize != 0xFFFFFFFF)
                {
                    // If we were able to get the file size.
                    bGotFileSize = TRUE;
                }
            }

            // If this is the metabase.xml file then show the filesize!
            if (_tcsicmp(szExtensionOnly, _T(".xml")) == 0)
            {
                dwFileSize = ReturnFileSize(lpszFullFilePath);
                if (dwFileSize != 0xFFFFFFFF)
                {
                    // If we were able to get the file size.
                    bGotFileSize = TRUE;
                }
            }

            // get the fileinformation
            // includes version and localizedversion
            MyGetVersionFromFile(lpszFullFilePath, &dwMSVer, &dwLSVer, szLocalizedVersion);

            hFile = FindFirstFile(lpszFullFilePath, &FindFileData);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Try to get the systemtime.
                if ( FileTimeToSystemTime( &FindFileData.ftCreationTime, &st) )
                {
                    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, szDate, sizeof(szDate)/sizeof(TCHAR));
                    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER, &st, NULL, szTime, sizeof(szTime)/sizeof(TCHAR));
                    bGotTime = TRUE;
                }

                // Get the file attributes.
                _stprintf(szFileAttributes, _T("%s%s%s%s%s%s%s%s"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? _T("A") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED ? _T("C") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? _T("D") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ? _T("E") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ? _T("H") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_NORMAL ? _T("N") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY ? _T("R") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM ? _T("S") : _T("_")
                    );

                if (bGotTime)
                {
                    if (bThisIsABinary)
                    {
                        if (bShowArchType)
                        {
                            TCHAR szFileArchType[30] = _T("");
                            LogFileArchType(lpszFullFilePath, szFileArchType);
                            if (szFileArchType)
                            {
                                // show everything
                                if (bGotFileSize)
                                {
                                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s: %s: %d"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, szFileArchType, lpszFullFilePath, dwFileSize));
                                }
                                else
                                {
                                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s: %s"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, szFileArchType, lpszFullFilePath));
                                }
                            }
                            else
                            {
                                // show without arch type
                                if (bGotFileSize)
                                {
                                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s: %d"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath, dwFileSize));
                                }
                                else
                                {
                                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath));
                                }
                            }
                        }
                        else
                        {
                            // show without arch type
                            if (bGotFileSize)
                            {
                                iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s: %d"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath, dwFileSize));

                            }
                            else
                            {
                                iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath));
                            }
                        }
                    }
                    else
                    {
                        // This is not a binary file, must be like a text file.
                        if (bGotFileSize)
                        {
                            iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %s: %d"), szDate, szTime, szFileAttributes, lpszFullFilePath, dwFileSize));
                        }
                        else
                        {
                            iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %s"), szDate, szTime, szFileAttributes, lpszFullFilePath));
                        }
                   }
                }
                else
                {
                    // Show without filetime, since we couldn't get it
                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %d.%d.%d.%d: %s: %s"), szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath));
                }

                FindClose(hFile);
            }
            iReturn = TRUE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("\r\nException Caught in LogFileVersion(%1!s!). GetExceptionCode()=0x%2!x!\r\n"), lpszFullFilePath, GetExceptionCode()));
    }

    return iReturn;
}

BOOL LogFilesInThisDir(LPCTSTR szDirName)
{
    BOOL bReturn = FALSE;
    DWORD retCode;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szTempFileName[_MAX_PATH] = _T("");
    TCHAR szDirNameCopy[_MAX_PATH] = _T("");
    TCHAR szDirName2[_MAX_PATH] = _T("");

    if (szDirName)
    {
        _tcscpy(szDirNameCopy, szDirName);
    }
    else
    {
        // get currentdir
        GetCurrentDirectory(_MAX_PATH, szDirNameCopy);
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("LogFilesInThisDir()=%1!s!.  No parameter specified, so using current dir.\n"), szDirNameCopy));
    }

    retCode = GetFileAttributes(szDirNameCopy);
    if (retCode == 0xFFFFFFFF){goto LogFilesInThisDir_Exit;}

    // if this is a file, then
    // do this for only this one file.
    if (!(retCode & FILE_ATTRIBUTE_DIRECTORY))
    {
        bReturn = LogFileVersion(szDirNameCopy, TRUE);
        goto LogFilesInThisDir_Exit;
    }

    // ok, this is a directory,
    // so tack on the *.* deal
    _stprintf(szDirName2, _T("%s\\*.*"), szDirNameCopy);
    hFile = FindFirstFile(szDirName2, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        do {
                // display the filename, if it is not a directory.
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, so let's output the info.
                        _stprintf(szTempFileName, _T("%s\\%s"), szDirNameCopy, FindFileData.cFileName);
                        if (LogFileVersion(szTempFileName, TRUE) == TRUE) {bReturn = TRUE;}
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) )
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }


LogFilesInThisDir_Exit:
    return bReturn;
}



/*----------------------------------------------------------------------------*\
  Function: StripLastBackSlash (TCHAR *)
  ----------------------------------------------------------------------------
  Description: StripLastBackSlash strips the last backslash in a path string
    NOTE: this code can be very easily broken as it lives under the assumption
         that the input string is a valid path (i.e. string of length two or greater)
\*----------------------------------------------------------------------------*/
TCHAR *StripLastBackSlash(TCHAR * i_szDir)
{
	TCHAR	* iszDir;
	iszDir = i_szDir + lstrlen(i_szDir);
	do
	{
		iszDir = CharPrev(i_szDir , iszDir);
	}
	while (((*iszDir == _T(' ')) || (*iszDir == _T('\\'))) && (iszDir != i_szDir));

	// If we came out of the loop and the current pointer still points to
	// a space or a backslash then all the string contains is some combination
	// of spaces and backspaces
	if ((*iszDir == _T(' ')) || (*iszDir == _T('\\')))
	{
		*i_szDir = _T('\0');
		return(i_szDir);
	}

	iszDir = CharNext(iszDir);
	*iszDir = _T('\0');
	return(i_szDir);
}


void LogCurrentProcessIDs(void)
{
    DWORD          numTasks = 0;
    PTASK_LIST     The_TList = NULL;

    // Allocate the TASK_LIST in the heap and not on the stack!
    The_TList = (PTASK_LIST) HeapAlloc(GetProcessHeap(), 0, sizeof(TASK_LIST) * MAX_TASKS);
    if (NULL == The_TList){goto LogCurrentProcessIDs_Exit;}

    // Get the task list for the system, store it in The_TList
    numTasks = GetTaskList( The_TList, MAX_TASKS);
    for (DWORD i=0; i<numTasks; i++)
    {
        TCHAR szTempString[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
        MultiByteToWideChar( CP_ACP, 0, (char*) The_TList[i].ProcessName, -1, szTempString, _MAX_PATH);
#else
        _tcscpy(szTempString, The_TList[i].ProcessName);
#endif
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%4d] %s\n"), The_TList[i].dwProcessId, szTempString));
    }
LogCurrentProcessIDs_Exit:
    if (The_TList){HeapFree(GetProcessHeap(), 0, The_TList);The_TList = NULL;}
    return;
}


VOID LogFileArchType(LPCTSTR Filename, TCHAR * ReturnMachineType)
{
    HANDLE                 fileHandle;
    HANDLE                 mapHandle;
    DWORD                  fileLength;
    PVOID                  view;
    TCHAR                  szReturnedString[30] = _T("");

    //
    // Open the file.
    //
    fileHandle = CreateFile(Filename,GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if( fileHandle == INVALID_HANDLE_VALUE )
		{
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("LogFileArchType: FAILURE: Cannot open %1!s!.\n"), Filename));
        return;
		}

    //
    // Get its size.
    //
    fileLength = GetFileSize(fileHandle,NULL);
    if( ( fileLength == (DWORD)-1L ) &&( GetLastError() != NO_ERROR ) )
		{
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("LogFileArchType: failure. cannot get size of %1!s!.\n"), Filename));
        CloseHandle( fileHandle );
        return;
		}
    if( fileLength < sizeof(IMAGE_DOS_HEADER) )
		{
        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("LogFileArchType: failure. %1!s! is an invalid image.\n"), Filename));
        CloseHandle( fileHandle );
        return;
		}

    //
    // Create the mapping.
    //
    mapHandle = CreateFileMapping(fileHandle,NULL,PAGE_READONLY,0,0,NULL);
    if( mapHandle == NULL )
		{
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("LogFileArchType: failure. Cannot create mapping for %1!s!.\n"), Filename));
        CloseHandle( fileHandle );
        return;
		}

    //
    // Map it in.
    //
    view = MapViewOfFile(mapHandle,FILE_MAP_READ,0,0,0);
    if( view == NULL )
		{
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("LogFileArchType: failure. Cannot map %1!s!.\n"), Filename));
        CloseHandle( mapHandle );
        CloseHandle( fileHandle );
        return;
		}

    //
    // Dump the image info.
    //
    _tcscpy(ReturnMachineType, _T(""));
    DumpFileArchInfo(Filename,view,fileLength, szReturnedString);
    _tcscpy(ReturnMachineType, szReturnedString);

    //
    // Cleanup.
    //
    UnmapViewOfFile( view );
    CloseHandle( mapHandle );
    CloseHandle( fileHandle );

    return;
}

TCHAR *MachineToString(DWORD Machine)
{
    switch( Machine )
	{
		case IMAGE_FILE_MACHINE_UNKNOWN :
			return _T("Unknown");
		case IMAGE_FILE_MACHINE_I386 :
			return _T("x86");
		case IMAGE_FILE_MACHINE_AMD64 :
			return _T("AMD64");
		case IMAGE_FILE_MACHINE_IA64 :
			return _T("IA64");
    }
    return _T("INVALID");
}

VOID DumpFileArchInfo(LPCTSTR Filename,PVOID View,DWORD Length,TCHAR *ReturnString)
{
    PIMAGE_DOS_HEADER      dosHeader;
    PIMAGE_NT_HEADERS      ntHeaders;
    PIMAGE_FILE_HEADER     fileHeader;

    //
    // Validate the DOS header.
    //
    dosHeader = IMAGE_BASE_TO_DOS_HEADER( View );
    if( dosHeader->e_magic != IMAGE_DOS_SIGNATURE )
		{
        return;
		}

    //
    // Validate the NT headers.
    //
    ntHeaders = IMAGE_BASE_TO_NT_HEADERS( View );
    if( ntHeaders->Signature != IMAGE_NT_SIGNATURE )
		{
        return;
		}

    fileHeader = IMAGE_BASE_TO_FILE_HEADER( View );
    //
    // Dump the info.
    //
	// dump machine type
    _tcscpy(ReturnString, MachineToString( fileHeader->Machine ));

    return;
}


void LogCheckIfTempDirWriteable(void)
{
    // attempt get the temp directory
    // and write to it.
    // we have had occurences where the tempdir was locked so,
    // some regsvr things failed.
    HANDLE hFile = NULL;
    TCHAR szTempFileName[_MAX_PATH+1];
    TCHAR szTempDir[_MAX_PATH+1];
    if (GetTempPath(_MAX_PATH,szTempDir) == 0)
    {
        // failed.
        iisDebugOut((LOG_TYPE_WARN, _T("LogCheckIfTempDirWriteable:GetTempPath() Failed.  POTENTIAL PROBLEM.  FAILURE.\n")));
    }
    else
    {
        // nope we got the temp dir
        // now let's get a tempfilename, write to it and
        // delete it.

        // trim off the last backslash...
        LPTSTR ptszTemp = _tcsrchr(szTempDir, _T('\\'));
        if (ptszTemp)
        {
            *ptszTemp = _T('\0');
        }

        if (GetTempFileName(szTempDir, _T("IIS"), 0, szTempFileName) != 0)
        {
            // Write to this file, and
            DeleteFile(szTempFileName);

		    // Open existing file or create a new one.
		    hFile = CreateFile(szTempFileName,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
		    if (hFile == INVALID_HANDLE_VALUE)
		    {
			    hFile = NULL;
                iisDebugOutSafeParams((LOG_TYPE_WARN, _T("LogCheckIfTempDirWriteable:LogTempDirLockedCheck() failed to CreateFile %1!s!. POTENTIAL PROBLEM.  FAILURE.\n"), szTempFileName));
		    }
            else
            {
                // write to the file
                if (hFile)
                {
                    DWORD dwBytesWritten = 0;
                    char szTestData[30];
                    strcpy(szTestData, "Test");
                    if (WriteFile(hFile,szTestData,strlen(szTestData),&dwBytesWritten,NULL))
                    {
                        // everything is hunky dory. don't print anything
                    }
                    else
                    {
                        // error writing to the file.
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("LogCheckIfTempDirWriteable:WriteFile(%1!s!) Failed.  POTENTIAL PROBLEM.  FAILURE.  Error=0x%2!x!.\n"), szTempFileName, GetLastError()));
                    }
                }
            }
            DeleteFile(szTempFileName);
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("LogCheckIfTempDirWriteable:GetTempFileName(%1!s!, %2!s!) Failed.  POTENTIAL PROBLEM.  FAILURE.\n"), szTempDir, _T("IIS")));
        }
    }

    if (hFile)
    {
        CloseHandle(hFile);
        DeleteFile(szTempFileName);
    }
    return;
}


#ifndef _CHICAGO_

BOOL EnumProcessModules(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded)
{
	if (!g_lpfEnumProcessModules)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("EnumProcessModules: unable to work\n")));
        return FALSE;
    }

	return g_lpfEnumProcessModules(hProcess, lphModule, cb, lpcbNeeded);
}


BOOL Init_Lib_PSAPI(void)
{
    BOOL bReturn = FALSE;

    // load the library
    if (!g_hInstLib_PSAPI){g_hInstLib_PSAPI = LoadLibrary( _T("PSAPI.DLL") ) ;}
	if( g_hInstLib_PSAPI == NULL ){goto Init_Library_PSAPI_Exit;}
	
    // get entry point
    if (!g_lpfEnumProcessModules)
        {g_lpfEnumProcessModules = (PfnEnumProcessModules) GetProcAddress( g_hInstLib_PSAPI, "EnumProcessModules");}
    if( g_lpfEnumProcessModules == NULL ){goto Init_Library_PSAPI_Exit;}

    // get entry point
#if defined(UNICODE) || defined(_UNICODE)
    if (!g_lpfGetModuleFileNameEx)
        {g_lpfGetModuleFileNameEx = (PfnGetModuleFileNameEx) GetProcAddress( g_hInstLib_PSAPI, "GetModuleFileNameExW");}
#else
    if (!g_lpfGetModuleFileNameEx)
        {g_lpfGetModuleFileNameEx = (PfnGetModuleFileNameEx) GetProcAddress( g_hInstLib_PSAPI, "GetModuleFileNameExA");}
#endif
    if( g_lpfGetModuleFileNameEx == NULL ){goto Init_Library_PSAPI_Exit;}

    bReturn = TRUE;

Init_Library_PSAPI_Exit:
    if (FALSE == bReturn)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("non fatal error initing lib:PSAPI.DLL\n")));
    }
    return bReturn;
}

#define MAX_MODULES 256
BOOL IsProcessUsingThisModule(LPWSTR lpwsProcessName,DWORD dwProcessId,LPWSTR ModuleName)
{
    BOOL    bReturn = FALSE;
    HANDLE  hRealProcess = NULL;
    DWORD   cbNeeded  = 0;
    int     iNumberOfModules = 0;
    bool    fProcessNameFound = FALSE;
    HMODULE hMod[MAX_MODULES];

    TCHAR   szFileName[_MAX_PATH] ;
    szFileName[0] = 0;


    if (FALSE == Init_Lib_PSAPI())
    {
        goto IsProcessUsingThisModule_Exit;
    }

    // if we don't have a dwProcessId, then get one from the filename!
    if (dwProcessId == 0)
    {
        __try
        {
           dwProcessId = FindProcessByNameW(lpwsProcessName);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("\r\nException Caught in FindProcessByNameW(%1!s!). GetExceptionCode()=0x%2!x!\r\n"), lpwsProcessName, GetExceptionCode()));
        }

        if( dwProcessId == 0 )
        {
            goto IsProcessUsingThisModule_Exit;
        }
    }

    hRealProcess = OpenProcess( MAXIMUM_ALLOWED,FALSE, dwProcessId );
    if( hRealProcess == NULL )
    {
        //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("IsProcessUsingThisModule: OpenProcess failed!\n")));
        goto IsProcessUsingThisModule_Exit;
    }

    if (!EnumProcessModules(hRealProcess,hMod,MAX_MODULES * sizeof(HMODULE),&cbNeeded))
        {goto IsProcessUsingThisModule_Exit;}

    // loop thru the modules in this .exe file
    // and see if it matches the one we are looking for!
    iNumberOfModules = cbNeeded / sizeof(HMODULE);
	fProcessNameFound = false;
	for(int i=0; i<iNumberOfModules; i++)
	{
        szFileName[0] = 0 ;
		// Get Full pathname!
		if(g_lpfGetModuleFileNameEx(hRealProcess, (HMODULE) hMod[i], szFileName, sizeof( szFileName )))
        {
            // if the szFileName is equal to the file we are looking for then Viola,
            // we've found it in this certain process!

            //[lsass.exe] C:\WINNT4\System32\ntdll.dll
            //iisDebugOut((LOG_TYPE_TRACE, _T("IsProcessUsingThisModule:[%s] %s\n"),lpwsProcessName,szFileName));
            if (_tcsicmp(szFileName,ModuleName) == 0)
            {
                // we've found it so
                // now add it to the list
                bReturn = TRUE;
                goto IsProcessUsingThisModule_Exit;
            }
		}
	}

IsProcessUsingThisModule_Exit:
    if (hRealProcess) {CloseHandle( hRealProcess );}
    return bReturn;
}


BOOL DumpProcessModules(DWORD dwProcessId)
{
    BOOL    bReturn = FALSE;
    HANDLE  hRealProcess = NULL;
    DWORD   cbNeeded  = 0;
    int     iNumberOfModules = 0;
    HMODULE hMod[MAX_MODULES];
    TCHAR   szFileName[_MAX_PATH] ;
    szFileName[0] = 0;

    if (FALSE == Init_Lib_PSAPI())
        {goto DumpProcessModules_Exit;}

    hRealProcess = OpenProcess( MAXIMUM_ALLOWED,FALSE, dwProcessId );
    if( hRealProcess == NULL )
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("DumpProcessModules: OpenProcess failed!\n")));
        goto DumpProcessModules_Exit;
    }

    if (!EnumProcessModules(hRealProcess,hMod,MAX_MODULES * sizeof(HMODULE),&cbNeeded))
        {goto DumpProcessModules_Exit;}

    // loop thru the modules in this .exe file
    // and see if it matches the one we are looking for!
    iNumberOfModules = cbNeeded / sizeof(HMODULE);
	for(int i=0; i<iNumberOfModules; i++)
	{
        bReturn = TRUE;

		// Get Full pathname!
		if(g_lpfGetModuleFileNameEx(hRealProcess, (HMODULE) hMod[i], szFileName, sizeof( szFileName )))
        {
            // if the szFileName is equal to the file we are looking for then Viola,
            // we've found it in this certain process!

            //[lsass.exe] C:\WINNT4\System32\ntdll.dll
            iisDebugOut((LOG_TYPE_TRACE, _T("[%d] %s\n"),dwProcessId,szFileName));
		}
	}

DumpProcessModules_Exit:
    if (hRealProcess) {CloseHandle( hRealProcess );}
    return bReturn;
}


DWORD WINAPI FindProcessByNameW(const WCHAR * pszImageName)
{
    DWORD      Result = 0;
    DWORD      numTasks = 0;
    PTASK_LIST The_TList = NULL;

    // Allocate the TASK_LIST in the heap and not on the stack!
    The_TList = (PTASK_LIST) HeapAlloc(GetProcessHeap(), 0, sizeof(TASK_LIST) * MAX_TASKS);
    if (NULL == The_TList){goto FindProcessByNameW_Exit;}

    // Get the task list for the system, store it in The_TList
    numTasks = GetTaskList( The_TList, MAX_TASKS);
    for (DWORD i=0; i<numTasks; i++)
    {
        TCHAR szTempString[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
        MultiByteToWideChar( CP_ACP, 0, (char*) The_TList[i].ProcessName, -1, szTempString, _MAX_PATH);
#else
        _tcscpy(szTempString, The_TList[i].ProcessName);
#endif
        // compare this process name with what they want
        // if we found the fully pathed process name in our list of processes
        // then return back the ProcessID
        if( _tcsicmp( szTempString, pszImageName ) == 0)
        {
            Result = The_TList[i].dwProcessId;
            goto FindProcessByNameW_Exit;
        }
    }
FindProcessByNameW_Exit:
    if (The_TList){HeapFree(GetProcessHeap(), 0, The_TList);The_TList = NULL;}
    return Result;
}


void LogProcessesUsingThisModuleW(LPCTSTR szModuleNameToLookup, CStringList &strList)
{
    DWORD          numTasks = 0;
    PTASK_LIST     The_TList = NULL;

    // return if nothing to lookup
    if (!(szModuleNameToLookup)) {return;}

    // Allocate the TASK_LIST in the heap and not on the stack!
    The_TList = (PTASK_LIST) HeapAlloc(GetProcessHeap(), 0, sizeof(TASK_LIST) * MAX_TASKS);
    if (NULL == The_TList){goto LogProcessesUsingThisModuleW_Exit;}

    // Get the task list for the system, store it in The_TList
    numTasks = GetTaskList( The_TList, MAX_TASKS);
    for (DWORD i=0; i<numTasks; i++)
    {
        TCHAR szTempString[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
        MultiByteToWideChar( CP_ACP, 0, (char*) The_TList[i].ProcessName, -1, szTempString, _MAX_PATH);
#else
        _tcscpy(szTempString, The_TList[i].ProcessName);
#endif

        if (TRUE == IsProcessUsingThisModule(szTempString,(DWORD) (DWORD_PTR) The_TList[i].dwProcessId,(TCHAR *) szModuleNameToLookup))
        {
            // Print out the .exe name
            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("LogProcessesUsingThisModuleW:[%s] using %s\n"),szTempString,szModuleNameToLookup));

            // Add it the list of processes which are using this certain .dll
            //
            // something1.exe
            // something2.exe
            // something3.exe <----
            //
            // Add it to the strList if not already there!
            if (TRUE != IsThisStringInThisCStringList(strList, szTempString))
            {
                strList.AddTail(szTempString);
            }
        }
    }

LogProcessesUsingThisModuleW_Exit:
    if (The_TList){HeapFree(GetProcessHeap(), 0, The_TList);The_TList = NULL;}
    return;
}
#endif

void UnInit_Lib_PSAPI(void)
{
    // Free entry points and library
    if (g_lpfGetModuleFileNameEx){g_lpfGetModuleFileNameEx = NULL;}
    if (g_lpfEnumProcessModules){g_lpfEnumProcessModules = NULL;}
    if (g_hInstLib_PSAPI)
    {
		FreeLibrary(g_hInstLib_PSAPI) ;
		g_hInstLib_PSAPI = NULL;
    }
    return;
}

#ifdef _CHICAGO_
    void LogProcessesUsingThisModuleA(LPCTSTR szModuleNameToLookup, CStringList &strList)
    {
        return;
    }
#endif

void LogProcessesUsingThisModule(LPCTSTR szModuleNameToLookup, CStringList &strList)
{
#ifndef _CHICAGO_
    __try
    {
        LogProcessesUsingThisModuleW(szModuleNameToLookup, strList);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ExceptionCaught!:LogProcessesUsingThisModule(): File:%1!s!\n"), szModuleNameToLookup));
    }
#else
    LogProcessesUsingThisModuleA(szModuleNameToLookup, strList);
#endif
    return;
}


#ifdef _CHICAGO_
    void LogThisProcessesDLLsA(void)
    {
        return;
    }
#else

void LogThisProcessesDLLsW(void)
{
    DWORD       numTasks  = 0;
    PTASK_LIST  The_TList = NULL;
    DWORD       ThisPid   = GetCurrentProcessId();;

    // Allocate the TASK_LIST in the heap and not on the stack!
    The_TList = (PTASK_LIST) HeapAlloc(GetProcessHeap(), 0, sizeof(TASK_LIST) * MAX_TASKS);
    if (NULL == The_TList){goto LogThisProcessesDLLsW_Exit;}

    // Get the task list for the system, store it in The_TList
    numTasks = GetTaskList( The_TList, MAX_TASKS);
    for (DWORD i=0; i<numTasks; i++)
    {
        if (ThisPid == (DWORD) (DWORD_PTR) The_TList[i].dwProcessId)
        {
            TCHAR szTempString[512];

#if defined(UNICODE) || defined(_UNICODE)
            MultiByteToWideChar( CP_ACP, 0, (char*) The_TList[i].ProcessName, -1, szTempString, _MAX_PATH);
#else
            _tcscpy(szTempString, The_TList[i].ProcessName);
#endif

            // display the used .dll files for this process. (our process)
            DumpProcessModules((DWORD) (DWORD_PTR) The_TList[i].dwProcessId);
            goto LogThisProcessesDLLsW_Exit;
        }
    }

LogThisProcessesDLLsW_Exit:
    if (The_TList){HeapFree(GetProcessHeap(), 0, The_TList);The_TList = NULL;}
    return;
}
#endif

void LogThisProcessesDLLs(void)
{
#ifdef _CHICAGO_
    LogThisProcessesDLLsA();
#else
    __try
    {
        LogThisProcessesDLLsW();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("ExceptionCaught!:LogThisProcessesDLLs().\n")));
    }
#endif
    return;
}


void LogFileVersions_System32(void)
{
    TCHAR buf[_MAX_PATH];
    GetSystemDirectory( buf, _MAX_PATH);
    CString csTempPath = buf;
    LogFilesInThisDir(csTempPath);
    return;
}

void LogFileVersions_Inetsrv(void)
{
    CString csTempPath = g_pTheApp->m_csPathInetsrv;
    LogFilesInThisDir(csTempPath);
    return;
}


DWORD LogFileVersionsForCopyFiles(IN HINF hFile, IN LPCTSTR szSection)
{
    DWORD dwReturn = ERROR_SUCCESS;
    return dwReturn;
}

int LoadExeFromResource(int iWhichExeToGet, LPTSTR szReturnPath)
{
    TCHAR szResourceNumString[10];
    TCHAR szSaveFileNameAs[_MAX_PATH];

    HANDLE  hFile = INVALID_HANDLE_VALUE;

    LPTSTR szPointerToAllExeData = NULL;
    DWORD  dwSize = 0;
    DWORD  dwTemp;
    int iReturn = E_FAIL;
    _tcscpy(szReturnPath, _T(""));

    // The Binaries stored in the resource is x86 only
    // so... exit if this is not an x86
    SYSTEM_INFO si;
    GetSystemInfo( &si );
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
    {
        iReturn = ERROR_NOT_SUPPORTED;
        goto LoadExeFromResource_Exit;
    }

    // get the resource id from the resource
    _stprintf(szResourceNumString, _T("#%d"), iWhichExeToGet);
    
    dwTemp = GetWindowsDirectory( szSaveFileNameAs, _MAX_PATH);

    if ( ( dwTemp == 0 ) ||
         ( dwTemp > _MAX_PATH ) )
    {
        iReturn = ERROR_INSUFFICIENT_BUFFER;
        goto LoadExeFromResource_Exit;
    }

    TCHAR szResourceFileName[_MAX_FNAME];
    _stprintf(szResourceFileName, _T("Res%d.bin"), iWhichExeToGet);
    AddPath(szSaveFileNameAs, szResourceFileName);

    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("LoadExeFromResource: '%1!s!' Start.\n"), szSaveFileNameAs));

    // Check if the filename already exists...if it does, then don't overwrite it!
    if (IsFileExist(szSaveFileNameAs))
    {
        iReturn = ERROR_FILE_EXISTS;
        goto LoadExeFromResource_Exit;
    }
   	
    HRSRC       hrscReg;
	hrscReg = FindResource((HMODULE) g_MyModuleHandle, szResourceNumString, _T("EXE"));
	if (NULL == hrscReg)
	{
		iReturn = GetLastError();
		goto LoadExeFromResource_Exit;
	}

    HGLOBAL     hResourceHandle;
	hResourceHandle = LoadResource((HMODULE)g_MyModuleHandle, hrscReg);
	if (NULL == hResourceHandle)
	{
		iReturn = GetLastError();
		goto LoadExeFromResource_Exit;
	}

	dwSize = SizeofResource((HMODULE)g_MyModuleHandle, hrscReg);

    // szPointerToAllExeData is a pointer to the whole thing
	szPointerToAllExeData = (LPTSTR) hResourceHandle;

    // Write all this data out to the file.
    __try
    {
	    hFile = CreateFile(szSaveFileNameAs,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	    if (hFile != INVALID_HANDLE_VALUE)
        {
            // save everything into the file
            DWORD dwBytesWritten = 0;
            if (WriteFile(hFile,szPointerToAllExeData,dwSize,&dwBytesWritten,NULL))
            {
                _tcscpy(szReturnPath, szSaveFileNameAs);
                iReturn = ERROR_SUCCESS;
            }
            else
            {
                iReturn = GetLastError();
            }
        }
        else
        {
            iReturn = ERROR_INVALID_HANDLE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TCHAR szErrorString[100];
        _stprintf(szErrorString, _T("\r\n\r\nException Caught in LoadExeFromResource().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
        OutputDebugString(szErrorString);
        g_MyLogFile.LogFileWrite(szErrorString);
    }

LoadExeFromResource_Exit:
    iisDebugOut_End(_T("LoadExeFromResource"),LOG_TYPE_TRACE);
    //if (szPointerToAllExeData) {LocalFree(szPointerToAllExeData);}
    if (hFile!=INVALID_HANDLE_VALUE) {CloseHandle(hFile);}
    return iReturn;
}


void LogFileVersionsForGroupOfSections(IN HINF hFile)
{
    CStringList strList;
    TSTR strTheSection;
    
    if ( !strTheSection.Copy( _T("VerifyFileSections") ) )
    {
      return;
    }

    if (GetSectionNameToDo(hFile, &strTheSection))
    {
        if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, strTheSection.QueryStr() ))
        {
            // loop thru the list returned back
            if (strList.IsEmpty() == FALSE)
            {
                POSITION pos;
                CString csEntry;

                pos = strList.GetHeadPosition();
                while (pos)
                {
                    csEntry = strList.GetAt(pos);
                    LogFileVersionsForThisINFSection(hFile, csEntry);
                    strList.GetNext(pos);
                }
            }
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\reg.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        reg.cxx

   Abstract:

        Class that modifies the registry

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       June 2001: Created

--*/

#include "stdafx.h"
#include "reg.hxx"
#include "tstr.hxx"

// constructor
//
CRegistry::CRegistry():
    m_hKey(NULL)
{
}

// destructor
//
CRegistry::~CRegistry()
{
  CloseRegistry();
}

// function: QueryKey
//
// Query our current registry key
//
HKEY 
CRegistry::QueryKey()
{
  return m_hKey;
}

// function: OpenRegistry
//
// Open a registry handle
//
// Parameters:
//   szNodetoOpen - A string containing the node to open
//   szSubKey - The subkey that you need to open
//   dwAccess - Access that is needed
//   pKey - A pointer to a key that is returned
//
// Return
//   TRUE - Success
//   FALSE - Failure
//
BOOL
CRegistry::OpenRegistry(LPTSTR szNodetoOpen, LPTSTR szSubKey, DWORD dwAccess)
{
  HKEY hHandleValue = HKEY_LOCAL_MACHINE;

  if ( _tcsicmp( szNodetoOpen, _T("HKCR") ) == 0 )
  {
    hHandleValue = HKEY_CLASSES_ROOT;
  }
  else if ( _tcsicmp( szNodetoOpen, _T("HKCC") ) == 0 )
    {
      hHandleValue = HKEY_CURRENT_CONFIG;
    }
    else if ( _tcsicmp( szNodetoOpen, _T("HKCU") ) == 0 )
      {
        hHandleValue = HKEY_CURRENT_USER;
      }
      else if ( _tcsicmp( szNodetoOpen, _T("HKLM") ) == 0 )
        {
          hHandleValue = HKEY_LOCAL_MACHINE;
        }
        else if ( _tcsicmp( szNodetoOpen, _T("HKU") ) == 0 )
          {
            hHandleValue = HKEY_USERS;
          }

  return OpenRegistry( hHandleValue, szSubKey, dwAccess );
}

// function: OpenRegistry
//
// Open a registry handle
//
// Parameters:
//   hKey - Key to open from
//   szSubKey - The subkey that you need to open
//   dwAccess - Access that is needed
//   bCreateIfNotPresent - Should we create key if not existent?
//
// Return
//   TRUE - Success
//   FALSE - Failure
//
BOOL 
CRegistry::OpenRegistry(HKEY hKey, LPCTSTR szSubKey, DWORD dwAccess, BOOL bCreateIfNotPresent /*= FALSE*/ )
{
  DWORD dwRet;

  // Close just incase it was open before
  CloseRegistry();

  dwRet = RegOpenKeyEx(hKey, szSubKey, 0, dwAccess, &m_hKey);

  if ( ( dwRet == ERROR_PATH_NOT_FOUND ) &&
       ( bCreateIfNotPresent ) )
  {
    // Try to create is
    dwRet = RegCreateKeyEx( hKey,
                            szSubKey,
                            0,          // Reserved
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            dwAccess,
                            NULL,       // SD
                            &m_hKey,
                            NULL );
  }

  return ( dwRet == ERROR_SUCCESS );
}

// function: CloseRegistry
//
void
CRegistry::CloseRegistry()
{
  if ( m_hKey )
  {
    RegCloseKey( m_hKey );
    m_hKey = NULL;
  }
}

// function: ReadValue
//
// Parameters:
//   Value - The container for the Value
//
// Return:
//   TRUE - Successfully read
//   FALSE - Could not be read
BOOL 
CRegistry::ReadValue(LPCTSTR szName, CRegValue &Value)
{
  DWORD dwSize = 0;
  DWORD dwType;

  if ( RegQueryValueEx(m_hKey, szName, NULL, &dwType, NULL, &dwSize) != ERROR_SUCCESS)
  {
    // We could not request the size
    return FALSE;
  }

  if ( !Value.m_buffData.Resize( dwSize ) )
  {
    // Could not expland value size
    return FALSE;
  }

  Value.m_dwSize = dwSize;

  if ( RegQueryValueEx(m_hKey, szName, NULL, &Value.m_dwType, (LPBYTE) Value.m_buffData.QueryPtr() , &dwSize) != ERROR_SUCCESS)
  {
    // Could not retrieve value
    return FALSE;
  }

  return TRUE;
}

// funtion : ReadValueString
//
// Read a string in from the registry.  If it is not string, then fail
//
// Parameters:
//   szName - The name of the registry key
//   strValue - The value of the registry value
//
// Return:
//   TRUE - Successfully read
//   FALSE - Could not be read, or it is not a string value
BOOL 
CRegistry::ReadValueString(LPCTSTR szName, TSTR *strValue)
{
  DWORD dwSize = 0;
  DWORD dwType;

  if ( RegQueryValueEx(m_hKey, szName, NULL, &dwType, NULL, &dwSize) != ERROR_SUCCESS)
  {
    // We could not request the size
    return FALSE;
  }

  if ( dwType != REG_SZ )
  {
    // It is not a string
    return FALSE;
  }

  if ( !strValue->Resize( dwSize ) )
  {
    // Could not expland the string
    return FALSE;
  }

  if ( RegQueryValueEx(m_hKey, szName, NULL, &dwType, (LPBYTE) strValue->QueryStr() , &dwSize) != ERROR_SUCCESS)
  {
    // Could not retrieve value
    return FALSE;
  }

  return TRUE;
}

// function: SetValue
//
// Parameters:
//   szName - Name of Value
//   Value - The container for the Value
//
// Return:
//   TRUE - Successfully written
//   FALSE - Could not be written
BOOL 
CRegistry::SetValue(LPCTSTR szName, CRegValue &Value)
{
  DWORD dwSize = 0;

  if ( RegSetValueEx(m_hKey, szName, NULL, Value.m_dwType, (LPBYTE) Value.m_buffData.QueryPtr(), Value.m_dwSize ) != ERROR_SUCCESS)
  {
    // Failed to write value
    return FALSE;
  }

  return TRUE;
}

// function: DeleteValue
//
// Parameters:
//   szName - Name of item to remove
// 
BOOL 
CRegistry::DeleteValue(LPCTSTR szName)
{
  return ( RegDeleteValue( m_hKey, szName ) == ERROR_SUCCESS );
}

// function: DeleteAllValues
//
// Delete all of the values inside a key
//
// Parameters:
//
BOOL 
CRegistry::DeleteAllValues()
{
  TSTR      strValueName;
  DWORD     dwRet = ERROR_SUCCESS;
  DWORD     dwValueNameSize;

  if ( !strValueName.Resize( MAX_PATH ) )
  {
    return FALSE;
  }

  while ( dwRet == ERROR_SUCCESS )
  {
    dwValueNameSize = strValueName.QuerySize();

    dwRet = RegEnumValue( m_hKey,
                          0,                        // Always delete first item
                          strValueName.QueryStr(),  // Buffer
                          &dwValueNameSize,         // Buffer Size
                          NULL,                     // Reserverd
                          NULL,                     // Type
                          NULL,                     // Data
                          0);                       // Size of Data Buffer

    if ( dwRet == ERROR_SUCCESS )
    {
      dwRet = RegDeleteValue( m_hKey, strValueName.QueryStr() );
    }
  }

  return ( ( dwRet == ERROR_SUCCESS ) ||
           ( dwRet == ERROR_NO_MORE_ITEMS )
         );
}

// function: DeleteKey
//
// Delete a key, and possible recursively delete the keys within it
//
// Parameters:
//   szKeyName - The name of the key to delete
//   bDeleteSubKeys - Should we delete all subkeys?
//   dwDepth - The depth that we are in, in our recursive calls
//   
BOOL 
CRegistry::DeleteKey(LPTSTR szKeyName, BOOL bDeleteSubKeys, DWORD dwDepth )
{
  CRegistry CurrentKey;
  TSTR      strSubKeyName;
  DWORD     dwSubKeySize;
  DWORD     dwErr = ERROR_SUCCESS;
  FILETIME  ft;

  if ( dwDepth >= REGKEY_RECURSION_MAXDEPTH )
  {
    // For security reasons, and stack space, lets put a limit on the depth
    return FALSE;
  }

  if ( !strSubKeyName.Resize( MAX_PATH ) )
  {
    return FALSE;
  }

  if ( bDeleteSubKeys )
  {
    if ( !CurrentKey.OpenRegistry( m_hKey, szKeyName, KEY_ALL_ACCESS ) )
    {
      return FALSE;
    }

    while ( dwErr == ERROR_SUCCESS )
    {
      dwSubKeySize = strSubKeyName.QuerySize();

      // Always look at the first key, since after you delete the first key,
      // the second will automatically become the first, and so on
      // WARNING: Watch the return paths for DeleteKey, because if it returns
      //          a true without deleting the key, we will loop forever...
      dwErr = RegEnumKeyEx( CurrentKey.QueryKey(),
                            0,
                            strSubKeyName.QueryStr(),
                            &dwSubKeySize,
                            NULL,
                            NULL,
                            0,
                            &ft );

      // Not call this function, to recursively delete the key
      // that we have found
      if ( dwErr == ERROR_SUCCESS )
      {
        if ( !CurrentKey.DeleteKey( strSubKeyName.QueryStr(), TRUE, dwDepth + 1 ) )
        {
          dwErr = ERROR_ACCESS_DENIED;
        }
      }
    }

    // This should be treated as success, we hit the end of the list
    if ( dwErr == ERROR_NO_MORE_ITEMS )
    {
      dwErr = ERROR_SUCCESS;
    }

    // If we had not problem so far and we are deleting recurisively, 
    // delete all the values in this key
    if ( dwErr == ERROR_SUCCESS )
    {
      if (!CurrentKey.DeleteAllValues() )
      {
        dwErr = ERROR_ACCESS_DENIED;
      }
    }

    CurrentKey.CloseRegistry();
  }

  // If we had not problem so far, delete the key itself
  if ( dwErr == ERROR_SUCCESS )
  {
    dwErr = RegDeleteKey( m_hKey, strSubKeyName.QueryStr() );
  }

  return ( dwErr == ERROR_SUCCESS );
}

// function: Verify Parameters
//
// Verify that the parameters are correct
//
BOOL
CRegistry_MoveValue::VerifyParameters(CItemList &ciParams)
{
  if ( ciParams.GetNumberOfItems() == 6 )
  {
    return TRUE;
  }

  return FALSE;
}

// function: DoInternalWork
//
// Move a registry value
//
// Parameters:
//   ciList - Parameters for function
//     0 - Source location (HKLM/HKCU/...)
//     1 - Source Path (/Software/Microsoft/...)
//     2 - Source Name
//     3 - Target location
//     4 - Target Path
//     5 - Target Name
//
BOOL 
CRegistry_MoveValue::DoInternalWork(CItemList &ciList)
{
  CRegistry   RegSource;
  CRegistry   RegTarget;
  CRegValue   Value;
  BOOL        bRet = TRUE;
  BOOL        bSameLocation = TRUE;

  if ( !RegSource.OpenRegistry(ciList.GetItem(0), ciList.GetItem(1), KEY_READ | KEY_WRITE) )
  {
    // We could not open this node in the registry
    return FALSE;
  }

  if ( ( _tcsicmp( ciList.GetItem(0), ciList.GetItem(3) ) != 0 ) ||
       ( _tcsicmp( ciList.GetItem(1), ciList.GetItem(4) ) != 0 )
     )
  {
    // Since the read and write are not both located at the same node, open the
    // write node also.
    if ( !RegTarget.OpenRegistry(ciList.GetItem(3), ciList.GetItem(4), KEY_READ |KEY_WRITE ) )
    {
      // We could not open the node needed for write in the registry
      return FALSE;
    }

    bSameLocation = FALSE;
  }

  // See if the target already has a value, if it does, then we do not need to move the old value
  if ( bSameLocation )
    bRet = !RegSource.ReadValue( ciList.GetItem(5), Value );
  else
    bRet = !RegTarget.ReadValue( ciList.GetItem(5), Value );

  if ( bRet )
  {
    // Try to read old value
    bRet = RegSource.ReadValue( ciList.GetItem(2), Value );
  }

  if ( bRet )
  {
    // Try to Set the new value
    if ( bSameLocation )
      bRet = RegSource.SetValue( ciList.GetItem(5), Value );
    else
      bRet = RegTarget.SetValue( ciList.GetItem(5), Value );
  }

  if ( bRet )
  {
    // Remove old value, since we have successfully copied it
    bRet = RegSource.DeleteValue( ciList.GetItem(2) );
  }

  return bRet;
}

// function: GetMethodName
//
LPTSTR 
CRegistry_MoveValue::GetMethodName()
{
  return _T("Registry_MoveValue");
}

// function: Verify Parameters
//
// Verify that the parameters are correct
//
BOOL
CRegistry_DeleteKey::VerifyParameters(CItemList &ciParams)
{
  // 3 parameters are for Root,Path,Name of Key
  // 4th parameter can be the if you want it recursively deleted
  if ( ( ciParams.GetNumberOfItems() == 3 ) ||
       ( ( ciParams.GetNumberOfItems() == 4 ) &&
         ( ciParams.IsNumber(3) )
       )
     )
  {
    return TRUE;
  }

  return FALSE;
}

// function: DoInternalWork
//
// Delete a registry key
//
// Parameters:
//   ciList - Parameters for function
//     0 - Source location (HKLM/HKCU/...)
//     1 - Source Path (/Software/Microsoft/...)
//     2 - Source Name
//     3 - Recursively delete keys? (optional)
//
BOOL 
CRegistry_DeleteKey::DoInternalWork(CItemList &ciList)
{
  CRegistry   Reg;
  BOOL        bRet = TRUE;

  if ( !Reg.OpenRegistry(ciList.GetItem(0), ciList.GetItem(1), KEY_ALL_ACCESS ) )
  {
    // We could not open this node in the registry
    return FALSE;
  }

  bRet = Reg.DeleteKey( ciList.GetItem(2),  // Name of specific key to delete
                        ciList.GetNumberOfItems() == 4 ? ciList.GetNumber(3) != 0 : TRUE);  // Delete recursively

  Reg.CloseRegistry( );

  return bRet;
}

// function: GetMethodName
//
LPTSTR 
CRegistry_DeleteKey::GetMethodName()
{
  return _T("Registry_DeleteKey");
}

// SetDword
//
// Set the value to a DWORD
//
BOOL 
CRegValue::SetDword( DWORD dwNewValue )
{
  if ( !m_buffData.Resize( sizeof( DWORD ) ) )
  {
    return FALSE;
  }

  m_dwSize = sizeof( DWORD );
  m_dwType = REG_DWORD;
  *( (LPDWORD) m_buffData.QueryPtr() ) = dwNewValue;

  return TRUE;
}

// GetDword
//
// Retrieve the DWORD Value from the class
//
BOOL 
CRegValue::GetDword( LPDWORD pdwValue )
{
  if ( m_dwType != REG_DWORD )
  {
    // This is not a DWORD
    return FALSE;
  }

  *pdwValue = *( (LPDWORD) m_buffData.QueryPtr() );

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\registry.h ===
#ifndef _REGISTRY_H_
#define _CRegKey_REGISTRY_defined_can_not_include_ATLBASE_H_/* new #def name */
#define _REGISTRY_H_                         /* old #def name */

//----------------------------------------------------------------
// we need the new explicit name since TW_Util.* needs to know if
// its defined in the iis\ui\setup\osrc directory that also defines
// a CRegKey class.  If so it will have trouble including a std
// windows file called <AtlBase.h>
// It keys off of: _CRegKey_REGISTRY_nonATLBASE_H_
//----------------------------------------------------------------


/****************************************************************************
REGISTRY.H
****************************************************************************/

//  Forward declarations
class CRegKey ;
class CRegValueIter ;
class CRegKeyIter ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CRegKey : public CObject
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue ( LPCTSTR pchValueName,
                        DWORD * pdwType,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CStringList to the REG_MULTI_SZ format
    static LONG FlattenValue ( CStringList & strList,
                                DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CByteArray to a REG_BINARY block
    static LONG FlattenValue ( CByteArray & abData,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

public:
    //  Key information return structure
    typedef struct
    {
        TCHAR chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

    //  Standard constructor for an existing key
    CRegKey ( HKEY hKeyBase,
              LPCTSTR pchSubKey = NULL,
              REGSAM regSam = KEY_ALL_ACCESS ) ;

    //  Constructor creating a new key.
    CRegKey ( LPCTSTR lpSubKey,
            HKEY hKeyBase,
            LPCTSTR lpValueName = NULL,
            DWORD dwType = 0,
            LPBYTE lpValueData = NULL,
            DWORD cbValueData = 0);

    ~ CRegKey () ;

    //  Allow a CRegKey to be used anywhere an HKEY is required.
    operator HKEY ()
        { return m_hKey ; }

    //  Fill a key information structure
    LONG QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
            //  if data exists but not in correct form to deliver into result object.
    LONG QueryValue ( LPCTSTR pchValueName, CString & strResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    LONG QueryValue ( LPCTSTR pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );

    //  Overloaded value setting members.
    LONG SetValue ( LPCTSTR pchValueName, LPCTSTR szResult, BOOL fExpand = FALSE ) ;
    LONG SetValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    LONG SetValue ( LPCTSTR pchValueName, DWORD dwResult ) ;
    LONG SetValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    LONG SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );

    LONG DeleteValue( LPCTSTR pchKeyName );
    LONG DeleteTree( LPCTSTR pchKeyName );

    int m_iDisplayWarnings;
};


    //  Iterate the values of a key, return the name and type
    //  of each.
class CRegValueIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegValueIter ( CRegKey & regKey ) ;
    ~ CRegValueIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, DWORD * pdwType ) ;
    LONG Next ( CString * pstrName, CString * pstrValue );

    // decrement the m_dw_index to account for deleted keys
    void Decrement( DWORD delta = 1 ) {m_dw_index -= delta;}

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

    //  Iterate the sub-key names of a key.
class CRegKeyIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
        DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegKeyIter ( CRegKey & regKey ) ;
    ~ CRegKeyIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, CTime * pTime = NULL ) ;

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

#endif  // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\product.cpp ===
#include "stdafx.h"
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "helper.h"

INT Register_iis_common()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_common__before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_common_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_common_after"));
    return (0);
}

INT Unregister_iis_common()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_common__before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_common_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_common_after"));
    return (0);

}

INT Register_iis_inetmgr()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];
    ACTION_TYPE atINETMGR = GetSubcompAction(_T("iis_inetmgr"), TRUE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_inetmgr_before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_inetmgr_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_inetmgr_after"));
    return (0);
}

INT Unregister_iis_inetmgr()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_inetmgr_before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_inetmgr_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_inetmgr_after"));
    return (0);
}



INT Register_iis_doc()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_doc__before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_doc_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_doc_after"));
    return (0);
    return 0;
}


// for backward compat
#define     PWS_TRAY_WINDOW_CLASS       _T("PWS_TRAY_WINDOW")

INT Register_iis_pwmgr()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];
    ACTION_TYPE atPWMGR = GetSubcompAction(_T("iis_pwmgr"),TRUE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_pwmgr_before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_pwmgr_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_pwmgr_after"));
    return (0);


    return (0);
}

INT Unregister_iis_pwmgr()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_pwmgr_before"));

    // kill pwstray.exe
    HWND hwndTray = NULL;
    hwndTray = FindWindow(PWS_TRAY_WINDOW_CLASS, NULL);
    if ( hwndTray ){::PostMessage( hwndTray, WM_CLOSE, 0, 0 );}

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_pwmgr_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_pwmgr_after"));
    return (0);
}



//
// (un)register-Order is important here
//
#define Register_iis_core_log _T("Register_iis_core")
INT Register_iis_core()
{
    INT err = 0;
    int iTempFlag = FALSE;
    INT iUserWasNewlyCreated = 0;
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    iisDebugOut_Start(Register_iis_core_log, LOG_TYPE_PROGRAM_FLOW);
    ACTION_TYPE atCORE = GetIISCoreAction(TRUE);
    ACTION_TYPE atFTP = GetSubcompAction(_T("iis_ftp"), FALSE);
    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"), FALSE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_core_before"));
    AdvanceProgressBarTickGauge();

#ifndef _CHICAGO_
    if ( atCORE == AT_INSTALL_FRESH ||  g_pTheApp->m_bWin95Migration || (atCORE == AT_INSTALL_REINSTALL && g_pTheApp->m_bRefreshSettings) ) 
    {
        int iSomethingWasSet = FALSE;
        g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csGuestName;
        g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csGuestPassword;
        g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csGuestName;
        g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csGuestPassword;

        // Check if there were any specified unattended users
        // if they specified a www user, then we'll try to use that one.
        
        // if www was specified to be install, then check for that specified name...
        if (atWWW == AT_INSTALL_FRESH) 
        {
            if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_NAME)
            {
                if (_tcsicmp(g_pTheApp->m_csWWWAnonyName_Unattend,_T("")) != 0)
                {
                    g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csWWWAnonyName_Unattend;
                    iSomethingWasSet = TRUE;
                }
            }
            if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_PASS)
            {
                g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csWWWAnonyPassword_Unattend;
                iSomethingWasSet = TRUE;
            }
        }


        if (TRUE == iSomethingWasSet)
            {
                CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword,&iUserWasNewlyCreated);
                if (1 == iUserWasNewlyCreated)
                {
                    // Add to the list
                    g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),g_pTheApp->m_csWWWAnonyName);
                }
            }
        else
        {
            // check if we're setting up ftp
            // if ftp was specified to be install, then check for that specified name...
            if (atFTP == AT_INSTALL_FRESH) 
            {

                if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_NAME)
                {
                    if (_tcsicmp(g_pTheApp->m_csFTPAnonyName_Unattend,_T("")) != 0)
                    {
                        g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csFTPAnonyName_Unattend;
                        iSomethingWasSet = TRUE;
                    }
                }

                if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_PASS)
                {
                    g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csFTPAnonyPassword_Unattend;
                    iSomethingWasSet = TRUE;
                }
            }
            if (TRUE == iSomethingWasSet)
            {
                CreateIUSRAccount(g_pTheApp->m_csFTPAnonyName, g_pTheApp->m_csFTPAnonyPassword,&iUserWasNewlyCreated);
                if (1 == iUserWasNewlyCreated)
                {
                    // Add to the list
                    g_pTheApp->UnInstallList_Add(_T("IUSR_FTP"),g_pTheApp->m_csFTPAnonyName);
                }
            }
            else
            {
                // Ah, nothing specified by user.  
                // just Create IUSR_ account, with defaults!
                CreateIUSRAccount(g_pTheApp->m_csGuestName, g_pTheApp->m_csGuestPassword,&iUserWasNewlyCreated);
            }
        }

        AdvanceProgressBarTickGauge();
    }
#endif // _CHICAGO_

    SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 33000, g_pTheApp->m_csGuestName);

    iCount = 0;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_core_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);

        AdvanceProgressBarTickGauge();
    }


    // Add special property registry key
    WriteToMD_IDRegistration(_T("LM/IISADMIN/PROPERTYREGISTRATION"));

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_core_after"));

    iisDebugOut_End(Register_iis_core_log, LOG_TYPE_PROGRAM_FLOW);
    return (err);
}

#define Unregister_iis_core_log _T("Unregister_iis_core")
INT Unregister_iis_core()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    iisDebugOut_Start(Unregister_iis_core_log, LOG_TYPE_PROGRAM_FLOW);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_core_before"));
    AdvanceProgressBarTickGauge();

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_core_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);

        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_core_after"));
    AdvanceProgressBarTickGauge();
    ShowIfModuleUsedForGroupOfSections(g_pTheApp->m_hInfHandle, TRUE);
    AdvanceProgressBarTickGauge();

    iisDebugOut_End(Unregister_iis_core_log, LOG_TYPE_PROGRAM_FLOW);
    return 0;
}


#define Unregister_old_asp_log _T("Unregister_old_asp")
INT Unregister_old_asp()
{
    //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("Unreg_old_asp:"));
    iisDebugOut_Start(Unregister_old_asp_log, LOG_TYPE_TRACE);

    CRegKey regASPUninstall(HKEY_LOCAL_MACHINE, REG_ASP_UNINSTALL, KEY_READ);
    if ((HKEY)regASPUninstall) 
    {
        // old asp exists
        ProcessSection(g_pTheApp->m_hInfHandle, _T("Unregister_old_asp"));

        // do not remove these dirs, aaronl
        //RecRemoveDir(g_pTheApp->m_csPathAdvWorks);
        //RecRemoveDir(g_pTheApp->m_csPathASPSamp);
        CRegKey regWWWVRoots( HKEY_LOCAL_MACHINE, REG_WWWVROOTS);
        if ((HKEY)regWWWVRoots) 
        {
            regWWWVRoots.DeleteValue(_T("/IASDocs"));
            // delete "/IASDocs," or "/IASDocs,<ip>"
            CRegValueIter regEnum( regWWWVRoots );
            CString csName, csValue;
            while ( regEnum.Next( &csName, &csValue ) == ERROR_SUCCESS ) 
            {
                csName.MakeUpper();
                if (csName.Left(9) == _T("/IASDOCS,"))
                    {
                    regWWWVRoots.DeleteValue((LPCTSTR)csName);
                    // tell the iterator to account for the item we just deleted
                    regEnum.Decrement();
                    }
            }
            // do not remove these vroots,aaronl
            //regWWWVRoots.DeleteValue(_T("/AdvWorks"));
            //regWWWVRoots.DeleteValue(_T("/ASPSamp"));
        }
    }
    iisDebugOut_End(Unregister_old_asp_log, LOG_TYPE_TRACE);
    //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\registry.cpp ===
#include "stdafx.h"
// defined with iisrtl2.lib
//DEBUG_PRINTS * g_pDebug;

// open an existing key
// if failure, return NULL pointer and put error into SetLastError();
CRegKey :: CRegKey (HKEY hKeyBase, LPCTSTR pchSubKey,REGSAM regSam ) : m_hKey( NULL ), m_dwDisposition( 0 )
{
    LONG err = ERROR_SUCCESS ;
    SetLastError(ERROR_SUCCESS);
    m_iDisplayWarnings = TRUE;

    if ( pchSubKey )
		{err = ::RegOpenKeyEx( hKeyBase, pchSubKey, 0, regSam, & m_hKey ) ;}
    else
		{m_hKey = hKeyBase ;}

    if ( err != ERROR_SUCCESS )
    {
        if (m_hKey) {::RegCloseKey(m_hKey);}
        m_hKey = NULL ;
        // Check if the error is because it simply doesn't exist.
        // if this is the case then don't say failed.  Say WARNING.
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRegKey:CRegKey() %s Key doesn't exist.  WARNING. Code=0x%x\n"), pchSubKey, err));}
        }
        else
        {
		    iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey:CRegKey() %s FAILED.  Err=0x%x\n"), pchSubKey, err));
        }
        SetLastError(err);
    }
}

//  Constructor creating a new key/opening a key if already exist, and set value if specified
CRegKey :: CRegKey (LPCTSTR lpSubKey,HKEY hKeyBase,LPCTSTR lpValueName,DWORD dwType,LPBYTE lpValueData,DWORD cbValueData): m_hKey( NULL ),m_dwDisposition( 0 )
{
    LONG err = ERROR_SUCCESS;
    SetLastError(ERROR_SUCCESS);
    m_iDisplayWarnings = TRUE;

    err = ::RegCreateKeyEx( hKeyBase, lpSubKey, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, & m_hKey, & m_dwDisposition ) ;
    if ( err != ERROR_SUCCESS)
	{
        if ( m_hKey ) {::RegCloseKey( m_hKey ) ;}
        m_hKey = NULL ;
        // Check if the error is because it simply doesn't exist.
        // if this is the case then don't say failed.  Say WARNING.
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRegKey:CRegKey() %s Key doesn't exist.  WARNING. Code=0x%x\n"), lpSubKey, err));}
        }
        else
        {
		    iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::CRegKey() Open %s FAILED.  err=0x%x\n"), lpSubKey, err));
        }
        SetLastError(err);
    }
	else
	{
        if (lpValueName)
		{
			::RegSetValueEx(m_hKey, lpValueName, 0, dwType, (const LPBYTE)lpValueData, cbValueData);
			if ( err != ERROR_SUCCESS)
			{
				iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::CRegKey() RegSetValueEx %s, %s FAILED.  err=0x%x\n"), lpSubKey,lpValueName, err));
                SetLastError(err);
			}
		}
    }
}

CRegKey :: ~ CRegKey ()
{
    if (m_hKey) {::RegCloseKey( m_hKey );}
}


    //  Prepare to read a value by finding the value's size.
LONG CRegKey :: PrepareValue (LPCTSTR pchValueName, DWORD * pdwType,DWORD * pcbSize,BYTE ** ppbData )
{
    LONG err = 0 ;

    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueEx( *this, (TCHAR *) pchValueName, 0, pdwType, chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( err == 0 )
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( err != ERROR_MORE_DATA )
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //  Now that have a buffer, re-fetch the value.

        err = ::RegQueryValueEx( *this, (TCHAR *) pchValueName, 0, pdwType, *ppbData, pcbSize ) ;

    } while ( FALSE ) ;

    if ( err )  {delete [] *ppbData ;}

    return err ;
}

//  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
//  if data exists but not in correct form to deliver into result object.
LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CString & strResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        err = PrepareValue( pchValueName, & dwType, & cbData, & pabData );

        if ( err )
			  {
          break;
        }

        if (( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ))
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the data looks like a string
        pabData[cbData] = 0 ;

        //  Catch exceptions trying to assign to the caller's string
        TRY
        {
            strResult = (TCHAR *) pabData ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x\n"), pchValueName, err));
            }
        }
    }
    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CStringList & strList )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;
    TCHAR * pbTemp, * pbTempLimit ;

    do
    {
        err = PrepareValue( pchValueName, & dwType, & cbData, & pabData );

        if ( err != 0 )
			  {
            break ;
        }

        if ( dwType != REG_MULTI_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the trailing data looks like a string
        pabData[cbData] = 0 ;
        pbTemp = (TCHAR *) pabData ;
        pbTempLimit = (TCHAR *) (& pabData[cbData]) ;

        //  Catch exceptions trying to build the list
        TRY
        {
            for ( ; pbTemp < pbTempLimit ; )
            {
                strList.AddTail( pbTemp ) ;
                pbTemp += ::_tcslen( pbTemp ) + 1 ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while ( FALSE ) ;

    delete [] pabData ;

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x.\n"), pchValueName, err));
            }
        }
    }
    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, DWORD & dwResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        err = PrepareValue( pchValueName, & dwType, & cbData, & pabData );

        if ( err != 0 )
            break ;

        if ( dwType != REG_DWORD || cbData != sizeof dwResult )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        dwResult = *((DWORD *) pabData) ;
    }
    while ( FALSE ) ;

    // Memory leak...
    //if ( err )
    //{
        delete [] pabData ;
    //}

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x.\n"), pchValueName, err));
            }
        }
    }
    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CByteArray & abResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        err = PrepareValue( pchValueName, & dwType, & cbData, & pabData );

        if ( err != 0 )
        {
            break ;
        }

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Catch exceptions trying to grow the result array
        TRY
        {
            abResult.SetSize( cbData ) ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL

        if ( err )
            break ;

        //  Move the data to the result array.
        for ( DWORD i = 0 ; i < cbData ; i++ )
        {
            abResult[i] = pabData[i] ;
        }
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x.\n"), pchValueName, err));
            }
        }
    }
    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        err = PrepareValue( pchValueName, & dwType, & cbData, & pabData );

        if ( err != 0 )
        {
            break ;
        }

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( cbSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(pvResult, pabData, cbData);
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x.\n"), pchValueName, err));
            }
        }
    }
    return err ;
}


//  Overloaded value setting members.
LONG CRegKey :: SetValue ( LPCTSTR pchValueName, LPCTSTR szResult, BOOL fExpand )
{
    LONG err = 0;
    err = ::RegSetValueEx( *this, pchValueName,0,fExpand ? REG_EXPAND_SZ : REG_SZ,(const BYTE *) szResult,(_tcsclen(szResult) + 1) * sizeof(_TCHAR) ) ;
	if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, CStringList & strList )
{
    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( strList, & cbSize, & pbData ) ;
    if ( err == 0 )
    {
        err = ::RegSetValueEx( *this, pchValueName,0,REG_MULTI_SZ,pbData, cbSize ) ;
		if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    }

    delete [] pbData ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, DWORD dwResult )
{
    LONG err = 0;
    err = ::RegSetValueEx( *this, pchValueName,0,REG_DWORD,(const BYTE *) & dwResult,sizeof dwResult ) ;
	if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, CByteArray & abResult )
{
    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( abResult, & cbSize, & pbData ) ;

    if ( err == 0 )
    {
        err = ::RegSetValueEx( *this, pchValueName,0,REG_BINARY,pbData, cbSize ) ;
		if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    }

    delete pbData ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize )
{
    LONG err = 0;
    err = ::RegSetValueEx( *this, pchValueName,0,REG_BINARY,(const BYTE *)pvResult, cbSize ) ;
	if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    return err ;
}

LONG CRegKey::DeleteValue( LPCTSTR pchKeyName )
{
    LONG err = 0;
    err = ::RegDeleteValue( *this, pchKeyName );
	if (err != ERROR_SUCCESS)
    {
        if ( err != ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::DeleteValue(): %s FAILED, err=0x%x\n"), pchKeyName,err));
        }
    }
    return(err);
}

LONG CRegKey::DeleteTree( LPCTSTR pchKeyName )
{
    LONG err = 0;
    CRegKey regSubKey( *this, pchKeyName );

    if ( NULL != (HKEY) regSubKey )
    {
        CString strName;
        CTime cTime;

        while (TRUE)
        {
            CRegKeyIter regEnum( regSubKey );

            if ( regEnum.Next( &strName, &cTime ) != ERROR_SUCCESS )
            {
                break;
            }

            regSubKey.DeleteTree( strName );
        }
        // delete myself
        err = ::RegDeleteKey( *this, pchKeyName );
    }
    return(err);
}

LONG CRegKey :: FlattenValue ( CStringList & strList, DWORD * pcbSize, BYTE ** ppbData )
{
    LONG err = 0 ;

    POSITION pos ;
    CString * pstr ;
    int cbTotal = 0 ;

    //  Walk the list accumulating sizes
    for ( pos = strList.GetHeadPosition() ; 
          ( pos != NULL ) && ( ( pstr = & strList.GetNext( pos ) ) != NULL ) ; 
        )
    {
        cbTotal += ((pstr->GetLength() + 1)*sizeof(TCHAR));
    }

    //  Allocate and fill a temporary buffer
    *pcbSize = cbTotal;

    if ( *pcbSize )
    {
        TRY
        {
            *ppbData = new BYTE[ *pcbSize ] ;

            if (*ppbData)
            {
                BYTE * pbData = *ppbData ;

                //  Populate the buffer with the strings.
                for ( pos = strList.GetHeadPosition() ; 
                      ( pos != NULL ) && ( ( pstr = & strList.GetNext( pos ) ) != NULL ); 
                     )
                {
                    int cb = (pstr->GetLength() + 1)*sizeof(TCHAR) ;
                    ::memcpy( pbData, (LPCTSTR) *pstr, cb ) ;
                    pbData += cb ;
                }
            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

	if (err)
    {
            iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::FlattenValue(): %s FAILED.  err=0x%x.\n"), strList, err));
    }
    return err ;
}

LONG CRegKey :: FlattenValue ( CByteArray & abData,DWORD * pcbSize,BYTE ** ppbData )
{
    LONG err = 0 ;

    DWORD i ;

    //  Allocate and fill a temporary buffer
    *pcbSize = (DWORD)abData.GetSize();

    if ( *pcbSize )
    {
        TRY
        {
            *ppbData = new BYTE[*pcbSize] ;
            if (*ppbData)
            {
                for ( i = 0 ; i < *pcbSize ; i++ )
                {
                    (*ppbData)[i] = abData[i] ;
                }
            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
            }

        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

	if (err)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::FlattenValue(): FAILED.  err=0x%x.\n"), err));
    }
    return err ;
}


LONG CRegKey :: QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo )
{
    LONG err = 0 ;
    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;
    err = ::RegQueryInfoKey( *this,pRegKeyInfo->chBuff,& pRegKeyInfo->dwClassNameSize,NULL,& pRegKeyInfo->dwNumSubKeys,& pRegKeyInfo->dwMaxSubKey,& pRegKeyInfo->dwMaxClass,& pRegKeyInfo->dwMaxValues,& pRegKeyInfo->dwMaxValueName,& pRegKeyInfo->dwMaxValueData,& pRegKeyInfo->dwSecDesc,& pRegKeyInfo->ftKey ) ;
	if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryKeyInfo(): FAILED.  err=0x%x.\n"), err));}
    return err ;
}

CRegKeyIter :: CRegKeyIter ( CRegKey & regKey ) : m_rk_iter( regKey ),m_p_buffer( NULL ),m_cb_buffer( 0 )
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;
    if ( err == 0 )
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegKeyIter::CRegKeyIter(): FAILED.  err=0x%x.\n"), err));
        }
    }
}

CRegKeyIter :: ~ CRegKeyIter ()
{
    delete [] m_p_buffer ;
}


    // Get the name (and optional last write time) of the next key.
LONG CRegKeyIter :: Next ( CString * pstrName, CTime * pTime )
{
    LONG err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    err = ::RegEnumKeyEx( m_rk_iter, m_dw_index, m_p_buffer,& dwNameSize, NULL,NULL,NULL,& ftDummy ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        if ( pTime )
        {
            *pTime = ftDummy ;
        }

        TRY
        {
            *pstrName = m_p_buffer ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegKeyIter::Next(): FAILED.  err=0x%x.\n"), err));
        }
    }
    return err ;
}


CRegValueIter :: CRegValueIter ( CRegKey & regKey )
    : m_rk_iter( regKey ),
    m_p_buffer( NULL ),
    m_cb_buffer( 0 )
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegValueIter::CRegValueIter(): FAILED.  err=0x%x.\n"), err));
        }
    }
}

CRegValueIter :: ~ CRegValueIter ()
{
    delete [] m_p_buffer ;
}

LONG CRegValueIter :: Next ( CString * pstrName, DWORD * pdwType )
{
    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;
    err = ::RegEnumValue( m_rk_iter,m_dw_index,m_p_buffer,& dwNameLength,NULL,pdwType,NULL,NULL ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        TRY
    {
        *pstrName = m_p_buffer ;
    }
    CATCH_ALL(e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegValueIter::Next(): FAILED.  err=0x%x.\n"), err));
        }
    }
    return err ;
}

LONG CRegValueIter :: Next ( CString * pstrName, CString * pstrValue )
{
    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    TCHAR szValue[_MAX_PATH];
    DWORD dwValue = _MAX_PATH * sizeof(TCHAR);

    err = ::RegEnumValue( m_rk_iter,m_dw_index,m_p_buffer,& dwNameLength,NULL,NULL,(LPBYTE)szValue,&dwValue ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        TRY
        {
            *pstrName = m_p_buffer ;
            *pstrValue = szValue;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegValueIter::Next(): FAILED.  err=0x%x.\n"), err));
        }
    }
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\parse.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        parse.hxx

   Abstract:

        This class is used to parse a line in the inf file

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       June 2001: Created

--*/

#include "stdafx.h"
#include "Parse.hxx"

// function: FindNextOccurance
//
// Find the next occurance of a character.  This will parse through a line,
// and find the next occurance of a character that is not inside '(','{'
// or '"'.
//
// Parameters:
//   szLine - The Line to parse, at the position you want to start the search
//   chTerminator - The character that you are looking for
//
// Return
//   NULL - Could not find character
//   pointer - the address of that terminator character
LPTSTR 
CParse::FindNextOccurance(LPTSTR szLine, TCHAR chTerminator)
{
  DWORD dwParen = 0;
  DWORD dwCurlyBraces = 0;
  BOOL bQuotes = FALSE;

  if (!szLine)
  {
    ASSERT(szLine);
    return NULL;
  }

  while (*szLine != '\0')
  {
    switch (*szLine)
    {
      case '"':
        bQuotes = !bQuotes;
        break;
      case '(':
        dwParen++;
        break;
      case ')':
        dwParen--;
        break;
      case '{':
        dwCurlyBraces++;
        break;
      case '}':
        dwCurlyBraces--;
        break;
      default:
        break;
    }

    if ( ( *szLine == chTerminator) &&
         ( dwParen == 0 ) &&
         ( dwCurlyBraces == 0 ) &&
         ( bQuotes == FALSE )
       )
    {
      return szLine;
    }

    szLine++;
  }

  return NULL;
}


// function: ParseLine
//
// Parse the line that has been send in, and interpret it accordingly, calling
// the appropriate functions
//
// Parameters:
//   szLine - The line to be interpreted.  THIS WILL BE MODIFIED accordingly, and
//            may not be returned in the state it was sent in.  This paremeter must
//            not be static
//
// return:
//   TRUE - Result returned is TRUE
//   FALSE - Result retuened is FALSE
BOOL
CParse::ParseLine(CFunctionDictionary *pDict, LPTSTR szLine)
{
  LPTSTR szThenStatement = NULL;
  LPTSTR szElseStatement = NULL;
  BOOL bRet = TRUE;

  if (!szLine)
  {
    ASSERT(!szLine);
    return FALSE;
  }

  szThenStatement = FindNextOccurance(szLine,'?');

  if ( szThenStatement )
  {
    szElseStatement = FindNextOccurance(szThenStatement,':');

    if ( szElseStatement )
    {
      *szElseStatement = '\0';
    }
    *szThenStatement = '\0';
  }

  if (szThenStatement || szElseStatement)
  {
    // If we could break this line apart, then lets try to break it apart again
    bRet = ParseLine(pDict, szLine);
  }
  else 
    if ( LPTSTR szOpenCurly = _tcschr( szLine, _T('{') ) )
    {
      // If this line contains { }, it needs further breaking apart
      LPTSTR szCloseCurly = _tcsrchr( szOpenCurly, _T('}') );

      if ( szCloseCurly )
      {
        *szCloseCurly = '\0';

        bRet = ParseLine(pDict, szOpenCurly+1);

        *szCloseCurly = '}';
      }
    }
    else
    {
      bRet = CallFunction(pDict, szLine);
    }

  if ( (bRet) && (szThenStatement) )
  {
    // Since this returned TRUE, call the Then part
    ParseLine(pDict,szThenStatement+1);
  }

  if ( (!bRet) && (szElseStatement) )
  {
    // Since this returned FALSE, call the Else part
    ParseLine(pDict,szElseStatement+1);
  }

  if (szThenStatement)
  {
    *szThenStatement = '?';
  }
  if (szElseStatement)
  {
    *szElseStatement = ':';
  }

  return bRet;
}

// function: CallFunction
//
// This function calls the appropriate function for this szLine
//
// Parameters:
//   szLine - The function to call with its parameters
//
// Return:
//   TRUE: The function returned true
//   FALSE: The function returned false
//
BOOL 
CParse::CallFunction(CFunctionDictionary *pDict, LPTSTR szLine)
{
  LPTSTR szFunctionName = szLine;
  LPTSTR szOpenParen = _tcschr( szLine, _T('(') );
  LPTSTR szCloseParen = szOpenParen ? _tcsrchr( szOpenParen, _T(')') ) : NULL;
  LPTSTR szParameters = szOpenParen + 1;
  BOOL bRet;

  if (!szOpenParen || !szCloseParen)
  {
    // Report error, this function had no parameters!
    return FALSE;
  }

  *szOpenParen = '\0';
  *szCloseParen = '\0';

  bRet = pDict->CallFunction(szFunctionName, szParameters);

  *szOpenParen = '(';
  *szCloseParen = ')';

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\restrlst.cxx ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        restrlst.cxx

   Abstract:

        Classes that are used to modify the restriction list and application
        dependency list in the metabase

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:

       April 2002: Created

--*/

#include "stdafx.h"
#include "restrlst.hxx"
#include "xmlupgrade.hxx"

// Constructor
//
CApplicationDependencies::CApplicationDependencies()
{
  m_bMetabaseOpened = FALSE;
}

// InitMetabase
//
// Open the metabase, at the correct location for the Application Dependecies,
// so that we can read and write to it
//
BOOL
CApplicationDependencies::InitMetabase()
{
  if ( m_bMetabaseOpened )
  {
    return TRUE;
  }

  m_bMetabaseOpened = SUCCEEDED( m_Metabase.OpenNode( METABASEPATH_WWW_ROOT, TRUE ) );

  return m_bMetabaseOpened;
}

// LoadCurrentSettings
//
// Load the current settings from the metabase
//
BOOL
CApplicationDependencies::LoadCurrentSettings()
{
  CMDValue mbValue;
  BOOL     bRet = TRUE;

  if ( !InitMetabase() )
  {
    return FALSE;
  }

  if ( !m_Metabase.GetData( mbValue, MD_APP_DEPENDENCIES ) )
  {
    m_mstrDependencies.Empty();
  }
  else
  {
    if ( ( mbValue.GetDataType() != MULTISZ_METADATA ) ||
         !m_mstrDependencies.Copy( (LPWSTR) mbValue.GetData() )
       )
    {
      // Either wrong type, or the copy failed
      bRet = FALSE;
    }
  }

  return bRet;
}

// SaveSettings
//
// Save the settings to the metabase
//
BOOL
CApplicationDependencies::SaveSettings()
{
  CMDValue  mbValue;

  if ( !InitMetabase() )
  {
    return FALSE;
  }

  if ( !mbValue.SetValue( MD_APP_DEPENDENCIES,                // Metabase property
                        0,                                    // Attributes
                        IIS_MD_UT_SERVER,                     // User Type
                        MULTISZ_METADATA,                     // Data Type
                        m_mstrDependencies.QueryLen() * sizeof(TCHAR), // Length
                        (LPVOID) m_mstrDependencies.QueryMultiSz() ) ) // Data
  {
    return FALSE;
  }

  return m_Metabase.SetData( mbValue, MD_APP_DEPENDENCIES );
}

// AddUnattendSettings
//
// Read the unattend settings from the file, and
// put them in the list
//
// It expects the lines in the unattend to be in the form
// [InternetServer]
// ApplicationDependency=CommerceServer,ASP60,INDEX99
// ApplicationDependency=ExchangeServer,ASP60
// ApplicationDependency=MyApp,ASPNET20
//
// And will product in the m_mstrDependencies:
// CommerceServer;ASP60,INDEX99\0
// ExchangeServer;ASP60\0
// MyApp;ASPNET20\0
// \0
//
// Return:
//   TRUE - Successfully imported all settings
//   FAILED - Failed to import settings
//
BOOL
CApplicationDependencies::AddUnattendSettings()
{
  BOOL        bContinue;
  INFCONTEXT  Context;
  TSTR        strLine;
  DWORD       dwRequiredSize;
  LPTSTR      szFirstComma;

  if ( g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE )
  {
    // Since there is no unattend file, return success
    return TRUE;
  }

  bContinue = SetupFindFirstLine( g_pTheApp->m_hUnattendFile,
                                  UNATTEND_FILE_SECTION,
                                  UNATTEND_INETSERVER_APPLICATIONDEPENDENCIES,
                                  &Context);

  while ( bContinue )
  {
    if ( !SetupGetLineText( &Context, INVALID_HANDLE_VALUE, NULL, NULL,
                            strLine.QueryStr(), strLine.QuerySize(), &dwRequiredSize) )
    {
      // Need to resize for larger buffer
      if ( ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ||
           ( dwRequiredSize <= strLine.QuerySize() ) ||
           !strLine.Resize( dwRequiredSize ) ||
           !SetupGetLineText( &Context, INVALID_HANDLE_VALUE, NULL, NULL,
                              strLine.QueryStr(), strLine.QuerySize(), &dwRequiredSize) )
      {
        // Failure to either resize, or read in data
        return FALSE;
      }
    }

    szFirstComma = _tcschr( strLine.QueryStr(), ',' );

    if ( !szFirstComma )
    {
      iisDebugOut((LOG_TYPE_ERROR,
                   _T("Failed to import Application Dependencies unattend \
                       setting '%s=%s' because it is in the wrong format"),
                  UNATTEND_INETSERVER_APPLICATIONDEPENDENCIES,
                  strLine.QueryStr() ) );

      return FALSE;
    }

    // Change the first comma to a ';', since the format in the unattend file,
    //and the metabase are different
    *szFirstComma = _T(';');

    // Remove the old line, if one existed for this Application
    if ( !RemoveOldAppDendency( strLine.QueryStr() ) )
    {
      return FALSE;
    }

    if ( !m_mstrDependencies.Add( strLine.QueryStr() ) )
    {
      return FALSE;
    }

    bContinue = SetupFindNextMatchLine( &Context,
                                        UNATTEND_INETSERVER_APPLICATIONDEPENDENCIES,
                                        &Context);
  }

  return TRUE;
}

// RemoveOldAppDendency
//
// Since a New Application Dependency line is being added, make sure to
// remove anylines that are already in the list for an Application
// with the same name
//
// Parameters:
//   szNewLine - The New line to be added
//
// Return
//   TRUE - It was removed if necessary
//   FALSE - Failure to remove old Line
BOOL
CApplicationDependencies::RemoveOldAppDendency( LPTSTR szNewLine )
{
  LPTSTR  szDelimeter = _tcschr( szNewLine, _T(';') );
  DWORD   dwLength;
  DWORD   dwCurrent;
  LPTSTR  szCurrent;

  if ( !szDelimeter )
  {
    // This should be in the correct format by the time it gets to us
    ASSERT( szDelimeter );
    return FALSE;
  }

  // The length on the name, including the ';'
  dwLength = (DWORD) ( szDelimeter + 1 - szNewLine );

  for ( dwCurrent = 0;
        ( szCurrent = m_mstrDependencies.QueryString( dwCurrent ) ) != NULL;
        dwCurrent++ )
  {
    // Compare Strings
    if ( _tcsnicmp( szCurrent, szNewLine, dwLength ) == 0 )
    {
      // This already exists in the list.  If the list is correct then
      // it can only be in the list once, so return
      return m_mstrDependencies.Remove( szCurrent, TRUE );
    }
  }

  // Not found, so no need to remove
  return TRUE;
}

// DoUnattendSettingsExist
//
// Do a simple check to see if unattend settings for this
// property exist.  Because if they don't, there is nothing
// to do.
//
BOOL
CApplicationDependencies::DoUnattendSettingsExist()
{
  INFCONTEXT  Context;

  if ( g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE )
  {
    return FALSE;
  }

  return SetupFindFirstLine( g_pTheApp->m_hUnattendFile,
                             UNATTEND_FILE_SECTION,
                             UNATTEND_INETSERVER_APPLICATIONDEPENDENCIES,
                             &Context);
}

// FindApplication
//
// Find the application in the list
//
// Parameters:
//   szApplicationName [in] - The name of the application to look for
//
// Return Values:
//   NULL - Not found
//   pointer - Pointer to item in list
//
LPTSTR
CApplicationDependencies::FindApplication( LPTSTR szApplicationName )
{
  DWORD   dwCurrent;
  LPTSTR  szCurrent;
  DWORD   dwLength = _tcslen( szApplicationName );

  ASSERT( szApplicationName );

  for ( dwCurrent = 0;
        ( szCurrent = m_mstrDependencies.QueryString( dwCurrent ) ) != NULL;
        dwCurrent++ )
  {
    // Compare Strings
    if ( ( _tcsnicmp( szCurrent, szApplicationName, dwLength ) == 0 ) &&
         ( ( *( szCurrent + dwLength ) == _T('\0') ) ||
           ( *( szCurrent + dwLength ) == _T(';') )
         )
       )
    {
      // It has been found
      return szCurrent;
    }
  }

  // Not found
  return NULL;
}

// DoesApplicationExist
//
// Determine if the application extst in the list
//
// Parameters:
//   szApplicationName [in] - The name of the application to look for
//
// Return Values:
//   TRUE - It exists
//   FALSE - It does not exist
//
BOOL
CApplicationDependencies::DoesApplicationExist( LPTSTR szApplicationName )
{
  return ( FindApplication( szApplicationName ) != NULL );
}

// AddApplication
//
// Add an application to the Application Dependencies list
//
// Parameters:
//   szApplication [in] - The name of the Application
//                        (ie. "Active Server Pages")
//                        Should contain no ';' or ','
//   szDependencies [in] - The dependencies seperated by comma's
//   bReplaceExisting [in] - If an application by the same name is in the
//                           list, should we replace it?
BOOL
CApplicationDependencies::AddApplication( LPTSTR szApplication,
                                          LPTSTR szDependencies,
                                          BOOL bReplaceExisting )
{
  LPTSTR  szOldApplication;
  TSTR    strNewApplication;

  ASSERT( szApplication );
  ASSERT( szDependencies );

  szOldApplication = FindApplication( szApplication );

  if ( szOldApplication )
  {
    if ( bReplaceExisting )
    {
      // Remove old item
      if ( !m_mstrDependencies.Remove( szOldApplication, TRUE ) )
      {
        // Failed to remove old item
        return FALSE;
      }
    }
    else
    {
      // Since we don't want to replace, lets exit
      return TRUE;
    }
  }

  if ( !strNewApplication.Copy( szApplication ) ||
       !strNewApplication.Append( _T(";") ) ||
       !strNewApplication.Append( szDependencies ) ||
       !m_mstrDependencies.Add( strNewApplication.QueryStr() )
     )
  {
    // Failed to construct name, and add it
    return FALSE;
  }

  return TRUE;
}

// AddDefaults
//
// Add the defaults to the list
//
BOOL
CApplicationDependencies::AddDefaults()
{
  DWORD dwCurrent;
  TSTR  strApplicationName;

  for ( dwCurrent = 0;
        dwCurrent < EXTENSION_ENDOFLIST;
        dwCurrent ++)
  {
    if ( !strApplicationName.LoadString( g_OurExtensions[dwCurrent].dwProductName ) )
    {
      // Failed to add application
      return FALSE;
    }

    if ( !AddApplication( strApplicationName.QueryStr(),
                          g_OurExtensions[dwCurrent].szNotLocalizedGroupName,
                          FALSE ) )
    {
      // Failed to add defaults
      return FALSE;
    }
  }

  return TRUE;
}

// Constructor
//
CRestrictionList::CRestrictionList()
{
  m_bMetabaseOpened = FALSE;
}

// InitMetabase
//
// Open the metabase, at the correct location for the Restriction List,
// so that we can read and write to it
//
BOOL
CRestrictionList::InitMetabase()
{
  if ( m_bMetabaseOpened )
  {
    return TRUE;
  }

  m_bMetabaseOpened = SUCCEEDED( m_Metabase.OpenNode( METABASEPATH_WWW_ROOT, TRUE ) );

  return m_bMetabaseOpened;
}

// LoadMSZFromPhysicalMetabase
//
// Load a multisz from the physical metabase at /lm/w3svc node
//
BOOL
CRestrictionList::LoadMSZFromPhysicalMetabase( TSTR_MSZ *pmszProperty, 
                                               LPCTSTR szPropertyName )
{
  TSTR_PATH strMbPath;
  CXMLEdit  XMLFile;
  TSTR      strTemp;

  if ( !strMbPath.RetrieveSystemDir() ||
       !strMbPath.PathAppend( CXMLBASE_METABASEPATH ) )
  {
    // Could not construct path, fail
    return FALSE;  
  }
  
  if ( !XMLFile.Open( strMbPath.QueryStr(), FALSE ) )
  {
    // Could not open file, this might be okay, since
    // it might be a IIS 6.0 upgrade before XML was used
    return TRUE;
  }

  while ( XMLFile.MovetoNextItem() )
  {
    // Find the IISWeb service node with Location=/LM/W3SVC
    if ( XMLFile.IsEqualItem( METABASE_PHYS_RESTR_UPG_NODETYPE ) &&
         XMLFile.MovetoFirstProperty() &&
         XMLFile.IsEqualProperty( METABASE_PHYS_RESTR_UPG_PROPTYPE ) &&
         XMLFile.IsEqualValue( METABASE_PHYS_RESTR_UPG_PROPVALUE ) )
    {
      // We found it, now lets get the read property
      XMLFile.MovetoFirstProperty();

      do
      {
        if ( XMLFile.IsEqualProperty( szPropertyName ) )
        {
          // We found the right property, now lets get the value
          if ( !XMLFile.RetrieveCurrentValue( &strTemp ) )
          {
            return FALSE;
          }

          return LoadMSZFromMultiLineSz( pmszProperty, (LPTSTR) strTemp.QueryStr() );
        }
      } while ( XMLFile.MovetoNextProperty() );

      // We found the right node, but it did not exist, that is okay, we will just
      // ignore it
      return TRUE;
    }
  }

  XMLFile.Close();

  return TRUE;
}

// LoadMSZFromMultiLineSz
//
// Load a MultiSZ from a Multi Line String with either \r\n or \r
// seperating them
//
BOOL
CRestrictionList::LoadMSZFromMultiLineSz( TSTR_MSZ *pmszProperty, LPTSTR szSource )
{
  LPTSTR szCurrent = szSource;
  LPTSTR szTemp;
  TCHAR  cTempChar;

  while ( *szCurrent != '\0' )
  {
    // Skip Spaces at begining
    while ( ( *szCurrent == ' ' ) ||
            ( *szCurrent == '\t' ) )
    {
      szCurrent++;
    }

    szTemp = szCurrent;

    while ( ( *szTemp != '\0' ) &&
            ( *szTemp != '\r' ) &&
            ( *szTemp != '\n' ) )
    {
      szTemp++;
    }

    // Temprorarily NULL Terminate
    cTempChar = *szTemp;
    *szTemp = '\0';

    if ( !pmszProperty->Add( szCurrent ) )
    {
      // Failed to construct list
      return FALSE;
    }

    *szTemp = cTempChar;
    if ( ( *szTemp == '\r' ) &&
         ( *(szTemp+1) == '\n' ) )
    {
      // Move past \n
      szTemp++;
    }

    if ( *szTemp != '\0' )
    {
      // Increment one char, to get to next line
      szTemp++;
    }

    // Start at new line
    szCurrent = szTemp;
  }

  return TRUE;
}

// LoadMSZFromMetabase
//
// Load a multisz from the metabase
//
// Parameters:
//   [out] pmszProperty - The Property that is being extracted
//   [in]  dwPropertyID - The ID of the property to be retrieved
//   [in]  szMBPath     - The sub path to look in
//
// Return Values:
//   FALSE - Failed to retrieve
//   TRUE - Retrieved successfully, or it did not exist and we are returning
//          an empty list
//
BOOL
CRestrictionList::LoadMSZFromMetabase( TSTR_MSZ *pmszProperty, DWORD dwPropertyID, LPWSTR szMBPath )
{
  CMDValue mbValue;
  BOOL     bRet = TRUE;

  if ( !InitMetabase() )
  {
    return FALSE;
  }

  if ( !m_Metabase.GetData( mbValue, dwPropertyID, szMBPath ) )
  {
    pmszProperty->Empty();
  }
  else
  {
    if ( ( mbValue.GetDataType() != MULTISZ_METADATA ) ||
         !pmszProperty->Copy( (LPWSTR) mbValue.GetData() )
       )
    {
      // Either wrong type, or the copy failed
      bRet = FALSE;
    }
  }

  return bRet;
}

// LoadCurrentSettings
//
// Load the current Restriction List Properties.
//
// Note: This loads them from the new location, not the old
//       ISAPIRestrictionLiad and CGIRestrictionList locations.
//       There is a seperate function to merge those in.
//
BOOL
CRestrictionList::LoadCurrentSettings()
{
  return LoadMSZFromMetabase( &m_mstrRestrictionList,
                              MD_WEB_SVC_EXT_RESTRICTION_LIST );

}

// LoadOldFormatSettings
//
// Load the old CGIRestrictionList and ISAPIRestrictionList and import
// them into our new variable
//
BOOL
CRestrictionList::LoadOldFormatSettings( TSTR_MSZ *pmstrCgiRestList, TSTR_MSZ *pmstrIsapiRestList )
{
  // Load old metabase values
  if ( !LoadMSZFromPhysicalMetabase( pmstrCgiRestList,
                                     METABASE_PHYS_RESTR_CGI ) ||
       !LoadMSZFromPhysicalMetabase( pmstrIsapiRestList,
                                     METABASE_PHYS_RESTR_ISAPI ) )
  {
    // Could not load errors
    return FALSE;
  }

  return TRUE;
}

// ImportOldLists
//
// Import the Old Restriction Lists into the new list
// This is only needed for IIS6->IIS6 upgrades, where
// the old settings were in the CGI/ISAPIRestrictionList
BOOL
CRestrictionList::ImportOldLists( TSTR_MSZ &mstrCgiRestList, TSTR_MSZ &mstrIsapiRestList )
{
  // Import old values into new list
  if ( !ImportOldList( mstrCgiRestList,
                       TRUE ) ||
       !ImportOldList( mstrIsapiRestList,
                       FALSE )
     )
  {
    // Could not import new values
    return FALSE;
  }

  return TRUE;
}

// SaveSettings
//
// Save the settings to the metabase
//
BOOL
CRestrictionList::SaveSettings()
{
  CMDValue  mbValue;

  if ( !InitMetabase() )
  {
    return FALSE;
  }

  if ( !mbValue.SetValue( MD_WEB_SVC_EXT_RESTRICTION_LIST,    // Metabase property
                        0,                                    // Attributes
                        IIS_MD_UT_SERVER,                     // User Type
                        MULTISZ_METADATA,                     // Data Type
                        m_mstrRestrictionList.QueryLen() * sizeof(TCHAR), // Length
                        (LPVOID) m_mstrRestrictionList.QueryMultiSz() ) ) // Data
  {
    return FALSE;
  }

  return m_Metabase.SetData( mbValue, MD_WEB_SVC_EXT_RESTRICTION_LIST );
}

// AddItem
//
// Add an Item to the list
//
// Parameters:
//   szInfo [in] - The line containing all the info for the path
//      Format:  ExtensionFile=access,path,<UI deleteable>,
//                             <short description>,<long description>
//      ie: 1,%windir%\system32\testisapi.dll,TRUE,Test Isapi,My Test Isapi for Foo.com
//   bReplaceExistiing - Should we replace existing
//
BOOL
CRestrictionList::AddItem( LPTSTR szInfo, BOOL bReplaceExisting)
{
  TSTR    strCopy( MAX_PATH );
  LPTSTR  pPhysicalPath = NULL;
  LPTSTR  pShortDescription = NULL;
  LPTSTR  pLongDescription = NULL;
  LPTSTR  pCurrent;
  BOOL    bAllow = FALSE;
  BOOL    bUIDeletable = TRUE;      // Different default for Unattend

  if ( !strCopy.Copy( szInfo ) )
  {
    // Could not copy line
    return FALSE;
  }

  pCurrent = strCopy.QueryStr();

  // Set access
  bAllow = ( *( pCurrent ) == _T('1') ) &&
           ( *( pCurrent + 1 ) == _T(',') );
  pCurrent = _tcschr( pCurrent, _T(',') );

  if ( !pCurrent )
  {
    // Without even a path, there is nothing we can do
    return FALSE;
  }

  // Set Physcial Path
  pCurrent++;                             // Move past ','
  pPhysicalPath = pCurrent;

  // Find UI deletable
  pCurrent = _tcschr( pCurrent, _T(',') );

  if ( pCurrent )
  {
    // Found UI Deletable
    // Null terminate path
    *(pCurrent++) = _T('\0');
    bUIDeletable = ( *( pCurrent ) == _T('1') ) &&
                   ( *( pCurrent + 1 ) == _T(',') );

    // Jump to next field
    pCurrent = _tcschr( pCurrent, _T(',') );
  }

  if ( pCurrent )
  {
    // Found Short Description
    pCurrent++;
    pShortDescription = pCurrent;

    // Jump to next field
    pCurrent = _tcschr( pCurrent, _T(',') );
  }

  if ( pCurrent )
  {
    // Found Long Description
    // Null terminal Short Description
    *(pCurrent++) = _T('\0');
    pLongDescription = pCurrent;
  }

  return AddItem( pPhysicalPath,
                  pShortDescription,
                  pLongDescription,
                  bAllow,
                  bUIDeletable,
                  bReplaceExisting );
}

// RetrieveDefaultsifKnow
//
// Retrieve defaults for the physical image if they are known
//
BOOL
CRestrictionList::RetrieveDefaultsifKnow( LPTSTR szPhysicalPath,
                                          LPTSTR *pszGroupId,
                                          TSTR   *pstrDescription,
                                          LPBOOL pbDeleteable )
{
  DWORD     dwIndex;
  TSTR_PATH strFullPath( MAX_PATH );

  ASSERT( szPhysicalPath );
  ASSERT( pszGroupId );
  ASSERT( pstrDescription );
  ASSERT( pbDeleteable );

  for ( dwIndex = 0;
        dwIndex < EXTENSION_ENDOFLIST;
        dwIndex++ )
  {
    if ( !strFullPath.Copy( g_pTheApp->m_csPathInetsrv.GetBuffer(0) ) ||
         !strFullPath.PathAppend( g_OurExtensions[dwIndex].szFileName ) )
    {
      // Failed to create full path, so skip to next one
      continue;
    }

    if ( strFullPath.IsEqual( szPhysicalPath, FALSE ) )
    {
      *pszGroupId = g_OurExtensions[dwIndex].szNotLocalizedGroupName;
      *pbDeleteable = g_OurExtensions[dwIndex].bUIDeletable;

      if ( !pstrDescription->LoadString( g_OurExtensions[dwIndex].dwProductName ) )
      {
        return FALSE;
      }

      // Done seaching
      return TRUE;
    }

  } // for ( dwIndex = ...

  // Return TRUE because we didn't fail
  return TRUE;
} // RetrieveDefaultsifKnow

// AddItem
//
// Add an item to the list.
//
// Parameters:
//   szPhysicalPath - The path of the executable
//   szGroupId      - The group name
//   szDescription  - The description for the executable
//   bAllow         - TRUE==allow, FALSE==deny
//   bDeleteable    - TRUE==UI deletable, FALSE==not UI deletable
//   bReplaceExisting - If it is already in the list, do we update it?
//
BOOL
CRestrictionList::AddItem(  LPTSTR szPhysicalPath,
                            LPTSTR szGroupId,
                            LPTSTR szDescription,
                            BOOL   bAllow,
                            BOOL   bDeleteable,
                            BOOL   bReplaceExisting)
{
  LPTSTR    szCurrentItem;
  LPTSTR    szCurentPath;
  DWORD     dwCurrentIndex = 0;
  TSTR      strNewItem;
  TSTR_PATH strPhysicalPath;
  TSTR      strDescription;

  ASSERT( szPhysicalPath );

  if ( !strPhysicalPath.Copy( szPhysicalPath ) ||
       !strPhysicalPath.ExpandEnvironmentVariables() )
  {
    return FALSE;
  }

  if ( szDescription &&
       !strDescription.Copy( szDescription) )
  {
    // Failed to do copy
    return FALSE;
  }

  // Fill in the Default valus if this is one of our isapi's
  if ( !RetrieveDefaultsifKnow( szPhysicalPath, &szGroupId, &strDescription, &bDeleteable ) )
  {
    return FALSE;
  }

  while ( ( szCurrentItem =
            m_mstrRestrictionList.QueryString( dwCurrentIndex++ ) ) != NULL )
  {
    szCurentPath = _tcschr( szCurrentItem, L',' );

    if ( szCurentPath == NULL )
    {
      continue;
    }

    szCurentPath++;

    if ( ( _tcsnicmp( szCurentPath,
                      strPhysicalPath.QueryStr(),
                      strPhysicalPath.QueryLen() ) == 0 ) &&
         ( ( *( szCurentPath + strPhysicalPath.QueryLen() ) == ',' ) ||
           ( *( szCurentPath + strPhysicalPath.QueryLen() ) == '\0' ) )
       )
    {
      if ( bReplaceExisting )
      {
        if ( !m_mstrRestrictionList.Remove( szCurrentItem, TRUE ) )
        {
          // Failed to remove item
          return FALSE;
        }
      }
      else
      {
        // It succeeded, because we didn't want to replace existing
        return TRUE;
      }

      break;
    }
  } // while ( ... )

  // Copy <allow/deny>,<physical path>,<ui deletable>
  if ( !strNewItem.Copy( bAllow ? _T("1") : _T("0") ) ||
       !strNewItem.Append( _T(",") ) ||
       !strNewItem.Append( strPhysicalPath.QueryStr() ) )
  {
    return FALSE;
  }

  // Append Group
  if ( ( szGroupId || ( strDescription.QueryLen() != 0 ) ) &&
       ( !strNewItem.Append( _T(",") ) ||
         !strNewItem.Append( bDeleteable ? _T("1") : _T("0") ) ||
         !strNewItem.Append( _T(",") ) ||
         !strNewItem.Append( szGroupId ? szGroupId : _T("") )
       )
     )
  {
    return FALSE;
  }

  // Append Description
  if ( ( strDescription.QueryLen() != 0 ) &&
       ( !strNewItem.Append( _T(",") ) ||
         !strNewItem.Append( strDescription.QueryStr() )
       )
     )
  {
    return FALSE;
  }

  // Add it to the list
  return m_mstrRestrictionList.Add( strNewItem.QueryStr() );
}

// ImportOldList
//
// Import settings from the old format to the new format
//
// Old Format:
//  AllowDenyFlagforAll    - Inidcates if default is to allow or deny
//  ExtensionPhysicalPath  - Exe to do opposite of default
//  ExtensionPhysicalPath  - Exe to do opposite of default
//
// New Format:
//  AllowDenyFlag,*.dll
//  AllowDenyFlag,*.exe
//  AllowDenyFlag,ExtensionPhysicalPath,UIDeletableFlag,GroupID,Description
//
//  AllowDenyFlag - 0 or 1 depending on allowed (1) or not allowed (0)
//  ExtensionPhysicalPath - Physical Path to dll
//  UIDeletableFlag - 0 for not ui deletable, 1 for UI deletable
//  GroupID - Id of the group
//  Descrition - Locallized Description
//
BOOL
CRestrictionList::ImportOldList( TSTR_MSZ &mstrOldStyleRestrictionList,
                                 BOOL     bCgiList)
{
  LPTSTR szCurrentItem;
  DWORD  dwIndex = 1;
  BOOL   bDefaultAllow = TRUE;
  LPTSTR szDefault;

  // Take the first string as the default
  szDefault = mstrOldStyleRestrictionList.QueryString( 0 );
  bDefaultAllow = szDefault ? ( *szDefault == '1' ? TRUE : FALSE ) : FALSE;

  if ( *szDefault == '\0' )
  {
    // There is nothing to import since the list is empty,
    // so lets quit
    return TRUE;
  }

  if ( !AddItem( bCgiList ? _T("*.exe") : _T("*.dll"),
                 NULL, NULL, bDefaultAllow, FALSE, FALSE ) )
  {
    // Could not set default for Restriction List
    return FALSE;
  }

  // Start importing starting at item[1]
  while ( ( szCurrentItem =
            mstrOldStyleRestrictionList.QueryString( dwIndex++ ) ) != NULL )
  {
    if ( *szCurrentItem == _T('\0') )
    {
      // Empty line
      continue;
    }

    if ( !AddItem( szCurrentItem,     // Path
                   NULL,              // Group
                   NULL,              // Description
                   !bDefaultAllow,    // bAllow
                   TRUE,
                   FALSE ) )
    {
      // Failed to add item
      return FALSE;
    }
  }

  if ( !bCgiList )
  {
    // Since we have imported all the ones we can.  We should now add all IIS's
    // defaults, or they will be added later with the wrong default
    // BUGBUG:: Right now this assumes the defaults are all ISAPI's, which they
    // are for now
    if ( !AddDefaults( bDefaultAllow ) )
    {
      return FALSE;
    }
  }

  return TRUE;
}

// AddDefaults
//
// Add the defaults to the restriction list
// If we fail, then try to add as many as possible
//
// Parameters
//   bAllOthersDefault - Should *.dll and *.exe be allowed or
//                       denied by default?
//
BOOL
CRestrictionList::AddDefaults( BOOL bAllOthersDefault )
{
  DWORD     dwIndex;
  BOOL      bRet = TRUE;
  TSTR_PATH strFullPath;

  if ( !AddItem( _T("*.dll"), NULL, NULL, bAllOthersDefault,
                 FALSE, FALSE ) ||
       !AddItem( _T("*.exe"), NULL, NULL, bAllOthersDefault,
                 FALSE, FALSE ) )
  {
    // Failed to add dll and exe defaults
    bRet = FALSE;
  }

  for ( dwIndex = 0;
        dwIndex < EXTENSION_ENDOFLIST;
        dwIndex++ )
  {
    if ( !strFullPath.Copy( g_pTheApp->m_csPathInetsrv.GetBuffer(0) ) ||
         !strFullPath.PathAppend( g_OurExtensions[dwIndex].szFileName ) )
    {
      // Failed to create full path, so skip to next one
      bRet = FALSE;
      continue;
    }

    // The Group and Description are sent in as NULL, because they will
    // be filled in automatically by AddItem
    if ( !AddItem( strFullPath.QueryStr(),  // Physical Path
                   NULL,      // Group Name
                   NULL,      // Description
                   bAllOthersDefault,     // Allowed/Denied
                   FALSE,     // Not UI Deletable
                   FALSE ) )  // Do not replace existing
    {
      bRet = FALSE;
    }
  }

  return bRet;
}

// IsEmpty
//
// Is the restrictionList Empty?
//
BOOL
CRestrictionList::IsEmpty()
{
  return m_mstrRestrictionList.QueryLen() == 1;
}

// AddUnattendSettings
//
// Read the unattend settings from the file, and
// put them in the list
//
// It expects the lines in the unattend to be in the form
// [InternetServer]
// ExtensionFile=0,*.dll
// ExtensionFile=1,*.exe
// ExtensionFile=1,%windir%\system32\testisapi.dll,0,Test Isapi,My Test Isapi for Foo.com
//
// And will product in the m_mstrDependencies:
// 0,*.dll\0
// 1,*,exe\0
// d:\whistler\system32\testisapi.dll,TRUE,Test Isapi,My Test Isapi for Foo.com\0
// \0
//
// Return:
//   TRUE - Successfully imported all settings
//   FAILED - Failed to import settings
//
BOOL
CRestrictionList::AddUnattendSettings()
{
  BOOL        bContinue;
  INFCONTEXT  Context;
  TSTR        strLine;
  DWORD       dwRequiredSize;

  if ( g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE )
  {
    // Since there is no unattend file, return success
    return TRUE;
  }

  bContinue = SetupFindFirstLine( g_pTheApp->m_hUnattendFile,
                                  UNATTEND_FILE_SECTION,
                                  UNATTEND_INETSERVER_EXTENSIONRESTRICTIONLIST,
                                  &Context);

  while ( bContinue )
  {
    if ( !SetupGetLineText( &Context, INVALID_HANDLE_VALUE, NULL, NULL,
                            strLine.QueryStr(), strLine.QuerySize(), &dwRequiredSize) )
    {
      // Need to resize for larger buffer
      if ( ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ||
           ( dwRequiredSize <= strLine.QuerySize() ) ||
           !strLine.Resize( dwRequiredSize ) ||
           !SetupGetLineText( &Context, INVALID_HANDLE_VALUE, NULL, NULL,
                              strLine.QueryStr(), strLine.QuerySize(), &dwRequiredSize) )
      {
        // Failure to either resize, or read in data
        return FALSE;
      }
    }

    if ( !AddItem( strLine.QueryStr(), TRUE ) )
    {
      // Failed to add item
      return FALSE;
    }

    bContinue = SetupFindNextMatchLine( &Context,
                                        UNATTEND_INETSERVER_EXTENSIONRESTRICTIONLIST,
                                        &Context);
  }

  return TRUE;
}

// UpdateItem
//
// Update an Item with the right value
//
BOOL
CRestrictionList::UpdateItem( LPTSTR szPhysicalPath,
                              LPTSTR szGroupId,
                              LPTSTR szDescription,
                              BOOL   bAllow,
                              BOOL   bDeleteable )
{
  return AddItem( szPhysicalPath, szGroupId, szDescription,
                  bAllow, bDeleteable, TRUE );
}

// FindItemByGroup
//
// Find an Item by the Group ID
//
LPTSTR
CRestrictionList::FindItemByGroup( LPTSTR szGroupId )
{
  LPTSTR    szCurrent;
  LPTSTR    szCurrentItem;
  DWORD     dwLength;
  DWORD     dwCurrentIndex = 0;

  dwLength = _tcslen( szGroupId );

  while ( ( szCurrentItem =
            m_mstrRestrictionList.QueryString( dwCurrentIndex++ ) ) != NULL )
  {
    // Get Physical Path
    szCurrent = _tcschr( szCurrentItem, L',' );

    if ( szCurrent )
    {
      // Get UI Deletable
      szCurrent++;
      szCurrent = _tcschr( szCurrent, L',' );
    }

    if ( szCurrent )
    {
      // Get Group ID
      szCurrent++;
      szCurrent = _tcschr( szCurrent, L',' );
    }

    if ( szCurrent )
    {
      // Since we found the group id, lets compare
      szCurrent++;
      if ( ( _tcsnicmp( szGroupId,
                        szCurrent,
                        dwLength ) == 0 ) &&
           ( ( *( szCurrent + dwLength ) == ',' ) ||
             ( *( szCurrent + dwLength ) == '\0' ) )
          )
      {
        // Found a match, return the item
        return szCurrentItem;
      }
    }
  } // while ( ... )

  // Could not find
  return NULL;
}

// Find an item
LPTSTR
CRestrictionList::FindItemByPhysicalPath( LPTSTR szPhysicalPath )
{
  LPTSTR    szCurrent;
  LPTSTR    szCurrentItem;
  DWORD     dwLength;
  DWORD     dwCurrentIndex = 0;

  dwLength = _tcslen( szPhysicalPath );

  while ( ( szCurrentItem =
            m_mstrRestrictionList.QueryString( dwCurrentIndex++ ) ) != NULL )
  {
    // Get Physical Path
    szCurrent = _tcschr( szCurrentItem, L',' );

    if ( szCurrent )
    {
      // Since we found the group id, lets compare
      szCurrent++;
      if ( ( _tcsnicmp( szPhysicalPath,
                        szCurrent,
                        dwLength ) == 0 ) &&
           ( ( *( szCurrent + dwLength ) == ',' ) ||
             ( *( szCurrent + dwLength ) == '\0' ) )
          )
      {
        // Found a match, return the item
        return szCurrentItem;
      }
    }
  } // while ( ... )

  // Could not find
  return NULL;
}

// IsEnabled
//
// Check to see if the particular item is enabled
// Note: Only works for dll's right now
//
// Return Values:
//   TRUE  - It is enabled
//   FALSE - Not enabled ( default if could not determine )
//
// Note: Since Core defaults to denied, we init bEnabled to FALSE
//
BOOL
CRestrictionList::IsEnabled( LPTSTR szGroupId, LPBOOL pbIsEnabled )
{
  BOOL    bEnabled = FALSE;
  LPTSTR  szItem = FindItemByGroup( szGroupId );

  if ( szItem )
  {
    // See if that item is enabled
    bEnabled = ( *szItem == _T('1') );
  }
  else
  {
    // Since this item was not found, lets take the default
    szItem = FindItemByPhysicalPath( _T("*.dll") );

    if ( szItem )
    {
      bEnabled = ( *szItem == _T('1') );
    }
  }

  *pbIsEnabled = bEnabled;

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\setpass.h ===
#include "stdafx.h"

#ifndef _CHICAGO_
	BOOL GetSecret(IN LPCTSTR pszSecretName,OUT TSTR *strSecret);
	BOOL GetAnonymousSecret(IN LPCTSTR pszSecretName,OUT TSTR *pstrPassword);
	BOOL GetRootSecret(IN LPCTSTR pszRoot,IN LPCTSTR pszSecretName,OUT LPTSTR pszPassword);
	DWORD SetSecret(IN LPCTSTR pszKeyName,IN LPCTSTR pszPassword);
#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\sakit.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        sakit.cxx

   Abstract:

        Class that is used as a wrapper to install and uninstall the 
        Server Administration Tool Kit.

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       August 2001: Created

--*/

#include "stdafx.h"
#define _WIN32_DCOM
#include <windows.h>
#include <objbase.h>
#include <ole2.h>
#include "sakit.hxx"
#include "tchar.h"

// Define the GUIDs used by the Server Appliance Kit COM object

#include <initguid.h>
DEFINE_GUID(CLSID_SaInstall,0x142B8185,0x53AE,0x45B3,0x88,0x8F,0xC9,0x83,0x5B,0x15,0x6C,0xA9);

// Constructor
//
SAKit::SAKit()
  : m_bCoInit(FALSE),
    m_pcSaKit(NULL)
{

}

// Destructor
//
SAKit::~SAKit()
{
  if ( m_pcSaKit )
  {
    // Release the SAKit Object if we still have it
    m_pcSaKit->Release();
  }

  // Uninitialize COM
  DoCoUnInit();
}

// function: DoCoInit
//
// Initialize COM for us
//
// Return Values:
//   TRUE - It is initialized
//   FALSE - It failed to initialize
BOOL
SAKit::DoCoInit()
{
  HRESULT hRes;

  if (m_bCoInit)
  {
    // We have already done this
    return TRUE;
  }

  hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

  // track our calls to coinit
  if ( hRes == S_OK )
  {
      m_bCoInit = TRUE;
  }

  if ( ( hRes == S_FALSE ) || ( hRes == RPC_E_CHANGED_MODE ) )
  {
    return TRUE;
  }

  return SUCCEEDED( hRes );
}

// function: QI
//
// Qi the object, and get it put into m_pcSaKit
BOOL 
SAKit::QI()
{
  HRESULT     hRes;
  ISaInstall  *ppv;

  if ( !DoCoInit() )
  {
    // If we can not CoInit we have no hope
    return FALSE;
  }

  hRes = CoCreateInstance(  CLSID_SaInstall,        // ClassID of SAInstall
                            NULL,                   // No pUnkOuter
                            CLSCTX_INPROC_SERVER,   // No remote server
                            __uuidof(ISaInstall),   // uuid of SAInstall
                            (LPVOID *) &ppv);
  
  if ( SUCCEEDED(hRes) )
  {
    m_pcSaKit = ppv;
    return TRUE; 
  }

  iisDebugOut((LOG_TYPE_TRACE, _T("SAKit::Could not QI the Server Appliance Kit, Error=0x%x\n"),hRes));
  return FALSE;
}

// function: DoCoUnInit()
// 
// Uninit Com
//
void
SAKit::DoCoUnInit()
{
  if (m_bCoInit)
  {
    CoUninitialize( );
    m_bCoInit = FALSE;
  }
}

// function: GetDiskName
//
// Get the name of the disk from the inf file.  This is so that the 
// SAKit knows which Disk to ask for
//
// Parameters:
//   [out] bstrDiskName - The name of the returning disk.
BOOL 
SAKit::GetDiskName(BSTR &bstrDiskName)
{
  TSTR        strDiskName;
  DWORD       dwRequiredSize = 0;

  if ( ( g_pTheApp->m_hInfHandle != INVALID_HANDLE_VALUE ) &&
       SetupGetLineText( NULL, 
                         g_pTheApp->m_hInfHandle, 
                         SECTIONNAME_STRINGS, 
                         SECTION_STRINGS_CDNAME, 
                         NULL, 
                         0, 
                         &dwRequiredSize) &&
       ( dwRequiredSize != 0 )
     )
  {
    if ( strDiskName.Resize( dwRequiredSize + 1 ) &&
         ( SetupGetLineText( NULL, 
                             g_pTheApp->m_hInfHandle, 
                             SECTIONNAME_STRINGS, 
                             SECTION_STRINGS_CDNAME, 
                             strDiskName.QueryStr(), 
                             strDiskName.QuerySize(), 
                             NULL) )
       )
      {
        bstrDiskName = SysAllocString( strDiskName.QueryStr() );

        if (bstrDiskName)
        {
          return TRUE;
        }
      }
    }

  iisDebugOut((LOG_TYPE_ERROR, _T("SAKit::GetDiskName: Can not retrieve the DiskName from the inf\n")));
  return FALSE;
}

// function: IsInstalled
//
// Determine if the component is already installed
BOOL
SAKit::IsInstalled(SA_TYPE sType)
{
  VARIANT_BOOL    IsInstalled = VARIANT_FALSE;
  HRESULT         hRes;

  if ( !QI() )
  {
    // If we can not QI then fail
    return FALSE;
  }

  hRes = m_pcSaKit->SAAlreadyInstalled( sType, &IsInstalled );

  if ( SUCCEEDED(hRes) )
  {
    return IsInstalled == VARIANT_TRUE;
  }

  return FALSE;
}

// function: InstallKit
//
// Install the Kit
//
// Parameters:
//   sType = The type of Kit to Install
BOOL 
SAKit::InstallKit(SA_TYPE sType)
{
  VARIANT_BOOL  bDisplayError = VARIANT_FALSE;
  VARIANT_BOOL  bUnattend = g_pTheApp->m_fUnattended ? VARIANT_TRUE : VARIANT_FALSE;
  BSTR          ErrorMessage = NULL;
  BSTR          DiskName = NULL;
  HRESULT       hRes;

  if ( g_pTheApp->m_fNTGuiMode )
  {
    // We are not resposible, and should not install the kit in
    // gui mode.  They are responsible for that.
    return FALSE;
  }

  if ( !QI() ||
       !GetDiskName(DiskName) )
  {
    // If we can not QI then fail
    iisDebugOut((LOG_TYPE_ERROR, _T("SAKit::InstallKit: Failed to install the Server Appliance\n")));
    return FALSE;
  }

  hRes = m_pcSaKit->SAInstall(sType,          // Install Type
                              DiskName,       // Disk Name
                              bDisplayError,  // Display Error?
                              bUnattend,      // Unattended?
                              &ErrorMessage); // Error Message

  // Free the DiskName
  SysFreeString(DiskName);

  if ( FAILED(hRes) )
  {
    // Failed to install
    iisDebugOut((LOG_TYPE_ERROR, _T("SAKit::InstallKit: Failed to install the Server Appliance, Return Err=0x%x  Error Message='%s'\n"), hRes, ErrorMessage));
    SysFreeString(ErrorMessage);
    return FALSE;
  }

  SysFreeString(ErrorMessage);
  return TRUE;
}

// function: UninstallKit
//
// UnInstall the Kit
BOOL
SAKit::UninstallKit(SA_TYPE sType)
{
  BSTR          ErrorMessage = NULL;
  HRESULT       hRes;
  BOOL          bRet = TRUE;

  if ( g_pTheApp->m_fNTGuiMode )
  {
    // We are not resposible, and should not uninstall the kit in
    // gui mode.  They are responsible for that.
    return FALSE;
  }

  if ( !QI() )
  {
    // If we can not QI then fail
    iisDebugOut((LOG_TYPE_ERROR, _T("SAKit::InstallKit: Failed to uninstall the Server Appliance\n")));
    return FALSE;
  }

  hRes = m_pcSaKit->SAUninstall(sType,          // Install Type
                                &ErrorMessage); // Error Message

  if ( FAILED(hRes) )
  {
    // Failed to install
    iisDebugOut((LOG_TYPE_ERROR, _T("SAKit::UninstallKit: Failed to uninstall the Server Appliance, Return Err=0x%x  Error Message='%s'\n"), hRes, ErrorMessage));
    bRet = FALSE;
  }

  SysFreeString(ErrorMessage);
  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by setup.rc
//
#define IDWRITEUNENCRYPTEDALL           3
#define IDS_CANNOT_GET_MACHINE_NAME     13
#define IDS_OS_NOT_SUPPORT              14
#define IDS_CANNOT_DETECT_OS_TYPE       15
#define IDS_IIS_ALL_INSTALL             16
#define IDS_IIS_ALL_UPGRADE             17
#define IDS_IIS                         18
#define IDS_IIS_ALL_CONFIGURE           18
#define IDS_SETUP                       19
#define IDS_IIS_ALL_REMOVE              19
#define IDS_OS_VERSION_NOT_SUPPORTED    20
#define IDS_GUEST_NAME                  21
#define IDS_IIS_ALL_COMPLETE            22
#define IDS_IIS_ERROR_MSGBOXTITLE       23
#define IDS_USER_COMMENT                24
#define IDS_USER_FULLNAME               25
#define IDS_IIS_ALL_FILEOPS             26
#define IDS_REMOVE_GOPHER               34
#define IDS_EULA_DECLINED               38
#define IDS_SELECT_DIR                  40
#define IDS_NOT_ADMINISTRATOR           41
#define IDS_NT5_NEEDED                  44
#define IDS_NEED_INPUT_FTP              47
#define IDS_NEED_INPUT_WWW              48
#define IDS_ADMIN_SERVER_COMMENT        52
#define IDS_FRESH_MINIMUM_STRING        65
#define IDS_FRESH_TYPICAL_STRING        67
#define IDS_FRESH_CUSTOM_STRING         69
#define IDS_REMOVEALL_WARNING           72
#define IDS_INCORRECT_PLATFORM          73
#define IDS_NEED_PLATFORM_NTW           75
#define IDS_CANNOT_OPEN_SRC_FILE        77
#define IDS_CANNOT_OPEN_DEST_FILE       78
#define IDS_CANNOT_COPY_FILE            79
#define IDS_SERVICE_IN_DELETE_STATE     82
#define IDS_NEED_VALID_PATH_UNATTENDED  83
#define IDS_WAM_ACCOUNT_NAME            88
#define IDS_WAMUSER_COMMENT             92
#define IDS_WAMUSER_FULLNAME            93
#define IDS_UNABLE_TO_STOP_SERVICE      95
#define IDS_INVALID_DIR_INETSRV         96
#define IDS_APP_FRIENDLY_ROOT           97
#define IDS_APP_FRIENDLY_IISADMIN       98
#define IDS_APP_FRIENDLY_WEBPUB         99
#define IDS_APP_FRIENDLY_IISSAMPLES     100
#define IDS_APP_FRIENDLY_IISHELP        101
#define IDS_UNABLE_TO_CREATE_DRIVER     102
#define IDS_BITMAP_MS                   103
#define IDS_BITMAP_TITLE                104
#define IDS_WELCOMES_INTRO              106
#define IDS_WELCOMEW_INTRO              108
#define IDS_WELCOMEW_FEATURE            109
#define IDB_WELCOMES                    110
#define IDS_WELCOMEC_INTRO              110
#define IDB_WELCOMEW                    111
#define IDS_WELCOMEC_FEATURE            111
#define IDB_WELCOMEC                    112
#define IDS_LOCATE_FILE                 112
#define IDB_BANNERS                     113
#define IDS_NEED_TCPIP_WARNING          113
#define IDB_BANNERW                     114
#define IDS_TCPIP_NEEDED_ON_OPTION      114
#define IDB_BANNERC                     115
#define IDS_BAD_SIGNATURE_RELNOTES      115
#define IDB_FTP                         116
#define IDS_DEFAULT_WEB_SITE            116
#define IDB_WWW                         117
#define IDS_DEFAULT_FTP_SITE            117
#define IDB_W3SAMP                      118
#define IDB_HTMLA                       120
#define IDS_BITMAP_MS_TRADEMARK         120
#define IDS_BITMAP_TITLE_TRADEMARK      121
#define IDB_PWS                         122
#define IDS_BITMAP_MS_TRADEMARK_OTHER   122
#define IDS_MTS_NOT_INSTALLED           123
#define IDB_TOPLEVEL_IIS                125
#define IDS_UNATTEND_UNSUPPORTED        125
#define IDB_WWW_VDIR                    126
#define IDD_DIALOG_MSG                  126
#define IDS_OS_BUILD_NUM_REQUIREMENT    128
#define IDS_UNABLE_TO_START             129
#define IDS_ERR_CALLING_DLL_PROCEDURE   130
#define IDD_ENCRYPTED_WRITE_ERROR_DIALOG 130
#define IDS_OLE_INIT_FAILED             131
#define IDS_FILE_DOES_NOT_EXIST         132
#define IDS_UNABLE_TO_LOCATE_PROCEDURE  133
#define IDS_PRODUCT_INDEXSERVICE        134
#define IDS_RETRY                       135
#define IDS_PRODUCT_INETPRINT           136
#define IDS_REGSVR_CAUGHT_EXCEPTION     137
#define IDS_SETDATA_ERROR               138
#define IDS_GETDATA_ERROR               139
#define IDS_CREATE_METABASE_ACLS        141
#define IDS_ADD_METABASE_1              143
#define IDS_CONFIG_USER_1               151
#define IDS_COMPONENT_INSTALL_PHASE     154
#define IDS_CLEANUP_PHASE               156
#define IDS_STOPPING_SERVICES           157
#define IDS_REG_ACCT_TO_LOCAL_GROUP     158
#define IDS_REG_ACCT_USER_RIGHTS        159
#define IDS_GET_DC_NAME                 161
#define IDS_CREATE_USER_ACCT            163
#define IDS_MTS_INCORRECTLY_INSTALLED   166
#define IDS_COMPLETED_FILE_CALL         167
#define IDS_TEMPLATE_PUBLIC_WEB_SITE    169
#define IDS_TEMPLATE_PUBLIC_SECURE_SITE 170
#define IDS_TEMPLATE_PUBLIC_FTP_SITE    171
#define IDS_VERIFY_CUSTOMERRORS         172
#define IDS_MIGRATE_IP_SEC              173
#define IDS_SET_ADMIN_RESTRICTION       174
#define IDS_VERIFY_FILTERS              175
#define IDS_CREATING_BASE_ENTRIES       176
#define IDS_SETUP_ERRORS_ENCOUNTERED_MTS 177
#define IDS_MTS_DOING_CREATEINPROC      178
#define IDS_MTS_ERROR_TITLEBAR          179
#define IDS_ADD_SETTINGS_FOR_WEB_1      180
#define IDS_ADD_SETTINGS_FOR_WEB_2      181
#define IDS_ADD_SETTINGS_FOR_WEB_3      182
#define IDS_ADD_SETTINGS_FOR_FTP_1      183
#define IDS_ADD_SETTINGS_FOR_FTP_2      184
#define IDB_WEBAPPSRV_CONSOLE           186
#define IDS_COMPONENT_INSTALLING        188
#define IDS_COMPONENT_REMOVING          189
#define IDB_ICON_COMPLUS                190
#define IDB_ICON_DTC                    191
#define IDB_ICON_WEB_APP_SERVER         192
#define IDS_COMPLUS_COMPONETNAME        193
#define IDS_DTC_COMPONETNAME            194
#define IDB_ICON_WWW_EXTENSION          195
#define IDS_PRODUCT_ASP                 196
#define IDS_PRODUCT_HTTPODBC            197
#define IDS_PRODUCT_SSINC               198
#define IDS_PRODUCT_WEBDAV              199
#define IDS_DTC_WORLDWIDEWEB            200
#define IDS_ERROR_INSTALLONFAT          201
#define IDS_PRODUCT_IIS                 202
#define IDS_IIS_COMPONENTNAME           203
#define IDS_ERROR_GROUPPOLICY           204
#define IDS_ERROR_SAKITONFAT            205
#define IDS_INITIAL_METABASE_BK_NAME    208
#define IDC_LICENSE_TEXT                1000
#define IDC_EULA_ACCEPT                 1001
#define IDC_EULA_DECLINE                1002
#define IDC_WWW_PUB_GROUP               1005
#define IDC_FTP_PUB_GROUP               1006
#define IDC_WWW_PUB_EDIT                1007
#define IDC_FTP_PUB_EDIT                1008
#define IDC_WWW_PUB_BROWSE              1009
#define IDC_FTP_PUB_BROWSE              1010
#define IDC_ADDREMOVE                   1014
#define IDC_REINSTALL                   1015
#define IDC_REMOVEALL                   1016
#define IDC_MINIMUM                     1017
#define IDC_TYPICAL                     1018
#define IDC_CUSTOM                      1019
#define IDC_UPGRADEONLY                 1020
#define IDC_ADDEXTRACOMPS               1021
#define IDC_FRAME_WELCOME               1022
#define IDC_FRAME_BANNER                1023
#define IDC_REINSTALL_REFRESH_FILES     1024
#define IDC_REINSTALL_REFRESH_SETTINGS  1025
#define IDC_FRESH_MINIMUM_STATIC        1034
#define IDC_FRESH_TYPICAL_STATIC        1035
#define IDC_FRESH_CUSTOM_STATIC         1036
#define IDC_FRAME_WELCOME_MS            1038
#define IDC_FRAME_WELCOME_TITLE         1039
#define IDC_FRAME_WELCOME_INTRO         1040
#define IDC_FRAME_WELCOME_FEATURE       1041
#define IDC_FRAME_BANNER_MS             1042
#define IDC_FRAME_BANNER_TITLE          1043
#define IDS_ADD_SETTINGS_FOR            1044
#define IDC_STATIC_BOTTOMLINE           1044
#define IDC_STATIC_TOPLINE              1045
#define IDWRITEUNENCRYPTED              1046
#define IDC_STATIC3                     1047
#define IDS_DEPENDENT_UPON_THIS_SVC_ERR 1048
#define IDC_STATIC1                     1048
#define IDC_STATIC2                     1049
#define IDS_LOADLIBRARY_FAILED          1052
#define IDS_RUN_PROG_FAILED             1054
#define IDS_BEFORE_CALLING_FILE         1055
#define IDS_SETUP_ERRORS_ENCOUNTERED    1056
#define IDS_TCPIP_ERROR                 1057
#define IDS_HTTPCUSTOM_UTF8             1058
#define IDS_REMOVE_CLUS_W3SVC_FIRST     1059
#define IDS_REMOVE_CLUS_MSFTPSVC_FIRST  1060
#define IDS_FAKE_METABASE_BIN_TEXT      1061

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        210
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1062
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\setuputl.cpp ===
#include "stdafx.h"
#include <setupapi.h>
#include <shlobj.h>
#include <ole2.h>
#include "lzexpand.h"
#include "log.h"
#include "dcomperm.h"
#include "strfn.h"
#include "other.h"
#include <direct.h>
#include <aclapi.h>


typedef struct _QUEUECONTEXT {
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;



//-------------------------------------------------------------------
//  purpose: install an section in an .inf file
//-------------------------------------------------------------------
int InstallInfSection_NoFiles(HINF InfHandle,TCHAR szINFFileName[],TCHAR szSectionName[])
{
    HWND	Window			= NULL;
    BOOL	bReturn			= FALSE;
	BOOL	bReturnTemp			= FALSE; // assume failure.
    TCHAR	ActualSection[1000];
    DWORD	ActualSectionLength;
    BOOL    bPleaseCloseInfHandle = FALSE;

    iisDebugOut_Start1(_T("InstallInfSection_NoFiles"),szSectionName,LOG_TYPE_PROGRAM_FLOW);

__try {

    // Check if a valid infhandle as passed in....
    // if so, use that, otherwise, use the passed in filename...
    if(InfHandle == INVALID_HANDLE_VALUE) 
    {
        // Try to use the filename.
        if (_tcsicmp(szINFFileName, _T("")) == 0)
        {
            goto c1;
        }

        // we have a filename entry. let's try to use it.
	    // Check if the file exists
	    if (!IsFileExist(szINFFileName)) 
		    {
		    //MessageBox(NULL, "unable to find file", "cannot find file", MB_OK);
		    goto c1;
		    }
        
        // Load the inf file and get the handle
        InfHandle = SetupOpenInfFile(szINFFileName, NULL, INF_STYLE_WIN4, NULL);
        bPleaseCloseInfHandle = TRUE;
    }
    if(InfHandle == INVALID_HANDLE_VALUE) {goto c1;}

    //
    // See if there is an nt-specific section
    //
    SetupDiGetActualSectionToInstall(InfHandle,szSectionName,ActualSection,sizeof(ActualSection)/sizeof(TCHAR),&ActualSectionLength,NULL);

    //
    // Perform non-file operations for the section passed on the cmd line.
    //
    bReturn = SetupInstallFromInfSection(Window,InfHandle,ActualSection,SPINST_ALL & ~SPINST_FILES,NULL,NULL,0,NULL,NULL,NULL,NULL);
    if(!bReturn) {goto c1;}

    //
    // Install any services for the section
    //
    bReturn = SetupInstallServicesFromInfSection(InfHandle,ActualSection,0);
    if(!bReturn) 
    {
    iisDebugOut((LOG_TYPE_TRACE, _T("SetupInstallServicesFromInfSection failed.Ret=%d.\n"), GetLastError()));
    }

    //
    // Refresh the desktop.
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

    //
    // If we get to here, then this routine has been successful.
    //
    bReturnTemp = TRUE;

c1:
    //
    // If the bReturnTemp failed and it was because the user cancelled, then we don't want to consider
    // that as an bReturnTemp (i.e., we don't want to give an bReturnTemp popup later).
    //
    if((bReturnTemp != TRUE) && (GetLastError() == ERROR_CANCELLED)) {bReturnTemp = TRUE;}
    if (bPleaseCloseInfHandle == TRUE)
    {
	    if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}
    }

    ;}
__except(EXCEPTION_EXECUTE_HANDLER) 
    {
        if (bPleaseCloseInfHandle == TRUE)
        {
	        if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}
        }
    }

    //
    // If the bReturnTemp failed because the user cancelled, then we don't want to consider
    // that as an bReturnTemp (i.e., we don't want to give an bReturnTemp popup later).
    //
    if((bReturnTemp != TRUE) && (GetLastError() == ERROR_CANCELLED)) {bReturnTemp = TRUE;}

	// Display installation failed message
    //if(bReturnTemp) {MyMessageBox(NULL, _T("IDS_INF_FAILED"), MB_OK);}

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("InstallInfSection_NoFiles.[%s].End.Ret=%d.\n"), szSectionName, bReturnTemp));
    return bReturnTemp;
}



//-------------------------------------------------------------------
//  purpose: install an section in an .inf file
//-------------------------------------------------------------------
int InstallInfSection(HINF InfHandle,TCHAR szINFFileName[],TCHAR szSectionName[])
{
    HWND	Window			= NULL;
    PTSTR	SourcePath		= NULL;
    //HINF	InfHandle		= INVALID_HANDLE_VALUE;
    HSPFILEQ FileQueue		= INVALID_HANDLE_VALUE;
    PQUEUECONTEXT	QueueContext	= NULL;
    BOOL	bReturn			= FALSE;
	BOOL	bReturnTemp			= FALSE; // assume failure.
    TCHAR	ActualSection[1000];
    DWORD	ActualSectionLength;
    BOOL    bPleaseCloseInfHandle = FALSE;

    iisDebugOut_Start1(_T("InstallInfSection"),szSectionName,LOG_TYPE_PROGRAM_FLOW);

__try {

    // Check if a valid infhandle as passed in....
    // if so, use that, otherwise, use the passed in filename...
    if(InfHandle == INVALID_HANDLE_VALUE) 
    {
        // Try to use the filename.
        if (_tcsicmp(szINFFileName, _T("")) == 0)
        {
            goto c1;
        }

        // we have a filename entry. let's try to use it.
	    // Check if the file exists
	    if (!IsFileExist(szINFFileName)) 
		    {
		    //MessageBox(NULL, "unable to find file", "cannot find file", MB_OK);
		    goto c1;
		    }
        
        // Load the inf file and get the handle
        InfHandle = SetupOpenInfFile(szINFFileName, NULL, INF_STYLE_WIN4, NULL);
        bPleaseCloseInfHandle = TRUE;
    }
    if(InfHandle == INVALID_HANDLE_VALUE) {goto c1;}

    //
    // See if there is an nt-specific section
    //
    SetupDiGetActualSectionToInstall(InfHandle,szSectionName,ActualSection,sizeof(ActualSection)/sizeof(TCHAR),&ActualSectionLength,NULL);

    //
    // Create a setup file queue and initialize the default queue callback.
	//
    FileQueue = SetupOpenFileQueue();
    if(FileQueue == INVALID_HANDLE_VALUE) {goto c1;}

    //QueueContext = SetupInitDefaultQueueCallback(Window);
    //if(!QueueContext) {goto c1;}

    QueueContext = (PQUEUECONTEXT) SetupInitDefaultQueueCallbackEx(Window,NULL,0,0,0);
    if(!QueueContext) {goto c1;}
    QueueContext->PendingUiType = IDF_CHECKFIRST;

    //
    // Enqueue file operations for the section passed on the cmd line.
    //
	//SourcePath = NULL;
    // SP_COPY_NOPRUNE = setupapi has a new deal which will prune files from the copyqueue if they already exist on the system.
    //                   however, the problem with the new deal is that the pruning code does not check if you have the same file
    //                   queued in the delete or rename queue.  specify SP_COPY_NOPRUNE to make sure that our file never gets
    //                   pruned (removed) from the copy queue. aaronl 12/4/98
    //bReturn = SetupInstallFilesFromInfSection(InfHandle,NULL,FileQueue,ActualSection,SourcePath,SP_COPY_NEWER | SP_COPY_NOPRUNE);
    bReturn = SetupInstallFilesFromInfSection(InfHandle,NULL,FileQueue,ActualSection,SourcePath, SP_COPY_NOPRUNE);
	if(!bReturn) {goto c1;}

    //
    // Commit file queue.
    //
    if(!SetupCommitFileQueue(Window, FileQueue, SetupDefaultQueueCallback, QueueContext)) {goto c1;}

    //
    // Perform non-file operations for the section passed on the cmd line.
    //
    bReturn = SetupInstallFromInfSection(Window,InfHandle,ActualSection,SPINST_ALL & ~SPINST_FILES,NULL,NULL,0,NULL,NULL,NULL,NULL);
    if(!bReturn) {goto c1;}

	//
    // Refresh the desktop.
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

    //
    // If we get to here, then this routine has been successful.
    //
    bReturnTemp = TRUE;

c1:
    //
    // If the bReturnTemp failed and it was because the user cancelled, then we don't want to consider
    // that as an bReturnTemp (i.e., we don't want to give an bReturnTemp popup later).
    //
    if((bReturnTemp != TRUE) && (GetLastError() == ERROR_CANCELLED)) {bReturnTemp = TRUE;}
	if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);QueueContext = NULL;}
	if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);FileQueue = INVALID_HANDLE_VALUE;}
    if (bPleaseCloseInfHandle == TRUE)
    {
	    if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}
    }

    ;}
__except(EXCEPTION_EXECUTE_HANDLER) 
    {
        if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);}
        if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);}
        if (bPleaseCloseInfHandle == TRUE)
        {
	        if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}
        }
    }

    //
    // If the bReturnTemp failed because the user cancelled, then we don't want to consider
    // that as an bReturnTemp (i.e., we don't want to give an bReturnTemp popup later).
    //
    if((bReturnTemp != TRUE) && (GetLastError() == ERROR_CANCELLED)) {bReturnTemp = TRUE;}

	// Display installation failed message
    //if(bReturnTemp) {MyMessageBox(NULL, _T("IDS_INF_FAILED"), MB_OK);}

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("InstallInfSection.[%s].End.Ret=%d.\n"), szSectionName, bReturnTemp));
    return bReturnTemp;
}


BOOL IsValidDriveType(LPTSTR szRoot)
{
    BOOL fReturn = FALSE;
    int i;

    i = GetDriveType(szRoot);

    if (i == DRIVE_FIXED) {fReturn = TRUE;}

    if (i == DRIVE_REMOVABLE)
    {
        BOOL b;
        ULONGLONG TotalSpace;
        DWORD SectorsPerCluster, BytesPerSector, NumberOfFreeClusters, TotalNumberOfClusters;
        DWORD FloppySpace = 10 * 1024 * 1024;// use 10MB to distinguish a floppy from other drives, like JAZ drive 1GB
        b = GetDiskFreeSpace(szRoot,&SectorsPerCluster, &BytesPerSector, &NumberOfFreeClusters, &TotalNumberOfClusters);
        if (b)
        {
             TotalSpace = (ULONGLONG) TotalNumberOfClusters * SectorsPerCluster * BytesPerSector;
             if (TotalSpace > (ULONGLONG) FloppySpace)
                {fReturn = TRUE;}
             else
             {
                 iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("GetDiskFreeSpace():Drive=DRIVE_REMOVABLE:Not Sufficient space on drive '%1!s!'.  FAIL\n"), szRoot));
             }
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("GetDiskFreeSpace(Drive=DRIVE_REMOVABLE) on %1!s! returns err: 0x%2!x!.  FAILURE\n"), szRoot, GetLastError()));
        }
    }

    return (fReturn);
}

// If lpszPath is a valid directory, return TRUE, and pass back the valid path in lpszPath to caller
// Otherwise, return FALSE.
BOOL IsValidDirectoryName(LPTSTR lpszPath)
{
    DWORD err = 0;
    BOOL bReturn = FALSE;
    TCHAR szFullPath[_MAX_PATH];
    LPTSTR p;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("IsValidDirectoryName %1!s!\n"), lpszPath));
    err = GetFullPathName(lpszPath, _MAX_PATH, szFullPath, &p);
    if (err != 0)
    {
        if (szFullPath[1] == _T(':')) { // good, not a UNC name
            // make sure it is a FIXED drive
            TCHAR szRoot[4];
            _tcsncpy(szRoot, szFullPath, 3);
            szRoot[3] = _T('\0');
            if (IsValidDriveType(szRoot))
            {
                // OK, ready to create each layered directory
                TCHAR szBuffer[_MAX_PATH];
                LPTSTR token, tail;
                CStringArray aDir;
                int i, n;

                tail = szBuffer;
                token = _tcstok(szFullPath, _T("\\"));
                if (token)
                {
                    _tcscpy(tail, token);
                    tail += _tcslen(token);
                    bReturn = TRUE; /* return TRUE if in the form of C:\ */
                    while ( ( token = _tcstok(NULL, _T("\\")) ) != NULL )
                    {
                        *tail = _T('\\');
                        tail = _tcsinc(tail);
                        _tcscpy(tail, token);
                        // create it & rememeber it
                        err = GetFileAttributes(szBuffer);
                        if (err == 0xFFFFFFFF)
                        {
                            // szBuffer contains a non-existing path
                            // create it
                            if (CreateDirectory(szBuffer, NULL))
                            {
                                // succeed, remember the directory in an array
                                aDir.Add(szBuffer);
                            }
                            else
                            {
                                iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory:CreateDirectory failed on %1!s!, err=%2!x!.\n"), szBuffer, GetLastError()));
                                bReturn = FALSE;
                                break;
                            }
                        } else {
                            // szBuffer contains an existing path,
                            // make sure it is a directory
                            if (!(err & FILE_ATTRIBUTE_DIRECTORY))
                            {
                                iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory failure. %1!s! is not a valid directory.\n"), szBuffer));
                                bReturn = FALSE;
                                break;
                            }
                        }
                        tail += _tcslen(token);
                    }
                    if (bReturn)
                    {
                        // pass the valid directory to the caller
                        if (*(tail-1) == _T(':'))
                        {
                            *tail = _T('\\');
                            tail = _tcsinc(tail);
                        }
                        _tcscpy(lpszPath, szBuffer);
                    }
                }
                // remove the created directories we remembered in the array
                n = (int)aDir.GetSize();
                for (i = n-1; i >= 0; i--)
                    RemoveDirectory(aDir[i]);
            } else {
                iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory failure. %1!s! is not on a valid drive.\n"), szFullPath));
            }
        } else {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory failure. UNC name %1!s! is not allowed.\n"), szFullPath));
        }
    } else {
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory:GetFullPathName failed on %1!s!, err=%2!x!.\n"), lpszPath, GetLastError()));
    }

    return (bReturn);
}

BOOL IsValidNumber(LPCTSTR szValue)
{
    LPTSTR p = (LPTSTR)szValue;
    while (*p) 
    {
        if ( *p >= _T('0') && *p <= _T('9') ) 
        {
            p = _tcsinc(p);
            continue;
        } else
            return FALSE;
    }
    return TRUE;
}

// Calculate the size of a Multi-String in TCHAR, including the ending 2 '\0's.
int GetMultiStrSize(LPTSTR p)
{
    int c = 0;

    while (1) {
        if (*p) {
            p++;
            c++;
        } else {
            c++;
            if (*(p+1)) {
                p++;
            } else {
                c++;
                break;
            }
        }
    }
    return c;
}

BOOL IsFileExist(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
        _tcscpy(szValue,szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szFile);}

        return (GetFileAttributes(szValue) != 0xFFFFFFFF);
    }
    else
    {
        return (GetFileAttributes(szFile) != 0xFFFFFFFF);
    }
}

void InetGetFilePath(LPCTSTR szFile, LPTSTR szPath)
{
    // if UNC name \\computer\share\local1\local2
    if (*szFile == _T('\\') && *(_tcsinc(szFile)) == _T('\\')) {
        TCHAR szTemp[_MAX_PATH], szLocal[_MAX_PATH];
        TCHAR *p = NULL;
        int i = 0;

        _tcscpy(szTemp, szFile);
        p = szTemp;
        while (*p) {
            if (*p == _T('\\'))
                i++;
            if (i == 4) {
                *p = _T('\0');
                p = _tcsinc(p); // p is now pointing at local1\local2
                break;
            }
            p = _tcsinc(p);
        }
        _tcscpy(szPath, szTemp); // now szPath contains \\computer\share

        if (i == 4 && *p) { // p is pointing the local path now
            _tcscpy(szLocal, p);
            p = _tcsrchr(szLocal, _T('\\'));
            if (p)
                *p = _T('\0');
            _tcscat(szPath, _T("\\"));
            _tcscat(szPath, szLocal); // szPath contains \\computer\share\local1
        }
    } else { // NOT UNC name
        TCHAR *p;
        if (GetFullPathName(szFile, _MAX_PATH, szPath, &p)) {
            p = _tcsrchr(szPath, _T('\\'));
            if (p) 
            {
                TCHAR *p2 = NULL;
                p2 = _tcsdec(szPath, p);
                if (p2)
                {
                    if (*p2 == _T(':') )
                        {p = _tcsinc(p);}
                }
                *p = _T('\0');
            }
        } else {
            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("GetFullPathName: szFile=%1!s!, err=%2!d!\n"), szFile, GetLastError()));
            MyMessageBox(NULL, _T("GetFullPathName"), GetLastError(), MB_OK | MB_SETFOREGROUND);
        }
    }

    return;
}


BOOL InetDeleteFile(LPCTSTR szFileName)
{
    // if file exists but DeleteFile() fails
    if ( IsFileExist(szFileName) && !(::DeleteFile(szFileName)) ) {
        // if we cannot delete it, then move delay until reboot
        // move it to top level dir on the same drive, and mark it as hidden
        // Note: MoveFileEx() works only on the same drive if dealing with file-in-use
        TCHAR TmpName[_MAX_PATH];
        TCHAR csTmpPath[5] = _T("C:\\.");
        csTmpPath[0] = *szFileName;
        if ( GetTempFileName( (LPCTSTR)csTmpPath, _T("INT"), 0, TmpName ) == 0 ||
            !MoveFileEx( szFileName, TmpName, MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ) ) {
            return FALSE;
        }
        MoveFileEx( TmpName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT );
        SetFileAttributes(TmpName, FILE_ATTRIBUTE_HIDDEN);
    }

    return TRUE;
}

BOOL InetCopyFile( LPCTSTR szSrc, LPCTSTR szDest)
{
    INT err;
    INT fSrc;
    INT fDest;
    OFSTRUCT ofstruct;

    do {
        // open source file
        iisDebugOut_Start((_T("LZ32.dll:LZOpenFile()")));
        if (( fSrc = LZOpenFile( (LPTSTR)szSrc, &ofstruct, OF_READ | OF_SHARE_DENY_NONE )) < 0 ) 
        {
            iisDebugOut_End((_T("LZ32.dll:LZOpenFile")));
            // cannot open src file
            LZClose(fSrc);

            UINT iMsg = MyMessageBox( NULL, IDS_CANNOT_OPEN_SRC_FILE, szSrc, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
            switch ( iMsg )
            {
            case IDABORT:
                return FALSE;
            case IDRETRY:
                break;
            case IDIGNORE:
            default:
                return TRUE;
            }
        }
        else
        {
            iisDebugOut_End((_T("LZ32.dll:LZOpenFile")));
            break;
        }
    } while (TRUE);

    // move the desintation file
    CFileStatus status;
    if ( CFile::GetStatus( szDest, status ))
    {
        // try to remove it
        if ( !InetDeleteFile( szDest ))
        {
            LZClose( fSrc );
            return TRUE;
        }
    }

    // open desination file
    do {
        iisDebugOut_Start((_T("LZ32.dll:LZOpenFile()")));
        if (( fDest = LZOpenFile( (LPTSTR)szDest, &ofstruct, OF_CREATE |  OF_WRITE | OF_SHARE_DENY_NONE )) < 0 )
        {
            iisDebugOut_End((_T("LZ32.dll:LZOpenFile")));
            LZClose(fDest);

            UINT iMsg = MyMessageBox( NULL, IDS_CANNOT_OPEN_DEST_FILE, szDest, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
            switch ( iMsg )
            {
            case IDABORT:
                LZClose(fSrc);
                return FALSE;
            case IDRETRY:
                break;
            case IDIGNORE:
            default:
                LZClose(fSrc);
                return TRUE;
            }
        }
        else
        {
            iisDebugOut_End((_T("LZ32.dll:LZOpenFile")));
            break;
        }
    } while (TRUE);

    do {
        iisDebugOut_Start((_T("LZ32.dll:LZCopy()")));
        if (( err = LZCopy( fSrc, fDest )) < 0 )
        {
            iisDebugOut_End((_T("LZ32.dll:LZCopy")));
            LZClose( fSrc );
            LZClose( fDest );

            UINT iMsg = MyMessageBox( NULL, IDS_CANNOT_COPY_FILE, szSrc,szDest,ERROR_CANNOT_COPY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
            switch ( iMsg )
            {
            case IDABORT:
                return FALSE;
            case IDRETRY:
                break;
            case IDIGNORE:
            default:
                return TRUE;
            }
        }
        else
        {
            iisDebugOut_End((_T("LZ32.dll:LZCopy")));
            LZClose( fSrc );
            LZClose( fDest );
            break;
        }
    } while (TRUE);

    return TRUE;
}

// Given a fullpathname of a directory, remove any empty dirs under it including itself

BOOL RecRemoveEmptyDir(LPCTSTR szName)
{
    BOOL fReturn = FALSE;
        DWORD retCode;
        BOOL fRemoveDir = TRUE;
        WIN32_FIND_DATA FindFileData;
        HANDLE hFile = INVALID_HANDLE_VALUE;
        TCHAR szSubDir[_MAX_PATH] = _T("");
        TCHAR szDirName[_MAX_PATH] = _T("");

        retCode = GetFileAttributes(szName);

        if (retCode == 0xFFFFFFFF || !(retCode & FILE_ATTRIBUTE_DIRECTORY))
                return FALSE;

        _stprintf(szDirName, _T("%s\\*"), szName);
        hFile = FindFirstFile(szDirName, &FindFileData);

        if (hFile != INVALID_HANDLE_VALUE) {
                do {
                        if (_tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
                                _tcsicmp(FindFileData.cFileName, _T("..")) != 0 ) {
                                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                                        _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                                        fRemoveDir = RecRemoveEmptyDir(szSubDir) && fRemoveDir;
                                } else {
                                    CString csFileName = FindFileData.cFileName;
                                    CString csPrefix = csFileName.Left(3);
                                    CString csSuffix = csFileName.Right(4);
                                    if (_tcsicmp(csPrefix, _T("INT")) == 0 &&
                                        _tcsicmp(csSuffix, _T(".tmp")) == 0 ) { // this is an INT*.tmp created by IIS
                                        _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                                        if (!::DeleteFile(szSubDir))
                                            fRemoveDir = FALSE; // this dir is not empty
                                    } else
                                        fRemoveDir = FALSE; // it is a file, this Dir is not empty
                                }
                        }

                        if (!FindNextFile(hFile, &FindFileData)) {
                                FindClose(hFile);
                                break;
                        }
                } while (TRUE);
        }

        if (fRemoveDir) {
            TCHAR szDirName[_MAX_PATH];
            GetCurrentDirectory( _MAX_PATH, szDirName );
            SetCurrentDirectory(g_pTheApp->m_csSysDir);
            fReturn = ::RemoveDirectory(szName);
            SetCurrentDirectory(szDirName);
        }

        return fReturn;

}

// Given a fullpathname of a directory, remove the directory node
// 
// Parameters
//   szName - The name of file or directory
//   bRemoveDirectoryItself - Should the directory itself be removed
//
BOOL RecRemoveDir(LPCTSTR szName, BOOL bRemoveDirectoryItself /* = TRUE */ )
{
    DWORD retCode;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szSubDir[_MAX_PATH] = _T("");
    TCHAR szDirName[_MAX_PATH] = _T("");

    retCode = GetFileAttributes(szName);

    if (retCode == 0xFFFFFFFF)
        return FALSE;

    if (!(retCode & FILE_ATTRIBUTE_DIRECTORY)) {
        InetDeleteFile(szName);
        return TRUE;
    }

    _stprintf(szDirName, _T("%s\\*"), szName);
    hFile = FindFirstFile(szDirName, &FindFileData);

    if (hFile != INVALID_HANDLE_VALUE) {
        do {
            if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
                 _tcsicmp(FindFileData.cFileName, _T("..")) != 0 ) {
                _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                RecRemoveDir(szSubDir, TRUE);
            }

            if ( !FindNextFile(hFile, &FindFileData) ) {
                FindClose(hFile);
                break;
            }
        } while (TRUE);
    }

    if ( bRemoveDirectoryItself )
    {
      return( ::RemoveDirectory(szName) );
    }

    return TRUE;
}


//
// Given a directory path, this subroutine will create the direct layer by layer
//

BOOL CreateLayerDirectory( CString &str )
{
    BOOL fReturn = TRUE;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateLayerDirectory %1!s!\n"), (LPCTSTR)str));
    do
    {
        INT index=0;
//        INT iLength = str.GetLength();
        INT iLength = _tcslen(str);

        // first find the index for the first directory
        if ( iLength > 2 )
        {
            if ( *_tcsninc(str,1) == _T(':'))
            {
                // assume the first character is driver letter
                if ( *_tcsninc(str,2) == _T('\\'))
                {
                    index = 2;
                } else
                {
                    index = 1;
                }
            } else if ( *_tcsninc(str,0) == _T('\\'))
            {
                if ( *_tcsninc(str,1) == _T('\\'))
                {
                    BOOL fFound = FALSE;
                    INT i;
                    INT nNum = 0;
                    // unc name
                    for (i = 2; i < iLength; i++ )
                    {
                        if ( *_tcsninc(str,i) == _T('\\'))
                        {
                            // find it
                            nNum ++;
                            if ( nNum == 2 )
                            {
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                    if ( fFound )
                    {
                        index = i;
                    } else
                    {
                        // bad name
                        break;
                    }
                } else
                {
                    index = 1;
                }
            }
        } else if ( *_tcsninc(str,0) == _T('\\'))
        {
            index = 0;
        }

        // okay ... build directory
        do
        {
            // find next one
            do
            {
                if ( index < ( iLength - 1))
                {
                    index ++;
                } else
                {
                    break;
                }
            } while ( *_tcsninc(str,index) != _T('\\'));


            TCHAR szCurrentDir[_MAX_PATH+1];
            TCHAR szLeftDir[_MAX_PATH+1];
            ZeroMemory( szLeftDir, _MAX_PATH+1 );

            GetCurrentDirectory( _MAX_PATH+1, szCurrentDir );

            _tcsncpy( szLeftDir, str,  index + 1 );
            if ( !SetCurrentDirectory(szLeftDir) )
            {
                if (( fReturn = CreateDirectory( szLeftDir, NULL )) != TRUE )
                {
                    break;
                }
            }

            SetCurrentDirectory( szCurrentDir );

            if ( index >= ( iLength - 1 ))
            {
                fReturn = TRUE;
                break;
            }
        } while ( TRUE );
    } while (FALSE);

    return(fReturn);
}


// szResult = szParentDir \ szSubDir
BOOL AppendDir(LPCTSTR szParentDir, LPCTSTR szSubDir, LPTSTR szResult)
{
    LPTSTR p = (LPTSTR)szParentDir;

    ASSERT(szParentDir);
    ASSERT(szSubDir);
    ASSERT(*szSubDir && *szSubDir != _T('\\'));

    if (*szParentDir == _T('\0'))
        _tcscpy(szResult, szSubDir);
    else {
        _tcscpy(szResult, szParentDir);

        p = szResult;
        while (*p)
            p = _tcsinc(p);

        if (*(_tcsdec(szResult, p)) != _T('\\'))
            _tcscat(szResult, _T("\\"));

        _tcscat(szResult, szSubDir);
    }
    return TRUE;
}



//***************************************************************************
//*                                                                         
//* purpose: add's filename onto path
//* 
//***************************************************************************
void AddPath(LPTSTR szPath, LPCTSTR szName )
{
	LPTSTR p = szPath;
    LPTSTR pPrev;
    ASSERT(szPath);
    ASSERT(szName); 

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    pPrev = _tcsdec(szPath, p);
    if ( (!pPrev) ||
         (*(pPrev) != _T('\\'))
         )
		{_tcscat(szPath, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

	// Add new name to existing path string
	_tcscat(szPath, szName);
}


CString AddPath(CString szPath, LPCTSTR szName )
{
    TCHAR szPathCopy[_MAX_PATH] = _T("");
    _tcscpy(szPathCopy,szPath);
	LPTSTR p = szPathCopy;
    ASSERT(szPathCopy);
    ASSERT(szName); 

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    if (*(_tcsdec(szPathCopy, p)) != _T('\\'))
		{_tcscat(szPathCopy, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == _T(' ') ) szName = _tcsinc(szName);;

    // make sure that the szName
    // does not look like this "\filename"
    CString csTempString = szName;
    if (_tcsicmp(csTempString.Left(1), _T("\\")) == 0)
    {
        csTempString = csTempString.Right( csTempString.GetLength() - 1);
    }
    
	// Add new name to existing path string
	_tcscat(szPathCopy, csTempString);

    return szPathCopy;
    //szPath = szPathCopy;
}


BOOL ReturnFileNameOnly(LPCTSTR lpFullPath, LPTSTR lpReturnFileName)
{
    int iReturn = FALSE;

    TCHAR pfilename_only[_MAX_FNAME];
    TCHAR pextention_only[_MAX_EXT];

    _tcscpy(lpReturnFileName, _T(""));

    _tsplitpath( lpFullPath, NULL, NULL, pfilename_only, pextention_only);
    if (pextention_only) {_tcscat(pfilename_only,pextention_only);}
    if (pfilename_only)
    {
        _tcscpy(lpReturnFileName, pfilename_only);
        iReturn = TRUE;
    }
    else
    {
        // well, we don't have anything in pfilename_only
        // that's probably because we got some strange path name like:
        // /??/c:\somethng\filename.txt
        // so... let's just return everything after the last "\" character.
        LPTSTR pszTheLastBackSlash = _tcsrchr((LPTSTR) lpFullPath, _T('\\'));
        _tcscpy(lpReturnFileName, pszTheLastBackSlash);
        iReturn = TRUE;
    }
    return iReturn;
}


BOOL ReturnFilePathOnly(LPCTSTR lpFullPath, LPTSTR lpReturnPathOnly)
{
    int iReturn = FALSE;
    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szFilename_only[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    _tcscpy(lpReturnPathOnly, _T(""));
    _tsplitpath( lpFullPath, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);
    _tcscpy(lpReturnPathOnly, szDrive_only);
    _tcscat(lpReturnPathOnly, szPath_only);
    iReturn = TRUE;

    return iReturn;
}


void DeleteFilesWildcard(TCHAR *szDir, TCHAR *szFileName)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFileToBeDeleted[_MAX_PATH];

    _stprintf(szFileToBeDeleted, _T("%s\\%s"), szDir, szFileName);

    hFile = FindFirstFile(szFileToBeDeleted, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, so let's Delete it.
                        TCHAR szTempFileName[_MAX_PATH];
                        _stprintf(szTempFileName, _T("%s\\%s"), szDir, FindFileData.cFileName);
                        // set to normal attributes, so we can delete it
                        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
                        // delete it, hopefully
                        InetDeleteFile(szTempFileName);
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return;
}


int IsThisDriveNTFS(IN LPTSTR FileName)
{
    BOOL Ntfs = FALSE;
    TCHAR szDriveRootPath[_MAX_DRIVE + 5];
    DWORD DontCare;
    TCHAR NameBuffer[100];

    // get the Drive only.
    _tsplitpath( FileName, szDriveRootPath, NULL, NULL, NULL);
    _tcscat(szDriveRootPath, _T("\\"));

    //
    //  find out what the file system is
    //
    if (0 != GetVolumeInformation(szDriveRootPath,NULL,0,NULL,&DontCare,&DontCare,NameBuffer,sizeof(NameBuffer)/sizeof(TCHAR)))
    {
        if (0 == _tcsicmp(NameBuffer,_T("NTFS"))) 
            {Ntfs = TRUE;}
    }

    return Ntfs;
}


// take something like
// e:\winnt\system32         and return back %systemroot%\system23
// e:\winnt\system32\inetsrv and return back %systemroot%\system23\inetsrv
int ReverseExpandEnvironmentStrings(LPTSTR szOriginalDir,LPTSTR szNewlyMungedDir)
{
    int     iReturn = FALSE;
    int     iWhere = 0;
    TCHAR   szSystemDir[_MAX_PATH];
    CString csTempString;
    CString csTempString2;

    // default it with the input string
    _tcscpy(szNewlyMungedDir, szOriginalDir);

    // get the c:\winnt\system32 dir
    if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
    {
        // we weren't able to get the systemdirectory, so just return whatever was put in
        iReturn = TRUE;
        goto ReverseExpandEnvironmentStrings_Exit;
    }

    csTempString = szOriginalDir;
    csTempString2 = szSystemDir;

    // Find the "e:\winnt\system32"
    iWhere = csTempString.Find(szSystemDir);
    if (-1 != iWhere)
    {
        CString AfterString;

        // there is a "e:\winnt\system32" in the string
        // Get the after e:\winnt\system32 stuff
        AfterString = csTempString.Right(csTempString.GetLength() - (iWhere + csTempString2.GetLength()));

        // Take everything after the string and append it to our new string.
        _tcscpy(szNewlyMungedDir, _T("%SystemRoot%\\System32"));
        _tcscat(szNewlyMungedDir, AfterString);

        // return true!
        iReturn = TRUE;
    }

ReverseExpandEnvironmentStrings_Exit:
    return iReturn;
}


DWORD ReturnFileSize(LPCTSTR myFileName)
{
    DWORD dwReturn = 0xFFFFFFFF;
    HANDLE hFile = CreateFile(myFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwReturn = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
    }
    return dwReturn;
}


BOOL IsFileExist_NormalOrCompressed(LPCTSTR szFile)
{
    int iReturn = FALSE;
    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szFilename_only[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    TCHAR szCompressedName[_MAX_PATH];

    // Check if the file exsts
    // if it doesn't, check if maybe the compressed file exists.
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s.\n"), szFile));
    if (IsFileExist(szFile) != TRUE)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s not exist.\n"), szFile));
        // check if maybe the compressed file exists
        _tsplitpath( szFile, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

        // Replace the last character with an '_'
        int nLen = 0;
        nLen = _tcslen(szFilename_ext_only);
        *_tcsninc(szFilename_ext_only, nLen-1) = _T('_');
        _stprintf(szCompressedName,_T("%s%s%s%s"),szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

        // see if it exists
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s.\n"), szCompressedName));
        if (IsFileExist(szCompressedName) != TRUE) 
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s. no exist.\n"), szCompressedName));
            goto IsFileExist_RegOrCompressed_Exit;
        }
        else
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s. exist.\n"), szCompressedName));
        }
    }

    // we got this far, that must mean things are okay.
    iReturn = TRUE;

IsFileExist_RegOrCompressed_Exit:
    return iReturn;
}


// Clean leading & trailing spaces
// Clean trailing backslashes
BOOL CleanPathString(LPTSTR szPath)
{
    CString csPath = szPath;

    csPath.TrimLeft();
    csPath.TrimRight();

    _tcscpy(szPath, (LPCTSTR)csPath);

    return TRUE;
}


//
//  Return 0 if there was nothing to compare 
//  Return 1 if Source is Equal  to   Destination
//  Return 2 if Source is Larger than Destination
//  Return 3 if Source is Less   than Destination
//
INT VerCmp(LPTSTR szSrcVerString, LPTSTR szDestVerString)
{
    INT iReturn = 0;
    const DWORD MAX_NUM_OF_VER_FIELDS = 32;
    DWORD dwSrcVer[MAX_NUM_OF_VER_FIELDS], dwDestVer[MAX_NUM_OF_VER_FIELDS];
    memset( (PVOID)dwSrcVer, 0, sizeof(dwSrcVer));
    memset( (PVOID)dwDestVer, 0, sizeof(dwDestVer));
    int i=0;
    TCHAR szSeps[] = _T(".");
    TCHAR *token;
    BOOL bNotEqual = FALSE;

    // expand src version string into a dword arrary
    i = 0;
    token = _tcstok(szSrcVerString, szSeps);
    while ( token && (i < MAX_NUM_OF_VER_FIELDS) ) {
        dwSrcVer[i++] = _ttoi(token);
        token = _tcstok(NULL, szSeps);
    }

    // expand dest version string into a dword arrary
    i = 0;
    token = _tcstok(szDestVerString, szSeps);
    while ( token && (i < MAX_NUM_OF_VER_FIELDS) ) {
        dwDestVer[i++] = _ttoi(token);
        token = _tcstok(NULL, szSeps);
    }

    // Check for Equality
    for (i=0; i<MAX_NUM_OF_VER_FIELDS; i++) 
    {
        if (dwSrcVer[i] != dwDestVer[i])
            {
            bNotEqual = TRUE;
            break;
            }
    }

    if (TRUE == bNotEqual)
    {
        // int compare each field
        for (i=0; i<MAX_NUM_OF_VER_FIELDS; i++) 
        {
            if (dwSrcVer[i] > dwDestVer[i])
                {return 2;}
            if (dwSrcVer[i] < dwDestVer[i])
                {return 3;}
        }
        // if we haven't return here, then
        // there probably wasn't anything to loop thru (for 0=0 till 0)
        return 0;
    }
    else
    {
        // it is equal so return so
        return 1;
    }
}


DWORD atodw(LPCTSTR lpszData)
{
    DWORD i = 0, sum = 0;
    TCHAR *s, *t;

    s = (LPTSTR)lpszData;
    t = (LPTSTR)lpszData;

    while (*t)
        t = _tcsinc(t);
    t = _tcsdec(lpszData, t);

    if (*s == _T('0') && (*(_tcsinc(s)) == _T('x') || *(_tcsinc(s)) == _T('X')))
        s = _tcsninc(s, 2);

    while (s <= t) {
        if ( *s >= _T('0') && *s <= _T('9') )
            i = *s - _T('0');
        else if ( *s >= _T('a') && *s <= _T('f') )
            i = *s - _T('a') + 10;
        else if ( *s >= _T('A') && *s <= _T('F') )
            i = *s - _T('A') + 10;
        else
            break;

        sum = sum * 16 + i;
        s = _tcsinc(s);
    }
    return sum;
}


void MakePath(LPTSTR lpPath)
{
   LPTSTR  lpTmp;
   lpTmp = CharPrev( lpPath, lpPath + _tcslen(lpPath));

   // chop filename off
   while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( lpPath, lpTmp );

   if ( *CharPrev( lpPath, lpTmp ) != ':' )
       *lpTmp = '\0';
   else
       *CharNext(lpTmp) = '\0';
   return;
}


CString ReturnUniqueFileName(CString csInputFullName)
{
    TCHAR szPathCopy[_MAX_PATH] = _T("");
    _tcscpy(szPathCopy,csInputFullName);
    long iNum = 1;
    do
    {
        _stprintf(szPathCopy,TEXT("%s.%d"),csInputFullName,iNum);
        // Check if the file exists
        if (!IsFileExist(szPathCopy)){goto ReturnUniqueFileName_Exit;}
        iNum++;
    } while (iNum <= 50);

ReturnUniqueFileName_Exit:
    // returns %s50 if there are fifty copies aleady!
    return szPathCopy;
}


/*---------------------------------------------------------------------------*
  Description: Displays the current running version of setup to the debug
  output and setup log.
-----------------------------------------------------------------------------*/
void DisplayVerOnCurrentModule()
{
    TCHAR       tszModuleName[_MAX_PATH+1];
    
    if ( GetModuleFileName((HINSTANCE)g_MyModuleHandle, tszModuleName, _MAX_PATH+1) != 0 )
    {
      LogFileVersion(tszModuleName, TRUE);
    }

    return;
}

void MyGetVersionFromFile(LPCTSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, LPTSTR pszReturnLocalizedVersion)
{
    struct TRANSARRAY {
	    WORD wLanguageID;
	    WORD wCharacterSet;
    };
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    LPTSTR      lpBuffer = NULL;
    LPVOID      lpVerBuffer = NULL;

    LPTSTR		pszTheResult = NULL;
    TCHAR       QueryString[48] = _T("");
    TRANSARRAY	*lpTransArray;

    *pdwMSVer = *pdwLSVer = 0L;

    dwVerInfoSize = GetFileVersionInfoSize( (LPTSTR) lpszFilename, &dwHandle);
    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = (LPTSTR) LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            int iTemp = 0;
            iTemp = GetFileVersionInfo( (LPTSTR) lpszFilename, dwHandle, dwVerInfoSize, lpBuffer);

            // Read version stamping info
            if (iTemp)
            {
                // Get the value for Translation
                if (VerQueryValue(lpBuffer, _T("\\"), (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize))
                {
                    *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                    *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                }

		        // get a pointer to the translation table information
		        if (VerQueryValue(lpBuffer, _T("\\VarFileInfo\\Translation"), &lpVerBuffer, &uiSize) && (uiSize))
                {
		            lpTransArray = (TRANSARRAY *) lpVerBuffer;
		            // lpTransArray points to the translation array.  dwFixedLength has number of bytes in array
		            _stprintf(QueryString, _T("\\StringFileInfo\\%04x%04x\\FileVersion"), lpTransArray[0].wLanguageID, lpTransArray[0].wCharacterSet);
		            if (VerQueryValue(lpBuffer, QueryString, (LPVOID*) &pszTheResult, &uiSize))
                    {
                        _tcscpy(pszReturnLocalizedVersion, pszTheResult);
                    }
                }
            }
        }
    }

    if(lpBuffer) {LocalFree(lpBuffer);lpBuffer=NULL;}
    return ;
}


BOOL MyGetDescriptionFromFile(LPCTSTR lpszFilename, LPTSTR pszReturnDescription)
{
    BOOL  bRet = FALSE;
    struct TRANSARRAY {
	    WORD wLanguageID;
	    WORD wCharacterSet;
    };
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    LPTSTR      lpBuffer = NULL;
    LPVOID      lpTempBuffer = NULL;

    LPTSTR		pszTheResult = NULL;
    TCHAR       QueryString[52] = _T("");
    TRANSARRAY	*lpTransArray;

    dwVerInfoSize = GetFileVersionInfoSize( (LPTSTR) lpszFilename, &dwHandle);
    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = (LPTSTR) LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            int iTemp = 0;
            iTemp = GetFileVersionInfo( (LPTSTR) lpszFilename, dwHandle, dwVerInfoSize, lpBuffer);

            // Read version stamping info
            if (iTemp)
            {
		        // get a pointer to the translation table information
                if (VerQueryValue(lpBuffer, _T("\\VarFileInfo\\Translation"), &lpTempBuffer, &uiSize) && (uiSize))
                {
		            lpTransArray = (TRANSARRAY *) lpTempBuffer;
		            // lpTransArray points to the translation array.  dwFixedLength has number of bytes in array
		            _stprintf(QueryString, _T("\\StringFileInfo\\%04x%04x\\FileDescription"), lpTransArray[0].wLanguageID, lpTransArray[0].wCharacterSet);
		            if (VerQueryValue(lpBuffer, QueryString, (LPVOID*) &pszTheResult, &uiSize))
                    {
                        _tcscpy(pszReturnDescription, pszTheResult);
                        bRet = TRUE;
                    }
                }
            }
        }
    }

    if(lpBuffer) {LocalFree(lpBuffer);lpBuffer=NULL;}
    return bRet;
}


//
// Returns True if the filename has a version stamp which is part of ntop4.0
//
int IsFileLessThanThisVersion(IN LPCTSTR lpszFullFilePath, IN DWORD dwNtopMSVer, IN DWORD dwNtopLSVer)
{
    int iReturn = FALSE;
    DWORD  dwMSVer, dwLSVer;
    TCHAR szLocalizedVersion[100] = _T("");
 
    // if the filename has a version number
    // and it's larger than the release version of ntop 4.2.622.1, 4.02.0622 (localized version)
    // return back true! if not, then return back false.

    // see if the file exists
    if (!IsFileExist(lpszFullFilePath)) 
        {goto iFileWasPartOfIIS4_Exit;}

    // get the fileinformation
    // includes version and localizedversion
    MyGetVersionFromFile(lpszFullFilePath, &dwMSVer, &dwLSVer, szLocalizedVersion);
    if (!dwMSVer)
        {
        iisDebugOut((LOG_TYPE_TRACE, _T("iFileWasPartOfIIS4:%s.No version."), lpszFullFilePath));
        goto iFileWasPartOfIIS4_Exit;
        }

    // okay, there is a version on this.
    iisDebugOut((LOG_TYPE_TRACE, _T("iFileWasPartOfIIS4:%d.%d.%d.%d, %s, %s"), HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath));

    // Check if the version is smaller than what was shipped with iis4.0
    // NTOP versions were 4.02.0622
    if (dwMSVer < dwNtopMSVer)
        {goto iFileWasPartOfIIS4_Exit;}

    // check if the file has a smaller minor version number
    if ( (dwMSVer == dwNtopMSVer) && (dwLSVer < dwNtopLSVer) )
        {goto iFileWasPartOfIIS4_Exit;}

    // this is a ntop 4.0 or greater versioned file
    iReturn = TRUE;

iFileWasPartOfIIS4_Exit:
    return iReturn;
}


void MakeSureDirAclsHaveAtLeastRead(LPTSTR lpszDirectoryPath)
{
    iisDebugOut_Start1(_T("MakeSureDirAclsHaveAtLeastRead"),lpszDirectoryPath, LOG_TYPE_TRACE);

    DWORD err;
    TCHAR szThePath[_MAX_PATH];

    if (FALSE == IsThisDriveNTFS(lpszDirectoryPath))
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("MakeSureDirAclsHaveAtLeastRead:filesys is not ntfs.")));
        goto MakeSureDirAclsHaveAtLeastRead_Exit;
    }

    do
    {
        //
        // Loop through all the files in the physical path
        //
        _tcscpy(szThePath, lpszDirectoryPath);
        _tcscat(szThePath, _T("\\*"));

        WIN32_FIND_DATA w32data;
        HANDLE hFind = ::FindFirstFile(szThePath, &w32data);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("MakeSureDirAclsHaveAtLeastRead:WARNING.filenotfound:%s"),lpszDirectoryPath));
            // No files...
            break;
        }
        //
        // First, set the new ACL on the folder itself.
        //
        err = SetAccessOnFile(lpszDirectoryPath, TRUE);
        err = SetAccessOnFile(lpszDirectoryPath, FALSE);
        err = ERROR_SUCCESS;
        //if (err != ERROR_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("MakeSureDirAclsHaveAtLeastRead:%s:FAILED WARNING.ret=0x%x."),lpszDirectoryPath,err));}
        //
        // Now do all the files in it
        //
        do
        {
            //
            // Only set the acl on files, not sub-directories
            //
            if (w32data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                continue;
            }

            //
            // Build the current file's full path name
            //
            _tcscpy(szThePath, lpszDirectoryPath);
            _tcscat(szThePath, _T("\\"));
            _tcscat(szThePath, w32data.cFileName);

            err = SetAccessOnFile(szThePath, TRUE);
            err = SetAccessOnFile(szThePath, FALSE);
            err = ERROR_SUCCESS;
            //if (err != ERROR_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("MakeSureDirAclsHaveAtLeastRead:%s:FAILED WARNING.ret=0x%x."),szThePath,err));}

        } while(SUCCEEDED(err) && FindNextFile(hFind, &w32data));
        FindClose(hFind);
    } while(FALSE);

MakeSureDirAclsHaveAtLeastRead_Exit:
    return;
}


DWORD SetAccessOnFile(IN LPTSTR FileName, BOOL bDoForAdmin)
{
    DWORD dwError = 0;
    TCHAR TrusteeName[50];
    PACL  ExistingDacl = NULL;
    PACL  NewAcl = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;

    // access stuff.
    DWORD AccessMask = GENERIC_ALL;
    EXPLICIT_ACCESS explicitaccess;
    ACCESS_MODE option;
    DWORD InheritFlag = NO_INHERITANCE;

    // other
    PSID principalSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // other other
	LPCTSTR ServerName = NULL; // local machine
	DWORD cbName = 200;
    TCHAR lpGuestGrpName[200];
	TCHAR ReferencedDomainName[200];
	DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
	SID_NAME_USE sidNameUse = SidTypeUser;

    // get current Dacl on specified file
    dwError = GetNamedSecurityInfo(FileName,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,&ExistingDacl,NULL,&psd);
    if(dwError != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile: GetNamedSecurityInfo failed on %s. err=0x%x\n"),FileName,dwError));
        goto SetAccessOnFile_Exit;
    }
    // set defaults
    option = GRANT_ACCESS;
    InheritFlag = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

    if (bDoForAdmin)
    {
        // Do for Administrators -- should be more access
        AccessMask = SYNCHRONIZE ;
        AccessMask |= GENERIC_ALL;
        _tcscpy(TrusteeName,_T("BUILTIN\\ADMINISTRATORS"));
        _tcscpy(TrusteeName,_T("administrators"));
    }
    else
    {
        // Do for Administrators -- should be more access
        AccessMask = SYNCHRONIZE ;
        AccessMask |= GENERIC_READ;
        _tcscpy(TrusteeName,_T("EVERYONE"));
    }

    // Get the SID for the certain string (administrator or everyone)
    dwError = GetPrincipalSID(TrusteeName, &principalSID, &bWellKnownSID);
    if (dwError != ERROR_SUCCESS)
        {
        iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile:GetPrincipalSID(%s) FAILED.  Error()= 0x%x\n"), TrusteeName, dwError));
        goto SetAccessOnFile_Exit;
        }

    // using Sid, get the "localized" name
    if (0 == LookupAccountSid(ServerName, principalSID, lpGuestGrpName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
        {
        iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile:LookupAccountSid(%s) FAILED.  GetLastError()= 0x%x\n"), TrusteeName, GetLastError()));
        goto SetAccessOnFile_Exit;
        }

    // using the "localized" name, build explicit access structure
    BuildExplicitAccessWithName(&explicitaccess,lpGuestGrpName,AccessMask,option,InheritFlag);
    explicitaccess.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    explicitaccess.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    explicitaccess.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;

    // set the acl with this certain access stuff
    dwError = SetEntriesInAcl(1,&explicitaccess,ExistingDacl,&NewAcl);
    if(dwError != ERROR_SUCCESS)
    {
        // it may error because the user is already there
        //iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile: SetEntriesInAcl failed on %s. for trustee=%s. err=0x%x\n"),FileName,explicitaccess.Trustee.ptstrName,dwError));
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SetAccessOnFile: SetEntriesInAcl failed on %s. for trustee=%s. err=0x%x\n"),FileName,explicitaccess.Trustee.ptstrName,dwError));
        goto SetAccessOnFile_Exit;
    }

    // apply new security to file
    dwError = SetNamedSecurityInfo(FileName,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,NewAcl,NULL);
    if(dwError != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile: SetNamedSecurityInfo failed on %s. err=0x%x\n"),FileName,dwError));
        goto SetAccessOnFile_Exit;
    }

    // everything is kool!
    dwError = ERROR_SUCCESS;

SetAccessOnFile_Exit:
    if(NewAcl != NULL){LocalFree(NewAcl);}
    if(psd != NULL){LocalFree(psd);}
    if (principalSID)
    {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }
    return dwError;
}


int CreateAnEmptyFile(CString strTheFullPath)
{
    int iReturn = FALSE;
    HANDLE hFile = NULL;

    if (IsFileExist(strTheFullPath) == TRUE)
    {
        return TRUE;
    }

	// Open existing file or create a new one.
	hFile = CreateFile(strTheFullPath,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hFile = NULL;
        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("CreateAnEmptyFile:() failed to CreateFile %1!s!. POTENTIAL PROBLEM.  FAILURE.\n"), strTheFullPath));
	}
    else
    {
        // write to the file
        if (hFile)
        {
            iReturn = TRUE;
            /*
            DWORD dwBytesWritten = 0;
            char szTestData[2];
            strcpy(szTestData, " ");
            if (WriteFile(hFile,szTestData,strlen(szTestData),&dwBytesWritten,NULL))
            {
                // everything is hunky dory. don't print anything
                iReturn = TRUE;
            }
            else
            {
                // error writing to the file.
                iisDebugOutSafeParams((LOG_TYPE_WARN, _T("CreateAnEmptyFile:WriteFile(%1!s!) Failed.  POTENTIAL PROBLEM.  FAILURE.  Error=0x%2!x!.\n"), strTheFullPath, GetLastError()));
            }
            */
        }
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    return iReturn;
}


DWORD GrantUserAccessToFile(IN LPTSTR FileName,IN LPTSTR TrusteeName)
{
    iisDebugOut_Start1(_T("GrantUserAccessToFile"),FileName,LOG_TYPE_TRACE);

    DWORD dwError = 0;
    PACL  ExistingDacl = NULL;
    PACL  NewAcl = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;

    // access stuff.
    DWORD AccessMask = GENERIC_ALL;
    EXPLICIT_ACCESS explicitaccess;
    ACCESS_MODE option;
    DWORD InheritFlag = NO_INHERITANCE;

    // other
    PSID principalSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // other other
	LPCTSTR ServerName = NULL; // local machine
	DWORD cbName = 200;
    TCHAR lpGuestGrpName[200];
	TCHAR ReferencedDomainName[200];
	DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
	SID_NAME_USE sidNameUse = SidTypeUser;

    if (IsFileExist(FileName) != TRUE)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GrantUserAccessToFile:file doesn't exist.")));
        goto GrantUserAccessToFile_Exit;
    }

    if (FALSE == IsThisDriveNTFS(FileName))
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GrantUserAccessToFile:filesys is not ntfs.")));
        goto GrantUserAccessToFile_Exit;
    }

    // get current Dacl on specified file
    dwError = GetNamedSecurityInfo(FileName,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,&ExistingDacl,NULL,&psd);
    if(dwError != ERROR_SUCCESS)
    {
        psd = NULL;
        iisDebugOut((LOG_TYPE_WARN, _T("GrantUserAccessToFile: GetNamedSecurityInfo failed on %s.\n"),FileName));
        goto GrantUserAccessToFile_Exit;
    }
    // set defaults
    option = GRANT_ACCESS;
    InheritFlag = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

    // assign access
    AccessMask = SYNCHRONIZE ;
    AccessMask |= GENERIC_ALL;
    //AccessMask = MAXIMUM_ALLOWED;

    // Get the SID for the certain string (administrator or everyone)
    dwError = GetPrincipalSID(TrusteeName, &principalSID, &bWellKnownSID);
    if (dwError != ERROR_SUCCESS)
        {
        principalSID = NULL;
        iisDebugOut((LOG_TYPE_WARN, _T("GrantUserAccessToFile:GetPrincipalSID(%s) FAILED.  Error()= 0x%x\n"), TrusteeName, dwError));
        goto GrantUserAccessToFile_Exit;
        }

    // using Sid, get the "localized" name
    if (0 == LookupAccountSid(ServerName, principalSID, lpGuestGrpName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
        {
        iisDebugOut((LOG_TYPE_WARN, _T("GrantUserAccessToFile:LookupAccountSid(%s) FAILED.  GetLastError()= 0x%x\n"), TrusteeName, GetLastError()));
        goto GrantUserAccessToFile_Exit;
        }

    // using the "localized" name, build explicit access structure
    BuildExplicitAccessWithName(&explicitaccess,lpGuestGrpName,AccessMask,option,InheritFlag);
    explicitaccess.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    explicitaccess.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    explicitaccess.Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
    if (_tcsicmp(TrusteeName, _T("administrators")) == 0 || _tcsicmp(TrusteeName, _T("everyone")) == 0)
    {
        explicitaccess.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    }

    // set the acl with this certain access stuff
    dwError = SetEntriesInAcl(1,&explicitaccess,ExistingDacl,&NewAcl);
    if(dwError != ERROR_SUCCESS)
    {
        NewAcl = NULL;
        // it may error because the user is already there
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GrantUserAccessToFile: SetEntriesInAcl failed on %s. for trustee=%s. err=0x%x\n"),FileName,explicitaccess.Trustee.ptstrName,dwError));
        goto GrantUserAccessToFile_Exit;
    }

    // apply new security to file
    dwError = SetNamedSecurityInfo(FileName,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,NewAcl,NULL);
    if(dwError != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_WARN, _T("GrantUserAccessToFile: SetNamedSecurityInfo failed on %s. err=0x%x\n"),FileName,dwError));
        goto GrantUserAccessToFile_Exit;
    }

    // everything is kool!
    dwError = ERROR_SUCCESS;

GrantUserAccessToFile_Exit:
    if(NewAcl != NULL){LocalFree(NewAcl);}
    if(psd != NULL){LocalFree(psd);}
    if (principalSID)
    {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }
    iisDebugOut_End1(_T("GrantUserAccessToFile"),FileName);
    return dwError;
}


#ifndef _CHICAGO_

DWORD SetDirectorySecurity(
    IN  LPCTSTR                 szDirPath,
    IN  LPCTSTR                 szPrincipal,
    IN  INT                     iAceType,
    IN  DWORD                   dwAccessMask,
    IN  DWORD                   dwInheritMask,
    IN  BOOL DontInheritFromParentAndOverWriteAccess
)
{
    DWORD dwStatus = ERROR_FILE_NOT_FOUND;

    if (ACCESS_ALLOWED_ACE_TYPE == iAceType || ACCESS_DENIED_ACE_TYPE == iAceType)
    {
        if (IsFileExist(szDirPath) == TRUE)
        {
            PSID principalSID = NULL;
            BOOL bWellKnownSID = FALSE;
            dwStatus = GetPrincipalSID((LPTSTR) szPrincipal, &principalSID, &bWellKnownSID);
            if (dwStatus == ERROR_SUCCESS)
            {
                PSECURITY_DESCRIPTOR psd = NULL;
                dwStatus = SetAccessOnDirOrFile((TCHAR*) szDirPath,principalSID,iAceType,dwAccessMask,dwInheritMask,&psd,DontInheritFromParentAndOverWriteAccess);

                //DumpAdminACL(INVALID_HANDLE_VALUE,psd);
                if (psd) {free(psd);psd=NULL;}
            }
        }
    }
    return dwStatus;
}

// -------------------------------------------------------------------------------------
// Function: RemovePrincipalFromFileAcl
//
// Remove a Access Control Entry from an Access Control List for a file/directory for a 
// particular SID
//
// -------------------------------------------------------------------------------------
DWORD RemovePrincipalFromFileAcl(IN TCHAR *pszFile,IN  LPTSTR szPrincipal)
{
    PACL                        pdacl;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PSECURITY_DESCRIPTOR        psdRelative = NULL;
    PSECURITY_DESCRIPTOR        psdAbsolute = NULL;
    DWORD                       cbSize = 0;
    BOOL                        bRes = 0;
    DWORD                       dwSecurityDescriptorRevision;
    BOOL                        fHasDacl  = FALSE;
    BOOL                        fDaclDefaulted = FALSE; 
    BOOL                        bUserExistsToBeDeleted;
    DWORD                       dwError = ERROR_SUCCESS;

    // get the size of the security descriptor
    bRes = GetFileSecurity(pszFile,DACL_SECURITY_INFORMATION,psdRelative,0,&cbSize);

    if ( !bRes )
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            psdRelative = malloc(cbSize);

            if (!psdRelative)
            {
                return ERROR_INSUFFICIENT_BUFFER;
            }

             bRes = GetFileSecurity(pszFile,DACL_SECURITY_INFORMATION,psdRelative,cbSize,&cbSize);
        }
    }

    if (!bRes)
    {
        if (psdRelative)
        {
            free(psdRelative);
        }
        return (GetLastError());
    }

    // get security descriptor control from the security descriptor 
    if (!GetSecurityDescriptorControl(psdRelative, (PSECURITY_DESCRIPTOR_CONTROL) &sdc,(LPDWORD) &dwSecurityDescriptorRevision))
    {
         dwError = GetLastError();
    }   
    else if (SE_DACL_PRESENT & sdc) 
    { 
        // Acl's are present, so we will attempt to remove the one passes in.
        if (GetSecurityDescriptorDacl(psdRelative, (LPBOOL) &fHasDacl,(PACL *) &pdacl, (LPBOOL) &fDaclDefaulted))
        {
            // Remove ACE from Acl
            dwError = RemovePrincipalFromACL(pdacl,szPrincipal,&bUserExistsToBeDeleted);

            if (dwError == ERROR_SUCCESS)
            {
                psdAbsolute = (PSECURITY_DESCRIPTOR) malloc(GetSecurityDescriptorLength(psdRelative));

                if (psdAbsolute)
                {
                    if ( !(InitializeSecurityDescriptor(psdAbsolute, SECURITY_DESCRIPTOR_REVISION)) ||
                         !(SetSecurityDescriptorDacl(psdAbsolute, TRUE, pdacl, fDaclDefaulted)) ||
                         !(IsValidSecurityDescriptor(psdAbsolute)) ||
                         !(SetFileSecurity(pszFile,(SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION),psdAbsolute))
                       )
                    {
                        dwError = GetLastError();
                    }

                    if (psdAbsolute)
                    {
                        free(psdAbsolute);
                    }
                }
                else
                {
                    dwError = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        } 
        else
        {
            dwError = GetLastError();
        }
    }

    if (psdRelative)
    {
        free(psdRelative);
    }

    return dwError;
}

DWORD SetAccessOnDirOrFile(IN TCHAR *pszFile,PSID psidGroup,INT iAceType,DWORD dwAccessMask,DWORD dwInheritMask,PSECURITY_DESCRIPTOR* ppsd,BOOL DontInheritFromParentAndOverWriteAccess)
{
    PSECURITY_DESCRIPTOR        psdAbsolute = NULL;
    PACL                        pdacl;
    DWORD                       cbSecurityDescriptor = 0;
    DWORD                       dwSecurityDescriptorRevision;
    DWORD                       cbDacl = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PACL                        pdaclNew = NULL; 
    DWORD                       cbAddDaclLength = 0; 
    BOOL                        fAceFound = FALSE;
    BOOL                        fHasDacl  = FALSE;
    BOOL                        fDaclDefaulted = FALSE; 
    ACCESS_ALLOWED_ACE*         pAce;
    DWORD                       i;
    BOOL                        fAceForGroupPresent = FALSE;
    DWORD                       dwMask;
    PSECURITY_DESCRIPTOR        psdRelative = NULL;
    DWORD                       cbSize = 0;
    BOOL bRes = 0;

    // get the size of the security descriptor
    bRes = GetFileSecurity(pszFile,DACL_SECURITY_INFORMATION,psdRelative,0,&cbSize);
    DWORD dwError = GetLastError();
    if (ERROR_INSUFFICIENT_BUFFER == dwError)
    {
        psdRelative = malloc(cbSize);
        if (!psdRelative)
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }

         bRes = GetFileSecurity(pszFile,DACL_SECURITY_INFORMATION,psdRelative,cbSize,&cbSize);
    }

    if (!bRes)
    {
        if (psdRelative){free(psdRelative);}
        return (GetLastError());
    }

    // get security descriptor control from the security descriptor 
    if (!GetSecurityDescriptorControl(psdRelative, (PSECURITY_DESCRIPTOR_CONTROL) &sdc,(LPDWORD) &dwSecurityDescriptorRevision))
    {
         return (GetLastError());
    }

    // check if DACL is present 
    if (SE_DACL_PRESENT & sdc) 
    {
        ACE_HEADER *pAceHeader;

        // get dacl   
        if (!GetSecurityDescriptorDacl(psdRelative, (LPBOOL) &fHasDacl,(PACL *) &pdacl, (LPBOOL) &fDaclDefaulted))
        {
            return ( GetLastError());
        }

        // check if pdacl is null
        // if it is then security is wide open -- this could be a fat drive.
        if (NULL == pdacl)
        {
            return ERROR_SUCCESS;
        }

        // get dacl length  
        cbDacl = pdacl->AclSize;
        // now check if SID's ACE is there  
        for (i = 0; i < pdacl->AceCount; i++)  
        {
            if (!GetAce(pdacl, i, (LPVOID *) &pAce))
            {
                return ( GetLastError());   
            }

            pAceHeader = (ACE_HEADER *)pAce;

            // check if group sid is already there
            if (EqualSid((PSID) &(pAce->SidStart), psidGroup))    
            {
                if (ACCESS_DENIED_ACE_TYPE == iAceType)
                {
                    if (pAceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
                    {
                        // If the correct access is present, return success
                        if ((pAce->Mask & dwAccessMask) == dwAccessMask)
                        {
                            return ERROR_SUCCESS;
                        }
                        fAceForGroupPresent = TRUE;
                        break;  
                    }
                }
                else
                {
                    if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
                    {
                        if (FALSE == DontInheritFromParentAndOverWriteAccess)
                        {
                            // If the correct access is present, return success
                            if ((pAce->Mask & dwAccessMask) == dwAccessMask)
                            {
                                return ERROR_SUCCESS;
                            }
                        }
                        fAceForGroupPresent = TRUE;
                        break;  
                    }
                }
            }
        }
        // if the group did not exist, we will need to add room
        // for another ACE
        if (!fAceForGroupPresent)  
        {
            // get length of new DACL  
            cbAddDaclLength = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psidGroup); 
        }
    } 
    else
    {
        // get length of new DACL
        cbAddDaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid (psidGroup);
    }


    // get memory needed for new DACL
    //pdaclNew = (PACL) malloc (cbDacl + cbAddDaclLength);
    pdaclNew = (PACL) LocalAlloc(LMEM_FIXED, cbDacl + cbAddDaclLength);
    if (!pdaclNew)
    {
        return (GetLastError()); 
    }

    // get the sd length
    cbSecurityDescriptor = GetSecurityDescriptorLength(psdRelative); 

    // get memory for new SD
    psdAbsolute = (PSECURITY_DESCRIPTOR) malloc(cbSecurityDescriptor + cbAddDaclLength);
    if (!psdAbsolute) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // change self-relative SD to absolute by making new SD
    if (!InitializeSecurityDescriptor(psdAbsolute, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // init new DACL
    if (!InitializeAcl(pdaclNew, cbDacl + cbAddDaclLength, ACL_REVISION)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // Add a new ACE for our SID if one was not already present
    if ( (!fAceForGroupPresent) && (ACCESS_DENIED_ACE_TYPE == iAceType) )
    {
        if (!AddAccessDeniedAce(pdaclNew, ACL_REVISION, dwAccessMask,psidGroup)) 
        {  
            dwError = GetLastError();  
            goto ErrorExit; 
        }
    }

    // now add in all of the ACEs into the new DACL (if org DACL is there)
    if (SE_DACL_PRESENT & sdc) 
    {
        ACE_HEADER *pAceHeader;
        DWORD aceHeader_Flags = 0;

        for (i = 0; i < pdacl->AceCount; i++)
        {   
            // get ace from original dacl
            if (!GetAce(pdacl, i, (LPVOID*) &pAce))   
            {
                dwError = GetLastError();    
                goto ErrorExit;   
            }

            pAceHeader = (ACE_HEADER *)pAce;

            aceHeader_Flags = pAce->Header.AceFlags;

            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                dwMask = pAce->Mask;
                if (ACCESS_ALLOWED_ACE_TYPE == iAceType)
                {
                    // If an ACE for our SID exists, we just need to bump
                    // up the access level instead of creating a new ACE
                    if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
                    {
                        if (FALSE == DontInheritFromParentAndOverWriteAccess)
                        {
                            dwMask = dwAccessMask | pAce->Mask;
                        }
                        else
                        {
                            dwMask = dwAccessMask;
                            aceHeader_Flags = dwInheritMask;
                        }
                    }
                }

                if (!AddAccessAllowedAceEx(pdaclNew, ACL_REVISION, aceHeader_Flags,dwMask,(PSID) &(pAce->SidStart)))   
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
           }
            else if (pAceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
            {
                dwMask = pAce->Mask;
                if (ACCESS_DENIED_ACE_TYPE == iAceType)
                {
                    // If an ACE for our SID exists, we just need to bump
                    // up the access level instead of creating a new ACE
                    if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
                    {
                        dwMask = dwAccessMask | pAce->Mask;
                    }
                }
                if (!AddAccessDeniedAceEx(pdaclNew, ACL_REVISION, pAce->Header.AceFlags,dwMask,(PSID) &(pAce->SidStart)))   
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }
            else
            {
                // copy denied or audit ace.
                if (!AddAce(pdaclNew, ACL_REVISION, 0xFFFFFFFF,pAce, pAceHeader->AceSize ))
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }

            //iisDebugOut((LOG_TYPE_TRACE, _T("OrgAce[%d]=0x%x\n"),i,pAce->Header.AceFlags));
        }
    } 

    // Add a new ACE for our SID if one was not already present
    if ( (!fAceForGroupPresent) && (ACCESS_ALLOWED_ACE_TYPE == iAceType) )
    {
        if (!AddAccessAllowedAce(pdaclNew, ACL_REVISION, dwAccessMask,psidGroup)) 
        {  
            dwError = GetLastError();  
            goto ErrorExit; 
        }
    }

    // change the header on an existing ace to have inherit
    for (i = 0; i < pdaclNew->AceCount; i++)
    {
        if (!GetAce(pdaclNew, i, (LPVOID *) &pAce))
        {
            return ( GetLastError());   
        }

        // CONTAINER_INHERIT_ACE = Other containers that are contained by the primary object inherit the entry.  
        // INHERIT_ONLY_ACE = The ACE does not apply to the primary object to which the ACL is attached, but objects contained by the primary object inherit the entry.  
        // NO_PROPAGATE_INHERIT_ACE = The OBJECT_INHERIT_ACE and CONTAINER_INHERIT_ACE flags are not propagated to an inherited entry. 
        // OBJECT_INHERIT_ACE = Noncontainer objects contained by the primary object inherit the entry.  
        // SUB_CONTAINERS_ONLY_INHERIT = Other containers that are contained by the primary object inherit the entry. This flag corresponds to the CONTAINER_INHERIT_ACE flag. 
        // SUB_OBJECTS_ONLY_INHERIT = Noncontainer objects contained by the primary object inherit the entry. This flag corresponds to the OBJECT_INHERIT_ACE flag. 
        // SUB_CONTAINERS_AND_OBJECTS_INHERIT = Both containers and noncontainer objects that are contained by the primary object inherit the entry. This flag corresponds to the combination of the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags. 

        //iisDebugOut((LOG_TYPE_TRACE, _T("NewAce[%d]=0x%x\n"),i,pAce->Header.AceFlags));

        // if it's our SID, then change the header to be inherited
        if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
        {
            pAce->Header.AceFlags |= dwInheritMask;
        }
    }

    if (TRUE == DontInheritFromParentAndOverWriteAccess)
    {
        // Reorder ace's
        // -------------
        // ugly.
        dwError = ReOrderACL(&pdaclNew);
        if (ERROR_SUCCESS != dwError)
        {
            goto ErrorExit;
        }
    }
    
    
    // check if everything went ok 
    if (!IsValidAcl(pdaclNew)) 
    {
        dwError = ERROR_INVALID_ACL;
        goto ErrorExit; 
    }

    // now set security descriptor DACL
    if (!SetSecurityDescriptorDacl(psdAbsolute, TRUE, pdaclNew, fDaclDefaulted)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(psdAbsolute)) 
    {
        dwError = ERROR_INVALID_SECURITY_DESCR;
        goto ErrorExit; 
    }

    // now set the reg key security (this will overwrite any existing security)
    bRes = SetFileSecurity(pszFile,(SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION),psdAbsolute);
    if (bRes)
    {
        dwError = ERROR_SUCCESS;
    }

    if (ppsd)
    {
        *ppsd = psdRelative;
    }

ErrorExit: 
    // free memory
    if (psdAbsolute)  
    {
        free (psdAbsolute); 
        if (pdaclNew)
        {
            //free((VOID*) pdaclNew); 
            LocalFree(pdaclNew);pdaclNew=NULL;
        }
    }

    return dwError;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetAccessOnRegKey
//
//  Purpose:    Adds access for a specified SID to a registry key
//
//  Arguments:
//      hkey         [in]  The registry key that will receive the
//                            modified security descriptor
//      psidGroup    [in]  The SID (in self-relative mode) that will be 
//                            granted access to the key 
//      dwAccessMask [in]  The access level to grant
//      ppsd         [out] The previous security descriptor
//
//  Returns:    DWORD. ERROR_SUCCESS or a failure code from winerror.h
//
//+--------------------------------------------------------------------------
DWORD 
SetAccessOnRegKey(HKEY hkey, PSID psidGroup,
                                DWORD dwAccessMask,
                                DWORD dwInheritMask,
                                PSECURITY_DESCRIPTOR* ppsd)
{ 
    PSECURITY_DESCRIPTOR        psdAbsolute = NULL;
    PACL                        pdacl;
    DWORD                       cbSecurityDescriptor = 0;
    DWORD                       dwSecurityDescriptorRevision;
    DWORD                       cbDacl = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PACL                        pdaclNew = NULL; 
    DWORD                       cbAddDaclLength = 0; 
    BOOL                        fAceFound = FALSE;
    BOOL                        fHasDacl  = FALSE;
    BOOL                        fDaclDefaulted = FALSE; 
    ACCESS_ALLOWED_ACE*         pAce;
    DWORD                       i;
    BOOL                        fAceForGroupPresent = FALSE;
    DWORD                       dwMask;
    PSECURITY_DESCRIPTOR        psdRelative = NULL;
    DWORD                       cbSize = 0;

    // Get the current security descriptor for hkey
    //
    DWORD dwError = RegGetKeySecurity(hkey, DACL_SECURITY_INFORMATION, psdRelative, &cbSize);

    if (ERROR_INSUFFICIENT_BUFFER == dwError)
    {
        psdRelative = malloc(cbSize);
        if (!psdRelative)
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }
        
        dwError = RegGetKeySecurity(hkey, DACL_SECURITY_INFORMATION, psdRelative, &cbSize);
    }

    // get security descriptor control from the security descriptor 
    if ( (!psdRelative) ||
         (dwError != ERROR_SUCCESS) ||
         (!GetSecurityDescriptorControl(psdRelative, (PSECURITY_DESCRIPTOR_CONTROL) &sdc,(LPDWORD) &dwSecurityDescriptorRevision))
       )
    {
         return (GetLastError());
    }

    // check if DACL is present 
    if (SE_DACL_PRESENT & sdc) 
    {
        ACE_HEADER *pAceHeader;

        // get dacl   
        if (!GetSecurityDescriptorDacl(psdRelative, (LPBOOL) &fHasDacl,(PACL *) &pdacl, (LPBOOL) &fDaclDefaulted))
        {
            return ( GetLastError());
        }

        // check if pdacl is null
        // if it is then security is wide open -- this could be a fat drive.
        if (NULL == pdacl)
        {
            return ERROR_SUCCESS;
        }

        // get dacl length  
        cbDacl = pdacl->AclSize;
        // now check if SID's ACE is there  
        for (i = 0; i < pdacl->AceCount; i++)  
        {
            if (!GetAce(pdacl, i, (LPVOID *) &pAce))
            {
                return ( GetLastError());   
            }

            pAceHeader = (ACE_HEADER *)pAce;
            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                // check if group sid is already there
                if (EqualSid((PSID) &(pAce->SidStart), psidGroup))    
                {
                    // If the correct access is present, return success
                    if ((pAce->Mask & dwAccessMask) == dwAccessMask)
                    {
                        return ERROR_SUCCESS;
                    }
                    fAceForGroupPresent = TRUE;
                    break;  
                }
            }
        }
        // if the group did not exist, we will need to add room
        // for another ACE
        if (!fAceForGroupPresent)  
        {
            // get length of new DACL  
            cbAddDaclLength = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psidGroup); 
        }
    } 
    else
    {
        // get length of new DACL
        cbAddDaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid (psidGroup);
    }


    // get memory needed for new DACL
    //pdaclNew = (PACL) malloc (cbDacl + cbAddDaclLength);
    pdaclNew = (PACL) LocalAlloc(LMEM_FIXED, cbDacl + cbAddDaclLength);
    if (!pdaclNew)
    {
        return (GetLastError()); 
    }

    // get the sd length
    cbSecurityDescriptor = GetSecurityDescriptorLength(psdRelative); 

    // get memory for new SD
    psdAbsolute = (PSECURITY_DESCRIPTOR) malloc(cbSecurityDescriptor + cbAddDaclLength);
    if (!psdAbsolute) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // change self-relative SD to absolute by making new SD
    if (!InitializeSecurityDescriptor(psdAbsolute, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // init new DACL
    if (!InitializeAcl(pdaclNew, cbDacl + cbAddDaclLength, ACL_REVISION)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // now add in all of the ACEs into the new DACL (if org DACL is there)
    if (SE_DACL_PRESENT & sdc) 
    {
        ACE_HEADER *pAceHeader;

        for (i = 0; i < pdacl->AceCount; i++)
        {
            // get ace from original dacl
            if (!GetAce(pdacl, i, (LPVOID*) &pAce))
            {
                dwError = GetLastError();    
                goto ErrorExit;   
            }

            pAceHeader = (ACE_HEADER *)pAce;
            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                // If an ACE for our SID exists, we just need to bump
                // up the access level instead of creating a new ACE
                //
                if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
                {
                    dwMask = dwAccessMask | pAce->Mask;
                }
                else
                {
                    dwMask = pAce->Mask;
                }

                //iisDebugOut((LOG_TYPE_TRACE, _T("OrgAce[%d]=0x%x\n"),i,pAce->Header.AceFlags));

                // now add ace to new dacl   
                if (!AddAccessAllowedAceEx(pdaclNew, ACL_REVISION, pAce->Header.AceFlags,dwMask,(PSID) &(pAce->SidStart)))   
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }
            else
            {
                // copy denied or audit ace.
                if (!AddAce(pdaclNew, ACL_REVISION, 0xFFFFFFFF, pAce, pAceHeader->AceSize ))
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }
        } 
    } 

    // Add a new ACE for our SID if one was not already present
    if (!fAceForGroupPresent)
    {
        // now add new ACE to new DACL
        if (!AddAccessAllowedAce(pdaclNew, ACL_REVISION, dwAccessMask,psidGroup)) 
        {  
            dwError = GetLastError();  
            goto ErrorExit; 
        }
    }
    
    // change the header on an existing ace to have inherit
    for (i = 0; i < pdaclNew->AceCount; i++)
    {
        if (!GetAce(pdaclNew, i, (LPVOID *) &pAce))
        {
            return ( GetLastError());   
        }
        // CONTAINER_INHERIT_ACE = Other containers that are contained by the primary object inherit the entry.  
        // INHERIT_ONLY_ACE = The ACE does not apply to the primary object to which the ACL is attached, but objects contained by the primary object inherit the entry.  
        // NO_PROPAGATE_INHERIT_ACE = The OBJECT_INHERIT_ACE and CONTAINER_INHERIT_ACE flags are not propagated to an inherited entry. 
        // OBJECT_INHERIT_ACE = Noncontainer objects contained by the primary object inherit the entry.  
        // SUB_CONTAINERS_ONLY_INHERIT = Other containers that are contained by the primary object inherit the entry. This flag corresponds to the CONTAINER_INHERIT_ACE flag. 
        // SUB_OBJECTS_ONLY_INHERIT = Noncontainer objects contained by the primary object inherit the entry. This flag corresponds to the OBJECT_INHERIT_ACE flag. 
        // SUB_CONTAINERS_AND_OBJECTS_INHERIT = Both containers and noncontainer objects that are contained by the primary object inherit the entry. This flag corresponds to the combination of the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags. 

        //iisDebugOut((LOG_TYPE_TRACE, _T("NewAce[%d]=0x%x\n"),i,pAce->Header.AceFlags));

        // if it's our SID, then change the header to be inherited
        if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
        {
            //pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | INHERITED_ACE;
            //pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | dwInheritMask;
            pAce->Header.AceFlags |= dwInheritMask;
        }
    }

    // ugly.
    dwError = ReOrderACL(&pdaclNew);
    if (ERROR_SUCCESS != dwError)
    {
        goto ErrorExit;
    }

    // check if everything went ok 
    if (!IsValidAcl(pdaclNew)) 
    {
        dwError = ERROR_INVALID_ACL;
        goto ErrorExit; 
    }

    // now set security descriptor DACL
    if (!SetSecurityDescriptorDacl(psdAbsolute, TRUE, pdaclNew, fDaclDefaulted)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(psdAbsolute)) 
    {
        dwError = ERROR_INVALID_SECURITY_DESCR;
        goto ErrorExit; 
    }

    // now set the reg key security (this will overwrite any
    // existing security)
    dwError = RegSetKeySecurity(hkey, (SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION), psdAbsolute);

    if (ppsd)
    {
        *ppsd = psdRelative;
    }
ErrorExit: 
    // free memory
    if (psdAbsolute)  
    {
        free (psdAbsolute); 
        if (pdaclNew)
        {
            //free((VOID*) pdaclNew); 
            LocalFree(pdaclNew);pdaclNew=NULL;

        }
    }

    return dwError;
}



BOOL
AddUserAccessToSD(
    IN  PSECURITY_DESCRIPTOR pSd,
    IN  PSID  pSid,
    IN  DWORD NewAccess,
    IN  UCHAR TheAceType,
    OUT PSECURITY_DESCRIPTOR *ppSdNew
    )
{
    ULONG i;
    BOOL bReturn = FALSE;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
    DWORD NewAclLength;
    ACCESS_ALLOWED_ACE* OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    BOOL fAceForGroupPresent = FALSE;
    DWORD dwMask;

    OldSD = pSd;

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddUserAccessToSD start\n")));

    // only do if the ace is allowed/denied
    if (ACCESS_ALLOWED_ACE_TYPE != TheAceType && ACCESS_DENIED_ACE_TYPE != TheAceType)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("AddUserAccessToSD useless param\n")));
        goto AddUserAccessToSD_Exit;
    }

    // Convert SecurityDescriptor to absolute format. It generates
    // a new SecurityDescriptor for its output which we must free.
    if ( !MakeAbsoluteCopyFromRelative(OldSD, &NewSD) ) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MakeAbsoluteCopyFromRelative failed\n")));
        goto AddUserAccessToSD_Exit;

    }

    // Must get DACL pointer from new (absolute) SD
    if(!GetSecurityDescriptorDacl(NewSD,&DaclPresent,&Dacl,&DaclDefaulted)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetSecurityDescriptorDacl failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;

    }

    // If no DACL, no need to add the user since no DACL
    // means all accesss
    if( !DaclPresent ) 
    {
        bReturn = TRUE;
        goto AddUserAccessToSD_Exit;
    }

    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows all access to the object.
    if( Dacl == NULL ) 
    {
        bReturn = TRUE;
        goto AddUserAccessToSD_Exit;
    }

    // Get the current ACL's size
    if( !GetAclInformation(Dacl,&AclInfo,sizeof(AclInfo),AclSizeInformation) ) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetAclInformation failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;
    }

    // Check if access is already there
    // --------------------------------
    // Check to see if this SID already exists in there
    // if it does (and it has the right access we want) then forget it, we don't have to do anything more.
    for (i = 0; i < AclInfo.AceCount; i++)  
    {
        ACE_HEADER *pAceHeader;
        ACCESS_ALLOWED_ACE* pAce = NULL;

        if (!GetAce(Dacl, i, (LPVOID *) &pAce))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("GetAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }

        pAceHeader = (ACE_HEADER *)pAce;

        // check if group sid is already there
        if (EqualSid((PSID) &(pAce->SidStart), pSid))
        {
            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                // If the correct access is present, return success
                if ((pAce->Mask & NewAccess) == NewAccess)
                {
                    //iisDebugOut((LOG_TYPE_TRACE, _T("AddUserAccessToSD:correct access already present. Exiting,1=0x%x,2=0x%x,3=0x%x\n"),pAce->Mask,NewAccess,(pAce->Mask & NewAccess)));
                    bReturn = TRUE;
                    goto AddUserAccessToSD_Exit;
                }
                else
                {
                    // the ace that exist doesn't have the permissions that we want.
                    // If an ACE for our SID exists, we just need to bump
                    // up the access level instead of creating a new ACE
                    fAceForGroupPresent = TRUE;
                }
            }
            break;  
        }
    }
    
    // If we have to create a new ACE
    // (because our user isn't listed in the existing ACL)
    // then let's Create a new ACL to put the new access allowed ACE on
    // --------------------------------
    if (!fAceForGroupPresent)
    {
        NewAclLength = sizeof(ACL) +
                       sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                       GetLengthSid( pSid );

        NewAceDacl = (PACL) LocalAlloc( LMEM_FIXED, NewAclLength );
        if ( NewAceDacl == NULL ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("LocalAlloc failed\n")));
            goto AddUserAccessToSD_Exit;
        }

        if(!InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION )) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("InitializeAcl failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }

        if (ACCESS_DENIED_ACE_TYPE == TheAceType)
        {
            Result = AddAccessDeniedAce(NewAceDacl,ACL_REVISION,NewAccess,pSid);
        }
        else 
        {
            Result = AddAccessAllowedAce(NewAceDacl,ACL_REVISION,NewAccess,pSid);
        }
        if( !Result ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }
        // Grab the 1st ace from the Newly created Dacl
        if(!GetAce( NewAceDacl, 0, (void **)&NewAce )) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("GetAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }

        // add CONTAINER_INHERIT_ACE TO AceFlags
        //NewAce->AceFlags |= CONTAINER_INHERIT_ACE;

        Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    }
    else
    {
        Length = AclInfo.AclBytesInUse;
    }

    // Allocate new DACL
    NewDacl = (PACL) LocalAlloc( LMEM_FIXED, Length );
    if(NewDacl == NULL) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("LocalAlloc failed\n")));
        goto AddUserAccessToSD_Exit;
    }
    if(!InitializeAcl( NewDacl, Length, ACL_REVISION )) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("InitializeAcl failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;
    }

    // Insert new ACE at the front of the new DACL
    if (!fAceForGroupPresent)
    {
        if(!AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize )) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }
    }

    // ----------------------------------------
    // Read thru the old Dacl and get the ACE's
    // add it to the new Dacl
    // ----------------------------------------
    for ( i = 0; i < AclInfo.AceCount; i++ ) 
    {
        ACE_HEADER *pAceHeader;

        Result = GetAce( Dacl, i, (LPVOID*) &OldAce );
        if( !Result ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("GetAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }

        pAceHeader = (ACE_HEADER *)OldAce;

        // If an ACE for our SID exists, we just need to bump
        // up the access level instead of creating a new ACE
        //
        if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            dwMask = OldAce->Mask;
            if (fAceForGroupPresent)
            {
                if (EqualSid((PSID) &(OldAce->SidStart), pSid))
                {
                    dwMask = NewAccess | OldAce->Mask;
                }
            }

            // now add ace to new dacl   
            Result = AddAccessAllowedAceEx(NewDacl, ACL_REVISION, OldAce->Header.AceFlags,dwMask,(PSID) &(OldAce->SidStart));
            if( !Result ) 
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedAceEx failed with 0x%x\n"),GetLastError()));
                goto AddUserAccessToSD_Exit;
            }
        }
        else
        {
            // copy denied or audit ace.
            if (!AddAce(NewDacl, ACL_REVISION, 0xFFFFFFFF,OldAce, pAceHeader->AceSize ))
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("AddAce failed with 0x%x\n"),GetLastError()));
                goto AddUserAccessToSD_Exit;
            }
        }
    }


    // Set new DACL for Security Descriptor
    if(!SetSecurityDescriptorDacl(NewSD,TRUE,NewDacl,FALSE)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetSecurityDescriptorDacl failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;
    }

    // The new SD is in absolute format. change it to Relative before we pass it back
    cboutpSD = 0;
    MakeSelfRelativeSD(NewSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GlobalAlloc failed\n")));
        goto AddUserAccessToSD_Exit;
    }

    if (!MakeSelfRelativeSD(NewSD, outpSD, &cboutpSD))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MakeSelfRelativeSD failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;
    }

    // The new SD is passed back in relative format,
    *ppSdNew = outpSD;

    bReturn = TRUE;

AddUserAccessToSD_Exit:
    if (NewSD){free( NewSD );NewSD = NULL;}
    if (NewDacl){LocalFree( NewDacl );NewDacl = NULL;}
    if (NewAceDacl){LocalFree( NewAceDacl );NewAceDacl = NULL;}
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddUserAccessToSD end\n")));
    return bReturn;
}

DWORD SetRegistryKeySecurityAdmin(HKEY hkey, DWORD samDesired,PSECURITY_DESCRIPTOR* ppsdOld)
{
    PSID                     psid;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    DWORD                    dwError = ERROR_SUCCESS;

    // Get sid for the local Administrators group
    if (!AllocateAndInitializeSid(&sidAuth, 2,SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,0, 0, 0, 0, 0, 0, &psid) ) 
    {
        dwError = GetLastError();
    }

    if (ERROR_SUCCESS == dwError)
    {
        // Add all access privileges for the local administrators group
        dwError = SetAccessOnRegKey(hkey, psid, samDesired, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | INHERITED_ACE, ppsdOld);
    }

    return dwError;
}


DWORD SetRegistryKeySecurity(
    IN  HKEY                    hkeyRootKey,
    IN  LPCTSTR                 szKeyPath,
    IN  LPCTSTR                 szPrincipal,
    IN  DWORD                   dwAccessMask,
    IN  DWORD                   dwInheritMask,
    IN  BOOL                    bDoSubKeys,
    IN  LPTSTR                  szExclusiveList
)
{
    DWORD    dwStatus;
    HKEY     hkeyThisKey;
    DWORD    dwKeyIndex;
    DWORD    dwSubKeyLen;
    TCHAR    szSubKeyName[_MAX_PATH];
    FILETIME FileTime;
    TCHAR    *szExclusiveStart;
    BOOL     fSetSecurityRec;

    dwStatus = RegOpenKeyEx(hkeyRootKey,szKeyPath,0L,KEY_ALL_ACCESS,&hkeyThisKey);
    if (ERROR_SUCCESS == dwStatus)
    {
        PSID principalSID = NULL;
        BOOL bWellKnownSID = FALSE;
        if (ERROR_SUCCESS == GetPrincipalSID((LPTSTR) szPrincipal, &principalSID, &bWellKnownSID))
        {
            PSECURITY_DESCRIPTOR psd = NULL;
            SetAccessOnRegKey(hkeyThisKey,principalSID,dwAccessMask,dwInheritMask,&psd);
            if (psd) {free(psd);}
            if (bDoSubKeys)
            {
                dwKeyIndex = 0;
                dwSubKeyLen = sizeof(szSubKeyName) / sizeof(TCHAR);

                while (RegEnumKeyEx (hkeyThisKey,dwKeyIndex,szSubKeyName,&dwSubKeyLen,NULL,NULL,NULL,&FileTime) == ERROR_SUCCESS) 
                {
                    // subkey found so set subkey security
                    // attach on the inherited ace attribute since everything under this will be inherited
                    dwInheritMask |= INHERITED_ACE;

                    fSetSecurityRec = TRUE;

                    szExclusiveStart = szExclusiveList;
                    while ( szExclusiveStart != NULL )
                    {
                        szExclusiveStart = _tcsstr(szExclusiveStart,szSubKeyName);

                        // If we have found the substring, and the character after it is a NULL terminator or a ',', and
                        // it is at the begining of the string, or it had a , before it, then it is a match.
                        if ( ( szExclusiveStart != NULL ) &&
                             ( ( *(szExclusiveStart  + dwSubKeyLen) == '\0' ) || ( *(szExclusiveStart  + dwSubKeyLen) == ',' ) ) &&
                             ( ( szExclusiveStart == szExclusiveList) || (*(szExclusiveStart - 1) == ',') ) 
                             )
                        {
                            fSetSecurityRec = FALSE;
                            break;
                        }

                        // Increment to move past current search result
                        if (szExclusiveStart)
                        {
                            szExclusiveStart = szExclusiveStart + dwSubKeyLen;
                        }
                    }

                    if ( fSetSecurityRec )
                    {
                        dwStatus = SetRegistryKeySecurity(hkeyThisKey,szSubKeyName,szPrincipal,dwAccessMask,dwInheritMask,bDoSubKeys,szExclusiveList);
                    }

                    // set variables for next call
                    dwKeyIndex++;
                    dwSubKeyLen = sizeof(szSubKeyName) / sizeof(TCHAR);
                }
            }
        }
        RegCloseKey(hkeyThisKey);
    }
    return dwStatus;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\setuputl.h ===
DWORD   atodw(LPCTSTR lpszData);
int     CreateAnEmptyFile(CString szTheFullPath);
BOOL    CleanPathString(LPTSTR szPath);
BOOL    CreateLayerDirectory(CString &str);
BOOL    ReturnFileNameOnly(LPCTSTR lpFullPath, LPTSTR lpReturnFileName);
BOOL    ReturnFilePathOnly(LPCTSTR lpFullPath, LPTSTR lpReturnPathOnly);
BOOL    IsFileExist(LPCTSTR szFile);
BOOL    IsFileExist_NormalOrCompressed(LPCTSTR szFile);
BOOL    IsValidDriveType(LPTSTR szRoot);
BOOL    IsValidDirectoryName(LPTSTR lpszPath);
int     IsThisDriveNTFS(IN LPTSTR FileName);
void    MakePath(LPTSTR lpPath);
void    AddPath(LPTSTR szPath, LPCTSTR szName );
CString AddPath(CString szPath, LPCTSTR szName );
BOOL    AppendDir(LPCTSTR szParentDir, LPCTSTR szSubDir, LPTSTR szResult);
BOOL    InetDeleteFile(LPCTSTR szFileName);
BOOL    InetCopyFile( LPCTSTR szSrc, LPCTSTR szDest);
void    InetGetFilePath(LPCTSTR szFile, LPTSTR szPath);
BOOL    RecRemoveEmptyDir(LPCTSTR szName);
BOOL    RecRemoveDir(LPCTSTR szName, BOOL bRemoveDirectoryItself = TRUE );
BOOL    VerCmp(LPTSTR szSrcVerString, LPTSTR szDestVerString);
int     InstallInfSection_NoFiles(HINF InfHandle,TCHAR szINFFileName[],TCHAR szSectionName[]);
int     InstallInfSection(HINF InfHandle,TCHAR szINFFileName[],TCHAR szSectionName[]);
DWORD   GrantUserAccessToFile(IN LPTSTR FileName,IN LPTSTR TrusteeName);
void    MakeSureDirAclsHaveAtLeastRead(LPTSTR lpszDirectoryPath);
DWORD   SetAccessOnFile(IN LPTSTR FileName, BOOL bDoForAdmin);
int     IsFileLessThanThisVersion(IN LPCTSTR lpszFullFilePath, IN DWORD dwNtopMSVer, IN DWORD dwNtopLSVer);
void    DeleteFilesWildcard(TCHAR *szDir, TCHAR *szFileName);
DWORD   ReturnFileSize(LPCTSTR myFileName);
CString ReturnUniqueFileName(CString csInputFullName);
DWORD RemovePrincipalFromFileAcl(IN TCHAR *pszFile,IN  LPTSTR szPrincipal);

#ifndef _CHICAGO_
    DWORD SetDirectorySecurity(IN LPCTSTR szDirPath,IN LPCTSTR szPrincipal,IN INT iAceType,IN DWORD dwAccessMask,IN DWORD dwInheritMask,BOOL DontInheritFromParentAndOverWriteAccess);
    DWORD SetRegistryKeySecurity(IN HKEY hkeyRootKey,IN LPCTSTR szKeyPath,IN LPCTSTR szPrincipal,IN DWORD dwAccessMask,IN DWORD dwInheritMask,IN BOOL bDoSubKeys, IN LPTSTR szExclusiveList = NULL);
    DWORD SetRegistryKeySecurityAdmin(HKEY hkey, DWORD samDesired,PSECURITY_DESCRIPTOR* ppsdOld);
    DWORD SetAccessOnDirOrFile(IN TCHAR *pszFile,PSID psidGroup,INT iAceType,DWORD dwAccessMask,DWORD dwInheritMask,PSECURITY_DESCRIPTOR* ppsd,BOOL DontInheritFromParentAndOverWriteAccess);
    DWORD SetAccessOnRegKey(HKEY hkey, PSID psidGroup,DWORD dwAccessMask,DWORD dwInheritMask,PSECURITY_DESCRIPTOR* ppsd);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\setpass.cpp ===
#include "stdafx.h"
#include "setpass.h"

#ifndef _CHICAGO_

#include "inetinfo.h"
#include "inetcom.h"

//
//  Quick macro to initialize a unicode string
//

#define InitUnicodeString( pUnicode, pwch )                                \
            {                                                              \
                (pUnicode)->Buffer    = (PWCH)pwch;                      \
                (pUnicode)->Length    = (pwch == NULL )? 0: (wcslen( pwch ) * sizeof(WCHAR));    \
                (pUnicode)->MaximumLength = (pUnicode)->Length + sizeof(WCHAR);\
            }

BOOL GetSecret(
    IN LPCTSTR        pszSecretName,
    OUT TSTR          *strSecret
    )
/*++
    Description:

        Retrieves the specified unicode secret

    Arguments:

        pszSecretName - LSA Secret to retrieve
        pbufSecret - Receives found secret

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL              fResult;
    NTSTATUS          ntStatus;
    PUNICODE_STRING   punicodePassword = NULL;
    UNICODE_STRING    unicodeSecret;
    LSA_HANDLE        hPolicy;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR wszSecretName[_MAX_PATH];

    if ( ( _tcslen( wszSecretName ) / sizeof (TCHAR) ) >= MAXUSHORT )
    {
      // Lets check to make sure that the implicit conversion in
      // InitUnicodeString further down is not a problem
      return FALSE;
    }

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszSecretName, pszSecretName);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)pszSecretName, -1, (LPWSTR)wszSecretName, _MAX_PATH);
#endif

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

#pragma warning( disable : 4244 )
    // InitUnicodeString is a #def, that does a implicit conversion from size_t to 
    // USHORT.  Since I can not change the #def, I am disabling the warning
    InitUnicodeString( &unicodeSecret, wszSecretName );
#pragma warning( default : 4244 )

    //
    //  Query the secret value.
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    if( NT_SUCCESS(ntStatus) && (NULL !=punicodePassword))
    {
        DWORD cbNeeded;

        cbNeeded = punicodePassword->Length + sizeof(WCHAR);

        strSecret->MarkSensitiveData( TRUE );

        if ( !strSecret->Resize( cbNeeded ) )
        {
            ntStatus = STATUS_NO_MEMORY;
            goto Failure;
        }

        memcpy( strSecret->QueryStr(),
                punicodePassword->Buffer,
                punicodePassword->Length );

        *((WCHAR *) strSecret->QueryStr() +
           punicodePassword->Length / sizeof(WCHAR)) = L'\0';

        SecureZeroMemory( punicodePassword->Buffer,
                       punicodePassword->MaximumLength );
    }
    else if ( !NT_SUCCESS(ntStatus) )
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

Failure:

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    if( punicodePassword != NULL )
    {
        LsaFreeMemory( (PVOID)punicodePassword );
    }

    LsaClose( hPolicy );

    if ( !fResult )
        SetLastError( LsaNtStatusToWinError( ntStatus ));

    return fResult;

}

BOOL GetAnonymousSecret(
    IN LPCTSTR      pszSecretName,
    OUT TSTR        *pstrPassword
    )
{
  LPWSTR  pwsz = NULL;
  BOOL    bRet = FALSE;
  BUFFER  bufSecret;

  // Mark this password as sensitive data
  pstrPassword->MarkSensitiveData( TRUE );

  if ( !GetSecret( pszSecretName, pstrPassword ))
  {
    return FALSE;
  }

  return TRUE;
}

BOOL GetRootSecret(
    IN LPCTSTR pszRoot,
    IN LPCTSTR pszSecretName,
    OUT LPTSTR pszPassword
    )
/*++
    Description:

        This function retrieves the password for the specified root & address

    Arguments:

        pszRoot - Name of root + address in the form "/root,<address>".
        pszSecretName - Virtual Root password secret name
        pszPassword - Receives password, must be at least PWLEN+1 characters

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    TSTR   strSecret;
    LPWSTR pwsz;
    LPWSTR pwszTerm;
    LPWSTR pwszNextLine;
    WCHAR wszRoot[_MAX_PATH];


    if ( !GetSecret( pszSecretName, &strSecret ))
        return FALSE;

    pwsz = strSecret.QueryStr();

    //
    //  Scan the list of roots looking for a match.  The list looks like:
    //
    //     <root>,<address>=<password>\0
    //     <root>,<address>=<password>\0
    //     \0
    //

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszRoot, pszRoot);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)pszRoot, -1, (LPWSTR)wszRoot, _MAX_PATH);
#endif

    while ( *pwsz )
    {
        pwszNextLine = pwsz + wcslen(pwsz) + 1;

        pwszTerm = wcschr( pwsz, L'=' );

        if ( !pwszTerm )
            goto NextLine;

        *pwszTerm = L'\0';

        if ( !_wcsicmp( wszRoot, pwsz ) )
        {
            //
            //  We found a match, copy the password
            //

#if defined(UNICODE) || defined(_UNICODE)
            _tcscpy(pszPassword, pwszTerm+1);
#else
            cch = WideCharToMultiByte( CP_ACP,
                                       WC_COMPOSITECHECK,
                                       pwszTerm + 1,
                                       -1,
                                       pszPassword,
                                       PWLEN + sizeof(CHAR),
                                       NULL,
                                       NULL );
            pszPassword[cch] = '\0';
#endif
            return TRUE;
        }

NextLine:
        pwsz = pwszNextLine;
    }

    //
    //  If the matching root wasn't found, default to the empty password
    //

    *pszPassword = _T('\0');

    return TRUE;
}


//
// Saves password in LSA private data (LSA Secret).
//
DWORD SetSecret(IN LPCTSTR pszKeyName,IN LPCTSTR pszPassword)
{
  DWORD       dwError = ERROR_NOT_ENOUGH_MEMORY;
	LSA_HANDLE  hPolicy = NULL;
  DWORD       dwPasswordSize  = wcslen(pszPassword) * sizeof(WCHAR);
  DWORD       dwKeyNameSize   = wcslen(pszKeyName) * sizeof(WCHAR);

  if ( ( dwPasswordSize >= MAXUSHORT ) ||
       ( dwKeyNameSize >= MAXUSHORT )
     )
  {
    return dwError;
  }

	try
	{
		LSA_OBJECT_ATTRIBUTES lsaoa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		dwError = LsaNtStatusToWinError( LsaOpenPolicy(NULL, &lsaoa, POLICY_CREATE_SECRET, &hPolicy) );

		if ( dwError != ERROR_SUCCESS )
		{
      return dwError;
		}

    LSA_UNICODE_STRING lsausKeyName = { (USHORT) dwKeyNameSize, 
                                        (USHORT) dwKeyNameSize, 
                                         const_cast<PWSTR>(pszKeyName) };
    LSA_UNICODE_STRING lsausPrivateData = { (USHORT) dwPasswordSize, 
                                            (USHORT) dwPasswordSize, 
                                            const_cast<PWSTR>(pszPassword) };
        
		dwError = LsaNtStatusToWinError( LsaStorePrivateData(hPolicy, &lsausKeyName, &lsausPrivateData) );
	}
	catch (...)
	{
		dwError = ERROR_NOT_ENOUGH_MEMORY;
	}

	if (hPolicy)
	{
		LsaClose(hPolicy);
	}

  return dwError;
}

#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\shellutl.h ===
#include "stdafx.h"
void GetErrorMsg(int errCode, LPCTSTR szExtraMsg);
void MyLoadString(int nID, CString &csResult);
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, UINT style);
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, LPCTSTR lpszTheTitle, UINT style);
int MyMessageBox(HWND hWnd, CString csTheMessage, HRESULT iTheErrorCode, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, int iTheErrorCode, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever, int iTheErrorCode, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever1, LPCTSTR lpszTheFileNameOrWhatever2, int iTheErrorCode, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever1, LPCTSTR lpszTheFileNameOrWhatever2, LPCTSTR lpszTheFileNameOrWhatever3,int iTheErrorCode, UINT style);
int MyMessageBoxArgs(HWND hWnd, TCHAR *pszfmt, ...);
HRESULT MySetLinkInfoTip(LPCTSTR lpszLink, LPCTSTR lpszDescription);
HRESULT MyQueryLink(LPCTSTR lpszLink, LPTSTR lpszProgram, LPTSTR lpszArgs, LPTSTR lpszDir, LPTSTR lpszIconPath, int *piIconIndex);
HRESULT MyCreateLink(LPCTSTR lpszProgram, LPCTSTR lpszArgs, LPCTSTR lpszLink, LPCTSTR lpszDir, LPCTSTR lpszIconPath, int iIconIndex, LPCTSTR lpszDescription);
BOOL MyDeleteLink(LPTSTR lpszShortcut);
void MyMoveLink(LPCTSTR lpszItemDesc, LPCTSTR lpszOldGroup, LPCTSTR lpszNewGroup);
void MyGetSendToPath(LPTSTR szPath);
void MyGetDeskTopPath(LPTSTR szPath);
void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath);
BOOL MyAddGroup(LPCTSTR szGroupName);
BOOL MyIsGroupEmpty(LPCTSTR szGroupName);
BOOL MyDeleteGroup(LPCTSTR szGroupName);
void MyAddSendToItem(LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir);
void MyDeleteLinkWildcard(TCHAR *szDir, TCHAR *szFileName);
void MyDeleteSendToItem(LPCTSTR szAppName);
void MyAddDeskTopItem(LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR szIconPath, int iIconIndex);
void MyDeleteDeskTopItem(LPCTSTR szAppName);
void MyDeleteDeskTopItem2(LPTSTR szSemiColonDelmitedListOfExeNames, BOOL bDeleteItsDirToo);
void MyAddItem(LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR lpszIconPath);
void MyAddItemInfoTip(LPCTSTR szGroupName, LPCTSTR szAppName, LPCTSTR szDescription);
void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName);
BOOL AddURLShortcutItem( LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szURL );
void DeleteFromGroup(LPCTSTR szGroupName, LPTSTR szApplicationExec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\setuser.h ===
#include "stdafx.h"

#ifndef _CHICAGO_
    INT  DeleteGuestUser(LPCTSTR szUsername, INT *UserWasDeleted);
    int  GetGuestUserName_SlowWay(LPWSTR lpGuestUsrName);
    int  GetGuestGrpName(LPTSTR lpGuestGrpName);
    void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String);
    DWORD OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle);
    INT  RegisterAccountToLocalGroup(LPCTSTR szAccountName, LPCTSTR szLocalGroupName, BOOL fAction);
    INT  RegisterAccountUserRights(LPCTSTR szAccountName, BOOL fAction, BOOL fSpecicaliwamaccount);
    BOOL IsUserExist( LPWSTR strUsername );
    INT  CreateUser( LPCTSTR szUsername, LPCTSTR szPassword, LPCTSTR szComment, LPCTSTR szFullName, BOOL fiWamUser,INT *NewlyCreated);
    BOOL GuestAccEnabled();
    NET_API_STATUS NetpNtStatusToApiStatus (IN NTSTATUS NtStatus);
    NET_API_STATUS UaspGetDomainId(IN LPCWSTR ServerName OPTIONAL,OUT PSAM_HANDLE SamServerHandle OPTIONAL,OUT PPOLICY_ACCOUNT_DOMAIN_INFO * AccountDomainInfo);
    NET_API_STATUS SampCreateFullSid(IN PSID DomainSid,IN ULONG Rid,OUT PSID *AccountSid);
    int  GetGuestUserNameForDomain_FastWay(LPTSTR szDomainToLookUp,LPTSTR lpGuestUsrName);
    void GetGuestUserName(LPTSTR lpOutGuestUsrName);
    int  ChangeUserPassword(IN LPTSTR szUserName, IN LPTSTR szNewPassword);
    VOID UpdateUserRights(LPCTSTR  account,LPTSTR pstrRights[],DWORD dwNofRights,INT iDoAdd);
    DWORD ModifyRightToUserAccount(LPCTSTR szAccountName, LPTSTR PrivilegeName, INT iDoAdd);
    DWORD DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName,BOOL *fHaveThatRight);
    HRESULT CreateGroup(LPCTSTR szGroupName, LPCTSTR szGroupComment, int iAction, int iFlagForSpecialGroup);
    int  CreateGroupDC(LPTSTR szGroupName, LPCTSTR szGroupComment);
    BOOL    LocalGroupExists( LPCWSTR wszGroupName );
#endif //_CHICAGO_

NET_API_STATUS NetpNtStatusToApiStatus(IN NTSTATUS NtStatus);
int GetGuestUserNameForDomain_FastWay(LPTSTR szDomainToLookUp,LPTSTR lpGuestUsrName);
void GetGuestUserName(LPTSTR lpOutGuestUsrName);
BOOL DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\setuser.cpp ===
#include "stdafx.h"
#include "svc.h"
#include "setuser.h"
#include "dcomperm.h"
#include "rights.hxx"

#ifndef _CHICAGO_
USE_USER_RIGHTS();

int GetGuestUserName_SlowWay(LPWSTR lpGuestUsrName)
{
    LPWSTR ServerName = NULL; // default to local machine
    DWORD Level = 1; // to retrieve info of all local and global normal user accounts
    DWORD Index = 0;
    DWORD EntriesRequested = 5;
    DWORD PreferredMaxLength = 1024;
    DWORD ReturnedEntryCount = 0;
    PVOID SortedBuffer = NULL;
    NET_DISPLAY_USER *p = NULL;
    DWORD i=0;
    int err = 0;
    BOOL fStatus = TRUE;

    while (fStatus) 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetQueryDisplayInformation().Start.")));
        err = NetQueryDisplayInformation(ServerName, Level, Index, EntriesRequested, PreferredMaxLength, &ReturnedEntryCount, &SortedBuffer);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetQueryDisplayInformation().End.")));
        if (err == NERR_Success)
            fStatus = FALSE;
        if (err == NERR_Success || err == ERROR_MORE_DATA) 
        {
            p = (NET_DISPLAY_USER *)SortedBuffer;
            i = 0;
            while (i < ReturnedEntryCount && (p[i].usri1_user_id != DOMAIN_USER_RID_GUEST))
                i++;
            if (i == ReturnedEntryCount) 
            {
                if (err == ERROR_MORE_DATA) 
                { // need to get more entries
                    Index = p[i-1].usri1_next_index;
                }
            }
            else 
            {
                wcscpy(lpGuestUsrName, p[i].usri1_name);
                fStatus = FALSE;
            }
        }
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
        NetApiBufferFree(SortedBuffer);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
    }

    return 0;
}

int GetGuestGrpName(LPTSTR lpGuestGrpName)
{
    LPCTSTR ServerName = NULL; // local machine
    DWORD cbName = UNLEN+1;
    TCHAR ReferencedDomainName[200];
    DWORD cbReferencedDomainName = sizeof(ReferencedDomainName) / sizeof(TCHAR);
    SID_NAME_USE sidNameUse = SidTypeUser;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID GuestsSid = NULL;

    AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS,0,0,0,0,0,0, &GuestsSid);

    LookupAccountSid(ServerName, GuestsSid, lpGuestGrpName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse);

    if (GuestsSid)
        FreeSid(GuestsSid);

    return 0;
}

void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String)
{
    DWORD StringLength;
 
    if (String == NULL) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }
 
    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

DWORD OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle)
{
    DWORD Error;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.ImpersonationLevel = SecurityImpersonation;
    QualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QualityOfService.EffectiveOnly = FALSE;

    //
    // The two fields that must be set are length and the quality of service.
    //
    ObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = 0;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    if (ServerName != NULL)
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString,ServerName);
        Server = &ServerString;
    }
    //
    // Attempt to open the policy for all access
    //
    Error = LsaOpenPolicy(Server,&ObjectAttributes,DesiredAccess,PolicyHandle);
    return(Error);

}

INT RegisterAccountToLocalGroup(LPCTSTR szAccountName, LPCTSTR szLocalGroupName, BOOL fAction)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("RegisterAccountToLocalGroup:Action=%d,Account=%s\n"), fAction, szAccountName));

    int err;

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("RegisterAccountToLocalGroup:GetPrincipalSID:fAction=%d, Account=%s, Group=%s, err=%d.\n"), fAction, szAccountName, szLocalGroupName, err));
        return (err);
    }

    // Get the localized LocalGroupName
    TCHAR szLocalizedLocalGroupName[GNLEN + 1];
    if (_tcsicmp(szLocalGroupName, _T("Guests")) == 0) 
    {
        GetGuestGrpName(szLocalizedLocalGroupName);
    }
    else 
    {
        _tcscpy(szLocalizedLocalGroupName, szLocalGroupName);
    }
    
    // transfer szLocalGroupName to WCHAR
    WCHAR wszLocalGroupName[_MAX_PATH];
#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszLocalGroupName, szLocalizedLocalGroupName);
#else
    MultiByteToWideChar( CP_ACP, 0, szLocalizedLocalGroupName, -1, wszLocalGroupName, _MAX_PATH);
#endif

    LOCALGROUP_MEMBERS_INFO_0 buf;

    buf.lgrmi0_sid = pSID;

    if (fAction) 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetLocalGroupAddMembers().Start.")));
        err = NetLocalGroupAddMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetLocalGroupAddMembers().End.")));
    }
    else 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetLocalGroupDelMembers().Start.")));
        err = NetLocalGroupDelMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetLocalGroupDelMembers().End.")));
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("RegisterAccountToLocalGroup:fAction=%d, Account=%s, Group=%s, err=%d.\n"), fAction, szAccountName, szLocalGroupName, err));

    if (pSID) 
    {
        if (bWellKnownSID)
            FreeSid (pSID);
        else
            free (pSID);
    }

    return (err);
}


VOID UpdateUserRights(LPCTSTR account,LPTSTR pstrRights[],DWORD dwNofRights,INT iDoAdd)
{
    DWORD status;
    BOOL  fPresence;
    
    for (DWORD i=0;i<dwNofRights;i++)
    {
        status = DoesUserHaveThisRight(account,pstrRights[i],&fPresence);
        if (!NT_SUCCESS(status))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("UpdateAnonymousUser:ModifyRightToUserAccount:Account=%s,righ %s,err=0x%0X.\n"), account, pstrRights[i], status));
        }
        else
        {
            if (!fPresence)
            {
                status = ModifyRightToUserAccount(account,pstrRights[i],iDoAdd);
                if (!NT_SUCCESS(status))
                {
                    if (iDoAdd)
                    {
                        iisDebugOut((LOG_TYPE_ERROR, _T("UpdateAnonymousUser:ModifyRightToUserAccount:Account=%s,righ %s,err=0x%0X.\n"), account, pstrRights[i], status));
                    }
                }
            }
        }
    }
}


DWORD ModifyRightToUserAccount(LPCTSTR szAccountName,LPTSTR PrivilegeName, INT iDoAdd)
{
    BOOL fEnabled = FALSE;
    NTSTATUS status;
	LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;

    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, (LPTSTR) PrivilegeName);

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;

    status = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (status != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("ModifyRightToUserAccount:GetPrincipalSID:Account=%s, err=0x%0X.\n"), szAccountName, status));
        return (status);
    }

    status = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( status == NERR_Success )
    {
        LSA_UNICODE_STRING *rgUserRights = NULL;

        if (iDoAdd)
        {
		    status = LsaAddAccountRights (
			    	 PolicyHandle,
				     pSID,
				     &UserRightString,
				     1);
        }
        else
        {
            status = LsaRemoveAccountRights (
                     PolicyHandle,
                     pSID,
                     FALSE,
                     &UserRightString,
                     1);
        }
    }

    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }
    if (pSID) 
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }
    return status;
}


BOOL IsUserExist( LPWSTR strUsername )
{
    BYTE *pBuffer;
    INT err = NERR_Success;
   
    do
    {
        WCHAR *pMachineName = NULL;

        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().Start.")));
        err = NetServerGetInfo( NULL, 101, &pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().End.")));
        
        //  make sure we are not backup docmain first
        if (err != NERR_Success )
        {
            // if this call returns that the service is not running, then let's just assume that the user does exist!!!!
            if (err == NERR_ServerNotStarted)
            {
                // Try to start the server service.
                err = InetStartService(_T("LanmanServer"));
                if (err == 0 || err == ERROR_SERVICE_ALREADY_RUNNING)
                {
                    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().Start.")));
                    err = NetServerGetInfo( NULL, 101, &pBuffer );
                    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().End.")));
                    if (err != NERR_Success )
                    {
                        if (err == NERR_ServerNotStarted)
                        {
                            iisDebugOut((LOG_TYPE_WARN, _T("NetServerGetInfo:failed.The Server service is not started. assume that %s exists.err=0x%x.\n"),strUsername,err));
                            err = NERR_Success;
                        }
                    }
                }
                else
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("NetServerGetInfo:failed.The Server service is not started. assume that %s exists.err=0x%x.\n"),strUsername,err));
                    err = NERR_Success;
                }
            }
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("NetServerGetInfo:failed.Do not call this on PDC or BDC takes too long.This must be a PDC or BDC.err=0x%x.\n"),err));
            }
            break;
        }

        LPSERVER_INFO_101 pInfo = (LPSERVER_INFO_101)pBuffer;
        if (( pInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) != 0 )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetGetDCName().Start.")));
            NetGetDCName( NULL, NULL, (LPBYTE*)&pMachineName );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetGetDCName().End.")));
        }

        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
        NetApiBufferFree( pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));

        if (pMachineName){iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NetUserGetInfo:[%s\\%s].Start.\n"),pMachineName,strUsername));}
        else{iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NetUserGetInfo:[(null)\\%s].Start.\n"),strUsername));}
       
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetUserGetInfo().Start.")));
        err = NetUserGetInfo( pMachineName, strUsername, 3, &pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetUserGetInfo().End.")));

        if (pMachineName){iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NetUserGetInfo:[%s\\%s].End.Ret=0x%x.\n"),pMachineName,strUsername,err));}
        else{iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NetUserGetInfo:[(null)\\%s].End.\n"),strUsername));}

        if ( err == NERR_Success )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
            NetApiBufferFree( pBuffer );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
        }
        if ( pMachineName != NULL )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
            NetApiBufferFree( pMachineName );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
        }

    } while (FALSE);

    return(err == NERR_Success );
}


//
// Create InternetGuest Account
//
INT CreateUser( LPCTSTR szUsername, LPCTSTR szPassword, LPCTSTR szComment, LPCTSTR szFullName, BOOL fiWamUser,INT *NewlyCreated)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("CreateUser: %s\n"), szUsername));
    INT iTheUserAlreadyExists = FALSE;
    INT err = NERR_Success;

    INT iTheUserIsMissingARight = FALSE;

    BYTE *pBuffer;
    WCHAR defGuest[UNLEN+1];
    TCHAR defGuestGroup[GNLEN+1];
    WCHAR wchGuestGroup[GNLEN+1];
    WCHAR wchUsername[UNLEN+1];
    WCHAR wchPassword[LM20_PWLEN+1];
    WCHAR *pMachineName = NULL;

    *NewlyCreated = 0;
    
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserName:Start.\n")));
    GetGuestUserName(defGuest);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserName:End.\n")));

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestGrpName:Start.\n")));
    GetGuestGrpName(defGuestGroup);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestGrpName:End.\n")));

    iisDebugOut((LOG_TYPE_TRACE, _T("defGuest=%s, defGuestGroup=%s\n"), defGuest, defGuestGroup));

    memset((PVOID)wchUsername, 0, sizeof(wchUsername));
    memset((PVOID)wchPassword, 0, sizeof(wchPassword));
#if defined(UNICODE) || defined(_UNICODE)
    wcsncpy(wchGuestGroup, defGuestGroup, GNLEN);
    wcsncpy(wchUsername, szUsername, UNLEN);
    wcsncpy(wchPassword, szPassword, LM20_PWLEN);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)defGuestGroup, -1, (LPWSTR)wchGuestGroup, GNLEN);
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szUsername, -1, (LPWSTR)wchUsername, UNLEN);
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szPassword, -1, (LPWSTR)wchPassword, LM20_PWLEN);
#endif

    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserGetInfo:(%s) Start.\n"),defGuest));
    err = NetUserGetInfo( NULL, defGuest, 3, &pBuffer );
    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserGetInfo:(%s) End.Ret=0x%x.\n"),defGuest,err));

    if ( err == NERR_Success )
    {
        do
        {
            WCHAR wchComment[MAXCOMMENTSZ+1];
            WCHAR wchFullName[UNLEN+1];

            memset((PVOID)wchComment, 0, sizeof(wchComment));
            memset((PVOID)wchFullName, 0, sizeof(wchFullName));
#if defined(UNICODE) || defined(_UNICODE)
            wcsncpy(wchComment, szComment, MAXCOMMENTSZ);
            wcsncpy(wchFullName, szFullName, UNLEN);
#else
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szComment, -1, (LPWSTR)wchComment, MAXCOMMENTSZ);
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szFullName, -1, (LPWSTR)wchFullName, UNLEN);
#endif
            USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

            lpui3->usri3_name = wchUsername;
            lpui3->usri3_password = wchPassword;
            lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
            lpui3->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
            lpui3->usri3_acct_expires = TIMEQ_FOREVER;

            lpui3->usri3_comment = wchComment;
            lpui3->usri3_usr_comment = wchComment;
            lpui3->usri3_full_name = wchFullName;
            lpui3->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;

            DWORD parm_err;

            iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserAdd():Start.\n")));
            err = NetUserAdd( NULL, 3, pBuffer, &parm_err );
            iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserAdd():End.Ret=0x%x.\n"),err));

            if ( err == NERR_NotPrimary )
            {
                // it is a backup dc
                iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():Start.\n")));
                err = NetGetDCName( NULL, NULL, (LPBYTE *)&pMachineName );
                iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():End.Ret=0x%x\n"),err));

                if (err != NERR_Success)
                {
                    MyMessageBox(NULL, _T("CreateUser:NetGetDCName"), err, MB_OK | MB_SETFOREGROUND);
                    break;
                }
                else 
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserAdd().Start.")));
                    err = NetUserAdd( pMachineName, 3, pBuffer, &parm_err );
                    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserAdd().End.")));
                }
            }
            else if ( err == NERR_UserExists )
            {
                iTheUserAlreadyExists = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("CreateUser:User Already exists. reusing.")));
                // see if we can just change the password.
                if (TRUE == ChangeUserPassword((LPTSTR) szUsername, (LPTSTR) szPassword))
                {
                    err = NERR_Success;
                }
            }

            if ( err != NERR_Success )
            {
                MyMessageBox(NULL, _T("CreateUser:NetUserAdd"), err, MB_OK | MB_SETFOREGROUND);
                break;
            }

        } while (FALSE);
        if ( pMachineName != NULL )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
            NetApiBufferFree( pMachineName );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
        }
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
        NetApiBufferFree( pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
    }
    if ( err == NERR_Success ) 
    {
        if (iTheUserAlreadyExists)
        {
            // if its the the iwam user, then make sure they are not part of the Guests Group by removing them
            if (fiWamUser)
            {
                RegisterAccountToLocalGroup(szUsername, _T("Guests"), FALSE);
            }
        }
        else
        {
            // User was successfully newly created
            *NewlyCreated = 1;

            // add it to the guests group
            // (but don't do it for the iwam user)
            if (!fiWamUser)
            {
                RegisterAccountToLocalGroup(szUsername, _T("Guests"), TRUE);
            }
        }

        if (fiWamUser)
        {
            UpdateUserRights(szUsername,g_pstrRightsFor_IWAM,sizeof(g_pstrRightsFor_IWAM)/sizeof(LPTSTR), TRUE);
        }
        else
        {
            UpdateUserRights(szUsername,g_pstrRightsFor_IUSR,sizeof(g_pstrRightsFor_IUSR)/sizeof(LPTSTR), TRUE);
        }
    }

    if (TRUE == iTheUserAlreadyExists)
        {*NewlyCreated = 2;}

    // Clear password to be safe
    SecureZeroMemory( wchPassword, sizeof( wchPassword ) );

    return err;
}

INT DeleteGuestUser(LPCTSTR szUsername, INT *UserWasDeleted)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("DeleteGuestUser:%s\n"), szUsername));

    INT err = NERR_Success;
    BYTE *pBuffer;
    *UserWasDeleted = 0;

    WCHAR wchUsername[UNLEN+1];
#if defined(UNICODE) || defined(_UNICODE)
    wcsncpy(wchUsername, szUsername, UNLEN);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szUsername, -1, (LPWSTR)wchUsername, UNLEN);
#endif

    if (FALSE == IsUserExist(wchUsername)) 
    {
        *UserWasDeleted = 1;
        iisDebugOut((LOG_TYPE_TRACE, _T("DeleteGuestUser return. %s doesn't exist.\n"), szUsername));
        return err;
    }

    // remove it from the guests group
    RegisterAccountToLocalGroup(szUsername, _T("Guests"), FALSE);

    // remove certain user rights of this account
    UpdateUserRights(szUsername,g_pstrRightsFor_AnyUserRemoval,sizeof(g_pstrRightsFor_AnyUserRemoval)/sizeof(LPTSTR), FALSE);

    do
    {
        WCHAR *pMachine = NULL;

        //  make sure we are not backup docmain first
        iisDebugOut((LOG_TYPE_TRACE, _T("NetServerGetInfo:Start.\n")));
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().Start.")));
        err = NetServerGetInfo( NULL, 101, &pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().End.")));
        if (err != NERR_Success )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("NetServerGetInfo:failed.err=0x%x.\n"),err));
            break;
        }
        iisDebugOut((LOG_TYPE_TRACE, _T("NetServerGetInfo:End.\n")));

        LPSERVER_INFO_101 pInfo = (LPSERVER_INFO_101)pBuffer;
        if (( pInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) != 0 )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():Start.\n")));
            NetGetDCName( NULL, NULL, (LPBYTE *)&pMachine);
            iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():End.\n")));
        }

        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
        NetApiBufferFree( pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));

        iisDebugOut((LOG_TYPE_TRACE, _T("NetUserDel:Start.\n")));
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetUserDel().Start.")));
        INT err = ::NetUserDel( pMachine, wchUsername );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetUserDel().End.")));
        iisDebugOut((LOG_TYPE_TRACE, _T("NetUserDel:End.Ret=0x%x.\n"),err));

        if (err == NERR_Success)
        {
            *UserWasDeleted = 1;
        }
        if ( pMachine != NULL )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
            NetApiBufferFree( pMachine );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
        }
    } while(FALSE);

    iisDebugOut((LOG_TYPE_TRACE, _T("DeleteGuestUser:%s. End. Return 0x%x\n"), szUsername, err));
    return err;
}

BOOL GuestAccEnabled()
{
    BOOL fEnabled = FALSE;
    INT err = NERR_Success;

    BYTE *pBuffer;
    WCHAR defGuest[UNLEN+1];
    
    GetGuestUserName(defGuest);

    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserGetInfo:Start.\n")));
    err = NetUserGetInfo( NULL, defGuest, 3, &pBuffer );
    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserGetInfo:End.Ret=0x%x.\n"),err));

    if ( err == NERR_Success )
    {
        USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;
        fEnabled = ( lpui3->usri3_flags & UF_ACCOUNTDISABLE ) == 0;
    }
    return fEnabled;
    
}


NET_API_STATUS
NetpNtStatusToApiStatus (
    IN NTSTATUS NtStatus
    )

/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    LAN Man error code.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    NET_API_STATUS error;

    //
    // A small optimization for the most common case.
    //
    if ( NtStatus == STATUS_SUCCESS ) {
        return NERR_Success;
    }


    switch ( NtStatus ) {

        case STATUS_BUFFER_TOO_SMALL :
            return NERR_BufTooSmall;

        case STATUS_FILES_OPEN :
            return NERR_OpenFiles;

        case STATUS_CONNECTION_IN_USE :
            return NERR_DevInUse;

        case STATUS_INVALID_LOGON_HOURS :
            return NERR_InvalidLogonHours;

        case STATUS_INVALID_WORKSTATION :
            return NERR_InvalidWorkstation;

        case STATUS_PASSWORD_EXPIRED :
            return NERR_PasswordExpired;

        case STATUS_ACCOUNT_EXPIRED :
            return NERR_AccountExpired;

        case STATUS_REDIRECTOR_NOT_STARTED :
            return NERR_NetNotStarted;

        case STATUS_GROUP_EXISTS:
                return NERR_GroupExists;

        case STATUS_INTERNAL_DB_CORRUPTION:
                return NERR_InvalidDatabase;

        case STATUS_INVALID_ACCOUNT_NAME:
                return NERR_BadUsername;

        case STATUS_INVALID_DOMAIN_ROLE:
        case STATUS_INVALID_SERVER_STATE:
        case STATUS_BACKUP_CONTROLLER:
                return NERR_NotPrimary;

        case STATUS_INVALID_DOMAIN_STATE:
                return NERR_ACFNotLoaded;

        case STATUS_MEMBER_IN_GROUP:
                return NERR_UserInGroup;

        case STATUS_MEMBER_NOT_IN_GROUP:
                return NERR_UserNotInGroup;

        case STATUS_NONE_MAPPED:
        case STATUS_NO_SUCH_GROUP:
                return NERR_GroupNotFound;

        case STATUS_SPECIAL_GROUP:
        case STATUS_MEMBERS_PRIMARY_GROUP:
                return NERR_SpeGroupOp;

        case STATUS_USER_EXISTS:
                return NERR_UserExists;

        case STATUS_NO_SUCH_USER:
                return NERR_UserNotFound;

        case STATUS_PRIVILEGE_NOT_HELD:
                return ERROR_ACCESS_DENIED;

        case STATUS_LOGON_SERVER_CONFLICT:
                return NERR_LogonServerConflict;

        case STATUS_TIME_DIFFERENCE_AT_DC:
                return NERR_TimeDiffAtDC;

        case STATUS_SYNCHRONIZATION_REQUIRED:
                return NERR_SyncRequired;

        case STATUS_WRONG_PASSWORD_CORE:
                return NERR_BadPasswordCore;

        case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
                return NERR_DCNotFound;

        case STATUS_PASSWORD_RESTRICTION:
                return NERR_PasswordTooShort;

        case STATUS_ALREADY_DISCONNECTED:
                return NERR_Success;

        default:

            //
            // Use the system routine to do the mapping to ERROR_ codes.
            //

#ifndef WIN32_CHICAGO
            error = RtlNtStatusToDosError( NtStatus );

            if ( error != (NET_API_STATUS)NtStatus ) {
                return error;
            }
#endif // WIN32_CHICAGO

            //
            // Could not map the NT status to anything appropriate.
            // Write this to the eventlog file
            //

            return NERR_InternalError;
    }
} // NetpNtStatusToApiStatus


NET_API_STATUS
UaspGetDomainId(
    IN LPCWSTR ServerName OPTIONAL,
    OUT PSAM_HANDLE SamServerHandle OPTIONAL,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO * AccountDomainInfo
    )
/*++
Routine Description:
    Return a domain ID of the account domain of a server.
Arguments:
    ServerName - A pointer to a string containing the name of the
        Domain Controller (DC) to query.  A NULL pointer
        or string specifies the local machine.
    SamServerHandle - Returns the SAM connection handle if the caller wants it.
    DomainId - Receives a pointer to the domain ID.
        Caller must deallocate buffer using NetpMemoryFree.
Return Value:
    Error code for the operation.
--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_HANDLE LocalSamHandle = NULL;

    ACCESS_MASK LSADesiredAccess;
    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;

    UNICODE_STRING ServerNameString;


    //
    // Connect to the SAM server
    //
    RtlInitUnicodeString( &ServerNameString, ServerName );

    Status = SamConnect(
                &ServerNameString,
                &LocalSamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                NULL);

    if ( !NT_SUCCESS(Status)) 
    {
        LocalSamHandle = NULL;
        NetStatus = NetpNtStatusToApiStatus( Status );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UaspGetDomainId: Cannot connect to Sam. err=0x%x\n"),NetStatus));
        goto Cleanup;
    }


    //
    // Open LSA to read account domain info.
    //
    
    if ( AccountDomainInfo != NULL) {
        //
        // set desired access mask.
        //
        LSADesiredAccess = POLICY_VIEW_LOCAL_INFORMATION;

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                LSADesiredAccess,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UaspGetDomainId: Cannot open LSA Policy %lX\n"),NetStatus));
            goto Cleanup;
        }


        //
        // now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) AccountDomainInfo );

        if( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UaspGetDomainId: Cannot read LSA.Err=0x%x.\n"),NetStatus));
            goto Cleanup;
        }
    }

    //
    // Return the SAM connection handle to the caller if he wants it.
    // Otherwise, disconnect from SAM.
    //

    if ( ARGUMENT_PRESENT( SamServerHandle ) ) {
        *SamServerHandle = LocalSamHandle;
        LocalSamHandle = NULL;
    }

    NetStatus = NERR_Success;

    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    return NetStatus;
} // UaspGetDomainId


NET_API_STATUS
SampCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *AccountSid
    )
/*++
Routine Description:
    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.
    The returned Sid may be freed with LocalFree.
--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS    IgnoreStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;

    //
    // Calculate the size of the new sid
    //
    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //
    *AccountSid = LocalAlloc(LMEM_ZEROINIT,AccountSidLength);
    if (*AccountSid == NULL) 
    {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
    }
    else 
    {
        //
        // Copy the domain sid into the first part of the account sid
        //
        IgnoreStatus = RtlCopySid(AccountSidLength, *AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //
        *RtlSubAuthorityCountSid(*AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //
        RidLocation = RtlSubAuthoritySid(*AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = Rid;

        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AccountSid=0x%x"),*AccountSid));

        NetStatus = NERR_Success;
    }

    return(NetStatus);
}



int GetGuestUserNameForDomain_FastWay(LPTSTR szDomainToLookUp,LPTSTR lpGuestUsrName)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain_FastWay.start.domain=%s\n"),szDomainToLookUp));
    int iReturn = FALSE;
    NET_API_STATUS NetStatus;

    // for UaspGetDomainId()
    SAM_HANDLE SamServerHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo = NULL;

    PSID pAccountSid = NULL;
    PSID pDomainSid = NULL;

    // for LookupAccountSid()
    SID_NAME_USE sidNameUse = SidTypeUser;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    TCHAR szUserName[UNLEN+1];
    DWORD cbName = UNLEN+1;
    // must be big enough to hold something bigger than DNLen since LookupAccountSid may returnn something really big.
    TCHAR szReferencedDomainName[200];
    DWORD cbReferencedDomainName = sizeof(szReferencedDomainName);

    ASSERT(lpGuestUsrName);

    // make sure not to return back gobble-d-gook
    _tcscpy(lpGuestUsrName, _T(""));

    //
    // Get the Sid for the specified Domain
    //
    // szDomainToLookUp=NULL for local machine
    NetStatus = UaspGetDomainId( szDomainToLookUp,&SamServerHandle,&pAccountDomainInfo );
    if ( NetStatus != NERR_Success ) 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain:UaspGetDomainId failed.ret=0x%x."),NetStatus));
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }
    pDomainSid = pAccountDomainInfo->DomainSid;
    //
    // Use the Domain Sid and the well known Guest RID to create the Real Guest Sid
    //
    // Well-known users ...
    // DOMAIN_USER_RID_ADMIN          (0x000001F4L)
    // DOMAIN_USER_RID_GUEST          (0x000001F5L)
    NetStatus = NERR_InternalError;
    NetStatus = SampCreateFullSid(pDomainSid, DOMAIN_USER_RID_GUEST, &pAccountSid);
    if ( NetStatus != NERR_Success ) 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain:SampCreateFullSid failed.ret=0x%x."),NetStatus));
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Check if the SID is valid
    //
    if (0 == IsValidSid(pAccountSid))
    {
        DWORD dwErr = GetLastError();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain:IsValidSid FAILED.  GetLastError()= 0x%x\n"), dwErr));
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Retrieve the UserName for the specified SID
    //
    _tcscpy(szUserName, _T(""));
    _tcscpy(szReferencedDomainName, _T(""));
    // szDomainToLookUp=NULL for local machine
    if (!LookupAccountSid(szDomainToLookUp, pAccountSid, szUserName, &cbName, szReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
    {
        DWORD dwErr = GetLastError();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain:LookupAccountSid FAILED.  GetLastError()= 0x%x\n"), dwErr));
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain:szDomainToLookUp=%s\n"),szDomainToLookUp));
    //iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain:pAccountSid=0x%x\n"),pAccountSid));
    //iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain:szUserName=%s\n"),szUserName));
    //iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain:szReferencedDomainName=%s\n"),szReferencedDomainName));

    // Return the guest user name that we got.
    _tcscpy(lpGuestUsrName, szUserName);

    // Wow, after all that, we must have succeeded
    iReturn = TRUE;

GetGuestUserNameForDomain_FastWay_Exit:
    // Free the Domain info if we got some
    if (pAccountDomainInfo) {NetpMemoryFree(pAccountDomainInfo);}
    // Free the sid if we had allocated one
    if (pAccountSid) {LocalFree(pAccountSid);}
    iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain_FastWay.end.domain=%s.ret=%d.\n"),szDomainToLookUp,iReturn));
    return iReturn;
}


void GetGuestUserName(LPTSTR lpOutGuestUsrName)
{
    // try to retrieve the guest username the fast way
    // meaning = lookup the domain sid, and the well known guest rid, to get the guest sid.
    // then look it up.  The reason for this function is that on large domains with mega users
    // the account can be quickly looked up.
    TCHAR szGuestUsrName[UNLEN+1];
    LPTSTR pszComputerName = NULL;
    if (!GetGuestUserNameForDomain_FastWay(pszComputerName,szGuestUsrName))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("GetGuestUserNameForDomain_FastWay:Did not succeed use slow way. WARNING.")));

        // if the fast way failed for some reason, then let's do it
        // the slow way, since this way always used to work, only on large domains (1 mil users) 
        // it could take 24hrs (since this function actually enumerates thru the domain)
        GetGuestUserName_SlowWay(szGuestUsrName);
    }

    // Return back the username
    _tcscpy(lpOutGuestUsrName,szGuestUsrName);

    return;
}


int ChangeUserPassword(IN LPTSTR szUserName, IN LPTSTR szNewPassword)
{
    int iReturn = TRUE;
    USER_INFO_1003  pi1003; 
    NET_API_STATUS  nas; 

    TCHAR szRawComputerName[CNLEN + 10];
    DWORD dwLen = CNLEN + 10;
    TCHAR szComputerName[CNLEN + 10];
    TCHAR szCopyOfUserName[UNLEN+10];
    TCHAR szTempFullUserName[(CNLEN + 10) + (DNLEN+1)];
    LPTSTR pch = NULL;

    _tcscpy(szCopyOfUserName, szUserName);

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().Start.name=%s,pass=%s"),szCopyOfUserName,szNewPassword));
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().Start.name=%s"),szCopyOfUserName));

    if ( !GetComputerName( szRawComputerName, &dwLen ))
        {goto ChangeUserPassword_Exit;}

    // Make a copy to be sure not to move the pointer around.
    SafeCopy(szTempFullUserName, szCopyOfUserName, sizeof(szTempFullUserName)/sizeof(TCHAR));
    // Check if there is a "\" in there.
    pch = _tcschr(szTempFullUserName, _T('\\'));
    if (pch) 
        {
            // szCopyOfUserName should now go from something like this:
            // mycomputer\myuser
            // to this myuser
            SafeCopy(szCopyOfUserName,pch+1, sizeof(szTempFullUserName)/sizeof(TCHAR));
            // trim off the '\' character to leave just the domain\computername so we can check against it.
            *pch = _T('\0');
            // compare the szTempFullUserName with the local computername.
            if (0 == _tcsicmp(szRawComputerName, szTempFullUserName))
            {
                // the computername\username has a hardcoded computername in it.
                // lets try to get only the username
                // look szCopyOfusername is already set
            }
            else
            {
                // the local computer machine name
                // and the specified username are different, so get out
                // and don't even try to change this user\password since
                // it's probably a domain\username

                // return true -- saying that we did in fact change the passoword.
                // we really didn't but we can't
                iReturn = TRUE;
                goto ChangeUserPassword_Exit;
            }
        }


    // Make sure the computername has a \\ in front of it
    if ( szRawComputerName[0] != _T('\\') )
        {SafeCopy(szComputerName,_T("\\\\"), sizeof(szComputerName)/sizeof(TCHAR));}
    SafeCat(szComputerName,szRawComputerName, sizeof(szComputerName)/sizeof(TCHAR));
    // 
    // administrative over-ride of existing password 
    // 
    // by this time szCopyOfUserName
    // should not look like mycomputername\username but it should look like username.
    pi1003.usri1003_password = szNewPassword;
     nas = NetUserSetInfo(
            szComputerName,   // computer name 
            szCopyOfUserName, // username 
            1003,             // info level 
            (LPBYTE)&pi1003,  // new info 
            NULL 
            ); 

    if(nas != NERR_Success) 
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

ChangeUserPassword_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().End.Ret=%d"),iReturn));
    return iReturn; 
} 


DWORD DoesUserHaveThisRight(LPCTSTR szAccountName,LPTSTR PrivilegeName,BOOL *fHaveThatRight)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("DoesUserHaveBasicRights:Account=%s\n"), szAccountName));
    BOOL fEnabled = FALSE;
    NTSTATUS status;
	LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;

    *fHaveThatRight = FALSE;

    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, PrivilegeName);

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;

    status = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (status != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("DoesUserHaveBasicRights:GetPrincipalSID:Account=%s, err=%d.\n"), szAccountName, status));
        return status;
    }

    status = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( status == NERR_Success )
    {
		UINT i;
        LSA_UNICODE_STRING *rgUserRights = NULL;
		ULONG cRights;
	
		status = LsaEnumerateAccountRights(
				 PolicyHandle,
				 pSID,
				 &rgUserRights,
				 &cRights);

		if (status==STATUS_OBJECT_NAME_NOT_FOUND)
        {
			// no rights/privileges for this account
            status = ERROR_SUCCESS;
			fEnabled = FALSE;
		}
		else if (!NT_SUCCESS(status)) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("DoesUserHaveBasicRights:GetPrincipalSID:Failed to enumerate rights: status 0x%08lx\n"), status));
			goto DoesUserHaveBasicRights_Exit;
		}

		for(i=0; i < cRights; i++) 
        {
            if ( RtlEqualUnicodeString(&rgUserRights[i],&UserRightString,FALSE) ) 
            {
                fEnabled = TRUE;
                break;
            }
		}
		
        if (rgUserRights) 
        {
            LsaFreeMemory(rgUserRights);
        }
    }

DoesUserHaveBasicRights_Exit:

    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }
    if (pSID) 
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }

    *fHaveThatRight = fEnabled;
    return status;
}

// function: DoesUserExist
//
// Check if a user exists
//
BOOL
DoesUserExist( LPCTSTR szAccountName, LPBOOL pbExists )
{
  PSID pSid = NULL;
  BOOL bWellKnownSID;
  BOOL bRet = FALSE;
  int  err;

  err = GetPrincipalSID ((LPTSTR)szAccountName, &pSid, &bWellKnownSID);

  if ( err == ERROR_SUCCESS )
  {
    *pbExists = TRUE;
    bRet = TRUE;

    if ( pSid ) 
    {
      // Free the Sid that was created
      if ( bWellKnownSID )
      {
        FreeSid (pSid);
      }
      else
      {
        free (pSid);
      }
    }
  }
  else
    if ( err == ERROR_NONE_MAPPED )
    {
      *pbExists = FALSE;
      bRet = TRUE;
    }

  return bRet;
}

HRESULT CreateGroup(LPCTSTR szGroupName, LPCTSTR szGroupComment, int iAction, int iFlagForSpecialGroup)
{
    HRESULT           hr = S_OK;
    NET_API_STATUS    dwRes;
    LOCALGROUP_INFO_1 MyLocalGroup;

    WCHAR wszLocalGroupName[_MAX_PATH];
    WCHAR wszLocalGroupComment[_MAX_PATH];

    memset(&MyLocalGroup, 0, sizeof(MyLocalGroup));

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszLocalGroupName, szGroupName);
    _tcscpy(wszLocalGroupComment, szGroupComment);
#else
    MultiByteToWideChar( CP_ACP, 0, szGroupName, -1, wszLocalGroupName, _MAX_PATH);
    MultiByteToWideChar( CP_ACP, 0, szGroupComment, -1, wszLocalGroupComment, _MAX_PATH);
#endif

    MyLocalGroup.lgrpi1_name    = (LPWSTR)szGroupName;
    MyLocalGroup.lgrpi1_comment = (LPWSTR)szGroupComment;

    if (iAction)
    {
      // Add Group
      dwRes = ::NetLocalGroupAdd( NULL, 1, (LPBYTE)&MyLocalGroup, NULL );
      if(dwRes != NERR_Success       &&
         dwRes != NERR_GroupExists   &&
         dwRes != ERROR_ALIAS_EXISTS  )
      {
          hr = HRESULT_FROM_WIN32(dwRes);
      }

      // if it's for the special group
      // then make sure it has required right.
      if (iFlagForSpecialGroup)
      {
          UpdateUserRights(szGroupName,g_pstrRightsFor_IIS_WPG,sizeof(g_pstrRightsFor_IIS_WPG)/sizeof(LPTSTR), TRUE);
      }
    }
    else
    {
      // Remove Group
      BOOL bExists;

      if ( DoesUserExist( szGroupName, &bExists ) &&
           ( bExists == FALSE ) )
      {
        // Nothing necessary to do, so quit
        return S_OK;
      }

      if (iFlagForSpecialGroup)
      {
          UpdateUserRights(szGroupName,g_pstrRightsFor_IIS_WPG,sizeof(g_pstrRightsFor_IIS_WPG)/sizeof(LPTSTR), FALSE);
      }

      dwRes = ::NetLocalGroupDel( NULL, wszLocalGroupName);
      if(dwRes != NERR_Success       &&
         dwRes != NERR_GroupNotFound   &&
         dwRes != ERROR_NO_SUCH_ALIAS   )
      {
          hr = HRESULT_FROM_WIN32(dwRes);
      }
    }

    return hr;
}


int CreateGroupDC(LPTSTR szGroupName, LPCTSTR szGroupComment)
{
    int iReturn = FALSE;
    GROUP_INFO_1 GI1;
    ULONG   BadParm;
    WCHAR * pMachineName = NULL;
    ULONG   ulErr = ERROR_SUCCESS;
    WCHAR wszLocalGroupName[_MAX_PATH];
    WCHAR wszLocalGroupComment[_MAX_PATH];

    memset(&GI1, 0, sizeof(GROUP_INFO_1));

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszLocalGroupName, szGroupName);
    _tcscpy(wszLocalGroupComment, szGroupComment);
#else
    MultiByteToWideChar( CP_ACP, 0, szGroupName, -1, wszLocalGroupName, _MAX_PATH);
    MultiByteToWideChar( CP_ACP, 0, szGroupComment, -1, wszLocalGroupComment, _MAX_PATH);
#endif


    GI1.grpi1_name      = wszLocalGroupName;
    GI1.grpi1_comment   = wszLocalGroupComment;


    iisDebugOut((LOG_TYPE_TRACE, _T("CreateGroup:NetGroupAdd\n")));
    ulErr = NetGroupAdd(NULL,1,(PBYTE)&GI1,&BadParm);
    iisDebugOut((LOG_TYPE_TRACE, _T("CreateGroup:NetGroupAdd,ret=0x%x\n"),ulErr));
	switch (ulErr) 
	    {
        case NERR_Success:
            iisDebugOut((LOG_TYPE_TRACE, _T("CreateGroup:NetGroupAdd,success\n"),ulErr));
            iReturn = TRUE;
            break;
        case NERR_GroupExists:
            iReturn = TRUE;
    		break;
        case NERR_InvalidComputer:
            iReturn = FALSE;
		    break;
        case NERR_NotPrimary:
            {
                // it is a backup dc
                int err;
                iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():Start.\n")));
                err = NetGetDCName( NULL, NULL, (LPBYTE *)&pMachineName );
                iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():End.Ret=0x%x\n"),err));
                if (err != NERR_Success)
                {
                    MyMessageBox(NULL, _T("CreateUser:NetGetDCName"), err, MB_OK | MB_SETFOREGROUND);
                }
                else 
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGroupAdd().Start.")));
                    ulErr = NetGroupAdd(pMachineName,1,(PBYTE)&GI1,&BadParm);
                    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGroupAdd().End.")));
                    if (NERR_Success == ulErr || NERR_GroupExists == ulErr)
                    {
                        iReturn = TRUE;
                    }
                }
            }
            break;
        case ERROR_ACCESS_DENIED:
            iReturn = FALSE;
		    break;
        default:
            iReturn = FALSE;
		    break;
	    }

    return iReturn;
}


/*
    Check if wszGroup name is present on the local computer
    Returns true if exists
*/
BOOL LocalGroupExists( IN LPCWSTR wszGroupName )
{
    BOOL    bRes    = FALSE;
    LPBYTE  pbtData = NULL;

    if ( ::NetLocalGroupGetInfo( NULL, wszGroupName, 1, &pbtData ) == NERR_Success )
    {
        bRes = TRUE;
    }
    
    if ( pbtData != NULL ) ::NetApiBufferFree( pbtData );

    iisDebugOut((LOG_TYPE_TRACE, _T("LocalGroupExists( '%s' ) returned %s"), wszGroupName, bRes ? _T("Yes") : _T("No") ));

    return bRes;        
}


#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT

#include <afxwin.h>
#include <afxext.h>
#include <afxcoll.h>
#include <afxcmn.h>
#include <malloc.h>

#include <ntsam.h>
#include <lm.h>
#include <lmerr.h>
#include <WinError.h>
#include <dbgutil.h>
#include <buffer.hxx>

#include "resource.h"
#include "tstr.hxx"
#include "setupapi.h"
#include "ocmanage.h"
#include "const.h"
#include "registry.h"
#include "initapp.h"
#include "helper.h"
#include "dllmain.h"
#include "setuputl.h"
#include "shellutl.h"
#include <assert.h>

#undef UNUSED
#include <netlib.h>
#include <lsarpc.h>

// STL
#pragma warning( push, 3 )
#include <list>
#include <memory>
#include <string>
#include <map>
#pragma warning( pop )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\sslkeys.h ===
#include "stdafx.h"
#include <wincrypt.h>

void Upgradeiis4Toiis5MetabaseSSLKeys();
void UpgradeLSAKeys(PWCHAR pszwTargetMachine);
BOOL PrepIPPortName(CString& csKeyMetaName, CString& csIP, CString& csPort);
void StoreKeyReference_Default(CMDKey& cmdW3SVC, PCCERT_CONTEXT pCert, CString& csPort);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\shellutl.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include <shlobj.h>
#include <iis64.h>
#include "log.h"
#include "shellutl.h"

extern OCMANAGER_ROUTINES gHelperRoutines;

HRESULT MySetLinkInfoTip(LPCTSTR lpszLink, LPCTSTR lpszDescription)
{
    HRESULT hres;
    IShellLink* pShellLink;

    CoInitialize(NULL);

    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

          // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          MultiByteToWideChar( CP_ACP, 0, lpszLink, -1, wsz, _MAX_PATH);
#endif
          hres = pPersistFile->Load(wsz, STGM_READ);
          if (SUCCEEDED(hres))
          {
              hres = pShellLink->Resolve(NULL, SLR_ANY_MATCH | SLR_NO_UI);
              if (SUCCEEDED(hres))
              {
                if (lpszDescription)
                    {
                    pShellLink->SetDescription(lpszDescription);
                    // Save the link by calling IPersistFile::Save.
                    hres = pPersistFile->Save(wsz, TRUE);
                    }
              }
              else
              {
                  iisDebugOut((LOG_TYPE_WARN, _T("MySetLinkInfoTip(): pShellLink->Resolve FAILED\n")));
              }
          }
          else
          {
              iisDebugOut((LOG_TYPE_WARN, _T("MySetLinkInfoTip(): pPersistFile->Load FAILED\n")));
          }
          pPersistFile->Release();
       }
       else
       {
           iisDebugOut((LOG_TYPE_WARN, _T("MySetLinkInfoTip(): QueryInterface FAILED\n")));
       }
       pShellLink->Release();
    }
    else
    {
        iisDebugOut((LOG_TYPE_WARN, _T("MySetLinkInfoTip(): CoCreateInstance FAILED\n")));
    }
    CoUninitialize();

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MySetLinkInfoTip(): Link=%1!s!, Desc=%2!s!\n"), lpszLink, lpszDescription));
    return hres;
}


HRESULT MyQueryLink(LPCTSTR lpszLink, LPTSTR lpszProgram, LPTSTR lpszArgs, LPTSTR lpszDir, LPTSTR lpszIconPath, int *piIconIndex)
{
    HRESULT hres;
    IShellLink* pShellLink;
    WIN32_FIND_DATA wfd;

    CoInitialize(NULL);

    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

          // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          MultiByteToWideChar( CP_ACP, 0, lpszLink, -1, wsz, _MAX_PATH);
#endif
          hres = pPersistFile->Load(wsz, STGM_READ);
          if (SUCCEEDED(hres))
          {
              hres = pShellLink->Resolve(NULL, SLR_ANY_MATCH | SLR_NO_UI);
              if (SUCCEEDED(hres))
              {
                   pShellLink->GetPath(lpszProgram, _MAX_PATH, (WIN32_FIND_DATA *)&wfd, SLGP_SHORTPATH);
                   pShellLink->GetArguments(lpszArgs, _MAX_PATH);
                   pShellLink->GetWorkingDirectory(lpszDir, _MAX_PATH);
                   pShellLink->GetIconLocation(lpszIconPath, _MAX_PATH, piIconIndex);
              }
              else
              {
                  iisDebugOut((LOG_TYPE_ERROR, _T("MyQueryLink(): pShellLink->Resolve FAILED\n")));
              }
          }
          else
          {
              iisDebugOut((LOG_TYPE_WARN, _T("MyQueryLink(): pPersistFile->Load FAILED\n")));
          }
          pPersistFile->Release();
       }
       else
       {
           iisDebugOut((LOG_TYPE_ERROR, _T("MyQueryLink(): QueryInterface FAILED\n")));
       }
       pShellLink->Release();
    }
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MyQueryLink(): CoCreateInstance FAILED\n")));
    }
    CoUninitialize();
    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyQueryLink(): Program=%1!s!, Args=%2!s!, WorkDir=%3!s!, IconPath=%4!s!, IconIndex=%5!d!\n"), lpszProgram, lpszArgs, lpszDir, lpszIconPath, *piIconIndex));
    return hres;
}

HRESULT MyCreateLink(LPCTSTR lpszProgram, LPCTSTR lpszArgs, LPCTSTR lpszLink, LPCTSTR lpszDir, LPCTSTR lpszIconPath, int iIconIndex, LPCTSTR lpszDescription)
{
    HRESULT hres;
    IShellLink* pShellLink;

    CoInitialize(NULL);

    //CoInitialize must be called before this
    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;

       // Set the path to the shortcut target, and add the description.
       pShellLink->SetPath(lpszProgram);
       pShellLink->SetArguments(lpszArgs);
       pShellLink->SetWorkingDirectory(lpszDir);
       pShellLink->SetIconLocation(lpszIconPath, iIconIndex);
       if (lpszDescription)
        {
           pShellLink->SetDescription(lpszDescription);
        }
       
       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          // Ensure that the string is WCHAR.
          MultiByteToWideChar( CP_ACP,0,lpszLink,-1,wsz,_MAX_PATH);
#endif

          // Save the link by calling IPersistFile::Save.
          hres = pPersistFile->Save(wsz, TRUE);
          if (!SUCCEEDED(hres))
          {
              iisDebugOut((LOG_TYPE_ERROR, _T("MyCreateLink(): pPersistFile->Save FAILED\n")));
          }

          pPersistFile->Release();
       }
       else
       {
           iisDebugOut((LOG_TYPE_ERROR, _T("MyCreateLink(): pShellLink->QueryInterface FAILED\n")));
       }
       pShellLink->Release();
    }
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MyCreateLink(): CoCreateInstance FAILED\n")));
    }
    CoUninitialize();
    return hres;
}

BOOL MyDeleteLink(LPTSTR lpszShortcut)
{
    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory(szFile, sizeof(szFile));
    _tcscpy(szFile, lpszShortcut);

	iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteLink(): %s.\n"), szFile));

    if (IsFileExist(szFile))
    {
        ZeroMemory(&fos, sizeof(fos));
        fos.hwnd = NULL;
        fos.wFunc = FO_DELETE;
        fos.pFrom = szFile;
        fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        int iTemp = SHFileOperation(&fos);
        if (iTemp != 0)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MyDeleteLink(): SHFileOperation FAILED\n")));
        }
    }

    return TRUE;
}

void MyMoveLink(LPCTSTR lpszItemDesc, LPCTSTR lpszOldGroup, LPCTSTR lpszNewGroup)
{
    TCHAR szOldLink[_MAX_PATH], szNewLink[_MAX_PATH];
    TCHAR szProgram[_MAX_PATH], szArgs[_MAX_PATH], szDir[_MAX_PATH], szIconPath[_MAX_PATH];
    int iIconIndex;

    MyGetGroupPath(lpszOldGroup, szOldLink);
    _tcscat(szOldLink, _T("\\"));
    _tcscat(szOldLink, lpszItemDesc);
    _tcscat(szOldLink, _T(".lnk"));

    MyGetGroupPath(lpszNewGroup, szNewLink);
    if (!IsFileExist(szNewLink))
        MyAddGroup(lpszNewGroup);
    _tcscat(szNewLink, _T("\\"));
    _tcscat(szNewLink, lpszItemDesc);
    _tcscat(szNewLink, _T(".lnk"));

    MyQueryLink(szOldLink, szProgram, szArgs, szDir, szIconPath, &iIconIndex);
    MyDeleteLink(szOldLink);
    MyCreateLink(szProgram, szArgs, szNewLink, szDir, szIconPath, iIconIndex, NULL);

    return;
}

void MyGetSendToPath(LPTSTR szPath)
{
    LPITEMIDLIST   pidlSendTo;
    HRESULT hRes = NOERROR;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("SendTo path=%1!s!\n"), szPath));

    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_SENDTO, &pidlSendTo);
    if (hRes != NOERROR)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetSendToPath() SHGetSpecialFolderLocation (CSIDL_SENDTO) FAILED. hresult=0x%x\n"), hRes));}

    int iTemp = SHGetPathFromIDList(pidlSendTo, szPath);
    if (iTemp != TRUE)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetSendToPath() SHGetPathFromIDList FAILED\n")));}

    return;
}

void MyGetDeskTopPath(LPTSTR szPath)
{
    LPITEMIDLIST   pidlDeskTop;
    HRESULT hRes = NOERROR;

#ifndef _CHICAGO_
    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidlDeskTop);
#else
    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &pidlDeskTop);
#endif
    if (hRes != NOERROR)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetDeskTopPath() SHGetSpecialFolderLocation (CSIDL_COMMON_DESKTOPDIRECTORY) FAILED. hresult=0x%x\n"), hRes));}

    int iTemp = SHGetPathFromIDList(pidlDeskTop, szPath);
    if (iTemp != TRUE)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetDeskTopPath() SHGetPathFromIDList FAILED\n")));}

    return;
}

void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath)
{
    int            nLen = 0;
    LPITEMIDLIST   pidlPrograms;
    HRESULT hRes = NOERROR;

#ifndef _CHICAGO_
    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlPrograms);
    if (hRes != NOERROR)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetGroupPath() SHGetSpecialFolderLocation (CSIDL_COMMON_PROGRAMS) FAILED. hresult=0x%x\n"), hRes));}
#else
    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &pidlPrograms);
    if (hRes != NOERROR)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetGroupPath() SHGetSpecialFolderLocation (CSIDL_PROGRAMS) FAILED. hresult=0x%x\n"), hRes));}
#endif
    int iTemp = SHGetPathFromIDList(pidlPrograms, szPath);
    if (iTemp != TRUE)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetGroupPath() SHGetPathFromIDList FAILED\n")));}

    nLen = _tcslen(szPath);
    if (szGroupName)
    {
        if (szPath[nLen-1] != _T('\\')){_tcscat(szPath, _T("\\"));}
        _tcscat(szPath, szGroupName);
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("MyGetGroupPath(%s). Returns %s.\n"), szGroupName, szPath));
    return;
}

BOOL MyAddGroup(LPCTSTR szGroupName)
{
    CString csPath;
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    csPath = szPath;
    if (CreateLayerDirectory(csPath) != TRUE)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("MyAddGroup() CreateLayerDirectory FAILED\n")));
        }
    SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, szPath, 0);
    return TRUE;
}

BOOL MyIsGroupEmpty(LPCTSTR szGroupName)
{
    TCHAR             szPath[_MAX_PATH];
    TCHAR             szFile[_MAX_PATH];
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
    BOOL              fReturn = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    _tcscpy(szFile, szPath);
    _tcscat(szFile, _T("\\*.*"));

    hFind = FindFirstFile(szFile, &FindData);
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
           fReturn = FALSE;
           break;
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }
    FindClose(hFind);

    return fReturn;
}

BOOL MyDeleteGroup(LPCTSTR szGroupName)
{
    BOOL fResult;
    TCHAR             szPath[_MAX_PATH];
    TCHAR             szFile[_MAX_PATH];
    SHFILEOPSTRUCT    fos;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    //we can't remove a directory that is not empty, so we need to empty this one

    _tcscpy(szFile, szPath);
    _tcscat(szFile, _T("\\*.*"));

    ZeroMemory(&fos, sizeof(fos));
    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

    hFind = FindFirstFile(szFile, &FindData);
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
          //copy the path and file name to our temp buffer
          memset( (PVOID)szFile, 0, sizeof(szFile));
          _tcscpy(szFile, szPath);
          _tcscat(szFile, _T("\\"));
          _tcscat(szFile, FindData.cFileName);
          //add a second NULL because SHFileOperation is looking for this
          _tcscat(szFile, _T("\0"));

          //delete the file
          fos.pFrom = szFile;
          int iTemp = SHFileOperation(&fos);
          if (iTemp != 0)
            {iisDebugOut((LOG_TYPE_ERROR, _T("MyDeleteGroup(): SHFileOperation FAILED\n")));}
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }
    FindClose(hFind);

    fResult = RemoveDirectory(szPath);
    if (fResult) 
    {
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szPath, 0);
    }
    return(fResult);
}

void MyAddSendToItem(LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir)
{
    TCHAR szPath[_MAX_PATH];

    MyGetSendToPath(szPath);

    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szItemDesc);
    _tcscat(szPath, _T(".lnk"));

    MyCreateLink(szProgram, szArgs, szPath, szDir, NULL, 0, NULL);
}

void MyDeleteLinkWildcard(TCHAR *szDir, TCHAR *szFileName)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFileToBeDeleted[_MAX_PATH];

    _stprintf(szFileToBeDeleted, _T("%s\\%s"), szDir, szFileName);

    hFile = FindFirstFile(szFileToBeDeleted, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, so let's Delete it.
                        TCHAR szTempFileName[_MAX_PATH];
                        _stprintf(szTempFileName, _T("%s\\%s"), szDir, FindFileData.cFileName);
                        // set to normal attributes, so we can delete it
                        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
                        // delete it, hopefully
                        InetDeleteFile(szTempFileName);
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return;
}

void MyDeleteSendToItem(LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];
    TCHAR szPath2[_MAX_PATH];

    /*
    MyGetSendToPath(szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));
    MyDeleteLink(szPath);
    */

    MyGetSendToPath(szPath);
    _tcscpy(szPath2, szAppName);
    _tcscat(szPath2, _T(".lnk"));

    MyDeleteLinkWildcard(szPath, szPath2);
}

void MyAddDeskTopItem(LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR szIconPath, int iIconIndex)
{
    TCHAR szPath[_MAX_PATH];

    MyGetDeskTopPath(szPath);

    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szItemDesc);
    _tcscat(szPath, _T(".lnk"));

    MyCreateLink(szProgram, szArgs, szPath, szDir, szIconPath, iIconIndex, NULL);
}

HRESULT GetLNKProgramRunInfo(LPCTSTR lpszLink, LPTSTR lpszProgram)
{
    HRESULT hres;
    int iDoUninit = FALSE;
    IShellLink* pShellLink = NULL;
    WIN32_FIND_DATA wfd;

    if (SUCCEEDED(CoInitialize(NULL)))
        {iDoUninit = TRUE;}

    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile = NULL;
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

          // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          MultiByteToWideChar( CP_ACP, 0, lpszLink, -1, wsz, _MAX_PATH);
#endif
          hres = pPersistFile->Load(wsz, STGM_READ);
          if (SUCCEEDED(hres))
          {
              hres = pShellLink->Resolve(NULL, SLR_ANY_MATCH | SLR_NO_UI);
              if (SUCCEEDED(hres))
              {
                   pShellLink->GetPath(lpszProgram, _MAX_PATH, (WIN32_FIND_DATA *)&wfd, SLGP_SHORTPATH);
              }
          }
          if (pPersistFile)
            {pPersistFile->Release();pPersistFile = NULL;}
       }
       if (pShellLink)
        {pShellLink->Release();pShellLink = NULL;}
    }

    if (TRUE == iDoUninit)
        {CoUninitialize();}
    return hres;
}

BOOL IsFileNameInDelimitedList(LPTSTR szCommaDelimList,LPTSTR szExeNameWithoutPath)
{
    BOOL bReturn = FALSE;
    TCHAR *token = NULL;
    TCHAR szCopyOfDataBecauseStrTokIsLame[_MAX_PATH];
    _tcscpy(szCopyOfDataBecauseStrTokIsLame,szCommaDelimList);

    // breakup the szCommaDelimList into strings and see if it contains the szExeNameWithoutPath string
    token = _tcstok(szCopyOfDataBecauseStrTokIsLame, _T(",;\t\n\r"));
    while(token != NULL)
	{
        // check if it matches our .exe name.
        if (0 == _tcsicmp(token,szExeNameWithoutPath))
        {
            return TRUE;
        }
	    // Get next token
	    token = _tcstok(NULL, _T(",;\t\n\r"));
    }

    return FALSE;
}


int LNKSearchAndDestroyRecursive(LPTSTR szDirToLookThru, LPTSTR szSemiColonDelmitedListOfExeNames, BOOL bDeleteItsDirToo)
{
    int iReturn = FALSE;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFilePath[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    DWORD retCode = GetFileAttributes(szDirToLookThru);

    if (retCode == 0xFFFFFFFF || !(retCode & FILE_ATTRIBUTE_DIRECTORY))
    {
            return FALSE;
    }
   
    _tcscpy(szFilePath, szDirToLookThru);
    AddPath(szFilePath, _T("*.*"));

    iisDebugOut((LOG_TYPE_TRACE, _T("LNKSearchAndDestroyRecursive:%s,%s,%d\n"),szDirToLookThru, szSemiColonDelmitedListOfExeNames, bDeleteItsDirToo));

    hFile = FindFirstFile(szFilePath, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        TCHAR szFullNewDirToLookInto[_MAX_EXT];
                        _tcscpy(szFullNewDirToLookInto, szDirToLookThru);
                        AddPath(szFullNewDirToLookInto,FindFileData.cFileName);

                        // this is a directory, so let's go into this
                        // directory recursively
                        LNKSearchAndDestroyRecursive(szFullNewDirToLookInto,szSemiColonDelmitedListOfExeNames,bDeleteItsDirToo);
                    }
                    else
                    {
                        // check if this file is a .lnk file
                        // if it is then let's open it and 
                        // see if it points to our .exe we're looking for...
                        
                        // get only the filename's extention
                        _tsplitpath( FindFileData.cFileName, NULL, NULL, NULL, szFilename_ext_only);

                        // check for .lnk
                        if (0 == _tcsicmp(szFilename_ext_only, _T(".lnk")))
                        {
                            TCHAR szFilename_only[_MAX_FNAME];
                            TCHAR szFullPathAndFilename[_MAX_PATH];
                            TCHAR szTemporaryString[_MAX_PATH];

                            // this is a .lnk,
                            // open it and check the .exe..
                            _tcscpy(szFullPathAndFilename,szDirToLookThru);
                            AddPath(szFullPathAndFilename,FindFileData.cFileName);
                            _tcscpy(szTemporaryString,_T(""));

                            if (SUCCEEDED(GetLNKProgramRunInfo(szFullPathAndFilename, szTemporaryString)))
                            {
                                _tsplitpath( szTemporaryString, NULL, NULL, szFilename_only, szFilename_ext_only);
                                _tcscpy(szTemporaryString, szFilename_only);
                                _tcscat(szTemporaryString, szFilename_ext_only);

                                //iisDebugOut((LOG_TYPE_TRACE, _T("open:%s,%s\n"),szFullPathAndFilename,szTemporaryString));

                                // see if it is on our list of comma delimited names...
                                if (TRUE == IsFileNameInDelimitedList(szSemiColonDelmitedListOfExeNames,szTemporaryString))
                                {
                                    SetFileAttributes(szFullPathAndFilename, FILE_ATTRIBUTE_NORMAL);
                                    // delete it, hopefully
                                    InetDeleteFile(szFullPathAndFilename);

                                    // DELETE the file that references this .exe
                                    if (bDeleteItsDirToo)
                                    {
                                        // Get it's dirname and delete that too...
                                        RecRemoveEmptyDir(szDirToLookThru);
                                    }

                                    iReturn = TRUE;
                                }
                             }
                        }
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return iReturn;
}

void MyDeleteDeskTopItem(LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];
    TCHAR szPath2[_MAX_PATH];

    /*
    MyGetDeskTopPath(szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));
    //if this is an upgrade, then the directories could have changed.
    //see if we need to delete the old one...
    MyDeleteLink(szPath);
    */

    MyGetDeskTopPath(szPath);
    _tcscpy(szPath2, szAppName);
    _tcscat(szPath2, _T(".lnk"));

    MyDeleteLinkWildcard(szPath, szPath2);
}

void DeleteFromGroup(LPCTSTR szGroupName, LPTSTR szApplicationExec)
{
    TCHAR szPath[_MAX_PATH];
    // Get path to that group
    MyGetGroupPath(szGroupName, szPath);

    LNKSearchAndDestroyRecursive(szPath, szApplicationExec, FALSE);
}

void MyDeleteDeskTopItem2(LPTSTR szSemiColonDelmitedListOfExeNames, BOOL bDeleteItsDirToo)
{
    TCHAR szPath[_MAX_PATH];
    MyGetDeskTopPath(szPath);
    LNKSearchAndDestroyRecursive(szPath, szSemiColonDelmitedListOfExeNames, bDeleteItsDirToo);
}

// boydm -------------------------------------------------------------------------------------------
// Adds a web URL shortcut file . The URL is passed in and is put into the file in the form of a INI file.
BOOL AddURLShortcutItem( LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szURL )
{
    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("AddURLShortcutItem(): %1!s!,%2!s!,%3!s!\n"), szGroupName, szItemDesc, szURL));
    // this first part of getting the paths is copied from MyAddItem below
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    if (!IsFileExist(szPath))
    {
        MyAddGroup(szGroupName);
    }
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szItemDesc);
    _tcscat(szPath, _T(".url"));

    // now use the private profile routines to easily create and fill in the content for the .url file
    return WritePrivateProfileString(
        _T("InternetShortcut"),        // pointer to section name
        _T("URL"),            // pointer to key name
        szURL,                          // pointer to string to add
        szPath                          // pointer to initialization filename
        );
}

void MyAddItem(LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR lpszIconPath)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    if (!IsFileExist(szPath))
        MyAddGroup(szGroupName);

    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szItemDesc);
    _tcscat(szPath, _T(".lnk"));

    if (lpszIconPath && IsFileExist(lpszIconPath))
    {
        MyCreateLink(szProgram, szArgs, szPath, szDir, lpszIconPath, 0, NULL);
    }
    else
    {
        MyCreateLink(szProgram, szArgs, szPath, szDir, NULL, 0, NULL);
    }
}

void MyAddItemInfoTip(LPCTSTR szGroupName, LPCTSTR szAppName, LPCTSTR szDescription)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));

    MySetLinkInfoTip(szPath, szDescription);
}


void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];
    TCHAR szPath2[_MAX_PATH];

    /*
    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));
    MyDeleteLink(szPath);

    // try to remove items added by AddURLShortcutItem()
    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath2, szAppName);
    _tcscat(szPath2, _T(".url"));
    MyDeleteLink(szPath);
    */

    MyGetGroupPath(szGroupName, szPath);
    _tcscpy(szPath2, szAppName);
    _tcscat(szPath2, _T(".lnk"));
    MyDeleteLinkWildcard(szPath, szPath2);

    MyGetGroupPath(szGroupName, szPath);
    _tcscpy(szPath2, szAppName);
    _tcscat(szPath2, _T(".url"));
    MyDeleteLinkWildcard(szPath, szPath2);

    if (MyIsGroupEmpty(szGroupName)) {MyDeleteGroup(szGroupName);}
}

//
// Used when the strings are passed in.
//
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, UINT style)
{
    int iReturn = TRUE;
    CString csTitle;

    MyLoadString(IDS_IIS_ERROR_MSGBOXTITLE,csTitle);

    // call MyMessageBox which will log to the log file and 
    // check the global variable to see if we can even display the popup
    iReturn = MyMessageBox(hWnd, lpszTheMessage, csTitle, style | MB_SETFOREGROUND);
    return iReturn;
}

//
// Used when the strings are passed in.
//
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, LPCTSTR lpszTheTitle, UINT style)
{
    int iReturn = IDOK;

    // make sure it goes to iisdebugoutput
    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("MyMessageBox: Title:%1!s!, Msg:%2!s!\n"), lpszTheTitle, lpszTheMessage));

    if (style & MB_ABORTRETRYIGNORE) 
    {
        iReturn = IDIGNORE;
    }
    
    // Check global variable to see if we can even display the popup!
    if (g_pTheApp->m_bAllowMessageBoxPopups)
    {
        // Suppress the message if unattened or remove all
        // Who cares the user can't do anything about it anyway?
        // no use upsetting them, we do log to the OCM though
        //
        if (! g_pTheApp->m_fUnattended || g_pTheApp->m_dwSetupMode != SETUPMODE_REMOVEALL)
        {
            iReturn = MessageBox(hWnd, lpszTheMessage, lpszTheTitle, style | MB_SETFOREGROUND);
        }
    }
    return iReturn;
}


//
// Used when the string and an error code passed in.
// 
int MyMessageBox(HWND hWnd, CString csTheMessage, HRESULT iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsg, csErrMsg;

    csMsg = csTheMessage;

    TCHAR pMsg[_MAX_PATH] = _T("");
    HRESULT nNetErr = (HRESULT) iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}



//
// Used when the String ID's are passed in.
// 
int MyMessageBox(HWND hWnd, UINT iTheMessage, UINT style)
{
    int iReturn = TRUE;
    CString csMsg;

    MyLoadString(iTheMessage,csMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csMsg, style | MB_SETFOREGROUND);

    return iReturn;
}

//
// Used when the String ID's are passed in.
// And the tthere is an error code which needs to get shown and
// 
int MyMessageBox(HWND hWnd, UINT iTheMessage, int iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsg, csErrMsg;

    MyLoadString(iTheMessage,csMsg);

    TCHAR pMsg[_MAX_PATH] = _T("");
    int nNetErr = (int)iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}


int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever, UINT style)
{
    int iReturn = TRUE;
    CString csMsgForSprintf, csMsg;

    // Get the iTheMessage from the resouce file
    // csMsgForSprintf should now look something like: "cannot find file %s".
    MyLoadString(iTheMessage,csMsgForSprintf);

    // now load the passed in filename or whatever.
    // csMsg should now look like: "cannot find file Whatever";
    csMsg.Format( csMsgForSprintf, lpszTheFileNameOrWhatever);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csMsg, style | MB_SETFOREGROUND);

    return iReturn;
}


int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever, int iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsgForSprintf, csMsg, csErrMsg;

    // Get the iTheMessage from the resouce file
    // csMsgForSprintf should now look something like: "cannot find file %s".
    MyLoadString(iTheMessage,csMsgForSprintf);

    // now load the passed in filename or whatever.
    // csMsg should now look like: "cannot find file Whatever";
    csMsg.Format( csMsgForSprintf, lpszTheFileNameOrWhatever);

    TCHAR pMsg[_MAX_PATH] = _T("");
    int nNetErr = (int)iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}


int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever1, LPCTSTR lpszTheFileNameOrWhatever2, int iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsgForSprintf, csMsg, csErrMsg;

    // Get the iTheMessage from the resouce file
    // csMsgForSprintf should now look something like: "cannot find file %s %s".
    MyLoadString(iTheMessage,csMsgForSprintf);

    // now load the passed in filename or whatever.
    // csMsg should now look like: "cannot find file Whatever1 Whatever2";
    csMsg.Format( csMsgForSprintf, lpszTheFileNameOrWhatever1, lpszTheFileNameOrWhatever2);

    TCHAR pMsg[_MAX_PATH] = _T("");
    int nNetErr = (int)iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}

int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever1, LPCTSTR lpszTheFileNameOrWhatever2, LPCTSTR lpszTheFileNameOrWhatever3, int iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsgForSprintf, csMsg, csErrMsg;

    // Get the iTheMessage from the resouce file
    // csMsgForSprintf should now look something like: "cannot find file %s %s".
    MyLoadString(iTheMessage,csMsgForSprintf);

    // now load the passed in filename or whatever.
    // csMsg should now look like: "cannot find file Whatever1 Whatever2 Whatever3";
    csMsg.Format( csMsgForSprintf, lpszTheFileNameOrWhatever1, lpszTheFileNameOrWhatever2, lpszTheFileNameOrWhatever3);

    TCHAR pMsg[_MAX_PATH] = _T("");
    int nNetErr = (int)iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}


int MyMessageBoxArgs(HWND hWnd, TCHAR *pszfmt, ...)
{
    int iReturn = TRUE;
    TCHAR tszString[1000];
    va_list va;
    va_start(va, pszfmt);
    _vstprintf(tszString, pszfmt, va);
    va_end(va);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, tszString, MB_OK | MB_SETFOREGROUND);

    return iReturn;
}


void GetErrorMsg(int errCode, LPCTSTR szExtraMsg)
{
    SetErrorFlag(__FILE__, __LINE__);

    TCHAR pMsg[_MAX_PATH];

    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, errCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    _tcscat(pMsg, szExtraMsg);
    MyMessageBox(NULL, pMsg, _T(""), MB_OK | MB_SETFOREGROUND);

    return;
}

void MyLoadString(int nID, CString &csResult)
{
    TCHAR buf[MAX_STR_LEN];

    if (LoadString((HINSTANCE) g_MyModuleHandle, nID, buf, MAX_STR_LEN))
        csResult = buf;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\sslkeys.cpp ===
/* code to upgrade SSL keys to the latest mechanism

    Since there have been several mechanisms to do this in the past we need
    several mechanisms to store and retrieve the private and public portions
    of the keys.

    IIS2/3 used the LSA mechanism to store the keys as secrets in the registry.
    IIS4 stored the keys directly in the metabase as secured data objects.

    IIS5 will be using the native NT5 Protected Storage mechanism to keep the keys.
    This means that we are no longer in the business of storing, protecting and
    retrieving the keys. It will all be done in NT maintained facilities. However,
    we still need to migrate the keys over to the new storage mechanism, which is
    what this code is all about.

    One more thing. Previously the keys were associated with the virtual servers
    in an indirect manner. The keys (IIS4) were stored in a metabase location that
    was parallel to the virtual servers. Then each key had an IP\Port binding
    associated with it that mapped the key back to the original server.
    This has caused no end of confusion for the users as they struggle to associate
    keys with virtual servers.

    Now the references to the keys in the PStore are stored directly on each virtual
    server, creating a implicit releationship between the key and the server.

    The old mapping scheme also supported the concept of wildcarded IP or Port
    address. Whereas this new scheme does not. This means the upgrading will be done
    as a several stop process. First, we look for all the existing keys that are bound
    to a specific IP/Port combination. This takes precedence over wildcards and is
    applied to the keys first. Then IP/wild is applied to any matching virtual server
    that does not already have a key on it. Then wile/Port. Since we have always
    required that there can only be one default key at a time, as soon as we encounter
    it in the process we can just apply it to the master-properties level.

    Fortunately, this whole file is on NT only, so we can assume everything is UNICODE always
*/

#include "stdafx.h"

// this file is also only used on NT, so don't do anything if its win9X
#ifndef _CHICAGO_

#include <ole2.h>
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "lsaKeys.h"

#undef MAX_SERVICE_NAME_LEN
#include "elem.h"
#include "mdentry.h"
#include "inetinfo.h"

#include "inetcom.h"
#include "logtype.h"
#include "ilogobj.hxx"
#include "sslkeys.h"
extern OCMANAGER_ROUTINES gHelperRoutines;

#include <wincrypt.h>

#define SECURITY_WIN32
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <schnlsp.h>

#include "certupgr.h"


const LPCTSTR MDNAME_INCOMPLETE = _T("incomplete");
const LPCTSTR MDNAME_DISABLED = _T("disabled");
const LPCTSTR MDNAME_DEFAULT = _T("default");

const LPCTSTR SZ_SERVER_KEYTYPE = _T("IIsWebServer");

const LPTSTR SZ_SSLKEYS_NODE = _T("SSLKeys");
const LPTSTR SZ_W3SVC_PATH = _T("LM/W3SVC");
const LPTSTR SZ_SSLKEYS_PATH = _T("LM/W3SVC/SSLKeys");

const LPWSTR SZ_CAPI_STORE = L"MY";

#define     ALLOW_DELETE_KEYS       // Normally defined. Don't define for test purposes.

//------------------------------------------------------------------------------
// Given the name of a key in the metabase migrate it to the PStore. At this point we
// are actually only loading and preparing the raw data. The routines to stick it in the
// right place are in an external library so they can be shared with other utilities.
// since the metabase key is already opened by the calling routine, pass it in as a
// parameter.
// returns TRUE for success
PCCERT_CONTEXT MigrateKeyToPStore( CMDKey* pmdKey, CString& csMetaKeyName )
{
    iisDebugOut((LOG_TYPE_TRACE, _T("MigrateKeyToPStore():Start.%s."), (LPCTSTR)csMetaKeyName));
    BOOL        fSuccess = FALSE;
    BOOL        f;
    DWORD       dwAttr, dwUType, dwDType, cbLen;

    PVOID       pbPrivateKey = NULL;
    DWORD       cbPrivateKey = 0;

    PVOID       pbPublicKey = NULL;
    DWORD       cbPublicKey = 0;

    PVOID       pbRequest = NULL;
    DWORD       cbRequest = 0;

    PCHAR       pszPassword = NULL;

    PCCERT_CONTEXT pcCertContext = NULL;

    // the actual sub key path this the sslkeys dir plus the key name. The actual metabase
    // object is opened to the w3svc level
    CString     csSubKeyPath = _T("SSLKeys/");
    csSubKeyPath += csMetaKeyName;

    // get the private key - required ---------
    dwAttr = 0;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = BINARY_METADATA;
    // this first call is just to get the size of the pointer we need
    f = pmdKey->GetData(MD_SSL_PRIVATE_KEY,&dwAttr,&dwUType,&dwDType,&cbPrivateKey,NULL,0,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // if the get data fails on the private key, we have nothing to do
    if ( cbPrivateKey == 0 )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED: Unable to read private key for %s"), (LPCTSTR)csMetaKeyName));
        return NULL;
        }

    // allocate the buffer for the private key
    pbPrivateKey = GlobalAlloc( GPTR, cbPrivateKey );
    if ( !pbPrivateKey ) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED to allocate memory for private key.")));
        return NULL;
    }

    // do the real call to get the data from the metabase
    f = pmdKey->GetData(MD_SSL_PRIVATE_KEY,&dwAttr,&dwUType,&dwDType,&cbPrivateKey,(PUCHAR)pbPrivateKey,cbPrivateKey,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // if the get data fails on the private key, we have nothing to do
    if ( !f )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED: Unable to read private key for %s"), (LPCTSTR)csMetaKeyName));
        goto cleanup;
        }


    // get the password -required ------------
    // the password is stored as an ansi binary secure item.
    dwAttr = 0;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = BINARY_METADATA;
    cbLen = 0;
    // this first call is just to get the size of the pointer we need
    f = pmdKey->GetData(MD_SSL_KEY_PASSWORD,&dwAttr,&dwUType,&dwDType,&cbLen,NULL,0,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // if the get data fails on the password, we have nothing to do
    if ( cbLen == 0 )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED retrieve password. Nothing to do.")));
        goto cleanup;
    }

    // allocate the buffer for the password
    pszPassword = (PCHAR)GlobalAlloc( GPTR, cbLen );
    if ( !pszPassword ) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED to allocate memory for password.")));
        goto cleanup;
    }

    // do the real call to get the data from the metabase
    f = pmdKey->GetData(MD_SSL_KEY_PASSWORD,&dwAttr,&dwUType,&dwDType,&cbLen,(PUCHAR)pszPassword,cbLen,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // if the get data fails on the password, we have nothing to do
    if ( !f )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED: Unable to read ssl password for %s"), (LPCTSTR)csMetaKeyName));
        goto cleanup;
        }

    // get the public key -optional -----------
    dwAttr = 0;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = BINARY_METADATA;
    // this first call is just to get the size of the pointer we need
    f = pmdKey->GetData(MD_SSL_PUBLIC_KEY,&dwAttr,&dwUType,&dwDType,&cbPublicKey,NULL,0,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // the public key is optional, so don't fail if we don't get it
    if ( cbPublicKey )
    {
        // allocate the buffer for the private key
        pbPublicKey = GlobalAlloc( GPTR, cbPublicKey );
        if ( !pbPublicKey ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED to allocate memory for public key.")));
        }
        else
        {
            // do the real call to get the data from the metabase
            f = pmdKey->GetData(MD_SSL_PUBLIC_KEY,&dwAttr,&dwUType,&dwDType,&cbPublicKey,(PUCHAR)pbPublicKey,cbPublicKey,(PWCHAR)(LPCTSTR)csSubKeyPath);
            // if the get data fails on the public key, clean it up and reset it to null
            if ( !f )
            {
                if ( pbPublicKey )
                {
                    GlobalFree( pbPublicKey );
                    pbPublicKey = NULL;
                }
                cbPublicKey = 0;
            }
        }
    }

    // get the request -optional -----------
    dwAttr = 0;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = BINARY_METADATA;
    // this first call is just to get the size of the pointer we need
    f = pmdKey->GetData(MD_SSL_KEY_REQUEST,&dwAttr,&dwUType,&dwDType,
        &cbRequest,NULL,0,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // the request is optional, so don't fail if we don't get it
    if ( cbRequest )
    {
        // allocate the buffer for the private key
        pbRequest = GlobalAlloc( GPTR, cbRequest );
        if ( !pbRequest ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED to allocate memory for key request.")));
        }
        else
        {
            // do the real call to get the data from the metabase
            f = pmdKey->GetData(MD_SSL_KEY_REQUEST,&dwAttr,&dwUType,&dwDType,
                &cbRequest,(PUCHAR)pbRequest,cbRequest,(PWCHAR)(LPCTSTR)csSubKeyPath);
            // if the get data fails on the key request, clean it up and reset it to null
            if ( !f )
            {
                if ( pbRequest )
                {
                    GlobalFree( pbRequest );
                    pbRequest = NULL;
                }
                cbRequest = 0;
            }
        }
    }

    // ------------------------------------------------------------------
    // Now that we've loaded the data, we can call the conversion utility
    // ------------------------------------------------------------------
    pcCertContext = CopyKRCertToCAPIStore(
        pbPrivateKey, cbPrivateKey,
        pbPublicKey, cbPublicKey,
        pbRequest, cbRequest,
        pszPassword,
        SZ_CAPI_STORE,
        TRUE
        );

    if ( pcCertContext )
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("MigrateKeyToPStore():CopyKRCertToCAPIStore():Upgrade KR key to CAPI for %s. Success."), (LPCTSTR)csMetaKeyName));
    }
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():CopyKRCertToCAPIStore():Upgrade KR key to CAPI for %s.  FAILED."), (LPCTSTR)csMetaKeyName));
    }


cleanup:
    if ( pbPrivateKey ) {GlobalFree( pbPrivateKey );}
    if ( pbPublicKey ) {GlobalFree( pbPublicKey );}
    if ( pszPassword ) {GlobalFree( pszPassword );}

    iisDebugOut((LOG_TYPE_TRACE, _T("MigrateKeyToPStore():End.%s."), (LPCTSTR)csMetaKeyName));

    return pcCertContext;
}


//------------------------------------------------------------------------------
// write a reference to a PStore key on a specific node in the metabase
void WriteKeyReference( CMDKey& cmdW3SVC, PWCHAR pwchSubPath, PCCERT_CONTEXT pCert )
    {
    // get the hash that we need to write out

    //
    // SHA produces 160 bit hash for any message < 2^64 bits in length
    BYTE HashBuffer[40];                // give it some extra size
    DWORD dwHashSize = sizeof(HashBuffer);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertGetCertificateContextProperty().Start.")));
    if ( !CertGetCertificateContextProperty( pCert,
                                             CERT_SHA1_HASH_PROP_ID,
                                             (VOID *) HashBuffer,
                                             &dwHashSize ) )
        {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertGetCertificateContextProperty().End.")));
        if ( GetLastError() == ERROR_MORE_DATA )
            {
            //Very odd, cert wants more space ..
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: StoreCertInfoInMetabase Unable to get hash property")));
            }

        // We definitely need to store the hash of the cert, so error out
        return;
        }
    else
        {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertGetCertificateContextProperty().End.")));
        }

    // write out the hash of the certificate
    cmdW3SVC.SetData( MD_SSL_CERT_HASH, METADATA_INHERIT, IIS_MD_UT_SERVER, BINARY_METADATA,
                        dwHashSize, (PUCHAR)&HashBuffer, pwchSubPath );

    // write out the name of the store
    cmdW3SVC.SetData( MD_SSL_CERT_STORE_NAME, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA,
                    (_tcslen(SZ_CAPI_STORE)+1) * sizeof(TCHAR), (PUCHAR)SZ_CAPI_STORE, pwchSubPath );
    }

//------------------------------------------------------------------------------
// store a reference to a PStore key on all the appropriate virtual servers. If csIP
// or csPort is empty, then that item is a wildcard and applies to all virtual servers.
void StoreKeyReference( CMDKey& cmdW3SVC, PCCERT_CONTEXT pCert, CString& csIP, CString& csPort )
{
    TCHAR szForDebug[100];

    if (csIP) 
    {
        if (csPort){_stprintf(szForDebug, _T("ip:%s port:%s"), csIP, csPort);}
        else{_stprintf(szForDebug, _T("ip:%s port:(null)"), csIP);}
    }
    else 
    {
        if (csPort){_stprintf(szForDebug, _T("ip:(null) port:%s"), csPort);}
        else{_stprintf(szForDebug, _T("ip:(null) port:(null)"));}
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s."),szForDebug));


    // if it was unable to open the node, then there are no keys to upgrade.
    if ( (METADATA_HANDLE)cmdW3SVC == NULL )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: passed in invalid metabase handle")));
        iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference End")));
        return;
        }

    // generate the iterator for retrieving the virtual servers
    CMDKeyIter  cmdKeyEnum( cmdW3SVC );
    CString     csNodeName;              // Metabase name for the virtual server
    CString     csNodeType;              // node type indicator string
    CString     csBinding;

    PVOID       pData = NULL;

    BOOL        f;

    DWORD       dwAttr, dwUType, dwDType, cbLen, dwLength;

    // iterate through the virtual servers
    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.iterate through the virtual servers"),szForDebug));
    while (cmdKeyEnum.Next(&csNodeName) == ERROR_SUCCESS)
        {
        // some of the keys under this node are not virutal servers. Thus
        // we first need to check the node type property. If it is not a
        // virtual server then we can just contiue on to the next node.

        // get the string that indicates the node type
        dwAttr = 0;
        dwUType = IIS_MD_UT_SERVER;
        dwDType = STRING_METADATA;
        cbLen = 200;
        f = cmdW3SVC.GetData(MD_KEY_TYPE,
                     &dwAttr,
                     &dwUType,
                     &dwDType,
                     &cbLen,
                     (PUCHAR)csNodeType.GetBuffer(cbLen),
                     cbLen,
                     (PWCHAR)(LPCTSTR)csNodeName);
        csNodeType.ReleaseBuffer();

        // check it - if the node is not a virutal server, then continue on to the next node
        if ( csNodeType != SZ_SERVER_KEYTYPE )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s not a virtualserver, skip."),szForDebug,csNodeName));
            continue;
        }


        // before we do anything else, check if this virtual server already has a key on it.
        // if it does then do not do anything to it. Continue on to the next one
        // we don't actually need to load any data for this to work, so we can call GetData
        // with a size of zero as if we are querying for the size. If that succeedes, then
        // we know that it is there and can continue on
        dwAttr = 0;                     // do not inherit
        dwUType = IIS_MD_UT_SERVER;
        dwDType = BINARY_METADATA;
        dwLength = 0;
        cmdW3SVC.GetData( MD_SSL_CERT_HASH,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                NULL,
                0,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                BINARY_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName);

        // if there is a key there already - continue to the next node
        if ( dwLength > 0 )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s already has a key there, skip."),szForDebug,csNodeName));
            continue;
        }

        // this is a valid virtual server with no pre-existing key. Now we need to load
        // the bindings and see if we have a match
        dwAttr = 0;                     // do not inherit
        dwUType = IIS_MD_UT_SERVER;
        dwDType = MULTISZ_METADATA;
        dwLength = 0;
        // The bindings are in a multi-sz. So, first we need to figure out how much space we need
        f = cmdW3SVC.GetData( MD_SECURE_BINDINGS,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                NULL,
                0,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                MULTISZ_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName);

        // if the length is zero, then there are no bindings
        if ( dwLength == 0 )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s data len=0 no bindings, skip."),szForDebug,csNodeName));
            continue;
        }

        // Prepare some space to receive the bindings
        TCHAR*      pBindings;

        // if pData is pointing to something, then we need to free it so that we don't leak
        if ( pData )
            {
            GlobalFree( pData );
            pData = NULL;
            }

        // allocate the space, if it fails, we fail
        // note that GPTR causes it to be initialized to zero
        pData = GlobalAlloc( GPTR, dwLength + 2 );
        if ( !pData )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("StoreKeyReference.Start.%s.%s GlobalAlloc failed."),szForDebug,csNodeName));
            continue;
        }
        pBindings = (TCHAR*)pData;

        // now get the real data from the metabase
        f = cmdW3SVC.GetData( MD_SECURE_BINDINGS,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                (PUCHAR)pBindings,
                dwLength,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                MULTISZ_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName );

        // if we did not get the bindings, then this node doesn't have any security
        // options set on it. We can continue on to the next virtual server
        if ( FALSE == f )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s No security options set on it, skip."),szForDebug,csNodeName));
            continue;
        }

        // OK. We do have bindings. Now we get to parse them out and check them
        // against the binding strings that were passed in. Note: if a binding
        // matches, but has a host-header at the end, then it does not qualify
        // got the existing bindings, scan them now - pBindings will be pointing at the second end \0
        // when it is time to exit the loop.
        while ( *pBindings )
            {
            csBinding = pBindings;
            csBinding.TrimRight();

            CString     csBindIP;
            CString     csBindPort;         // don't actually care about this one

            // get the binding's IP and port sections so we can look for wildcards in the binding itself
            PrepIPPortName( csBinding, csBindIP, csBindPort );

            // if there is a specified IP, look for it. If we don't find it, go to the next binding.
            if ( !csIP.IsEmpty() && !csBindIP.IsEmpty() )
                {
                // if the IP is not in the binding then bail on this binding
                if ( csBinding.Find( csIP ) < 0 )
                    {
                    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s:org=%s,findIP=%s bail."),szForDebug,csNodeName,csBinding,csIP));
                    goto NextBinding;
                    }
                }

            // if there is a specified Port, look for it. If we don't find it, go to the next binding.\
            // secure bindings themselves always have a port
            if ( !csPort.IsEmpty() )
                {
                // if the Port is not in the binding then bail on this binding
                if ( csBinding.Find( csPort ) < 0 )
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s:org=%s,findport=%s bail."),szForDebug,csNodeName,csBinding,csPort));
                    goto NextBinding;
                }
                }

            // test if host headers are there by doing a reverse find for the last colon. Then
            // check if it is the last character. If it isn't, then there is a host-header and
            // we should go to a different binding
            if ( csBinding.ReverseFind(_T(':')) < (csBinding.GetLength()-1) )
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s:bail2."),szForDebug,csNodeName));
                goto NextBinding;
            }


            // Well, this is a valid binding on a valid virtual server, we can now write out the key
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.%s.%s:Write out the key!"),szForDebug,csNodeName));
            WriteKeyReference( cmdW3SVC, (PWCHAR)(LPCTSTR)csNodeName, pCert );

            // we can break to get out of the specific bindings loop
            break;

NextBinding:
            // increment pBindings to the next string
            pBindings = _tcsninc( pBindings, _tcslen(pBindings))+1;
            }
        }

    // if pData is pointing to something, then we need to free it so that we don't leak
    if ( pData )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.End.%s."),szForDebug));
}

//------------------------------------------------------------------------------
// given a metabase key name, create strings that can be used to search the virutal servers
// an empty string is a wildcard.
BOOL PrepIPPortName( CString& csKeyMetaName, CString& csIP, CString& csPort )
    {
    int iColon;

    // the first thing we are going to do is seperate the IP and PORT into seperate strings
    // actually, thats not true. Prep the string by putting a colon in it.
    csIP.Empty();
    csPort = _T(':');

    // look for the first ':' and seperate
    iColon = csKeyMetaName.Find( _T(':') );

    // if we got the colon, we can seperate easy
    if ( iColon >= 0 )
        {
        csIP = csKeyMetaName.Left(iColon);
        csPort += csKeyMetaName.Right(csKeyMetaName.GetLength() - iColon - 1);
        }
    // we did not get the colon, so it is one or the other, look for a '.' to get the IP
    else
        {
        if ( csKeyMetaName.Find( _T('.') ) >= 0 )
            csIP = csKeyMetaName;
        else
            csPort += csKeyMetaName;
        }

    // finish decorating the strings with colons if appropriate.
    if ( !csIP.IsEmpty() )
        csIP += _T(':');

    // If the only thing in the port string is a : then it is a wildcard. Clear it out.
    if ( csPort.GetLength() == 1 )
        {
        csPort.Empty();
        }
    else
        {
        // add a final colon to it
        csPort += _T(':');
        }

    return TRUE;
    }


//------------------------------------------------------------------------------
// used when upgrading from IIS2 or IIS3
// this code was in the K2 setup program that shipped. It used to reside in mdentry.cpp and
// has now been encapsulted into its own routine and moved here. The only change to it has been
// to add the Upgradeiis4Toiis5MetabaseSSLKeys call at the end.
void UpgradeLSAKeys( PWCHAR pszwTargetMachine )
{
    iisDebugOut((LOG_TYPE_TRACE, _T("UpgradeLSAKeys Start")));

    DWORD       retCode = KEYLSA_SUCCESS;
    MDEntry     stMDEntry;
    CString     csMDPath;
    TCHAR       tchFriendlyName[_MAX_PATH], tchMetaName[_MAX_PATH];
    BOOL        fUpgradedAKey = FALSE;

    CLSAKeys    lsaKeys;
    WCHAR       wchMachineName[UNLEN + 1];

    memset( (PVOID)wchMachineName, 0, sizeof(wchMachineName));

#if defined(UNICODE) || defined(_UNICODE)
    wcsncpy(wchMachineName, g_pTheApp->m_csMachineName, UNLEN);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)g_pTheApp->m_csMachineName, -1, (LPWSTR)wchMachineName, UNLEN);
#endif

    retCode = lsaKeys.LoadFirstKey(wchMachineName);
    while (retCode == KEYLSA_SUCCESS) {
#if defined(UNICODE) || defined(_UNICODE)
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lsaKeys.m_szMetaName, -1, (LPWSTR)tchMetaName, _MAX_PATH);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lsaKeys.m_szFriendlyName, -1, (LPWSTR)tchFriendlyName, _MAX_PATH);
#else
        _tcscpy(tchMetaName, lsaKeys.m_szMetaName);
        _tcscpy(tchFriendlyName, lsaKeys.m_szFriendlyName);
#endif
        iisDebugOut((LOG_TYPE_TRACE, _T("lsaKeys: FriendName=%s MetaName=%s\n"), tchFriendlyName, tchMetaName));
        csMDPath = SZ_SSLKEYS_PATH;
        csMDPath += _T("/");
        csMDPath += (CString)tchMetaName;
        stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csMDPath;
        stMDEntry.dwMDIdentifier = MD_SSL_FRIENDLY_NAME;
        stMDEntry.dwMDAttributes = METADATA_INHERIT;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = STRING_METADATA;
        stMDEntry.dwMDDataLen = (_tcslen(tchFriendlyName) + 1) * sizeof(TCHAR);
        stMDEntry.pbMDData = (LPBYTE)tchFriendlyName;
        SetMDEntry(&stMDEntry);
        stMDEntry.dwMDIdentifier = MD_SSL_PUBLIC_KEY;
        stMDEntry.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = BINARY_METADATA;
        stMDEntry.dwMDDataLen = lsaKeys.m_cbPublic;
        stMDEntry.pbMDData = (LPBYTE)lsaKeys.m_pPublic;
        SetMDEntry(&stMDEntry);
        stMDEntry.dwMDIdentifier = MD_SSL_PRIVATE_KEY;
        stMDEntry.dwMDDataLen = lsaKeys.m_cbPrivate;
        stMDEntry.pbMDData = (LPBYTE)lsaKeys.m_pPrivate;
        SetMDEntry(&stMDEntry);
        stMDEntry.dwMDIdentifier = MD_SSL_KEY_PASSWORD;
        stMDEntry.dwMDDataLen = lsaKeys.m_cbPassword;
        stMDEntry.pbMDData = (LPBYTE)lsaKeys.m_pPassword;
        SetMDEntry(&stMDEntry);
        stMDEntry.dwMDIdentifier = MD_SSL_KEY_REQUEST;
        stMDEntry.dwMDDataLen = lsaKeys.m_cbRequest;
        stMDEntry.pbMDData = (LPBYTE)lsaKeys.m_pRequest;
        SetMDEntry(&stMDEntry);
        fUpgradedAKey = TRUE;

        retCode = lsaKeys.LoadNextKey();
    }

    if (retCode == KEYLSA_NO_MORE_KEYS) {
        iisDebugOut((LOG_TYPE_TRACE, _T("No More Keys\n")));
        lsaKeys.DeleteAllLSAKeys();
    }

    // Now that the keys have been upgraded to the metabase, upgrade again from
    // the metabase to the PStore
    if ( fUpgradedAKey )
        Upgradeiis4Toiis5MetabaseSSLKeys();
    iisDebugOut((LOG_TYPE_TRACE, _T("UpgradeLSAKeys End")));
}


//------------------------------------------------------------------------------
// the plan here is to enumerate all the server keys under the SSLKEYS key in the metabase.
//    Then they need to be migrated to the PStore and have their references resaved into
//    the correct virtual server.
//
// How the heck does all this work?
//
// iis4.0 metabase looks like this:
// w3svc
// w3svc/1
// w3svc/2
// sslkeys
// sslkeys/(entry1) <--could be one of either of the ssl key types list below
// sslkeys/(entry2) <--
// sslkeys/(entry3) <--
// 
// sslkey types:
//  sslkeys/MDNAME_DISABLED
//  sslkeys/MDNAME_INCOMPLETE
//  sslkeys/MDNAME_DEFAULT
//  sslkeys/ip:port
//
//  step 1. Grab all these sslkeys/entries and move them into the new storage (MigrateKeyToPStore)
//          (for each entry we move into the new storage, we add an entry to a Cstring List to say (we did this one already) )
//          a. do it in iteration#1 for In this loop we look for the default key, disabled keys, incomplete keys, and keys specified by specific IP/Port pairs.
//          b. do it in iteration#2 for IP/wild port keys.
//          c. do it in iteration#3 the rest of the keys, which should all be wild ip/Port keys.
//  step 2. for each of these keys which we moved to the new storage: store the reference which we get back from CAPI
//          in our metabase (StoreKeyReference)
//  step 3. Make sure to keep the metabasekeys around, because setup may actually fail: so we don't want to delete the keys
//          until we are sure that setup is completed.
//  step 4. after setup completes without any errors, we delete all the sslkeys
//
void Upgradeiis4Toiis5MetabaseSSLKeys()
{
    iisDebugOut_Start(_T("Upgradeiis4Toiis5MetabaseSSLKeys"), LOG_TYPE_TRACE);
    iisDebugOut((LOG_TYPE_TRACE, _T("--------------------------------------")));
    CString     csMDPath;
   
    // start by testing that the sslkeys node exists.
    CMDKey cmdKey;
    cmdKey.OpenNode( SZ_SSLKEYS_PATH );
    if ( (METADATA_HANDLE)cmdKey == NULL )
    {
        // there is nothing to do
        iisDebugOut((LOG_TYPE_TRACE, _T("Nothing to do.")));
        return;
    }
    cmdKey.Close();

    // create a key object for the SSLKeys level in the metabase. Open it too.
    cmdKey.OpenNode( SZ_W3SVC_PATH );
    if ( (METADATA_HANDLE)cmdKey == NULL )
    {
        // if it was unable to open the node, then there are no keys to upgrade.
        iisDebugOut((LOG_TYPE_WARN, _T("could not open lm/w3svc")));
        iisDebugOut_End(_T("Upgradeiis4Toiis5MetabaseSSLKeys,No keys to upgrade"),LOG_TYPE_TRACE);
        return;
    }

    // create and prepare a metadata iterator object for the sslkeys
    CMDKeyIter  cmdKeyEnum(cmdKey);
    CString     csKeyName;                  // Metabase name for the key

    // used to parse out the name information
    CString     csIP;
    CString     csPort;
    //CString     csSubPath;

    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pDefaultCert = NULL;

    BOOL bUpgradeToPStoreIsGood = TRUE;

    // do the first iteration. In this loop we look for the default key, disabled keys,
    // incomplete keys, and keys specified by specific IP/Port pairs.
    // Note: cmdKeyEnum.m_index is the index member for the iterator
    iisDebugOut((LOG_TYPE_TRACE, _T("1.first interate for default,disabled,incomplete,and keys specified by specific IP/Port pairs.")));
    while (cmdKeyEnum.Next(&csKeyName, SZ_SSLKEYS_NODE ) == ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("KeyName=%s."),csKeyName));

        pCert = NULL;

        // look for disabled keys
        if ( csKeyName.Find(MDNAME_DISABLED) >= 0)
        {
            pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if (!pCert){bUpgradeToPStoreIsGood = FALSE;}
        }
        // look for incomplete keys
        else if ( csKeyName.Find(MDNAME_INCOMPLETE) >= 0)
        {
            pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if (!pCert){bUpgradeToPStoreIsGood = FALSE;}
        }
        // look for the default key
        else if ( csKeyName.Find(MDNAME_DEFAULT) >= 0)
        {
            pDefaultCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if (!pDefaultCert){bUpgradeToPStoreIsGood = FALSE;}
        }
        // parse the IP/Port name
        else
        {
            // we are only taking keys that have both the IP and the Port specified at this time
            PrepIPPortName( csKeyName, csIP, csPort );
            if ( !csIP.IsEmpty() && !csPort.IsEmpty() )
            {
                // move the key from the metabase to the
                pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
                if ( pCert )
                    {StoreKeyReference( cmdKey, pCert, csIP, csPort );}
                else
                    {bUpgradeToPStoreIsGood = FALSE;}
            }
        }

        // don't leak CAPI certificate contexts now that we are done with it
        if ( pCert )
            {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().Start.")));
            CertFreeCertificateContext( pCert );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().End.")));
            }
    } // end while part 1


    // do the second iteration looking only for IP/wild port keys.
    iisDebugOut((LOG_TYPE_TRACE, _T("2.Second iteration looking only for IP/wild port keys.")));
    cmdKeyEnum.Reset();
    while (cmdKeyEnum.Next(&csKeyName, SZ_SSLKEYS_NODE ) == ERROR_SUCCESS)
    {
        pCert = NULL;

        // parse the IP/Port name
        // we are only taking keys that have the IP specified at this time
        PrepIPPortName( csKeyName, csIP, csPort );
        if ( !csIP.IsEmpty() && csPort.IsEmpty() )
        {
            // move the key from the metabase to the
            pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if ( pCert )
                {StoreKeyReference( cmdKey, pCert, csIP, csPort );}
            else
                {bUpgradeToPStoreIsGood = FALSE;}
        }

        // don't leak CAPI certificate contexts now that we are done with it
        if ( pCert )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().Start.")));
            CertFreeCertificateContext( pCert );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().End.")));
        }
    }

    // upgrade the rest of the keys, which should all be wild ip/Port keys.
    iisDebugOut((LOG_TYPE_TRACE, _T("3.upgrade the rest of the keys, which should all be wild ip/Port keys.")));
    cmdKeyEnum.Reset();
    while (cmdKeyEnum.Next(&csKeyName, SZ_SSLKEYS_NODE) == ERROR_SUCCESS)
    {
        pCert = NULL;

        // parse the IP/Port name
        // we are only taking keys that have the PORT specified at this time
        PrepIPPortName( csKeyName, csIP, csPort );
        if ( !csPort.IsEmpty() && csIP.IsEmpty())
        {
            // move the key from the metabase to the
            pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if ( pCert )
                {StoreKeyReference( cmdKey, pCert, csIP, csPort );}
            else
                {bUpgradeToPStoreIsGood = FALSE;}
        }

        // don't leak CAPI certificate contexts now that we are done with it
        if ( pCert )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().Start.")));
            CertFreeCertificateContext( pCert );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().End.")));
        }
    }

    // if there is one, write the default key reference out
    if ( pDefaultCert )
        {
        iisDebugOut((LOG_TYPE_TRACE, _T("4.write default key reference out")));

        CString     csPortDefault;

        // old way which used to put it on the lm/w3svc node.
        // but we can't do that anymore since that node can't be accessed by the iis snap-in!
        //WriteKeyReference( cmdKey, L"", pDefaultCert );

        csPortDefault = _T(":443:");
        StoreKeyReference_Default( cmdKey, pDefaultCert, csPortDefault );

        // don't leak CAPI certificate contexts now that we are done with it
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().Start.")));
        CertFreeCertificateContext( pDefaultCert );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().End.")));
        }

//#ifdef ALLOW_DELETE_KEYS
    if (TRUE == bUpgradeToPStoreIsGood)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("Upgradeiis4Toiis5MetabaseSSLKeys. 5. Removing upgraded sslkeys node.")));
        // delete the sslkeys node in the metabase
        cmdKey.DeleteNode( SZ_SSLKEYS_NODE );
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("Upgradeiis4Toiis5MetabaseSSLKeys. 6. MigrateKeyToPStore failed so keeping ssl key in metabase.")));
    }
//#endif //ALLOW_DELETE_KEYS

    // close the master properties key.
    cmdKey.Close();

    iisDebugOut_End(_T("Upgradeiis4Toiis5MetabaseSSLKeys"), LOG_TYPE_TRACE);
    iisDebugOut((LOG_TYPE_TRACE, _T("--------------------------------------")));

    // force the metabase to write.
    WriteToMD_ForceMetabaseToWriteToDisk();
    return;
}


//------------------------------------------------------------------------------
// store a reference to a PStore key on all the appropriate virtual servers.
void StoreKeyReference_Default( CMDKey& cmdW3SVC, PCCERT_CONTEXT pCert, CString& csPort )
{
    iisDebugOut_Start(_T("StoreKeyReference_Default"), LOG_TYPE_TRACE);

    // generate the iterator for retrieving the virtual servers
    CMDKeyIter  cmdKeyEnum( cmdW3SVC );
    CString     csNodeName;              // Metabase name for the virtual server
    CString     csNodeType;              // node type indicator string
    CString     csBinding;
    PVOID       pData = NULL;
    BOOL        f;
    DWORD       dwAttr, dwUType, dwDType, cbLen, dwLength;

    // We are looking for a particular port which is stored in csPort.
    // if there is no csPort passed in then lets get out of here!
    if ( csPort.IsEmpty() )
    {
        goto StoreKeyReference_Default_Exit;
    }

    // if it was unable to open the node, then there are no keys to upgrade.
    if ( (METADATA_HANDLE)cmdW3SVC == NULL )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("passed in invalid metabase handle")));
        goto StoreKeyReference_Default_Exit;
    }

    // iterate through the virtual servers
    while (cmdKeyEnum.Next(&csNodeName) == ERROR_SUCCESS)
    {
        // some of the keys under this node are not virutal servers. Thus
        // we first need to check the node type property. If it is not a
        // virtual server then we can just contiue on to the next node.

        // get the string that indicates the node type
        dwAttr = 0;
        dwUType = IIS_MD_UT_SERVER;
        dwDType = STRING_METADATA;
        cbLen = 200;
        f = cmdW3SVC.GetData(MD_KEY_TYPE,
                     &dwAttr,
                     &dwUType,
                     &dwDType,
                     &cbLen,
                     (PUCHAR)csNodeType.GetBuffer(cbLen),
                     cbLen,
                     (PWCHAR)(LPCTSTR)csNodeName);
        csNodeType.ReleaseBuffer();
        // check it - if the node is not a virutal server, then continue on to the next node
        if ( csNodeType != SZ_SERVER_KEYTYPE )
        {
            continue;
        }


        // before we do anything else, check if this virtual server already has a key on it.
        // if it does then do not do anything to it. Continue on to the next one
        // we don't actually need to load any data for this to work, so we can call GetData
        // with a size of zero as if we are querying for the size. If that succeedes, then
        // we know that it is there and can continue on
        dwAttr = 0;                     // do not inherit
        dwUType = IIS_MD_UT_SERVER;
        dwDType = BINARY_METADATA;
        dwLength = 0;
        cmdW3SVC.GetData(MD_SSL_CERT_HASH,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                NULL,
                0,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                BINARY_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName);
        // if there is a key there already - continue to the next node
        if ( dwLength > 0 )
        {
            continue;
        }

        // this is a valid virtual server with no pre-existing key. Now we need to load
        // the bindings and see if we have a match
        dwAttr = 0;                     // do not inherit
        dwUType = IIS_MD_UT_SERVER;
        dwDType = MULTISZ_METADATA;
        dwLength = 0;
        // The bindings are in a multi-sz. So, first we need to figure out how much space we need
        f = cmdW3SVC.GetData( MD_SECURE_BINDINGS,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                NULL,
                0,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                MULTISZ_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName);

        // if the length is zero, then there are no bindings
        if ( dwLength == 0 )
        {
            continue;
        }

        // Prepare some space to receive the bindings
        TCHAR*      pBindings;

        // if pData is pointing to something, then we need to free it so that we don't leak
        if ( pData )
        {
            GlobalFree( pData );
            pData = NULL;
        }

        // allocate the space, if it fails, we fail
        // note that GPTR causes it to be initialized to zero
        pData = GlobalAlloc( GPTR, dwLength + 2 );
        if ( !pData )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("%s GlobalAlloc failed."),csNodeName));
            continue;
        }
        pBindings = (TCHAR*)pData;

        // now get the real data from the metabase
        f = cmdW3SVC.GetData( MD_SECURE_BINDINGS,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                (PUCHAR)pBindings,
                dwLength,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                MULTISZ_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName );
        // if we did not get the bindings, then this node doesn't have any security
        // options set on it. We can continue on to the next virtual server
        if ( FALSE == f )
        {
            continue;
        }

        // OK. We do have bindings. Now we get to parse them out and check them
        // against the binding strings that were passed in. Note: if a binding
        // matches, but has a host-header at the end, then it does not qualify
        // got the existing bindings, scan them now - pBindings will be pointing at the second end \0
        // when it is time to exit the loop.
        while ( *pBindings )
        {
            csBinding = pBindings;
            csBinding.TrimRight();

            // We are looking for a particular port which is stored in csPort.
            // if there is no csPort passed in then lets get out of here!
            if ( csPort.IsEmpty() )
            {
                break;
            }
            else
            {
                // if the Port is not in the binding then bail on this binding
                if ( csBinding.Find( csPort ) < 0 )
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("%s:org=%s,findport=%s bail."),csNodeName,csBinding,csPort));
                    goto NextBinding;
                }
            }

            // test if host headers are there by doing a reverse find for the last colon. Then
            // check if it is the last character. If it isn't, then there is a host-header and
            // we should go to a different binding
            if ( csBinding.ReverseFind(_T(':')) < (csBinding.GetLength()-1) )
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("%s:bail2."),csNodeName));
                goto NextBinding;
            }

            // Well, this is a valid binding on a valid virtual server, we can now write out the key
            iisDebugOut((LOG_TYPE_TRACE, _T("%s:Write out the key!"),csNodeName));
            WriteKeyReference( cmdW3SVC, (PWCHAR)(LPCTSTR)csNodeName, pCert );

            // we can break to get out of the specific bindings loop
            break;

NextBinding:
            // increment pBindings to the next string
            pBindings = _tcsninc( pBindings, _tcslen(pBindings))+1;
        }
    }

    // if pData is pointing to something, then we need to free it so that we don't leak
    if ( pData )
    {
        GlobalFree( pData );
        pData = NULL;
    }

StoreKeyReference_Default_Exit:
    iisDebugOut_End(_T("StoreKeyReference_Default"), LOG_TYPE_TRACE);
}

#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\strfn.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        strfrn.cpp

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)
        Munged to work with setup by BoydM

   Project:

        Internet Services Manager
        And now setup too

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "strfn.h"
#include <pudebug.h>


#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() EnterCriticalSection(&_csSect)
    #define LowerThreadProtection() LeaveCriticalSection(&_csSect)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT

#define MAKE_NULL(obj) { if (obj) delete obj, obj = NULL; }


//
// Text copy functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    )
/*++

Routine Description:

    Convert CR/LF string to LF string (T String to W String).  Destination
    string will be allocated.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));
    if (lpstrDestination != NULL)
    {
        LPCTSTR lpS = strSource;
        LPWSTR lpD = lpstrDestination;

        do
        {
            if (*lpS != _T('\r'))
            {

#ifdef UNICODE
                *lpD++ = *lpS;
#else
                ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpS, 1, lpD++, 1);
#endif // UNICODE

            }
        }
        while (*lpS++);

        return TRUE;
    }

    return FALSE;
}



BOOL
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    )
/*++

Routine Description:

    Expand LF to CR/LF (no allocation necessary) W String to T String.

Arguments:

    CString & strDestination : Destination string
    LPCWSTR lpstrSource      : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        LPCWSTR lpS = lpstrSource;
        //
        // Since we're doubling every linefeed length, assume
        // the worst possible expansion to start with.
        //
        int cch = (::lstrlenW(lpstrSource) + 1) * 2;
        LPTSTR lpD = strDestination.GetBuffer(cch);

        do
        {
            if (*lpS == L'\n')
            {
                *lpD++ = _T('\r');
            }

#ifdef UNICODE
                *lpD++ = *lpS;
#else
                ::WideCharToMultiByte(CP_ACP, 0, lpS, 1, lpD++, 1, NULL, NULL);
#endif // UNICODE

        }
        while (*lpS++);

        strDestination.ReleaseBuffer();

        ++fSuccess;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception in UnixToPCText");
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



BOOL
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    )
/*++

Routine Description:

    Straight copy with allocation. T String to W String.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));
    if (lpstrDestination != NULL)
    {
        TWSTRCPY(lpstrDestination, strSource, cch);
        return TRUE;
    }

    return FALSE;
}



#ifndef UNICODE



#define WBUFF_SIZE  255



LPWSTR
ReferenceAsWideString(
    IN LPCTSTR str
    )
/*++

Routine Description:

    Reference a T string as a W string (non-unicode only).

Arguments:

    LPCTSTR str : Source string

Return Value:

    Wide char pointer to wide string.

Notes:

    This uses an internal wide char buffer, which will be overwritten
    by subsequent calls to this function.

--*/
{
    static WCHAR wchBuff[WBUFF_SIZE + 1];

    ::MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        str,
        -1,
        wchBuff,
        WBUFF_SIZE + 1
        );

    return wchBuff;
}


#endif !UNICODE


LPWSTR
AllocWideString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Convert the incoming string to an wide string, which is allocated
    by this function

Arguments:

    LPCTSTR lpString        : Input wide string

Return Value:

    Pointer to the allocated string

--*/
{
    //
    // Character counts are DBCS friendly
    //
    int cChars = lstrlen(lpString);
    int nLength = (cChars+1) * sizeof(WCHAR);
    LPWSTR lp = (LPWSTR)AllocMem(nLength);
    if (lp)
    {
#ifdef UNICODE
        lstrcpy(lp, lpString);
#else
        ::MultiByteToWideChar(
            CP_ACP, // code page  
            MB_PRECOMPOSED, // character-type options  
            lpString, // address of string to map  
            cChars, // number of characters in string  
            lp, // address of wide-character buffer  
            cChars+1  // size of buffer  
            ); 
#endif
    }

    return lp;
}

LPSTR
AllocAnsiString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Convert the wide string to an ansi (multi-byte) string, which is allocated
    by this function

Arguments:

    LPCTSTR lpString        : Input wide string

Return Value:

    Pointer to the allocated string

--*/
{
    //
    // Character counts are DBCS friendly
    //
    int cChars = lstrlen(lpString);
    int nLength = (cChars * 2) + 1;
    LPSTR lp = (LPSTR)AllocMem(nLength);
    if (lp)
    {
#ifdef UNICODE
        ::WideCharToMultiByte(
            CP_ACP,
            0,
            lpString,
            cChars + 1,
            lp,
            nLength,
            NULL,
            NULL
            );
#else
    lstrcpy(lp, lpString);
#endif
    }

    return lp;
}


LPTSTR
AllocString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Allocate and copy string

Arguments:

    LPCTSTR lpString        : Input string

Return Value:

    Pointer to the allocated string

--*/
{
    int nLength = lstrlen(lpString) + 1;
    LPTSTR lp = (LPTSTR)AllocMem(nLength * sizeof(TCHAR));
    if (lp)
    {
        lstrcpy(lp, lpString);
    }

    return lp;
}



BOOL
IsUNCName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is a UNC path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a UNC path, FALSE otherwise.

Notes:

    Any string of the form \\foo\bar\whatever is considered a UNC path

--*/
{
    if (strDirPath.GetLength() >= 5)  // It must be at least as long as \\x\y,
    {                                 //
        LPCTSTR lp = strDirPath;      //
        if (*lp == _T('\\')           // It must begin with \\,
         && *(lp + 1) == _T('\\')     //
         && _tcschr(lp + 2, _T('\\')) // And have at least one more \ after that
           )
        {
            //
            // Yes, it's a UNC path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



BOOL
IsFullyQualifiedPath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string is a fully qualified path name

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a fully qualified path name


--*/
{
    return strDirPath.GetLength() >= 3
        && strDirPath[1] == _T(':')
        && strDirPath[2] == _T('\\');
}



LPCTSTR
MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    )
/*++

Routine Description:

    Convert the given directory to a UNC path.

Arguments:

    CString & strDir      : UNC String.
    LPCTSTR lpszOwner     : Computer name
    LPCTSTR lpszDirectory : Source string

Return Value:

    Pointer to strDir

Notes:

    The owner may or may not start with "\\".  If it doesn't, the
    backslashes are provided.

--*/
{
    //
    // Try to make make a unc path out of the directory
    //
    ASSERT(lpszDirectory[1] == _T(':'));

    strDir.Format(
        _T("\\\\%s\\%c$\\%s"),
        PURE_COMPUTER_NAME(lpszOwner),
        lpszDirectory[0],
        lpszDirectory + 3
        );

    return (LPCTSTR)strDir;
}



BOOL
IsURLName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is an URL path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is an URL path, FALSE otherwise.

Notes:

    Any string of the form protocol://whatever is considered an URL path

--*/
{
    if (strDirPath.GetLength() >= 4)  // It must be at least as long as x://
    {                                 //
        if (strDirPath.Find(_T("://")) > 0) // Must contain ://
        {
            //
            // Yes, it's an URL path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



int
CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    )
/*++

Routine Description:

    This should be CString::FindNoCase().  Same as CString::Find(),
    but case-insensitive.

Arguments:

    const CString & strSrc  : Source string
    LPCTSTR lpszSub         : String to look for.

Return Value:

    The position of the substring, or -1 if not found.

--*/
{
    LPCTSTR lp1 = strSrc;
    LPCTSTR lp2, lp3;
    int nPos = -1;

    while (*lp1)
    {
        lp2 = lp1;
        lp3 = lpszSub;

        while(*lp2 && *lp3 && _totupper(*lp2) == _totupper(*lp3))
        {
            ++lp2;
            ++lp3;
        }

        if (!*lp3)
        {
            //
            // Found the substring
            //
            nPos = (int)(lp1 - (LPCTSTR)strSrc);
            break;
        }
    
        ++lp1;                    
    }

    return nPos;
}



DWORD
ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    )
/*++

Routine Description:

    Replace the first occurrence of a string with a second string
    inside a third string.

Arguments:

    CString & strBuffer         : Buffer in which to replace
    CString & strTarget         : String to look for
    CString & strReplacement    : String to replace it with
    BOOL fCaseSensitive         : TRUE for case sensitive replacement.
    
Return Value:

    ERROR_SUCCESS for successful replacement.
    ERROR_INVALID_PARAMETER if any string is empty,
    ERROR_FILE_NOT_FOUND if the target string doesn't exist, or
    another win32 error code indicating failure.

--*/
{
    if (strBuffer.IsEmpty() || strTarget.IsEmpty() || strReplacement.IsEmpty())
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD err = ERROR_FILE_NOT_FOUND;
    int nPos = fCaseSensitive 
        ? strBuffer.Find(strTarget)
        : CStringFindNoCase(strBuffer, strTarget);

    if (nPos >= 0)
    {
        try
        {
            CString str(strBuffer.Left(nPos));

            str += strReplacement;
            str += strBuffer.Mid(nPos + strTarget.GetLength());
            strBuffer = str;

            err = ERROR_SUCCESS;
        }
        catch(CMemoryException * e)
        {
            e->Delete();
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    return err;
}


int
CountCharsToDoubleNull(
    IN LPCTSTR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;
        if (lp[0] == _T('\0') && lp[1] == _T('\0'))
        {
            return ++cChars;
        }

        ++lp;
    }
}

int
CountWCharsToDoubleNull(
    IN PWCHAR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;
        if (lp[0] == L'\0' && lp[1] == L'\0')
        {
            return ++cChars;
        }

        ++lp;
    }
}


DWORD
ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars                  OPTIONAL
    )
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringListEx

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    CStringList & strlDest : Destination string list.
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        strlDest.RemoveAll();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            strlDest.AddTail(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}

DWORD
ConvertWDoubleNullListToStringList(
    IN  PWCHAR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars                  OPTIONAL
    )
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringListEx

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    CStringList & strlDest : Destination string list.
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountWCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        strlDest.RemoveAll();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            strlDest.AddTail(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}




DWORD
ConvertStringListToWDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPWSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a WIDE double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    POSITION pos;
    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = AllocWString(cchDest);
    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPWSTR pch = lpstrDest;
    LPWSTR pwstr;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);


        // if we are not already UNICODE, we need to convert
#ifndef UNICODE
        pwstr = AllocWideString( (LPCTSTR)str );
#else
        pwstr = (LPWSTR)(LPCTSTR)str;
#endif
        if (pwstr == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pch, pwstr);
        pch += str.GetLength();
        *pch++ = L'\0';

#ifndef UNICODE
        // clean up the temporary wide string
        FreeMem( pwstr );
#endif
    }

    *pch++ = L'\0';

    if (fNullPad)
    {
        *pch++ = L'\0';
    }

    return ERROR_SUCCESS;
}


DWORD
ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    POSITION pos;
    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = AllocTString(cchDest);
    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPTSTR pch = lpstrDest;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        lstrcpy(pch, (LPCTSTR)str);
        pch += str.GetLength();
        *pch++ = _T('\0');
    }

    *pch++ = _T('\0');

    if (fNullPad)
    {
        *pch++ = _T('\0');
    }

    return ERROR_SUCCESS;
}


int
ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert a line containing multiple strings separated by
    a given character to a CStringListEx

Arguments:

    LPCTSTR lpstrIn         : Input line
    CStringListEx & strlOut : Output stringlist
    LPCTSTR lpstrSep        : List of separators

Return Value:

    The number of items added

--*/
{
    int cItems = 0;
    strlOut.RemoveAll();

    try
    {
        CString strSrc(lpstrIn);
        LPTSTR lp = strSrc.GetBuffer(0);
        lp = StringTok(lp, lpstrSep);

        while (lp)
        {
            CString str(lp);

            strlOut.AddTail(str);
            lp = StringTok(NULL, lpstrSep);
            ++cItems;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception converting CSV list to stringlist");
        e->ReportError();
        e->Delete();
    }

    return cItems;
}




LPCTSTR
ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert stringlist into a single CString, each entry seperated by the given
    seperator string.

Arguments:

    CStringListEx & strlIn  : Input stringlist
    CString & strOut        : Output string
    LPCTSTR lpstrSep        : Seperator string

Return Value:

    Pointer to the output string.

--*/
{
    __try 
    {
        strOut.Empty();
        POSITION pos = strlIn.GetHeadPosition();
        BOOL      fAddSep = FALSE;

        while(pos)
        {
            CString & str = strlIn.GetNext(pos);

            if ( fAddSep )
            {
                strOut += lpstrSep;
            }

            if (str)
            {
                strOut += str;
            }
            fAddSep = TRUE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("nException Caught in ConvertStringListToSepLine()=0x%x.."),GetExceptionCode()));
    }

    return strOut;
}



LPTSTR
StringTok(
    IN LPTSTR string,
    IN LPCTSTR control
    )
/*++

Routine Description:

    strtok replacement function.

Arguments:

    LPTSTR string       : string, see strtok
    LPCTSTR control     : seperators, see strtok

Return Value:

    Pointer to string or NULL, see strtok.

Notes:

    This function is NOT thread-safe.

--*/
{
    LPTSTR str;
    LPCTSTR ctrl = control;

    TCHAR map[32];

    static LPTSTR nextoken;

    //
    // Clear control map
    //
    ZeroMemory(map, sizeof(map));

    //
    // Set bits in delimiter table
    //
    do
    {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    }
    while (*ctrl++);

    //
    // Initialize str. If string is NULL, set str to the saved
    // pointer (i.e., continue breaking tokens out of the string
    // from the last StringTok call)
    //
    if (string != NULL)
    {
        str = string;
    }
    else
    {
        str = nextoken;
    }

    //
    // Find beginning of token (skip over leading delimiters). Note that
    // there is no token iff this loop sets str to point to the terminal
    // null (*str == '\0').
    //
#ifdef UNICODE
    //
    // To avoid index overflow, check non-ASCII characters (UNICODE)
    //
    while (!(*str & 0xff00) &&
        (map[*str >> 3] & (1 << (*str & 7))) && *str)
#else
    while ((map[*str >> 3] & (1 << (*str & 7))) && *str)
#endif // UNICODE
    {
        ++str;
    }

    string = str;

    //
    // Find the end of the token. If it is not the end of the string,
    // put a null there.
    //
    for ( /**/ ; *str ; str++ )
    {
#ifdef UNICODE
        //
        // To avoid index overflow, check non-ASCII characters (UNICODE)
        //
        if ( !(*str & 0xff00) &&
            map[*str >> 3] & (1 << (*str & 7)) )
#else
        //
        // Skip DBCS character (ANSI)
        //
        if (IsDBCSLeadByte(*str) && *(str + 1))
        {
            ++str;
        }
        else if ( map[*str >> 3] & (1 << (*str & 7)) )
#endif // UNICODE
        {
            *str++ = '\0';
            break;
        }
    }

    //
    // Update nextoken structure
    //
    nextoken = str;

    //
    // Determine if a token has been found.
    //
    return string != str ? string : NULL;
}



BOOL
CStringListEx::operator ==(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Compare against CStringList.  In order for two CStringLists to match,
    they must match in every element, which must be in the same order.

Arguments:

    CStringList strl       : String list to compare against.

Return Value:

    TRUE if the two string lists are identical

--*/
{
    if (strl.GetCount() != GetCount())
    {
        return FALSE;
    }

    POSITION posa = strl.GetHeadPosition();
    POSITION posb = GetHeadPosition();

    while (posa)
    {
        ASSERT(posa);
        ASSERT(posb);

        CString strA = strl.GetNext(posa);
        CString strB = GetNext(posb);

        if (strA != strB)
        {
            return FALSE;
        }
    }

    return TRUE;
}


/*
void
CopyCList(
    OUT CStringList & strlDest,
    IN  CStringList & strlSrc
    )
/*++

Routine Description:

    Assign one stringlist to another.  This is a simple member by member
    copy.

Arguments:

    CStringList & strlDest      : Destination stringlist
    CStringList & strlSrc       : Source stringlist

Return Value:

    None

--/
{
    strlDest.RemoveAll();
    POSITION pos = strlSrc.GetHeadPosition();
    while(pos)
    {
        CString & str = strlSrc.GetNext(pos);
        strlDest.AddTail(str);
    }
}


*/

CStringListEx & 
CStringListEx::operator =(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CStringList & strl        : Source stringlist

Return Value:

    Reference to this

--*/
{
    RemoveAll();
    POSITION pos = strl.GetHeadPosition();
    while(pos)
    {
        AddTail( strl.GetNext(pos) );
    }

    return *this;
}



BOOL
SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    )
/*++

Routine Description:

    Split the user name and domain from the given
    username, which is in the format "domain\user".

    Return TRUE if the user name contained a domain
    FALSE if it did not

Arguments:

    CString & strUserName   : User name which may contain a domain name
    CString & strDomainName : Output domain name ("." if local)

Return Value:

    TRUE if a domain is split off

--*/
{
    //
    // Assume local
    //
    strDomainName = _T(".");
    int nSlash = strUserName.Find(_T("\\"));
    if (nSlash >= 0)
    {
        strDomainName = strUserName.Left(nSlash);
        strUserName = strUserName.Mid(nSlash + 1);

        return TRUE;
    }

    return FALSE;
}






const LPCTSTR g_cszMonths[] =
{
    _T("Jan"),
    _T("Feb"),
    _T("Mar"),
    _T("Apr"),
    _T("May"),
    _T("Jun"),
    _T("Jul"),
    _T("Aug"),
    _T("Sep"),
    _T("Oct"),
    _T("Nov"),
    _T("Dec"),
};



const LPCTSTR g_cszWeekDays[] =
{
    _T("Sun"),
    _T("Mon"),
    _T("Tue"),
    _T("Wed"),
    _T("Thu"),
    _T("Fri"),
    _T("Sat"),
};



inline BOOL SkipTillDigit(LPCTSTR & lp)
{
    while (lp && *lp && !_istdigit(*lp)) ++lp;

    return lp != NULL;
}



inline BOOL SkipPastDigits(LPCTSTR & lp)
{
    while (lp && *lp && _istdigit(*lp)) ++lp;

    return lp != NULL;
}



BOOL
FetchIntField(
    LPCTSTR & lp,
    int & n
    )
{
    if (SkipTillDigit(lp))
    {
        n = _ttoi(lp);
        if (n < 0)
        {
            ASSERT(FALSE && "Bogus string->int");
            return FALSE;
        }

        return SkipPastDigits(lp);
    }

    return FALSE;
}



BOOL
MatchString(
    LPCTSTR lpTarget,
    const LPCTSTR * rglp,
    int cElements,
    int & idx
    )
{
    for (idx = 0; idx < cElements; ++idx)
    {
        if (!_tcsnicmp(lpTarget, rglp[idx], _tcslen(rglp[idx])))
        {
            return TRUE;
        }
    }

    return FALSE;
}



static g_dwCurrentTimeZone = TIME_ZONE_ID_INVALID;
static TIME_ZONE_INFORMATION g_tzInfo;


//
// International numeric strings
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Initialize library
//
BOOL
InitIntlSettings()
{
#ifdef _MT
    INITIALIZE_CRITICAL_SECTION(&_csSect);
#endif // _MT

    return CINumber::Allocate();
}



//
// De-initialize library
//
void
TerminateIntlSettings()
{
    CINumber::DeAllocate();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT
}



//
// Static Member Initialization
//
CString * CINumber::s_pstrThousandSeperator = NULL;
CString * CINumber::s_pstrDecimalPoint = NULL;
CString * CINumber::s_pstrBadNumber = NULL;
CString * CINumber::s_pstrCurrency = NULL;
CString * CINumber::s_pstr = NULL;
BOOL CINumber::s_fAllocated = FALSE;
BOOL CINumber::s_fCurrencyPrefix = TRUE;
BOOL CINumber::s_fInitialized = FALSE;



#ifdef _DOS



BOOL
_dos_getintlsettings(
    OUT INTLFORMAT * pStruct
    )
/*++

Routine Description:

    Get the international settings on a DOS box

Parameters:

    INTLFORMAT * pStruct : Structure to be filled in.

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    TRACEEOLID("[_dos_getintlsetting]");
    union _REGS inregs, outregs;
    struct _SREGS segregs;

    inregs.h.ah = 0x38;   // Intl call
    inregs.h.al = 0x00;   // Current country code
    inregs.x.bx = 0x00;   // Current country code

    segregs.ds  = _FP_SEG(pStruct);
    inregs.x.dx = _FP_OFF(pStruct);

    int nError = _intdosx(&inregs, &outregs, &segregs);

    return outregs.x.cflag == 0;
}

#endif // _DOS



/* protected */
CINumber::CINumber()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
{
    if (!CINumber::s_fInitialized)
    {
        CINumber::Initialize();
    }
}



CINumber::~CINumber()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



/* protected */
/* static */
BOOL
CINumber::Allocate()
/*++

Routine Description:

    Allocate with US settings

Arguments:

    None

Return Value:

    TRUE if allocation was successfull, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    ASSERT(!IsAllocated());
    if (!IsAllocated())
    {
        try
        {
            CINumber::s_pstrThousandSeperator = new CString(_T(","));
            CINumber::s_pstrDecimalPoint = new CString(_T("."));
            CINumber::s_pstrBadNumber = new CString(_T("--"));
            CINumber::s_pstrCurrency = new CString(_T("$ "));
            CINumber::s_pstr = new CString;
            s_fAllocated = TRUE;
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Initialization Failed");
            e->ReportError();
            e->Delete();
        }
    }

    LowerThreadProtection();

    return IsAllocated();
}



/* protected */
/* static */
void
CINumber::DeAllocate()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    RaiseThreadProtection();
    
    ASSERT(IsAllocated());
    if (IsAllocated())
    {
        MAKE_NULL(CINumber::s_pstrThousandSeperator);
        MAKE_NULL(CINumber::s_pstrDecimalPoint);
        MAKE_NULL(CINumber::s_pstrBadNumber);
        MAKE_NULL(CINumber::s_pstrCurrency);
        MAKE_NULL(CINumber::s_pstr);
    }

    LowerThreadProtection();

    s_fAllocated = FALSE;
}



/* static */
/* protected */
BOOL
CINumber::Initialize(
    IN BOOL fUserSetting /* TRUE */
    )
/*++

Routine Description:

    Initialize all the international settings, such as thousand
    seperators and decimal points

Parameters:

    BOOL    fUserSetting        If TRUE, use current user settings,
                                if FALSE use system settings.
Return Value:

    TRUE for success, FALSE for failure

Notes:

    Note that this function only needs to be explicitly called
    when the country settings have changed, or when system
    settings are desired (user is default)

--*/
{
#define MAXLEN  6

    int cErrors = 0;

    TRACEEOLID("Getting locale-dependend information");

    ASSERT(IsAllocated());
    if (!IsAllocated())
    {
        Allocate();
    }

    RaiseThreadProtection();

    try
    {

#if defined(_MAC)

        TRACEEOLID("Couldn't get international settings from system");

#elif defined(_WIN32)

        LCID lcid = fUserSetting
            ? ::GetUserDefaultLCID()
            : GetSystemDefaultLCID();

        LCTYPE lctype = fUserSetting ? 0 : LOCALE_NOUSEROVERRIDE;

        //
        // Get Decimal Point
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SDECIMAL | lctype,
            CINumber::s_pstrDecimalPoint->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get intl decimal point");
            ++cErrors;
        }

        CINumber::s_pstrDecimalPoint->ReleaseBuffer();

        //
        // Get Thousand Seperator
        //
        if (!::GetLocaleInfo(
            lcid, LOCALE_STHOUSAND | lctype,
            CINumber::s_pstrThousandSeperator->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get 1000 seperator");
            ++cErrors;
        }

        CINumber::s_pstrThousandSeperator->ReleaseBuffer();

#ifndef _UNICODE

        //
        // Some countries have a space as a 1000 seperator,
        // but for some reason, this is ansi 160, which
        // shows up as a space fine on windows apps,
        // looks like garbage on console apps.
        //
        if ( ( (UCHAR) ( *(CINumber::s_pstrThousandSeperator) )[0] ) == ( (UCHAR) 160 ) )
        {
            CINumber::s_pstrThousandSeperator->SetAt(0, ' ');
            TRACEEOLID("Space 1000 seperator substituted");
        }

#endif // _UNICODE

        //
        // Get currency symbol
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SCURRENCY | lctype,
            CINumber::s_pstrCurrency->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get currency symbol");
            ++cErrors;
        }

        CINumber::s_pstrCurrency->ReleaseBuffer();

#elif defined(_WIN16)

        //
        // Get Decimal Point
        //
        ::GetProfileString(
            "Intl",
            "sDecimal",
            ".",
            CINumber::s_pstrDecimalPoint->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrDecimalPoint->ReleaseBuffer();

        //
        // Get 1000 seperator
        //
        ::GetProfileString(
            "Intl",
            "sThousand",
            ",",
            CINumber::s_pstrThousandSeperator->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrThousandSeperator->ReleaseBuffer();

        //
        // Get currency symbol
        //
        ::GetProfileString(
            "Intl",
            "sCurrency",
            ",",
            CINumber::s_pstrCurrency->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrCurrency->ReleaseBuffer();

#elif defined(_DOS)

        INTLFORMAT fm;

        if (_dos_getintlsettings(&fm))
        {
            //
            // Get Decimal Point
            //
            *CINumber::s_pstrDecimalPoint = fm.szDecimalPoint;

            //
            // Get 1000 seperator
            //
            *CINumber::s_pstrThousandSeperator = fm.szThousandSep;

            //
            // Get Currency Symbol
            //
            *CINumber::s_pstrCurrency = fm.szCurrencySymbol;
        }
        else
        {
            TRACEEOLID("Unable to get intl settings");
            ++cErrors;
        }

#endif // _WIN32 etc

    }

    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception in getting intl settings:");
        e->ReportError();
        e->Delete();
        ++cErrors;
    }

    TRACEEOLID("Thousand Seperator . . . . . : " << *CINumber::s_pstrThousandSeperator);
    TRACEEOLID("Decimal Point  . . . . . . . : " << *CINumber::s_pstrDecimalPoint);
    TRACEEOLID("Currency Symbol. . . . . . . : " << *CINumber::s_pstrCurrency);
    TRACEEOLID("Bad number . . . . . . . . . : " << *CINumber::s_pstrBadNumber);
    TRACEEOLID("Currency Prefix. . . . . . . : " << CINumber::s_fCurrencyPrefix);

    CINumber::s_fInitialized = TRUE;

    LowerThreadProtection();

    return cErrors == 0;
}



/* static */
double
CINumber::BuildFloat(
    IN const LONG lInteger,
    IN const LONG lFraction
    )
/*++

Return Value:

    Combine integer and fraction to form float

Parameters:

    const LONG lInteger       Integer portion
    const LONG lFraction      Fractional portion

Return Value:

    float value

--*/
{
    double flValue = 0.0;

    //
    // Negative fractions?
    //
    ASSERT(lFraction >= 0);

    if (lFraction >= 0)
    {
        flValue = (double)lFraction;
        while (flValue >= 1.0)
        {
            flValue /= 10.0;
        }

        //
        // Re-add (or subtract if the original number
        // was negative) the fractional part
        //
        if (lInteger > 0L)
        {
            flValue += (double)lInteger;
        }
        else
        {
            flValue -= (double)lInteger;
            flValue = -flValue;
        }
    }

    return flValue;
}



/* static */
LPCTSTR
CINumber::ConvertLongToString(
    IN  const LONG lSrc,
    OUT CString & str
    )
/*++

CINumber::ConvertLongToString

Purpose:

    Convert long number to string with 1000 seperators

Parameters:

    const LONG lSrc         Source number
    CString & str           String to write to

Return Value:

    Pointer to converted string

--*/
{
    LPTSTR lpOutString = str.GetBuffer(16);

    //
    // Forget about the negative sign for now.
    //
    LONG lNum = (lSrc >= 0L) ? lSrc : -lSrc;
    int outstrlen = 0;
    do
    {
        lpOutString[outstrlen++] = _T('0') + (TCHAR)(lNum % 10L);
        lNum /= 10L;

        //
        // if more digits left and we're on a 1000 boundary (printed 3 digits,
        // or 3 digits + n*(3 digits + 1 comma), then print a 1000 separator.
        // Note: will only work if the 1000 seperator is 1 character.
        //
        ASSERT(CINumber::s_pstrThousandSeperator->GetLength() == 1);
        if (lNum != 0L && (outstrlen == 3 || outstrlen == 7 || outstrlen == 11))
        {
            lstrcpy(lpOutString + outstrlen, *CINumber::s_pstrThousandSeperator);
            outstrlen += CINumber::s_pstrThousandSeperator->GetLength();
        }

    }
    while (lNum > 0L);

    //
    // Add a negative sign if necessary.
    //
    if (lSrc < 0L)
    {
        lpOutString[outstrlen++] = _T('-');
    }

    str.ReleaseBuffer(outstrlen);
    str.MakeReverse();

    return (LPCTSTR)str;
}



/* static */
LPCTSTR
CINumber::ConvertFloatToString(
    IN const double flSrc,
    IN int nPrecision,
    OUT CString & str
    )
/*++

Routine Description:

    Convert floating point number to string represenation

Parameters:

    const double flSrc          Source floating point number
    int nPrecision              Number of decimal points
    CString & str               String to convert to

Return Value:

    Pointer to converted string.

--*/
{
    //
    // Forget about the negative sign for now,
    // and the fractional portion.
    //
    TCHAR szFraction[256];
    LPCTSTR lpFraction = NULL;

    ::_stprintf(szFraction, _T("%.*f"), nPrecision, flSrc);
    lpFraction = ::_tcschr(szFraction, _T('.') );
    ASSERT(lpFraction != NULL);
    ++lpFraction;

    CINumber::ConvertLongToString((LONG)flSrc, str);

    str += *CINumber::s_pstrDecimalPoint + lpFraction;

    return (LPCTSTR)str;
}



/* static */
BOOL
CINumber::ConvertStringToLong(
    IN  LPCTSTR lpsrc,
    OUT LONG & lValue
    )
/*++

Routine Description:

    Convert string to long integer.  1000 Seperators will be treated
    correctly.

Parameters:

    LPCTSTR lpsrc       Source string
    LONG & lValue       Value to convert to.  Will be 0 in case of error

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    CString strNumber(lpsrc);
    LONG lBase = 1L;
    BOOL fNegative = FALSE;

    lValue = 0L;

    //
    // Empty strings are invalid
    //
    if (strNumber.IsEmpty())
    {
        return FALSE;
    }

    //
    // Check for negative sign (at the end only)
    //
    if (strNumber[0] == _T('-'))
    {
        fNegative = TRUE;
    }

    strNumber.MakeReverse();

    //
    // Strip negative sign
    //
    if (fNegative)
    {
        strNumber.ReleaseBuffer(strNumber.GetLength()-1);
    }

    //
    // Make sure the 1000 seperator is only 1 char.  See note below
    //
    ASSERT(CINumber::s_pstrThousandSeperator->GetLength() == 1);
    for (int i = 0; i < strNumber.GetLength(); ++i)
    {
        if ((strNumber[i] >= _T('0')) && (strNumber[i] <= _T('9')))
        {
            LONG lDigit = (LONG)(strNumber[i] - _T('0'));
            if (lDigit != 0L)
            {
                LONG lOldValue = lValue;
                LONG lDelta = (lDigit * lBase);
                if (lDelta / lDigit != lBase)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }

                lValue += lDelta;
                if (lValue - lDelta != lOldValue)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }
            }

            lBase *= 10L;
        }
        //
        // It's not a digit, maybe a thousand seperator?
        // CAVEAT: If a thousand seperator of more than
        //         one character is used, this won't work.
        //
        else if ((strNumber[i] != (*CINumber::s_pstrThousandSeperator)[0])
             || (i != 3) && (i != 7) && (i != 11))
        {
            //
            // This is just invalid, since it is not a thousand
            // seperator in the proper location, nor a negative
            // sign.
            //
            TRACEEOLID("Invalid character " << (BYTE)strNumber[i] << " encountered");
            return FALSE;
        }
    }

    if (fNegative)
    {
        lValue = -lValue;
    }

    return TRUE;
}



/* static */
BOOL
CINumber::ConvertStringToFloat(
    IN  LPCTSTR lpsrc,
    OUT double & flValue
    )
/*++

Routine Description:

    Convert fully decorated floating point string to double

Parameters:

    LPCTSTR lpsrc       Source string
    double & flValue    float value generated from string

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    CString strNumber(lpsrc);

    //
    // This only works if the decimal point is a
    // single character
    //
    ASSERT(CINumber::s_pstrDecimalPoint->GetLength() == 1);

    //
    // Strip off the > 0 part
    //
    LONG lFraction = 0;

    int nPoint = strNumber.ReverseFind((*CINumber::s_pstrDecimalPoint)[0]);

    if (nPoint >= 0)
    {
        //
        // Convert fractional part
        //
        LPCTSTR lpszFraction = (LPCTSTR)strNumber + ++nPoint;
        lFraction = ::_ttol(lpszFraction);
        strNumber.ReleaseBuffer(--nPoint);
    }

    //
    // Convert integer part
    //
    LONG lInteger;
    if (ConvertStringToLong(strNumber, lInteger))
    {
        flValue = CINumber::BuildFloat(lInteger, lFraction);
        return TRUE;
    }

    return FALSE;
}



CILong::CILong()
/*++

Routine Description:

    Constructor without arguments

Parameters:

    None.

Return Value:

    N/A

--*/
    : m_lValue(0L)
{
}



CILong::CILong(
    IN LONG lValue
    )
/*++

Routine Description:

    Constructor taking LONG argument

Parameters:

    LONG lValue     Value to be set

Return Value:

    N/A

--*/
    : m_lValue(lValue)
{
}



CILong::CILong(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Constructor taking string argument

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    N/A

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);
}



CILong &
CILong::operator =(
    IN LONG lValue
    )
/*++

Routine Description:

    Assignment operator taking long value

Parameters:

    LONG lValue     Value to be set

Return Value:

    this object

--*/
{
    m_lValue = lValue;

    return *this;
}



CILong &
CILong::operator =(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Assignment operator taking string value

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    this object

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);

    return *this;
}



//
// Arithmetic Shorthand operators
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CILong &
CILong::operator +=(
    IN const LONG lValue
    )
{
    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const CILong& value
    )
{
    m_lValue += value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LONG lValue
    )
{
    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const CILong& value
    )
{
    m_lValue -= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LONG lValue
    )
{
    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const CILong& value
    )
{
    m_lValue *= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LONG lValue
    )
{
    if (lValue != 0)
    {
        m_lValue /= lValue;
    }

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    if (0 == lValue)
    {
        m_lValue = 0;
    }
    else
    {
        m_lValue /= lValue;
    }

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const CILong& value
    )
{
    m_lValue /= value.m_lValue;

    return *this;
}



CIFloat::CIFloat(
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor without arguments

Parameters:

    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_flValue(0.0),
      m_nPrecision(nPrecision)
{
}



CIFloat::CIFloat(
    IN double flValue,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking double argument

Parameters:

    double flValue              Value to be set
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_flValue(flValue),
      m_nPrecision(nPrecision)
{
}



CIFloat::CIFloat(
    IN LONG lInteger,
    IN LONG lFraction,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking integer and fraction argument

Parameters:

    LONG lInteger               Integer portion
    LONG lFraction              Fractional portion
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_nPrecision(nPrecision)
{
    m_flValue = CINumber::BuildFloat(lInteger, lFraction);
}



CIFloat::CIFloat(
    IN LPCTSTR lpszValue,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking string argument

Parameters:

    LPCTSTR lpszValue           String number
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_nPrecision(nPrecision)
{
    ConvertStringToFloat(lpszValue, m_flValue);
}



CIFloat &
CIFloat::operator =(
    IN double flValue
    )
/*++

Routine Description:

    Assignment operator taking double value

Parameters:

    double flValue     Value to be set

Return Value:

    this object

--*/
{
    m_flValue = flValue;

    return *this;
}



CIFloat &
CIFloat::operator =(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Assignment operator taking string value

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    this object

--*/
{
    ConvertStringToFloat(lpszValue, m_flValue);

    return *this;
}



//
// Arithmetic Shorthand operators
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIFloat &
CIFloat::operator +=(
    IN const double flValue
    )
{
    m_flValue += flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator +=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue += flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator +=(
    IN const CIFloat& value
    )
{
    m_flValue += value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const double flValue
    )
{
    m_flValue -= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue -= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const CIFloat& value
    )
{
    m_flValue -= value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const double flValue
    )
{
    m_flValue *= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue *= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const CIFloat& value
    )
{
    m_flValue *= value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const double flValue
    )
{
    m_flValue /= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);
    if (flValue != 0)
    {
        m_flValue /= flValue;
    }

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const CIFloat& value
    )
{
    m_flValue /= value.m_flValue;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\svc.cpp ===
#include "stdafx.h"
#include <winsvc.h>
#include <winsock2.h>
#include <nspapi.h>
#include "w3svc.h"
#include <inetsvcs.h>
#include <pwsdata.hxx>
#include "kill.h"
#include "svc.h"

TCHAR gServicesWhichMustBeRestarted[20][PROCESS_SIZE];
int gServicesWhichMustBeRestarted_nextuse = 0;
int gServicesWhichMustBeRestarted_total = 0;

extern int g_GlobalDebugLevelFlag;

int ServicesRestartList_EntryExists(LPCTSTR szServiceName)
{
    int iFoundMatch = FALSE;

    // loop thru the whole list
    for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
    {
        if (_tcsicmp(gServicesWhichMustBeRestarted[i], szServiceName) == 0)
        {
            iFoundMatch = TRUE;
            break;
        }
    }

    return iFoundMatch;
}


int ServicesRestartList_Add(LPCTSTR szServiceName)
{
    // check if this value already exists in the globalarary
    if (ServicesRestartList_EntryExists(szServiceName)) {return FALSE;}

    // move info into global array
    if (gServicesWhichMustBeRestarted_nextuse <= 20)
    {
        _tcscpy(gServicesWhichMustBeRestarted[gServicesWhichMustBeRestarted_nextuse],szServiceName);
        // increment counter to array
        // increment next use space
        ++gServicesWhichMustBeRestarted_total;
        ++gServicesWhichMustBeRestarted_nextuse;
    }
    return TRUE;
}

int ServicesRestartList_RestartServices(void)
{
    int iReturn = FALSE;
    INT err = 0;

    // loop thru the whole list and restart the services in reverse
    // order from how they were entered?
    if (gServicesWhichMustBeRestarted_total >= 1)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("RestartServices()Start.\n")));
        for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
        {
            if (CheckifServiceExist(gServicesWhichMustBeRestarted[i]) == 0 )
            {
                err = InetStartService(gServicesWhichMustBeRestarted[i]);
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("RestartServices():%s:Not restarting since it no longer exist.\n"),gServicesWhichMustBeRestarted[i]));
            }
        }
        iisDebugOut_End(_T("RestartServices"));
    }

    return iReturn;
}

DWORD InetStopExtraWait(LPCTSTR lpServiceName)
{
    DWORD dwSvcMaxSleep = 180000;
    int iFileExist = FALSE;

    // Wait.  How long should we really wait for this service to actually stop?
    // the iisadmin Service can take a long time if the metabase.bin file is huge.
    // So... if it's the iisadmin service we're trying to stop, then
    // check to see how big the metabase.bin file is, then for each 1meg give it 3 minutes (180000)
    if (_tcsicmp(lpServiceName,_T("IISADMIN")) == 0)
    {
        // look for the metabase.bin file
        TCHAR szTempDir[_MAX_PATH];
        _tcscpy(szTempDir, g_pTheApp->m_csPathInetsrv);
        AddPath(szTempDir, _T("Metabase.bin"));
        if (IsFileExist(szTempDir))
        {
            iFileExist = TRUE;
        }
        else
        {
            _tcscpy(szTempDir, g_pTheApp->m_csPathInetsrv);
            AddPath(szTempDir, _T("Metabase.xml"));
            if (IsFileExist(szTempDir))
            {
                iFileExist = TRUE;
            }
        }

        if (TRUE == iFileExist)
        {
            // Check to see how big it is.
            DWORD dwFileSize = ReturnFileSize(szTempDir);
            if (dwFileSize != 0xFFFFFFFF)
            {
                int iTime = 1;
                // We were able to get the file size.
                // for each meg for size, give it 3 minutes to save.
                if (dwFileSize > 1000000)
                {
                    iTime = (dwFileSize/1000000);
                    dwSvcMaxSleep = iTime * 180000;

                    iisDebugOut((LOG_TYPE_TRACE, _T("InetStopExtraWait():Metabase.bin is kind of big (>1meg), Lets wait longer for IISADMIN service to stop.maxmilsec=0x%x.\n"),dwSvcMaxSleep));
                }
            }
        }
    }
    return dwSvcMaxSleep;
}

// function: IsServiceDisabled
//
// Check to see if the service being sent in is disabled
BOOL
IsServiceDisabled(LPTSTR szServiceName)
{
  SC_HANDLE hService;
  SC_HANDLE hSCManager;
  BOOL      bRet = FALSE;
  BUFFER    buffConfig;
  DWORD     dwSizeRequired;

  hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT | GENERIC_READ );

  if ( hSCManager == NULL )
  {
    return FALSE;
  }

  hService = OpenService( hSCManager, szServiceName, SERVICE_QUERY_CONFIG );

  if ( hService == NULL )
  {
    CloseServiceHandle( hSCManager );
    return FALSE;
  }

  if ( !QueryServiceConfig( hService, NULL, 0, &dwSizeRequired ) &&
       ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) &&
       buffConfig.Resize( dwSizeRequired ) &&
       QueryServiceConfig( hService, (LPQUERY_SERVICE_CONFIG) buffConfig.QueryPtr(), buffConfig.QuerySize(), &dwSizeRequired )
    )
  {
    // Check the service Startup Type
    bRet = ((LPQUERY_SERVICE_CONFIG) buffConfig.QueryPtr())->dwStartType == SERVICE_DISABLED;
  }

  CloseServiceHandle( hSCManager );
  CloseServiceHandle( hService );

  return bRet;
}

// function: SetServiceStart
//
// Change the service state
void
SetServiceStart(LPTSTR szServiceName, DWORD dwServiceStart)
{
  SC_HANDLE hService;
  SC_HANDLE hSCManager;

  hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT | GENERIC_READ );

  if ( hSCManager == NULL )
  {
    return;
  }

  hService = OpenService( hSCManager, szServiceName, SERVICE_CHANGE_CONFIG );

  if ( hService == NULL )
  {
    CloseServiceHandle( hSCManager );
    return;
  }

  ChangeServiceConfig(  hService,
                        SERVICE_NO_CHANGE,      // ServiceType
                        dwServiceStart,         // Startup
                        SERVICE_NO_CHANGE,      // Error Control
                        NULL,                   // Binary Path
                        NULL,                   // Load order group
                        NULL,                   // TagId
                        NULL,                   // Dependencies
                        NULL,                   // Service Start Name
                        NULL,                   // Password
                        NULL );                 // StartName

  CloseServiceHandle( hSCManager );
  CloseServiceHandle( hService );
}

INT InetDisableService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    DWORD dwSvcMaxSleep = 180000 ;
    DWORD dwSleepTotal;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    // Calculcate if this is a "special" service which we
    // need to give more time to in order to stop.
    dwSvcMaxSleep = InetStopExtraWait(lpServiceName);

    do {
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        // if the service is running, stop it
        SERVICE_STATUS svcStatus;
        if ( QueryServiceStatus( hService, &svcStatus ))
        {
            if (( svcStatus.dwCurrentState == SERVICE_RUNNING ))
            {
                if ( !ControlService( hService, SERVICE_CONTROL_STOP, &svcStatus ))
                {
                    err = GetLastError();
                    break;
                }
                for ( dwSleepTotal = 0 ;
                    dwSleepTotal < dwSvcMaxSleep
                    && (QueryServiceStatus( hService, & svcStatus ))
                    && svcStatus.dwCurrentState == SERVICE_STOP_PENDING ;
                    dwSleepTotal += dwSvcSleepInterval )
                {
                    ::Sleep( dwSvcSleepInterval ) ;
                }
            }
        }

        if ( !ChangeServiceConfig( hService, 
                                   SERVICE_NO_CHANGE, 
                                   SERVICE_DISABLED,
                                   SERVICE_NO_CHANGE, 
                                   NULL, 
                                   NULL, 
                                   NULL, 
                                   NULL, 
                                   NULL, 
                                   NULL, 
                                   NULL ) )
        {
          err = GetLastError();
        }

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetDisableService():ServiceName=%s.  Return=0x%x\n"), lpServiceName, err));
    return(err);
}

INT InetStartService( LPCTSTR lpServiceName )
{
    iisDebugOut_Start1(_T("InetStartService"),(LPTSTR) lpServiceName);

    INT err = 0;
    INT err2 = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    DWORD dwSvcMaxSleep = 180000 ;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    // Calculcate if this is a "special" service which we
    // need to give more time to in order to stop.
    dwSvcMaxSleep = InetStopExtraWait(lpServiceName);

    do
    {
        // set up the service first
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_RUNNING )
        {
            // We will only get this ERROR_SERVICE_MARKED_FOR_DELETE
            // message if the service is already running.
            if ( !::StartService( hService, 0, NULL ))
            {
                err2 = ::GetLastError();
                if (err2 == ERROR_SERVICE_MARKED_FOR_DELETE) {err = err2;}
            }
            break; // service already started and running
        }

        if ( !::StartService( hService, 0, NULL ))
        {
            err = ::GetLastError();
            break;
        }

        //  Wait for the service to attain "running" status; but
        //  wait no more than 3 minute.
        DWORD dwSleepTotal;
        for ( dwSleepTotal = 0 ; dwSleepTotal < dwSvcMaxSleep
            && (QueryServiceStatus( hService, &svcStatus ))
            && svcStatus.dwCurrentState == SERVICE_START_PENDING ;
            dwSleepTotal += dwSvcSleepInterval )
        {
            ::Sleep( dwSvcSleepInterval ) ;
        }

        if ( svcStatus.dwCurrentState != SERVICE_RUNNING )
        {
            err = dwSleepTotal > dwSvcMaxSleep ? ERROR_SERVICE_REQUEST_TIMEOUT : svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    if (err){iisDebugOut((LOG_TYPE_WARN, _T("InetStartService():ServiceName=%s unable to start WARNING.  Err=0x%x.\n"), lpServiceName, err));}
    else{iisDebugOut((LOG_TYPE_TRACE, _T("InetStartService():ServiceName=%s success.\n"), lpServiceName));}
    return(err);
}

DWORD InetQueryServiceStatus( LPCTSTR lpServiceName )
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetQueryServiceStatus():ServiceName=%s\n"), (LPTSTR) lpServiceName));
    DWORD dwStatus = 0;
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS svcStatus;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL ||
            !::QueryServiceStatus( hService, &svcStatus ) )
        {
            err = GetLastError();
            break;
        }

        dwStatus = svcStatus.dwCurrentState;

    } while (0);

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetQueryServiceStatus():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return( dwStatus );
}

INT InetStopService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    DWORD dwSvcMaxSleep = 180000 ;
    DWORD dwSleepTotal;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    // Calculcate if this is a "special" service which we
    // need to give more time to in order to stop.
    dwSvcMaxSleep = InetStopExtraWait(lpServiceName);

    do {
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_STOPPED )
            break; // service already stopped

         if (( svcStatus.dwCurrentState == SERVICE_RUNNING ))
        {
            if ( !ControlService( hService, SERVICE_CONTROL_STOP, &svcStatus ))
            {
                err = GetLastError();
                break;
            }
            for ( dwSleepTotal = 0 ;
                dwSleepTotal < dwSvcMaxSleep
                && (QueryServiceStatus( hService, & svcStatus ))
                && svcStatus.dwCurrentState == SERVICE_STOP_PENDING ;
                dwSleepTotal += dwSvcSleepInterval )
            {
                ::Sleep( dwSvcSleepInterval ) ;
            }
        }

        if ( svcStatus.dwCurrentState != SERVICE_STOPPED )
        {
            err = dwSleepTotal > dwSvcMaxSleep ?
                ERROR_SERVICE_REQUEST_TIMEOUT :
                svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetStopService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetDeleteService( LPCTSTR lpServiceName )
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    /*
    The DeleteService function marks a service for deletion from the service control manager database.
    The database entry is not removed until all open handles to the service have been closed by calls
    to the CloseServiceHandle function, and the service is not running. A running service is stopped
    by a call to the ControlService function with the SERVICE_CONTROL_STOP control code.
    If the service cannot be stopped, the database entry is removed when the system is restarted.
    The service control manager deletes the service by deleting the service key and its subkeys from
    the registry.
    */
    // To delete service immediately, we need to stop service first
    StopServiceAndDependencies(lpServiceName, FALSE);

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL ||
            !::DeleteService( hService ) )
        {
            err = GetLastError();
            break;
        }
    } while (0);

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetDeleteService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetCreateDriver(LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType)
{
    iisDebugOut_Start1(_T("InetCreateDriver"),(LPTSTR) lpServiceName);

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ( (hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }
		//
		// if Driver already exits then just change the parameters
		//
		if ( CheckifServiceExist(  lpServiceName ) == 0 ) {

			hService = OpenService( hScManager, lpServiceName, GENERIC_ALL );

			if ( hService ) {
	   			if ( ChangeServiceConfig(
						hService,  				// handle to service
					 	SERVICE_KERNEL_DRIVER,  // type of service
						dwStartType,  			// when to start service
					 	SERVICE_ERROR_NORMAL,  	// severity if service fails to start
					  	lpBinaryPathName,  		// pointer to service binary file name
						NULL,				  	// pointer to load ordering group name
					 	NULL, 		 			// pointer to variable to get tag identifier
					  	NULL, 					// pointer to array of dependency names
					 	NULL,  					// pointer to account name of service
					 	NULL, 	 				// pointer to password for service account
					  	lpDisplayName  			// pointer to display name
					 	) ){
					 	break;
            	}
			}

		} else {

	        hService = ::CreateService( hScManager, lpServiceName, lpDisplayName,
                GENERIC_ALL, SERVICE_KERNEL_DRIVER, dwStartType,
                SERVICE_ERROR_NORMAL, lpBinaryPathName, NULL, NULL,
                NULL, NULL, NULL );

	        if ( hService )  {
            	break;
	        }
		}
    	err = GetLastError();

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetCreateDriver():Name=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetCreateService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType, LPCTSTR lpDependencies)
{
    iisDebugOut_Start1(_T("InetCreateService"),(LPTSTR) lpServiceName);

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ( (hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        hService = ::CreateService( hScManager, lpServiceName, lpDisplayName,
                GENERIC_ALL, SERVICE_WIN32_SHARE_PROCESS, dwStartType,
                SERVICE_ERROR_NORMAL, lpBinaryPathName, NULL, NULL,
                lpDependencies, _T("LocalSystem"), NULL );
        if ( !hService )
        {
            err = GetLastError();
            break;
        }

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetCreateService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetConfigService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, LPCTSTR lpDependencies)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetConfigService():ServiceName=%s\n"), (LPTSTR) lpServiceName));

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
			iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigService():OpenSCManager or OpenService: Service=%s BinPathName=%s Dependencies=%s Err=0x%x FAILED\n"), lpServiceName, lpBinaryPathName, lpDependencies, err));
            break;
        }

        if ( !::ChangeServiceConfig(hService, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, lpBinaryPathName, NULL, NULL, lpDependencies, _T("LocalSystem"), NULL, lpDisplayName) )
        {
            err = GetLastError();
			iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigService():ChangeServiceConfig: Service=%s BinPathName=%s Dependencies=%s Err=0x%x FAILED\n"), lpServiceName, lpBinaryPathName, lpDependencies, err));
            break;
        }

    } while ( FALSE );

    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetConfigService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetConfigService2( LPCTSTR lpServiceName, LPCTSTR lpDescription)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetConfigService2():ServiceName=%s\n"), (LPTSTR) lpServiceName));

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_DESCRIPTION ServiceDescription;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
			iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigService2():OpenSCManager or OpenService: Service=%s Err=0x%x FAILED\n"), lpServiceName, err));
            break;
        }

        if (lpDescription)
        {
            if (_tcscmp(lpDescription, _T("")) != 0)
            {
                ServiceDescription.lpDescription = (LPTSTR) lpDescription;
                if (!ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, (LPVOID)&ServiceDescription))
                {
                    err = GetLastError();
			        iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigService2():ChangeServiceConfig2: Service=%s Err=0x%x FAILED\n"), lpServiceName, err));
                    break;
                }
            }
        }

    } while ( FALSE );

    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetConfigService2():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}


# define SetServiceTypeValues( pSvcTypeValue, dwNS, dwType, dwSize, lpValName, lpVal)   \
       ( pSvcTypeValue)->dwNameSpace = ( dwNS);          \
       ( pSvcTypeValue)->dwValueType = ( dwType);        \
       ( pSvcTypeValue)->dwValueSize = ( dwSize);        \
       ( pSvcTypeValue)->lpValueName = ( lpValName);     \
       ( pSvcTypeValue)->lpValue     = (PVOID ) ( lpVal); \

# define SetServiceTypeValuesDword( pSvcTypeValue, dwNS, lpValName, lpVal) \
   SetServiceTypeValues( (pSvcTypeValue), (dwNS), REG_DWORD, sizeof( DWORD), \
                         ( lpValName), ( lpVal))

BOOL InetRegisterService( LPCTSTR pszMachine, LPCTSTR   pszServiceName, GUID *pGuid, DWORD SapId, DWORD TcpPort, BOOL fAdd )
{
    iisDebugOut_Start1(_T("InetRegisterService"),(LPTSTR) pszServiceName);
    int err;

    WSADATA  WsaData;

    SERVICE_INFO serviceInfo;
    LPSERVICE_TYPE_INFO_ABS lpServiceTypeInfo ;
    LPSERVICE_TYPE_VALUE_ABS lpServiceTypeValues ;
    BYTE serviceTypeInfoBuffer[sizeof(SERVICE_TYPE_INFO) + 1024];
    // Buffer large enough for 3 values ( SERVICE_TYPE_VALUE_ABS)

    DWORD Value1 = 1 ;
    DWORD SapValue = SapId;
    DWORD TcpPortValue = TcpPort;
    DWORD statusFlags;

    //
    // Initialize Windows Sockets DLL
    //

    err = WSAStartup( 0x0101, & WsaData);
    if ( err == SOCKET_ERROR)
    {
        return ( FALSE);
    }


    //
    // Setup the service information to be passed to SetService() for adding
    //   or deleting this service. Most of the SERVICE_INFO fields are not
    //   required for add or delete operation. The main things of interests are
    //  GUIDs and ServiceSpecificInfo structure.
    //

    memset( (PVOID ) & serviceInfo, 0, sizeof( serviceInfo)); //null all fields

    serviceInfo.lpServiceType     =  pGuid;
    serviceInfo.lpMachineName     =  (LPTSTR)pszMachine;

    //
    // The "Blob" will contain the service specific information.
    // In this case, fill it with a SERVICE_TYPE_INFO_ABS structure
    //  and associated information.
    //
    serviceInfo.ServiceSpecificInfo.pBlobData = serviceTypeInfoBuffer;
    serviceInfo.ServiceSpecificInfo.cbSize    = sizeof( serviceTypeInfoBuffer);

    lpServiceTypeInfo = (LPSERVICE_TYPE_INFO_ABS ) serviceTypeInfoBuffer;

    //
    //  There are totally 3 values associated with this service if we're doing
    //  both SPX and TCP, there's only one value if TCP.
    //

    if ( SapId )
    {
        lpServiceTypeInfo->dwValueCount = 3;
    }
    else
    {
        lpServiceTypeInfo->dwValueCount = 1;
    }
    lpServiceTypeInfo->lpTypeName   = (LPTSTR)pszServiceName;

    lpServiceTypeValues = lpServiceTypeInfo->Values;

    if ( SapId )
    {
        //
        // 1st value: tells the SAP that this is a connection oriented service.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                  NS_SAP,                    // Name Space
                                  SERVICE_TYPE_VALUE_CONN,   // ValueName
                                  &Value1                    // actual value
                                  );

        //
        // 2nd Value: tells SAP about object type to be used for broadcasting
        //   the service name.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 1),
                                  NS_SAP,
                                  SERVICE_TYPE_VALUE_SAPID,
                                  &SapValue);

        //
        // 3rd value: tells TCPIP name-space provider about TCP/IP port to be used.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 2),
                                  NS_DNS,
                                  SERVICE_TYPE_VALUE_TCPPORT,
                                  &TcpPortValue);

    }
    else
    {
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                    NS_DNS,
                                    SERVICE_TYPE_VALUE_TCPPORT,
                                    &TcpPortValue);
    }
    //
    // Finally, call SetService to actually perform the operation.
    //
    err = SetService(
                     NS_DEFAULT,             // all default name spaces
                     ( fAdd ) ? SERVICE_ADD_TYPE : SERVICE_DELETE_TYPE,       // either ADD or DELETE
                     0,                      // dwFlags not used
                     &serviceInfo,           // the service info structure
                     NULL,                   // lpServiceAsyncInfo
                     &statusFlags            // additional status information
                     );

    // for some unknown reason, the SERVICE_DELETE_TYPE never remove the related registry
    // I have to manually clean it here.
    if (!fAdd)
    {
        CRegKey regSvcTypes(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\ServiceProvider\\ServiceTypes"));
        if ((HKEY)regSvcTypes) {regSvcTypes.DeleteTree(pszServiceName);}
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("InetRegisterService():ServiceName=%s.End.Return=%d.\n"), pszServiceName, err));
    return ( err != NO_ERROR);
} // InetRegisterService()

INT CheckifServiceExistAndDependencies( LPCTSTR lpServiceName )
{
    INT err = 0;
    INT iReturn = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    BYTE ConfigBuffer[4096];
    LPENUM_SERVICE_STATUS ServiceConfigEnum = (LPENUM_SERVICE_STATUS) &ConfigBuffer;

    if ((	hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
        // Failed, or more likely the service doesn't exist
        iReturn = GetLastError();
        goto CheckifServiceExistAndDependencies_Exit;
        }

    // There was no error and the service exists.
    // Then let's make sure the actual file exists!!!
    // The above calls will only return true if the service has been registered, but
    // the call doesn't actually check if the file exists!

	// Retrieve the service's config for the BinaryPathName
    // if it fails then hey, we don't have a correctly installed service
    // so return error!
    if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
    {
        iReturn = GetLastError();
	goto CheckifServiceExistAndDependencies_Exit;
    }
    if (!ServiceConfig)
    {
        iReturn = GetLastError();
	goto CheckifServiceExistAndDependencies_Exit;
    }

    if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
    {
        if (ServiceConfig->lpBinaryPathName)
        {
            if (IsFileExist(ServiceConfig->lpBinaryPathName))
            {
                // the service exists and the file exists too!
                iReturn = 0;
            }
            else
            {
                iReturn = ERROR_FILE_NOT_FOUND;
                goto CheckifServiceExistAndDependencies_Exit;
            }
        }
    }
    else
    {
        iReturn = 0;
    }


    // Get our list of services which we depend upon.
    // let's make sure they are registered and exist.

	// ServiceConfig->lpDependencies should look something like this
	// service\0service\0\0  double null terminated
    {
	TCHAR * pdest = NULL;
	long RightMostNull = 0;

	pdest = ServiceConfig->lpDependencies;
	do
	{
		if (*pdest != _T('\0'))
		{
			RightMostNull = RightMostNull + _tcslen(pdest) + 1;

            // Check if the service exists
            if (0 != CheckifServiceExistAndDependencies(pdest)){iReturn = err;}

			pdest = _tcschr(pdest, _T('\0'));
			pdest++;
		}
		else
		{
			break;
		}
	} while (TRUE);
    }

CheckifServiceExistAndDependencies_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
	return (iReturn);
}



INT CheckifServiceExist( LPCTSTR lpServiceName )
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

	if ((	hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL
		|| (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {err = GetLastError();}

    if (hService) CloseServiceHandle(hService);
    if (hScManager) CloseServiceHandle(hScManager);
	return (err);
}

/*----------------------------------------------------------------------------------------
Routine Description:
    This routine allocates a buffer for the specified service's configuration parameters,
    and retrieves those parameters into the buffer.  The caller is responsible for freeing
    the buffer.
Remarks:
    The pointer whose address is contained in ServiceConfig is guaranteed to be NULL upon
    return if any error occurred.
-----------------------------------------------------------------------------------------*/
DWORD RetrieveServiceConfig(IN SC_HANDLE ServiceHandle,OUT LPQUERY_SERVICE_CONFIG *ServiceConfig)
{
  DWORD ServiceConfigSize = 0, Err;
  if (NULL == ServiceConfig)
  {
    return ERROR_INVALID_PARAMETER;
  }

  *ServiceConfig = NULL;
  while(TRUE)
  {
    if(QueryServiceConfig(ServiceHandle, *ServiceConfig, ServiceConfigSize, &ServiceConfigSize))
    {
      //assert(*ServiceConfig);
      return NO_ERROR;
    }
    else
    {
      Err = GetLastError();
      if(*ServiceConfig)
      {
        free(*ServiceConfig);
        *ServiceConfig=NULL;
      }

      if(Err == ERROR_INSUFFICIENT_BUFFER)
      {
        // Allocate a larger buffer, and try again.
        *ServiceConfig = (LPQUERY_SERVICE_CONFIG) malloc(ServiceConfigSize);

        if( !( *ServiceConfig ) )
        {
          return ERROR_NOT_ENOUGH_MEMORY;
        }
      }
      else
      {
        *ServiceConfig = NULL;
        return Err;
      }
    }
  } // while (TRUE)
}


INT CreateDependencyForService( LPCTSTR lpServiceName, LPCTSTR lpDependency )
{
    iisDebugOut_Start1(_T("CreateDependencyForService"),(LPTSTR) lpServiceName);

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

	LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;
	TCHAR szTempDependencies[1024];
	TCHAR * pszTempDependencies = NULL;
	pszTempDependencies = szTempDependencies;

    do {
        // set up the service first
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

		// Get the existing Service information
		if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR) 
			{
			err = GetLastError();
			break;
			}
		if(!ServiceConfig)
			{
			err = GetLastError();
			break;
			}
		// Check if our service is already in there.
		// ServiceConfig->lpDependencies should look something like this
		// service\0service\0\0  double null terminated
		TCHAR * pdest = NULL;
		int bFoundFlag = FALSE;
		long RightMostNull = 0;

		pdest = ServiceConfig->lpDependencies;
		do 
		{
			if (*pdest != _T('\0'))
			{
				RightMostNull = RightMostNull + _tcslen(pdest) + 1;
				if (_tcsicmp(pdest, lpDependency) == 0) 
					{
					bFoundFlag = TRUE;
					break;
					}

				// copy the entry onto our string which we'll use later.
				_tcscpy(pszTempDependencies,pdest);
				// position pointer to the end
				pszTempDependencies=pszTempDependencies + RightMostNull;

				pdest = _tcschr(pdest, _T('\0'));
				pdest++;
			}
			else
			{
				break;
			}
		} while (TRUE);

		// if the service is already on the dependency list then exit
		if (bFoundFlag == TRUE) 
		{
			break;
		}
				
		// The Service is not there So Let's add it to the end of the list then change the data
		// The pointer should be at the beginning or at the next entry point
		_tcscpy(pszTempDependencies, lpDependency);
		// position pointer to the end
		pszTempDependencies=pszTempDependencies + (_tcslen(pszTempDependencies) + 1);
		// add another null to the end
		*pszTempDependencies = _T('\0');

	
        if(!::ChangeServiceConfig(hService,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,NULL,NULL,NULL,szTempDependencies,NULL,NULL,NULL)) 
			{
			err = GetLastError();
			break;
			}

	} while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("CreateDependencyForService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
	return err;
}


INT RemoveDependencyForService( LPCTSTR lpServiceName, LPCTSTR lpDependency )
{
    iisDebugOut_Start1(_T("RemoveDependencyForService"),(LPTSTR) lpServiceName);

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

	LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;
	TCHAR szTempDependencies[1024];
	TCHAR * pszTempDependencies = NULL;
	pszTempDependencies = szTempDependencies;

    do {
            // set up the service first
            if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
                (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
            {
                err = GetLastError();
                break;
            }

            // Get the existing Service information
            if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR) 
                {
                err = GetLastError();
                break;
                }
            if(!ServiceConfig) 
                {
                err = GetLastError();
                break;
                }

		// Check if our service is already in there.
		// ServiceConfig->lpDependencies should look something like this
		// service\0service\0\0  double null terminated

		TCHAR * pdest = NULL;
		int bFoundFlag = FALSE;
		long RightMostNull = 0;
		_tcsset(szTempDependencies, _T('\0'));
		pdest = ServiceConfig->lpDependencies;
		do 
		{
			if (*pdest != _T('\0'))
			{
				RightMostNull = RightMostNull + _tcslen(pdest) + 1;
				if (_tcsicmp(pdest, lpDependency) == 0) 
					{
					bFoundFlag = TRUE;
					}
				else
				{
				// copy the entry onto our string which we'll use later.
				_tcscpy(pszTempDependencies,pdest);
				// position pointer to the end
				pszTempDependencies=pszTempDependencies + RightMostNull;
				*pszTempDependencies = _T('\0');

				/*
					if (_tcslen(szTempDependencies) == 0)
						memcpy(szTempDependencies, pdest, _tcslen(pdest) + 1);
					else
						memcpy(szTempDependencies + _tcslen(szTempDependencies) + 1, pdest, _tcslen(pdest) + 1);
					*/
				}
				pdest = _tcschr(pdest, _T('\0'));
				pdest++;
			}
			else
			{
				break;
			}
		} while (TRUE);
		// if the service was in the list.
		// Then let's remove it.
		if (bFoundFlag == FALSE) 
		{
			break;
		}

		if(!::ChangeServiceConfig(hService,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,NULL,NULL,NULL,szTempDependencies,NULL,NULL,NULL)) 
			{
			err = GetLastError();
			break;
			}

	} while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    iisDebugOut((LOG_TYPE_TRACE, _T("RemoveDependencyForService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
	return err;
}

INT DisplayDependencyForService( LPCTSTR lpServiceName)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

	LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    do {
        // set up the service first
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

		// Get the existing Service information
		if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
			{
			err = GetLastError();
			break;
			}
		if(!ServiceConfig)
			{
			err = GetLastError();
			break;
			}
		// Check if our service is already in there.
		// ServiceConfig->lpDependencies should look something like this
		// service\0service\0\0  double null terminated
		TCHAR * pdest = NULL;
		int bFoundFlag = FALSE;
		long RightMostNull = 0;
		pdest = ServiceConfig->lpDependencies;
		do
		{
			if (*pdest != _T('\0'))
			{
				pdest = _tcschr(pdest, _T('\0'));
				pdest++;
			}
			else
			{
				break;
			}
		} while (TRUE);


	} while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
	return err;
}


//
//Routine Description:
//    Stop the named service and all those services which depend upon it.
//    And if the service is hung and can't be stopped, then kill the darn thing.
//
//Arguments:
//    ServiceName (Name of service to stop)
//
//Return Status:
//    TRUE - Indicates service successfully stopped
//    FALSE - Timeout occurred.
//
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList)
{
    iisDebugOut_Start1(_T("StopServiceAndDependencies"),(LPTSTR) ServiceName);

    int Err = 0;
    int iBeforeServiceStatus = 0;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD Timeout;
	int iReturn = FALSE;
    DWORD TimeoutMaxSecs = 60;
    DWORD dwSvcMaxSleep = 0;

    //
    // Open a handle to the Service.
    //
    ScManagerHandle = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT );
    if (ScManagerHandle == NULL)
	{
        Err = GetLastError();
		iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():OpenSCManager: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
        goto Cleanup;
    }

    ServiceHandle = OpenService(ScManagerHandle,ServiceName,SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP | SERVICE_QUERY_CONFIG );
    if ( ServiceHandle == NULL )
	{
        Err = GetLastError();
        if (Err == ERROR_SERVICE_DOES_NOT_EXIST)
        {
             iReturn = TRUE;
             iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("StopServiceAndDependencies():%s Service does not exist.\n"), ServiceName));
        }
        else
        {
	     iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():OpenService: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
        }
        goto Cleanup;
    }

    // Get the before service status.
    if (QueryServiceStatus(ServiceHandle, &ServiceStatus))
    {
        iBeforeServiceStatus = ServiceStatus.dwCurrentState;
    }

    //
    // Ask the service to stop.
    //
    if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) )
	{
        Err = GetLastError();
        // If there are dependent services running,
        //  determine their names and stop them.
        if ( Err == ERROR_DEPENDENT_SERVICES_RUNNING )
		{
            BYTE ConfigBuffer[4096];
            LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
            DWORD BytesNeeded;
            DWORD ServiceCount;
            DWORD ServiceIndex;

            //
            // Get the names of the dependent services.
            //
            if ( !EnumDependentServices( ServiceHandle,SERVICE_ACTIVE,ServiceConfig,sizeof(ConfigBuffer),&BytesNeeded,&ServiceCount ) )
			{
                Err = GetLastError();
				iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():EnumDependentServices: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
                goto Cleanup;
            }

            //
            // Stop those services.
            //
            for ( ServiceIndex=0; ServiceIndex<ServiceCount; ServiceIndex++ )
			{
                StopServiceAndDependencies( ServiceConfig[ServiceIndex].lpServiceName, AddToRestartList);
            }

            //
            // Ask the original service to stop.
            //
            if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) )
			{
                Err = GetLastError();

				// check if the service is already stopped..
				if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE)
				{
					// check if the service is alread stopped.
					if (QueryServiceStatus( ServiceHandle, &ServiceStatus ))
					{
						if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
							{
                            iReturn = TRUE;
                            goto Cleanup;
                            }
					}
				}
				else
				{
                    // The service must be in a hung mode.  Let's kill it.
                    iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it.\n"), ServiceName));
                    KillService(ServiceHandle);
                    goto WaitLoop;
				}

                goto Cleanup;
            }
        }
		else
		{
			// check if the service is already stopped..
			if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE)
			{
				// check if the service is alread stopped.
				if (QueryServiceStatus( ServiceHandle, &ServiceStatus ))
				{
					if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
						{
                        Err = ServiceStatus.dwCurrentState;
                        iReturn = TRUE;
                        goto Cleanup;
                        }
				}
			}
			else
			{
					// The service must be in a hung mode.  Let's kill it.
					iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it.\n"), ServiceName));
					KillService(ServiceHandle);
					goto WaitLoop;
			}

            goto Cleanup;
        }
    }
    else
    {
        // We successfully asked the service to stop...
    }


WaitLoop:
    // Calculcate if this is a "special" service which we
    // need to give more time to in order to stop.
    dwSvcMaxSleep = InetStopExtraWait(ServiceName);
    // dwSvcMaxSleep returns 3 minute intervals.  so default dwSvcMaxSleep will be 180000 (3 minutes)
    // we need to convert this into how many seconds
    TimeoutMaxSecs = (dwSvcMaxSleep/1000);

    // Loop waiting for the service to stop.
    for ( Timeout=0; Timeout < TimeoutMaxSecs; Timeout++ )
    {
        // Return or continue waiting depending on the state of the service.
        if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
		{
			// The service successfully stopped.
            iisDebugOut((LOG_TYPE_TRACE, _T("StopServiceAndDependencies(): %s Service stopped.\n"), ServiceName));
			iReturn = TRUE;
            goto Cleanup;
        }

        // Wait a second for the service to finish stopping.
        Sleep( 1000 );

        // Query the status of the service again.
        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus ))
		{
            Err = GetLastError();
			iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():QueryServiceStatus: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
            goto Cleanup;
        }

        // if the service we are trying to stop is a driver,
        // then heck we should just get out of here..
        if (TRUE == IsThisServiceADriver(ServiceName))
        {
            iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies(): %s service is a driver, and can only be removed upon reboot.\n"), ServiceName));
            goto Cleanup;
        }
    }

    // if we get here then the service failed to stop.
    iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies(): failed to stop %s service.\n"), ServiceName));

Cleanup:
    if ( ScManagerHandle != NULL )  {(VOID) CloseServiceHandle(ScManagerHandle);}
	if ( ServiceHandle != NULL ) {(VOID) CloseServiceHandle(ServiceHandle);}

    // if we successfully stopped this service, then
    // add it to the restart service list
    if (iReturn == TRUE)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("StopServiceAndDependencies(): %s service. success.\n"), ServiceName));
        if (iBeforeServiceStatus == SERVICE_RUNNING)
        {
            if (AddToRestartList) {ServicesRestartList_Add(ServiceName);}
        }
    }
    return iReturn;
}


// ----------------------------------------------
// The service must be in a hung mode.  Let's kill it.
// Get the binary path name and use that to kill it.
// Return true on successfull kill.  false otherwise.
// ----------------------------------------------
int KillService(SC_HANDLE ServiceHandle)
{
	int iReturn = FALSE;
	LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;
    int iFlagPutItBack = FALSE;

	// Retrieve the service's config for the BinaryPathName
	// if failed then just return
	if(RetrieveServiceConfig(ServiceHandle, &ServiceConfig) != NO_ERROR)
		{
		goto KillService_Exit;
		}
	if(!ServiceConfig)
		{
		goto KillService_Exit;
		}

	// The Service can be one of these types:
	//		SERVICE_WIN32_OWN_PROCESS: A service type flag that indicates a Win32 service that runs in its own process.
	//		SERVICE_WIN32_SHARE_PROCESS: A service type flag that indicates a Win32 service that shares a process with other services.
	//		SERVICE_KERNEL_DRIVER: A service type flag that indicates a Windows NT device driver.
	//		SERVICE_FILE_SYSTEM_DRIVER: A service type flag that indicates a Windows NT file system driver.
	//		SERVICE_INTERACTIVE_PROCESS: A flag that indicates a Win32 service process that can interact with the desktop.

	// Attempt to kill only if it's a process.
	if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
	{
    if ( _tcslen(ServiceConfig->lpBinaryPathName) >= MAX_PATH )
    {
  		goto KillService_Exit;
    }

		// parse out the different parts and take only the filename.ext
		TCHAR pfilename_only[ MAX_PATH ];
		TCHAR pextention_only[ MAX_PATH ];
		_tsplitpath( ServiceConfig->lpBinaryPathName, NULL, NULL, pfilename_only, pextention_only);
		if (pextention_only) {_tcscat(pfilename_only,pextention_only);}

    if ( _tcsicmp( pfilename_only, _T("lsass") ) == 0 )
    {
      // No matter what service it is, lets not kill lsass.exe
      goto KillService_Exit;
    }

		// Convert it to ansi for our "kill" function
		char szFile[ MAX_PATH ];
		#if defined(UNICODE) || defined(_UNICODE)
			WideCharToMultiByte( CP_ACP, 0, (WCHAR*)pfilename_only, -1, szFile, MAX_PATH, NULL, NULL );
		#else
			_tcscpy(szFile, pfilename_only);
		#endif

        // Some of these services have some action to do if the service is killed.
        // like IISADMIN has some restart function which will automagically restart the
        // Service if the process is not properly shutdown.
        // We need to disable this deal because We can't have this service just startup by itself again.
        iFlagPutItBack = FALSE;
        if (_tcsicmp(ServiceConfig->lpServiceStartName,_T("IISADMIN")) == 0)
        {
            // Go lookup the registry for "FailureCommands" and save that information.
            // retrieve from registry
            CString csFailureCommand;
            CRegKey regIISADMINParam(HKEY_LOCAL_MACHINE, REG_IISADMIN);
            if ( (HKEY)regIISADMINParam )
            {
                regIISADMINParam.m_iDisplayWarnings = FALSE;
                if (ERROR_SUCCESS == regIISADMINParam.QueryValue(_T("FailureCommands"), csFailureCommand))
                {
                    // Kool, we got it.
                    // Set it to do nothing.
                    regIISADMINParam.SetValue(_T("FailureCommands"), _T(""));
                    iFlagPutItBack = TRUE;
                }
            }

            // kill the service's process
            if (KillProcessNameReturn0(szFile) == 0) {iReturn = TRUE;}

            if (TRUE == iFlagPutItBack)
            {
                CRegKey regIISADMINParam(HKEY_LOCAL_MACHINE, REG_IISADMIN);
                if ( (HKEY)regIISADMINParam )
                {
                    regIISADMINParam.SetValue(_T("FailureCommands"), csFailureCommand);
                }
            }

        }
        else
        {
		    if (KillProcessNameReturn0(szFile) == 0) {iReturn = TRUE;}
        }
	}

KillService_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
	return iReturn;
}



INT CheckifServiceMarkedForDeletion( LPCTSTR lpServiceName )
{
    INT iReturn = FALSE;
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    // set up the service first
    if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
        (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
    {
        err = GetLastError();
        goto CheckifServiceMarkedForDeletion_Exit;
    }

    SERVICE_STATUS svcStatus;
    if ( !QueryServiceStatus( hService, &svcStatus ))
    {
        err = ::GetLastError();
        goto CheckifServiceMarkedForDeletion_Exit;
    }

    if ( svcStatus.dwCurrentState == SERVICE_RUNNING )
    {
        // We will only get this ERROR_SERVICE_MARKED_FOR_DELETE
        // message if the service is already running.
        if ( !::StartService( hService, 0, NULL ))
        {
            err = ::GetLastError();
            if (err == ERROR_SERVICE_MARKED_FOR_DELETE) {iReturn = TRUE;}
            goto CheckifServiceMarkedForDeletion_Exit;
        }
    }

CheckifServiceMarkedForDeletion_Exit:
    if (hService) CloseServiceHandle(hService);
    if (hScManager) CloseServiceHandle(hScManager);
    return iReturn;
}


//
// warning: This will leave the lpServiceToValidate in the started mode upon exit!
//
int ValidateDependentService(LPCTSTR lpServiceToValidate, LPCTSTR lpServiceWhichIsDependent)
{
    iisDebugOut_Start1(_T("ValidateDependentService"),(LPTSTR) lpServiceToValidate);

    int iReturn = FALSE;
    INT err = 0;
    int iFailFlag = FALSE;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    // Let's validate that the lpServiceToValidate is installed fine.

    // Check if the lpServiceToValidate service EVEN exists
    err = CheckifServiceExistAndDependencies(lpServiceToValidate);
    if ( err != 0 )
    {
        MyMessageBox(NULL, IDS_DEPENDENT_UPON_THIS_SVC_ERR, lpServiceWhichIsDependent,lpServiceWhichIsDependent,err, MB_OK | MB_SETFOREGROUND);
    }
    else
    {
        // Try to start the service
        err = InetStartService(lpServiceToValidate);
        if (err == 0 || err == ERROR_SERVICE_ALREADY_RUNNING)
        {
            err = NERR_Success;
            iReturn = TRUE;
            goto ValidateDependentService_Exit;
        }

        // Service returned an error when we tried to start it.
        // Check if the error = ERROR_SERVICE_DEPENDENCY_FAIL
        if (err == ERROR_SERVICE_DEPENDENCY_FAIL)
        {
            // Loop thru this services dependencies and try to
            // start them, to find out which one failed to start.
            iFailFlag = FALSE;
            if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = ::OpenService( hScManager, lpServiceToValidate, GENERIC_ALL )) == NULL )  {iFailFlag = TRUE;}
            // Get the existing Service information
            if (iFailFlag != TRUE) {if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR) {iFailFlag = TRUE;}}
            if (iFailFlag != TRUE) {if(!ServiceConfig){iFailFlag = TRUE;}}
            // Get the dependencies
            if (iFailFlag != TRUE)
            {
	            TCHAR * pdest = NULL;
	            long RightMostNull = 0;
	            pdest = ServiceConfig->lpDependencies;
	            do
	            {
		            if (*pdest != _T('\0'))
		            {
                        RightMostNull = RightMostNull + _tcslen(pdest) + 1;

                        // Try to start the service...
                        err = InetStartService(pdest);
                        if (err)
                        {
                        if (err != ERROR_SERVICE_ALREADY_RUNNING)
                        {
                            // The pdest
                            // Service was unable to start because...
                            // MyMessageBox(NULL, IDS_UNABLE_TO_START, pdest, err, MB_OK | MB_SETFOREGROUND);
                            iisDebugOut((LOG_TYPE_ERROR, _T("ValidateDependentService():Unable to start ServiceName=%s.\n"), pdest));
                        }
                        }
			            pdest = _tcschr(pdest, _T('\0'));
			            pdest++;
		            }
		            else
		            {
			            break;
		            }
                } while (TRUE);
            }
        }
        else
        {
            MyMessageBox(NULL, IDS_UNABLE_TO_START, lpServiceToValidate, err, MB_OK | MB_SETFOREGROUND);
        }

    }

ValidateDependentService_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    iisDebugOut_End1(_T("ValidateDependentService"), lpServiceToValidate, LOG_TYPE_TRACE);
    return iReturn;
}



int LogEnumServicesStatus(void)
{
    int iReturn = FALSE;
#ifndef _CHICAGO_
    BOOL success = 0;
	SC_HANDLE scm = NULL;
	LPENUM_SERVICE_STATUS status = NULL;
	DWORD numServices=0, sizeNeeded=0, resume=0;

	// Open a connection to the SCM
    //scm = OpenSCManager(0, 0, GENERIC_ALL);
	scm = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (!scm)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CallEnumServicesStatus():OpenSCManager.  FAILED.  err=0x%x\n"), GetLastError()));
        goto CallEnumServicesStatus_Exit;
    }

	// get the number of bytes to allocate
	// MAKE SURE resume starts at 0
	resume = 0;
	success = EnumServicesStatus(scm, SERVICE_WIN32 | SERVICE_DRIVER, SERVICE_ACTIVE | SERVICE_INACTIVE, 0, 0, &sizeNeeded, &numServices, &resume);
	if (GetLastError() != ERROR_MORE_DATA)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CallEnumServicesStatus():EnumServicesStatus0.  FAILED.  err=0x%x\n"), GetLastError()));
        goto CallEnumServicesStatus_Exit;
    }

	// Allocate space
	status = (LPENUM_SERVICE_STATUS) LocalAlloc(LPTR, sizeNeeded);
    if( status == NULL )
    {
        goto CallEnumServicesStatus_Exit;
    }

	// Get the status records. Making an assumption
	// here that no new services get added during
	// the allocation (could lock the database to
	// guarantee that...)
	resume = 0;
	success = EnumServicesStatus(scm, SERVICE_WIN32,SERVICE_ACTIVE | SERVICE_INACTIVE,status, sizeNeeded, &sizeNeeded,&numServices, &resume);
	if (!success)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CallEnumServicesStatus():EnumServicesStatus.  FAILED.  err=0x%x\n"), GetLastError()));
        goto CallEnumServicesStatus_Exit;
    }

	DWORD i;
	for (i=0; i < numServices; i++)
    {
        switch(status[i].ServiceStatus.dwCurrentState)
        {
            case SERVICE_STOPPED:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_STOPPED [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_START_PENDING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_START_PENDING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_STOP_PENDING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_STOP_PENDING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_RUNNING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_RUNNING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_CONTINUE_PENDING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_CONTINUE_PENDING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_PAUSE_PENDING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_PAUSE_PENDING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_PAUSED:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_PAUSED [%s].\n"), status[i].lpServiceName));
                break;
        }
    }
    iReturn = TRUE;

CallEnumServicesStatus_Exit:
    if (status){LocalFree(status);}
    if (scm) {CloseServiceHandle(scm);}
#endif
    return iReturn;
}


int InetIsThisExeAService(LPCTSTR lpFileNameToCheck, LPTSTR lpReturnServiceName)
{
    int iReturn = FALSE;
#ifndef _CHICAGO_
    BOOL success = 0;
	SC_HANDLE scm = NULL;
	LPENUM_SERVICE_STATUS status = NULL;
	DWORD numServices=0, sizeNeeded=0, resume=0;

    _tcscpy(lpReturnServiceName, _T(""));

	// Open a connection to the SCM
    //scm = OpenSCManager(0, 0, GENERIC_ALL);
	scm = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (!scm)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("InetIsThisExeAService():OpenSCManager.  FAILED.  err=0x%x\n"), GetLastError()));
        goto InetIsThisExeAService_Exit;
    }

	// get the number of bytes to allocate
	// MAKE SURE resume starts at 0
	resume = 0;
	success = EnumServicesStatus(scm, SERVICE_WIN32 | SERVICE_DRIVER, SERVICE_ACTIVE | SERVICE_INACTIVE, 0, 0, &sizeNeeded, &numServices, &resume);
	if (GetLastError() != ERROR_MORE_DATA)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("InetIsThisExeAService():EnumServicesStatus0.  FAILED.  err=0x%x\n"), GetLastError()));
        goto InetIsThisExeAService_Exit;
    }

	// Allocate space
	status = (LPENUM_SERVICE_STATUS) LocalAlloc(LPTR, sizeNeeded);
    if( status == NULL )
    {
        goto InetIsThisExeAService_Exit;
    }

	// Get the status records. Making an assumption
	// here that no new services get added during
	// the allocation (could lock the database to
	// guarantee that...)
	resume = 0;
	success = EnumServicesStatus(scm, SERVICE_WIN32,SERVICE_ACTIVE | SERVICE_INACTIVE,status, sizeNeeded, &sizeNeeded,&numServices, &resume);
	if (!success)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("InetIsThisExeAService():EnumServicesStatus.  FAILED.  err=0x%x\n"), GetLastError()));
        goto InetIsThisExeAService_Exit;
    }

	DWORD i;
	for (i=0; i < numServices; i++)
    {
        // Use the status[i].lpServiceName
        // to query the service and find out it's binary filename
        if (TRUE == InetIsThisExeAService_Worker(status[i].lpServiceName, lpFileNameToCheck))
        {
            iReturn = TRUE;
            // copy in the service name into the return string.
            _tcscpy(lpReturnServiceName, status[i].lpServiceName);
            goto InetIsThisExeAService_Exit;
        }
    }

InetIsThisExeAService_Exit:
    if (status){LocalFree(status);}
    if (scm) {CloseServiceHandle(scm);}
#endif
    return iReturn;
}


int InetIsThisExeAService_Worker(LPCTSTR lpServiceName, LPCTSTR lpFileNameToCheck)
{
    int iReturn = FALSE;

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    BYTE ConfigBuffer[4096];
    LPENUM_SERVICE_STATUS ServiceConfigEnum = (LPENUM_SERVICE_STATUS) &ConfigBuffer;

    if ((	hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
        // Failed, or more likely the service doesn't exist
        //iReturn = GetLastError();
        goto InetIsThisExeAService_Worker_Exit;
        }

	if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
		{
                //iReturn = GetLastError();
		goto InetIsThisExeAService_Worker_Exit;
		}

	if(!ServiceConfig)
		{
		goto InetIsThisExeAService_Worker_Exit;
		}

    if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
    {
        if (ServiceConfig->lpBinaryPathName)
        {
            if (_tcsicmp(lpFileNameToCheck, ServiceConfig->lpBinaryPathName) == 0)
            {
                //We found a match!!!!!
                iReturn = TRUE;
            }
            else
            {
                // we did not find a match, based on c:\path\filename and c:\path\filename
                // maybe we try "filename.exe" and "filename.exe"????
                TCHAR szBinaryNameOnly[_MAX_FNAME];
                TCHAR szFileNameToCheckNameOnly[_MAX_FNAME];
                if (TRUE == ReturnFileNameOnly((LPCTSTR) ServiceConfig->lpBinaryPathName, szBinaryNameOnly))
                {
                    if (TRUE == ReturnFileNameOnly((LPCTSTR) lpFileNameToCheck, szFileNameToCheckNameOnly))
                    {
                        if (_tcsicmp(szFileNameToCheckNameOnly, szBinaryNameOnly) == 0)
                        {
                            //We found a match!!!!!
                            iReturn = TRUE;
                        }
                    }
                }

            }
        }
    }

InetIsThisExeAService_Worker_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    return iReturn;
}


int IsThisServiceADriver(LPCTSTR lpServiceName)
{
    int iReturn = FALSE;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    BYTE ConfigBuffer[4096];
    LPENUM_SERVICE_STATUS ServiceConfigEnum = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
    if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
    {
        // Failed, or more likely the service doesn't exist
        //iReturn = GetLastError();
        goto IsThisServiceADriver_Exit;
    }

    if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
    {
        //iReturn = GetLastError();
        goto IsThisServiceADriver_Exit;
    }

    if(!ServiceConfig)
    {
        //iReturn = GetLastError();
        goto IsThisServiceADriver_Exit;
    }

    if ( (ServiceConfig->dwServiceType & SERVICE_KERNEL_DRIVER) || (ServiceConfig->dwServiceType & SERVICE_FILE_SYSTEM_DRIVER))
    {
        iReturn = TRUE;
    }

IsThisServiceADriver_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    return iReturn;
}


int CreateDriver(CString csDriverName, CString csDisplayName, CString csFileName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    CString csBinPath;
    CString csFile;
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CreateDriver:%s:%s start.\n"), csDriverName, csFileName));

    csBinPath = _T("\\SystemRoot\\System32\\drivers\\");
    csBinPath += csFileName;

    // Check if the file even exists first.
    csFile = g_pTheApp->m_csSysDir;
    csFile += _T("\\Drivers\\");
    csFile += csFileName;
    if (!IsFileExist(csFile))
    {
        dwReturn = ERROR_FILE_NOT_FOUND;
        goto CreateDriver_Exit;
    }

    //
    // Attempt to create the service, could fail if this is an
    // Refresh Install will leave the driver from the prior
    // Install, becuse if we delete in the remove phase it will
    // get marked for deletion and not get readded now.
    // this could happen in a upgrade as well....
    //
    dwReturn = InetCreateDriver(csDriverName, (LPCTSTR)csDisplayName, (LPCTSTR)csBinPath, SERVICE_DEMAND_START);
    if ( dwReturn != ERROR_SUCCESS )
    {
        if (dwReturn == ERROR_SERVICE_EXISTS)
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("CreateDriver:%s:Service exists.\n"), csDriverName));
            dwReturn = ERROR_SUCCESS;
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CreateDriver:%s:failed to create service Err=0x%x.\n"), csDriverName, dwReturn));
            MyMessageBox(NULL, IDS_UNABLE_TO_CREATE_DRIVER, csDriverName, dwReturn, MB_OK | MB_SETFOREGROUND);
        }
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateDriver:%s:Successfully created.\n"), csDriverName));
    }

CreateDriver_Exit:
    return dwReturn;
}


DWORD CreateDriver_Wrap(CString csDriverName, CString csDisplayName, CString csFileName,BOOL bDisplayMsgOnErrFlag)
{
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;

    // Create or Config driver spud.sys, NT Server product onloy!!!
    if (g_pTheApp->m_eOS != OS_W95)
    {
	    do
	    {
		    dwReturn = CreateDriver(csDriverName, csDisplayName, csFileName);
		    if (dwReturn == ERROR_SUCCESS)
		    {
			    break;
		    }
		    else
		    {
			    if (bDisplayMsgOnErrFlag == TRUE)
			    {
                    iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				    switch ( iMsg )
				    {
				    case IDIGNORE:
					    dwReturn = ERROR_SUCCESS;
					    goto CreateDriver_Wrap_Exit;
				    case IDABORT:
					    dwReturn = ERROR_OPERATION_ABORTED;
					    goto CreateDriver_Wrap_Exit;
				    case IDRETRY:
					    break;
				    default:
					    break;
				    }
			    }
			    else
			    {
				    // return whatever err happened
				    goto CreateDriver_Wrap_Exit;
			    }

		    }
	    } while (dwReturn != ERROR_SUCCESS);
    }

CreateDriver_Wrap_Exit:
	return dwReturn;
}


INT InetConfigServiceInteractive(LPCTSTR lpServiceName, int AddInteractive)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetConfigServiceInteractive(%i):ServiceName=%s\n"),AddInteractive,(LPTSTR) lpServiceName));

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig = NULL;
    DWORD dwNewServiceType = 0;
    BOOL bDoStuff =  FALSE;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            // if error = ERROR_SERVICE_DOES_NOT_EXIST
            if (ERROR_SERVICE_DOES_NOT_EXIST != err)
            {
                 iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigServiceInteractive():OpenSCManager or OpenService: Service=%s Err=0x%x FAILED\n"), lpServiceName,err));
            }
            break;
        }

            if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
	        {
                err = GetLastError();
                break;
		}

            if(!ServiceConfig)
	        {
                err = GetLastError();
                break;
		}

	    // Interactive flag can only work on own_process or share_process types
	    if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
	    {
            // default it incase someone changes code below and logic gets messed up
            dwNewServiceType = ServiceConfig->dwServiceType;

            // if the interactive flag is already there
            // then don't do jack, otherwise, add it on
            if (ServiceConfig->dwServiceType & SERVICE_INTERACTIVE_PROCESS)
            {
                // only do stuff if we're asked to remove it!
                if (FALSE == AddInteractive)
                {
                    // Remove it from the mask!
                    dwNewServiceType = ServiceConfig->dwServiceType & (~SERVICE_INTERACTIVE_PROCESS);
                    bDoStuff = TRUE;
                }
            }
            else
            {
                if (TRUE == AddInteractive)
                {
                    dwNewServiceType = ServiceConfig->dwServiceType | SERVICE_INTERACTIVE_PROCESS;
                    bDoStuff = TRUE;
                }
            }

            if (TRUE == bDoStuff)
            {
                if ( !::ChangeServiceConfig(hService, dwNewServiceType, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL) )
                {
                    err = GetLastError();
			        iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigServiceInteractive():ChangeServiceConfig: Service=%s Err=0x%x FAILED\n"), lpServiceName, err));
                    break;
                }
            }
            else
            {
                break;
            }

        }
        else
        {
            break;
        }

    } while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetConfigServiceInteractive():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}


// This function trys to create the www service
int MyCreateService(CString csServiceName, CString csDisplayName, CString csBinPath, CString csDependencies, CString csDescription)
{
    int iReturn = !ERROR_SUCCESS;
    int err = NERR_Success;
    TSTR strDependencies2( MAX_PATH );

    iisDebugOut((LOG_TYPE_TRACE, _T("MyCreateService:%s,%s,%s,%s.\n"),csServiceName, csDisplayName, csBinPath, csDependencies));

    if ( !strDependencies2.Copy( csDependencies.GetBuffer(0) ) ||
         !strDependencies2.Append( _T(":") )
       )
    {
      return iReturn;
    }
        
    // make sure it ends with a ":"
    // and then replace all the ":", with a "\0" null....
    TCHAR *p = (LPTSTR) strDependencies2.QueryStr();
    while (*p) 
    {
        // change ":" to a null "\0"
        if (*p == _T(':')){*p = _T('\0');}
        p = _tcsinc(p);
    }

    err = InetCreateService(csServiceName, 
                            (LPCTSTR)csDisplayName, 
                            (LPCTSTR)csBinPath, 
                            SERVICE_AUTO_START, 
                            strDependencies2.QueryStr());

    if ( err != NERR_Success )
    {
        // check if the error is because the service already exists...
        if (err == ERROR_SERVICE_EXISTS)
        {
            // Since the service should exist by the time we get here,
            // let's make sure it has the dependency we want it to have.
            err = InetConfigService(csServiceName, (LPCTSTR)csDisplayName, (LPCTSTR)csBinPath, strDependencies2.QueryStr());
            if (err != NERR_Success)
            {
                SetLastError(err);
                goto MyCreateService_Exit;
            }
        }
        else
        {
            SetLastError(err);
            goto MyCreateService_Exit;
        }

    }

    // Use newer api to add the description field.
    err = InetConfigService2(csServiceName, (LPCTSTR)csDescription);
    if (err != NERR_Success)
    {
        SetLastError(err);
        goto MyCreateService_Exit;
    }

    // there was no error in the InetCreateService call.
    // so everything is hunky dory
    iReturn = ERROR_SUCCESS;

MyCreateService_Exit:
    return iReturn;
}


DWORD CreateService_wrap(CString csServiceName, CString csDisplayName, CString csBinPath, CString csDependencies, CString csDescription, BOOL bDisplayMsgOnErrFlag)
{
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;

	do
	{
		dwReturn = MyCreateService(csServiceName, csDisplayName, csBinPath, csDependencies, csDescription);
		if (dwReturn == ERROR_SUCCESS)
		{
			break;
		}
		else
		{
			if (bDisplayMsgOnErrFlag == TRUE)
			{
                iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				case IDIGNORE:
					dwReturn = ERROR_SUCCESS;
					goto CreateService_wrap_Exit;
				case IDABORT:
					dwReturn = ERROR_OPERATION_ABORTED;
					goto CreateService_wrap_Exit;
				case IDRETRY:
					break;
				default:
					break;
				}
			}
			else
			{
				// return whatever err happened
				goto CreateService_wrap_Exit;
			}

		}
	} while (dwReturn != ERROR_SUCCESS);

CreateService_wrap_Exit:
	return dwReturn;
}

// function: ChangeServiceDepenedency
//
// Change the dependency of a particular service, to either add or remove another service name
// from it
//
// ex. ChangeServiceDependency( W3SSL, TRUE, IISADMIN ) - Would make W3SSL dependant on IISADMIN
//
// Parameters:
//   szServiceName - The service to modify
//   bAddDependency - Add or remove dependency
//   szDependantService - The service that you wand to add as the depenedency
//
BOOL
ChangeServiceDependency(LPTSTR szServiceName, BOOL bAddDependency, LPTSTR szDependantService)
{
  SC_HANDLE hService;
  SC_HANDLE hSCManager;
  BOOL      bRet = FALSE;
  BOOL      bChange = FALSE;
  BUFFER    buffConfig;
  DWORD     dwSizeRequired;
  TSTR_MSZ  mszDependencies;

  hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT | GENERIC_READ );

  if ( hSCManager == NULL )
  {
    return FALSE;
  }

  hService = OpenService( hSCManager, szServiceName, SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG );

  if ( hService == NULL )
  {
    CloseServiceHandle( hSCManager );
    return FALSE;
  }

  if ( !QueryServiceConfig( hService, NULL, 0, &dwSizeRequired ) &&
       ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) &&
       buffConfig.Resize( dwSizeRequired ) &&
       QueryServiceConfig( hService, (LPQUERY_SERVICE_CONFIG) buffConfig.QueryPtr(), buffConfig.QuerySize(), &dwSizeRequired )
    )
  {
    // We have successfully retrieved the service info, so lets modify it
    if ( mszDependencies.Copy( ((LPQUERY_SERVICE_CONFIG) buffConfig.QueryPtr())->lpDependencies ) )
    {
      if ( bAddDependency )
      {
        if ( !mszDependencies.IsPresent(szDependantService, FALSE) )
        {
          bRet = mszDependencies.Add( szDependantService );
          bChange = TRUE;
        }
        else
        {
          // It is already present, so we don't need to add again
          bRet = TRUE;
        }
      }
      else
      {
        if ( mszDependencies.IsPresent(szDependantService, FALSE) )
        {
          bRet = mszDependencies.Remove( szDependantService, FALSE );
          bChange = TRUE;
        }
        else
        {
          // Since it is not there, lets not worry about it
          bRet = TRUE;
        }
      }

      if ( bRet && bChange )
      {
        bRet = ChangeServiceConfig( hService,                     // Service Handle
                                    SERVICE_NO_CHANGE,            // Service Type
                                    SERVICE_NO_CHANGE,            // Startup Type
                                    SERVICE_NO_CHANGE,            // Error Control
                                    NULL,                         // Binary Path
                                    NULL,                         // Load Order Group
                                    NULL,                         // TagID
                                    mszDependencies.QueryMultiSz(), // Dependencies
                                    NULL,                         // Service Start Name
                                    NULL,                         // Password
                                    NULL );                       // Display Name
      }
    }
  }

  CloseServiceHandle( hSCManager );
  CloseServiceHandle( hService );

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\svc.h ===
#include "stdafx.h"

int   InetIsThisExeAService(LPCTSTR lpFileNameToCheck, LPTSTR lpReturnServiceName);
int   InetIsThisExeAService_Worker(LPCTSTR lpServiceName, LPCTSTR lpFileNameToCheck);
INT   InetDisableService( LPCTSTR lpServiceName );
INT   InetStartService( LPCTSTR lpServiceName );
DWORD InetQueryServiceStatus( LPCTSTR lpServiceName );
INT   InetStopService( LPCTSTR lpServiceName );
INT   InetDeleteService( LPCTSTR lpServiceName );
INT   InetCreateService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType, LPCTSTR lpDependencies);
INT   InetCreateDriver(LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType);
INT   InetConfigService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, LPCTSTR lpDependencies);
BOOL  InetRegisterService(LPCTSTR pszMachine, LPCTSTR pszServiceName, GUID *pGuid, DWORD SapId, DWORD TcpPort, BOOL fAdd = TRUE);
DWORD RetrieveServiceConfig(IN SC_HANDLE ServiceHandle,OUT LPQUERY_SERVICE_CONFIG *ServiceConfig);
INT   CheckifServiceExist( LPCTSTR lpServiceName );
INT   CheckifServiceExistAndDependencies( LPCTSTR lpServiceName );
INT   CheckifServiceMarkedForDeletion( LPCTSTR lpServiceName );
int   ValidateDependentService(LPCTSTR lpServiceToValidate, LPCTSTR lpServiceWhichIsDependent);
int   StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList);
int   KillService(SC_HANDLE ServiceHandle);
INT   InetConfigServiceInteractive(LPCTSTR lpServiceName, int AddInteractive);
DWORD CreateDriver_Wrap(CString csDriverName, CString csDisplayName, CString csFileName,BOOL bDisplayMsgOnErrFlag);
DWORD CreateService_wrap(CString csServiceName, CString csDisplayName, CString csBinPath, CString csDependencies, CString csDescription, BOOL bDisplayMsgOnErrFlag);
int   ServicesRestartList_Add(LPCTSTR szServiceName);
int   ServicesRestartList_EntryExists(LPCTSTR szServiceName);
int   ServicesRestartList_RestartServices(void);
int   IsThisServiceADriver(LPCTSTR lpServiceName);

void SetServiceStart(LPTSTR szServiceName, DWORD dwServiceStart);
BOOL IsServiceDisabled(LPTSTR szServiceName);
BOOL ChangeServiceDependency(LPTSTR szServiceName, BOOL bAddDependency, LPTSTR szDependantService);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\sysprep.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "mdacl.h"
#include "inetinfo.h"
#include "log.h"
#include "svc.h"
#include "dcomperm.h"
#include "setpass.h"
#include "comncomp.hxx"
#include <comadmin.h>   // CLSID_COMAdminCatalog
#include <Sddl.h>
#include <acl.hxx>
#include "webcomp.hxx"

typedef TCHAR USERNAME_STRING_TYPE[MAX_PATH];
typedef TCHAR PASSWORD_STRING_TYPE[LM20_PWLEN+1];
typedef enum {
    GUFM_SUCCESS,
    GUFM_NO_PATH,
    GUFM_NO_PASSWORD,
    GUFM_NO_USER_ID
} GUFM_RETURN;
#define OPEN_TIMEOUT_VALUE 30000
#define MD_SET_DATA_RECORD_EXT(PMDR, ID, ATTR, UTYPE, DTYPE, DLEN, PD) \
            { \
            (PMDR)->dwMDIdentifier=ID; \
            (PMDR)->dwMDAttributes=ATTR; \
            (PMDR)->dwMDUserType=UTYPE; \
            (PMDR)->dwMDDataType=DTYPE; \
            (PMDR)->dwMDDataLen=DLEN; \
            (PMDR)->pbMDData=(PBYTE)PD; \
            }

#define SYSPREP_TEMPFILE_NAME _T("IISSysPr.tmp")
#define SYSPREP_KNOWN_SECTION_NAME _T("paths")
#define SYSPREP_KNOWN_REGISTRY_KEY _T("SysPrepIISInfo")
#define SYSPREP_KNOWN_REGISTRY_KEY2 _T("SysPrepIISInfoStage")
#define SYSPREP_TEMP_PASSWORD_LENGTH 256
#define SYSPREP_USE_SECRETS

#define REG_ENABLEPASSSYNC_KEY          _T("SOFTWARE\\Microsoft\\InetStp")
#define REG_ENABLEPASSSYNC_VALUE        _T("EnableUserAccountRestorePassSync")

DWORD   AddUserToMetabaseACL2( CSecurityDescriptor *pSD, LPTSTR szUserToAdd, LPTSTR szSidString, ACCESS_ALLOWED_ACE * MyACEInfo);
HRESULT RemoveMetabaseACL( LPCTSTR szPath );

#ifndef _CHICAGO_
HRESULT 
UpdateComApplications( 
    IMSAdminBase2 * pcCom,
    LPCTSTR     szWamUserName, 
    LPCTSTR     szWamUserPass 
    )
/*++
Routine Description:

    If the IWAM account has been modified, it is necessary to update the
    the out of process com+ applications with the correct account
    information. This routine will collect all the com+ applications and
    reset the activation information.

Arguments:

    pcCom               - metabase object
    szWamUserName       - the new user name
    szWamUserPass       - the new user password

Note:

    This routine is a royal pain in the butt. I take back
    all the good things I may have said about com automation.

Return Value:
    
    HRESULT             - Return value from failed API call
                        - E_OUTOFMEMORY
                        - S_OK - everything worked
                        - S_FALSE - encountered a non-fatal error, unable
                          to reset at least one application.
--*/                       
{
    HRESULT     hr = NOERROR;
    BOOL        fNoErrors = TRUE;

    METADATA_HANDLE     hMetabase = NULL;
    WCHAR *             pwszDataPaths = NULL;
    DWORD               cchDataPaths = 0;
    BOOL                fTryAgain;
    DWORD               cMaxApplications;
    WCHAR *             pwszCurrentPath;

    SAFEARRAY *     psaApplications = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    DWORD           cApplications;
    VARIANT         varAppKey;
    LONG            rgIndices[1];

    METADATA_RECORD     mdrAppIsolated;
    METADATA_RECORD     mdrAppPackageId;
    DWORD               dwAppIsolated;
    WCHAR               wszAppPackageId[ 40 ];
    DWORD               dwMDGetDataLen = 0;

    ICOMAdminCatalog *      pComCatalog = NULL;
    ICatalogCollection *    pComAppCollection = NULL;
    ICatalogObject *        pComApp = NULL;
    BSTR                    bstrAppCollectionName = NULL;
    LONG                    nAppsInCollection;
    LONG                    iCurrentApp;
    LONG                    nChanges;

    VARIANT     varOldAppIdentity;
    VARIANT     varNewAppIdentity;
    VARIANT     varNewAppPassword;

    // This is built unicode right now. Since all the com apis I need
    // are unicode only I'm using wide characters here. I should get
    // plenty of compiler errors if _UNICODE isn't defined, but just
    // in case....
    DBG_ASSERT( sizeof(TCHAR) == sizeof(WCHAR) );

    iisDebugOut((LOG_TYPE_TRACE, _T("UpdateComApplications():start\n")));

    // Init variants
    VariantInit( &varAppKey );
    VariantInit( &varOldAppIdentity );
    VariantInit( &varNewAppIdentity );
    VariantInit( &varNewAppPassword );

    //
    // Get the applications to be reset by querying the metabase paths
    //
    hr = pcCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                     L"LM/W3SVC",
                                     METADATA_PERMISSION_READ,
                                     OPEN_TIMEOUT_VALUE,
                                     &hMetabase
                                     );
    if( FAILED(hr) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to open metabase (%08x)\n"),hr));
        goto cleanup;
    }

    // Get the data paths string

    fTryAgain = TRUE;
    do
    {
        hr = pcCom->GetDataPaths( hMetabase,
                                           NULL,
                                           MD_APP_PACKAGE_ID,
                                           STRING_METADATA,
                                           cchDataPaths,
                                           pwszDataPaths,
                                           &cchDataPaths 
                                           );

        if( HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr )
        {
            delete[] pwszDataPaths;
            pwszDataPaths = NULL;

            pwszDataPaths = new WCHAR[cchDataPaths];
            if( !pwszDataPaths )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
        }
        else
        {
            fTryAgain = FALSE;
        }
    }
    while( fTryAgain );

    if( FAILED(hr) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to find metadata (%08x) Data(%d)\n"),hr,MD_APP_PACKAGE_ID));
        goto cleanup;
    }
    else if (pwszDataPaths == NULL)
    {
        //
        // If we found no isolated apps, make the path list an empty multisz
        //
        cchDataPaths = 1;
        pwszDataPaths = new WCHAR[cchDataPaths];
        if( !pwszDataPaths )
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        pwszDataPaths[0] = L'\0';
    }

    // Determine the maximum number of applications

    cMaxApplications = 1; // The pooled application

    for( pwszCurrentPath = pwszDataPaths; 
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        cMaxApplications++;
    }

    //
    // Build a key array and load the com applications.
    //

    // Create an array to hold the keys

    rgsaBound[0].cElements = cMaxApplications;
    rgsaBound[0].lLbound = 0;

    psaApplications = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if( psaApplications == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Set the out of process pool application key
    varAppKey.vt = VT_BSTR;
    varAppKey.bstrVal = SysAllocString( W3_OOP_POOL_PACKAGE_ID );
    if( !varAppKey.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    rgIndices[0] = 0;
    hr = SafeArrayPutElement( psaApplications, rgIndices, &varAppKey );
    if( FAILED(hr) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed setting an element in a safe array (%08x)\n"),hr));
        goto cleanup;
    }

    // For each of the application paths determine if an out of process
    // application is defined there and set the appropriate key into
    // our array    

    MD_SET_DATA_RECORD_EXT( &mdrAppIsolated,
                            MD_APP_ISOLATED,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            DWORD_METADATA,
                            sizeof(DWORD),
                            (PBYTE)&dwAppIsolated
                            );

    MD_SET_DATA_RECORD_EXT( &mdrAppPackageId,
                            MD_APP_PACKAGE_ID,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            STRING_METADATA,
                            sizeof(wszAppPackageId),
                            (PBYTE)wszAppPackageId
                            );

    wszAppPackageId[0] = L'\0';

    // Go through each data path and set it into our array if
    // it is an isolated application

    cApplications = 1;  // Actual # of applications - 1 for pool

    for( pwszCurrentPath = pwszDataPaths; 
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        hr = pcCom->GetData( hMetabase,
                             pwszCurrentPath,
                             &mdrAppIsolated,
                             &dwMDGetDataLen
                             );
        if( FAILED(hr) )
        {
            iisDebugOut(( LOG_TYPE_ERROR, 
                       _T("Failed to get data from the metabase (%08x) Path(%S) Data(%d)\n"),
                       hr,
                       pwszCurrentPath,
                       mdrAppIsolated.dwMDIdentifier
                       ));

            fNoErrors = FALSE;
            continue;
        }

        // Is the application out of process
        if( dwAppIsolated == 1 )
        {
            // Get the application id

            hr = pcCom->GetData( hMetabase,
                                 pwszCurrentPath,
                                 &mdrAppPackageId,
                                 &dwMDGetDataLen
                                 );
            if( FAILED(hr) )
            {
                iisDebugOut(( LOG_TYPE_ERROR,
                           _T("Failed to get data from the metabase (%08x) Path(%S) Data(%d)\n"),
                           hr,
                           pwszCurrentPath,
                           mdrAppPackageId.dwMDIdentifier
                           ));

                fNoErrors = FALSE;
                continue;
            }

            // Add the application id to the array

            VariantClear( &varAppKey );
            varAppKey.vt = VT_BSTR;
            varAppKey.bstrVal = SysAllocString( wszAppPackageId );
            if( !varAppKey.bstrVal )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            rgIndices[0]++;
            hr = SafeArrayPutElement( psaApplications, 
                                      rgIndices, 
                                      &varAppKey 
                                      );
            if( FAILED(hr) )
            {
                iisDebugOut(( LOG_TYPE_ERROR,
                           _T("Failed to set safe array element (%08x)\n"),
                           hr
                           ));
                VariantClear( &varAppKey );
                rgIndices[0]--;
                fNoErrors = FALSE;
                continue;
            }
            cApplications++;
        }
    }

    // Done with the metabase
    pcCom->CloseKey(hMetabase);
    hMetabase = NULL;

    // Shrink the size of the safe-array if necessary
    if( cApplications < cMaxApplications )
    {
        rgsaBound[0].cElements = cApplications;

        hr = SafeArrayRedim( psaApplications, rgsaBound );
        if( FAILED(hr) )
        {
            iisDebugOut(( LOG_TYPE_ERROR,
                       _T("Failed to redim safe array (%08x)\n"),
                       hr
                       ));
            goto cleanup;
        }
    }

    //
    // For each application reset the activation identity
    //

    // Use our key array to get the application collection

    hr = CoCreateInstance( CLSID_COMAdminCatalog,
                           NULL,
                           CLSCTX_SERVER,
                           IID_ICOMAdminCatalog,
                           (void**)&pComCatalog
                           );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to create COM catalog (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }

    hr = pComCatalog->GetCollection( L"Applications", 
                                     (IDispatch **)&pComAppCollection
                                     );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to get Applications collection (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }

    hr = pComAppCollection->PopulateByKey( psaApplications );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to populate Applications collection (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }

    // Iterate over the application collection and update all the
    // applications that use IWAM.

    hr = pComAppCollection->get_Count( &nAppsInCollection );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to get Applications count (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }

    // Init our new app identity and password.

    varNewAppIdentity.vt = VT_BSTR;
    varNewAppIdentity.bstrVal = SysAllocString( szWamUserName );
    if( !varNewAppIdentity.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    varNewAppPassword.vt = VT_BSTR;
    varNewAppPassword.bstrVal = SysAllocString( szWamUserPass );
    if( !varNewAppPassword.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    for( iCurrentApp = 0; iCurrentApp < nAppsInCollection; ++iCurrentApp )
    {
        if( pComApp )
        {
            pComApp->Release();
            pComApp = NULL;
        }
        if( varOldAppIdentity.vt != VT_EMPTY )
        {
            VariantClear( &varOldAppIdentity );
        }

        hr = pComAppCollection->get_Item( iCurrentApp, 
                                          (IDispatch **)&pComApp );
        if( FAILED(hr) )
        {
            iisDebugOut(( LOG_TYPE_ERROR,
                       _T("Failed to get item from Applications collection (%08x)\n"),
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        // If the user has set this to something other than the IWAM_
        // user, then we will respect that and not reset the identiy.

        hr = pComApp->get_Value( L"Identity", &varOldAppIdentity );
        if( FAILED(hr) )
        {
            iisDebugOut(( LOG_TYPE_ERROR,
                       _T("Failed to get Identify from Application (%08x)\n"),
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        DBG_ASSERT( varOldAppIdentity.vt == VT_BSTR );
        if( varOldAppIdentity.vt == VT_BSTR )
        {
            if( memcmp( L"IWAM_", varOldAppIdentity.bstrVal, 10 ) == 0 )
            {
                hr = pComApp->put_Value( L"Identity", varNewAppIdentity );
                if( FAILED(hr) )
                {
                    iisDebugOut(( LOG_TYPE_ERROR,
                               _T("Failed to set new Identify (%08x)\n"),
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }

                hr = pComApp->put_Value( L"Password", varNewAppPassword );
                if( FAILED(hr) )
                {
                    iisDebugOut(( LOG_TYPE_ERROR,
                               _T("Failed to set new Password (%08x)\n"),
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }
            }
            else
            {
                DBGINFO(( DBG_CONTEXT,
                          "Unrecognized application identity (%S)\n",
                          varOldAppIdentity.bstrVal
                          ));
            }
        }
    }

    hr = pComAppCollection->SaveChanges( &nChanges );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to save changes (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }
    
    goto cleanup;

cleanup:

    if( hMetabase != NULL )
    {
        pcCom->CloseKey(hMetabase);
    }

    if( psaApplications != NULL )
    {
        SafeArrayDestroy( psaApplications );
    }

    if( pComCatalog != NULL )
    {
        pComCatalog->Release();
    }

    if( pComAppCollection != NULL )
    {
        pComAppCollection->Release();
    }

    if( pComApp != NULL )
    {
        pComApp->Release();
    }

    if( varAppKey.vt != VT_EMPTY )
    {
        VariantClear( &varAppKey );
    }

    if( varOldAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varOldAppIdentity );
    }

    if( varNewAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppIdentity );
    }

    if( varNewAppPassword.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppPassword );
    }

    delete [] pwszDataPaths;

    iisDebugOut((LOG_TYPE_TRACE, _T("UpdateComApplications():end\n")));

    // return
    if( FAILED(hr) )
    {
        return hr;
    }
    else if( fNoErrors == FALSE )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}


GUFM_RETURN GetUserFromMetabase(IMSAdminBase2 *pcCom,
                                LPWSTR pszPath,
                                DWORD dwUserMetaId,
                                DWORD dwPasswordMetaId,
                                USERNAME_STRING_TYPE ustUserBuf,
                                PASSWORD_STRING_TYPE pstPasswordBuf)
{

    HRESULT hresTemp;
    GUFM_RETURN  gufmReturn = GUFM_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen;

    METADATA_HANDLE mhOpenHandle;


    hresTemp = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                              pszPath,
                              METADATA_PERMISSION_READ,
                              OPEN_TIMEOUT_VALUE,
                              &mhOpenHandle);
    if (FAILED(hresTemp)) {
        gufmReturn = GUFM_NO_PATH;
    }
    else {
        MD_SET_DATA_RECORD_EXT(&mdrData,
                               dwUserMetaId,
                               METADATA_NO_ATTRIBUTES,
                               ALL_METADATA,
                               STRING_METADATA,
                               MAX_PATH * sizeof(TCHAR),
                               (PBYTE)ustUserBuf)

        hresTemp = pcCom->GetData(mhOpenHandle,
                                  NULL,
                                  &mdrData,
                                  &dwRequiredDataLen);

        if (FAILED(hresTemp) || (ustUserBuf[0] == (TCHAR)'\0')) {
            gufmReturn = GUFM_NO_USER_ID;
        }
        else {

            MD_SET_DATA_RECORD_EXT(&mdrData,
                                   dwPasswordMetaId,
                                   METADATA_NO_ATTRIBUTES,
                                   ALL_METADATA,
                                   STRING_METADATA,
                                   MAX_PATH * sizeof(TCHAR),
                                   (PBYTE)pstPasswordBuf)

            hresTemp = pcCom->GetData(mhOpenHandle,
                                      NULL,
                                      &mdrData,
                                      &dwRequiredDataLen);
            if (FAILED(hresTemp)) {
                gufmReturn = GUFM_NO_PASSWORD;
            }
        }
        pcCom->CloseKey(mhOpenHandle);
    }

    return gufmReturn;
}
#endif

// ReRegisterDav
//
// This will re-register Dav.  This is need after sysprep, so that the sids in the 
// registry are correct.
//
BOOL
ReregisterDav()
{
  TSTR_PATH strDavExe;
  TSTR      strCmdLine;

  if ( !strDavExe.RetrieveSystemDir() ||
       !strDavExe.PathAppend( _T("inetsrv") ) ||
       !strDavExe.PathAppend( _T("davcdata.exe") ) ||
       !strCmdLine.Copy( strDavExe ) ||
       !strCmdLine.Append( _T(" /RegServer") ) )
  {
    // Failed to construct strings
    return FALSE;
  }

  return RunProgram( strDavExe.QueryStr(),    // Exe
                     strCmdLine.QueryStr(),   // Parameters
                     TRUE,                    // Minimized
                     90,                      // Timeout, in seconds
                     FALSE );                 // Do not create new console
}

HRESULT WINAPI SysPrepAclSyncIWam(void)
{
    HRESULT hr = S_OK;
    IMSAdminBase2 * pcCom;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));

    hr = CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase2,(void **) & pcCom);
    if (SUCCEEDED(hr)) 
    {
#ifndef _CHICAGO_
        GUFM_RETURN gufmTemp;
        PASSWORD_STRING_TYPE pstAnonyPass;
        USERNAME_STRING_TYPE ustAnonyName;

        pstAnonyPass[0] = (TCHAR)'\0';
        ustAnonyName[0] = (TCHAR)'\0';
        //
        // Get the WAM username and password
        //
        gufmTemp = GetUserFromMetabase(pcCom,
                                       TEXT("LM/W3SVC"),
                                       MD_WAM_USER_NAME,
                                       MD_WAM_PWD,
                                       ustAnonyName,
                                       pstAnonyPass);

        UpdateComApplications(pcCom,ustAnonyName,pstAnonyPass);
#endif
    pcCom->Release();
    }

    // Loop thru all the acl's
    // and get the values, store it somewhere

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hr));
    return hr;
}

// function: ChangeIUsrPasswords
//
// Change the IUsr Passwords after you have been sysprepped
//
// This is three steps:
//   1) Get the IUSR account name
//   2) Create a new password for it
//   3) Change the password at all locations with the username
//
BOOL ChangeIUsrPasswords()
{
  CMDKey      cmdKey;
  TSTR        strAnonymousPrefix;   
  CMDValue    cmdAnonymousUserName;
  CMDValue    cmdCurrentUser;
  LPTSTR      pszNewPassword;
  CString     csPath;
  LPTSTR      szPath;
  CStringList cslpathList;
  POSITION    pos;
  BOOL        bRet = TRUE;

  if ( !strAnonymousPrefix.LoadString( IDS_GUEST_NAME ) ||
       FAILED( cmdKey.OpenNode(TEXT("LM")) ) )
  {
    // Either of these is fatal
    return FALSE;
  }

  // Find the anonymous username
  if ( !cmdKey.GetData( cmdAnonymousUserName,
                        MD_ANONYMOUS_USER_NAME,
                        L"W3SVC" ) ||
       ( _tcsnicmp( strAnonymousPrefix.QueryStr(),
                    (LPTSTR) cmdAnonymousUserName.GetData(),
                    strAnonymousPrefix.QueryLen() ) != 0 ) )
  {
    // Either there was no anynmous user there, or they replace the IUSR_ username
    return TRUE;
  }

  // Now update in all location
  if (FAILED( cmdKey.GetDataPaths( MD_ANONYMOUS_USER_NAME, 
                                   STRING_METADATA, 
                                   cslpathList) ))
  {
    // Could not GetDataPaths for this value
    return FALSE;
  }

  // Create new password
  pszNewPassword = CreatePassword(LM20_PWLEN+1);

  if ( !pszNewPassword )
  {
    // Could not create new password
    return FALSE;
  }

  pos = cslpathList.GetHeadPosition();

  while ( NULL != pos )
  {
    csPath = cslpathList.GetNext( pos );
    szPath = csPath.GetBuffer(0);

    if ( cmdKey.GetData( cmdCurrentUser, MD_ANONYMOUS_USER_NAME, szPath ),
         ( _tcsicmp( (LPTSTR) cmdAnonymousUserName.GetData(),
                     (LPTSTR) cmdCurrentUser.GetData() ) == 0 ) )
    {
      // We found a location with the username set
      if ( FAILED( cmdKey.SetData( MD_ANONYMOUS_PWD,
                                   METADATA_INHERIT | METADATA_SECURE,
                                   IIS_MD_UT_FILE,
                                   STRING_METADATA,
                                   ( _tcslen( pszNewPassword ) + 1 )*sizeof( TCHAR ),
                                   (LPBYTE) pszNewPassword,
                                   szPath ) ) )
      {
        // Failed to set correctly
        bRet = FALSE;
      }
    }
  }

  if ( pszNewPassword )
  {
    GlobalFree(pszNewPassword);
  }

  return bRet;
}

// function: ReSetIWamIUsrPasswds
//
// This function Changes the IWAM and IUSR passwords the 
// metabase.  Then sets a reg entry, and stops and starts 
// iisadmin.  This causes iisadmin to reset the password in NT,
// and re sync the com objects.
//
// Return:
//   TRUE - Succeeded
//   FALSE - Failed
//
BOOL ReSetIWamIUsrPasswds(void)
{
    DWORD               dwType;
    DWORD               dwValue;
    DWORD               dwSize;
    DWORD               dwOldRegValue;
    BOOL                fOldRegWasSet = FALSE;
    CMDKey              cmdKey;
    LPTSTR              pszNewPassword = NULL;
    HKEY                hKey;

    iisDebugOut((LOG_TYPE_TRACE, _T("ReSetIWamIUsrPasswds:start\n")));

    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_ENABLEPASSSYNC_KEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hKey) != ERROR_SUCCESS)
    {
        // If we can not open the registry to set the flag,
        // there is not hope in resetting the password
        return FALSE;
    }

    if ( !ChangeIUsrPasswords() )
    {
      return FALSE;
    }

    cmdKey.OpenNode(TEXT("LM/W3SVC"));

    // Set New IWAM Password
    pszNewPassword = CreatePassword(LM20_PWLEN+1);

    if ( pszNewPassword )
    {
        cmdKey.SetData(MD_WAM_PWD,METADATA_INHERIT | METADATA_SECURE,IIS_MD_UT_FILE,STRING_METADATA,(_tcslen(pszNewPassword)+1)*sizeof(TCHAR),(LPBYTE) pszNewPassword);
        GlobalFree(pszNewPassword);
    }

    cmdKey.Close();

    // Retrieve Old Value for REG_ENABLEPASSSYNC
    dwSize = sizeof(DWORD);
    if ( (RegQueryValueEx(hKey,REG_ENABLEPASSSYNC_VALUE,NULL,&dwType,(LPBYTE) &dwValue,&dwSize) == ERROR_SUCCESS) &&
         (dwType == REG_DWORD)
         )
    {
        fOldRegWasSet = TRUE;
        dwOldRegValue = dwValue;
    }

    // Set New Value
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    dwValue = 1;
    if (RegSetValueEx(hKey,REG_ENABLEPASSSYNC_VALUE,0,dwType,(LPBYTE) &dwValue,dwSize) == ERROR_SUCCESS)
    {

        // Stop IISAdmin Service
        StopServiceAndDependencies(TEXT("IISADMIN"), FALSE);

        // Start IISAdmin Service (this will resync the passwords)
        InetStartService(TEXT("IISADMIN"));

        // We are going to reboot after installing, so don't
        // worry about starting the services that we cascadingly
        // stopped

        // Reset the Key to the old value
        if (fOldRegWasSet)
        {
            dwSize = sizeof(DWORD);
            dwType = REG_DWORD;
            RegSetValueEx(hKey,REG_ENABLEPASSSYNC_VALUE,0,dwType,(LPBYTE) &dwOldRegValue,dwSize);
        }
        else
        {
            RegDeleteValue(hKey,REG_ENABLEPASSSYNC_VALUE);
        }
    }
    else
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;
}


DWORD SysPrepTempfileWriteAclInfo(HANDLE hFile,CString csKeyPath)
{
    DWORD dwReturn = ERROR_ACCESS_DENIED;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    PSECURITY_DESCRIPTOR pOldSd = NULL;

    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE)
    {
        return S_OK;
    }

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound)
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("MDDumpAdminACL():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                }
            }
        }
        cmdKey.Close();

        if (bFound)
        {
            // dump out the info
            // We've got the acl
            pOldSd = (PSECURITY_DESCRIPTOR) pData;
            if (IsValidSecurityDescriptor(pOldSd))
            {
#ifndef _CHICAGO_
                DumpAdminACL(hFile,pOldSd);
                dwReturn = ERROR_SUCCESS;
#endif
            }
        }
        else
        {
            dwReturn = ERROR_PATH_NOT_FOUND;
        }
    }
    return dwReturn;
}

void SysPrepTempfileWrite(HANDLE hFile,TCHAR * szBuf)
{
    DWORD dwBytesWritten = 0;
    if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
    {
        if (WriteFile(hFile, szBuf, _tcslen(szBuf) * sizeof(TCHAR), &dwBytesWritten, NULL ) == FALSE )
            {iisDebugOut((LOG_TYPE_WARN, _T("WriteFile Failed=0x%x.\n"), GetLastError()));}
    }
    return;
}

// Loop thru all the acl's
// and get the values, store it somewhere
HRESULT WINAPI SysPrepAclBackup(void)
{
    HRESULT hRes = S_OK;
    CMDKey cmdKey;
    CStringList cslpathList;
    POSITION        pos;
    CString         csPath;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    DWORD dwBytesWritten = 0;
    TCHAR buf[256];

    TCHAR szTempFileNameFull[_MAX_PATH];

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));
   
	hRes = cmdKey.OpenNode(_T("/"));
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("OpenNode failed. err=0x%x.\n"), hRes));
        goto SysPrepAclBackup_Exit;
    }

    // get the sub-paths that have the data on them
    hRes = cmdKey.GetDataPaths( MD_ADMIN_ACL, BINARY_METADATA, cslpathList);
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Update()-GetDataPaths failed. err=0x%x.\n"), hRes));
        goto SysPrepAclBackup_Exit;
    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = cslpathList.GetHeadPosition();
    if ( NULL == pos )
    {
        goto SysPrepAclBackup_Exit;
    }

    // Create the tempfile
	if (!GetWindowsDirectory(szTempFileNameFull,_MAX_PATH))
    {
        goto SysPrepAclBackup_Exit;
    }

    AddPath(szTempFileNameFull, SYSPREP_TEMPFILE_NAME);
    if (GetFileAttributes(szTempFileNameFull) != 0xFFFFFFFF)
    {
        // if file already exists, then delete it
        SetFileAttributes(szTempFileNameFull, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTempFileNameFull);
    }

    // create the file
	hFile = CreateFile(szTempFileNameFull,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hFile = NULL;
        goto SysPrepAclBackup_Exit;
	}
    SetFilePointer( hFile, NULL, NULL, FILE_END );

    // write a couple of bytes to the beginning of the file say that it's "unicode"
    WriteFile(hFile, (LPCVOID) 0xFF, 1, &dwBytesWritten, NULL);
    WriteFile(hFile, (LPCVOID) 0xFE, 1, &dwBytesWritten, NULL);

    // write a section so that setupapi api's can read it
    //
    //[version]
    //signature="$Windows NT$"
    memset(buf, 0, _tcslen(buf) * sizeof(TCHAR));
    _tcscpy(buf, _T("[version]\r\n"));SysPrepTempfileWrite(hFile, buf);
    _tcscpy(buf, _T("signature=\"$Windows NT$\"\r\n"));SysPrepTempfileWrite(hFile, buf);

    // Write in known section
    _stprintf(buf, _T("[%s]\r\n"),SYSPREP_KNOWN_SECTION_NAME);SysPrepTempfileWrite(hFile, buf);

    // Add entries for the [paths] section
    // [paths]
    // /
    // /w3svc/info
    // etc...
    //
    while ( NULL != pos )
    {
        // get the next path in question
        csPath = cslpathList.GetNext( pos );

        // Write to [paths] section
        _stprintf(buf, _T("%s\r\n"),csPath);
        SysPrepTempfileWrite(hFile, buf);

        // Save this whole list to the tempfile....
        //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s]\n"),csPath));
    }

    // close the metabase
    if ( (METADATA_HANDLE)cmdKey )
        {cmdKey.Close();}

    // go to the top of the list again
    pos = cslpathList.GetHeadPosition();
    while ( NULL != pos )
    {
        // get the next path in question
        csPath = cslpathList.GetNext( pos );

        // Write to [paths] section
        _stprintf(buf, _T("[%s]\r\n"),csPath);
        SysPrepTempfileWrite(hFile, buf);

        // Get the info that we will add to this section from looking up the metabase...
        // open up the metabase item for each of them.
        // Grab the AdminACL data, convert it to username/permissions
        // save the username/permission data into text format
        SysPrepTempfileWriteAclInfo(hFile,csPath);
    }

SysPrepAclBackup_Exit:
    if ( (METADATA_HANDLE)cmdKey )
        {cmdKey.Close();}
    if (hFile)
        {CloseHandle(hFile);}
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hRes));
    return hRes;
}



void SysPrepRestoreAclSection(IN HINF hFile, IN LPCTSTR szSection)
{
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    bRet = FALSE;
    INFCONTEXT Context;
    CSecurityDescriptor SD;
    DWORD               dwSize;
    BUFFER              buffNewSD;
    TSTR                strSid;

    // go to the beginning of the section in the INF file
    bRet = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!bRet)
        {
        goto SysPrepRestoreAclSection_Exit;
        }

    // Start off by deleting the old ACL, since we do not want to add
    // to it, we want to replace it
    if ( FAILED( RemoveMetabaseACL( szSection ) ) )
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("RemoveMetabaseACL failed!!\n")));
    }

    // Set Group and Owner of SD
    if ( !SD.SetOwnerbyWellKnownID( CSecurityDescriptor::GROUP_ADMINISTRATORS ) ||
         !SD.SetGroupbyWellKnownID( CSecurityDescriptor::GROUP_ADMINISTRATORS ) )
    {
      iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Failed to initialize SD with owner and group, GLE=%8x\n"),GetLastError()));
      goto SysPrepRestoreAclSection_Exit;    
    }

    // loop through the items in the section.
    while (bRet) 
    {
        // get the size of the memory we need for this
        bRet = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            goto SysPrepRestoreAclSection_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            goto SysPrepRestoreAclSection_Exit;
            }

        // The line we get should look something like this:
        //
        //[/]
        //IIS_WPG,0x0,0x0,0x24,0x400ab
        //Administrators,0x0,0x0,0x18,0x400ab
        //Everyone,0x0,0x0,0x14,0x8

        // Get everything to the left of the "=" sign
        // this should be the username
        TCHAR szUserName[UNLEN + 1];
        ACCESS_ALLOWED_ACE MyNewACE;

        TCHAR *token = NULL;
        token = _tcstok(szLine, _T(","));
        if (token == NULL)
        {
            goto SysPrepRestoreAclSection_Exit;
        }
        // Get the username
        _tcscpy(szUserName,token);

        // Copy the String Sid
        token = _tcstok(NULL, _T(","));
        if ( (NULL == token) ||
             !strSid.Copy( token ) )
        {
          goto SysPrepRestoreAclSection_Exit;
        }

        // Get the next 4 values...
        token = _tcstok(NULL, _T(","));
        if (NULL == token){goto SysPrepRestoreAclSection_Exit;}
        MyNewACE.Header.AceType = (UCHAR) atodw(token);

        token = _tcstok(NULL, _T(","));
        if (NULL == token){goto SysPrepRestoreAclSection_Exit;}
        MyNewACE.Header.AceFlags = (UCHAR) atodw(token);

        token = _tcstok(NULL, _T(","));
        if (NULL == token){goto SysPrepRestoreAclSection_Exit;}
        MyNewACE.Header.AceSize = (USHORT) atodw(token);

        token = _tcstok(NULL, _T(","));
        if (NULL == token){goto SysPrepRestoreAclSection_Exit;}
        MyNewACE.Mask = atodw(token);

        //iisDebugOut((LOG_TYPE_TRACE, _T("NewACLinfo:%s,0x%x,0x%x,0x%x,0x%x\n"),szUserName,MyNewACE.Header.AceType,MyNewACE.Header.AceFlags,MyNewACE.Header.AceSize,MyNewACE.Mask));

        // Grab this info and create an ACL for it.
        if ( AddUserToMetabaseACL2( &SD, szUserName, strSid.QueryStr(), &MyNewACE) != ERROR_SUCCESS )
        {
          iisDebugOut((LOG_TYPE_ERROR, _T("Failed to restore metabase acl by adding '%s' to ACL at '%s', GLE=%8x)\n"),szUserName,szSection,GetLastError()));
          return;
        }
       
        // find the next line in the section. If there is no next line it should return false
        bRet = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );szLine=NULL;
        szLine = NULL;
    }

    if ( !SD.CreateSelfRelativeSD( &buffNewSD, &dwSize ) )
    {
      // Failed to make selfrelative
      iisDebugOut((LOG_TYPE_ERROR, _T("Failed to create SelfRelative SD at '%s', GLE=%8x)\n"),szSection,GetLastError()));
      return;
    }

    WriteSDtoMetaBase( (PSECURITY_DESCRIPTOR) buffNewSD.QueryPtr(), szSection);

SysPrepRestoreAclSection_Exit:
    if (szLine) {GlobalFree(szLine);szLine=NULL;}
    return;
}

// Function: RemoveMetabaseACL
//
// Delete the Metabase ACL from the node specified
//
// Parameters:
//   szPath - The node to delete it from
//
HRESULT RemoveMetabaseACL( LPCTSTR szPath )
{
  DWORD hr;
  CMDKey cmdKey;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("RemoveMetabaseACL:start\n")));

  hr = cmdKey.OpenNode( szPath );

  if ( FAILED( hr ) )
  {
    // Failed to open Node
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("RemoveMetabaseACL: Open failed, hr = %8x\n"), hr));
    return hr;
  }

  hr = cmdKey.DeleteData( MD_ADMIN_ACL, ALL_METADATA );

  if ( FAILED( hr ) &&
       ( hr == MD_ERROR_DATA_NOT_FOUND ) ) 
  {
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("RemoveMetabaseACL: Delete failed, hr = %8x\n"), hr));
    // If the value did not exist, that is fine, 
    // we will just create a new one
    hr = S_OK;
  }

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("RemoveMetabaseACL: end\n")));

  // Successfully removed
  return hr;
}

DWORD AddUserToMetabaseACL2( CSecurityDescriptor *pSD, LPTSTR szUserToAdd, LPTSTR szSidString, ACCESS_ALLOWED_ACE * MyACEInfo)
{
  DWORD dwReturn;

  iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddUserToMetabaseACL2():start.  MyACEInfo->Mask=0x%x.\n"), MyACEInfo->Mask));


  if ( !pSD->AddAccessAcebyName( szUserToAdd, 
                                 MyACEInfo->Mask, 
                                 MyACEInfo->Header.AceType == ACCESS_ALLOWED_ACE_TYPE ) )
  {
    // If we can not add by Username, then lets try to add by the old Sid
    // since it might be a domain account we just can not get to
    if ( !pSD->AddAccessAcebyStringSid( szSidString,
                                        MyACEInfo->Mask, 
                                        MyACEInfo->Header.AceType == ACCESS_ALLOWED_ACE_TYPE ) )
    {
      // Failed to add user
      dwReturn = GetLastError();
    }
  }

  iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddUserToMetabaseACL2():End.  Return=0x%x.\n"), dwReturn ));
  return ERROR_SUCCESS;
}


HRESULT WINAPI SysPrepAclRestore(void)
{
    HRESULT hr = S_OK;
    HINF InfHandle;
    TCHAR szTempFileNameFull[_MAX_PATH];
    CStringList strList;
    CString csTheSection = SYSPREP_KNOWN_SECTION_NAME;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));
    //MDDumpAdminACL(_T("/"));

    // Loop thru our data file
    // Create the tempfile
	if (!GetWindowsDirectory(szTempFileNameFull,_MAX_PATH))
    {
        goto SysPrepAclRestore_Exit;
    }
    AddPath(szTempFileNameFull, SYSPREP_TEMPFILE_NAME);

    // Get a handle to it.
    InfHandle = SetupOpenInfFile(szTempFileNameFull, NULL, INF_STYLE_WIN4, NULL);
    if(InfHandle == INVALID_HANDLE_VALUE) 
    {
        goto SysPrepAclRestore_Exit;
    }

    if (ERROR_SUCCESS == FillStrListWithListOfSections(InfHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos;
            CString csEntry;

            pos = strList.GetHeadPosition();
            while (pos) 
            {
                csEntry = strList.GetAt(pos);

                // go get this section and read thru it's info
                SysPrepRestoreAclSection(InfHandle, csEntry);
                strList.GetNext(pos);
            }
        }
    }

    //MDDumpAdminACL(_T("/"));

    if (GetFileAttributes(szTempFileNameFull) != 0xFFFFFFFF)
    {
        // if file already exists, then delete it
        SetFileAttributes(szTempFileNameFull, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTempFileNameFull);
    }


SysPrepAclRestore_Exit:
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hr));
    return hr;
}

//
// DO NOT REMOVE THIS ENTRY POINT
//
// Entry point used by SysPrep in Whistler
//
// When sysprep runs, it is going to reset the machine sid
// so when that happens all the crypto stuff is broken.
// we had to implement this stuff so that before sysprep
// changes the sid (and thus breaking crypto) we can save our
// working metabase off somewhere (without crypto key encryption)
//
// At some point after sysprep has changed the machine sid
// it will call us into SysPrepRestore() and we wil restore
// our metabase using the new crypto keys on the machine.
//
HRESULT WINAPI SysPrepBackup(void)
{
    HRESULT hr = S_OK;
    WCHAR lpwszBackupLocation[_MAX_PATH];
    DWORD dwMDVersion;
    DWORD dwMDFlags;
    WCHAR * pwszPassword = NULL;
    BOOL bThingsAreGood = FALSE;
    IMSAdminBase2 * pIMSAdminBase2 = NULL;

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("SysPrepBackup:"));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));

#ifndef _CHICAGO_
#ifdef SYSPREP_USE_SECRETS
#else
    CRegKey regBigString(HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_ALL_ACCESS);
#endif
#endif
    // Check if the user who loaded this dll 
    // and is calling this entry point has the right priv to do this!
    if (FALSE == RunningAsAdministrator())
    {
        hr = E_ABORT;
        iisDebugOut((LOG_TYPE_ERROR, _T("No admin priv, aborting\n")));
        goto SysPrepBackup_Exit2;
    }


    // if the service doesn't exist, then we don't have to do anyting
    if (CheckifServiceExist(_T("IISADMIN")) != 0 ) 
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("IIS not installed. do nothing.\n")));
        hr = S_OK;
        goto SysPrepBackup_Exit2;
    }

    // start the iisadmin service before calling backup.
    // this is because if the backup function is called and the metabase is not
    // running, then the metabase must startup while backup is trying to lock the
    // metabase for backup.  a race condition will happen and sometimes backup will
    // fail since the metabase may take a while before starting up.
    // this function will wait till the service is fully started before returning
    InetStartService(_T("IISADMIN"));

#ifndef _CHICAGO_
    pwszPassword = CreatePassword(SYSPREP_TEMP_PASSWORD_LENGTH);
    if (pwszPassword)
    {
#ifdef SYSPREP_USE_SECRETS
        // calling set 
        if (ERROR_SUCCESS == SetSecret(SYSPREP_KNOWN_REGISTRY_KEY,pwszPassword))
        {
            bThingsAreGood = TRUE;
        }
#else
        if ((HKEY) regBigString)
        {
            regBigString.SetValue(SYSPREP_KNOWN_REGISTRY_KEY, pwszPassword);
            bThingsAreGood = TRUE;
        }
#endif
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("PASSWORD=%s,len=%d\n"),pwszPassword,wcslen(pwszPassword)));
#endif

    // Tell the metabase where it should backup to.
    wcscpy(lpwszBackupLocation,L"");
    
    dwMDFlags = MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST | MD_BACKUP_FORCE_BACKUP;
    dwMDVersion = MD_BACKUP_MAX_VERSION;

#ifndef _CHICAGO_
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    hr = CoInitialize(NULL);
#endif
    // no need to call uninit
    if( FAILED (hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx failed\n")));
        goto SysPrepBackup_Exit2;
    }

    hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase2,(void **) & pIMSAdminBase2);
    if(FAILED (hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoCreateInstance on IID_IMSAdminBase2 failed\n")));
        goto SysPrepBackup_Exit;
    }

    // Call the metabase function
	if (SUCCEEDED(hr))
	{
        iisDebugOut((LOG_TYPE_TRACE, _T("BackupWithPasswd calling...\n")));
        if (bThingsAreGood)
        {
            //iisDebugOut((LOG_TYPE_TRACE, _T("using org\n")));
		    hr = pIMSAdminBase2->BackupWithPasswd(lpwszBackupLocation, dwMDVersion, dwMDFlags, pwszPassword);
        }
        else
        {
            //iisDebugOut((LOG_TYPE_TRACE, _T("using backup\n")));
            hr = pIMSAdminBase2->BackupWithPasswd(lpwszBackupLocation, dwMDVersion, dwMDFlags, L"null");
        }
        if (pIMSAdminBase2) 
        {
            pIMSAdminBase2->Release();
            pIMSAdminBase2 = NULL;
        }
        if (SUCCEEDED(hr))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("BackupWithPasswd SUCCEEDED\n")));
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("BackupWithPasswd failed\n")));
        }

        // Save all the acl info somewhere.
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("SysPrepAclBackup"));
        SysPrepAclBackup();
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        // set a flag to say that we called backup...
        CRegKey regStageString(HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_ALL_ACCESS);
        if ((HKEY) regStageString)
        {
            regStageString.SetValue(SYSPREP_KNOWN_REGISTRY_KEY2, _T("1"));
        }
	}

SysPrepBackup_Exit:
    CoUninitialize();

SysPrepBackup_Exit2:
    if (pwszPassword) {GlobalFree(pwszPassword);pwszPassword=NULL;}
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hr));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T(""));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    return hr;
}

//
// DO NOT REMOVE THIS ENTRY POINT
//
// Entry point used by SysPrep in Whistler
//
// When sysprep runs, it is going to reset the machine sid
// so when that happens all the crypto stuff is broken.
// we had to implement this stuff so that before sysprep
// changes the sid (and thus breaking crypto) we can save our
// working metabase off somewhere (without crypto key encryption)
//
// At some point after sysprep has changed the machine sid
// it will call us into SysPrepRestore() and we wil restore
// our metabase using the new crypto keys on the machine.
//
HRESULT WINAPI SysPrepRestore(void)
{
    HRESULT hr = S_OK;
    WCHAR lpwszBackupLocation[_MAX_PATH];
    TCHAR  szTempDir[_MAX_PATH];
    TCHAR  szSystemDir[_MAX_PATH];
    DWORD dwMDVersion;
    DWORD dwMDFlags;
    TSTR  strPassword;
    IMSAdminBase2 * pIMSAdminBase2 = NULL;
    BOOL bThingsAreGood = FALSE;

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("SysPrepRestore:"));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));

    strPassword.MarkSensitiveData(TRUE);

#ifndef _CHICAGO_
#ifdef SYSPREP_USE_SECRETS
#else
    CRegKey regBigString(HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_ALL_ACCESS);
#endif
#endif
    CRegKey regStageString(HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_ALL_ACCESS);
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SysPrepRestore start\n")));

    // Check if the user who loaded this dll 
    // and is calling this entry point has the right priv to do this!
    if (FALSE == RunningAsAdministrator())
    {
        hr = E_ABORT;
        iisDebugOut((LOG_TYPE_ERROR, _T("No admin priv, aborting\n")));
        goto SysPrepRestore_Exit2;
    }

    // Only do this restore stuff if backup was called...
    
    if ((HKEY) regStageString)
    {
        CString csTheData;
        regStageString.m_iDisplayWarnings = FALSE;
        if ( regStageString.QueryValue(SYSPREP_KNOWN_REGISTRY_KEY2, csTheData) == ERROR_SUCCESS )
        {
            if (_tcsicmp(csTheData,_T("1")) == 0)
            {
                // Backup was run!
                bThingsAreGood = TRUE;
            }
            else
            {
                bThingsAreGood = FALSE;
            }
        }
    }

    if (FALSE == bThingsAreGood)
    {
        // Lets get out.
        iisDebugOut((LOG_TYPE_TRACE, _T("SysPrepBackup not called, so not doing SysPrepRestore. do nothing.\n")));
        hr = S_OK;
        goto SysPrepRestore_Exit2;
    }

    if ( !SetInstallStateInRegistry( INSTALLSTATE_CURRENTLYINSTALLING ) )
    {
        hr = E_ABORT;
        iisDebugOut((LOG_TYPE_ERROR, _T("Could not set setup install state in registry, aborting\n")));
        goto SysPrepRestore_Exit2;
    }

    // if the service doesn't exist, then we don't have to do anyting
    if (CheckifServiceExist(_T("IISADMIN")) != 0 ) 
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("SysPrepRestore IIS not installed. do nothing.\n")));
        hr = S_OK;
        goto SysPrepRestore_Exit2;
    }

    // make sure the iisadmin service is stopped.
    StopServiceAndDependencies(_T("IISADMIN"), TRUE);

#ifndef _CHICAGO_
#ifdef SYSPREP_USE_SECRETS
    if (GetSecret(SYSPREP_KNOWN_REGISTRY_KEY, &strPassword))
    {
        bThingsAreGood = TRUE;
    }
#else
    if ((HKEY) regBigString)
    {
        CString csTheData;
        regBigString.m_iDisplayWarnings = FALSE;
        if ( regBigString.QueryValue(SYSPREP_KNOWN_REGISTRY_KEY, csTheData) == ERROR_SUCCESS )
        {
            pwszPassword = (WCHAR *) GlobalAlloc (GPTR, (csTheData.GetLength() + 1) * sizeof(TCHAR) );
            if (pwszPassword)
            {
                wcscpy(pwszPassword,csTheData);
                bThingsAreGood = TRUE;
            }
        }
    }
#endif
#endif

    //iisDebugOut((LOG_TYPE_TRACE, _T("PASSWORD=%s,len=%d\n"),pwszPassword,wcslen(pwszPassword)));


    // Tell the metabase where it should backup to.
    wcscpy(lpwszBackupLocation,L"");
    dwMDFlags = 0;
    dwMDVersion = MD_BACKUP_MAX_VERSION;

    //
    // IISAdmin won't start up if the metabase.xml,mbschema.xml files are corrupted (bad signature)
    // so delete them before restoring....
    if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
    {
        goto SysPrepRestore_Exit2;
    }

    // delete existing metabase files
    // we can't have this file hanging around --> the metabase won't start if it is here!

    // iis6 files -- for whistler server skus
    _stprintf(szTempDir, _T("%s\\inetsrv\\Metabase.xml"),szSystemDir);
    InetDeleteFile(szTempDir);
    _stprintf(szTempDir, _T("%s\\inetsrv\\MBSchema.xml"),szSystemDir);
    InetDeleteFile(szTempDir);
    // iis51 files -- for whistler pro sku
    _stprintf(szTempDir, _T("%s\\inetsrv\\metabase.bin"),szSystemDir);
    InetDeleteFile(szTempDir);

#ifndef _CHICAGO_
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    hr = CoInitialize(NULL);
#endif
    // no need to call uninit
    if( FAILED (hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx failed\n")));
        goto SysPrepRestore_Exit2;
    }
    hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase2,(void **) & pIMSAdminBase2);
    if(FAILED (hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoCreateInstance on IID_IMSAdminBase2 failed\n")));
        goto SysPrepRestore_Exit;
    }

    // Call the metabase function
	if (SUCCEEDED(hr))
	{
        iisDebugOut((LOG_TYPE_TRACE, _T("RestoreWithPasswd calling...\n")));
        if (bThingsAreGood)
        {
            //iisDebugOut((LOG_TYPE_TRACE, _T("using org\n")));
		    hr = pIMSAdminBase2->RestoreWithPasswd(lpwszBackupLocation, dwMDVersion, dwMDFlags, strPassword.QueryStr() );
        }
        else
        {
            //iisDebugOut((LOG_TYPE_TRACE, _T("using backup\n")));
            hr = pIMSAdminBase2->RestoreWithPasswd(lpwszBackupLocation, dwMDVersion, dwMDFlags, L"null");
        }
        if (pIMSAdminBase2) 
        {
            pIMSAdminBase2->Release();
            pIMSAdminBase2 = NULL;
        }
        if (SUCCEEDED(hr))
        {

            // Delete the backup file that we used!
            //MD_DEFAULT_BACKUP_LOCATION + ".md" + MD_BACKUP_MAX_VERSION
            _stprintf(szTempDir, _T("%s\\inetsrv\\MetaBack\\%s.md%d"),szSystemDir,MD_DEFAULT_BACKUP_LOCATION,MD_BACKUP_MAX_VERSION);
            InetDeleteFile(szTempDir);
            _stprintf(szTempDir, _T("%s\\inetsrv\\MetaBack\\%s.sc%d"),szSystemDir,MD_DEFAULT_BACKUP_LOCATION,MD_BACKUP_MAX_VERSION);
            InetDeleteFile(szTempDir);
            iisDebugOut((LOG_TYPE_TRACE, _T("RestoreWithPasswd SUCCEEDED\n")));
#ifndef _CHICAGO_
#ifdef SYSPREP_USE_SECRETS
            // we need to delete the Secret that we used here!            
            SetSecret(SYSPREP_KNOWN_REGISTRY_KEY,L" ");
#else
            if ((HKEY) regBigString)
            {
                regBigString.DeleteValue(SYSPREP_KNOWN_REGISTRY_KEY);
            }
#endif
#endif

            // Do extra stuff
            // like Re-applying the acl for the iis_wpg group to the "/" node
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("SysPrepAclRestore"));
            SysPrepAclRestore();
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

            // syncronize wam with new iwam user
            //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("SysPrepAclSyncIWam"));
            //SysPrepAclSyncIWam();
            //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

            // only delete this if restore ws success
            if ((HKEY) regStageString)
            {
                regStageString.DeleteValue(SYSPREP_KNOWN_REGISTRY_KEY2);
            }

        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("RestoreWithPasswd failed, with hr=0x%8x\n"),hr));
        }
	}

    // Reset the passwords, and allow iisadmin to fix the com information
    if (!ReSetIWamIUsrPasswds())
    {
        iisDebugOut((LOG_TYPE_WARN, _T("ReSetIWamIUsrPasswds was unable to reset IUSR and IWAM passwords\n")));
    }

    if ( !ReregisterDav() )
    {
        iisDebugOut((LOG_TYPE_WARN, _T("Failed to update DAV COM ACL's\n")));
    }

SysPrepRestore_Exit:
    CoUninitialize();

SysPrepRestore_Exit2:
    SetInstallStateInRegistry( INSTALLSTATE_DONE );
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hr));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T(""));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    return hr;
}

// ValidateWebRootDir
//
// Update the g_pTheApp->m_csPathWWWRoot
BOOL ValidateWebRootDir()
{
  TSTR  strWWWRootDir;

  if ( !strWWWRootDir.Resize( MAX_PATH ) )
  {
    // Could not allocate space for this
    return FALSE;
  }

  if ( GetDataFromMetabase(METABASEPATH_DEFAULTSITE, MD_VR_PATH, (PBYTE)strWWWRootDir.QueryStr(), strWWWRootDir.QuerySize()))
  {
    g_pTheApp->m_csPathWWWRoot = strWWWRootDir.QueryStr();
  }

  return TRUE;
}

// IsInstalled
//
// Check if the component is installed
//
BOOL
IsInstalled( LPTSTR szServiceName, LPBOOL pbIsInstalled )
{
  DWORD dwRet;

  dwRet = CheckifServiceExist( szServiceName );

  if ( ( dwRet != ERROR_SUCCESS ) &&
       ( dwRet != ERROR_SERVICE_DOES_NOT_EXIST ) )
  {
    SetLastError( dwRet );
    return FALSE;
  }

  *pbIsInstalled = ( dwRet == ERROR_SUCCESS );

  return TRUE;
}

// ApplyIISAcl
//
// Apply the IIS Acl's to the machine, or remove them
//
BOOL
ApplyIISAcl( WCHAR cDriveLetter, BOOL bAdd )
{
  BOOL      bRet = TRUE;
  BOOL      bW3SVCIsInstalled;
  BOOL      bIISAdminIsInstalled;
  TSTR_PATH strSystemDrive;

  if ( !IsInstalled( _T("W3SVC"), &bW3SVCIsInstalled ) ||
       !IsInstalled( _T("IISAdmin"), &bIISAdminIsInstalled ) )
  {
    // Failed to query if service was installed
    return FALSE;
  }

  if ( !bIISAdminIsInstalled )
  {
    // Since nothing is installed, lets just exit now
    return TRUE;
  }

  if ( !g_pTheApp->InitApplicationforSysPrep() ||
       !ValidateWebRootDir() ||
       !UpdateAnonymousUsers( NULL ) ||
       !strSystemDrive.RetrieveWindowsDir() )
  {
    return FALSE;
  }

  // Reset this now, since we do not want it to interfere with the ACLing
  g_pTheApp->m_eUpgradeType = UT_NONE;

  if ( bAdd )
  {
    if ( bIISAdminIsInstalled &&
         ( ( cDriveLetter == L'*' ) ||
           ( tolower( cDriveLetter ) == tolower( *( strSystemDrive.QueryStr() ) ) )
         )
       )
    {
      // Update ACL's for IISAdmin if we are acling system drive
      bRet = bRet && CCommonInstallComponent::SetMetabaseFileAcls();
    }

    if ( bW3SVCIsInstalled )
    {
      // Update ACL's for W3SVC
      bRet = bRet && CWebServiceInstallComponent::SetAppropriateFileAclsforDrive( cDriveLetter );

      if ( ( cDriveLetter == L'*' ) ||
           ( tolower( cDriveLetter ) == tolower( *( strSystemDrive.QueryStr() ) ) ) )
      {
        bRet = bRet && CWebServiceInstallComponent::SetAspTemporaryDirAcl( TRUE );
      }
    }
  }
  else
  {
    // Not implemented yet, because it is not used
    bRet = FALSE;
  }

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\webcomp.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        webcomp.cxx

   Abstract:

        Class used to install the World Wide Web component

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       April 2002: Created

--*/

#include "stdafx.h"
#include "webcomp.hxx"
#include "acl.hxx"
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "mdentry.h"
#include "restrlst.hxx"
#include "svc.h"
#include "reg.hxx"
#include "ACShim.h"
#include "Setuser.h"
#include "lockdown.hxx"
#include "helper.h"
#include "Wtsapi32.h"           // TS settings
#include "Mprapi.h"             // RAS/VPN Settings
#include "lockdown.hxx"
#include <secconlib.h>
#include <shlwapi.h>
#include "inetinfo.h"
#include "resource.h"

// Undef this becase of collision with TSTR::PathAppend
#ifdef PathAppend 
#undef PathAppend
#endif

// Local const definitions
//
LPCWSTR IIS_WPG_GROUPNAME = L"IIS_WPG";
LPCWSTR OLD_WAM_GROUPNAME = L"Web Applications";

const LPTSTR MofCompFiles[] = 
  { { _T("asp.mof") },
    { _T("w3core.mof") },
    { _T("w3isapi.mof") },
    { NULL } };



sOurDefaultExtensions CWebServiceInstallComponent::m_aExternalExt[ CWebServiceInstallComponent::EXTENSIONS_EXTERNAL ] =
    {
        {   _T("idq.dll"),
            _T("IndexingService"),
            IDS_PRODUCT_INDEXSERVICE,
            NULL,   // No component name - we don't install this
            FALSE,  // UI deletable
            FALSE,  // Disabled
            {   _T(".idq"),
                _T(".ida"),
                NULL
            } 
        },
        {   _T("webhits.dll"),
            _T("IndexingService"),
            IDS_PRODUCT_INDEXSERVICE,
            NULL,   // No component name - we don't install this
            FALSE,  // UI deletable
            FALSE,  // Disabled
            {   _T(".htw"),
                NULL
            } 
        },
        {   _T("msw3prt.dll"),
            _T("W3PRT"),
            IDS_PRODUCT_INETPRINT,
            NULL,   // No component name - we don't install this
            FALSE,  // UI deletable
            FALSE,  // Disabled
            {   _T(".printer"),
                NULL
            } 
        }
    };



// Constructor
//
CWebServiceInstallComponent::CWebServiceInstallComponent()
{
  m_bMofCompRun = FALSE;
  m_bWebDavIsDisabled = FALSE;
}

// GetName
//
// Return the name for the Web Service Component
//
LPTSTR 
CWebServiceInstallComponent::GetName()
{
  return _T("iis_www");
}

// GetFriendlyName
//
// Get the Friendly name for the UI
//
BOOL 
CWebServiceInstallComponent::GetFriendlyName( TSTR *pstrFriendlyName )
{
  return pstrFriendlyName->LoadString( IDS_DTC_WORLDWIDEWEB );
}

// SetWWWRootAclonDir
//
// Set the WWW Root Acl that we need.  This will be used for WWWRoot
// and the customer error pages root
//
// The acl is the following:
//   Upgrades      - Add IIS_WPG:R
//   Fresh Install - <Deny>   IUSR_MACHINENAME:Write+Delete
//                   <Allow>  Users:Read+Execute
//                   <Allow>  IIS_WPG:Read+Execute
//                   <Allow>  Administrators:Full
//                   <Allow>  LocalSystem:Full
//
// Parameters:
//   szPhysicalPath - The Physical Path to add the ACL
//   bAddIusrDeny - Should we add the IUSR_ deny acl?
//
// Return:
//   TRUE - Success
//   FALSE - Failure
BOOL 
CWebServiceInstallComponent::SetWWWRootAclonDir(LPTSTR szPhysicalPath, 
                                                BOOL bAddIusrDeny)
{
  CSecurityDescriptor PathSD;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetWWWRootAclonDir\n")));

  if ( IsUpgrade() )
  {
    // Upgrade
    if ( !PathSD.GetSecurityInfoOnFile( szPhysicalPath ) )
    {
      // Failed to retrieve old SD
      return FALSE;
    }
  }
  else
  {
    // Fresh Install
    if ( !PathSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::GROUP_USERS, 
                                            CSecurityDescriptor::ACCESS_READ_EXECUTE,
                                            TRUE, 
                                            TRUE ) ||
         !PathSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::GROUP_ADMINISTRATORS, 
                                            CSecurityDescriptor::ACCESS_FULL, 
                                            TRUE, 
                                            TRUE ) ||
         !PathSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::USER_LOCALSYSTEM, 
                                            CSecurityDescriptor::ACCESS_FULL, 
                                            TRUE, 
                                            TRUE )
        )
    {
      // Failed ot create SD
      return FALSE;
    }

    if ( bAddIusrDeny &&
         !PathSD.AddAccessAcebyName( g_pTheApp->m_csGuestName.GetBuffer(0), 
                                    CSecurityDescriptor::ACCESS_WRITEONLY | 
                                    CSecurityDescriptor::ACCESS_DIR_DELETE, 
                                    FALSE, 
                                    TRUE ) )
    {
      // Failed to add IUSR_
      return FALSE;
    }
  }

  if ( !PathSD.AddAccessAcebyName( _T("IIS_WPG"), 
                                    CSecurityDescriptor::ACCESS_READ_EXECUTE,
                                    TRUE, 
                                    TRUE ) )
  {
    // Failed to add IIS_WPG
    return FALSE;
  }

  if ( !CreateDirectoryWithSA( szPhysicalPath, PathSD, FALSE ) )
  {
    // Failed to set ACL on file/dir
    return FALSE;
  }

  return TRUE;
}

// SetPassportAcls
//
// Set the appropriate Passport Acl's
//
// Parameters
//   bAdd - TRUE == Add Acl
//          FALSE == Remove Acl
// 
BOOL 
CWebServiceInstallComponent::SetPassportAcls( BOOL bAdd )
{
  BOOL                bIsAclable;
  TSTR_PATH           strPassportDir;
  CSecurityDescriptor sdPassport;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetPassportAcls\n")));

  if ( !strPassportDir.RetrieveSystemDir() ||
       !strPassportDir.PathAppend( PATH_PASSPORT )
     )
  {
    // Could not create CustomError Path
    return FALSE;
  }

  if ( !CSecurityDescriptor::DoesFileSystemSupportACLs( 
                                  strPassportDir.QueryStr(),
                                  &bIsAclable ) )
  {
    return FALSE;
  }

  if ( !bIsAclable )
  {
    // Passport dir is not aclable, so lets exit
    return TRUE;
  }

  // If directory does not exist, then create it
  if ( !IsFileExist( strPassportDir.QueryStr() ) ) 
  {
    if ( !bAdd ) 
    {
      // Nothing to remove ACl From
      return TRUE;
    }

    if ( !CreateDirectory( strPassportDir.QueryStr(), NULL ) )
    {
      // Failed to create passport dir
      return FALSE;
    }
  }

  if ( !sdPassport.GetSecurityInfoOnFile( strPassportDir.QueryStr() ) )
  {
    return FALSE;
  }
  
  if ( bAdd )
  {
    if ( !sdPassport.AddAccessAcebyName( _T("IIS_WPG"), 
                                         CSecurityDescriptor::ACCESS_READ_EXECUTE |
                                         CSecurityDescriptor::ACCESS_WRITEONLY |
                                         CSecurityDescriptor::ACCESS_DIR_DELETE,
                                         TRUE, 
                                         TRUE )
       )
    {
      return FALSE;
    }
  }
  else
  {
    if ( !sdPassport.RemoveAccessAcebyName( _T("IIS_WPG") ) )
    {
      return FALSE;
    }
  }

  if ( !sdPassport.SetSecurityInfoOnFile( strPassportDir.QueryStr(), FALSE ) )
  {
    // Failed to set ACL
    return FALSE;
  }

  return TRUE;
}

// SetAdminScriptsAcl
//
// Set the ACL on the AdminScripts Directory
//
BOOL 
CWebServiceInstallComponent::SetAdminScriptsAcl()
{
  TSTR_PATH           strAdminScripts;
  CSecurityDescriptor AdminSD;
  BOOL                bDriveIsAclable;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetAdminScriptsAcl\n")));

  if ( !strAdminScripts.Copy( g_pTheApp->m_csPathInetpub.GetBuffer(0) ) ||
       !strAdminScripts.PathAppend( _T("AdminScripts") ) )
  {
    // Failed to construct Path
    return FALSE;
  }

  if ( !CSecurityDescriptor::DoesFileSystemSupportACLs(
                strAdminScripts.QueryStr(),
                &bDriveIsAclable ) )
  {
    // Failed to check if ACL is valid for this filesystem
    return FALSE;
  }

  if ( !bDriveIsAclable )
  {
    // This drive is not aclable, so skip it
    return TRUE;
  }

  if ( !AdminSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::GROUP_ADMINISTRATORS, 
                                           CSecurityDescriptor::ACCESS_FULL, 
                                           TRUE, 
                                           TRUE ) ||
       !AdminSD.AddAccessAcebyWellKnownID( CSecurityDescriptor::USER_LOCALSYSTEM, 
                                           CSecurityDescriptor::ACCESS_FULL, 
                                           TRUE, 
                                           TRUE ) )
  {
    // Failed to create Admin SD
    return FALSE;
  }

  if ( !AdminSD.SetSecurityInfoOnFiles( strAdminScripts.QueryStr(), FALSE ) )
  {
    // Failed to set ACL on this resource
    return FALSE;
  }

  return TRUE;
}

// SetAppropriateFileAcls
//
// To tighten security, set some ACL's in strategic places
// where we install files.
//
// We set the following ACL's on the web root, and 
// custom error root
//   IUSR_MACHINE: Deny Write and Delete
//   IIS_WPG: Allow Read
//   Administrators: Allow Full
//   Local System: Allow Full
//   Users: Allow Read
//
BOOL 
CWebServiceInstallComponent::SetAppropriateFileAcls()
{
  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetAppropriateFileAcls\n")));

  return SetAppropriateFileAclsforDrive( _T('*') );
}

// SetAppropriateFileAclsforDrive
//
// Set the appropriate File Acl's, but only for the drive
// specified
//
// Parameters:
//   cDriveLetter - The drive letter to be acl'd, send in '*'
//                  for all drives
//
BOOL 
CWebServiceInstallComponent::SetAppropriateFileAclsforDrive( WCHAR cDriveLetter)
{
  BOOL      bWWWRootIsAclable;
  BOOL      bCustomErrorsAreAclable;
  TSTR_PATH strCustomErrorPath;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetAppropriateFileAclsforDrive\n")));

  if ( !strCustomErrorPath.RetrieveWindowsDir() ||
       !strCustomErrorPath.PathAppend( PATH_WWW_CUSTOMERRORS )
     )
  {
    // Could not create CustomError Path
    return FALSE;
  }

  if ( !CSecurityDescriptor::DoesFileSystemSupportACLs( 
                                  g_pTheApp->m_csPathWWWRoot.GetBuffer(0),
                                  &bWWWRootIsAclable ) ||
       !CSecurityDescriptor::DoesFileSystemSupportACLs( 
                                  strCustomErrorPath.QueryStr(),
                                  &bCustomErrorsAreAclable ) )
  {
    // Could not check FS if they were aclable
    return FALSE;
  }

  // Acl everything needed for systemdrive
  if ( ( cDriveLetter == _T('*') ) ||
       ( tolower( cDriveLetter ) == tolower( *( strCustomErrorPath.QueryStr() ) ) ) )
  {
    if ( bCustomErrorsAreAclable &&
        !SetWWWRootAclonDir( strCustomErrorPath.QueryStr(), FALSE ) )
    {
      // Failed to set ACL
      return FALSE;
    }

    if ( !SetPassportAcls( TRUE ) )
    {
      // Failed to set ACL
      return FALSE;
    }

    if ( !SetIISTemporaryDirAcls( TRUE ) )
    {
      // Failed to set Acl on IIS Temporary Dirs
      return FALSE;
    }

    if ( !SetAdminScriptsAcl() )
    {
      // Failed to set ACL for AdminScripts directory
      return FALSE;
    }
  }

  // Acl everything in inetpub
  if ( ( cDriveLetter == _T('*') ) ||
       ( tolower( cDriveLetter ) == tolower( *( g_pTheApp->m_csPathWWWRoot.GetBuffer(0) ) ) ) )
  {
    if ( bWWWRootIsAclable &&
        !SetWWWRootAclonDir( g_pTheApp->m_csPathWWWRoot.GetBuffer(0), TRUE ) )
    {
      // Failed to set ACL
      return FALSE;
    }
  }

  return TRUE;
}

// SetIISTemporaryDirAcls
//
// Set the ACL's on the IIS Temporary dirs
//
BOOL 
CWebServiceInstallComponent::SetIISTemporaryDirAcls( BOOL bAdd )
{
  BOOL                bIsAclable;
  TSTR_PATH           strCompressionDir;
  CSecurityDescriptor sdCompression;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetIISTemporaryDirAcls\n")));

  if ( !strCompressionDir.RetrieveWindowsDir() ||
       !strCompressionDir.PathAppend( PATH_TEMPORARY_COMPRESSION_FILES )
     )
  {
    // Could not create CustomError Path
    return FALSE;
  }

  if ( !CSecurityDescriptor::DoesFileSystemSupportACLs( 
                                  strCompressionDir.QueryStr(),
                                  &bIsAclable ) )
  {
    return FALSE;
  }

  if ( !bIsAclable )
  {
    // Passport dir is not aclable, so lets exit
    return TRUE;
  }

  // If directory does not exist, then create it
  if ( !IsFileExist( strCompressionDir.QueryStr() ) ) 
  {
    if ( !bAdd ) 
    {
      // Nothing to remove ACl From
      return TRUE;
    }

    if ( !CreateDirectory( strCompressionDir.QueryStr(), NULL ) )
    {
      // Failed to create passport dir
      return FALSE;
    }
  }

  if ( !sdCompression.GetSecurityInfoOnFile( strCompressionDir.QueryStr() ) )
  {
    return FALSE;
  }
  
  if ( bAdd )
  {
    if ( !sdCompression.AddAccessAcebyName( _T("IIS_WPG"), 
                                         CSecurityDescriptor::ACCESS_FULL,
                                         TRUE, 
                                         TRUE )
       )
    {
      return FALSE;
    }
  }
  else
  {
    if ( !sdCompression.RemoveAccessAcebyName( _T("IIS_WPG") ) )
    {
      return FALSE;
    }
  }

  if ( !sdCompression.SetSecurityInfoOnFile( strCompressionDir.QueryStr(), FALSE ) )
  {
    // Failed to set ACL
    return FALSE;
  }

  return TRUE;
}

// SetAspTemporaryDirAcl
//
// Set the ACL's on the ASP Temporary dirs
//
BOOL 
CWebServiceInstallComponent::SetAspTemporaryDirAcl( BOOL bAdd )
{
  BOOL                bIsAclable;
  TSTR_PATH           strASPDir;
  CSecurityDescriptor sdASP;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetAspTemporaryDirAcl\n")));

  if ( !strASPDir.RetrieveSystemDir() ||
       !strASPDir.PathAppend( PATH_TEMPORARY_ASP_FILES )
     )
  {
    // Could not create CustomError Path
    return FALSE;
  }

  if ( !CSecurityDescriptor::DoesFileSystemSupportACLs( 
                                  strASPDir.QueryStr(),
                                  &bIsAclable ) )
  {
    return FALSE;
  }

  if ( !bIsAclable )
  {
    // Passport dir is not aclable, so lets exit
    return TRUE;
  }

  // If directory does not exist, then create it
  if ( !IsFileExist( strASPDir.QueryStr() ) ) 
  {
    if ( !bAdd ) 
    {
      // Nothing to remove ACL From
      return TRUE;
    }

    if ( !CreateDirectory( strASPDir.QueryStr(), NULL ) )
    {
      // Failed to create ASP Temporary Dir
      return FALSE;
    }
  }

  if ( bAdd )
  {
    if ( !sdASP.AddAccessAcebyName( _T("IIS_WPG"), 
                                    CSecurityDescriptor::ACCESS_FULL,
                                    TRUE, 
                                    TRUE ) ||
         !sdASP.AddAccessAcebyWellKnownID( CSecurityDescriptor::GROUP_ADMINISTRATORS, 
                                            CSecurityDescriptor::ACCESS_FULL, 
                                            TRUE, 
                                            TRUE ) ||
         !sdASP.AddAccessAcebyWellKnownID( CSecurityDescriptor::USER_LOCALSYSTEM, 
                                            CSecurityDescriptor::ACCESS_FULL, 
                                            TRUE, 
                                            TRUE )
       )
    {
      // Could not create appropriate ACL
      return FALSE;
    }
  }
  else
  {
    if ( !sdASP.GetSecurityInfoOnFile( strASPDir.QueryStr() ) ||
         !sdASP.RemoveAccessAcebyName( _T("IIS_WPG") ) )
    {
      return FALSE;
    }
  }

  if ( !sdASP.SetSecurityInfoOnFile( strASPDir.QueryStr(), FALSE ) )
  {
    // Failed to set ACL
    return FALSE;
  }

  return TRUE;
}

// RemoveOurAcls
//
// Remove IIS's Acls from a resource.  This is so that when
// we delete the accounts, the bad sid's are not left around
//
BOOL 
CWebServiceInstallComponent::RemoveOurAcls( LPTSTR szPhysicalPath)
{
  BOOL                bIsAclable;
  CSecurityDescriptor sd;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling RemoveOurAcls\n")));

  if ( !CSecurityDescriptor::DoesFileSystemSupportACLs( 
                                  szPhysicalPath,
                                  &bIsAclable ) )
  {
    // Failed to check if it was aclable
    return FALSE;
  }

  if ( !bIsAclable )
  {
    // No acling was needed
    return TRUE;
  }

  if ( !sd.GetSecurityInfoOnFile( szPhysicalPath ) ||
       !sd.RemoveAccessAcebyName( g_pTheApp->m_csGuestName.GetBuffer(0), TRUE ) ||
       !sd.RemoveAccessAcebyName( _T("IIS_WPG"), TRUE ) ||
       !sd.SetSecurityInfoOnFile( szPhysicalPath, FALSE ) )
  {
    // Failed to remove our acl's
    return FALSE;
  }

  return TRUE;
}

// RemoveAppropriateFileAcls
//
// During install, we explicity set the ACLs for a couple of locations,
// including the \inetpub\wwwroot and the custom errors pages.  For uninstall
// we will not remove all the ACL's, since someone might still have
// valuable information in those directories.  What we will do, is we will
// remove the ACL's that will not mean anything after we are uninstalled.  Like
// the IUSR_ and IIS_WPG since.  Since those users are being removed later in setup,
// we must delete the ACL's now.
//
BOOL 
CWebServiceInstallComponent::RemoveAppropriateFileAcls()
{
  TSTR                strCustomErrorPath;
  BOOL                bRet = TRUE;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling RemoveAppropriateFileAcls\n")));

  if ( !strCustomErrorPath.Copy( g_pTheApp->m_csWinDir ) ||
       !strCustomErrorPath.Append( PATH_WWW_CUSTOMERRORS )
     )
  {
    // Could not create CustomError Path
    return FALSE;
  }

  if ( !RemoveOurAcls( g_pTheApp->m_csPathWWWRoot.GetBuffer(0) ) )
  {
    bRet = FALSE;
  }

  if ( !RemoveOurAcls( strCustomErrorPath.QueryStr() ) )
  {
    bRet = FALSE;
  }

  if ( !SetPassportAcls( FALSE ) )
  {
    // Failed to set ACL
    bRet = FALSE;
  }

  if ( !SetIISTemporaryDirAcls( FALSE ) )
  {
    // Failed to set Acl on IIS Temporary Dirs
    bRet =  FALSE;
  }

  if ( !SetAspTemporaryDirAcl( FALSE ) )
  {
    // Failed to remove acl for ASP Temp Dir
    bRet = FALSE;
  }

  return bRet;
}

// SetApplicationDependencies
//
// Set the Application Dependencies as they are defined in the 
// unattend file.  We take the dependencies from the inf, and 
// put them in the metabase
//
BOOL 
CWebServiceInstallComponent::SetApplicationDependencies()
{
  CApplicationDependencies AppDep;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetApplicationDependencies\n")));

  // Load current settings
  if ( !AppDep.InitMetabase() ||
       !AppDep.LoadCurrentSettings() )
  {
    return FALSE;
  }

  // Load Unattend Values
  if ( AppDep.DoUnattendSettingsExist() )
  {
    if ( !AppDep.AddUnattendSettings() )
    {
      // Failed to add unattend settings
      return FALSE;
    }
  }

  if ( !AppDep.AddDefaults() )
  {
    // Failed to add defaults
    return FALSE;
  }

  return AppDep.SaveSettings();
}

// SetRestrictionList
//
// Set the restriction list for the extensions and CGIs.
//
// This will:
//   - Load current RestrictionList
//   - Incorporate old values (IsapiRestrictionList and CgiRestrictionList)
//   - Load unattend values
//   - Add defaults
//   - Save them to metabase
//
// Return Values:
//   TRUE  - Successfully loaded and written
//   FALSE - Failure
//
BOOL 
CWebServiceInstallComponent::SetRestrictionList()
{
  CRestrictionList RestList;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetRestrictionList\n")));

  // Load current Value
  if ( !RestList.InitMetabase() ||
       !RestList.LoadCurrentSettings() )
  {
    // Failed to load current value
    return FALSE;
  }

  if ( RestList.IsEmpty() &&
       IsUpgrade() &&
       ( GetUpgradeVersion() == 6 ) 
     )
  {
    // This is an IIS6 upgrade, so lets try to load the old format
    // Isapi and Cgi Restriction Lists
    if ( !RestList.ImportOldLists( m_mstrOldCgiRestList,
                                   m_mstrOldIsapiRestList ) )
    {
      return FALSE;
    }
  }

  // Now lets load values in unattend, if they exist
  if ( !RestList.AddUnattendSettings() )
  {
    return FALSE;
  }

  // Last, lets put in the default values if they are not already
  // present
  if ( !RestList.AddDefaults( IsUpgrade() ? TRUE : FALSE ) )
  {
    return FALSE;
  }

  // Everything is done, so lets save our new values
  return RestList.SaveSettings();
}

// LogWarningonFAT
//
// On Fat systems, just log a warning saying that we are installing on FAT,
// and that is not secure
//
BOOL 
CWebServiceInstallComponent::LogWarningonFAT()
{
  BOOL bSystemPreservesAcls;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling LogWarningonFAT\n")));

  if ( !DoesTheInstallDrivePreserveAcls( &bSystemPreservesAcls ) )
  {
    return FALSE;
  }

  if ( !bSystemPreservesAcls )
  {
    iisDebugOut((LOG_TYPE_WARN, 
                  _T("IIS is being installed on a fat volume.  This will disable IIS security features.  Please consider converting the partition from FAT to NTFS.\n") ) );
  }

  return TRUE;
}

// DisableW3SVCOnUpgrade
//
// Disable W3SVC on Upgrades
// This is determined by checking the registry entry that is set by
// the compatability wizard that runs on the Win2k side of the 
// upgrade, and also affected by the unattend setting
//
// Return Values:
//   TRUE  - Success
//   FALSE - Failure
//
BOOL 
CWebServiceInstallComponent::DisableW3SVCOnUpgrade()
{
  BOOL        bDisable = TRUE;
  BOOL        bRet = TRUE;
  CRegValue   Value;
  CRegistry   Registry;
  TSTR        strUnattendValue( MAX_PATH );

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling DisableW3SVCOnUpgrade\n")));

  if ( !Registry.OpenRegistry( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ | KEY_WRITE ) )
  {
    // Failed to open our node in registry
    return FALSE;
  }

  // Check registry entry
  if ( Registry.ReadValue( REGISTR_IISSETUP_DISABLEW3SVC, Value ) )
  {
    if ( Value.m_dwType == REG_DWORD )
    {
      // Set Disable to on or off
      bDisable = *( (LPDWORD) Value.m_buffData.QueryPtr() ) != 0;
    }

    // Delete the value, since it is no longer needed
    Registry.DeleteValue( REGISTR_IISSETUP_DISABLEW3SVC );
  }

  if ( ( g_pTheApp->m_hUnattendFile != NULL ) &&
       ( g_pTheApp->m_hUnattendFile != INVALID_HANDLE_VALUE) &&
       SetupGetLineText(  NULL,
                          g_pTheApp->m_hUnattendFile, 
                          UNATTEND_FILE_SECTION, 
                          UNATTEND_INETSERVER_DISABLEW3SVC,
                          strUnattendValue.QueryStr(),
                          strUnattendValue.QuerySize(),
                          NULL ) )
  {
    // Retrieved line from unattend, so lets compare
    if ( strUnattendValue.IsEqual( _T("true"), FALSE ) )
    {
      bDisable = TRUE;
    }
    else if ( strUnattendValue.IsEqual( _T("false"), FALSE ) )
    {
      bDisable = FALSE;
    }
    else
    {
      iisDebugOut((LOG_TYPE_ERROR, 
                   _T("Unattend setting incorrect '%s=%s'\n"), 
                   UNATTEND_INETSERVER_DISABLEW3SVC,
                   strUnattendValue.QueryStr() ) );
    }
  }

  if ( bDisable )
  {
    // Disable the W3SVC Service
    if ( InetDisableService( _T("W3SVC") ) != 0 )
    {
      iisDebugOut((LOG_TYPE_ERROR, 
                    _T("Failed to disable W3SVC\n") ) );
      bRet = FALSE;
    }

    g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_MANUAL_START_WWW;
  }

  return bRet;
}

// DisableIUSRandIWAMLogons
// 
// Disable Terminal Server Logons and RAS VPN Logons 
// for both IUSR and IWAM accounts
//
// Return 
//   TRUE - Successfully changed
//   FALSE - Not successfully changed
//
BOOL 
CWebServiceInstallComponent::DisableIUSRandIWAMLogons()
{
  DWORD       dwAllowTSLogin = FALSE;
  RAS_USER_1  RasInfo;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling DisableIUSRandIWAMLogons\n")));

  RasInfo.bfPrivilege = RASPRIV_NoCallback | RASPRIV_CallbackType; // No callback
  RasInfo.bfPrivilege = 0;        // Do not allow dialin
  _tcscpy( RasInfo.wszPhoneNumber, _T("") );

  // Disable RAS/VPN access for our users
  if ( MprAdminUserSetInfo( NULL,               // Server
                            g_pTheApp->m_csWWWAnonyName.GetBuffer(0),
                            1,                  // RAS_USER_0
                            (LPBYTE) &RasInfo ) != NO_ERROR )
  {
    return FALSE;
  }

  if ( MprAdminUserSetInfo( NULL,               // Server
                            g_pTheApp->m_csWAMAccountName.GetBuffer(0),
                            1,                  // RAS_USER_0
                            (LPBYTE) &RasInfo ) != NO_ERROR )
  {
    return FALSE;
  }

  // Disable TS access for our users
  // IUSR_ account
  if ( !WTSSetUserConfig( WTS_CURRENT_SERVER_NAME,
                          g_pTheApp->m_csWWWAnonyName.GetBuffer(0),
                          WTSUserConfigfAllowLogonTerminalServer,
                          (LPTSTR) &dwAllowTSLogin,
                          sizeof(DWORD) ) )
  {
    return FALSE;
  }

  // IWAM_ account
  if ( !WTSSetUserConfig( WTS_CURRENT_SERVER_NAME,
                          g_pTheApp->m_csWAMAccountName.GetBuffer(0),
                          WTSUserConfigfAllowLogonTerminalServer,
                          (LPTSTR) &dwAllowTSLogin,
                          sizeof(DWORD) ) )
  {
    return FALSE;
  }

  return TRUE;
}

// RunMofCompOnIISFiles
//
// Run MofComp on the IIS mofcomp files
//
BOOL
CWebServiceInstallComponent::RunMofCompOnIISFiles()
{
  HRESULT   hRes;
  TSTR_PATH strMofPath;
  DWORD     dwCurrent;
  BOOL      bRet = TRUE;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling RunMofCompOnIISFiles\n")));

  if ( m_bMofCompRun )
  {
    // We have already done this
    return TRUE;
  }

  for ( dwCurrent = 0;
        MofCompFiles[ dwCurrent ] != NULL;
        dwCurrent++ )
  {
    if ( !strMofPath.Copy( g_pTheApp->m_csPathInetsrv.GetBuffer(0) ) ||
         !strMofPath.PathAppend( MofCompFiles[ dwCurrent ] ) )
    {
      // Fatal Error
      iisDebugOut((LOG_TYPE_ERROR, 
           _T("RunMofCompOnIISFiles: Failed to construct path for '%s'\n"),
           MofCompFiles[ dwCurrent ] ) );
      return FALSE;
    }

    hRes = MofCompile( strMofPath.QueryStr() );

    if ( FAILED( hRes ) )
    {
      iisDebugOut((LOG_TYPE_ERROR, 
            _T("RunMofCompOnIISFiles: Failed to mofcomp on file '%s', hRes=0x%8x\n"),
            strMofPath.QueryStr(),
            hRes ) );
      bRet = FALSE;
    }
  }

  if ( bRet )
  {
    m_bMofCompRun = TRUE;
  }

  return bRet;
}

// CheckIfWebDavIsDisabled
//
// Check if WebDav is disabled via the IIS Lockdown tool for 
// IIS 4, 5, and 5.1
//
BOOL
CWebServiceInstallComponent::CheckIfWebDavIsDisabled()
{
  BOOL      bIsAclDisabled;
  BOOL      bIsRegistryDisabled = FALSE;
  CRegValue Value;
  CRegistry Registry;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling CheckIfWebDavIsDisabled\n")));

  if ( !IsUpgrade() ||
       ( GetUpgradeVersion() <= 3 ) ||
       ( GetUpgradeVersion() >= 6 ) )
  {
    // Since we either not upgrading, or the version is not between
    // 4 and 5.1, lets not do the test
    return TRUE;
  }

  if ( !IsWebDavDisabled( &bIsAclDisabled ) ||
       !IsWebDavDisabledViaRegistry( &bIsRegistryDisabled ) )
  {
    // Failed during check
    return FALSE;
  }

  m_bWebDavIsDisabled = bIsAclDisabled || bIsRegistryDisabled;

  return TRUE;
}

// DisabledWebDavOnUpgrade
//
// If Web DAV was disabled before the upgrade via acl's, then lets
// put that in the restriction list now
//
BOOL
CWebServiceInstallComponent::DisabledWebDavOnUpgrade()
{
  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling DisabledWebDavOnUpgrade\n")));

  if ( !m_bWebDavIsDisabled )
  {
    // Nothing needed to be done
    return TRUE;
  }

  return DisableWebDavInRestrictionList();
}

// SetServiceToManualIfNeeded
//
// Set the service to manual if specified in unattend file
//
BOOL 
CWebServiceInstallComponent::SetServiceToManualIfNeeded()
{
  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetServiceToManualIfNeeded\n")));

  if ( g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_MANUAL_START_WWW )
  {
      SetServiceStart( _T("W3SVC"), SERVICE_DEMAND_START );
  }

  return TRUE;
}

// PreInstall
//
// Do all of the work that needs to be done before we do
// all the heavy install work
//
BOOL 
CWebServiceInstallComponent::PreInstall()
{
    BOOL bRet = TRUE;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling PreInstall\n")));

    // Rename the "Web Applications" group to IIS_WPG. This group is created by IIS Lockdown tool
    if ( bRet && IsUpgrade() && ( GetUpgradeVersion() >= 4 ) )
    {
        if ( LocalGroupExists( OLD_WAM_GROUPNAME ) )
        {
            if ( !LocalGroupExists( IIS_WPG_GROUPNAME ) )
            {
                LOCALGROUP_INFO_0 Info = { const_cast<LPWSTR>( IIS_WPG_GROUPNAME ) };

                if ( ::NetLocalGroupSetInfo( NULL, OLD_WAM_GROUPNAME, 0, (BYTE*)&Info, NULL ) != NERR_Success )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("Failed to rename '%s' group to '%s'!\n"), OLD_WAM_GROUPNAME, IIS_WPG_GROUPNAME ));
                    bRet = FALSE;
                }
            }
            else
            {
                // IIS_WPG NT group should not exist at this point. If it does - move the code that creates it
                // later or do no create it if the 'Web Applications' group exist
                _ASSERT( false );
                iisDebugOut((LOG_TYPE_ERROR, _T("IIS_WPG group exists. Cannot rename 'Web Applications'!\n"), OLD_WAM_GROUPNAME, IIS_WPG_GROUPNAME ));
            }
        }
    }
 
  bRet = bRet && CheckIfWebDavIsDisabled();

  if ( bRet && IsUpgrade() )
  {
    if ( GetUpgradeVersion() == 6 )
    {
      // If it is an IIS6 upgrade, then we should load the old Cgi and Isapi Restriction
      // Lists, because the metabase no longer know anything about them
      bRet = bRet && CRestrictionList::LoadOldFormatSettings( &m_mstrOldCgiRestList,
                                                              &m_mstrOldIsapiRestList );
    }
  }

  return bRet;
}

// Install
//
// Do all of the main work need for install
//
BOOL 
CWebServiceInstallComponent::Install()
{
  BOOL bRet = TRUE;
 
  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Executing Install of WWW Component...\n")));

  bRet = bRet && SetVersionInMetabase();
  bRet = bRet && SetAppropriateFileAcls();
  /*bRet = bRet &&*/ DisableIUSRandIWAMLogons();

  // Load the Restriction List and Application Dependencies
  bRet = bRet && DisabledWebDavOnUpgrade();
  bRet = bRet && SetRestrictionList();
  bRet = bRet && SetApplicationDependencies();
  bRet = bRet && SetServiceToManualIfNeeded();
  bRet = bRet && AddInheritFlagToSSLUseDSMap();
  bRet = bRet && SetRegEntries( TRUE );
  bRet = bRet && UpdateSiteFiltersAcl();         // Set /w3svc/X/filters acl

  if ( IsUpgrade() )
  {
    //Do work for upgrades
    bRet = bRet && ProcessIISShims();              // Import IIS Shims from the AppCompat sys DB
    bRet = bRet && UpgradeRestrictedExtensions();  // Upgrade restricted ( 404.dall mapped ) extension to WebSvcExtRestrictionList

    if ( ( GetUpgradeVersion() >= 4 ) &&
         ( GetUpgradeVersion() < 6  ) )
    {
      bRet = bRet && UpgradeWAMUsers();
    }

    if ( GetUpgradeVersion() == 5 )
    {
      // Do work for Win2k Upgrades
      bRet = bRet && DisableW3SVCOnUpgrade();
    }

    if ( ( GetUpgradeVersion() >= 4 ) &&
         ( GetUpgradeVersion() <= 5 ) )
    {
      // Remove IIS Help Vdir
      bRet = bRet && RemoveHelpVdironUpgrade();
    }
  }

  if ( !g_pTheApp->m_fNTGuiMode )
  {
    // Do non GUI stuff
    bRet = bRet && RunMofCompOnIISFiles();  // If in GUI, must do at OC_CLEANUP
  }

  bRet = bRet && LogWarningonFAT();

  return bRet;
}

// Post install
// 
BOOL 
CWebServiceInstallComponent::PostInstall()
{
    BOOL bRet = TRUE;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Executing PostInstall for the WWW component...\n")));

    // Run MofComp if not already run
    bRet = bRet && RunMofCompOnIISFiles();
    bRet = bRet && InitialMetabaseBackUp( TRUE );        // Backup Metabase

    // Start the service
    if ( !g_pTheApp->m_fNTGuiMode &&
         ( g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_MANUAL_START_WWW ) == 0 )
    {
        // If it is not GUI mode, then we will try an start the service.
        // It's not fatal if we fail to start the service, but return result anyway
        INT nRes = InetStartService( _T("W3SVC") ); 

        bRet = ( (nRes == ERROR_SUCCESS) || (nRes == ERROR_SERVICE_ALREADY_RUNNING) );
    }

    return bRet;
}

// Uninstall
//
// Do all the main work to uninstall the component
//
BOOL 
CWebServiceInstallComponent::UnInstall()
{
  BOOL bRet = TRUE;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Executing UnInstall of WWW Component...\n")));

  bRet = SetRegEntries( FALSE )         && bRet;
  bRet = InitialMetabaseBackUp( FALSE ) && bRet;

  return bRet;
}

// PreUninstall
//
// Do everything that needs to be done before uninstall
//
BOOL 
CWebServiceInstallComponent::PreUnInstall()
{
  BOOL bRet = TRUE;
 
  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Executing PreUnInstall of WWW Component...\n")));

  bRet = bRet && RemoveAppropriateFileAcls();

  return bRet;
}


/*
    Locates all MD_WAM_USER_NAME values in the metabse and inserts each value ( the value is NT username )
    in the IIS_WPG NT Group
*/
BOOL CWebServiceInstallComponent::UpgradeWAMUsers()
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Upgrading WAM users...\n")));


// We support only UNICODE now. This functions is designed for UNICODE only!
#if !( defined(UNICODE) || defined(_UNICODE) )
#error UNICODE build required
#endif

    // Find all nodes that have MD_WAM_USER_NAME explicitly set
    CMDKey MBKey;
    CStringList listPaths;

    if ( FAILED( MBKey.OpenNode( METABASEPATH_WWW_ROOT ) ) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed open LM/W3SVC node\n") ));
        return FALSE;
    }
 
    if ( FAILED( MBKey.GetDataPaths( MD_WAM_USER_NAME, STRING_METADATA, /*r*/listPaths ) ) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to get data paths from LM/W3SVC node\n") ));
        return FALSE;
    }

    // Get each value
    POSITION    pos     = listPaths.GetHeadPosition();
    BOOL        bRet    = TRUE;

    while( pos != NULL )
    {
        CString     strPath = listPaths.GetNext( pos );

        CMDValue    UserName;
        BOOL        bResult = MBKey.GetData( /*r*/UserName, MD_WAM_USER_NAME, strPath.GetBuffer( 0 ) );
        
        if ( bResult )
        {
            NET_API_STATUS nRes = RegisterAccountToLocalGroup(  reinterpret_cast<LPCWSTR>( UserName.GetData() ),
                                                                IIS_WPG_GROUPNAME,
                                                                TRUE );
            bResult = ( ( nRes == NERR_Success ) || ( nRes == ERROR_MEMBER_IN_ALIAS  ) );
        }

        if ( !bResult )
        {
            // Log error but try to import the other usernames
            iisDebugOut((LOG_TYPE_ERROR, _T("Failed to transfer a WAM user from MB to IIS_WPG. Will try with next one...\n") ));
            bRet = FALSE;
        }
    };

    return bRet;
}


/*
    Get all script maps ( on each level bellow LM/W3SVC )
    For each script mapping - if there is a disabled extension - restore the mapping to the original one
    and create a disabled entry for this extension in the WebSvcExtRestrictionList 
*/
BOOL CWebServiceInstallComponent::UpgradeRestrictedExtensions()
{
    typedef std::map<std::wstring, DWORD>   TExtMap;
    typedef std::list<std::pair<std::wstring, std::wstring> >   TStrStrList;

    // This shows whether a particular ext group ( an elem of TExtToCheck ) should be upgraded
    enum GroupState
    {
        esUnknown,      // Don't know if the element should be upgraded, so it woun't be
        esUpgrade,      // Upgrade it ( move it to WebSvcExtRestrictionList
        esDontUpgrade   // No thanks
    };

    // This is the array that flags which extensions should be moved to WebSvcExtRe...
    GroupState anUpgradeExt[ TExtToCheck::ARRAY_SIZE ];

    // Create a map for the file extension that we need to check
    // The map is Extension->ExtnesionIndex
    // Where Extension is the filename extension ( ".asp" )
    // And ExtensionIndex is the array index in TExtToCheck and abUpgradeExt
    TExtMap mapExt;

    // This list holds a pair of strings. The first one is the full MB key where a script map is located
    // The second script is extension name ( ".asp" )
    // At one point of time we will change the mapping of this extension to be the default filename
    TStrStrList listKeysToUpdate;

    // Create the map with the extensions
    // By default no extensions will be upgraded ( which means - added as disabled in WebSvcExtRestrictionList )
    for ( DWORD iExtInfo = 0; iExtInfo < TExtToCheck::ARRAY_SIZE; ++iExtInfo )
    {
        anUpgradeExt[ iExtInfo ]    = esUnknown;       

        // Enter the extensions in the map
        for ( DWORD iExt = 0; iExt < sOurDefaultExtensions::MaxFileExtCount; ++iExt )
        {
            if ( TExtToCheck::Element( iExtInfo ).szExtensions[ iExt ] != NULL )
            {
                // Put this extension in the map
                TExtMap::value_type New( std::wstring( TExtToCheck::Element( iExtInfo ).szExtensions[ iExt ] ), iExtInfo );
                mapExt.insert( New );
            }
        }
    }

    // Get all paths at which the script mappings are set
    CStringList listPaths;
    CMDKey      mdKey;

    if ( FAILED( mdKey.OpenNode( METABASEPATH_WWW_ROOT ) ) ) return FALSE;
    if ( FAILED( mdKey.GetDataPaths( MD_SCRIPT_MAPS, MULTISZ_METADATA, /*r*/listPaths ) ) ) return FALSE;

    POSITION pos = listPaths.GetHeadPosition();

    // For each script map - check if every mapping in the map is mapped to 404.dll
    // and if so - whether this is an IIS extension
    while( pos != NULL )
    {
        const CString   strSubPath  = listPaths.GetNext( /*r*/pos );
        DWORD           dwType      = 0;
        DWORD           dwAttribs   = 0;
        LPCWSTR         wszSubKey   = strSubPath;
        CStringList     listMappings;        
        
        // If we fail - exit. No need to continue with other paths because we 
        // need to be sure that no mapping exist to anything different then 404.dll
        if ( FAILED( mdKey.GetMultiSzAsStringList(  MD_SCRIPT_MAPS, 
                                                    &dwType, 
                                                    &dwAttribs, 
                                                    /*r*/listMappings,
                                                    wszSubKey ) ) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Failed to get and parse ScriptMap value\n") ));
            return FALSE;
        }

        // For each mapping in the script map - get what ext is mapped to what filename
        // If it is one of our extensions ( the ones in the map ) - check the filename
        // If the filename is not 404.dll - this extension will not be modified
        POSITION posMapping = listMappings.GetHeadPosition();
        while( posMapping != NULL )
        {
            WCHAR wszFilename[ MAX_PATH ];
            CString strMapping      = listMappings.GetNext( /*r*/posMapping );
            LPCWSTR wszMapping      = strMapping;
            LPCWSTR wszFirstComma   = ::wcschr( wszMapping, L',' ) + 1;     // Will point at the first symb after the comma
            if ( NULL == wszFirstComma )
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("Invalid mapping: %s\n"),wszMapping ));
                return FALSE;
            }
            LPCWSTR wszSecondComma  = ::wcschr( wszFirstComma, L',' );  // Will point at the second comma
            if ( NULL == wszSecondComma )
            {
                // Set to point at the end of the string
                wszSecondComma = wszMapping + ::wcslen( wszMapping );
            }

            // Get the extension and the filename
            ::wcsncpy( wszFilename, wszFirstComma, min( wszSecondComma - wszFirstComma, MAX_PATH ) );
            wszFilename[ min( wszSecondComma - wszFirstComma, MAX_PATH ) ] = L'\0';
            std::wstring    strExt( wszMapping, wszFirstComma - wszMapping - 1 );   // -1 to remove the comma as well

            TExtMap::iterator it = mapExt.find( strExt );

            // If this is not an IIS extension - skip it
            if ( mapExt.end() == it ) continue;

            // Strip the path to be the filename only
            ::PathStripPath( wszFilename );

            if ( ::_wcsicmp( wszFilename, L"404.dll" ) != 0 )
            {
                // If this is not an 404.dll filename - this extension will not be upgraded
                anUpgradeExt[ it->second ] = esDontUpgrade;
            }
            else
            {
                // This is an IIS ext mapped to 404.dll. 

                // If this group upgrade flag is not esDontUpgrade - then we will upgrade the group
                if ( anUpgradeExt[ it->second ] != esDontUpgrade  )
                {
                    anUpgradeExt[ it->second ] = esUpgrade;
                
                    // We may need to upgrade this entry, so store it
                    std::wstring strKeyName( L"LM/W3SVC/" );
                    strKeyName += ( L'/' == wszSubKey[ 0 ] ) ? wszSubKey + 1 : wszSubKey;
                    listKeysToUpdate.push_back( TStrStrList::value_type( strKeyName, strExt ) );
                }
            }
        };
    };

    // Close the MB key. It is important to close it here because we will write to LM/W3SVC node
    // so we should not have open handles
    mdKey.Close();

    // Right here, in anUpgradeExt we have esUpgrade values for all WebSvcExtensions we need to upgrade
    // In listKeysToUpdate we have all the keys that contains script maps that contain
    // mappings that MAY need to be modified. So perform the upgrade now
    
    // Modify the script mappings for file extensions that will be upgraded
    for (   TStrStrList::iterator itMapping = listKeysToUpdate.begin();
            itMapping != listKeysToUpdate.end();
            ++itMapping )
    {
        // Find which element in TExtToCheck array represents this extension
        TExtMap::iterator itInfo = mapExt.find( itMapping->second.c_str() );
        // For an extension to be in listKeysToUpdate, it should've existed in mapExt. 
        // So we will always find it
        _ASSERT( itInfo != mapExt.end() );

        // If we will upgrade this extension info - then we need to modify this value
        if ( esUpgrade == anUpgradeExt[ itInfo->second ] )
        {
            // Don't fail on error - try to update as many mappings as possible
            if ( !UpdateScriptMapping( itMapping->first.c_str(), itMapping->second.c_str(), itInfo->second ) )
            {
                iisDebugOut((   LOG_TYPE_ERROR, 
                                _T("Failed to update script mapping. Ext='%s' at '%s'\n"),
                                itMapping->second.c_str(),
                                itMapping->first.c_str() ));
            }
        }
    }

    CSecConLib  Helper;
    TSTR_PATH   strFullPath( MAX_PATH );
    BOOL        bRet = TRUE;

    // Now we need to put an entry in WebSvcExtRestrictionList for all disabled ISAPI dlls
    // The ones we need to process are the ones on abUpgradeExt for which the element is TRUE
    for ( DWORD iExtInfo = 0; iExtInfo < TExtToCheck::ARRAY_SIZE; ++iExtInfo )
    {
        if ( esUpgrade == anUpgradeExt[ iExtInfo ] )
        {
            TSTR strDesc;

            // Extensions from the first array go to InetSrv dir
            // Extensions from the second array - System32
            LPCWSTR wszDir = TExtToCheck::IsIndexInFirst( iExtInfo ) ? 
                                g_pTheApp->m_csPathInetsrv.GetBuffer(0) :
                                g_pTheApp->m_csSysDir.GetBuffer(0);

            if (    !strFullPath.Copy( wszDir ) ||
                    !strFullPath.PathAppend( TExtToCheck::Element( iExtInfo ).szFileName ) ||
                    !strDesc.LoadString( TExtToCheck::Element( iExtInfo ).dwProductName ) )
            {
                // Failed to create full path, so skip to next one
                bRet = FALSE;
                iisDebugOut((LOG_TYPE_ERROR, _T("Unable to build full path for WebSvc extension. Possible OutOfMem\n") ));
                continue;
            }

            // Delete the extension first ( the SeccLib will fail to add an extension if it's alreafy there )
            HRESULT hrDel = Helper.DeleteExtensionFileRecord( strFullPath.QueryStr(), METABASEPATH_WWW_ROOT );
            if ( FAILED( hrDel ) && ( hrDel != MD_ERROR_DATA_NOT_FOUND ) )
            {
                iisDebugOut((   LOG_TYPE_WARN, 
                                _T("Failed to delete extension file '%s' in order to change it's settings\n"), 
                                strFullPath.QueryStr() ) );
                bRet = FALSE;
                continue;
            }

            if ( FAILED( Helper.AddExtensionFile(   strFullPath.QueryStr(),     // Path
                                                    false,                      // Image should be disabled
                                                    TExtToCheck::Element( iExtInfo ).szNotLocalizedGroupName,     // GroupID
                                                    TExtToCheck::Element( iExtInfo ).bUIDeletable != FALSE,       // UI deletable
                                                    strDesc.QueryStr(),         // Group description
                                                    METABASEPATH_WWW_ROOT ) ) ) // MB location
            {
                iisDebugOut((   LOG_TYPE_WARN, 
                                _T("Failed to add extension '%s' to group '%s'\n"), 
                                strFullPath.QueryStr(), 
                                TExtToCheck::Element( iExtInfo ).szNotLocalizedGroupName ));
                bRet = FALSE;
                continue;
            }
        }
    }

    return bRet;
}


/*
    This function updates the script mapping value ( MD_SCRIPT_MAP ) under the
    metabase key wszMBKey.
    The file extension wszExt will be associated with the filename specified in TExtToCheck[ iExtInfo ]
*/
BOOL CWebServiceInstallComponent::UpdateScriptMapping( LPCWSTR wszMBKey, LPCWSTR wszExt, DWORD iExtInfo )
{
    _ASSERT( wszMBKey != NULL );
    _ASSERT( ::wcsstr( wszMBKey, L"LM/W3SVC" ) != NULL );
    _ASSERT( wszExt != NULL );
    _ASSERT( iExtInfo < TExtToCheck::ARRAY_SIZE );

    CMDKey      Key;
    CStringList listMappings;
    DWORD       dwType      = 0;
    DWORD       dwAttribs   = 0;

    if ( FAILED( Key.OpenNode( wszMBKey ) ) ) return FALSE;
    if ( FAILED( Key.GetMultiSzAsStringList( MD_SCRIPT_MAPS, &dwType, &dwAttribs, /*r*/listMappings ) ) ) return FALSE;

    // Find the string that is the extension we are looking for
    POSITION pos = listMappings.GetHeadPosition();
    while( pos != NULL )
    {
        CString strMapping = listMappings.GetAt( pos );

        // The mapping must be large enough to consist of our ext, +2 symbols for the first and second commas
        // and +1 for at least one symbol for filename
        if ( static_cast<size_t>( strMapping.GetLength() ) <= ( ::wcslen( wszExt ) + 2 + 1 ) )
        {
            continue;
        }

        // Check if this is the exteniosn we are looking for
        if ( ::_wcsnicmp( wszExt, strMapping, ::wcslen( wszExt ) ) == 0 )
        {
            // Create the full path to the ISAPI that this ext should be mapped to
            TSTR_PATH   strFullPath( MAX_PATH );

            // There is a little trick here - extensions from the first array go to InetSrv dir
            // Extensions from the second array - System32
            LPCWSTR wszDir = TExtToCheck::IsIndexInFirst( iExtInfo ) ? 
                                g_pTheApp->m_csPathInetsrv.GetBuffer(0) :
                                g_pTheApp->m_csSysDir.GetBuffer(0);

            if (    !strFullPath.Copy( wszDir ) ||
                    !strFullPath.PathAppend( TExtToCheck::Element( iExtInfo ).szFileName ) )
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("Unable to build full path for WebSvc extension. Possible OutOfMem\n") ));
                return FALSE;
            }

            LPCWSTR wszMapping  = strMapping;
            LPCWSTR wszTheRest = ::wcschr( wszMapping + wcslen( wszExt ) + 1, L',' );
            _ASSERT( wszTheRest != NULL );

            // Our buffer will be the ext size, +1 comma, +Path, + the rest of it +1 for the '\0'
            std::auto_ptr<WCHAR> spMapping( new WCHAR[ ::wcslen( wszExt ) + 1 + strFullPath.QueryLen() + ::wcslen( wszTheRest ) + 1 ] );
            if ( NULL == spMapping.get() ) return FALSE;
            
            ::wcscpy( spMapping.get(), wszExt );
            ::wcscat( spMapping.get(), L"," );
            ::wcscat( spMapping.get(), strFullPath.QueryStr() );
            ::wcscat( spMapping.get(), wszTheRest );

            listMappings.SetAt( pos, CString( spMapping.get() ) );

            if ( FAILED( Key.SetMultiSzAsStringList( MD_SCRIPT_MAPS, dwType, dwAttribs, listMappings ) ) )
            {
                iisDebugOut((   LOG_TYPE_ERROR, 
                                _T("Failed to modify extension mapping ( ISAPI dll name ) for ext '%s' in '%s'\n"),
                                wszExt,
                                wszMBKey ));
            }

            // Thats it
            break;
        }

        listMappings.GetNext( /*r*/pos );
    }


    return TRUE;
}

// SetVersionInMetabase
//
// Set the version information in the metabase
//
// Return Values
//   TRUE - Successfully Set
//   FALSE - Failed to Set
//
BOOL 
CWebServiceInstallComponent::SetVersionInMetabase()
{
  CMDValue MajorVersion;
  CMDValue MinorVersion;
  CMDKey   Metabase;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling SetVersionInMetabase\n")));

  if ( !MajorVersion.SetValue( MD_SERVER_VERSION_MAJOR,
			       0,
			       DWORD_METADATA,
			       IIS_SERVER_VERSION_MAJOR ) ||
       !MinorVersion.SetValue( MD_SERVER_VERSION_MINOR,
			       0,
			       DWORD_METADATA,
			       IIS_SERVER_VERSION_MINOR ) )
    {
      // Could not create properties
      return FALSE;
    }

  if ( FAILED( Metabase.OpenNode( METABASEPATH_WWW_INFO ) ) ||
       !Metabase.SetData( MajorVersion, MD_SERVER_VERSION_MAJOR ) ||
       !Metabase.SetData( MinorVersion, MD_SERVER_VERSION_MINOR ) )
  {
    // Failed to set
    return FALSE;
  }

  return TRUE;
}

// RemoveIISHelpVdir
//
// Remove an IISHelp Vdir, if it exists
//
// Parameters
//   szMetabasePath - Metabase path of website
//   szPhysicalPath1 - One of the physical path's it could point to, to be considered valid
//   szPhysicalPath1 - The second possible physical path it could point to, to be considered valid
//
BOOL 
CWebServiceInstallComponent::RemoveIISHelpVdir( LPCTSTR szMetabasePath, LPCTSTR szPhysicalPath1, LPCTSTR szPhysicalPath2 )
{
  CMDKey     cmdKey;
  CMDValue   cmdValue;
  TSTR       strFullPath;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling RemoveIISHelpVdir\n")));

  if ( !strFullPath.Copy( szMetabasePath ) ||
       !strFullPath.Append( _T("/") ) ||
       !strFullPath.Append( METABASEPATH_UPG_IISHELP_NAME ) )
  {
    // Failed to construct Full Path
    return FALSE;
  }

  if ( SUCCEEDED( cmdKey.OpenNode( strFullPath.QueryStr() ) ) &&
       cmdKey.GetData( cmdValue, MD_VR_PATH ) && 
       ( cmdValue.GetDataType() == STRING_METADATA ) &&
       ( ( _tcsicmp( (LPTSTR) cmdValue.GetData(), szPhysicalPath1 ) == 0 ) ||
         ( _tcsicmp( (LPTSTR) cmdValue.GetData(), szPhysicalPath2 ) == 0 ) 
       )
     )
  {
    cmdKey.Close();

    // This is the correct vdir, so lets delete it
    if ( FAILED( cmdKey.OpenNode( szMetabasePath ) ) )
    {
      // Failed to open node
      return FALSE;
    }

    if ( FAILED( cmdKey.DeleteNode( METABASEPATH_UPG_IISHELP_NAME ) ) )
    {
      // Failed to remove vdir
      return FALSE;
    }
  }

  return TRUE;
}

// RemoveHelpVdironUpgrade
//
// Remove the IIS Help vdir on upgrades
//
BOOL 
CWebServiceInstallComponent::RemoveHelpVdironUpgrade()
{
  TSTR_PATH  strHelpLoc1;
  TSTR_PATH  strHelpLoc2;
  TSTR_PATH  strHelpDeleteLoc;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling RemoveHelpVdironUpgrade\n")));

  if ( !strHelpLoc1.RetrieveWindowsDir() ||
       !strHelpLoc1.PathAppend( PATH_UPG_IISHELP_1 ) ||
       !strHelpLoc2.RetrieveWindowsDir() ||
       !strHelpLoc2.PathAppend( PATH_UPG_IISHELP_2 ) ||
       !strHelpDeleteLoc.RetrieveWindowsDir() ||
       !strHelpDeleteLoc.PathAppend( PATH_IISHELP_DEL ) )
  {
    // Failed to create Path
    return FALSE;
  }

  if ( !RemoveIISHelpVdir( METABASEPATH_UPG_IISHELP_WEB1_ROOT,
                           strHelpLoc1.QueryStr(),
                           strHelpLoc2.QueryStr() ) ||
       !RemoveIISHelpVdir( METABASEPATH_UPG_IISHELP_WEB2_ROOT,
                           strHelpLoc1.QueryStr(),
                           strHelpLoc2.QueryStr() ) )
  {
    // Failed to remove VDir
    return FALSE;
  }
  
  // Now delete directory
  RecRemoveDir( strHelpDeleteLoc.QueryStr(), TRUE );

  return TRUE;
}

// CreateInitialMetabaseBackUp
//
// Create an initial backup of the metabase at the end of
// the W3SVC Instalation
//
// Parameters:
//  bAdd - TRUE == Add, 
//         FALSE == remove
//
BOOL 
CWebServiceInstallComponent::InitialMetabaseBackUp( BOOL bAdd )
{
  TSTR   strBackupName;

  if ( !strBackupName.LoadString( IDS_INITIAL_METABASE_BK_NAME ) )
  {
    // Failed to get metabase name
    return FALSE;
  }

  if ( bAdd )
  {
    return CMDKey::Backup( strBackupName.QueryStr(),         // Backup Name
                          1,                                // Version #
                          MD_BACKUP_OVERWRITE | 
                          MD_BACKUP_SAVE_FIRST | 
                          MD_BACKUP_FORCE_BACKUP );            // Overwrite if one already exists
  }

  return CMDKey::DeleteBackup( strBackupName.QueryStr(),
                               1 );
}

// CWebServiceInstallComponent::
//
// If during upgrade, this metabase setting is set, add the inherit flag to it
// The reason for this was because it was not set in Win2k days, and now
// we need it set
//
BOOL 
CWebServiceInstallComponent::AddInheritFlagToSSLUseDSMap()
{
  CMDKey   cmdKey;
  CMDValue cmdValue;

  if ( FAILED( cmdKey.OpenNode( METABASEPATH_WWW_ROOT ) ) )
  {
    // Failed to open metabase
    return FALSE;
  }

  if ( cmdKey.GetData( cmdValue, MD_SSL_USE_DS_MAPPER ) && 
       ( cmdValue.GetDataType() == DWORD_METADATA ) )
  {
    // If this value is present, then set with inheritance
    cmdValue.SetAttributes( METADATA_INHERIT );

    if ( !cmdKey.SetData( cmdValue, MD_SSL_USE_DS_MAPPER ) )
    {
      return FALSE;
    }
  }

  return TRUE;
}

// SetRegEntries
//
// Set the appropriate registry entries
//
// Parameters:
//   bAdd - [in] TRUE == Add; FALSE == Remove
//
BOOL 
CWebServiceInstallComponent::SetRegEntries( BOOL bAdd )
{
  CRegistry Registry;

  if ( !Registry.OpenRegistry( HKEY_LOCAL_MACHINE, 
                               REG_HTTPSYS_PARAM,
                               KEY_WRITE ) )
  {
    // Failed to open registry Key
    return FALSE;
  }

  if ( bAdd ) 
  {
    CRegValue Value;

    if ( !Value.SetDword( 1 ) ||
         !Registry.SetValue( REG_HTTPSYS_DISABLESERVERHEADER, Value ) )
    {
      // Failed to set
      return FALSE;
    }
  }
  else
  {
    Registry.DeleteValue( REG_HTTPSYS_DISABLESERVERHEADER );
  }

  return TRUE;
}

// function: UpdateSiteFiltersAcl
//
// Update all the SiteFilter's Acl's with the new ACL
//
// Return Value:
//   TRUE - Success change
//   FALSE - Failure changing
BOOL 
CWebServiceInstallComponent::UpdateSiteFiltersAcl()
{
  CMDKey   cmdKey;
  CMDValue cmdValue;
  CMDValue cmdIISFiltersValue;
  WCHAR    szSubNode[METADATA_MAX_NAME_LEN];
  TSTR     strFilterKey;
  DWORD    i = 0;

  iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Calling UpdateSiteFiltersAcl\n")));

  if ( !RetrieveFiltersAcl( &cmdValue ) )
  {
    // There is no acl to set, so lets exit
    return TRUE;
  }

  if ( FAILED( cmdKey.OpenNode( METABASEPATH_WWW_ROOT ) ) ||
       !cmdIISFiltersValue.SetValue( MD_KEY_TYPE,      // ID
                                     0,                // Attributes
                                     IIS_MD_UT_SERVER, // UserType
                                     STRING_METADATA,  // DataType
                                     ( _tcslen( KEYTYPE_FILTERS ) + 1 ) * sizeof(TCHAR),
                                     KEYTYPE_FILTERS ) ) // Value
  {
    // Failed to open filters node
    return FALSE;
  }

  while ( cmdKey.EnumKeys( szSubNode, i++ ) )
  {
    if ( !IsNumber( szSubNode ) )
    {
      // Since it is not a number, it is not a website, so lets skip
      continue;
    }

    if ( !strFilterKey.Copy( szSubNode ) ||
         !strFilterKey.Append( METABASEPATH_FILTER_PATH ) )
    {
      return FALSE;  
    }

    // Add the filters node if not already there
    cmdKey.AddNode( strFilterKey.QueryStr() );
    
    if ( !cmdKey.SetData( cmdIISFiltersValue, MD_KEY_TYPE, strFilterKey.QueryStr() ) || 
         !cmdKey.SetData( cmdValue, MD_ADMIN_ACL, strFilterKey.QueryStr() ) )
    {
      // Failed to set ACL
      return FALSE;
    }
  }

  return TRUE;
}

// function: RetrieveFiltersAcl
//
// Retrieve the Filters ACL to use
//
BOOL 
CWebServiceInstallComponent::RetrieveFiltersAcl(CMDValue *pcmdValue)
{
  CMDKey cmdKey;

  if ( FAILED( cmdKey.OpenNode( METABASEPATH_FILTER_GLOBAL_ROOT ) ) )
  {
    // Failed to open filters node
    return FALSE;
  }

  // Don't inherit acl, but do retrieve if it should be inheritted
  pcmdValue->SetAttributes( METADATA_ISINHERITED );

  if ( !cmdKey.GetData( *pcmdValue, MD_ADMIN_ACL ) )
  {
    // Failed to retrieve value
    return FALSE;
  }

  return TRUE;
}

// function: IsNumber
//
// Determine if the string is a number
//
BOOL 
CWebServiceInstallComponent::IsNumber( LPWSTR szString )
{
  while ( *szString )
  {
    if ( ( *szString < '0' ) ||
         ( *szString > '9' ) )
    {
      return FALSE;
    }

    szString++;
  }

  return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\wolfpack.h ===
#include "stdafx.h"
#include <resapi.h>

INT DoesClusterServiceExist(void);
#ifndef _CHICAGO_
    void  Upgrade_WolfPack();
    DWORD BringALLIISClusterResourcesOffline();
    DWORD BringALLIISClusterResourcesOnline();
    INT   DoClusterServiceCheck(CLUSTER_SVC_INFO_FILL_STRUCT * MyStructOfInfo);
    BOOL  RegisterIisServerInstanceResourceType(LPWSTR pszResType,LPWSTR pszResTypeDisplayName,LPWSTR pszPath,LPWSTR pszAdminPath);
    BOOL  UnregisterIisServerInstanceResourceType(LPWSTR pszResType,LPWSTR pszAdminPath,BOOL bGrabVRootFromResourceAndAddToIISVRoot,BOOL bDeleteAfterMove);
#endif //_CHICAGO_
void   MoveVRootToIIS3Registry( CString strRegPath, CStringArray &strArryOfVrootNames, CStringArray &strArryOfVrootData);
DWORD  IsResourceThisTypeOfService(HRESOURCE hResource, LPWSTR pszTheServiceType);
INT    GetClusterResName(HRESOURCE hResource, CString * csReturnedName);
DWORD WINAPI DoesThisServiceTypeExistInCluster(PVOID pInfo);
int    GetClusterIISVRoot(HRESOURCE hResource, LPWSTR pszTheServiceType, CStringArray &strArryOfVrootNames, CStringArray &strArryOfVrootData);
LPWSTR GetParameter(IN HKEY ClusterKey,IN LPCWSTR ValueName);
int    CheckForIISDependentClusters(HRESOURCE hResource);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\strfn.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        strfrn.h

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)
        Munged for setup by BoydM

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _STRFN_H
#define _STRFN_H


//
// Memory Allocation Macros
//
#define AllocMem(cbSize)\
    ::LocalAlloc(LPTR, cbSize)

#define FreeMem(lp)\
    ::LocalFree(lp)

#define AllocMemByType(citems, type)\
    (type *)AllocMem(citems * sizeof(type))


//
// Debug Formatting Macros
//
   #define TRACEOUT(x)        { ; }
   #define TRACEEOL(x)        { ; }
   #define TRACEEOLID(x)      { ; }
   #define TRACEEOLERR(err,x) { ; }


//
// Helper Macros
//

//
// Get number of array elements
//
#define ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))

//
// Compute size of string array in characters.  That is, don't count
// the terminal null.
//
#define STRSIZE(str)     (ARRAY_SIZE(str)-1)

#define AllocTString(cch)\
    (LPTSTR)AllocMem((cch) * sizeof(TCHAR))
#define AllocWString(cch)\
    (LPWSTR)AllocMem((cch) * sizeof(WCHAR))

#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))

//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

//
// Convert CR/LF to LF
//
BOOL 
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    );

//
// Expand LF to CR/LF (no allocation necessary)
//
BOOL 
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    );

//
// Straight copy
//
BOOL
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    );

LPWSTR
AllocWideString(
    IN LPCTSTR lpString
    );

LPSTR AllocAnsiString(
    IN LPCTSTR lpString
    );


LPTSTR AllocString(
    IN LPCTSTR lpString
    );

#ifdef UNICODE

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Reference a T String as a W String (a nop in Unicode)
    //
    #define TWSTRREF(str)   ((LPWSTR)str)

#else

    //
    // Convert a T String to a temporary W Buffer, and
    // return a pointer to this internal buffer
    //
    LPWSTR ReferenceAsWideString(LPCTSTR str);

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cch, NULL, NULL)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, dst, cch)

    //
    // Reference a T String as a W String 
    //
    #define TWSTRREF(str)   ReferenceAsWideString(str)

#endif // UNICODE

//
// Determine if the given string is a UNC name
//
BOOL IsUNCName(
    IN const CString & strDirPath
    );

//
// Determine if the path is a fully qualified path in the context
// of the local machine
//
BOOL IsFullyQualifiedPath(
    IN const CString & strDirPath
    );

//
// Determine if the given string is an URL path
//
BOOL IsURLName(
    IN const CString & strDirPath
    );

//
// Determine if the given string describes a relative URL path
//
inline BOOL IsRelURLPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT(lpPath != NULL);
    return *lpPath == _T('/');
}

//
// Determine if the given path describes a wild-carded redirection
// path (starts with *;)
//
inline BOOL IsWildcardedRedirectPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT(lpPath != NULL);
    return lpPath[0] == '*' && lpPath[1] == ';';
}

//
// Determine if the account is local (doesn't have a computer name)
//
inline BOOL MyIsLocalAccount(
    IN CString & strAccount
    )
{
    return strAccount.Find(_T('\\')) == -1;
}

//
// Convert local path to UNC path
//
LPCTSTR MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    );

//
// Given domain\username, split into user name and domain
//
BOOL SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    );

//
// Convert double-null terminated string to a CStringList
//
DWORD
ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars = -1
    );

DWORD
ConvertWDoubleNullListToStringList(
    IN  PWCHAR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars = -1
    );

//
// Go from a CStringList to a WIDE double null terminated list
//
DWORD
ConvertStringListToWDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT PWCHAR & lpstrDest
    );

//
// Go from a CStringList to a double null terminated list
//
DWORD
ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    );


//
// Convert separated list of strings to CStringList
//
int
ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    );

//
// Reverse function of the above
//
LPCTSTR
ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    );

//
// Private strtok
//
LPTSTR 
StringTok(
    IN LPTSTR string,
    IN LPCTSTR control
    );

//
// CString.Find() that's not case-sensitive
//
int 
CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    );

//
// Replace the first occurrance of one string
// inside another one.  Return error code
//
DWORD
ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    );


class CStringListEx : public CStringList
/*++

Class Description:

    Superclass of CStringList with comparison and assignment
    operators.

Public Interface:

    operator ==       Comparison operator
    operator !=       Comparison operator
    operator =        Assignment operator  

--*/
{
//
// ctor
//
public:
    CStringListEx(int nBlockSize = 10) : CStringList(nBlockSize) {};

//
// Operators
//
public:
    BOOL operator == (const CStringList & strl);           
    BOOL operator != (const CStringList & strl) { return !operator ==(strl); }
    CStringListEx & operator =(const CStringList & strl);
};


#ifdef _DOS

typedef struct tagINTLFORMAT
{
    WORD wDateFormat;
    CHAR szCurrencySymbol[5];
    CHAR szThousandSep[2];
    CHAR szDecimalPoint[2];
    CHAR szDateSep[2];
    CHAR szTimeSep[2];
    BYTE bCurrencyFormat;
    BYTE bCurrencyDecimals;
    BYTE bTimeFormat;
    DWORD dwMapCall;
    CHAR szDataSep[2];
    BYTE bReserved[5];
} INTLFORMAT;

BOOL _dos_getintlsettings(INTLFORMAT * pStruct);

#endif // _DOS



class CINumber
/*++

Class Description:

    Base class for international-friendly number formatting

Public Interface:

NOTES: Consider making this class a template

--*/
{
public:
    static BOOL Initialize(BOOL fUserSetting = TRUE);
    static CString * s_pstrBadNumber;
    static BOOL UseSystemDefault();
    static BOOL UseUserDefault();
    static BOOL IsInitialized();
    static LPCTSTR QueryThousandSeperator();
    static LPCTSTR QueryDecimalPoint();
    static LPCTSTR QueryCurrency();
    static double BuildFloat(const LONG lInteger, const LONG lFraction);
    static LPCTSTR ConvertLongToString(const LONG lSrc, CString & str);
    static LPCTSTR ConvertFloatToString(
        IN const double flSrc, 
        IN int nPrecision, 
        OUT CString & str
        );

    static BOOL ConvertStringToLong(LPCTSTR lpsrc, LONG & lValue);
    static BOOL ConvertStringToFloat(LPCTSTR lpsrc, double & flValue);

protected:
    CINumber();
    ~CINumber();

protected:
    friend BOOL InitIntlSettings();
    friend void TerminateIntlSettings();
    static BOOL Allocate();
    static void DeAllocate();
    static BOOL IsAllocated();

protected:
    static CString * s_pstr;

private:
    static CString * s_pstrThousandSeperator;
    static CString * s_pstrDecimalPoint;
    static CString * s_pstrCurrency;
    static BOOL s_fCurrencyPrefix;
    static BOOL s_fInitialized;
    static BOOL s_fAllocated;
};



class CILong : public CINumber
/*++

Class Description:

    International-friendly LONG number

Public Interface:


--*/
{
public:
    //
    // Constructors
    //
    CILong();
    CILong(LONG lValue);
    CILong(LPCTSTR lpszValue);

public:
    //
    // Assignment Operators
    //
    CILong & operator =(LONG lValue);
    CILong & operator =(LPCTSTR lpszValue);

    //
    // Shorthand Operators
    //
    CILong & operator +=(const LONG lValue);
    CILong & operator +=(const LPCTSTR lpszValue);
    CILong & operator +=(const CILong& value);
    CILong & operator -=(const LONG lValue);
    CILong & operator -=(const LPCTSTR lpszValue);
    CILong & operator -=(const CILong& value);
    CILong & operator *=(const LONG lValue);
    CILong & operator *=(const LPCTSTR lpszValue);
    CILong & operator *=(const CILong& value);
    CILong & operator /=(const LONG lValue);
    CILong & operator /=(const LPCTSTR lpszValue);
    CILong & operator /=(const CILong& value);

    //
    // Comparison operators
    //
    BOOL operator ==(LONG value);
    BOOL operator !=(CILong& value);

    //
    // Conversion operators
    //
    operator const LONG() const;
    operator LPCTSTR() const;

    inline friend CArchive & AFXAPI operator<<(CArchive & ar, CILong & value)
    {
        return (ar << value.m_lValue);
    }

    inline friend CArchive & AFXAPI operator>>(CArchive & ar, CILong & value)
    {
        return (ar >> value.m_lValue);
    }

#ifdef _DEBUG
    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext & AFXAPI operator<<(
        CDumpContext& dc, 
        const CILong& value
        )
    {
        return (dc << value.m_lValue);
    }

#endif // _DEBUG

protected:
    LONG m_lValue;
};



class CIFloat : public CINumber
/*++

Class Description:

    International-friendly floating point number    

Public Interface:

--*/
{
public:
    //
    // Constructors
    //
    CIFloat(int nPrecision = 2);
    CIFloat(double flValue, int nPrecision = 2);
    CIFloat(LONG lInteger, LONG lFraction, int nPrecision = 2);
    CIFloat(LPCTSTR lpszValue, int nPrecision = 2);

public:
    //
    // Precision functions
    //
    int QueryPrecision() const;
    void SetPrecision(int nPrecision);

    //
    // Assignment Operators
    //
    CIFloat & operator =(double flValue);
    CIFloat & operator =(LPCTSTR lpszValue);

    //
    // Shorthand Operators
    //
    CIFloat & operator +=(const double flValue);
    CIFloat & operator +=(const LPCTSTR lpszValue);
    CIFloat & operator +=(const CIFloat& value);
    CIFloat & operator -=(const double flValue);
    CIFloat & operator -=(const LPCTSTR lpszValue);
    CIFloat & operator -=(const CIFloat& value);
    CIFloat & operator *=(const double flValue);
    CIFloat & operator *=(const LPCTSTR lpszValue);
    CIFloat & operator *=(const CIFloat& value);
    CIFloat & operator /=(const double flValue);
    CIFloat & operator /=(const LPCTSTR lpszValue);
    CIFloat & operator /=(const CIFloat& value);

    //
    // Conversion operators
    //
    operator const double() const;
    operator LPCTSTR() const;

    //
    // Persistence Operators
    //
    inline friend CArchive& AFXAPI operator<<(CArchive& ar, CIFloat& value)
    {
        return (ar << value.m_flValue);
    }

    inline friend CArchive& AFXAPI operator>>(CArchive& ar, CIFloat& value)
    {
        return (ar >> value.m_flValue);
    }

#ifdef _DEBUG

    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext& AFXAPI operator<<(
        CDumpContext& dc, 
        const CIFloat& value
        )
    {
        return (dc << value.m_flValue);
    }

#endif // _DEBUG

protected:
    double m_flValue;
    int m_nPrecision;
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline /* static */ BOOL CINumber::UseSystemDefault()
{
    return Initialize(FALSE);
}

inline /* static */ BOOL CINumber::UseUserDefault()
{
    return Initialize(TRUE);
}

inline /* static */ BOOL CINumber::IsInitialized()
{
    return s_fInitialized;
}

inline /* static */ LPCTSTR CINumber::QueryThousandSeperator()
{
    return (LPCTSTR)*s_pstrThousandSeperator;
}

inline /* static */ LPCTSTR CINumber::QueryDecimalPoint()
{
    return (LPCTSTR)*s_pstrDecimalPoint;
}

inline /* static */ LPCTSTR CINumber::QueryCurrency()
{
    return (LPCTSTR)*s_pstrCurrency;
}

inline /* static */ BOOL CINumber::IsAllocated()
{
    return s_fAllocated;
}

inline BOOL CILong::operator ==(LONG value)
{
    return m_lValue == value;
}

inline BOOL CILong::operator !=(CILong& value)
{
    return m_lValue != value.m_lValue;
}

inline CILong::operator const LONG() const
{
    return m_lValue;
}

inline CILong::operator LPCTSTR() const
{
    return CINumber::ConvertLongToString(m_lValue, *CINumber::s_pstr);
}

inline int CIFloat::QueryPrecision() const
{
    return m_nPrecision;
}

inline void CIFloat::SetPrecision(int nPrecision)
{
    m_nPrecision = nPrecision;
}

inline CIFloat::operator const double() const
{
    return m_flValue;
}

inline CIFloat::operator LPCTSTR() const
{
    return CINumber::ConvertFloatToString(
        m_flValue, 
        m_nPrecision, 
        *CINumber::s_pstr
        );
}

#endif // _STRFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\tstr.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        tstr.cxx

   Abstract:

        Class that is used for string manipulation

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       January 2002: Created

--*/

#include "stdafx.h"

// Constructor
//
TSTR::TSTR()
  : m_bSensitiveData( FALSE )
{
  Copy( _T("\0") );
}

// Constructor
//
// Allows you to construct the buffer, of a certain size.
// This is really just a suggestion, since on failure we have
// no way to alert the user.  It is okay though, since subsequest
// copies and appends will fail if it can not resize
//
// Parameters:
//   dwInitialSize - Initial size for the buffer (in chars)
//
TSTR::TSTR(DWORD dwInitialSize)
  : m_bSensitiveData( FALSE )
{
  Copy( _T("\0") );

  // Ignore return value, since if we don't resize, it is okay,
  // subsequent calls will fail in that case
  Resize( dwInitialSize );
}

// Destructor
//
TSTR::~TSTR()
{
  if ( m_bSensitiveData )
  {
    // Clear old contents
    SecureZeroMemory( m_buff.QueryPtr(), m_buff.QuerySize() );
  }
}

// MarkSensitiveData
//
// Marks this information as sensitive data.  What this does is it
// makes sure than when we delete it, SecureZeroMemory is used
// to delete the old contents.  It does not save us from the
// Resize functions, but we will worry about that later.
//
// Parameters:
//   bIsSensitive - Is the data sensitive or not?
//
void 
TSTR::MarkSensitiveData( BOOL bIsSensitive )
{
  if ( !m_bSensitiveData )
  {
    // We will allow the use to go from unsensitive to sensitive, but
    // not to go back, since what was there before might be sensitive
    m_bSensitiveData = bIsSensitive;
  }
}

// function: Resize
//
// resize the string to the size needed
//
// Parameters:
//   dwChars - The size in characters, including the terminating NULL
BOOL
TSTR::Resize(DWORD dwChars)
{
  if ( dwChars <= QuerySize() )
  {
    // No resize needed
    return TRUE;
  }

  if ( !m_bSensitiveData )
  {
    // If this is not sensitive data, this is an easy operation
    return m_buff.Resize( dwChars * sizeof(TCHAR) );
  }

  // Since this is sensitive data, we must make sure that during the resize,
  // data is not left in memory somewhere
  TSTR strTemp;
  BOOL bRet;

  if ( !strTemp.Copy( QueryStr() ) )
  {
    // Could not copy into temp for buffer
    return FALSE;
  }

  strTemp.MarkSensitiveData( TRUE );

  // Clear old contents before resizing and possibly losing old pointer with data
  SecureZeroMemory( m_buff.QueryPtr(), m_buff.QuerySize() );
  bRet = m_buff.Resize( dwChars * sizeof(TCHAR) );

  // This can not fail, since the buffer could not have gotten smaller
  // This call will copy only the bytes before the NULL terminator, the other
  // ones will be lost.  This is by design, it is more secure if we don't
  // copy those that aren't being used
  DBG_REQUIRE( Copy( strTemp.QueryStr() ) );
  
  return bRet;
}

// function: QueryStr 
//
// Query a pointer to the string
//
LPTSTR  
TSTR::QueryStr()
{
  return (LPTSTR) m_buff.QueryPtr();
}

// function: Copy
//
// Copy the Source string into this string itself
//
// Parameters:
//   szSource - The string to be copied
//
BOOL    
TSTR::Copy(LPCTSTR szSource)
{
  DWORD dwSize = _tcslen(szSource) + 1;
  BOOL  bRet = TRUE;

  if ( dwSize > QuerySize() )
  {
    bRet = Resize( dwSize );
  }

  if ( bRet )
  {
    _tcscpy( QueryStr(), szSource );
  }

  return bRet;
}

// function: Copy
//
// Copy the Source string into this string itself
//
// Parameters:
//   strSource - The string to be copied
//
BOOL    
TSTR::Copy(TSTR &strSource)
{
  return Copy( strSource.QueryStr() );
}

// funtion: QueryLen
//
// Query the length of the string (in chars) without the null terminator
//
DWORD
TSTR::QueryLen()
{
  return _tcslen( QueryStr() );
}

// function: QuerySize
//
// Query the size of the buffer in chars
//
DWORD 
TSTR::QuerySize()
{
  return ( m_buff.QuerySize() / sizeof( TCHAR ) );
}

// function: Append
//
// Append a string to the end of what we have
//
// Parameters:
//   szSource - The string to be appended
//
BOOL    
TSTR::Append(LPCTSTR szSource)
{
  DWORD dwCurrentLen = QueryLen();
  DWORD dwSize = _tcslen(szSource) + 1 + dwCurrentLen;

  BOOL  bRet = TRUE;

  if ( dwSize > QuerySize() )
  {
    bRet = Resize( dwSize );
  }

  if ( bRet )
  {
    _tcscpy( QueryStr() + dwCurrentLen , szSource );
  }

  return bRet;
}

// function: Append
//
// Append a string to the end of what we have
//
// Parameters:
//   strSource - The string to be appended
//
BOOL    
TSTR::Append(TSTR &strSource)
{
  return Append( strSource.QueryStr() );
}

// function: IsEqual
//
// Is the string passed in, equal to the one in the class
//
// Parameters:
//   szCompareString - The string to compare it with
//   bCaseSensitive - Is the test case sensitive
//
BOOL    
TSTR::IsEqual(LPCTSTR szCompareString, BOOL bCaseSensitive)
{
  BOOL bRet;

  if ( bCaseSensitive )
  {
    bRet = _tcscmp( QueryStr(), szCompareString ) == 0;
  }
  else
  {
    bRet = _tcsicmp( QueryStr(), szCompareString ) == 0;
  }

  return bRet;
}

// function: FindSubString
//
// Find a substring inside of a string(ie. "st" inside of "Test"
//
// Parameters:
//   szSubString - the sub string to find
//   bCaseSensitive - Is the search case sensitive?
//
// Return Values:
//   NULL - Not found.
//   pointer - pointer to substring
//
LPTSTR
TSTR::FindSubString(LPTSTR szSubString, BOOL bCaseSensitive )
{
  if ( bCaseSensitive )
  {
    // If case sensitive, then we can just call tscstr
    return _tcsstr( QueryStr(), szSubString );
  }

  LPTSTR szSubCurrent;                      // Current position in substring
  LPTSTR  szStringCurrent = QueryStr();      // Current position in full string

  while ( *szStringCurrent )
  {
    // Walk through string comparing each character in string, with the first
    // one in the sub string
    if ( ( bCaseSensitive && ( *szStringCurrent == *szSubString ) ) ||
         ( !bCaseSensitive && ( ToLower( *szStringCurrent ) == ToLower( *szSubString ) ) )
       )
    {
      // The first character matched, so lets check the rest of the sub string
      szSubCurrent = szSubString + 1;
      LPTSTR szStringTemp = szStringCurrent + 1;

      while ( ( *szSubCurrent != '\0' ) &&
              ( *szStringTemp != '\0' ) &&
              ( bCaseSensitive || ( ToLower( *szStringTemp ) == ToLower( *szSubCurrent ) ) ) &&
              ( !bCaseSensitive || ( *szStringTemp == *szSubCurrent ) )
            )
      {
        szStringTemp++;
        szSubCurrent++;
      }

      if ( *szSubCurrent == '\0' )
      {
        // We found a match, so return the pointer to this substring in the main string
        return szStringCurrent;
      }
    }

    // Increment pointer in string
    szStringCurrent++;
  }

  return NULL;
}

// function: ToLower
//
// Get the lower case of a character
//
// Parameters:
//   cChar - The character to make lower
//
// Return Values
//   Either the character that was sent in, or its lower value if possible
//
TCHAR 
TSTR::ToLower(TCHAR cChar)
{
#ifdef UNICODE
  if ( iswupper( cChar ) )
  {
    return towlower( cChar );
  }
  else
  {
    return cChar;
  }
#else
  return (TCHAR) tolower( cChar );
#endif
}

// function: SubStringExists
//
// Does a substring exist inside a string (ie. "st" inside of "test"
//
// Parameters:
//   szSubString - the sub string to find
//   bCaseSensitive - Is the search case sensitive?
//
// Return Values:
//   TRUE - Found
//   FALSE - Not found
BOOL 
TSTR::SubStringExists(LPTSTR szCompareString, BOOL bCaseSensitive )
{
  return ( FindSubString( szCompareString, bCaseSensitive ) != NULL );
}

// function: Format
//
// format a string, same exact functionality as snprintf
//
// Parameters:
//   szFormat - The format for the string
//   ... - The options parameters to snprintf
//
// Return Value
//   TRUE - Successfully copied
//   FALSE - Error, probly couldn't get memory
//
BOOL 
TSTR::Format(LPTSTR szFormat ... )
{
  DWORD   dwTryCount = 0;
  va_list va;
  INT     iRet;

  // Initialize the variable length arguments
  va_start(va, szFormat);

  do {
    iRet = _vsntprintf( QueryStr(), QuerySize(), szFormat, va);

    if ( iRet > 0 )
    {
      // Successfully written to string
      if ( ( (DWORD) iRet ) == QuerySize() )
      {
        // Lets null terminate just to be sure
        *( QueryStr() + iRet - 1 ) = _T( '\0' );
      }

      va_end(va);
      return TRUE;
    }

    dwTryCount++;
  } while ( ( dwTryCount < TSTR_SNPRINTF_RESIZER_TRIES ) && 
            ( Resize( QuerySize() * 2 + TSTR_SNPRINTF_RESIZER_SIZE ) ) 
           );

  // Uninitialize the arguments
  va_end(va);

  // We fail
  return FALSE;
}

// LoadString
//
// Load a string into our class
//
BOOL 
TSTR::LoadString( UINT uResourceId )
{
  INT iRet;

  // Lets resize first, so that we can hopefully fit the string
  if ( !Resize( MAX_PATH ) )
  {
    // Could not resize
    return FALSE;
  }

  iRet = ::LoadString( (HINSTANCE) g_MyModuleHandle, 
                        uResourceId,
                        QueryStr(),
                        QuerySize() );

  ASSERT( iRet < (INT) QuerySize() );

  return ( iRet > 0 );
}

// Constructor
TSTR_PATH::TSTR_PATH()
{

}

// Constructor
TSTR_PATH::TSTR_PATH(DWORD dwInitialSize) 
    : TSTR( dwInitialSize )
{

}

// ExpandEnvironmentVariables
//
// Expand the environment variables in the string
// No parameters needed, it takes the string already
// in the TSTR
//
BOOL 
TSTR_PATH::ExpandEnvironmentVariables()
{
  TSTR  strResult;
  DWORD dwRequiredLen;

  if ( _tcschr( QueryStr(), _T('%') ) == NULL )
  {
    // If there is not a '%' in the string, then we don't have
    // to do any expanding, so lets quit
    return TRUE;
  }

  // Try to expand the strings
  dwRequiredLen = ExpandEnvironmentStrings( QueryStr(),
                                            strResult.QueryStr(),
                                            strResult.QuerySize() );

  if ( dwRequiredLen == 0 )
  {
    // Failure
    return FALSE;
  }

  if ( dwRequiredLen <= strResult.QuerySize() )
  {
    // This indicates success, since the size of the result is
    // smaller or equal to the size of the buffer we gave it
    return TRUE;
  }

  if ( !strResult.Resize( dwRequiredLen ) )
  {
    // Could not resize to required size
    return FALSE;
  }

  // Try to expand the strings
  dwRequiredLen = ExpandEnvironmentStrings( QueryStr(),
                                            strResult.QueryStr(),
                                            strResult.QuerySize() );


  if ( dwRequiredLen == 0 )
  {
    // Failure
    return FALSE;
  }

  if ( strResult.QuerySize() < dwRequiredLen )
  {
    // We should not fail the second time because the buffer is too small
    ASSERT( !(strResult.QuerySize() < dwRequiredLen) );

    return FALSE;
  }

  // Copy into our bufffer now
  return Copy( strResult );
}

// PathAppend
//
// Appends a Path to the current Path
//
BOOL 
TSTR_PATH::PathAppend(LPCTSTR szSource)
{
  DWORD dwLen = QueryLen();
  BOOL  bRet = TRUE;

  if ( ( dwLen != 0 ) &&
       ( *( QueryStr() + dwLen - 1 ) != _T('\\') )
     )
  {
    bRet = Append( _T("\\") );
  }

  if ( bRet )
  {
    if ( *szSource == '\\' )
    {
      // If it starts with a \, then move it up one char
      szSource++;
    }

    bRet = Append( szSource );
  }

  return bRet;
}

// PathAppend
//
// Appends a Path to the current path
//
BOOL 
TSTR_PATH::PathAppend(TSTR &strSource)
{
  return PathAppend( strSource.QueryStr() );
}

// RetrieveSystemDir
//
// Retrieve the System Directory (%windir%\system32), and put it into
// out string
//
BOOL 
TSTR_PATH::RetrieveSystemDir()
{
  DWORD dwLength;

  if ( !Resize( MAX_PATH ) )
  {
    // Failed to resize
    return FALSE;
  }

  dwLength = GetSystemDirectory( QueryStr(), QuerySize() );

  if ( ( dwLength == 0 ) ||
       ( dwLength > QuerySize() ) )
	{
		return FALSE;
	}

  return TRUE;
}

// RetrieveWindowsDir
//
// Retrieve the Windows Directory and put it into our string
//
BOOL 
TSTR_PATH::RetrieveWindowsDir()
{
  DWORD dwLength;

  if ( !Resize( MAX_PATH ) )
  {
    // Failed to resize
    return FALSE;
  }

  dwLength = GetSystemWindowsDirectory( QueryStr(), QuerySize() );

  if ( ( dwLength == 0 ) ||
       ( dwLength > QuerySize() ) )
	{
		return FALSE;
	}

  return TRUE;
}

// RemoveTrailingPath
//
// Remove the path trailing at the end of this path
// ie. c:\foo\test         -> c:\foo
//     c:\foo\test\bar.asp -> c:\foo\test
//     c:\foo.asp          -> c:\
//     c:\                 -> c:\
//
// We succeeded no matter what, the return value just signifies 
// if something was removed
//
// Return Values
//   TRUE - The trailing path was removed
//   FALSE - There was not trailing path to remove
//
BOOL 
TSTR_PATH::RemoveTrailingPath()
{
  LPTSTR szFirstSlash;
  LPTSTR szLastSlash;

  if ( QueryLen() <= 3 )
  {
    // Not long enough to be a real path
    return FALSE;
  }

  szFirstSlash = _tcschr( QueryStr() + 2, _T('\\') );  // Move path c:\ or \\ 
  szLastSlash  = _tcsrchr( QueryStr() - 1, _T('\\') ); // Move back one

  if ( ( szFirstSlash == NULL ) || 
       ( szLastSlash == NULL ) ||
       ( szFirstSlash == szLastSlash ) ||
       ( szFirstSlash > szLastSlash ) )
  {
    // No path to remove
    return FALSE;
  }

  // Terminate string at last slash
  *szLastSlash = _T('\0');

  return TRUE;
}

// function: Construtor
//
// Initialize the list with nothing in it.
//
TSTR_MSZ::TSTR_MSZ()
{
  BOOL bRet; 

  // We are pretty much assuming this will never fail, because
  // 1) We can't notify anyone if it does
  // 2) The implimentation of the buffer class, has static space, so this won't fail  
  bRet = Empty();

  ASSERT( bRet );
}

// function: Empty
//
// Empty the list, so there is nothing in it
//
BOOL
TSTR_MSZ::Empty()
{
  if ( !Resize( 1 ) )  // The size of '\0'
  {
    return FALSE;
  }

  return Copy( _T("") );
}

// function: Resize
//
// Resize the buffer so it is big enough for the multisz
//
// Parameters:
//   dwChars - The number of characters that you need (this includes all
//             the null terminators)
//
BOOL
TSTR_MSZ::Resize(DWORD dwChars)
{
  return m_buff.Resize( dwChars * sizeof(TCHAR) );
}

// function: QueryMultiSz
//
// Return a pointer to the multisz
//
LPTSTR 
TSTR_MSZ::QueryMultiSz()
{
  return (LPTSTR) m_buff.QueryPtr();
}

// function: FindNextString
//
// Given the pointer to the begining of a string in a multisz,
// return a pointer to the begining of the next string
//
// Note: This should not be called on the terminating '\0' of the multisz
//
// Paramters:
//   FindNextString - A pointer to the begining of a string in a mutlisz
//                   (not at the terminating multisz)
//
// Return Values
//   pointer to the next string
//   if the value at the returned string is '\0', then it is the end of the 
//     multisz
//
LPTSTR 
TSTR_MSZ::FindNextString(LPTSTR szCurrentString)
{
  // Make sure that this is not the terminating '\0' of the multisz,
  // (signified by a '\0' is the [0] position of the string)
  if ( *szCurrentString == _T('\0') )
  {
    // This should never be called on the last terminator in a multisz,
    ASSERT( FALSE );
    return szCurrentString;
  }

  while ( *szCurrentString != _T('\0') )
  {
    szCurrentString++;
  }

  // Move to the first character of the next string
  szCurrentString++;

  return szCurrentString;
}

// function: Find
//
// Check to see if 'szSource' string is in the multisz
//
// Parameters:
//   szSource - The string to find a match for
//   bCaseSensitive - Is the search case sensitive or not (default==not)
//
LPTSTR 
TSTR_MSZ::Find(LPTSTR szSource, BOOL bCaseSensitive )
{
  LPTSTR szCurrent = QueryMultiSz();

  while ( *szCurrent != '\0' )
  {
    if ( ( bCaseSensitive &&
           ( _tcscmp( szCurrent, szSource ) == 0 )
         ) ||
         ( !bCaseSensitive &&
           ( _tcsicmp( szCurrent, szSource ) == 0 )
         )
       )
    {
      return szCurrent;
    }

    // Move to next string
    szCurrent = FindNextString( szCurrent );
  }

  return NULL;
}

// function: IsPresent
//
// Checks to see if a string is present.
// Same functionality as Find, but returns BOOL
//
// Parameters:
//   szSource - The string to find a match for
//   bCaseSensitive - Is the search case sensitive or not (default==not)
//
BOOL
TSTR_MSZ::IsPresent(LPTSTR szSource, BOOL bCaseSensitive )
{
  return ( Find( szSource, bCaseSensitive ) != NULL );
}

// function: QueryString
//
// Retrieve a string from inside the multisz
//
// Parameters:
//   dwIndex - The index of the string you want to retrieve ( 0 based, of course )
//
// Return Values:
//   NULL - It is not found (ie. there aren't that many string in the multisz)
//   pointer - The string you are looking for
LPTSTR 
TSTR_MSZ::QueryString( DWORD dwIndex )
{
  LPTSTR szCurrent = QueryMultiSz();

  while ( ( *szCurrent != _T('\0') ) && 
          ( dwIndex != 0 )
        )
  {
    // Move to next string
    szCurrent = FindNextString( szCurrent );
    dwIndex--;
  }

  if ( dwIndex != 0 )
  {
    // We prematurely exited, so there must not be enough strings in
    // the multisz
    return NULL;
  }

  return szCurrent;
}

// function: FindEnd
//
// Find the end of the multisz
// This returns a pointer to the last '\0' of the multisz
//
LPTSTR 
TSTR_MSZ::FindEnd(LPTSTR szCurrentString)
{
  while ( *szCurrentString != _T('\0') )
  {
    // Move to next string
    szCurrentString = FindNextString( szCurrentString );   
  }

  return szCurrentString;
}

// function: Add
//
// Add a string to the end of the list
//
// Parameters:
//   szSource - The string to add to the multisz
//
// Return Values
//   TRUE - Successfully added
//   FALSE - Failure to add
//
BOOL
TSTR_MSZ::Add(LPCTSTR szSource)
{
  LPTSTR szCurrent;

  ASSERT( *szSource != _T('\0') );    // Assert that it is not an empty string

  if ( !Resize( QueryLen() + _tcslen( szSource ) + 1 ) )
  {
    // We could not expand the string large enough, so fail
    return FALSE;
  }

  szCurrent = FindEnd( QueryMultiSz() );

  // Copy New String in
  _tcscpy( szCurrent, szSource );

  // Null terminate the multisz
  *( szCurrent + _tcslen(szSource) + 1 ) = _T('\0');

  return TRUE;
}

// function: Remove
//
// Removes a string from a multisz
//
// Parameters:
//   szSource - The string you want to remove
//   bCaseSensitive - Is the check going to be case sensitive on if it exists
//
// Return Values
//   TRUE - Successfully removed
//   FALSE - Was not found, so it was not removed
//
BOOL 
TSTR_MSZ::Remove(LPTSTR szSource, BOOL bCaseSensitive )
{
  LPTSTR szRemoveString = Find( szSource, bCaseSensitive );
  LPTSTR szEndofMultiSz;
  LPTSTR szNextString;

  if ( szRemoveString == NULL )
  {
    // String was not found
    return FALSE;
  }

  szEndofMultiSz = FindEnd( szRemoveString );
  szNextString = FindNextString( szRemoveString );

  // Assert just to make sure that the next string is before the end
  ASSERT( szNextString <= szEndofMultiSz );

  // Squish the Multisz to remove the string
  // Use memmove, since the strings overlap
  memmove(  szRemoveString, 
            szNextString,
            ( szEndofMultiSz - szNextString + 1 ) * sizeof (TCHAR) );

  return TRUE;
}

// function: Copy
// 
// Copy the multisz that is being send in, into our multisz,
// deleting anything that was there before
//
// Parameters:
//   szSource - The multisz to copy
//
BOOL 
TSTR_MSZ::Copy(LPTSTR szSource)
{
  if ( !Resize( (DWORD) ( FindEnd(szSource) - szSource + 1 ) ) )
  {
    // We could not resize to copy the string
    return FALSE;
  }

  LPTSTR szDestination = QueryMultiSz();
  DWORD dwLen;

  while ( *szSource )
  {
    // Calc length
    dwLen = _tcslen( szSource ) + 1;

    // Copy string
    _tcscpy( szDestination, szSource );

    // Move to next string locations
    szSource += dwLen;
    szDestination += dwLen;
  }

  // Null terminate Multisz
  *szDestination = _T('\0');

  return TRUE;
}

// function: QueryLen
//
// Query the length of the multisz (in chars)
// (including the terminating NULL)
//
DWORD
TSTR_MSZ::QueryLen()
{
  return ( (DWORD) ( FindEnd( QueryMultiSz() ) - QueryMultiSz() + 1 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\wolfpack.cpp ===
#include "stdafx.h"
#include "wolfpack.h"

#ifndef _CHICAGO_
#include    <windows.h>
#include    <stdio.h>
#include    <clusapi.h>
#include    <resapi.h>
#include    <helper.h>

#define INITIAL_RESOURCE_NAME_SIZE 256 // In characters not in bytes
#define IIS_RESOURCE_TYPE_NAME L"IIS Server Instance"
#define SMTP_RESOURCE_TYPE_NAME L"SMTP Server Instance"
#define NNTP_RESOURCE_TYPE_NAME L"NNTP Server Instance"

#define MAX_OFFLINE_RETRIES 5 // Number of times to try and take a resources offline before giving up 
#define DELAY_BETWEEN_CALLS_TO_OFFLINE 1000*2 // in milliseconds

CONST LPCWSTR scClusterPath = _T("System\\CurrentControlSet\\Services\\ClusSvc");
CONST LPCWSTR scClusterPath2 = _T("System\\CurrentControlSet\\Services\\ClusSvc\\Parameters");

CStringList gcstrListOfClusResources;

int g_ClusterSVCExist = -1; // -1 = not checked, 1 = exist, 0 = not exist

typedef DWORD
(WINAPI *PFN_RESUTILFINDSZPROPERTY)(
IN LPVOID lpTheProperty,
IN OUT LPDWORD nInBufferSize,
IN LPCWSTR lpszResourceTypeName,
OUT LPVOID lpOutBuffer);

typedef DWORD
(WINAPI *PFN_RESUTILFINDDWORDPROPERTY)(
IN LPVOID lpTheProperty,
IN OUT LPDWORD nInBufferSize,
IN LPCWSTR lpszResourceTypeName,
OUT LPDWORD pdwPropertyValue);

typedef DWORD
(WINAPI *PFN_CLUSTERRESOURCECONTROL)(
IN HRESOURCE hResource,
IN HNODE hNode,
IN DWORD dwControlCode,
IN LPVOID lpInBuffer,
IN OUT DWORD nInBufferSize,
OUT LPVOID lpOutBuffer,
IN OUT DWORD nOutBufferSize,
OUT LPDWORD lpBytesReturned
);


typedef HCLUSTER
(WINAPI *PFN_OPENCLUSTER)(
    IN LPCWSTR lpszClusterName
    );

typedef BOOL
(WINAPI *PFN_CLOSECLUSTER)(
    IN HCLUSTER hCluster
    );

typedef DWORD
(WINAPI *PFN_CREATECLUSTERRESOURCETYPE)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszResourceTypeDll,
    IN DWORD dwLooksAlivePollInterval,
    IN DWORD dwIsAlivePollInterval
    );

typedef DWORD
(WINAPI *PFN_DELETECLUSTERRESOURCETYPE)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName
    );

typedef HCLUSENUM
(WINAPI
*PFN_ClusterOpenEnum)(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    );

typedef DWORD
(WINAPI
*PFN_ClusterEnum)(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName
    );

typedef DWORD
(WINAPI
*PFN_ClusterCloseEnum)(
    IN HCLUSENUM hEnum
    );

typedef HRESOURCE
(WINAPI
*PFN_OpenClusterResource)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    );

typedef BOOL
(WINAPI
*PFN_CloseClusterResource)(
    IN HRESOURCE hResource
    );

typedef DWORD
(WINAPI
*PFN_DeleteClusterResource)(
    IN HRESOURCE hResource
    );

typedef DWORD
(WINAPI
*PFN_OfflineClusterResource)(
    IN HRESOURCE hResource
    );

typedef HKEY
(WINAPI
*PFN_GetClusterResourceKey)(
    IN HRESOURCE hResource,
    IN REGSAM samDesired
    );

typedef LONG
(WINAPI
*PFN_ClusterRegCloseKey)(
    IN HKEY hKey
    );

typedef LONG
(WINAPI
*PFN_ClusterRegQueryValue)(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

typedef CLUSTER_RESOURCE_STATE
(WINAPI
*PFN_GetClusterResourceState)(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcbNodeName,
    OUT OPTIONAL LPWSTR lpszGroupName,
    IN OUT LPDWORD lpcbGroupName
    );

typedef DWORD
(WINAPI *PFN_DLLREGISTERCLUADMINEXTENSION)(
    IN HCLUSTER hCluster
    );

typedef DWORD
(WINAPI *PFN_DLLUNREGISTERCLUADMINEXTENSION)(
    IN HCLUSTER hCluster
    );


void ListOfClusResources_Add(TCHAR * szEntry)
{
    //Add entry to the list if not already there
    if (_tcsicmp(szEntry, _T("")) != 0)
    {
        // Add it if it is not already there.
        if (TRUE != IsThisStringInThisCStringList(gcstrListOfClusResources, szEntry))
        {
            gcstrListOfClusResources.AddTail(szEntry);
            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ListOfClusResources_Add:%s\n"),szEntry));
        }
    }
    return;
}


INT ListOfClusResources_Check(TCHAR * szEntry)
{
    int iReturn = FALSE;

    //Add entry to the list if not already there
    if (_tcsicmp(szEntry, _T("")) != 0)
    {
        // Return true if it's in there!
        iReturn = IsThisStringInThisCStringList(gcstrListOfClusResources, szEntry);
    }
    return iReturn;
}



BOOL
RegisterIisServerInstanceResourceType(
    LPWSTR pszResType,
    LPWSTR pszResTypeDisplayName,
    LPWSTR pszPath,
    LPWSTR pszAdminPath
    )
{
    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_CREATECLUSTERRESOURCETYPE   pfnCreateClusterResourceType;
    HRESULT                         hres;

    hClusapi = LoadLibrary( L"clusapi.dll" );

    if ( hClusapi )
    {
        pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
        pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
        pfnCreateClusterResourceType = (PFN_CREATECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "CreateClusterResourceType" );

        if ( pfnOpenCluster &&
             pfnCloseCluster &&
             pfnCreateClusterResourceType )
        {
            hC = pfnOpenCluster( NULL );

            if ( hC )
            {
                hres = pfnCreateClusterResourceType(
                    hC,
                    pszResType,
                    pszResType,
                    pszPath,
                    5000,
                    60000 );


                if ( SUCCEEDED( hres ) )
                {
                    HINSTANCE                           hAdmin;
                    PFN_DLLREGISTERCLUADMINEXTENSION    pfnDllRegisterCluAdminExtension;

                    hAdmin = LoadLibrary( pszAdminPath );

                    if ( hAdmin )
                    {
                        pfnDllRegisterCluAdminExtension =
                            (PFN_DLLREGISTERCLUADMINEXTENSION)GetProcAddress( hAdmin, "DllRegisterCluAdminExtension" );
                        if ( pfnDllRegisterCluAdminExtension )
                        {
                            if ( FAILED(hres = pfnDllRegisterCluAdminExtension( hC )) )
                            {
                                dwErr = hres;
                            }
                        }
                        else
                        {
                            dwErr = GetLastError();
                        }
                        FreeLibrary( hAdmin );
                    }
                    else
                    {
                        dwErr = GetLastError();
                    }
                }
                else
                {
                    dwErr = hres;
                }

                pfnCloseCluster( hC );

                if ( dwErr )
                {
                    SetLastError( dwErr );
                }
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        FreeLibrary( hClusapi );
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr == ERROR_SUCCESS ? TRUE : FALSE;
}


BOOL
UnregisterIisServerInstanceResourceType(
    LPWSTR pszResType,
    LPWSTR pszAdminPath,
    BOOL   bGrabVRootFromResourceAndAddToIISVRoot,
    BOOL   bDeleteAfterMove
    )
{
    CStringArray cstrArryName, cstrArryPath;
    CStringArray cstrArryNameftp, cstrArryPathftp;

    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_DELETECLUSTERRESOURCETYPE   pfnDeleteClusterResourceType;
    PFN_ClusterOpenEnum             pfnClusterOpenEnum;
    PFN_ClusterEnum                 pfnClusterEnum;
    PFN_ClusterCloseEnum            pfnClusterCloseEnum;
    PFN_OpenClusterResource         pfnOpenClusterResource;
    PFN_CloseClusterResource        pfnCloseClusterResource;
    PFN_DeleteClusterResource       pfnDeleteClusterResource;
    PFN_OfflineClusterResource      pfnOfflineClusterResource;
    PFN_GetClusterResourceKey       pfnGetClusterResourceKey;
    PFN_ClusterRegCloseKey          pfnClusterRegCloseKey;
    PFN_ClusterRegQueryValue        pfnClusterRegQueryValue;
    PFN_GetClusterResourceState     pfnGetClusterResourceState;
    HRESULT                         hres;
    HCLUSENUM                       hClusEnum;
    WCHAR                           awchResType[256];
    DWORD                           dwEnum;
    DWORD                           dwType;
    DWORD                           dwStrLen;
    HRESOURCE                       hRes;
    HKEY                            hKey;
    BOOL                            fDel;
    DWORD                           dwRetry;
    BUFFER                          buffResName;

    hClusapi = NULL;
    hClusapi = LoadLibrary(L"clusapi.dll");
    if (!hClusapi)
    {
        hClusapi = NULL;
        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType:LoadLib clusapi.dll failed.\n")));
        goto UnregisterIisServerInstanceResourceType_Exit;
    }
    pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
    pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
    pfnDeleteClusterResourceType = (PFN_DELETECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "DeleteClusterResourceType" );
    pfnClusterOpenEnum = (PFN_ClusterOpenEnum)GetProcAddress( hClusapi, "ClusterOpenEnum" );
    pfnClusterEnum = (PFN_ClusterEnum)GetProcAddress( hClusapi, "ClusterEnum" );
    pfnClusterCloseEnum = (PFN_ClusterCloseEnum)GetProcAddress( hClusapi, "ClusterCloseEnum" );
    pfnOpenClusterResource = (PFN_OpenClusterResource)GetProcAddress( hClusapi, "OpenClusterResource" );
    pfnCloseClusterResource = (PFN_CloseClusterResource)GetProcAddress( hClusapi, "CloseClusterResource" );
    pfnDeleteClusterResource = (PFN_DeleteClusterResource)GetProcAddress( hClusapi, "DeleteClusterResource" );
    pfnOfflineClusterResource = (PFN_OfflineClusterResource)GetProcAddress( hClusapi, "OfflineClusterResource" );
    pfnGetClusterResourceKey = (PFN_GetClusterResourceKey)GetProcAddress( hClusapi, "GetClusterResourceKey" );
    pfnClusterRegCloseKey = (PFN_ClusterRegCloseKey)GetProcAddress( hClusapi, "ClusterRegCloseKey" );
    pfnClusterRegQueryValue = (PFN_ClusterRegQueryValue)GetProcAddress( hClusapi, "ClusterRegQueryValue" );
    pfnGetClusterResourceState = (PFN_GetClusterResourceState)GetProcAddress( hClusapi, "GetClusterResourceState" );

    if ( !pfnOpenCluster ||
         !pfnCloseCluster ||
         !pfnDeleteClusterResourceType ||
         !pfnClusterOpenEnum ||
         !pfnClusterEnum ||
         !pfnClusterCloseEnum ||
         !pfnOpenClusterResource ||
         !pfnCloseClusterResource ||
         !pfnDeleteClusterResource ||
         !pfnOfflineClusterResource ||
         !pfnGetClusterResourceKey  ||
         !pfnClusterRegCloseKey ||
         !pfnClusterRegQueryValue ||
         !pfnGetClusterResourceState )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType:clusapi.dll missing export function.failure.\n")));
        goto UnregisterIisServerInstanceResourceType_Exit;
    }

    hC = pfnOpenCluster(NULL);
    // if we can't open the cluster, then maybe there are none.
    if (!hC) {goto UnregisterIisServerInstanceResourceType_Exit;}

    // Delete all resources of type pszResType
    hClusEnum = pfnClusterOpenEnum(hC, CLUSTER_ENUM_RESOURCE);
    if (hClusEnum != NULL)
    {
        dwEnum = 0;
        int iClusterEnumReturn = ERROR_SUCCESS;

        // allocate the initial buffer for pawchResName
        if ( !buffResName.Resize( 256 * sizeof( WCHAR ) ) )
        {
           goto UnregisterIisServerInstanceResourceType_Exit;
        }

        do
        {
            iClusterEnumReturn = ERROR_SUCCESS;
            dwStrLen = buffResName.QuerySize() / sizeof(WCHAR);
            iClusterEnumReturn = pfnClusterEnum( hClusEnum, dwEnum, &dwType, (LPWSTR) buffResName.QueryPtr(), &dwStrLen );
            if (iClusterEnumReturn != ERROR_SUCCESS)
            {
                // Check if failed because it needs more space.
                if ( (iClusterEnumReturn == ERROR_MORE_DATA) &&
                     ( ( dwStrLen + 1 ) > buffResName.QuerySize() ) )
                {
                    if ( !buffResName.Resize( ( dwStrLen + 1 ) * sizeof(WCHAR) ) )
                    {
                        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType: realloc FAILED.out of memory.\n")));
                        goto UnregisterIisServerInstanceResourceType_Exit;
                    }
                    // try it again.
                    iClusterEnumReturn = ERROR_SUCCESS;
                    dwStrLen = buffResName.QuerySize() / sizeof(WCHAR);
                    iClusterEnumReturn = pfnClusterEnum( hClusEnum, dwEnum, &dwType, (LPWSTR) buffResName.QueryPtr(), &dwStrLen );
                    if (iClusterEnumReturn != ERROR_SUCCESS)
                    {
                        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType: FAILED.err=0x%x.\n"), iClusterEnumReturn));
                        break;
                    }
                }
                else
                {
                    if (iClusterEnumReturn != ERROR_NO_MORE_ITEMS)
                    {
                        // failed for some other reason than no more data
                        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType: FAILED.err=0x%x.\n"), iClusterEnumReturn));
                    }
                    break;
                }
            }


            // proceed
            hRes = pfnOpenClusterResource( hC, (LPWSTR) buffResName.QueryPtr() );

            if ( hRes )
            {
                hKey = pfnGetClusterResourceKey( hRes, KEY_READ );

                if ( hKey )
                {
                    dwStrLen = sizeof(awchResType)/sizeof(WCHAR);
                    // Check if it's for 'our' type of key (pszResType)
                    fDel = pfnClusterRegQueryValue( hKey, L"Type", &dwType, (LPBYTE)awchResType, &dwStrLen ) == ERROR_SUCCESS && !wcscmp( awchResType, pszResType );
                    pfnClusterRegCloseKey( hKey );

                    if ( fDel )
                    {
                        if (bDeleteAfterMove)
                        {
                            // Take the resource off line so that we can actually delete it, i guess.
                            pfnOfflineClusterResource( hRes );
                            for ( dwRetry = 0 ;dwRetry < 30 && pfnGetClusterResourceState( hRes,NULL,&dwStrLen,NULL,&dwStrLen ) != ClusterResourceOffline; ++dwRetry )
                            {
                                Sleep( 1000 );
                            }
                        }

                        // At this point we have successfully got the cluster to go offline
                        if (bGrabVRootFromResourceAndAddToIISVRoot)
                        {
                            // At this point we have successfully got the cluster to go offline

                            // Get the vroot names and path's here and stick into the arrays....
                            GetClusterIISVRoot(hRes, L"W3SVC", cstrArryName, cstrArryPath);

                            // Do it for FTP now.
                            GetClusterIISVRoot(hRes, L"MSFTPSVC", cstrArryNameftp, cstrArryPathftp);

                            // No need to do it for gopher since there is none.
                            //GetClusterIISVRoot(hRes, L"GOPHERSVC", cstrArryName, cstrArryPath);
                        }

                        // We have saved all the important data into our Array's
                        // now it's okay to delete the Resource
                        if (bDeleteAfterMove)
                        {
                            pfnDeleteClusterResource( hRes );
                        }
                    }
                }

                pfnCloseClusterResource( hRes );
            }

            // Increment to the next one
            ++dwEnum;

        } while(TRUE);

        pfnClusterCloseEnum( hClusEnum );
    }

    if (bDeleteAfterMove)
    {
        dwErr = pfnDeleteClusterResourceType(hC,pszResType );

        HINSTANCE hAdmin = LoadLibrary( pszAdminPath );

        if ( hAdmin )
        {
            PFN_DLLUNREGISTERCLUADMINEXTENSION  pfnDllUnregisterCluAdminExtension;
            pfnDllUnregisterCluAdminExtension = (PFN_DLLUNREGISTERCLUADMINEXTENSION)GetProcAddress( hAdmin, "DllUnregisterCluAdminExtension" );
            if ( pfnDllUnregisterCluAdminExtension )
            {
                if ( FAILED(hres = pfnDllUnregisterCluAdminExtension( hC )) )
                {
                    dwErr = hres;
                }
            }
            else
            {
                dwErr = GetLastError();
            }
            FreeLibrary( hAdmin );
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    pfnCloseCluster( hC );

    if (dwErr)
        {SetLastError( dwErr );}

UnregisterIisServerInstanceResourceType_Exit:
    // Copy these to the iis virtual root registry....
    MoveVRootToIIS3Registry(REG_W3SVC,cstrArryName,cstrArryPath);
    // Copy these to the iis virtual root registry....
    MoveVRootToIIS3Registry(REG_MSFTPSVC,cstrArryNameftp,cstrArryPathftp);

    if (hClusapi) {FreeLibrary(hClusapi);}
    return dwErr == ERROR_SUCCESS ? TRUE : FALSE;
}


void TestClusterRead(LPWSTR pszClusterName)
{
    iisDebugOut_Start(_T("TestClusterRead"));

    LPWSTR pszResType = L"IIS Virtual Root";

    CStringArray cstrArryName, cstrArryPath;
    CStringArray cstrArryNameftp, cstrArryPathftp;

    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_DELETECLUSTERRESOURCETYPE   pfnDeleteClusterResourceType;
    PFN_ClusterOpenEnum             pfnClusterOpenEnum;
    PFN_ClusterEnum                 pfnClusterEnum;
    PFN_ClusterCloseEnum            pfnClusterCloseEnum;
    PFN_OpenClusterResource         pfnOpenClusterResource;
    PFN_CloseClusterResource        pfnCloseClusterResource;
    PFN_DeleteClusterResource       pfnDeleteClusterResource;
    PFN_OfflineClusterResource      pfnOfflineClusterResource;
    PFN_GetClusterResourceKey       pfnGetClusterResourceKey;
    PFN_ClusterRegCloseKey          pfnClusterRegCloseKey;
    PFN_ClusterRegQueryValue        pfnClusterRegQueryValue;
    PFN_GetClusterResourceState     pfnGetClusterResourceState;
    HCLUSENUM                       hClusEnum;
    WCHAR *                         pawchResName = NULL;
    WCHAR                           awchResType[256];
    DWORD                           dwEnum;
    DWORD                           dwType;
    DWORD                           dwStrLen;
    HRESOURCE                       hRes;
    HKEY                            hKey;
    BOOL                            fDel;

    hClusapi = NULL;
    hClusapi = LoadLibrary(L"clusapi.dll");
    if (!hClusapi)
    {
        hClusapi = NULL;
        iisDebugOut((LOG_TYPE_TRACE, _T("fail 1\n")));
        goto TestClusterRead_Exit;
    }
    pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
    pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
    pfnDeleteClusterResourceType = (PFN_DELETECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "DeleteClusterResourceType" );
    pfnClusterOpenEnum = (PFN_ClusterOpenEnum)GetProcAddress( hClusapi, "ClusterOpenEnum" );
    pfnClusterEnum = (PFN_ClusterEnum)GetProcAddress( hClusapi, "ClusterEnum" );
    pfnClusterCloseEnum = (PFN_ClusterCloseEnum)GetProcAddress( hClusapi, "ClusterCloseEnum" );
    pfnOpenClusterResource = (PFN_OpenClusterResource)GetProcAddress( hClusapi, "OpenClusterResource" );
    pfnCloseClusterResource = (PFN_CloseClusterResource)GetProcAddress( hClusapi, "CloseClusterResource" );
    pfnDeleteClusterResource = (PFN_DeleteClusterResource)GetProcAddress( hClusapi, "DeleteClusterResource" );
    pfnOfflineClusterResource = (PFN_OfflineClusterResource)GetProcAddress( hClusapi, "OfflineClusterResource" );
    pfnGetClusterResourceKey = (PFN_GetClusterResourceKey)GetProcAddress( hClusapi, "GetClusterResourceKey" );
    pfnClusterRegCloseKey = (PFN_ClusterRegCloseKey)GetProcAddress( hClusapi, "ClusterRegCloseKey" );
    pfnClusterRegQueryValue = (PFN_ClusterRegQueryValue)GetProcAddress( hClusapi, "ClusterRegQueryValue" );
    pfnGetClusterResourceState = (PFN_GetClusterResourceState)GetProcAddress( hClusapi, "GetClusterResourceState" );

    if ( !pfnOpenCluster ||
         !pfnCloseCluster ||
         !pfnDeleteClusterResourceType ||
         !pfnClusterOpenEnum ||
         !pfnClusterEnum ||
         !pfnClusterCloseEnum ||
         !pfnOpenClusterResource ||
         !pfnCloseClusterResource ||
         !pfnDeleteClusterResource ||
         !pfnOfflineClusterResource ||
         !pfnGetClusterResourceKey  ||
         !pfnClusterRegCloseKey ||
         !pfnClusterRegQueryValue ||
         !pfnGetClusterResourceState )
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("fail 2\n")));
        goto TestClusterRead_Exit;
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("try to open cluster=%s\n"),pszClusterName));
    // try to open the cluster on the computer
    hC = pfnOpenCluster( pszClusterName );

    if ( hC )
    {
        //
        // Delete all resources of type pszResType
        //
        if ( (hClusEnum = pfnClusterOpenEnum( hC, CLUSTER_ENUM_RESOURCE )) != NULL )
        {
            dwEnum = 0;
            int iClusterEnumReturn = ERROR_SUCCESS;

            // allocate the initial buffer for pawchResName
            dwStrLen = 256 * sizeof(WCHAR);
            pawchResName = NULL;
            pawchResName = (LPTSTR) malloc( dwStrLen );
            if (!pawchResName)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("TestClusterRead: malloc FAILED.out of memory.\n")));
                goto TestClusterRead_Exit;
            }

            do
            {
                iClusterEnumReturn = pfnClusterEnum( hClusEnum, dwEnum, &dwType, pawchResName, &dwStrLen );
                if (iClusterEnumReturn != ERROR_SUCCESS)
                {
                    // Check if failed because it needs more space.
                    if (iClusterEnumReturn == ERROR_MORE_DATA)
                    {
                        LPTSTR pOldResName = pawchResName;

                        // dwStrLen should be set to the required length returned from pfnClusterEnum
                        dwStrLen = (dwStrLen + 1) * sizeof(WCHAR);
                        pawchResName = (LPTSTR) realloc(pawchResName, dwStrLen);
                        if (!pawchResName)
                        {
                            if ( pOldResName )
                            {
                              free ( pOldResName );
                            }
                            iisDebugOut((LOG_TYPE_ERROR, _T("TestClusterRead: realloc FAILED.out of memory.\n")));
                            goto TestClusterRead_Exit;
                        }
                        // try it again.
                        iClusterEnumReturn = pfnClusterEnum( hClusEnum, dwEnum, &dwType, pawchResName, &dwStrLen );
                        if (iClusterEnumReturn != ERROR_SUCCESS)
                        {
                            iisDebugOut((LOG_TYPE_ERROR, _T("TestClusterRead: FAILED.err=0x%x.\n"), iClusterEnumReturn));
                            break;
                        }
                    }
                    else
                    {
                        if (iClusterEnumReturn != ERROR_NO_MORE_ITEMS)
                        {
                            // failed for some other reason.
                            iisDebugOut((LOG_TYPE_ERROR, _T("TestClusterRead: FAILED.err=0x%x.\n"), iClusterEnumReturn));
                        }
                        break;
                    }
                }

                // proceed
                hRes = pfnOpenClusterResource( hC, pawchResName ); 

                if ( hRes )
                {
                    hKey = pfnGetClusterResourceKey( hRes, KEY_READ ) ; 

                    if ( hKey )
                    {
                        dwStrLen = sizeof(awchResType)/sizeof(WCHAR);

                        fDel = pfnClusterRegQueryValue( hKey, L"Type", &dwType, (LPBYTE)awchResType, &dwStrLen ) == ERROR_SUCCESS && !wcscmp( awchResType, pszResType );

                        iisDebugOut((LOG_TYPE_TRACE, _T("TestClusterRead():ClusterRegQueryValue:%s."),awchResType));
                        pfnClusterRegCloseKey( hKey );

                        if ( fDel )
                        {
                            /*
                            pfnOfflineClusterResource( hRes );
                            for ( dwRetry = 0 ; dwRetry < 30 && pfnGetClusterResourceState( hRes,NULL,&dwStrLen,NULL,&dwStrLen ) != ClusterResourceOffline; ++dwRetry )
                            {
                                Sleep( 1000 );
                            }
                            */

                            // At this point we have successfully got the cluster to go offline

                            // Get the vroot names and path's here and stick into the arrays....
                            GetClusterIISVRoot(hRes, L"W3SVC", cstrArryName, cstrArryPath);

                            // Do it for FTP now.
                            GetClusterIISVRoot(hRes, L"MSFTPSVC", cstrArryNameftp, cstrArryPathftp);

                            // No need to do it for gopher since there is none.
                            //GetClusterIISVRoot(hRes, L"GOPHERSVC", cstrArryName, cstrArryPath);
                        }
                    }

                    pfnCloseClusterResource( hRes );
                }

                // Increment to the next one
                ++dwEnum;

            } while(TRUE);

            pfnClusterCloseEnum( hClusEnum );
        }

        //dwErr = pfnDeleteClusterResourceType(hC,pszResType );

        pfnCloseCluster( hC );

        if (dwErr)
            {SetLastError( dwErr );}
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("fail 3\n")));
    }

TestClusterRead_Exit:
    // Copy these to the iis virtual root registry....
    MoveVRootToIIS3Registry(REG_W3SVC,cstrArryName,cstrArryPath);
    // Copy these to the iis virtual root registry....
    MoveVRootToIIS3Registry(REG_MSFTPSVC,cstrArryNameftp,cstrArryPathftp);

    if (hClusapi) {FreeLibrary(hClusapi);}
    if (pawchResName) {free(pawchResName);}
    iisDebugOut_End(_T("TestClusterRead"));
    return;
}

/****************************************************************************************
 *
 * Function: GetClusterIISVRoot
 *
 * Args: [in] hResource , the resource whos info should be added to the list
 *
 * Retrurn: GetLastError, on error
 *
 ****************************************************************************************/
int GetClusterIISVRoot(HRESOURCE hResource, LPWSTR pszTheServiceType, CStringArray &strArryOfVrootNames, CStringArray &strArryOfVrootData)
{
    //iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: start\n")));
    int iReturn = FALSE;
    HINSTANCE                       hClusapi;
    HINSTANCE                       hResutils;

    PFN_CLUSTERRESOURCECONTROL      pfnClusterResourceControl;
    PFN_RESUTILFINDSZPROPERTY       pfnResUtilFindSzProperty;
    PFN_RESUTILFINDDWORDPROPERTY    pfnResUtilFindDwordProperty;

	//
	// Initial size of the buffer
	//
	DWORD dwBufferSize = 256;
	
	//
	// The requested buffer size, and the number of bytes actually in the returned buffer
	//
	DWORD dwRequestedBufferSize = dwBufferSize;

	//
	// Result from the call to the cluster resource control function
	//
	DWORD dwResult;

	//
	// Buffer that holds the property list for this resource
	//
	LPVOID lpvPropList = NULL;

	//
	// The Proivate property that is being read
	//
	LPWSTR lpwszPrivateProp = NULL;

    hClusapi = LoadLibrary( L"clusapi.dll" );
    if (!hClusapi)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to loadlib clusapi.dll\n")));
        goto GetIISVRoot_Exit;
        }

    pfnClusterResourceControl = (PFN_CLUSTERRESOURCECONTROL)GetProcAddress( hClusapi, "ClusterResourceControl" );
    if (!pfnClusterResourceControl)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to GetProcAddress clusapi.dll:ClusterResourceControl\n")));
        goto GetIISVRoot_Exit;
        }

    hResutils = LoadLibrary( L"resutils.dll" );
    if (!hResutils)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to loadlib resutils.dll\n")));
        goto GetIISVRoot_Exit;
        }
    pfnResUtilFindSzProperty = (PFN_RESUTILFINDSZPROPERTY)GetProcAddress( hResutils, "ResUtilFindSzProperty" );
    if (!pfnResUtilFindSzProperty)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to GetProcAddress resutils.dll:ResUtilFindSzProperty\n")));
        goto GetIISVRoot_Exit;
        }
    pfnResUtilFindDwordProperty = (PFN_RESUTILFINDDWORDPROPERTY)GetProcAddress( hResutils, "ResUtilFindDwordProperty" );
    if (!pfnResUtilFindDwordProperty)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to GetProcAddress resutils.dll:ResUtilFindDwordProperty\n")));
        goto GetIISVRoot_Exit;
        }

	//
	// Allocate memory for the resource type
	//
	lpvPropList = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, dwBufferSize * sizeof(WCHAR) );
	if( lpvPropList == NULL)
	{
		lpvPropList = NULL;
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: E_OUTOFMEMORY\n")));
        goto GetIISVRoot_Exit;
	}

	//
	// Allocate memory for the Property
	//
	lpwszPrivateProp = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (_MAX_PATH+_MAX_PATH+1) * sizeof(WCHAR) );
	if( lpwszPrivateProp == NULL)
	{
		lpvPropList = NULL;
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: E_OUTOFMEMORY\n")));
        goto GetIISVRoot_Exit;
	}
	
	//
	// Get the resource's private properties (Service , InstanceId)
	//
	while( 1 )
	{
		dwResult = pfnClusterResourceControl(hResource,NULL,CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,NULL,0,lpvPropList,dwBufferSize,&dwRequestedBufferSize );
		if( ERROR_SUCCESS == dwResult )
		{
            // ---------------------
            // what the entries are:
            // AccessMask (dword) = 5
            // Alias (string)     = "virtual dir name"
            // Directory (string) = "c:\la\lalalala"
            // ServiceName (string) = W3SVC, MSFTPSVC, GOPHERSVC
            // ---------------------

            //
            // Get the "ServiceName" entry
            //
            dwResult = pfnResUtilFindSzProperty( lpvPropList, &dwRequestedBufferSize, L"ServiceName", &lpwszPrivateProp);
			if( dwResult != ERROR_SUCCESS )
			{
                iisDebugOut((LOG_TYPE_ERROR, _T("Couldn't get 'ServiceName' property.fail\n")));
                goto GetIISVRoot_Exit;
			}

            if (_wcsicmp(lpwszPrivateProp, pszTheServiceType) == 0)
            {
                // okay, we want to do stuff with this one!!!
                DWORD dwAccessMask;
                CString csAlias;
                CString csDirectory;

                TCHAR szMyBigPath[_MAX_PATH + 20];

                DWORD dwPrivateProp = 0;
                dwRequestedBufferSize = sizeof(DWORD);

                // get the Access Mask.
                dwResult = pfnResUtilFindDwordProperty( lpvPropList, &dwRequestedBufferSize, L"AccessMask", &dwPrivateProp);
			    if( dwResult != ERROR_SUCCESS )
			    {
                    iisDebugOut((LOG_TYPE_ERROR, _T("Couldn't get 'AccessMask' property.fail\n")));
                    goto GetIISVRoot_Exit;
			    }
                dwAccessMask = dwPrivateProp;

                // get the Alias
                dwResult = pfnResUtilFindSzProperty( lpvPropList, &dwRequestedBufferSize, L"Alias", &lpwszPrivateProp);
			    if( dwResult != ERROR_SUCCESS )
			    {
                    iisDebugOut((LOG_TYPE_ERROR, _T("Couldn't get 'Alias' property.fail\n")));
                    goto GetIISVRoot_Exit;
			    }
                csAlias = lpwszPrivateProp;

                // Get the Directory
                dwResult = pfnResUtilFindSzProperty( lpvPropList, &dwRequestedBufferSize, L"Directory", &lpwszPrivateProp);
			    if( dwResult != ERROR_SUCCESS )
			    {
                    iisDebugOut((LOG_TYPE_ERROR, _T("Couldn't get 'Directory' property.fail\n")));
                    goto GetIISVRoot_Exit;
			    }
                TCHAR thepath[_MAX_PATH];
                TCHAR * pmypath;
                csDirectory = lpwszPrivateProp;

                // make sure it's a valid directory name!
                if (0 != GetFullPathName(lpwszPrivateProp, _MAX_PATH, thepath, &pmypath))
                    {csDirectory = thepath;}

                // --------------------
                // formulate the string
                // --------------------

			    //
			    // Put the Name into the array.
			    //
                // "/Alias"
                strArryOfVrootNames.Add(csAlias);

                //
                // "C:\inetpub\ASPSamp,,5"
                //
                _stprintf(szMyBigPath,_T("%s,,%d"),csDirectory, dwAccessMask);
                strArryOfVrootData.Add(szMyBigPath);

                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("Entry=[%s] '%s=%s'\n"),pszTheServiceType,csAlias,szMyBigPath));
            }
            goto GetIISVRoot_Exit;
		}

		if( ERROR_MORE_DATA == dwResult )
		{
      LPVOID lpvTemp = lpvPropList;
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			dwBufferSize = ++dwRequestedBufferSize;

			lpvPropList = (LPWSTR) HeapReAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, lpvPropList, dwBufferSize * sizeof(WCHAR) );
			if ( lpvPropList == NULL)
			{
        if ( lpvTemp )
        {
          HeapFree( GetProcessHeap(), 0, lpvTemp );
        }
        // out of memory!!!!
        goto GetIISVRoot_Exit;
			}
		}
	}

GetIISVRoot_Exit:
    if (lpwszPrivateProp)
        {HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpwszPrivateProp);}
    if (lpvPropList)
        {HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpvPropList);}
    //iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: end\n")));
    return iReturn;
}


// REG_W3SVC, REG_MSFTPSVC
void MoveVRootToIIS3Registry(CString strRegPath, CStringArray &strArryOfVrootNames, CStringArray &strArryOfVrootData)
{
    int nArrayItems = 0;
    int i = 0;

    strRegPath +=_T("\\Parameters\\Virtual Roots");
    CRegKey regVR( HKEY_LOCAL_MACHINE, strRegPath);
    if ((HKEY) regVR)
    {
        nArrayItems = (int)strArryOfVrootNames.GetSize();
        // if the CString arrays are empty then we won't ever process anything (nArrayItems is 1 based)
        for (i = 0; i < nArrayItems; i++ )
        {
            regVR.SetValue(strArryOfVrootNames[i], strArryOfVrootData[i]);
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("Array[%d]:%s=%s\n"),i,strArryOfVrootNames[i], strArryOfVrootData[i]));
        }
    }
    return;
}

void Upgrade_WolfPack()
{
    iisDebugOut_Start(_T("Upgrade_WolfPack"),LOG_TYPE_TRACE);

    CRegKey regClusSvc(HKEY_LOCAL_MACHINE, scClusterPath, KEY_READ);
    if ( (HKEY)regClusSvc )
    {
        CString csPath;
        TCHAR szPath[MAX_PATH];
        if (regClusSvc.QueryValue(_T("ImagePath"), csPath) == NERR_Success)
        {
			// string is formatted like this
			// %SystemRoot%\cluster\clusprxy.exe
			// Find the last \ and trim and paste the new file name on
			csPath = csPath.Left(csPath.ReverseFind('\\'));
			
			if ( csPath.IsEmpty() )
            {
				ASSERT(TRUE);
				return;
			}
			
            csPath += _T("\\iisclex3.dll");
	
	        if ( ExpandEnvironmentStrings( (LPCTSTR)csPath,szPath,sizeof(szPath)/sizeof(TCHAR)))
            {
                // in iis3.0 the resources were called 'IIS Virtual Root'
                // in iis4.0 it is something else (iis50 is the same as iis4)
	    	    UnregisterIisServerInstanceResourceType(L"IIS Virtual Root",(LPTSTR)szPath,TRUE,TRUE);
            }
            else
            {
				ASSERT(TRUE);
            }
        }

        ProcessSection(g_pTheApp->m_hInfHandle, _T("Wolfpack_Upgrade"));
    }
    iisDebugOut_End(_T("Upgrade_WolfPack"),LOG_TYPE_TRACE);
}


/****************************************************
*
* Known "problem": If a resource doesn't come offline after the five
* retries than the function continues to try to take the other iis resources
* offline but there is no error reported. You could change this pretty simply I think.
*
*****************************************************/
DWORD BringALLIISClusterResourcesOffline()
{
	//
	// The return code
	//
	DWORD dwError = ERROR_SUCCESS;
	
	//
	// Handle for the cluster
	//
	HCLUSTER hCluster = NULL;

	//
	// Handle for the cluster enumerator
	//
	HCLUSENUM hClusResEnum = NULL;

	//
	// Handle to a resource
	// 
	HRESOURCE hResource = NULL;

	//
	// The index of the resources we're taking offline
	//
	DWORD dwResourceIndex = 0;

	//
	// The type cluster object being enumerated returned by the ClusterEnum function
	//
	DWORD dwObjectType = 0;

	//
	// The name of the cluster resource returned by the ClusterEnum function
	//
	LPWSTR lpwszResourceName = NULL;
	
	//
	// The return code from the call to ClusterEnum
	//
	DWORD dwResultClusterEnum = ERROR_SUCCESS;

	//
	// The size of the buffer (in characters) that is used to hold the resource name's length
	//	
	DWORD dwResourceNameBufferLength = INITIAL_RESOURCE_NAME_SIZE;

	//
	// Size of the resource name passed to and returned by the ClusterEnum function
	//	
	DWORD dwClusterEnumResourceNameLength = dwResourceNameBufferLength;

    BOOL iClusDependsOnIISServices = FALSE;

	//
	// Open the cluster
	//
  hCluster = OpenCluster(NULL);

  if ( hCluster == NULL )
	{
        dwError = GetLastError();
        // This will fail with RPC_S_SERVER_UNAVAILABLE "The RPC server is unavailable" if there is no cluster on this system
        if (hCluster == NULL)
        {
            if ( (dwError != RPC_S_SERVER_UNAVAILABLE) &&
                 (dwError != EPT_S_NOT_REGISTERED ) )
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOffline:OpenCluster failed err=0x%x.\n"),dwError));
            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOffline:OpenCluster failed err=0x%x.\n"),dwError));
        }
		goto clean_up;
	}

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOffline:start.\n")));

	//
	// Get Enumerator for the cluster resouces
	// 
  hClusResEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );

	if ( hClusResEnum == NULL )
	{
		dwError = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOffline:ClusterOpenEnum failed err=0x%x.\n"),dwError));
		goto clean_up;	
	}
	
	//
	// Enumerate the Resources in the cluster
	// 
	
	//
	// Allocate memory to hold the cluster resource name as we enumerate the resources
	//
  lpwszResourceName = (LPWSTR) LocalAlloc(LPTR, dwResourceNameBufferLength * sizeof(WCHAR));

	if ( lpwszResourceName == NULL )
	{
		dwError = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOffline:LocalAlloc failed err=0x%x.\n"),dwError));
		goto clean_up;
	}

	// 
	// Enumerate all of the resources in the cluster and take the IIS Server Instance's offline
	//
  dwResultClusterEnum = ClusterEnum(hClusResEnum,
	    		                          dwResourceIndex, 
			          	                  &dwObjectType, 
				                            lpwszResourceName,
				                            &dwClusterEnumResourceNameLength );

	while( ERROR_NO_MORE_ITEMS != dwResultClusterEnum )
	{
		//
		// If we have a resource's name
		//
		if( ERROR_SUCCESS == dwResultClusterEnum )
		{
      hResource = OpenClusterResource( hCluster, lpwszResourceName );

			if ( hResource == NULL )
			{
				dwError = GetLastError();
				break;
			}

            // If the resource type is "IIS Server Instance", or some other one that is 
            // dependent upon the iis services, then we need to stop it.
            iClusDependsOnIISServices = CheckForIISDependentClusters(hResource);
            if (iClusDependsOnIISServices)
			{
	            CLUSTER_RESOURCE_STATE TheState = GetClusterResourceState(hResource,NULL,0,NULL,0);
                if (TheState == ClusterResourceOnline || TheState == ClusterResourceOnlinePending)
                {
                    HKEY hKey = GetClusterResourceKey( hResource, KEY_READ );

                    if ( hKey )
                    {
                        //
                        // Get the resource name.
                        //
                        LPWSTR lpwsResourceName = NULL;
                        lpwsResourceName = GetParameter( hKey, L"Name" );
                        if ( lpwsResourceName != NULL ) 
                        {
                            // this is a resource which we will try to stop
                            // so we should save the name somewhere in like a global list
                            iisDebugOut((LOG_TYPE_TRACE, _T("OfflineClusterResource:'%s'\n"),lpwsResourceName));
                            ListOfClusResources_Add(lpwsResourceName);
                        }
                        if (lpwsResourceName){LocalFree((LPWSTR) lpwsResourceName);}

                        ClusterRegCloseKey(hKey);
                    }

                    //
                    // If the resource doesn't come offline quickly then wait 
                    //
                    if ( ERROR_IO_PENDING == OfflineClusterResource( hResource ) )
                    {
                        for(int iRetry=0; iRetry < MAX_OFFLINE_RETRIES; iRetry++)
                        {
                            Sleep( DELAY_BETWEEN_CALLS_TO_OFFLINE );

                            if ( ERROR_SUCCESS == OfflineClusterResource( hResource ) )
                            {
                                break;
                            }
                        }	
                    }
                }
			CloseClusterResource( hResource );
            }
			
			dwResourceIndex++;
      dwResultClusterEnum = ClusterEnum(hClusResEnum,
                                        dwResourceIndex, 
                                        &dwObjectType, 
                                        lpwszResourceName,
                                        &dwClusterEnumResourceNameLength );
		}
			
		//
		// If the buffer wasn't large enough then retry with a larger buffer
		//
		if( ERROR_MORE_DATA == dwResultClusterEnum )
		{
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			LPWSTR lpwszResourceNameTmp = lpwszResourceName;

			//
			// After returning from ClusterEnum dwClusterEnumResourceNameLength 
			// doesn't include the null terminator character
			//
			dwResourceNameBufferLength = dwClusterEnumResourceNameLength + 1;
      lpwszResourceName = (LPWSTR) LocalReAlloc (lpwszResourceName, dwResourceNameBufferLength * sizeof(WCHAR), 0);

      if ( !lpwszResourceName )
			{
				dwError = GetLastError();

				LocalFree( lpwszResourceNameTmp );	
				lpwszResourceNameTmp = NULL;
				break;
			}
		}

		//
		// Reset dwResourceNameLength with the size of the number of characters in the buffer
		// You have to do this because everytime you call ClusterEnum is sets your buffer length 
		// argument to the number of characters in the string it's returning.
		//
		dwClusterEnumResourceNameLength = dwResourceNameBufferLength;
	}	


clean_up:

	if ( lpwszResourceName )
	{
		LocalFree( lpwszResourceName );
		lpwszResourceName = NULL;
	}
	
	if ( hClusResEnum )
	{
		ClusterCloseEnum( hClusResEnum );
		hClusResEnum = NULL;
	}

	if ( hCluster )
	{
		CloseCluster( hCluster );
		hCluster = NULL;
	}

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOffline:end.ret=0x%x\n"),dwError));
	return dwError;
}


DWORD BringALLIISClusterResourcesOnline()
{
    //
    // The return code
    //
    DWORD dwError = ERROR_SUCCESS;

    //
    // Handle for the cluster
    //
    HCLUSTER hCluster = NULL;

    //
    // Handle for the cluster enumerator
    //
    HCLUSENUM hClusResEnum = NULL;

    //
    // Handle to a resource
    // 
    HRESOURCE hResource = NULL;

    //
    // The index of the resources we're taking offline
    //
    DWORD dwResourceIndex = 0;

    //
    // The type cluster object being enumerated returned by the ClusterEnum function
    //
    DWORD dwObjectType = 0;

    //
    // The name of the cluster resource returned by the ClusterEnum function
    //
    LPWSTR lpwszResourceName = NULL;

    //
    // The return code from the call to ClusterEnum
    //
    DWORD dwResultClusterEnum = ERROR_SUCCESS;

    //
    // The size of the buffer (in characters) that is used to hold the resource name's length
    //	
    DWORD dwResourceNameBufferLength = INITIAL_RESOURCE_NAME_SIZE;

    //
    // Size of the resource name passed to and returned by the ClusterEnum function
    //	
    DWORD dwClusterEnumResourceNameLength = dwResourceNameBufferLength;

    BOOL iClusDependsOnIISServices = FALSE;


    //
    // Open the cluster
    //
    hCluster = OpenCluster(NULL);

    if ( !hCluster )
    {
        dwError = GetLastError();
        // This will fail with RPC_S_SERVER_UNAVAILABLE "The RPC server is unavailable" if there is no cluster on this system
        if (hCluster == NULL)
        {
            if ( (dwError != RPC_S_SERVER_UNAVAILABLE) &&
                 (dwError != EPT_S_NOT_REGISTERED ) )
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOnline:OpenCluster failed err=0x%x.\n"),dwError));
            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOnline:OpenCluster failed err=0x%x.\n"),dwError));
        }
        goto clean_up;
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOnline:end.ret=0x%x\n"),dwError));

    //
    // Get Enumerator for the cluster resouces
    // 
    hClusResEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );

    if ( !hClusResEnum )
    {
        dwError = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOnline:ClusterOpenEnum failed err=0x%x.\n"),dwError));
        goto clean_up;	
    }
	
	//
	// Enumerate the Resources in the cluster
	// 
	
    //
    // Allocate memory to hold the cluster resource name as we enumerate the resources
    //
    lpwszResourceName = (LPWSTR) LocalAlloc(LPTR, dwResourceNameBufferLength * sizeof(WCHAR));

    if ( !lpwszResourceName )
    {
        dwError = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOnline:LocalAlloc failed err=0x%x.\n"),dwError));
        goto clean_up;
    }

    // 
    // Enumerate all of the resources in the cluster and take the IIS Server Instance's offline
    //
    while( ERROR_NO_MORE_ITEMS  != 
        (dwResultClusterEnum = ClusterEnum(hClusResEnum,
            dwResourceIndex, 
            &dwObjectType, 
            lpwszResourceName,
            &dwClusterEnumResourceNameLength )) )
	{
		//
		// If we have a resource's name
		//
		if( ERROR_SUCCESS == dwResultClusterEnum )
		{

      hResource = OpenClusterResource( hCluster, lpwszResourceName );

			if ( !hResource )
			{
				dwError = GetLastError();
				break;
			}

            // If the resource type is "IIS Server Instance", or some other one that is 
            // dependent upon the iis services, then we probably stopped, it.
            iClusDependsOnIISServices = CheckForIISDependentClusters(hResource);
			if (iClusDependsOnIISServices)
			{
	            CLUSTER_RESOURCE_STATE TheState = GetClusterResourceState(hResource,NULL,0,NULL,0);
	            if (TheState == ClusterResourceOffline || TheState == ClusterResourceOfflinePending)
	            {
                    int iRestart = FALSE;
                    LPWSTR lpwsResourceName = NULL;

                    HKEY hKey;
                    hKey = GetClusterResourceKey( hResource, KEY_READ );

                    if ( hKey )
                    {
                        //
                        // Get the resource name.
                        //
                        lpwsResourceName = GetParameter( hKey, L"Name" );
                        if ( lpwsResourceName != NULL ) 
                        {
                            iRestart = ListOfClusResources_Check(lpwsResourceName);
                        }
                        ClusterRegCloseKey(hKey);
                    }

                    if (TRUE == iRestart)
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("OnlineClusterResource:'%s'.\n"),lpwsResourceName));
                        OnlineClusterResource(hResource);
                        if (lpwsResourceName){LocalFree((LPWSTR) lpwsResourceName);}
                    }
			    }
            }
            CloseClusterResource( hResource );
		
			dwResourceIndex++;
		}
			
        //
        // If the buffer wasn't large enough then retry with a larger buffer
        //
        if( ERROR_MORE_DATA == dwResultClusterEnum )
        {
            //
            // Set the buffer size to the required size reallocate the buffer
            //
            LPWSTR lpwszResourceNameTmp = lpwszResourceName;

            //
            // After returning from ClusterEnum dwClusterEnumResourceNameLength 
            // doesn't include the null terminator character
            //
            dwResourceNameBufferLength = dwClusterEnumResourceNameLength + 1;
            lpwszResourceName = (LPWSTR) LocalReAlloc (lpwszResourceName, dwResourceNameBufferLength * sizeof(WCHAR), 0);

            if ( !lpwszResourceName )
            {
                dwError = GetLastError();

                LocalFree( lpwszResourceNameTmp );	
                lpwszResourceNameTmp = NULL;
                break;
            }
        }

		//
		// Reset dwResourceNameLength with the size of the number of characters in the buffer
		// You have to do this because everytime you call ClusterEnum is sets your buffer length 
		// argument to the number of characters in the string it's returning.
		//
		dwClusterEnumResourceNameLength = dwResourceNameBufferLength;
	}	


clean_up:
    if ( lpwszResourceName )
    {
        LocalFree( lpwszResourceName );
        lpwszResourceName = NULL;
    }

    if ( hClusResEnum )
    {
        ClusterCloseEnum( hClusResEnum );
        hClusResEnum = NULL;
    }

    if ( hCluster )
    {
        CloseCluster( hCluster );
        hCluster = NULL;
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOnline:end.ret=0x%x\n"),dwError));
    return dwError;
}


LPWSTR GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )
/*++
Routine Description:

    Reads a REG_SZ parameter from the cluster regitry, and allocates the
    necessary storage for it.

Arguments:

    ClusterKey - supplies the cluster key where the parameter is stored.

    ValueName - supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter value on success.

    NULL on failure.

--*/
{
    LPWSTR  value = NULL;
    DWORD   valueLength;
    DWORD   valueType;
    DWORD   status;

    valueLength = 0;
    status = ClusterRegQueryValue( ClusterKey,ValueName,&valueType,NULL,&valueLength );
    if ( (status != ERROR_SUCCESS) && (status != ERROR_MORE_DATA) ) 
    {
        SetLastError(status);
        return(NULL);
    }
    if ( valueType == REG_SZ ) 
    {
        valueLength += sizeof(UNICODE_NULL);
    }

    value = (LPWSTR) LocalAlloc(LMEM_FIXED, valueLength);
    if ( value == NULL ) 
        {return(NULL);}
    status = ClusterRegQueryValue(ClusterKey,ValueName,&valueType,(LPBYTE)value,&valueLength);
    if ( status != ERROR_SUCCESS) 
    {
        LocalFree(value);
        SetLastError(status);
        value = NULL;
    }
    return(value);
}


INT CheckForIISDependentClusters(HRESOURCE hResource)
{
    INT iReturn = FALSE;

	// If the resource type is "IIS Server Instance", 
	// "SMTP Server Instance" or "NNTP Server Instance" then take it offline
    iReturn = ResUtilResourceTypesEqual(IIS_RESOURCE_TYPE_NAME, hResource);
    if (!iReturn){iReturn = ResUtilResourceTypesEqual(SMTP_RESOURCE_TYPE_NAME, hResource);}
    if (!iReturn){iReturn = ResUtilResourceTypesEqual(NNTP_RESOURCE_TYPE_NAME, hResource);}

    // check for other ones which might be listed in the inf file!
    if (!iReturn && g_pTheApp->m_hInfHandle)
    {
        CStringList strList;
        TSTR        strTheSection;

        if ( strTheSection.Copy( _T("ClusterResType_DependsonIIS") ) &&
             GetSectionNameToDo(g_pTheApp->m_hInfHandle, &strTheSection)
           )
        {
            if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, strTheSection.QueryStr() ))
            {
                // loop thru the list returned back
                if (strList.IsEmpty() == FALSE)
                {
                    POSITION pos;
                    CString csEntry;

                    pos = strList.GetHeadPosition();
                    while (pos) 
                    {
                        csEntry = strList.GetAt(pos);

                        int iTempReturn = FALSE;
                        iTempReturn = ResUtilResourceTypesEqual(csEntry, hResource);
                        if (iTempReturn)
                        {
                            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CheckForIISDependentClusters:yes='%s'\n"),csEntry));
                            iReturn = TRUE;
                            break;
                        }
                        strList.GetNext(pos);
                    }
                }
            }
        }
    }

    return iReturn;
}


DWORD WINAPI DoesThisServiceTypeExistInCluster(PVOID pInfo)
{
    INT iTemp = FALSE;
    CLUSTER_SVC_INFO_FILL_STRUCT * pMyStructOfInfo;
    pMyStructOfInfo = (CLUSTER_SVC_INFO_FILL_STRUCT *) pInfo;

    //pMyStructOfInfo->szTheClusterName
    //pMyStructOfInfo->pszTheServiceType
    //pMyStructOfInfo->csTheReturnServiceResName
    //pMyStructOfInfo->dwReturnStatus

	//
	// The return code
	//
    DWORD dwReturn = ERROR_NOT_FOUND;
    pMyStructOfInfo->dwReturnStatus = dwReturn;

	//
	// Handle for the cluster
	//
	HCLUSTER hCluster = NULL;

	//
	// Handle for the cluster enumerator
	//
	HCLUSENUM hClusResEnum = NULL;

	//
	// Handle to a resource
	// 
	HRESOURCE hResource = NULL;

	//
	// The index of the resources we're taking offline
	//
	DWORD dwResourceIndex = 0;

	//
	// The type cluster object being enumerated returned by the ClusterEnum function
	//
	DWORD dwObjectType = 0;

	//
	// The name of the cluster resource returned by the ClusterEnum function
	//
	LPWSTR lpwszResourceName = NULL;
	
	//
	// The return code from the call to ClusterEnum
	//
	DWORD dwResultClusterEnum = ERROR_SUCCESS;

	//
	// The size of the buffer (in characters) that is used to hold the resource name's length
	//	
	DWORD dwResourceNameBufferLength = INITIAL_RESOURCE_NAME_SIZE;

	//
	// Size of the resource name passed to and returned by the ClusterEnum function
	//	
	DWORD dwClusterEnumResourceNameLength = dwResourceNameBufferLength;

    //
    //  Open the cluster
    //
    hCluster = OpenCluster(pMyStructOfInfo->szTheClusterName);
    if( !hCluster )
    {
        dwReturn = GetLastError();
        goto DoesThisServiceTypeExistInCluster_Exit;	
    }

    //
    // Get Enumerator for the cluster resouces
    // 
    hClusResEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );

    if ( !hClusResEnum )
    {
        dwReturn = GetLastError();
        goto DoesThisServiceTypeExistInCluster_Exit;	
    }

    //
    // Enumerate the Resources in the cluster
    // 
	
    //
    // Allocate memory to hold the cluster resource name as we enumerate the resources
    //
    lpwszResourceName = (LPWSTR) LocalAlloc(LPTR, dwResourceNameBufferLength * sizeof(WCHAR));

    if ( !lpwszResourceName )
    {
        dwReturn = GetLastError();
        goto DoesThisServiceTypeExistInCluster_Exit;
    }

    // 
    // Enumerate all of the resources in the cluster
    //
    while( ERROR_NO_MORE_ITEMS  != (dwResultClusterEnum = ClusterEnum(hClusResEnum,dwResourceIndex,&dwObjectType,lpwszResourceName,&dwClusterEnumResourceNameLength)) )
    {
        //
        // If we have a resource's name
        //
		if( ERROR_SUCCESS == dwResultClusterEnum )
		{
      hResource = OpenClusterResource( hCluster, lpwszResourceName );

			if ( !hResource )
			{
				dwReturn = GetLastError();
				break;
			}

            // If the resource type is "IIS Server Instance", or one that depends upon iis like smtp or nntp then
            // check further to see if they have our services (W3SVC or MSFTPSVC)

            iTemp = ResUtilResourceTypesEqual(IIS_RESOURCE_TYPE_NAME, hResource);
            if (!iTemp){iTemp = ResUtilResourceTypesEqual(SMTP_RESOURCE_TYPE_NAME, hResource);}
            if (!iTemp){iTemp = ResUtilResourceTypesEqual(NNTP_RESOURCE_TYPE_NAME, hResource);}

            if (TRUE == iTemp)
            {
                // if the resource hangs it will hang on this call
                pMyStructOfInfo->dwReturnStatus = ERROR_INVALID_BLOCK;
                if (ERROR_SUCCESS == IsResourceThisTypeOfService(hResource, pMyStructOfInfo->pszTheServiceType))
                {
                    CString csResName;
                    //
                    // Yes! we found it
                    //
                    dwReturn = ERROR_SUCCESS;

                    // Display the resource name for fun
                    if (TRUE == GetClusterResName(hResource, &csResName))
                    {
                        // copy it to the return string
                        *pMyStructOfInfo->csTheReturnServiceResName = csResName;
                    }

                    CloseClusterResource( hResource );
                    goto DoesThisServiceTypeExistInCluster_Exit;
                }
                dwReturn = ERROR_NOT_FOUND;
			    CloseClusterResource( hResource );
            }
			
			dwResourceIndex++;
		}

		//
		// If the buffer wasn't large enough then retry with a larger buffer
		//
		if( ERROR_MORE_DATA == dwResultClusterEnum )
		{
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			LPWSTR lpwszResourceNameTmp = lpwszResourceName;

			//
			// After returning from ClusterEnum dwClusterEnumResourceNameLength 
			// doesn't include the null terminator character
			//
			dwResourceNameBufferLength = dwClusterEnumResourceNameLength + 1;
      lpwszResourceName = (LPWSTR) LocalReAlloc (lpwszResourceName, dwResourceNameBufferLength * sizeof(WCHAR), 0);

			if ( !lpwszResourceName )
			{
                dwReturn = GetLastError();

				LocalFree( lpwszResourceNameTmp );	
				lpwszResourceNameTmp = NULL;
				break;
			}
		}

		//
		// Reset dwResourceNameLength with the size of the number of characters in the buffer
		// You have to do this because everytime you call ClusterEnum is sets your buffer length 
		// argument to the number of characters in the string it's returning.
		//
		dwClusterEnumResourceNameLength = dwResourceNameBufferLength;
	}	


DoesThisServiceTypeExistInCluster_Exit:
	if ( lpwszResourceName )
	{
		LocalFree( lpwszResourceName );
		lpwszResourceName = NULL;
	}
	
	if ( hClusResEnum )
	{
		ClusterCloseEnum( hClusResEnum );
		hClusResEnum = NULL;
	}

	if ( hCluster )
	{
		CloseCluster( hCluster );
		hCluster = NULL;
	}

    pMyStructOfInfo->dwReturnStatus = dwReturn;
    return dwReturn;
}


DWORD IsResourceThisTypeOfService(HRESOURCE hResource, LPWSTR pszTheServiceType)
{
    DWORD dwReturn = ERROR_NOT_FOUND;
    HINSTANCE hClusapi  = NULL;
    HINSTANCE hResutils = NULL;

    PFN_CLUSTERRESOURCECONTROL      pfnClusterResourceControl;
    PFN_RESUTILFINDSZPROPERTY       pfnResUtilFindSzProperty;

	//
	// Initial size of the buffer
	//
	DWORD dwBufferSize = 256;
	
	//
	// The requested buffer size, and the number of bytes actually in the returned buffer
	//
	DWORD dwRequestedBufferSize = dwBufferSize;

	//
	// Result from the call to the cluster resource control function
	//
	DWORD dwResult;

	//
	// Buffer that holds the property list for this resource
	//
	LPVOID lpvPropList = NULL;

	//
	// The Proivate property that is being read
	//
	LPWSTR lpwszPrivateProp = NULL;

    //
    // Load cluster dll's
    //
    hClusapi = LoadLibrary( L"clusapi.dll" );
    if (!hClusapi)
        {
        dwReturn = ERROR_PATH_NOT_FOUND;
        goto IsResourceThisTypeOfService_Exit;
        }

    pfnClusterResourceControl = (PFN_CLUSTERRESOURCECONTROL)GetProcAddress( hClusapi, "ClusterResourceControl" );
    if (!pfnClusterResourceControl)
        {
        dwReturn = ERROR_PROC_NOT_FOUND;
        goto IsResourceThisTypeOfService_Exit;
        }

    hResutils = LoadLibrary( L"resutils.dll" );
    if (!hResutils)
        {
        dwReturn = ERROR_PATH_NOT_FOUND;
        goto IsResourceThisTypeOfService_Exit;
        }
    pfnResUtilFindSzProperty = (PFN_RESUTILFINDSZPROPERTY)GetProcAddress( hResutils, "ResUtilFindSzProperty" );
    if (!pfnResUtilFindSzProperty)
        {
        dwReturn = ERROR_PROC_NOT_FOUND;
        goto IsResourceThisTypeOfService_Exit;
        }

	//
	// Allocate memory for the resource type
	//
	lpvPropList = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, dwBufferSize * sizeof(WCHAR) );
	if( lpvPropList == NULL)
	{
		lpvPropList = NULL;
        dwReturn = ERROR_OUTOFMEMORY;
        goto IsResourceThisTypeOfService_Exit;
	}

	//
	// Allocate memory for the Property
	//
	lpwszPrivateProp = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (_MAX_PATH+_MAX_PATH+1) * sizeof(WCHAR) );
	if( lpwszPrivateProp == NULL)
	{
		lpvPropList = NULL;
        dwReturn = ERROR_OUTOFMEMORY;
        goto IsResourceThisTypeOfService_Exit;
	}
	
	//
	// Get the resource's private properties (Service , InstanceId)
	//
	while( 1 )
	{
		dwResult = pfnClusterResourceControl(hResource,NULL,CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,NULL,0,lpvPropList,dwBufferSize,&dwRequestedBufferSize );
		if( ERROR_SUCCESS == dwResult )
		{

            // ---------------------
            // what the entries are:
            // AccessMask (dword) = 5
            // Alias (string)     = "virtual dir name"
            // Directory (string) = "c:\la\lalalala"
            // ServiceName (string) = W3SVC, MSFTPSVC, GOPHERSVC
            // ---------------------

            //
            // Get the "ServiceName" entry
            //
            dwResult = pfnResUtilFindSzProperty( lpvPropList, &dwRequestedBufferSize, L"ServiceName", &lpwszPrivateProp);
			if( dwResult != ERROR_SUCCESS )
			{
                dwReturn = dwResult;
                goto IsResourceThisTypeOfService_Exit;
			}

            if (_wcsicmp(lpwszPrivateProp, pszTheServiceType) == 0)
            {
                // Okay, we found at least 1 service name that matches
                // the one that was passed -- which we're supposed to look for
                // return success
                dwReturn = ERROR_SUCCESS;
            }
            goto IsResourceThisTypeOfService_Exit;
		}

		if( ERROR_MORE_DATA == dwResult )
		{
      LPVOID lpdPropListTemp = lpvPropList;
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			dwBufferSize = ++dwRequestedBufferSize;

			lpvPropList = (LPWSTR) HeapReAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, lpvPropList, dwBufferSize * sizeof(WCHAR) );
			if ( lpvPropList == NULL)
			{
        if ( lpdPropListTemp )
        {
          HeapFree( GetProcessHeap(), 0, lpdPropListTemp );
        }
        dwReturn = ERROR_OUTOFMEMORY;
        goto IsResourceThisTypeOfService_Exit;
			}
		}
	}

IsResourceThisTypeOfService_Exit:
    if (lpwszPrivateProp)
        {HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpwszPrivateProp);}
    if (lpvPropList)
        {HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpvPropList);}
    if (hClusapi)
        {FreeLibrary(hClusapi);}
    if (hResutils)
        {FreeLibrary(hClusapi);}
   
    return dwReturn;
}


INT GetClusterResName(HRESOURCE hResource, CString * csReturnedName)
{
    int iReturn = FALSE;
    HKEY hKey = GetClusterResourceKey( hResource, KEY_READ );

    if ( hKey )
    {
        //
        // Get the resource name.
        //
        LPWSTR lpwsResourceName = NULL;
        lpwsResourceName = GetParameter( hKey, L"Name" );
        if ( lpwsResourceName != NULL ) 
        {
            //wcscpy(csReturnedName,lpwsResourceName);
            *csReturnedName = lpwsResourceName;
            iReturn = TRUE;
        }
        if (lpwsResourceName){LocalFree((LPWSTR) lpwsResourceName);}

        ClusterRegCloseKey(hKey);
    }
    return iReturn;
}




INT DoClusterServiceCheck(CLUSTER_SVC_INFO_FILL_STRUCT * pMyStructOfInfo)
{
    int iReturn = FALSE;
    DWORD ThreadID = 0;
    DWORD status = 0;
   
    HANDLE hMyThread = CreateThread(NULL,0,DoesThisServiceTypeExistInCluster,pMyStructOfInfo,0,&ThreadID);
    if (hMyThread)
    {
        // wait for 30 secs only
        DWORD res = WaitForSingleObject(hMyThread,30*1000);
        if (res == WAIT_TIMEOUT)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ERROR DoClusterServiceCheck thread never finished...\n")));
		    GetExitCodeThread(hMyThread, &status);
		    if (status == STILL_ACTIVE) 
            {
			    if (hMyThread != NULL)
                    {TerminateThread(hMyThread, 0);}
		    }
        }
        else
        {
            GetExitCodeThread(hMyThread, &status);
		    if (status == STILL_ACTIVE) 
            {
			    if (hMyThread != NULL)
                    {TerminateThread(hMyThread, 0);}
		    }
            else
            {
                if (ERROR_SUCCESS == status)
                    {iReturn = TRUE;}
            }

            if (hMyThread != NULL)
                {CloseHandle(hMyThread);}
        }
    }

    return iReturn;
}


INT DoesClusterServiceExist(void)
{
    if (-1 == g_ClusterSVCExist)
    {
        CRegKey regClusSvc(HKEY_LOCAL_MACHINE, scClusterPath2, KEY_READ);
        if ( (HKEY) regClusSvc )
        {
            g_ClusterSVCExist = 1;
        }
        else
        {
            g_ClusterSVCExist = 0;
        }
    }
    return g_ClusterSVCExist;
}
#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\www.h ===
#include "stdafx.h"

int CheckIfThisServerHasAUserThenUseIt(int iForWhichUser);
int CheckIfServerAHasAUserThenUseForServerB(TCHAR *szServerAMetabasePath,int iServerBisWhichUser);
int MakeThisUserNameAndPasswordWork(int iForWhichUser, TCHAR *szAnonyName,TCHAR *szAnonyPassword, int iMetabaseUserExistsButCouldntGetPassword, int IfUserNotExistThenReturnFalse);
int LoopThruW3SVCInstancesAndSetStuff();
#ifndef _CHICAGO_
    int Register_iis_www_handle_iusr_acct(void);
    int Register_iis_www_handle_iwam_acct(void);
    int CheckForOtherIUsersAndUseItForWWW(void);
#endif
INT Register_iis_www();
INT Unregister_iis_www();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\sld\makefile.inc ===
iCPU=$(PROCESSOR_ARCHITECTURE)

!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\main.cpp ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        updurls2.cpp

   Abstract:

        The main for the Project

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/

// updurls2.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "windows.h"
#include "urlscan.h"
#include "resource.h"

BOOL CheckParameters( int argc, _TCHAR* argv[], BOOL *bQuietMode, BOOL *bExpandOnly );

// ShowMessage
//
// Show either a warning or a message to the user
//
// Parameters:
//   dwMessageId - The id of the message
//   bError - TRUE == error, FALSE == informative
//
// This does not return anything, because there would be no 
// point.  By this time we have failed or not, and there
// is not additional way to notify the user
//
void ShowMessage( DWORD dwMessageId, BOOL bError )
{
  HMODULE hModule = GetModuleHandle( NULL );
  TCHAR   szMessage[MAX_PATH];
  TCHAR   szTitle[MAX_PATH];

  if ( hModule == NULL )
  {
    // Could not get handle to module
    return;
  }

  if ( !LoadString( hModule, dwMessageId, szMessage, MAX_PATH ) )
  {
    // Failed to Retrieve Message
    return;
  }

  if ( !LoadString( hModule, IDS_TITLEBAR, szTitle, MAX_PATH ) )
  {
    // Failed to Retrieve Title
    return;
  }

  MessageBox( NULL, szMessage, szTitle, MB_OK | ( bError ? MB_ICONEXCLAMATION : MB_ICONINFORMATION ) );
}

// ShowText
//
// Show text out to the console
//
// Parameters:
//   dwMessageId - The id of the message
//   szExeName - The name of this executable
//
// This does not return anything, because there would be no 
// point.  By this time we have failed or not, and there
// is not additional way to notify the user
//
void ShowText( DWORD dwMessageId, LPWSTR szExeName )
{
  HMODULE hModule = GetModuleHandle( NULL );
  TCHAR   szMessage[MAX_PATH];

  if ( hModule == NULL )
  {
    // Could not get handle to module
    return;
  }

  if ( !LoadString( hModule, dwMessageId, szMessage, MAX_PATH ) )
  {
    // Failed to Retrieve Message
    return;
  }

  wprintf(szMessage, szExeName);
}

// UrlScanUpdate
//
// Update the URLScan files
DWORD
UrlScanUpdate()
{
  TCHAR szUrlScanPath[ MAX_PATH ];
  DWORD dwErr;

  if ( !IsAdministrator() )
  {
    return IDS_ERROR_ADMIN;
  }

  if ( !IsUrlScanInstalled( szUrlScanPath, MAX_PATH ) )
  {
    return IDS_ERROR_NOTINSTALLED;
  }

  dwErr = InstallURLScanFix( szUrlScanPath );

  if ( dwErr != ERROR_SUCCESS )
  {
    // Failure, IDS resource should be returned
    return dwErr;
  }

  // This is very cosmetic thing, so we do not want to
  // fail for this reason
  UpdateRegistryforAddRemove();

  // Success
  return IDS_SUCCESS_UPDATE;
}

// CheckParameters
// 
// Check Parameters for command line flags
//
// Parameters:
//   argc         - [in]  Number of arguments
//   argv         - [in]  The list of arguments
//   bQuietMode   - [out] Is Quiet Mode Turned On?
//   bExpandOnly  - [out] Is Expand Only turned on?
//
// Return values:
//   TRUE - Read Parameters without a problem
//   FALSE - Failed to read parameters
//
BOOL 
CheckParameters( int argc, _TCHAR* argv[], BOOL *bQuietMode, BOOL *bExpandOnly )
{
  DWORD dwCount;

  // SET Defaults
  *bQuietMode = FALSE;
  *bExpandOnly = FALSE;

  for ( dwCount = 1; dwCount < (DWORD) argc; dwCount ++ )
  {
    if ( ( argv[ dwCount ][0] != '/' ) ||
         ( argv[ dwCount ][1] == '\0' ) ||
         ( argv[ dwCount ][2] != '\0' )
       )
    {
      return FALSE;
    }

    // Because if previous "if", command must be in the form "/x\0" where 
    // x is any character but '\0'
    switch ( argv[ dwCount ][1] )
    {
    case 'x':
    case 'X':
      *bExpandOnly = TRUE;
      break;
    case 'q':
    case 'Q':
      *bQuietMode = TRUE;
      break;
    default:
      return FALSE;
      break;
    }
  }

  return TRUE;
}

int __cdecl wmain(int argc, _TCHAR* argv[])
{
  BOOL  bExpandOnly;
  BOOL  bQuietMode;
  BOOL  bRet = TRUE;
  DWORD dwErr;

  if ( !CheckParameters( argc, argv, &bQuietMode, &bExpandOnly ) )
  {
    ShowText( IDS_USAGE, ( argv && argv[0] ) ? argv[0] : 
                                               URLSCAN_UPDATE_DEFAULT_NAME );
    return 1;
  }

  if ( bExpandOnly )
  {
    // Only Expansion is wanted, so only do that.
    if ( ExtractUrlScanFile( URLSCAN_DEFAULT_FILENAME ) )
    {
      dwErr = IDS_SUCCESS_EXTRACT;
    }
    else
    {
      dwErr = IDS_ERROR_EXTRACT;
    }
  }
  else
  {
    dwErr = UrlScanUpdate();
  }

  bRet = ( dwErr == IDS_SUCCESS_EXTRACT ) ||
         ( dwErr == IDS_SUCCESS_UPDATE  );

  if ( !bQuietMode )
  {
    ShowMessage( dwErr, !bRet );
  }

  // Return 0 or 1 depending on if there is an error or not
  return bRet ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\xmlupgrade.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        xmlupgrade.cxx

   Abstract:

        Classes that are used to upgrade the xml metabase and mbschema from
        one version to another

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       September 2001: Created

--*/

#include "stdafx.h"
#include "buffer.hxx"
#include "xmlupgrade.hxx"
#include "acl.hxx"

// Constructor, initialize all the variables
//
CFileModify::CFileModify()
{
  m_hReadFile = INVALID_HANDLE_VALUE;
  m_hWriteFile = INVALID_HANDLE_VALUE;
  m_buffData.Resize(CFILEMODIFY_BLOCKSIZE + 2);
  m_szCurrentData = (LPBYTE) m_buffData.QueryPtr();
  m_dwSizeofData = 0;
  m_bUnicode = FALSE;
  *m_szReadFileName = '\0';
  *m_szWriteFileName = '\0';
  SetValue(m_szCurrentData, '\0');
}

// Destructor, close the file
//
CFileModify::~CFileModify()
{
  // Just incase it has not been closed yet, close it
  CloseFile();
}

// function: MoveXChars
//
// Move the pointer the number of characters specified
//
// Parameters:
//   szCurrent - Pointer to a unicode or ansi string 
//                (type is determined by m_m_bUnicode)
//
// Return:
//    Pointer to szCurrent + dwChars
//
LPBYTE 
CFileModify::MoveXChars(LPBYTE szCurrent, DWORD dwChars)
{
  if ( m_bUnicode )
  {
    return (LPBYTE) ( ( ( LPWSTR ) szCurrent ) + dwChars );
  }
  else
  {
    return (LPBYTE) ( ( ( LPSTR ) szCurrent ) + dwChars );
  }
}

LPBYTE 
CFileModify::MoveXChars(LPVOID szCurrent, DWORD dwChars)
{
  return MoveXChars( (LPBYTE) szCurrent, dwChars );
}

// function: SetValue
//
// Set the value at the location specified
//
// Parameters:
//   szCurrent - Pointer to a unicode or ansi string 
//                (type is determined by m_m_bUnicode)
//   dwValue - The value to put in the string
//   dwOffset - Offset to add to szCurrent (in chars) (default of 0)
//
void 
CFileModify::SetValue(LPBYTE szCurrent, DWORD dwValue, DWORD dwOffset )
{
  LPBYTE szNewLocation = szCurrent;

  if ( dwOffset )
  {
    szNewLocation = MoveXChars(szCurrent,dwOffset);
  }

  if ( m_bUnicode )
  {
    * ( ( LPWSTR ) szNewLocation ) = (WCHAR) dwValue;
  }
  else
  {
    * ( ( LPSTR ) szNewLocation ) = (CHAR) dwValue;
  }
}

void 
CFileModify::SetValue(PVOID szCurrent, DWORD dwValue, DWORD dwOffset )
{
  SetValue( (LPBYTE) szCurrent,dwValue,dwOffset);
}

// function: CopyString
//
// Copy a string into the buffer
void 
CFileModify::CopyString(LPBYTE szCurrent, LPTSTR szInsertString)
{
  while ( *szInsertString )
  {
    SetValue(szCurrent,*szInsertString);
    GetNextChar(szCurrent);
    szInsertString++;
  }
}

// function: AbortFile
//
// Abort the current file modification.  So, we close the file handles, and delete the 
// file that we wrote to
//
BOOL
CFileModify::AbortFile()
{
  BOOL bRet = TRUE;

  if (m_hReadFile != INVALID_HANDLE_VALUE)
  {
    CloseHandle(m_hReadFile);
    m_hReadFile = INVALID_HANDLE_VALUE;
  }

  if (m_hWriteFile != INVALID_HANDLE_VALUE)
  {
    CloseHandle(m_hWriteFile);
    m_hWriteFile = INVALID_HANDLE_VALUE;
    bRet = DeleteFile( m_szWriteFileName );
  }

  return bRet;
}

// function: CloseFile
//
// Close all of the files, and write all the data to disk
//
BOOL
CFileModify::CloseFile()
{
  BOOL bWrite = m_hWriteFile != INVALID_HANDLE_VALUE;
  BOOL bRet = TRUE;

  if ( bWrite )
  {
    // Dump the rest of the input file to the output one.
    while ( ReadNextChunk() )
    {
      // Move to the end of the block, so it will all be written
      m_szCurrentData = MoveXChars( m_buffData.QueryPtr(), m_dwSizeofData );
    }

    if ( m_dwSizeofData )
    {
      // The last ReadNextChunk failed because we could not read anymore,
      // lets call it one more time to flush the rest of the data in the buffer
      m_szCurrentData = MoveXChars( m_buffData.QueryPtr(), m_dwSizeofData );
      ReadNextChunk();
    }
  }

  if (m_hReadFile != INVALID_HANDLE_VALUE)
  {
    CloseHandle(m_hReadFile);
    m_hReadFile = INVALID_HANDLE_VALUE;
  }

  if (m_hWriteFile != INVALID_HANDLE_VALUE)
  {
    CloseHandle(m_hWriteFile);
    m_hWriteFile = INVALID_HANDLE_VALUE;
  }

  if ( bWrite )
  {
    bRet = FALSE;
    if ( DeleteFile( m_szReadFileName ) )
    {
      MoveFile( m_szWriteFileName, m_szReadFileName );
      bRet = TRUE;
    }
  }

  return bRet;
}

// function: OpenFile
//
// This function opens a readonly handle to the file specified in szFileName,
// also a second File handle will be opened with write only access under the 
// name szFileName+".tmp".  This is for temporary storage for the new file
//
// Parameters:
//   szFileName - The filename of the file to read
//   bModify - Are we going to be modifing this file or not?
//
// Return
//   TRUE - Read and Write files we successfully opened
//   FALSE - Failure to open one of the files
//
BOOL
CFileModify::OpenFile(LPTSTR szFileName, BOOL bModify)
{
  CSecurityDescriptor AdminAcl;

  if ( ( _tcslen(szFileName) - _tcslen(_T(".tmp")) ) >= _MAX_PATH )
  {
    return FALSE;
  }

  if ( !AdminAcl.CreateAdminDAcl() )
  {
    // We could not create an admin acl, so lets exit
    return FALSE;
  }

  // First abort the last file, if one was opened
  AbortFile();

  _tcscpy(m_szReadFileName,szFileName);
  _tcscpy(m_szWriteFileName,szFileName);
  _tcscat(m_szWriteFileName,_T(".tmp"));

  m_hReadFile = CreateFile( m_szReadFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );

  if ( m_hReadFile == INVALID_HANDLE_VALUE )
  {
    return FALSE;
  }
  
  if ( bModify )
  {
    m_hWriteFile = CreateFile( m_szWriteFileName,
                             GENERIC_WRITE,
                             0,
                             AdminAcl.QuerySA(),
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_TEMPORARY,
                             NULL );

    if ( m_hWriteFile == INVALID_HANDLE_VALUE )
    {
      // Close Read File and return
      AbortFile();
      return FALSE;
    }
  }

  m_szCurrentData = (LPBYTE) m_buffData.QueryPtr();
  m_dwSizeofData = 0;
  m_bUnicode = FALSE;

  if ( ReadNextChunk() )
  {

    if ( ( m_dwSizeofData > 3 ) &&
         ( *( ( LPBYTE ) m_buffData.QueryPtr() ) == 0xEF ) &&
         ( *( ( LPBYTE ) m_buffData.QueryPtr() + 1 ) == 0xBB ) &&
         ( *( ( LPBYTE ) m_buffData.QueryPtr() + 2 ) == 0xBF )
       )
    {
      // It is UTF8 Encoded
      m_bUnicode = FALSE;
      m_szCurrentData = (LPBYTE) m_buffData.QueryPtr() + 3;
    }
    else if ( ( m_dwSizeofData >= 2 ) &&
              ( *( ( LPBYTE ) m_buffData.QueryPtr() ) == 0xFF ) &&
              ( *( ( LPBYTE ) m_buffData.QueryPtr() + 1 ) == 0xFE)
            )
      {
        // It is Unicode
        m_bUnicode = TRUE;
        m_szCurrentData = (LPBYTE) m_buffData.QueryPtr() + 2;
      }
  }

  return TRUE;
}

// function: ResizeData
//
// Resize the data buffer to the size specified
// never shrink the buffer itself, just exand it
//
// Parameters:
//   dwNewSize - The new size needed
BOOL 
CFileModify::ResizeData(DWORD dwNewSize)
{
  BOOL bRet = TRUE;

  if (m_buffData.QuerySize() < (dwNewSize + 2) )
  {
    DWORD dwCurrentOffset = (DWORD) (DWORD_PTR) (m_szCurrentData - (LPBYTE) m_buffData.QueryPtr());

    if ( !m_buffData.Resize(dwNewSize + 2) )
    {
      // We failed to allocate the memory necessary
      bRet = FALSE;
    }

    if (dwCurrentOffset <= dwNewSize)
    {
      m_szCurrentData = (LPBYTE) m_buffData.QueryPtr() + dwCurrentOffset;
    }
    else
    {
      ASSERT(FALSE);
      m_szCurrentData = (LPBYTE) m_buffData.QueryPtr();
    }
  }

  return bRet;
}

// function: ResizeData
//
// Resize Data, and move the pointer accourdingly
//
BOOL 
CFileModify::ResizeData(DWORD dwNewSize, LPBYTE *szString)
{
  DWORD dwOffset = (DWORD) (DWORD_PTR) ( *szString - GetCurrentLocation() );
  BOOL bRet;

  bRet = ResizeData(dwNewSize);

  // Move current pointer to account for possible resizing of buffer
  *szString = GetCurrentLocation() + dwOffset;

  return bRet;
}


// function: ReadNextChunk
//
// Read in the next Chunk of Data, in order to do this, take the part of
// the chunck that has already been processed, and write it to the output
// file.  Then move the rest of the chunck over, so that you can read some
// more data in.  The divider between processed, and unprocessed is determined
// by the location of m_szCurrentData
//
// Data before:
//   |-------------------------------------------------------------|
//   | Used Data    | Currently using Data |  Extra Space          |
//   |-------------------------------------------------------------|
//
// Data after:
//   |-------------------------------------------------------------|
//   | Currently using Data |  New Data                            |
//   |-------------------------------------------------------------|
//
// Return:
//   TRUE - The next piece of data was correctly read in
//   FASLE - Their was an error, either reading from the file, or writing the 
//           data that we currently have to the output file.
BOOL 
CFileModify::ReadNextChunk()
{
  DWORD dwUsedSize;             // Size of Block used and done with (in bytes)
  DWORD dwCurrentlyUsingSize;   // Size of Data to keep
  DWORD dwExtraSpaceSize;       // Size of Free Space
  DWORD dwTotalChunkSize;
  DWORD dwSizeofCurrentChunk;

  if ( m_dwSizeofData != 0 )
  {
    dwUsedSize = (DWORD) ( ( (BYTE*) m_szCurrentData ) - ( (BYTE*) m_buffData.QueryPtr() ) );
    dwCurrentlyUsingSize = m_dwSizeofData - dwUsedSize;
    dwExtraSpaceSize = m_buffData.QuerySize() - dwCurrentlyUsingSize - 2;  // 2 for possible LPWSTR '\0'

    ASSERT( dwUsedSize <= m_dwSizeofData );  // Assert that the UsedSection is smaller that our overall section size
  }
  else
  {
    // We have not read anything in before, so initialize stuff
    dwUsedSize = 0;
    dwCurrentlyUsingSize = 0;
    dwExtraSpaceSize = m_buffData.QuerySize() - dwCurrentlyUsingSize - 2;
  }

  if ( dwUsedSize ) 
  {
    // Part of this block is done with, so lets write it to disk
    dwTotalChunkSize = dwUsedSize;
    dwSizeofCurrentChunk = 0;

    if ( m_hWriteFile != INVALID_HANDLE_VALUE )
    {
      LPBYTE pData = (LPBYTE) m_buffData.QueryPtr();

      // If we have a file open, then lets write to it, if not then we are read only
      while ( dwTotalChunkSize > 0 )
      {
        if ( ( !WriteFile(m_hWriteFile,                 // Handle to write file
                          pData,                        // Data to send
                          dwTotalChunkSize,             // # of Bytes to write
                          &dwSizeofCurrentChunk,        // Bytes Written
                          NULL ) ) ||
             ( dwSizeofCurrentChunk == 0 )
           )
        {
          // We had problems writing to disk, FAIL
          return FALSE;
        }

        pData += dwSizeofCurrentChunk;
        dwTotalChunkSize -= dwSizeofCurrentChunk;
      }
    }

    // Move Current Block
    memmove( m_buffData.QueryPtr(), m_szCurrentData, dwCurrentlyUsingSize + 2 );
    m_szCurrentData = ( (BYTE *) m_buffData.QueryPtr() );
    m_dwSizeofData -= dwUsedSize;
  }
  else if (dwCurrentlyUsingSize)
  {
    // If there is not data to take out of the buffer, and we have data in the buffer
    // Double the size of the buffer
    ResizeData( m_buffData.QuerySize() * 2 );
    dwExtraSpaceSize = m_buffData.QuerySize() - dwCurrentlyUsingSize - 2;  // 2 for possible LPWSTR '\0'
  }

  if ( dwExtraSpaceSize != 0 )
  {
    // There is space remaining in the block, so lets read the data in
    dwTotalChunkSize = dwExtraSpaceSize;
    dwSizeofCurrentChunk = 0;

    while ( dwTotalChunkSize > 0 )
    {
      if ( !ReadFile( m_hReadFile,
                     ( (BYTE *) m_buffData.QueryPtr() ) + dwCurrentlyUsingSize,
                     dwTotalChunkSize,
                     &dwSizeofCurrentChunk,
                     NULL ) )
      {
        // We could not read the chunk, so fail
        return FALSE;
      }

      if ( dwSizeofCurrentChunk == 0 )
      {
        if ( dwExtraSpaceSize == dwTotalChunkSize )
        {
          // If the extra space is the same as the totalchunksize, then we
          // haven't read anything yet, so return FALSE signifying that we
          // did not read anything from the file
          return FALSE;
        }

        // We are at the end of file, so break out.
        break;
      }

      dwTotalChunkSize -= dwSizeofCurrentChunk;
      dwCurrentlyUsingSize += dwSizeofCurrentChunk;
    }

    // Terminate Block
    m_dwSizeofData = dwCurrentlyUsingSize;
    SetValue(m_buffData.QueryPtr(),'\0',dwCurrentlyUsingSize / (m_bUnicode?2:1) );
  }

  return TRUE;
}

// function: MoveCurrentPtr
//
// Move the pointer in the array
//
// Parameters 
//   szCurrent - New Location
//
BOOL 
CFileModify::MoveCurrentPtr(LPBYTE szCurrent)
{
  if ( (szCurrent < m_buffData.QueryPtr()) || (szCurrent > ( (LPBYTE) m_buffData.QueryPtr() + m_buffData.QuerySize() ) ) )
  {
    // This is out of range, reject position
    ASSERT(FALSE);
    return FALSE;
  }

  m_szCurrentData = szCurrent;

  return TRUE;
}

// function: GetCurrentLocation
//
// return a pointer to the current location of the pointer
LPBYTE
CFileModify::GetCurrentLocation()
{
  return m_szCurrentData;
}

// function: GetBaseLocation
//
// return a pointer to the begining of the block
LPBYTE
CFileModify::GetBaseLocation()
{
  return (LPBYTE) m_buffData.QueryPtr();
}

// function: GetNextChar
// return the value of the next character
//
// Parameters:
//   szCurrent - Pointer to part of our m_buffData Block
//
// Return Value:
//   The unicode of ansi value for the next character
//
DWORD
CFileModify::GetNextChar(LPBYTE &szCurrent)
{
  DWORD dwValue;

  if ( m_bUnicode )
  {
    szCurrent = (LPBYTE) ( ( LPWSTR ) szCurrent) + 1;
    dwValue = *( ( LPWSTR ) szCurrent);
  }
  else
  {
    szCurrent = (LPBYTE) ( ( LPSTR ) szCurrent) + 1;
    dwValue = *( ( LPSTR ) szCurrent);
  }

  return dwValue;
}

// function: GetNextWideChar
//
// Return the value of the next wide character
//
// Return Value:
//   The unicode equivalent of the next character
//
DWORD 
CFileModify::GetNextWideChar(LPBYTE &szCurrent)
{
  if ( m_bUnicode )
  {
    szCurrent = (LPBYTE) ( ( LPWSTR ) szCurrent) + 1;
  }
  else
  {
    szCurrent = (LPBYTE) CharNextA( (LPSTR) szCurrent );
  }

  return GetWideChar( szCurrent );
}

// function: GetPrevChar
// return the value of pointer decremeted and dereferenced
//
// Parameters:
//   szCurrent - Pointer to part of our m_buffData Block
//
// Return Value:
//   The unicode of ansi value for the next character that is pointer at
//
DWORD
CFileModify::GetPrevChar(LPBYTE &szCurrent)
{
  DWORD dwValue;

  if ( m_bUnicode )
  {
    szCurrent = (LPBYTE) ( ( LPWSTR ) szCurrent) - 1;
    dwValue = *( ( LPWSTR ) szCurrent);
  }
  else
  {
    szCurrent = (LPBYTE) ( ( LPSTR ) szCurrent) - 1;
    dwValue = *( ( LPSTR ) szCurrent);
  }

  return dwValue;
}

// function: GetChar
// return the value of the current character
//
// Parameters:
//   szCurrent - Pointer to part of our m_buffData Block
//
// Return Value:
//   The unicode of ansi value for the character that is pointer at
//
DWORD
CFileModify::GetChar(LPBYTE szCurrent)
{
  if ( m_bUnicode )
  {
    return *( ( LPWSTR ) szCurrent );
  }
  else
  {
    return *( ( LPSTR ) szCurrent );
  }
}

// function: GetWideChar
//
// Get the Wide Char equivalent of the current character
//
WCHAR 
CFileModify::GetWideChar(LPBYTE szCurrent)
{
  if ( m_bUnicode )
  {
    return (WCHAR) *( ( LPWSTR ) szCurrent );
  }
  else
  {
    DWORD dwMBCSLen = (DWORD) ( ( (LPBYTE) CharNextA( (LPSTR) szCurrent ) ) - szCurrent );
    WCHAR wChar;

    if ( MultiByteToWideChar( CP_ACP,
                              MB_PRECOMPOSED,
                              (LPSTR) szCurrent,
                              dwMBCSLen,
                              &wChar,
                              sizeof(wChar)/sizeof(WCHAR) ) == 0 )
    {
      return 0;
    }
  
    return wChar;
  }
}

// function: MoveData
// 
// Expand or contract data in order to add a value or remove one
//
// Parameters:
//   szCurrent - A pointer to where the data will be removed/added
//   iBytes - The amount of data to remove or add
//
BOOL 
CFileModify::MoveData(LPBYTE szCurrent, INT iBytes)
{
  DWORD dwNewSize = ( (INT) m_dwSizeofData ) + iBytes;

  if ( !ResizeData(dwNewSize, &szCurrent) )
  {
    return FALSE;
  }

  if ( iBytes > 0 )
  {
    // Move bytes forward
    memmove( szCurrent + iBytes, szCurrent, m_dwSizeofData - ( szCurrent - (LPBYTE) m_buffData.QueryPtr() ) + 2 );
  }
  else
    if ( iBytes < 0 )
    {
      // Move bytes back
      memmove( szCurrent, szCurrent - iBytes, m_dwSizeofData - ( szCurrent - iBytes - (LPBYTE) m_buffData.QueryPtr() ) + 2 );
    }

  m_dwSizeofData = dwNewSize;

  return TRUE;
}

BOOL 
CFileModify::IsUnicode()
{
  return m_bUnicode;
}

// function: GetBufferSize
//
// return the size of the buffer used in this class
DWORD 
CFileModify::GetBufferSize()
{
  return (m_dwSizeofData);
}

// function: CXMLEdit
//
// Constructor for XMLEditor
//
CXMLEdit::CXMLEdit():
  m_dwItemOffset(0),
  m_dwPropertyOffset(0),
  m_dwValueOffset(0)
{

}

// function: ~CXMLEdit
//
// Destructor for XMLEditor
//
// Close Everything open
//
CXMLEdit::~CXMLEdit()
{
  XMLFile.CloseFile();
}

// function: Open
//
// Open the file to edit
//
BOOL
CXMLEdit::Open(LPTSTR szName, BOOL bModify )
{
  BOOL bRet;

  bRet = XMLFile.OpenFile(szName,bModify);

  if ( bRet )
  {
    SetCurrentItem(XMLFile.GetCurrentLocation());
  }

  return bRet;
}

// function: Close
//
// Close the xml file
//
BOOL 
CXMLEdit::Close()
{
  return XMLFile.CloseFile();
}

// function: MoveData
// 
// Move the data in the CFileModify.  This also means that we need to move our
// pointers into it.
//
// Parameters:
//   szCurrent - A pointer to where the data will be removed/added
//   iBytes - The amount of data to remove or add
//
BOOL 
CXMLEdit::MoveData(LPBYTE szCurrent, INT iBytes)
{
  return XMLFile.MoveData(szCurrent,iBytes);
}

// function: ReadNextChunk();
//
// ReadNextChunk of Data
//
BOOL    
CXMLEdit::ReadNextChunk()
{
  BOOL bRet;
  DWORD dwItemOffset = (DWORD) (DWORD_PTR) (GetCurrentItem() - XMLFile.GetCurrentLocation());
  DWORD dwPropertyOffset = (DWORD) (DWORD_PTR) (GetCurrentProperty() - XMLFile.GetCurrentLocation());
  DWORD dwValueOffset = (DWORD) (DWORD_PTR) (GetCurrentValue() - XMLFile.GetCurrentLocation());

  bRet = XMLFile.ReadNextChunk();

  // Since the CurrentLocation Pointer might have moved, move
  // our pointers as well!
  SetCurrentItem( ((LPBYTE) XMLFile.GetCurrentLocation()) + dwItemOffset );
  SetCurrentProperty( ((LPBYTE) XMLFile.GetCurrentLocation()) + dwPropertyOffset );
  SetCurrentValue( ((LPBYTE) XMLFile.GetCurrentLocation()) + dwValueOffset );

  return bRet;
}

// function: LoadFullItem
//
// Load the full item into memory, will all of it's properties before continuing
// The purpose of this is to make it much easier for other functions to scan
// through the buffer.  It is a lot simplier, it they can assume all the information
// they need is loaded.
//
// Parameters:
//   szPointerInsideBuffer [in/out] - This is a pointer to a something side of our
//        file buffer.  The purpose of this, is so that we can move this pointer
//        so that it points to the same data before we moved the buffer
void 
CXMLEdit::LoadFullItem()
{
  LPBYTE    szCurrent = GetCurrentItem();
  LPBYTE    szCurrentTemp;
  DWORD     cCurrent;
  BOOL      bContinue = TRUE;

  do {
    cCurrent = XMLFile.GetChar( szCurrent );
    szCurrentTemp = szCurrent;

    if ( (cCurrent == '<') ||
         (cCurrent == '>') ||
         ( (cCurrent == '/') && ( XMLFile.GetNextChar(szCurrentTemp) == '>' ) )
       )
    {
      // We have found the end
      return;
    }

    if ( cCurrent == '\0' )
    {
      // We have found the end of the string, try to get the next chunk
      if (!ReadNextChunk())
      {
        return;
      }

      // Start again at begining
      szCurrent = GetCurrentItem();
    }
    else
    {
      szCurrentTemp = szCurrent;
      szCurrent = SkipString(szCurrent);

      if (szCurrent == szCurrentTemp)
      {
        XMLFile.GetNextChar( szCurrent );
      }
    }

  } while (bContinue);

}

// function: FindNextItem
//
// Find the next item after the pointer that we are sent
//
// Parameters:
//   szStartLocation - A pointer to the current item
//   bReturnName - Return a pointer to the begining of the name
//
LPBYTE 
CXMLEdit::FindNextItem(LPBYTE szStartLocation, BOOL bReturnName)
{
  BOOL  bQuotes;
  LPBYTE szCurrent;
  DWORD dwItemOffset;

  if (!szStartLocation)
  {
    // We have no item to start at
    return NULL;
  }

  // Calculate offset for Start (incase pointer moves)
  dwItemOffset = (DWORD) (DWORD_PTR) (szStartLocation - XMLFile.GetCurrentLocation());

  do 
  {
    // Reset szCurrent to begining of current item
    szCurrent = XMLFile.GetCurrentLocation() + dwItemOffset;
    bQuotes = FALSE;

    while ( XMLFile.GetChar( szCurrent ) != '\0')
    {
      switch ( XMLFile.GetChar( szCurrent ) )
      {
      case '"':
        bQuotes = !bQuotes;
        break;
      case '<':
        if (!bQuotes)
        {
          LPBYTE szTempCurrent = szCurrent;

          // Move past '<'
          XMLFile.GetNextChar(szCurrent);

          while ( IsWhiteSpace( XMLFile.GetChar( szCurrent ) ) )
          {
            XMLFile.GetNextChar(szCurrent);
          }

          if (bReturnName)
          {
            szTempCurrent = szCurrent;
          }

          while ( ( XMLFile.GetChar( szCurrent ) != ' ') && ( XMLFile.GetChar( szCurrent ) != '\t') && ( XMLFile.GetChar( szCurrent ) != '\0') )
          {
            XMLFile.GetNextChar(szCurrent);
          }

          if ( XMLFile.GetChar( szCurrent ) != '\0')
          {
            // We could not read the whole name, because we are the end of what we
            // read in, so lets try this whole thing again
            return ( szTempCurrent );
          }

        }
        else
        {
          // Remove
          //ASSERT(FALSE);
        }
        break;
      default:
        break;
      }

      if ( XMLFile.GetChar( szCurrent ) != '\0' )
      {
        XMLFile.GetNextChar(szCurrent);
      }
    }

  } while ( ReadNextChunk() );

  return NULL;
}

// function: FindNextItem()
//
// find the next item.  This means to start at the item we are in, and get to the
// next one
//
// Parameters:
//   bReturnName - Skip the '<' at the beinging of the item, and return a pointer to the
//                 begining of the name
LPBYTE
CXMLEdit::FindNextItem(BOOL bReturnName)
{
  return FindNextItem(GetCurrentItem(),bReturnName);
}

// function: SkipString
//
// Skip over a string value, and the spaces trailing it
//
LPBYTE 
CXMLEdit::SkipString(LPBYTE szString, BOOL bSkipTrailingWhiteSpaces)
{
  BOOL bQuotes = FALSE;

  while ( XMLFile.GetChar( szString ) )
  {
    switch ( XMLFile.GetChar( szString ) )
    {
    case '"':
      bQuotes = !bQuotes;
      break;
    case '<':
    case '>':
    case '=':
      if ( !bQuotes )
      {
        return szString;
      }
      break;
    default:
      if ( !bQuotes )
      {
        if ( IsWhiteSpace( XMLFile.GetChar( szString ) ) )
        {
          if (bSkipTrailingWhiteSpaces)
          {
            while ( IsWhiteSpace( XMLFile.GetChar( szString ) ) )
            {
              XMLFile.GetNextChar(szString);
            }
          }

          return szString;
        }
      }
      break;
    }

    XMLFile.GetNextChar(szString);
  }

  if (bSkipTrailingWhiteSpaces)
  {
    while ( IsWhiteSpace( XMLFile.GetChar( szString ) ) )
    {
      XMLFile.GetNextChar(szString);    
    }
  }

  return szString;
}


// function: FindNextProperty
//
// Find the next property in the current item
//
// Parameters:
//   szCurrentValue - Pointer to Value
//
// Return Values
//   NULL - Another Property was not found
//   not NULL - The pointer to the next property
LPBYTE 
CXMLEdit::FindNextProperty(LPBYTE &szValue)
{
  BOOL  bQuotes;
  LPBYTE szCurrent;
  LPBYTE szCurrentProp;
  LPBYTE szCurrentValue;

  if (!GetCurrentProperty())
  {
    // We do not have a current property
    return NULL;
  }

  do 
  {
    // Reset szCurrent to begining of current property
    bQuotes = FALSE;
    szCurrent = SkipString(GetCurrentProperty());

    if ( XMLFile.GetChar(szCurrent) == '=' )
    {
      // We have found a value for our old property
      XMLFile.GetNextChar(szCurrent);
      szCurrent = SkipString(szCurrent);
    }

    // Set the current property
    szCurrentProp = szCurrent;

    // Try to find a value for this property
    szCurrent = SkipString(szCurrent);

    if ( XMLFile.GetChar(szCurrent) == '=' )
    {
      // We have found a value for our new property
      XMLFile.GetNextChar(szCurrent);  
      szCurrentValue = szCurrent;
    }
    else
    {
      szCurrentValue = NULL;
    }

    if ( ( XMLFile.GetChar(szCurrent) == '<' ) || ( XMLFile.GetChar(szCurrent) == '>' ) )
    {
      // We have left the current item, so return NULL
      return NULL;
    }

    if ( XMLFile.GetChar(szCurrent) != '\0' )
    {
      // We have found the next item, lets return it
      szValue = szCurrentValue;
      return szCurrentProp;
    }

  } while ( ReadNextChunk() );

  // End of File, no more values are present.
  return NULL;
}

// function: MoveToNextItem
//
// Move to the Next Item
//
BOOL 
CXMLEdit::MovetoNextItem()
{
  LPBYTE szTemp;
  LPBYTE szLastItem;

  szTemp = FindNextItem();
  szLastItem = GetCurrentItem();    // Do this afterwards, just incase we moved the buffer

  if (szTemp == NULL)
  {
    return FALSE;
  }

  SetCurrentItem(szTemp);
  SetCurrentProperty(szTemp);
  SetCurrentValue(szTemp);

  // Always keep the last item in the buffer
  // The reason for this, is because on delete we want to be able
  // to back up to the '<' of the current item
  XMLFile.MoveCurrentPtr(szLastItem);

  return TRUE;
}

// function: MoveToNextProperty
//
// Move to the Next Property
//
BOOL 
CXMLEdit::MovetoNextProperty()
{
  LPBYTE szTemp;
  LPBYTE szTempValue = NULL;

  szTemp = FindNextProperty(szTempValue);

  if (szTemp == NULL)
  {
    return FALSE;
  }

  SetCurrentProperty(szTemp);

  if (szTempValue)
  {
    SetCurrentValue(szTempValue);
  }
  else
  {
    SetCurrentValue(szTemp);
  }

  return TRUE;
}

// function: MoveToFirstProperty
//
// Move to the First Property
//
BOOL 
CXMLEdit::MovetoFirstProperty()
{
  SetCurrentProperty(GetCurrentItem());
  SetCurrentValue(GetCurrentProperty());

  return MovetoNextProperty();
}

// RetrieveCurrentValue
//
// Retrieve the current Value, and put it in pstrValue
//
BOOL 
CXMLEdit::RetrieveCurrentValue( TSTR *pstrValue )
{
  LPBYTE szBeginingofValue;
  LPBYTE szCurrentLocation;
  BOOL   bInsideQuotes = FALSE;
  DWORD  dwCurrentLen = 0;
  DWORD  i;

  LoadFullItem();

  szBeginingofValue = GetCurrentValue();

  if ( *szBeginingofValue == '"' )
  {
    bInsideQuotes = TRUE;
    XMLFile.GetNextChar(szBeginingofValue);
  }

  szCurrentLocation = szBeginingofValue;

  while ( TRUE )
  {
    if ( bInsideQuotes && ( XMLFile.GetWideChar(szCurrentLocation) == '"' ) )
    {
      // Hit end
      break;
    }

    if ( ( !bInsideQuotes && IsTerminator( XMLFile.GetWideChar(szCurrentLocation) ) ) ||
         ( XMLFile.GetWideChar(szCurrentLocation) == '\0' ) )
    {
      // We hit the end again
      break;
    }

    XMLFile.GetNextWideChar(szCurrentLocation);
    dwCurrentLen++;
  }

  if ( !pstrValue->Resize( dwCurrentLen + 1 ) )
  {
    return FALSE;
  }

  szCurrentLocation = szBeginingofValue;

  for ( i = 0;
        i < dwCurrentLen;
        i++ )
  {
    *(pstrValue->QueryStr() + i ) = ( WCHAR ) XMLFile.GetWideChar( szCurrentLocation );
    XMLFile.GetNextWideChar( szCurrentLocation );
  }

  *(pstrValue->QueryStr() + i ) = '\0';

  return TRUE;
}

// function:IsWhiteSpace
//
// returns if the character is a space
//
BOOL 
CXMLEdit::IsWhiteSpace(DWORD ch)
{
  return ( ( ch == ' ' ) ||
           ( ch == '\t' ) ||
           ( ch == '\r' ) ||
           ( ch == '\n' )
         );
}

// function:IsWhiteSpace
//
// returns if the character is a xml string terminator
//
BOOL 
CXMLEdit::IsTerminator(DWORD ch)
{
  return ( ( ch == '\0' ) ||
           ( ch == '=' ) ||
           IsWhiteSpace(ch)
         );
}

// function: GetCurrentItem
//
// Return a pointer to the Current Item
LPBYTE 
CXMLEdit::GetCurrentItem()
{
  return XMLFile.GetBaseLocation() + m_dwItemOffset;
}

// function: GetCurrentProperty
//
// Return a pointer to the Current Property
LPBYTE 
CXMLEdit::GetCurrentProperty()
{
  return XMLFile.GetBaseLocation() + m_dwPropertyOffset;
}

// function: GetCurrentValue
//
// Return a pointer to the value for the current property
LPBYTE 
CXMLEdit::GetCurrentValue()
{
  return XMLFile.GetBaseLocation() + m_dwValueOffset;
}

// function: SetCurrentItem
//
// Set the location for the current item
void 
CXMLEdit::SetCurrentItem(LPBYTE szInput)
{
  ASSERT( ((DWORD) ( szInput - XMLFile.GetBaseLocation() ) ) < XMLFile.GetBufferSize() );

  m_dwItemOffset = (DWORD) (DWORD_PTR) (szInput - XMLFile.GetBaseLocation());
}

// function: SetCurrentProperty
//
// Set the location for the current property
void 
CXMLEdit::SetCurrentProperty(LPBYTE szInput)
{
  ASSERT( ((DWORD) ( szInput - XMLFile.GetBaseLocation() ) ) < XMLFile.GetBufferSize() );

  m_dwPropertyOffset = (DWORD) (DWORD_PTR) (szInput - XMLFile.GetBaseLocation());
}

// function: SetCurrentValue
//
// Set the location for the current value
void
CXMLEdit::SetCurrentValue(LPBYTE szInput)
{
  ASSERT( ((DWORD) ( szInput - XMLFile.GetBaseLocation() ) ) < XMLFile.GetBufferSize() );

  m_dwValueOffset = (DWORD) (DWORD_PTR) (szInput - XMLFile.GetBaseLocation());
}

// function: FindBeginingofItem
//
// Find the begining of the current item
//
// Parameters:
//   szInput - The Location to start at
//
// Return:
//   NULL - Could not find the begining
//   Pointer - The begining, starting with the '<'
LPBYTE
CXMLEdit::FindBeginingofItem(LPBYTE szInput)
{
  while ( ( szInput >= XMLFile.GetBaseLocation() ) &&
          ( XMLFile.GetChar(szInput) != '\0' )
        )
  {
    if ( XMLFile.GetChar(szInput) == '<' )
    {
      return szInput;
    }

    XMLFile.GetPrevChar(szInput);
  }

  return NULL;
}

// function: DeleteItem()
//
// Delete an item
//
// Note:  This will not only delete the current item, but it will delete any items that
//        are nested inside of it.
//
// Return:
//   TRUE - Deleted successfully
//   FALSE - Failed to delete it
BOOL 
CXMLEdit::DeleteItem()
{
  LPBYTE szBegin;
  LPBYTE szEnd;
  LPBYTE szCurrentItem;
  DWORD  dwNestedItems = 0;


  do {
    // Load the whole item
    LoadFullItem();
    // Increment this because we are inside an item
    dwNestedItems++;

    // Initialize to the current Item
    szCurrentItem = GetCurrentItem();

    // Scan for terminator
    // See if this is the end of an item
    if ( XMLFile.GetChar(szCurrentItem) == '/' )
    {
      // This item is in the form </foo>, so it is the end of an item that
      // was opened earlier, we have to subtract 2, one for the current item
      // and one that was for the start of this one
      ASSERT(dwNestedItems >= 2);
      dwNestedItems -= 2;
    }

    // Move to next item
    szEnd = FindNextItem(szCurrentItem,TRUE);

    if (!szEnd)
    {
      // We could not find the end, so we couldn't delete it
      return FALSE;
    }

    // See if this item self terminate (ie. <FOO bar="test"/>)
    while ( ( szEnd != GetCurrentItem() ) &&
            ( XMLFile.GetPrevChar(szEnd) != '>' )
          )
    {
      // continue on
    }

    if ( ( XMLFile.GetChar(szEnd) == '>' ) &&
         ( szEnd != GetCurrentItem() ) &&
         ( XMLFile.GetPrevChar(szEnd) == '/' )
       )
    {
      // We have found an item that self terminates, so we can 
      // decrement the counter (ie. <foo bar="TRUE" />
      ASSERT(dwNestedItems>0);
      dwNestedItems--;
    }

    // Delete current item
    szEnd = FindNextItem(GetCurrentItem(),FALSE);

    if (!szEnd)
    {
      return FALSE;
    }

    szBegin = FindBeginingofItem( GetCurrentItem() );
    MoveData(szBegin, (DWORD) (DWORD_PTR) (szBegin - szEnd) );
    szBegin = FindNextItem(szBegin,TRUE);

    if (!szBegin)
    {
      return FALSE;
    }

    SetCurrentItem(szBegin);
  } while ( dwNestedItems > 0 );

  return TRUE;
}

BOOL 
CXMLEdit::DeleteValue()
{
  // Not yet implemented
  ASSERT(FALSE);

  return FALSE;
}

BOOL 
CXMLEdit::DeleteProperty()
{
  LPBYTE szTemp;

  LoadFullItem();

  szTemp = SkipString( GetCurrentProperty() );

  if ( XMLFile.GetChar(szTemp) == '=' )
  {
    // Skip the Value for this also
    XMLFile.GetNextChar(szTemp);
    szTemp = SkipString(szTemp);
  }

  if ( XMLFile.GetChar(szTemp) != '\0' )
  {
    XMLFile.MoveData( GetCurrentProperty(), (INT) ( GetCurrentProperty() - szTemp ) );
    return TRUE;
  }

  return FALSE;
}

// function: ReplaceString
//
// Replace a string at a given location, with another string
// that is passed in.
//
// Parameters:
//   szLocation - The location of the variable to change
//   szNewValue - The new string to replace it with
//
// Return 
//   TRUE - It succeeded
//   FLASE - It failed
BOOL 
CXMLEdit::ReplaceString(LPBYTE szLocation, LPTSTR szNewValue)
{
  LPBYTE szTemp;
  LPBYTE    szOldCurrentItem = GetCurrentItem();

  LoadFullItem();

  if ( szOldCurrentItem != GetCurrentItem() )
  {
    // Current Item has moved, so we must update the szLocation Pointer
    szLocation = szLocation - (szOldCurrentItem - GetCurrentItem());
  }

  // Skip to the begining of the next string
  szTemp = SkipString( szLocation, FALSE );

  if ( XMLFile.GetChar(szTemp) != '\0' )
  {
    MoveData( szLocation, (INT) ( _tcslen(szNewValue) - ( szTemp - szLocation ) ) );
    XMLFile.CopyString( szLocation, szNewValue);
    return TRUE;
  }

  return FALSE;
}

// function: ReplaceItem
//
// Replace a item name at the CurrentItem()
//
// Parameters
//   szNewItem - The new name item to add
//
BOOL 
CXMLEdit::ReplaceItem(LPTSTR szNewItem)
{
  return ReplaceString(GetCurrentItem(),szNewItem);
}

// function: ReplaceProperty
//
// Replace a property name at the property CurrentProperty()
//
// Parameters
//   szProp - The new name for the property
//
BOOL 
CXMLEdit::ReplaceProperty(LPTSTR szNewProp)
{
  return ReplaceString(GetCurrentProperty(),szNewProp);
}

// function: ReplaceValue
//
// Replace a property name at the property CurrentProperty()
//
// Parameters
//   szNewValueProp - The new name for the property
//
BOOL 
CXMLEdit::ReplaceValue(LPTSTR szNewValue)
{
  if (GetCurrentProperty() == GetCurrentValue())
  {
    // There is no value, so we will not replace the property
    // by mistkae
    return FALSE;
  }

  if (*szNewValue != '"')
  {
    BUFFER buffValue;

    if (buffValue.Resize((_tcslen(szNewValue) + 3) * sizeof(TCHAR)))  // 3 chars = '"' + '"' + '\0'
    {
      // Copy the string with quotes around it.
      _tcscpy((LPTSTR) buffValue.QueryPtr(), _T("\""));
      _tcscat((LPTSTR) buffValue.QueryPtr(), szNewValue);
      _tcscat((LPTSTR) buffValue.QueryPtr(), _T("\""));

      return ReplaceString(GetCurrentValue(),(LPTSTR) buffValue.QueryPtr());
    }

    return FALSE;
  }
  else
  {
    return ReplaceString(GetCurrentValue(),szNewValue);
  }
}

// function: IsEqual
//
// Compares a Unicode and ANSI String to see if they are equal
//
// Note: This works on ANSI Strings, but will not work on DBCS 
//       Strings!
// Note: Termination character for this function is either a 
//       '\0', ' ', or '\t'
//
// Parameters:
//   szWideString - Wide Char String
//   szAnsiString - An Ansi String
// 
// Return:
//   TRUE - They are equal
//   FALSE - They are not equal
BOOL 
CXMLEdit::IsEqual(LPCWSTR szWideString, LPCSTR szAnsiString)
{
  if (*szWideString == '"')
  {
    // If the string is inside quotes, do not use that in the comparison
    szWideString++;
  }

  if (*szAnsiString == '"')
  {
    // If the string is inside quotes, do not use that in the comparison
    szAnsiString++;
  }

  while ( *szWideString && 
          *szAnsiString &&
          (*szWideString == *szAnsiString)
        )
  {
    szWideString++;  // Increment 1 character (2 bytes)
    szAnsiString++;  // Increment 1 character (1 byte )
  }

  if ( ( IsTerminator ( *szWideString ) || ( *szWideString == '"' ) ) &&
       ( IsTerminator ( *szAnsiString ) || ( *szAnsiString == '"' )  )
     )
  {
    // We have made it throught the string, and all the 
    // chars were equal
    return TRUE;
  }

  return FALSE;
}

// function: IsEqual
//
// Compares two unicode strings, or two ansi strings
//
// Note: This works on ANSI Strings, but will not work on DBCS 
//       Strings!
// Note: Termination character for this function is either a 
//       '\0', ' ', or '\t'
//
// Parameters:
//   szString1 - String to Compare
//   szString2 - String to Compare
// 
// Return:
//   TRUE - They are equal
//   FALSE - They are not equal
BOOL 
CXMLEdit::IsEqual(LPCTSTR szString1, LPCTSTR szString2)
{
  if (*szString1 == '"')
  {
    // If the string is inside quotes, do not use that in the comparison
    szString1++;
  }

  if (*szString2 == '"')
  {
    // If the string is inside quotes, do not use that in the comparison
    szString2++;
  }

  while ( *szString1 && 
          *szString2 &&
          (*szString1 == *szString2)
        )
  {
    szString1++;  // Increment 1 character (2 bytes)
    szString2++;  // Increment 1 character (1 byte )
  }

  if ( ( IsTerminator ( *szString1 ) || ( *szString1 == '"' )  ) &&
       ( IsTerminator ( *szString2 ) || ( *szString2 == '"' )  )
     )
  {
    // We have made it throught the string, and all the 
    // chars were equal
    return TRUE;
  }

  return FALSE;
}

// function: IsEqual
//
// Compare a LPBYTE string of type XMLFile.IsUnicode() with 
// a LPTSTR
// 
// Parameters:
//   szGenericString - The string from our internal buffer
//   szTCHARString - The string to compare with from the user
// 
// Return:
//   TRUE - They are the same
//   FALSE - They are different
//
BOOL 
CXMLEdit::IsEqual(LPBYTE szGenericString, LPCTSTR szTCHARString)
{
  if ( (!szGenericString) || (!szTCHARString) )
  {
    // No item to compare it with
    return FALSE;
  }

#if defined(UNICODE) || defined(_UNICODE)

  // For UNICODE, szItemName is Unicode
  if ( XMLFile.IsUnicode() )
  {
    // Both are Unicode
    return ( IsEqual( szTCHARString, (LPWSTR) szGenericString ) == 0 );
  }
  else
  {
    // szGenericString is Unicode, szCurrentItem is ANSI
    return ( IsEqual( szTCHARString , (LPSTR) szGenericString ) );
  }

#else

  // For !UNICODE, szItemName is ANSI
  if ( XMLFile.IsUnicode() )
  {
    // szGenericString is ANSI, szCurrentItem is Unicode
    return ( IsEqual( (LPWSTR) szGenericString, szTCHARString ) );
  }
  else
  {
    // Both are ANSI
    return ( IsEqual( (LPSTR) szGenericString, szTCHARString ) == 0 );
  }

#endif

}

// function: IsEqualItem
//
// Compares the CurrentItem Name to the one passed in
//
// Paramters:
//   szItemName - The ItemName to compare with
//
BOOL 
CXMLEdit::IsEqualItem(LPCTSTR szItemName)
{
  return IsEqual( GetCurrentItem(), szItemName );
}

// function: IsPropertyItem
//
// Compares the CurrentProperty Name to the one passed in
//
// Paramters:
//   szItemName - The ItemName to compare with
//
BOOL 
CXMLEdit::IsEqualProperty(LPCTSTR szPropertyName)
{
  return IsEqual( GetCurrentProperty(), szPropertyName );
}

// function: IsEqualValue
//
// Compares the CurrentValue to the one passed in
//
// Paramters:
//   szValue - The value to coompare with
//
BOOL 
CXMLEdit::IsEqualValue(LPCTSTR szValue)
{
  return IsEqual( GetCurrentValue(), szValue );
}

// function: CXML_Metabase_Upgrade::MethodName
//
LPTSTR 
CXML_Metabase_Upgrade::GetMethodName()
{
  return _T("XML_Metabase_Upgrade");
}

// function: CXML_Base::ParseFile
//
// Upgrade the XML Metabase/Schema to a format that the new
// Configuration store will be happy with, and not report
// any errors to the pesky Event Log
//
// Parameters
//   szFile - The file to parse
//   ciList - The parameters to use, they consist of:
//     0 - The name of the Item
//     1 - Items==2 -> New name of item     | Items > 2 -> Name of Property
//     2 - Items==3 -> New name of property | Items > 3 -> Value to look for
//     3 - Items==4 -> New Value            | Items > 4 -> Name of Next Property to Check
//     4 - Items==5 -> New Value for last prop | Items > 5 -> Name of the Next Value to look for
//     etc.
//
//   Note:
//    1) A '*' as an item name, property name, or value means to replace no matter
//       what it is
//    2) A '*' for a replacement character means to remove that item/property/value
//    3) A '**' for a replacement character means to remove the whole item
//
// Return Value:
//   TRUE - It worked correctly
//   FALSE - It failed
BOOL
CXML_Base::ParseFile(LPTSTR szFile, CItemList &ciList)
{
  CXMLEdit    XMLFile;
  CItemList   *pList;
  DWORD       i;

  // Create array of ItemLists
  pList = new (CItemList[ciList.GetNumberOfItems()]);

  if ( pList == NULL )
  {
    // Could not allocation memory needed for ItemList
    return FALSE;
  }

  for (i = 0; i < ciList.GetNumberOfItems(); i++)
  {
    if ( ( !pList[i].LoadSubList( ciList.GetItem(i) ) ) ||
         ( pList[i].GetNumberOfItems() < 2 )
       )
    {
      // Could not load one of the items
      delete [] pList;
      return FALSE;
    }
  }

  // Open the metabase, to modify it 
  if (!XMLFile.Open(szFile,TRUE))
  {
    delete [] pList;
    return FALSE;
  }

  while (XMLFile.MovetoNextItem())
  {
    // Look for Item in replace list
    for (i = 0; i < ciList.GetNumberOfItems(); i++)
    {
      // Is the item equal to this
      if ( XMLFile.IsEqualItem( pList[i].GetItem(0) ) ||
           ( ( *pList[i].GetItem(0) == '*' ) && ( *(pList[i].GetItem(0)+1) == '\0' ) )
         )
      {
        if ( pList[i].GetNumberOfItems() == 2 )
        {
          // There is only 2 items, so the second item is the new name for the item, so replace/delete it
          if ( ( *pList[i].GetItem(1) == '*' ) && ( *(pList[i].GetItem(1)+1) == '\0' ) )
          {
            XMLFile.DeleteItem();
          }
          else
          {
            XMLFile.ReplaceItem( pList[i].GetItem(1) );
          }
        }
        else
        {
          // The item is found, check the properties...
          XMLFile.MovetoFirstProperty();

          do {
            if ( XMLFile.IsEqualProperty( pList[i].GetItem(1) ) ||
                 ( ( *pList[i].GetItem(1) == '*' ) && ( *(pList[i].GetItem(1)+1) == '\0' ) )
               )
            {
              // We have found a match of the property also
              if ( pList[i].GetNumberOfItems() == 3 )
              {
                // There are 3 items, so replace/delete the property name with this
                if ( ( *pList[i].GetItem(2) == '*' ) && ( *(pList[i].GetItem(2)+1) == '\0' ) )
                {
                  XMLFile.DeleteProperty();
                }
                else if ( ( *pList[i].GetItem(2) == '*' ) && ( *(pList[i].GetItem(2)+1) == '*' ) && ( *(pList[i].GetItem(2)+2) == '\0' ) )
                {
                  XMLFile.DeleteItem();
                  // Since we removed the item, we must jump out of the property checking
                  break;
                }
                else
                {
                  XMLFile.ReplaceProperty( pList[i].GetItem(2) );
                }
              }
              else
              {
                // Check value to make sure it is the same
                if ( XMLFile.IsEqualValue( pList[i].GetItem(2) ) ||
                     ( ( *pList[i].GetItem(2) == '*' ) && ( *(pList[i].GetItem(2)+1) == '\0' ) )
                   )
                {
                  DWORD dwCurrentProp = 3;
                  BOOL bContinue = TRUE;

                  while ( (pList[i].GetNumberOfItems() > (dwCurrentProp + 1) ) && ( bContinue ) )
                  {
                    XMLFile.MovetoFirstProperty();
                    bContinue = FALSE;
                    
                    do {
                      // compare the current property and value
                      if ( ( ( ( *pList[i].GetItem(dwCurrentProp) == '*' ) && ( *(pList[i].GetItem(dwCurrentProp)+1) == '\0' ) ) ||     // Compare Property
                             XMLFile.IsEqualProperty( pList[i].GetItem(dwCurrentProp) )
                           ) &&
                           ( ( ( *pList[i].GetItem(dwCurrentProp+1) == '*' ) && ( *(pList[i].GetItem(dwCurrentProp+1)+1) == '\0' ) ) || // Compare Value
                             XMLFile.IsEqualValue( pList[i].GetItem(dwCurrentProp+1) )
                           )
                         )
                      {
                        // If we have found a match for both property and value, then lets continue
                        bContinue = TRUE;
                        break;
                      }

                    } while (XMLFile.MovetoNextProperty());

                    dwCurrentProp += 2;
                  }

                  if (bContinue)
                  {
                    // The item, property, and value are correct, so replace/delete it
                    if ( ( *pList[i].GetItem(dwCurrentProp) == '*' ) && ( *(pList[i].GetItem(dwCurrentProp)+1) == '\0' ) )
                    {
                      XMLFile.DeleteValue();
                    }
                    else if ( ( *pList[i].GetItem(dwCurrentProp) == '*' ) && 
                              ( *(pList[i].GetItem(dwCurrentProp)+1) == '*' ) && 
                              ( *(pList[i].GetItem(dwCurrentProp)+2) == '\0' ) 
                            )
                    {
                      XMLFile.DeleteItem();
                      // Since we removed the item, we must jump out of the property checking
                      break;
                    }
                    else
                    {
                      XMLFile.ReplaceValue( pList[i].GetItem(dwCurrentProp) );
                    }
                  }

                  break;
                }
              } // if ( pList[i]->GetNumberofItems() == 3 )
            } // if ( XMLFile.IsEqualProperty( pList[i]->GetItem(1) ) ||

          } while (XMLFile.MovetoNextProperty());
        } // if ( pList[i]->GetNumberofItems() == 2 )
      } //  if ( XMLFile.IsEqualItem( pList[i]->GetItem(0) ) ||
    } // for (i = 0; i < ciList.GetNumberOfItems(); i++)
  } // while (XMLFile.MovetoNextItem())

  XMLFile.Close();

  delete [] pList;
  return TRUE;
}

// function: CXML_Metabase_Upgrade::DoInternalWork
//
// Upgrade the XML Metabase to a format that the new
// Configuration store will be happy with, and not report
// any errors to the pesky Event Log
//
// Return Value:
//   TRUE - It worked correctly
//   FALSE - It failed
//
BOOL 
CXML_Metabase_Upgrade::DoInternalWork(CItemList &ciList)
{
  TSTR        strMetabasePath;

  if ( !GetMetabasePath( &strMetabasePath ) )
  {
    return FALSE;
  }

  return ParseFile( strMetabasePath.QueryStr() , ciList);
}

// function: CXML_MBSchema_Upgrade::DoInternalWork
//
// Upgrade the XML MBSchema to a format that the new
// Configuration store will be happy with, and not report
// any errors to the pesky Event Log
//
// Return Value:
//   TRUE - It worked correctly
//   FALSE - It failed
//
BOOL 
CXML_MBSchema_Upgrade::DoInternalWork(CItemList &ciList)
{
  TSTR        strMBSchemaPath;

  if ( !GetSchemaPath( &strMBSchemaPath ) )
  {
    return FALSE;
  }

  return ParseFile( strMBSchemaPath.QueryStr() , ciList);
}

// function: CXML_MBSchema_Upgrade::MethodName
//
LPTSTR 
CXML_MBSchema_Upgrade::GetMethodName()
{
  return _T("XML_MBSchema_Upgrade");
}

// function: GetMetabasePath
//
// Retrieve the path to the metabase
//
// Parameters 
//   pstrPath - [OUT] The complete path to the metabase. (assumed to be og
//            _MAX_PATH size)
BOOL 
CXML_Base::GetMetabasePath(TSTR *pstrPath)
{
  DWORD dwReturn;

  if ( !pstrPath->Resize( MAX_PATH ) )
  {
    return FALSE;
  }
  
  dwReturn = GetSystemDirectory( pstrPath->QueryStr(), pstrPath->QuerySize() );

  if ( ( dwReturn == 0 ) ||
       ( dwReturn > pstrPath->QuerySize() )
     )
  {
    // Function failed, or path was too long to append filename
    return FALSE;
  }

  if ( !pstrPath->Append( CXMLBASE_METABASEPATH ) )
  {
    return FALSE;
  }

  return TRUE;
}

// function: GetSchemaPath
//
// Retrieve the path to the metabase schema
//
// Parameters 
//   pstrPath - [OUT] The complete path to the metabase. (assumed to be og
//            _MAX_PATH size)
BOOL 
CXML_Base::GetSchemaPath(TSTR *pstrPath)
{
  DWORD dwReturn;
  
  if ( !pstrPath->Resize( MAX_PATH ) )
  {
    return FALSE;
  }
  
  dwReturn = GetSystemDirectory( pstrPath->QueryStr(), pstrPath->QuerySize() );

  if ( ( dwReturn == 0 ) ||
       ( dwReturn > pstrPath->QuerySize() )
     )
  {
    // Function failed, or path was too long to append filename
    return FALSE;
  }

  if ( !pstrPath->Append( CXMLBASE_MBSCHEMAPATH ) )
  {
    return FALSE;
  }

  return TRUE;
}

// function: GetMethodName
//
// Return the method name for this class
LPTSTR
CXML_Metabase_VerifyVersion::GetMethodName()
{
  return ( _T("XML_Metabase_VerifyVersion") );
}

// function: GetMethodName
//
// Return the method name for this class
LPTSTR
CXML_MBSchema_VerifyVersion::GetMethodName()
{
  return ( _T("XML_MBSchema_VerifyVersion") );
}

// function: VerifyParameters:
//
// Verify that the parameters are correct fo VerifyVersion
BOOL 
CXML_Metabase_VerifyVersion::VerifyParameters(CItemList &ciParams)
{
  if ( ( ciParams.GetNumberOfItems() == 2 ) &&
       ciParams.IsNumber(0) &&
       ciParams.IsNumber(1)
     )
  {
    return TRUE;
  }

  return FALSE;
}

// function: VerifyParameters:
//
// Verify that the parameters are correct fo VerifyVersion
BOOL 
CXML_MBSchema_VerifyVersion::VerifyParameters(CItemList &ciParams)
{
  if ( ( ciParams.GetNumberOfItems() == 2 ) &&
       ciParams.IsNumber(0) &&
       ciParams.IsNumber(1)
     )
  {
    return TRUE;
  }

  return FALSE;
}

// function: IsFileWithinVersion
//
// Verify the a file is with a certain version.  This is done by paring the xml of the file,
// extrapulation the verion, and making sure it is withing the bounds
//
// Parameters
//   szFileName - The name of the xml file
//   szItemName - The name of the item to search for
//   szPropName - The name of the property that contains the version
//   dwMinVer - The minimum version for it to return true
//   dwMaxVer - The maximum version for it to return true
BOOL 
CXML_Base::IsFileWithinVersion(LPTSTR szFileName, LPTSTR szItemName, LPTSTR szPropName, DWORD dwMinVer, DWORD dwMaxVer)
{
  CXMLEdit XMLFile;
  BOOL bFound = FALSE;
  BOOL bRet = FALSE;

  if (!XMLFile.Open(szFileName, FALSE))
  {
    return FALSE;
  }

  while ( XMLFile.MovetoNextItem() && !bFound )
  {
    // Look for the configuration tag
    if (XMLFile.IsEqualItem( szItemName ))
    {
      XMLFile.MovetoFirstProperty();

      do {

        // Look for the xmlns tag that mentions the version #
        if (XMLFile.IsEqualProperty( szPropName ) )
        {
          DWORD dwVersion = XMLFile.ExtractVersion( XMLFile.GetCurrentValue() );
          bFound = TRUE;

          if ( ( dwMinVer >= dwMinVer ) &&
               ( dwMaxVer <= dwMaxVer )
             )
          {
            bRet = TRUE;
          }
        }

      } while ( XMLFile.MovetoNextProperty() && !bFound );
    }

  }

  XMLFile.Close();

  return bRet;
}

// function: CXML_Metabase_VerifyVersion::DoInternalWork
//
// Verify the versions are within the bounds that are sent in, so we 
// know wether we should execure the next command or not, by returning
// TRUE or FALSE
//
// Parameters:
//   ciList -
//     0 -Minimum Bound
//     1- Max Bound
BOOL 
CXML_Metabase_VerifyVersion::DoInternalWork(CItemList &ciList)
{
  TSTR  strMetabasePath;

  if ( !GetMetabasePath( &strMetabasePath ) )
  {
    return FALSE;
  }

  return IsFileWithinVersion( strMetabasePath.QueryStr(), // Filename
                              _T("configuration"),      // Item name
                              _T("xmlns"),              // Property Name
                              ciList.GetNumber(0),      // Min
                              ciList.GetNumber(1)       // Max
                            );
}

// function: CXML_MBSchema_VerifyVersion::DoInternalWork
//
// Verify the versions are within the bounds that are sent in, so we 
// know wether we should execure the next command or not, by returning
// TRUE or FALSE
//
// Parameters:
//   ciList -
//     0 -Minimum Bound
//     1- Max Bound
BOOL 
CXML_MBSchema_VerifyVersion::DoInternalWork(CItemList &ciList)
{
  TSTR  strSchemaPath;

  if ( !GetSchemaPath( &strSchemaPath ) )
  {
    return FALSE;
  }

  return IsFileWithinVersion( strSchemaPath.QueryStr(), // Filename
                              _T("MetaData"),           // Item name
                              _T("xmlns"),              // Property Name
                              ciList.GetNumber(0),      // Min
                              ciList.GetNumber(1)       // Max
                            );
}

// function: ExtractVersion
//
// Extract the Version number out of a string extracted from the metabase
//
// Parameters
//   szVersion - String version, such as "urn:microsoft-catalog:XML_Metabase_V1_0"
//
// RETURN
//   A Verison #
DWORD 
CXMLEdit::ExtractVersion(LPBYTE szVersion)
{
  DWORD dwVer = 0;

  if (!szVersion)
  {
    return 0;
  }

  while ( !IsTerminator(XMLFile.GetChar(szVersion)) )
  {
    if ( XMLFile.GetChar(szVersion) == '_' )
    {
      XMLFile.GetNextChar(szVersion);
      if ( XMLFile.GetChar(szVersion) == 'V' )
      {
        XMLFile.GetNextChar(szVersion);
        break;
      }
    }
    else
    {
      XMLFile.GetNextChar(szVersion);
    }
  }

  if (IsTerminator(XMLFile.GetChar(szVersion)) )
  {
    return FALSE;
  }

  while ( ( XMLFile.GetChar(szVersion) >= '0' ) && ( XMLFile.GetChar(szVersion) <= '9' ) )
  {
    dwVer = dwVer + ( XMLFile.GetChar(szVersion) - '0' );
    XMLFile.GetNextChar(szVersion);
  }

  return dwVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\www.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "other.h"
#include "setpass.h"
#include "setuser.h"
#include "www.h"
#include "rights.hxx"

extern OCMANAGER_ROUTINES gHelperRoutines;

#define Register_iis_www_log _T("Register_iis_www")


INT Register_iis_www()
{
    USE_USER_RIGHTS();
    iisDebugOut_Start(Register_iis_www_log, LOG_TYPE_TRACE);
    int iReturn = TRUE;
    int iTempFlag = TRUE;

    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"), TRUE);
    CMDKey cmdKey;

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_www_before"));

    // ---------------------------------------------------
    //
    // Here is the first place where we try to access the metabase!
    //
    // ---------------------------------------------------
    // create node /LM/W3SVC before wamreg.dll create IIS package
    // the registration of w3svc.dll will also require these initial entries to be here
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, _T("LM/W3SVC"));
    if ( !(METADATA_HANDLE)cmdKey )
    {
        // We failed to create node on the metabase
        // this is pretty serious.
        // we failed to create the ftp service.
        iisDebugOut((LOG_TYPE_ERROR, _T("%s(): failed to create initial node is metabase 'LM/W3SVC'. GetLastError()=0x%x\n"), Register_iis_www_log, GetLastError()));
        iReturn = FALSE;
        goto Register_iis_www_exit;
    }
    cmdKey.Close();

    // ---------------------------------------------------
    //
    // Get the anonymous username/passowrd and iwam username/password accounts.
    // And verify that the accounts exist and have the right privledges.
    //
    // ---------------------------------------------------
#ifndef _CHICAGO_
    // IUSR_(computername)
    Register_iis_www_handle_iusr_acct();
    SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 33002, g_pTheApp->m_csWWWAnonyName);
    AdvanceProgressBarTickGauge();

    // IWAM_(computername)
    Register_iis_www_handle_iwam_acct();
    SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 33001, g_pTheApp->m_csWAMAccountName);
    AdvanceProgressBarTickGauge();
#endif // _CHICAGO_

    // ---------------------------------------------------
    //
    // Install any services or whatever
    //
    // when we get out of this:
    // MAKE SURE THE IISADMIN SERVICE IS RUNNING.
    // This is because we don't want the startup code called twice.
    // example: start the metabase, but it takes a minute,
    // meanwhile, thru com, the metabase tries to get started again,
    // it will then error out with a "instance of the service is already running" error or something like it.
    // ---------------------------------------------------

    WriteToMD_Capabilities(_T("W3SVC"));

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_www_1"));
    AdvanceProgressBarTickGauge();

    ProgressBarTextStack_Set(IDS_IIS_ALL_CONFIGURE);

    InstallMimeMap();
    HandleSecurityTemplates(_T("W3SVC"));

    // ================
    //
    // LM/W3SVC/n/
    // LM/W3SVC/n/ServerBindings
    // LM/W3SVC/n/SecureBindings
    // LM/W3SVC/n/ServerComment
    // LM/W3SVC/n/ServerSize
    // LM/W3SVC/n/MD_NOT_DELETABLE
    //
    // fresh = ok.
    // reinstall = ok -- Do not re-create these things if it is a reinstall...
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff
    //
    //                 if the user does not have these virtual roots which we installed during iis4 days
    //                 then we don't need to verify that they are they.  the user removed them for some
    //                 reason, and we should honor that.
    //                 a. make sure the iishelp points to the right place though.
    // ================
    // About Virtual Roots
    AddVRootsToMD(_T("W3SVC"));
    AdvanceProgressBarTickGauge();

    LoopThruW3SVCInstancesAndSetStuff();
    LogHeapState(FALSE, __FILE__, __LINE__);
    AdvanceProgressBarTickGauge();

    iCount = 1;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;

        _stprintf(szTempSection, _T("register_iis_www_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);

        AdvanceProgressBarTickGauge();
    }

    //
    // Finaly Save the path to the WWW Root
    //
    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_www_after"));

    ProgressBarTextStack_Pop();

Register_iis_www_exit:
    iisDebugOut_End(Register_iis_www_log, LOG_TYPE_TRACE);
    return iReturn;
}



INT Unregister_iis_www()
{

    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];
    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"),TRUE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_www_before"));
    AdvanceProgressBarTickGauge();

    iCount = 0;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;

        _stprintf(szTempSection, _T("unregister_iis_www_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);

        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_www_after"));
    AdvanceProgressBarTickGauge();
    return 0;
}

int LoopThruW3SVCInstancesAndSetStuff()
{
    int iReturn = TRUE;
    CMDKey cmdKey;
    CStringArray arrayInstance;
    int nArray = 0, i = 0;

    // get all instances into an array
    cmdKey.OpenNode(_T("LM/W3SVC"));

    if ( (METADATA_HANDLE)cmdKey )
    {
        CMDKeyIter cmdKeyEnum(cmdKey);
        CString csKeyName;
        while (cmdKeyEnum.Next(&csKeyName) == ERROR_SUCCESS)
        {
            if (IsValidNumber((LPCTSTR)csKeyName))
            {
                arrayInstance.Add(csKeyName);
            }
        }
        cmdKey.Close();
    }

    nArray = (int)arrayInstance.GetSize();

    // set AppFriendlyName
    for (i=0; i<nArray; i++)
        {
        CString csPath;
        csPath = _T("LM/W3SVC/");
        csPath += arrayInstance[i];
        SetAppFriendlyName(csPath);
        }
    goto CreateW3SVCInstances_exit;

CreateW3SVCInstances_exit:
    return iReturn;
}


#ifndef _CHICAGO_

#define Register_iis_www_handle_iwam_acct_log _T("Register_iis_www_handle_iwam_acct")

int Register_iis_www_handle_iwam_acct(void)
{
    int err = FALSE;
    int iReturn = TRUE;
    INT iUserWasNewlyCreated = 0;
    iisDebugOut_Start(Register_iis_www_handle_iwam_acct_log, LOG_TYPE_TRACE);

    if (0 != g_pTheApp->dwUnattendConfig)
    {
        // if some sort of unattended user was specified
        // then use it.  if they specified only a password,
        // then use that password for the default user.
        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WAM_USER_NAME)
        {
            if (_tcsicmp(g_pTheApp->m_csWAMAccountName_Unattend,_T("")) != 0)
                {g_pTheApp->m_csWAMAccountName = g_pTheApp->m_csWAMAccountName_Unattend;}
        }

        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WAM_USER_PASS)
        {
            g_pTheApp->m_csWAMAccountPassword = g_pTheApp->m_csWAMAccountPassword_Unattend;
        }

        // let's use the iusr_computername deal
    
        err = CreateIWAMAccount(g_pTheApp->m_csWAMAccountName,g_pTheApp->m_csWAMAccountPassword, &iUserWasNewlyCreated);
        if ( err != NERR_Success )
        {
            // something went wrong, set the user back to iwam!!!
            g_pTheApp->ReGetMachineAndAccountNames();
            g_pTheApp->ResetWAMPassword();

            // flow down and process CheckIfThisServerHasAUserThenUseIt()
            // since things are now hosed!
        }
        else
        {
            // Check if the user was NewlyCreated.
            // if it was then add it to list that eventually gets written to
            // the registry -- so that when uninstall happens, setup knows
            // which users it added -- so that it can remove them!
            if (1 == iUserWasNewlyCreated)
            {
                // Add to the list
                g_pTheApp->UnInstallList_Add(_T("IUSR_WAM"),g_pTheApp->m_csWAMAccountName);
            }
            WriteToMD_IWamUserName_WWW();
            goto Register_iis_www_handle_iwam_acct_Exit;
        }
    }

    if (TRUE == CheckIfThisServerHasAUserThenUseIt(DO_IT_FOR_W3SVC_WAMUSER))
        {goto Register_iis_www_handle_iwam_acct_Exit;}

    // if there are no registry/existing user combinations
    // then we'll have to create a new iusr for WWW

    // let's use the iusr_computername deal
    err = CreateIWAMAccount(g_pTheApp->m_csWAMAccountName,g_pTheApp->m_csWAMAccountPassword, &iUserWasNewlyCreated);
    if ( err != NERR_Success )
    {
        // regenerate the password and try again...
        g_pTheApp->ResetWAMPassword();
        err = CreateIWAMAccount(g_pTheApp->m_csWAMAccountName,g_pTheApp->m_csWAMAccountPassword, &iUserWasNewlyCreated);
    }

    // Check if the user was NewlyCreated.
    // if it was then add it to list that eventually gets written to
    // the registry -- so that when uninstall happens, setup knows
    // which users it added -- so that it can remove them!
    if (1 == iUserWasNewlyCreated)
    {
        // Add to the list
        //g_pTheApp->UnInstallList_Add(_T("IUSR_WAM"),g_pTheApp->m_csWAMAccountName);
    }

    // Stick iwam username in the metabase
    // (this may fail because the password is using encryption -- rsabase.dll)
    // ================
    // LM/W3SVC/WamUserName
    // LM/W3SVC/WamPwd
    // ================
    WriteToMD_IWamUserName_WWW();

    goto Register_iis_www_handle_iwam_acct_Exit;
    
Register_iis_www_handle_iwam_acct_Exit:
    iisDebugOut_End(Register_iis_www_handle_iwam_acct_log, LOG_TYPE_TRACE);
    return iReturn;
}


#define Register_iis_www_handle_iusr_acct_log _T("Register_iis_www_handle_iusr_acct")
int Register_iis_www_handle_iusr_acct(void)
{
    int err = FALSE;
    int iReturn = TRUE;
    INT iUserWasNewlyCreated = 0;
    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"),FALSE);
    iisDebugOut_Start(Register_iis_www_handle_iusr_acct_log, LOG_TYPE_TRACE);

    g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csGuestName;
    g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csGuestPassword;

    if (0 != g_pTheApp->dwUnattendConfig)
    {
        // if some sort of unattended www user was specified
        // then use it.  if they specified only a password,
        // then use that password for the default user.
        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_NAME)
        {
            if (_tcsicmp(g_pTheApp->m_csWWWAnonyName_Unattend,_T("")) != 0)
                {g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csWWWAnonyName_Unattend;}
        }

        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_PASS)
        {
            g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csWWWAnonyPassword_Unattend;
        }

        err = CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword, &iUserWasNewlyCreated);
        if ( err != NERR_Success )
        {
            // something went wrong, set the user back to guest!!!
            g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csGuestName;
            g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csGuestPassword;

            // flow down and process CheckIfThisServerHasAUserThenUseIt()
            // since things are now hosed!
        }
        else
        {
            // Check if the user was NewlyCreated.
            // if it was then add it to list that eventually gets written to
            // the registry -- so that when uninstall happens, setup knows
            // which users it added -- so that it can remove them!
            if (1 == iUserWasNewlyCreated)
            {
                // Add to the list
                g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),g_pTheApp->m_csWWWAnonyName);
            }

            WriteToMD_AnonymousUserName_WWW(FALSE);
            goto Register_iis_www_handle_iusr_acct_Exit;
        }
    }

    if (TRUE == CheckIfThisServerHasAUserThenUseIt(DO_IT_FOR_W3SVC_ANONYMOUSUSER))
        {goto Register_iis_www_handle_iusr_acct_Exit;}

    // Well, i guess the there is no metabase entry for the iusr under ftp.

    // see if we can get it from somewhere else...
    if (atWWW == AT_INSTALL_FRESH)
    {
        // if this is a fresh install of ftp, then
        // let's try to use the www user
        if (TRUE == CheckIfServerAHasAUserThenUseForServerB(_T("LM/MSFTPSVC"), DO_IT_FOR_W3SVC_ANONYMOUSUSER))
            {goto Register_iis_www_handle_iusr_acct_Exit;}
    }

    // if this is an upgrade or fresh or whatevers
    // see if we can get it from an older iis place
    if (TRUE == CheckForOtherIUsersAndUseItForWWW())
        {goto Register_iis_www_handle_iusr_acct_Exit;}

    // if there are no registry/existing user combinations
    // then we'll have to create a new iusr for WWW

    // this was inited in initapp.cpp: CInitApp::SetSetupParams
    // and it could have been overridden by the time we get here

    // let's use the iusr_computername deal
    g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csGuestName;
    g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csGuestPassword;
    CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword, &iUserWasNewlyCreated);
    if (1 == iUserWasNewlyCreated)
    {
        // Add to the list
        //g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),g_pTheApp->m_csWWWAnonyName);
    }

    // ================
    // LM/W3SVC/AnonymousUserName
    // LM/W3SVC/AnonymousPwd
    // ================
    WriteToMD_AnonymousUserName_WWW(FALSE);
    goto Register_iis_www_handle_iusr_acct_Exit;
    
Register_iis_www_handle_iusr_acct_Exit:
    iisDebugOut_End(Register_iis_www_handle_iusr_acct_log, LOG_TYPE_TRACE);
    return iReturn;
}


// Look in the old iis1.0,2.0,3.0 spot for the ftp user and name.
// retrieve it from the registry..
#define CheckForOtherIUsersAndUseItForWWW_log _T("CheckForOtherIUsersAndUseItForWWW")
int CheckForOtherIUsersAndUseItForWWW(void)
{
    int iReturn = FALSE;
    int IfTheUserNotExistThenDoNotDoThis = TRUE;

    CString csAnonyName;
    TCHAR szAnonyName[UNLEN+1];
    TSTR strAnonyPassword;
    iisDebugOut_Start(CheckForOtherIUsersAndUseItForWWW_log);

    CRegKey regFTPParam(HKEY_LOCAL_MACHINE, REG_FTPPARAMETERS, KEY_READ);
    CRegKey regWWWParam(HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, KEY_READ);

    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"),FALSE);
    if (atWWW != AT_INSTALL_UPGRADE)
        {goto CheckForOtherIUsersAndUseItForWWW_Exit;}

    if (g_pTheApp->m_eUpgradeType != UT_351 && g_pTheApp->m_eUpgradeType != UT_10 && g_pTheApp->m_eUpgradeType != UT_20 && g_pTheApp->m_eUpgradeType != UT_30)
        {goto CheckForOtherIUsersAndUseItForWWW_Exit;}

    // retrieve from registry
    if ( (HKEY) regWWWParam ) 
    {
        regWWWParam.m_iDisplayWarnings = FALSE;
        if (ERROR_SUCCESS == regWWWParam.QueryValue(_T("AnonymousUserName"), csAnonyName))
        {
            _tcscpy(szAnonyName, csAnonyName);
            if ( !GetAnonymousSecret( _T("W3_ANONYMOUS_DATA"), &strAnonyPassword ) )
            {
              goto CheckForOtherIUsersAndUseItForWWW_Exit;
            }

            int iThisIsFalseBecauseNoMetabase = FALSE;
            if (TRUE == MakeThisUserNameAndPasswordWork(DO_IT_FOR_W3SVC_ANONYMOUSUSER, szAnonyName, strAnonyPassword.QueryStr(), iThisIsFalseBecauseNoMetabase, IfTheUserNotExistThenDoNotDoThis))
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:using old www reg usr:%s.\n"),CheckForOtherIUsersAndUseItForWWW_log,szAnonyName));
                iReturn = TRUE;
                goto CheckForOtherIUsersAndUseItForWWW_Exit;
            }
            else
            {
                // the user was not found, so don't use this registry data
                // just flow down to the next check
            }
            goto CheckForOtherIUsersAndUseItForWWW_Exit;
        }
    }


    if ( (HKEY) regFTPParam ) 
    {
        regFTPParam.m_iDisplayWarnings = FALSE;
        if (ERROR_SUCCESS == regFTPParam.QueryValue(_T("AnonymousUserName"), csAnonyName))
        {
            _tcscpy(szAnonyName, csAnonyName);
            if ( !GetAnonymousSecret( _T("FTPD_ANONYMOUS_DATA"), &strAnonyPassword ) )
            {
                goto CheckForOtherIUsersAndUseItForWWW_Exit;
            }

            int iThisIsFalseBecauseNoMetabase = FALSE;
            if (TRUE == MakeThisUserNameAndPasswordWork(DO_IT_FOR_W3SVC_ANONYMOUSUSER, szAnonyName, strAnonyPassword.QueryStr(), iThisIsFalseBecauseNoMetabase, IfTheUserNotExistThenDoNotDoThis))
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:using old ftp reg usr:%s.\n"),CheckForOtherIUsersAndUseItForWWW_log,szAnonyName));
                iReturn = TRUE;
                goto CheckForOtherIUsersAndUseItForWWW_Exit;
            }
            else
            {
                // if this didn't work, then we'll have to return false
                // in other words -- we couldn't find a valid registry and existing user entry...
                iReturn = FALSE;
            }
        }
    }

CheckForOtherIUsersAndUseItForWWW_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():End.ret=%d\n"),CheckForOtherIUsersAndUseItForWWW_log,iReturn));
    return iReturn;
}


#define MakeThisUserNameAndPasswordWork_log _T("MakeThisUserNameAndPasswordWork")
int MakeThisUserNameAndPasswordWork(int iForWhichUser, TCHAR *szAnonyName,TCHAR *szAnonyPassword, int iMetabaseUserExistsButCouldntGetPassword, int IfUserNotExistThenReturnFalse)
{
    USE_USER_RIGHTS();
    int  iReturn = TRUE;
    int  iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere = FALSE;
    INT  iUserWasNewlyCreated = 0;

    // We want to see if these users exists
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:usrtype=%d:flag1=%d:flag2=%d\n"),MakeThisUserNameAndPasswordWork_log,iForWhichUser,szAnonyName,iMetabaseUserExistsButCouldntGetPassword,IfUserNotExistThenReturnFalse));

    // check if anonyname is blank
    if (!szAnonyName) {goto MakeThisUserNameAndPasswordWork_Exit;}
    // Check if just contains nothing
    if (_tcsicmp(szAnonyName, _T("")) == 0) {goto MakeThisUserNameAndPasswordWork_Exit;}

    // Only check if the user exists if this is a user on this machine.
    // if it is not a user on this machine, then don't validate the user/password,
    // since during Guimode setup, they may not be connected to the network.
    if ( IsDomainSpecifiedOtherThanLocalMachine(szAnonyName))
    {
        // use whatever they had.
        // can't verify that the user exists.
        // can't verify that the password actually works.

        // so we can't verify that the user exists, so let's figure it doesn't
        if (IfUserNotExistThenReturnFalse)
        {
            iReturn = FALSE;
        }
    }
    else
    {
        // Check if this user actually exists...
        if (IsUserExist(szAnonyName))
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:The %s user exists\n"),MakeThisUserNameAndPasswordWork_log,szAnonyName));

            // The only way we can be down here is if the username is a local account.
            // Reset the password to make sure it works!
            ChangeUserPassword(szAnonyName, szAnonyPassword);

            if (iForWhichUser == DO_IT_FOR_W3SVC_ANONYMOUSUSER)
            {
                // IUSR_ account already exist, reuse it
                g_pTheApp->m_csWWWAnonyName = szAnonyName;
                // But assume that the password is correct!
                g_pTheApp->m_csWWWAnonyPassword = szAnonyPassword;
                // make sure this user has the appropriate rights..
                UpdateUserRights(g_pTheApp->m_csWWWAnonyName,g_pstrRightsFor_IUSR,sizeof(g_pstrRightsFor_IUSR)/sizeof(LPTSTR), TRUE);
            }
            if (iForWhichUser == DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER)
            {
                // IUSR_ account already exist, reuse it
                g_pTheApp->m_csFTPAnonyName = szAnonyName;
                // But assume that the password is correct!
                g_pTheApp->m_csFTPAnonyPassword = szAnonyPassword;
                // make sure this user has the appropriate rights..
                UpdateUserRights(g_pTheApp->m_csFTPAnonyName,g_pstrRightsFor_IUSR,sizeof(g_pstrRightsFor_IUSR)/sizeof(LPTSTR), TRUE);
            }
            if (iForWhichUser == DO_IT_FOR_W3SVC_WAMUSER)
            {
                // IWAM_ account already exist, resue it
                g_pTheApp->m_csWAMAccountName = szAnonyName;
                // But assume that the password is correct!
                g_pTheApp->m_csWAMAccountPassword = szAnonyPassword;
                // make sure the user has the appropriate rights
                UpdateUserRights(g_pTheApp->m_csWAMAccountName,g_pstrRightsFor_IWAM,sizeof(g_pstrRightsFor_IWAM)/sizeof(LPTSTR), TRUE);
            }
           
        }
        else
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:The %s user does not exist\n"),MakeThisUserNameAndPasswordWork_log,szAnonyName));
            if (IfUserNotExistThenReturnFalse)
            {
                iReturn = FALSE;
            }
            else
            {
                if (iForWhichUser == DO_IT_FOR_W3SVC_ANONYMOUSUSER)
                {
                    iisDebugOut((LOG_TYPE_WARN, _T("%s():FAIL WARNING: previous W3SVC iusr_ does not exist. creating a new one.\n"),MakeThisUserNameAndPasswordWork_log));
                    g_pTheApp->m_csWWWAnonyName = szAnonyName;
                    if (!szAnonyPassword || _tcsicmp(szAnonyPassword, _T("")) == 0)
                        {_tcscpy(szAnonyPassword,g_pTheApp->m_csGuestPassword);}
                    g_pTheApp->m_csWWWAnonyPassword = szAnonyPassword;
                    CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword,&iUserWasNewlyCreated);
                }

                if (iForWhichUser == DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER)
                {
                    iisDebugOut((LOG_TYPE_WARN, _T("%s():FAIL WARNING: previous MSFTPSVC iusr_ does not exist. creating a new one.\n"),MakeThisUserNameAndPasswordWork_log));
                    g_pTheApp->m_csFTPAnonyName = szAnonyName;
                    if (!szAnonyPassword || _tcsicmp(szAnonyPassword, _T("")) == 0)
                        {_tcscpy(szAnonyPassword,g_pTheApp->m_csGuestPassword);}
                    g_pTheApp->m_csFTPAnonyPassword = szAnonyPassword;
                    CreateIUSRAccount(g_pTheApp->m_csFTPAnonyName, g_pTheApp->m_csFTPAnonyPassword,&iUserWasNewlyCreated);
                }

                if (iForWhichUser == DO_IT_FOR_W3SVC_WAMUSER)
                {
                    iisDebugOut((LOG_TYPE_WARN, _T("%s():FAIL WARNING: previous W3SVC iwam_ does not exist. creating a new one.\n"),MakeThisUserNameAndPasswordWork_log));
                    g_pTheApp->m_csWAMAccountName = szAnonyName;
                    if (!szAnonyPassword || _tcsicmp(szAnonyPassword, _T("")) == 0)
                        {_tcscpy(szAnonyPassword,g_pTheApp->m_csGuestPassword);}
                    g_pTheApp->m_csWAMAccountPassword = szAnonyPassword;
                    CreateIWAMAccount(g_pTheApp->m_csWAMAccountName,g_pTheApp->m_csWAMAccountPassword,&iUserWasNewlyCreated);
                }
            }
        }
    }

MakeThisUserNameAndPasswordWork_Exit:
    if (iMetabaseUserExistsButCouldntGetPassword)
    {
        iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere = TRUE;
    }
    if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
        iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere = TRUE;
    }

    if (iForWhichUser == DO_IT_FOR_W3SVC_ANONYMOUSUSER)
    {
        // ================
        // LM/W3SVC/AnonymousUserName
        // LM/W3SVC/AnonymousPwd
        // ================
        WriteToMD_AnonymousUserName_WWW(iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere);
    }
    if (iForWhichUser == DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER)
    {
        // ================
        // LM/MSFTPSVC/AnonymousUserName
        // LM/MSFTPSVC/AnonymousPwd
        // ================
        WriteToMD_AnonymousUserName_FTP(iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere);
    }
    if (iForWhichUser == DO_IT_FOR_W3SVC_WAMUSER)
    {
        // ================
        // LM/W3SVC/WamUserName
        // LM/W3SVC/WamPwd
        // ================
        WriteToMD_IWamUserName_WWW();
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():End.ret=%d.\n"),MakeThisUserNameAndPasswordWork_log,iReturn));
    return iReturn;
}


//
// Returns true if it can get the ftp/WWW username and password from the metabase,
// if it can then it will make sure that it can use that user <-- by creating it if it doesn't exist
//
#define CheckIfThisServerHasAUserThenUseIt_log _T("CheckIfThisServerHasAUserThenUseIt")
int CheckIfThisServerHasAUserThenUseIt(int iForWhichUser)
{
    int  iReturn = FALSE;
    TCHAR szAnonyName[UNLEN+1];
    TCHAR szAnonyPassword[PWLEN+1];
    TCHAR szMetabasePath[_MAX_PATH];
    int iMetabaseUserExistsButCouldntGetPassword = TRUE;

    // set defaults for the w3svc user
    int iMetabaseID_ForUserName = MD_ANONYMOUS_USER_NAME;
    int iMetabaseID_ForUserPassword = MD_ANONYMOUS_PWD;
    _tcscpy(szMetabasePath,_T("LM/W3SVC"));

    if (iForWhichUser == DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER)
    {
        _tcscpy(szMetabasePath,_T("LM/MSFTPSVC"));
        iMetabaseID_ForUserName = MD_ANONYMOUS_USER_NAME;
        iMetabaseID_ForUserPassword = MD_ANONYMOUS_PWD;
    }
    if (iForWhichUser == DO_IT_FOR_W3SVC_WAMUSER)
    {
        _tcscpy(szMetabasePath,_T("LM/W3SVC"));
        iMetabaseID_ForUserName = MD_WAM_USER_NAME;
        iMetabaseID_ForUserPassword = MD_WAM_PWD;
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():Start:%s:whichuser=%d\n"),CheckIfThisServerHasAUserThenUseIt_log,szMetabasePath,iForWhichUser));

    // See if it's already in the metabase if it is then use that.
    if (TRUE == GetDataFromMetabase(szMetabasePath, iMetabaseID_ForUserName, (PBYTE)szAnonyName, UNLEN+1))
    {
        // Check if the username is null
        if (!szAnonyName)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("...GetDataFromMetabase:username is null.fail.\n")));
            iReturn = FALSE;
            goto CheckIfThisServerHasAUserThenUseIt_Exit;
        }

        // Check if just contains nothing
        if (_tcsicmp(szAnonyName, _T("")) == 0)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("...GetDataFromMetabase:username is blank.fail.\n")));
            iReturn = FALSE;
            goto CheckIfThisServerHasAUserThenUseIt_Exit;
        }

        // see if we can get the password too!
        iMetabaseUserExistsButCouldntGetPassword = TRUE;
        if (TRUE == GetDataFromMetabase(szMetabasePath, iMetabaseID_ForUserPassword, (PBYTE)szAnonyPassword, PWLEN+1))
        {
            iMetabaseUserExistsButCouldntGetPassword = FALSE;
        }
        // Yes, we got the username and password.
        // let's see if they are valid...
        MakeThisUserNameAndPasswordWork(iForWhichUser, szAnonyName, szAnonyPassword, iMetabaseUserExistsButCouldntGetPassword, FALSE);
        iReturn = TRUE;
    }

CheckIfThisServerHasAUserThenUseIt_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():End.ret=%d.\n"),CheckIfThisServerHasAUserThenUseIt_log,iReturn));
    return iReturn;
}


#define CheckIfServerAHasAUserThenUseForServerB_log _T("CheckIfServerAHasAUserThenUseForServerB")
int CheckIfServerAHasAUserThenUseForServerB(TCHAR *szServerAMetabasePath,int iServerBisWhichUser)
{
    int  iReturn = FALSE;
    TCHAR szAnonyName[UNLEN+1];
    TCHAR szAnonyPassword[PWLEN+1];
    int iMetabaseUserExistsButCouldntGetPassword = TRUE;
    iisDebugOut_Start(CheckIfServerAHasAUserThenUseForServerB_log);

    // see if www server has a user there, if it does then use that.

    // See if it's already in the metabase if it is then use that.
    if (TRUE == GetDataFromMetabase(szServerAMetabasePath, MD_ANONYMOUS_USER_NAME, (PBYTE)szAnonyName, UNLEN+1))
    {
        // Check if the username is null
        if (!szAnonyName)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("...GetDataFromMetabase:username is null.fail.\n")));
            iReturn = FALSE;
            goto CheckIfServerAHasAUserThenUseForServerB_Exit;
        }

        // Check if just contains nothing
        if (_tcsicmp(szAnonyName, _T("")) == 0)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("...GetDataFromMetabase:username is blank.fail.\n")));
            iReturn = FALSE;
            goto CheckIfServerAHasAUserThenUseForServerB_Exit;
        }

        // see if we can get the password too!
        iMetabaseUserExistsButCouldntGetPassword = TRUE;
        if (TRUE == GetDataFromMetabase(szServerAMetabasePath, MD_ANONYMOUS_PWD, (PBYTE)szAnonyPassword, PWLEN+1))
        {
            iMetabaseUserExistsButCouldntGetPassword = FALSE;
        }

        // Yes, we got the username and password.
        // let's see if they are valid...
        MakeThisUserNameAndPasswordWork(iServerBisWhichUser, szAnonyName, szAnonyPassword, iMetabaseUserExistsButCouldntGetPassword, FALSE);
        iReturn = TRUE;
    }

CheckIfServerAHasAUserThenUseForServerB_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():End.ret=%d.\n"),CheckIfServerAHasAUserThenUseForServerB_log,iReturn));
    return iReturn;
}

#endif // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\osrc\wwwcmpts.cxx ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        wwwcmpts.cxx

   Abstract:

        Classes that are used to Install and Uninstall the 
        WWW IIS Components.  These include ASP, IDC, WebDav,
        and SSINC

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       May 2002: Created

--*/

#include "stdafx.h"
#include "wwwcmpts.hxx"
#include "restrlst.hxx"

// GetSmallIcon
//
// Retrieve the small icon for a WWW Extension
//
BOOL 
CWWWExtensionInstallComponent::GetSmallIcon( HBITMAP *phIcon )
{
  *phIcon = LoadBitmap( (HINSTANCE) g_MyModuleHandle, 
                        MAKEINTRESOURCE( IDB_ICON_WWW_EXTENSION ));

  return ( *phIcon != NULL );
}

// GetName
// 
// Return the component name for ASP
//
LPTSTR
CWWWExtensionInstallComponent::GetName()
{
  // Return name for this component
  return g_OurExtensions[ GetComponentIndex() ].szUnattendName;
}

// GetFriendlyName
//
// Get the FriendlyName for the extension component
//
BOOL 
CWWWExtensionInstallComponent::GetFriendlyName( TSTR *pstrFriendlyName )
{
  return pstrFriendlyName->LoadString( g_OurExtensions[ GetComponentIndex() ].dwProductName );
}

// UpdateEntry
//
// Update the componet to enable or disable it
//
BOOL 
CWWWExtensionInstallComponent::UpdateEntry( BOOL bEnable )
{
  CRestrictionList RestrictionList;
  TSTR_PATH        strPhysicalPath;
  TSTR             strProductName;

  if ( !RestrictionList.InitMetabase() ||
       !RestrictionList.LoadCurrentSettings() )
  {
    if ( !bEnable )
    {
      // If this is uninstall, then we might not be able to load the metabase
      // because it has uninstalled, so this is okay
      return TRUE;
    }

    // We failed to load the list, so we could not update it
    return FALSE;
  }

  if ( !strPhysicalPath.Copy( g_pTheApp->m_csPathInetsrv.GetBuffer(0) ) ||
       !strPhysicalPath.PathAppend( g_OurExtensions[ GetComponentIndex() ].szFileName ) )
  {
    // Could not create Path, so exit
    return FALSE;
  }

  if ( !strProductName.LoadString( g_OurExtensions[ GetComponentIndex() ].dwProductName ) )
  {
    return FALSE;
  }

  if ( !RestrictionList.UpdateItem( 
                    strPhysicalPath.QueryStr(),
                    g_OurExtensions[ GetComponentIndex() ].szNotLocalizedGroupName,
                    strProductName.QueryStr(),
                    bEnable,
                    g_OurExtensions[ GetComponentIndex() ].bUIDeletable ) )
  {
    // Failed to update entry
    return FALSE;
  }

  if ( !RestrictionList.SaveSettings() )
  {
    // Failed to save settings
    return FALSE;
  }

  return TRUE;
}

// Install
//
// Install the specific componet
//
BOOL 
CWWWExtensionInstallComponent::Install()
{
  return UpdateEntry( TRUE );
}

// UnInstall
//
// UnInstall the specific componet
//
BOOL 
CWWWExtensionInstallComponent::UnInstall()
{
  return UpdateEntry( FALSE );
}

BOOL 
CWWWExtensionInstallComponent::IsInstalled( LPBOOL pbIsInstalled )
{
  CRestrictionList RestrictionList;

  if ( !RestrictionList.InitMetabase() ||
       !RestrictionList.LoadCurrentSettings() )
  {
    // We failed to load the list, so we could not update it
    return FALSE;
  }

  return RestrictionList.IsEnabled( g_OurExtensions[ GetComponentIndex() ].szNotLocalizedGroupName,
                                    pbIsInstalled );
}

// GetComponentIndex
//
// Return the component Index for the particular component
// in g_OurExtensions
//
DWORD 
CWWWASPInstallComponent::GetComponentIndex()
{
  return EXTENSION_ASP;
}

// GetComponentIndex
//
// Return the component Index for the particular component
// in g_OurExtensions
//
DWORD 
CWWWIDCInstallComponent::GetComponentIndex()
{
  return EXTENSION_HTTPODBC;
}

// GetComponentIndex
//
// Return the component Index for the particular component
// in g_OurExtensions
//
DWORD 
CWWWSSIInstallComponent::GetComponentIndex()
{
  return EXTENSION_SSINC;
}

// GetComponentIndex
//
// Return the component Index for the particular component
// in g_OurExtensions
//
DWORD 
CWWWWebDavInstallComponent::GetComponentIndex()
{
  return EXTENSION_WEBDAV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\globals.h ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        globals.h

   Abstract:

        Globals for Prject

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/


#define SERVICE_NAME_WEB              L"W3SVC"
#define SERVICE_MAXWAIT               ( 1000 * 60 * 15 )  // 15 Minutes
#define SERVICE_INTERVALCHECK         100                 // 100 ms
#define METABASE_URLSCANFILT_LOC      L"LM/W3SVC/FILTERS/URLSCAN"
#define URLSCAN_DEFAULT_FILENAME      L"urlscan.dll"
#define URLSCAN_BACKUPKEY             L"backup."
#define URLSCAN_INI_EXTENSION         L".ini"
#define URLSCAN_UPDATE_DEFAULT_NAME   L"urlscan.exe"
#define URLSCAN_TOOL_REGPATH          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\IisUrlScan"
#define URLSCAN_TOOL_KEY_NAME         L"DisplayName"
#define URLSCAN_TOOL_KEY_NEWVALUE     L"IIS UrlScan Tool 2.5 (Uninstall)"
#define URLSCAN_DLL_INSTALL_INTERVAL  500     // 500 ms
#define URLSCAN_DLL_INSTALL_MAXTRIES  10      // 10 times ( 5 seconds )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\parseini.cpp ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        parseini.cpp

   Abstract:

        Class used to parse the ini file

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/

#include "stdafx.h"
#include "windows.h"
#include "parseini.h"
#include "stdio.h"
#include "malloc.h"

// Constructor
//
CIniFileLine::CIniFileLine()
{
  m_szLine[0] = '\0';
  m_szStrippedLineContents[0] = '\0';
}

// CopyLine
//
// Copy the specific line into both our buffers
//
BOOL 
CIniFileLine::CopyLine(LPWSTR szNewLineContents)
{
  if ( _tcslen( szNewLineContents ) >= ( MAX_PATH - 1 ) )
  {
    // Right now we only support loading Lines of MAX_PATH
    // chars or less
    return FALSE;
  }

  // Copy String into both buffers
  _tcscpy(m_szLine, szNewLineContents);
  _tcscpy(m_szStrippedLineContents, szNewLineContents);

  // Strip off \r\n
  StripOffEOL( m_szLine );
  StripOffEOL( m_szStrippedLineContents );

  // Strip off Comments
  StripOffComments( m_szStrippedLineContents );

  // Stipp off trailing white
  StripOffTrailingWhite( m_szStrippedLineContents );

  return TRUE;
}

// CopyLine
//
// Copy the specific line into both our buffers
//
BOOL 
CIniFileLine::CopyLine(LPSTR szNewLineContents)
{
  WCHAR szBuffer[MAX_PATH];

  if ( !MultiByteToWideChar( CP_ACP,                //CP_THREAD_ACP doesn't work on NT4
                             MB_ERR_INVALID_CHARS,
                             szNewLineContents,     // Input String
                             -1,                    // Null terminated
                             szBuffer,
                             MAX_PATH ) )
  {
    return FALSE;
  }

  return CopyLine( szBuffer );
}

// StripOffEOL
// 
// Strip off the EOL markers
//
void
CIniFileLine::StripOffEOL(LPTSTR szString)
{
  LPTSTR szCurrent;

  szCurrent = _tcsstr( szString, L"\r" );

  if ( szCurrent )
  {
    *szCurrent = '\0';
    return;
  }

  szCurrent = _tcsstr( szString, L"\n" );

  if ( szCurrent )
  {
    // we won't hit this case, unless it was terminated with
    // just \n
    *szCurrent = '\0';
  }
}

// StripOffComments
//
// Strip off any comments that are in the line
//
void 
CIniFileLine::StripOffComments(LPTSTR szString)
{
  LPTSTR szCurrent;

  szCurrent = _tcsstr( szString, L";" );

  if ( szCurrent )
  {
    *szCurrent = '\0';
  }  
}

// Strip Off TrailingWhite
//
// strip off all the trailing while stuff in the line
//
void 
CIniFileLine::StripOffTrailingWhite(LPTSTR szString)
{
  // Set szCurrent at Null Terminator
  LPTSTR szCurrent = szString + _tcslen( szString );

  if ( ( *szCurrent == '\0' ) &&
       ( szCurrent != szString ) )
  {
    // Backup one character to start on the last char
    szCurrent--;
  }

  while ( ( szCurrent != szString ) &&
          ( ( *szCurrent == ' ' ) ||
            ( *szCurrent == '\t' ) )
        )
  {
    szCurrent--;
  }

  if ( *szCurrent != '\0' )
  {
    *( szCurrent + 1 ) = '\0';
  }
}

// QueryLine
//
// Query the contents of the line, before formatting
//
LPTSTR 
CIniFileLine::QueryLine()
{
  return m_szLine;
}

// QueryStrippedLine
//
// Query the line that has the comments, EOL, and 
// white spaces removed
//
LPTSTR 
CIniFileLine::QueryStrippedLine()
{
  return m_szStrippedLineContents;
}

// Constructor
//
CIniFile::CIniFile()
{
  // Initialize everything to empty
  m_pIniLines = NULL;
  m_dwNumberofLines = 0;
  m_dwLinesAllocated = 0;
  m_dwCurrentLine = 0;
  m_bUnicodeFile = FALSE;
}

// Destructor
//
CIniFile::~CIniFile()
{
  ClearIni();
}

// ClearIni
//
// Clear all of the data in the ini file class
//
void 
CIniFile::ClearIni()
{
  DWORD dwCurrent;

  if ( m_pIniLines )
  {
    for ( dwCurrent = 0;
          dwCurrent < m_dwLinesAllocated;
          dwCurrent ++ )
    {
      if ( m_pIniLines[dwCurrent] )
      {
        // Free memory, and reset to NULL
        delete m_pIniLines[dwCurrent];
        m_pIniLines[dwCurrent] = NULL;
      }
    }

    m_dwNumberofLines = 0;

    // Free Ini Table Altogether
    delete m_pIniLines;
    m_pIniLines = NULL;

    m_dwLinesAllocated = 0;
  }

}

// CreateMoreLines
//
// Create Room for more lines on the array.  This allows us to 
// stretch the array
BOOL 
CIniFile::CreateRoomForMoreLines()
{
  CIniFileLine  **pNewLines = NULL;
  DWORD         dwNewNumberofLinesAllocated = m_dwLinesAllocated ? 
                                              m_dwLinesAllocated * 2 : 
                                              INIFILE_INITIALNUMBEROFLINES;
  DWORD         dwCurrent;

  // Enlarge buffer
  pNewLines = (CIniFileLine **) realloc( m_pIniLines, 
              sizeof( CIniFileLine * ) * dwNewNumberofLinesAllocated );

  if ( pNewLines == NULL )
  {
    // Failure to enlarge.
    // Do not need to worry about old memory, since it is still valid in m_pIniLines
    return FALSE;
  }

  for ( dwCurrent = m_dwLinesAllocated; 
        dwCurrent < dwNewNumberofLinesAllocated; 
        dwCurrent++ )
  {
    // Initialize to Null
    pNewLines[ dwCurrent ] = NULL;
  }

  m_pIniLines = pNewLines;
  m_dwLinesAllocated = dwNewNumberofLinesAllocated;

  return TRUE;
}

// AddLine
//
// Add a line at a specific location
//
// Parameters:
//   dwLineNumber - The line number where it should be inserted
//
// Return 
//   NULL - Failure
//   Pointer - A pointer to the CIniFileLine for the new line
//
CIniFileLine * 
CIniFile::AddLine( DWORD dwLocation )
{
  CIniFileLine *pNewLine;
  DWORD         dwCurrentLine;

  if ( dwLocation > m_dwNumberofLines )
  {
    // Fail if we try to insert in a number to big
    return FALSE;
  }

  if ( ( m_dwNumberofLines == m_dwLinesAllocated ) &&
       !CreateRoomForMoreLines() )
  {
    // Could not create new lines for us
    return FALSE;
  }

  pNewLine = new (CIniFileLine);

  if ( !pNewLine ) 
  {
    // Failure to create new line
    return FALSE;
  }

  // Move all the lines after it down, to make room for this one
  if ( m_dwNumberofLines != 0 )
  {
    for ( dwCurrentLine = m_dwNumberofLines - 1; 
          dwCurrentLine >= dwLocation; 
          dwCurrentLine-- )
    {
      m_pIniLines[ dwCurrentLine + 1 ] = m_pIniLines[ dwCurrentLine ];
    }
  }

  m_pIniLines[ dwLocation ] = pNewLine;
  m_dwNumberofLines++;

  return pNewLine;
}

// FindSectionNumber
//
// Find a section by a specific name
//
// Parameters
//   szSectionName - [in]  Section to look for
//   pdwSection    - [out] The Line #
//
// Return:
//   TRUE - Found
//   FALSE - Not found
//   
BOOL
CIniFile::FindSectionNumber(LPTSTR szSectionName, DWORD *pdwSection)
{
  DWORD dwCurrentIndex;

//  ASSERT( pdwSection );

  for ( dwCurrentIndex = 0; dwCurrentIndex < m_dwNumberofLines; dwCurrentIndex++ )
  {
    if ( IsSameSection( szSectionName,
                        m_pIniLines[dwCurrentIndex]->QueryStrippedLine() ) )
    {
      *pdwSection = dwCurrentIndex;
      return TRUE;
    }
  }

  return FALSE;
}

// IsSameSection
//
// Returns if the section is the same of not
//
// Parameters
//   szSectionName - [in] The name of the Section (ie. TestSection)
//   szLines       - [in] The line in the file (ie. [TheSection])
//
// Return Values:
//   TRUE - The same
//   FALSE - Not the same
//
BOOL 
CIniFile::IsSameSection(LPTSTR szSectionName, LPTSTR szLine)
{
  LPTSTR szSectionCurrent;
  LPTSTR szLineCurrent;

  if ( szLine[0] != '[' )
  {
    // If the first character is not a '[', then 
    // it is not een a section
    return FALSE;
  }

  szSectionCurrent = szSectionName;
  szLineCurrent = szLine + 1;         // Skip preceding '['

  while ( ( towlower( *szSectionCurrent ) == towlower( *szLineCurrent ) ) &&
          ( *szSectionCurrent != '\0' )
        )
  {
    szSectionCurrent++;
    szLineCurrent++;
  }

  if ( ( *szSectionCurrent == '\0' ) &&
       ( *szLineCurrent == ']' ) &&
       ( *(szLineCurrent + 1) == '\0' )
     )
  {
    // They match
    return TRUE;
  }

  return FALSE;
}

// function: IsSameItem
//
// Is the Item Passed in, and the line, the same?
// Since items have nothing else on the line, this should
// be a simple _tcsicmp
//
// Parameters:
//   szItemName - [in] The Item Name
//   szLine     - [in] The Line that is passed in
//
BOOL 
CIniFile::IsSameItem(LPTSTR szItemName, LPTSTR szLine)
{
  return _tcsicmp( szItemName, szLine) == 0;
}

// function: IsSameSetting
// 
// Is the setting that is passed in, the same on
// that is on this specific line
//
// Parameters:
//   szSettingName - [in] The Name of the setting (ie. MaxPath)
//   szLine        - [in] The Line to comapre (ie. MaxPath=30)
// 
// Return Values:
//   TRUE == same
//   FALSE == no same
BOOL 
CIniFile::IsSameSetting(LPTSTR szSettingName, LPTSTR szLine)
{
  LPTSTR szSettingCurrent;
  LPTSTR szLineCurrent;

  szSettingCurrent = szSettingName;
  szLineCurrent = szLine;

  while ( ( towlower( *szSettingCurrent ) == towlower( *szLineCurrent ) ) &&
          ( *szSettingCurrent != '\0' )
        )
  {
    szSettingCurrent++;
    szLineCurrent++;
  }

  if ( ( *szSettingCurrent == '\0' ) &&
       ( *szLineCurrent == '=' )
     )
  {
    // They match
    return TRUE;
  }

  return FALSE;
}

// DoesSectionExist
// 
// Does the specified section exist?
//
BOOL 
CIniFile::DoesSectionExist(LPTSTR szSectionName)
{
  DWORD dwLineNumber;

  return FindSectionNumber( szSectionName, &dwLineNumber );
}

// GetLine
//
// Return a pointer to a particular line number
//
CIniFileLine *
CIniFile::GetLine(DWORD dwLineNumber)
{
  return m_pIniLines[ dwLineNumber ];
}

// FindSection
//
// Find a specific section, and set the current pointer to
// that section, then user FindNextLineInSection to parse
// through that section
//
// Parameters
//   szSectionName - [in] The Name of the Section
//
BOOL 
CIniFile::FindSection( LPTSTR szSectionName )
{
  if ( !FindSectionNumber( szSectionName, &m_dwCurrentLine ) )
  {
    // Could not find section
    return FALSE;
  }

  return TRUE;
}

// FindNextLineInSection
//
// Find the next Line in the section, if any are left
//
BOOL 
CIniFile::FindNextLineInSection( CIniFileLine  **ppCurrentLine )
{
  // Increment Line number
  m_dwCurrentLine++;

  if ( ( m_dwCurrentLine >= m_dwLinesAllocated ) ||
       ( GetLine( m_dwCurrentLine ) == NULL ) )
  {
    // We have either gone past the last line, 
    // or it does not exist, so return FALSE
    return FALSE;
  }

  if ( GetLine( m_dwCurrentLine )->QueryStrippedLine()[0] == '[' )
  {
    // We have hit the begining of another section, so exit
    return FALSE;
  }

  *ppCurrentLine = GetLine( m_dwCurrentLine );
  return TRUE;
}

// DoesItemInSectionExist
//
// Does an Item in a particular section exist
//
// Parameters:
//   szSectionName - [in] The section to search
//   szItem        - [in] The Item to find
//
// Return Values:
//   TRUE - It exists
//   FALSE - It does not exist
//
BOOL 
CIniFile::DoesItemInSectionExist(LPTSTR szSectionName, LPTSTR szItem)
{
  CIniFileLine  *pCurrentLine;

  if ( !FindSection( szSectionName ) )
  {
    // Could not find section, forget about the item
    return FALSE;
  }

  while ( FindNextLineInSection( &pCurrentLine ) )
  {
    if ( IsSameItem( szItem, pCurrentLine->QueryStrippedLine() ) )
    {
      // We have found the item
      return TRUE;
    }
  }

  return FALSE;
}

// DoesSettingInSectionExist
//
// Does an Setting in a particular section exist
//
// Parameters:
//   szSectionName - [in] The section to search
//   szSetting     - [in] The Setting to find
//
// Return Values:
//   TRUE - It exists
//   FALSE - It does not exist
//
BOOL 
CIniFile::DoesSettingInSectionExist(LPTSTR szSectionName, LPTSTR szSetting)
{
  CIniFileLine  *pCurrentLine;

  if ( !FindSection( szSectionName ) )
  {
    // Could not find section, forget about the item
    return FALSE;
  }

  while ( FindNextLineInSection( &pCurrentLine ) )
  {
    if ( IsSameSetting( szSetting, pCurrentLine->QueryStrippedLine() ) )
    {
      // We have found the item
      return TRUE;
    }
  }

  return FALSE;
}

// GetNumberofLines
//
// Return the number of lines in the ini file
//
DWORD 
CIniFile::GetNumberofLines()
{
  return m_dwNumberofLines;
}

// AddSection
//
// Add a Section to the File
// (it inserts at end)
//
BOOL 
CIniFile::AddSection(LPTSTR szNewSectionName)
{
  TCHAR        szBuffer[MAX_PATH];
  CIniFileLine *pNewLine;

  if ( _tcslen( szNewSectionName ) >= ( MAX_PATH - 3 ) )  // Leave room for [,],\0
  {
    return FALSE;
  }

  // Add a new line at the end
  pNewLine = AddLine( GetNumberofLines() );

  if ( !pNewLine )
  {
    // Failed to Add
    return FALSE;
  }

  _tcscpy(szBuffer, L"[");
  _tcscat(szBuffer, szNewSectionName);
  _tcscat(szBuffer, L"]");

  if ( !pNewLine->CopyLine( szBuffer ) )
  {
    // Failed to copy data
    return FALSE;
  }

  // It has now been added, and updated with text
  return TRUE;
}

// SetStartforSectionIterator
//
// Set the current line for the Section Iterator,
// this is so that you can start at anyline in the file you want
// and iterate through that section
//
BOOL 
CIniFile::SetStartforSectionIterator( DWORD dwIndex )
{
  if ( dwIndex >= m_dwNumberofLines )
  {
    return FALSE;
  }

  m_dwCurrentLine = dwIndex;

  return TRUE;
}

// GetCurrentSectionIteratorLine
// 
// Get current line that the iterator has
//
DWORD
CIniFile::GetCurrentSectionIteratorLine()
{
  return m_dwCurrentLine;
}

// AddLinesToSection
//
// Add Lines to a specific section
// This is what we use to update the ini files with the new options
//
// Note: This will not create the section for you, so do that before
//       you call this function
// Note2: If this function fails, it is possible to have part of your
//        data in the file, so in essence, it is probably corrupted
//
// Parameters:
//   szSectionName - The name of the section to update
//   dwNumLines    - The number of Lines in **szLines
//   szLines       - An array of lines to add (Null terminated) 
//                   (no \r\n's are needed)
//
// Return Values:
//   TRUE - Added Successfully
//   FALSE - Failed to Add
//
BOOL 
CIniFile::AddLinesToSection(LPTSTR szSectionName, DWORD dwNumLines, LPTSTR *szLines)
{
  CIniFileLine  *pCurrentLine;
  DWORD         dwCurrentLineinFile;
  DWORD         dwCurrentLineinInput;

  if ( !FindSection( szSectionName ) )
  {
    // Failed to find section, bail now
    return FALSE;
  }

  while ( FindNextLineInSection( &pCurrentLine ) )
  {
    // Do nothing, just iterate through the section
  }

  dwCurrentLineinFile = GetCurrentSectionIteratorLine();

  for ( dwCurrentLineinInput = 0;
        dwCurrentLineinInput < dwNumLines;
        dwCurrentLineinInput++, dwCurrentLineinFile++ )
  {
    pCurrentLine = AddLine( dwCurrentLineinFile );

    if ( !pCurrentLine || 
         !pCurrentLine->CopyLine( szLines[ dwCurrentLineinInput ] )
       )
    {
      // We failed to add the line, or to add contents to 
      // it, so we must bail
      return FALSE;
    }
  }

  return TRUE;
}

// LoadFile
//
// Load the ini file from the OS
//
BOOL 
CIniFile::LoadFile( LPTSTR szFileName )
{
  HANDLE  hFile;
  BOOL    bRet;

  hFile = CreateFile( szFileName,
                      GENERIC_READ, // Read
                      0,            // No sharing
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL );

  if ( hFile == INVALID_HANDLE_VALUE )
  {
    // Could not open file, Doh!
    return FALSE;
  }

  bRet = ReadFileContents( hFile );

  // Close File
  CloseHandle( hFile );

  return bRet;
}

// ReadFileContents
//
// Read all of the FileContents into memory
//
BOOL 
CIniFile::ReadFileContents( HANDLE hFile )
{
  BYTE pBuffer[INIFILE_READ_CHUNK_SIZE + 2];   // For \0\0
  DWORD dwCurrentLocation = 0;
  DWORD dwBytesRead;
  BOOL  bRet = TRUE;
  
  m_bUnicodeFile = FALSE;

  if ( ReadFile( hFile, pBuffer, 2, &dwCurrentLocation, NULL ) &&
       ( dwCurrentLocation == 2 ) &&
       ( pBuffer[0] == 0xFF ) &&
       ( pBuffer[1] == 0xFE )
       )
  {
    // Since there is the 0xFF, 0xFE we will assume it is unicode
    m_bUnicodeFile = TRUE;
    // Reset Pointer, so we ignore the FFFE.
    dwCurrentLocation = 0;
  }

  while ( ReadFile( hFile,
                    pBuffer + dwCurrentLocation,
                    INIFILE_READ_CHUNK_SIZE - dwCurrentLocation,
                    &dwBytesRead,
                    NULL ) &&
          ( dwBytesRead != 0 ) )
  {
    dwCurrentLocation += dwBytesRead;
    pBuffer[dwCurrentLocation] = '\0';
    pBuffer[dwCurrentLocation + 1 ] = '\0';

    if ( !LoadChunk( pBuffer, &dwCurrentLocation, FALSE ) )
    {
      bRet = FALSE;
      break;
    }
  }

  if ( bRet )
  {
    if ( !LoadChunk( pBuffer, &dwCurrentLocation, TRUE) )
    {
      bRet = FALSE;
    }
  }

  return bRet;
}

// LoadChunk
//
// Load the Chunk of Data from this buffer, into the ini 
// class lines
//
// Parameters
//   pData              - [in/out] Buffer of Bytes to be loaded
//   pdwCurrentLocation - [in/out] Location of end of buffer
//   bIsLastChunck      - [in]     Flag to tells us if this is the last chunk
BOOL 
CIniFile::LoadChunk( LPBYTE pData, DWORD *pdwCurrentLocation, BOOL bIsLastChunk )
{
  LPBYTE        szEndofLine;
  LPBYTE        szNextLine;
  CIniFileLine  *pCurrentLine;

  while ( *pdwCurrentLocation > 0 )
  {
    szEndofLine = m_bUnicodeFile ? (LPBYTE) wcsstr( (LPWSTR) pData, L"\r" ) :
                                   (LPBYTE) strstr( (LPSTR) pData, "\r" );

    if ( szEndofLine == NULL )
    {
      szEndofLine = m_bUnicodeFile ? (LPBYTE) wcsstr( (LPWSTR) pData, L"\n" ) :
                                     (LPBYTE) strstr( (LPSTR) pData, "\n" );
      // Move to next line (this is \n, so it is only 1 char away)
      szNextLine = szEndofLine + ( m_bUnicodeFile ? 2 : 1 );
    }
    else
    {
      // \r was found

      if ( m_bUnicodeFile )
      {
        // Jump past \r, or \r\n
        szNextLine = szEndofLine + ( *( (LPWSTR) szEndofLine + 1 ) == '\n' ?
                                   4 : 2 );
      }
      else
      {
        // Jump past \r, or \r\n
        szNextLine = szEndofLine + ( *( (LPSTR) szEndofLine + 1) == '\n' ?
                                   2 : 1 );
      }

      if ( !bIsLastChunk &&
           ( m_bUnicodeFile ? *( (LPWSTR) szEndofLine + 1) == '\0' :
                              *( (LPSTR)  szEndofLine + 1) == '\0' ) )
      {
        // This is a \r with a \0 imediately after it, this might mean that we have
        // not read enough, so lets return and lets read another chunk
        return TRUE;
      }
    }

    if ( !szEndofLine )
    {
      if ( bIsLastChunk )
      {
        szEndofLine = pData + *pdwCurrentLocation;
        szNextLine = szEndofLine;
      }
      else
      {
        // Can not find another line, so exit
        return TRUE;
      }
    }

    // Null Terminate Here
    if ( m_bUnicodeFile )
    {
      wcscpy( (LPWSTR) szEndofLine, L"\0" );
    }
    else
    {
      strcpy( (LPSTR) szEndofLine, "\0" );
    }

    if ( ( ( pCurrentLine = AddLine( GetNumberofLines() ) ) == NULL ) ||
         !( m_bUnicodeFile ? pCurrentLine->CopyLine( (LPWSTR) pData ) :
                             pCurrentLine->CopyLine( (LPSTR) pData ) )
       )
    {
      // Error Adding Line
      return FALSE;
    }

    // Remove that part of the line
    memmove( pData, szNextLine, *pdwCurrentLocation - (szNextLine - pData) + 2 ); // +2 for \0\0
    *pdwCurrentLocation -= (DWORD) (szNextLine - pData);
  }

  return TRUE;
}

// SaveFile
//
// Save the ini file to disk
//
BOOL 
CIniFile::SaveFile( LPTSTR szFileName )
{
  HANDLE  hFile;
  BOOL    bRet;

  hFile = CreateFile( szFileName,
                      GENERIC_WRITE, // Read
                      0,             // No sharing
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL );

  if ( hFile == INVALID_HANDLE_VALUE )
  {
    // Could not create the file
    return FALSE;
  }

  bRet = WriteFileContents( hFile );

  // Close File
  CloseHandle( hFile );

  return bRet;
}

// WriteFileContents
//
// Write the ini contents to the file
//
BOOL 
CIniFile::WriteFileContents( HANDLE hFile )
{
  DWORD dwCurrent;
  CHAR  szLine[MAX_PATH];
  DWORD dwBytesWritten;

  if ( m_bUnicodeFile )
  {
    // If this file is unicode, lets write the prefix 0xFF,0xFE right now
    BYTE pData[2] = { 0xFF, 0xFE };

    if ( !WriteFile( hFile, pData, sizeof( pData ),
                &dwBytesWritten, NULL ) )
    {
      // Failed to write to file
      return FALSE;
    }
  }

  for ( dwCurrent = 0; dwCurrent < GetNumberofLines(); dwCurrent++ )
  {
    if ( !m_bUnicodeFile )
    {
      // If not unicode, then we need to translate back to Ansi
      if ( !WideCharToMultiByte( CP_ACP,                //CP_THREAD_ACP doesn't work on NT4
                                 0,
                                 GetLine( dwCurrent )->QueryLine(),
                                 -1,            // Null terminated
                                 szLine,
                                 MAX_PATH,
                                 NULL,
                                 NULL) )
      {
        // Line could not be converted, so lets fail
        return FALSE;
      }
    }

    // Write line to file
    if ( !WriteFile( hFile,
                    m_bUnicodeFile ? (LPBYTE) GetLine( dwCurrent )->QueryLine():
                                     (LPBYTE) szLine,
                    m_bUnicodeFile ? (DWORD) wcslen( GetLine( dwCurrent )->QueryLine() ) * sizeof( WCHAR ):
                                     (DWORD) strlen( szLine ) * sizeof( CHAR),
                    &dwBytesWritten,
                    NULL ) )
    {
      // Failed to write Line
      return FALSE;
    }
                    
    // Line Terminators
    if ( !WriteFile( hFile,
                    m_bUnicodeFile ? (LPBYTE) L"\r\n":
                                     (LPBYTE) "\r\n",
                    m_bUnicodeFile ? (DWORD) wcslen( L"\r\n" ) * sizeof( WCHAR ) :
                                     (DWORD) strlen( "\r\n") * sizeof( CHAR) ,
                    &dwBytesWritten,
                    NULL ) )
    {
      // Failed to write Line
      return FALSE;
    }

  } // for

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\parseini.h ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        parseini.h

   Abstract:

        Class used to parse the ini file

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/

#include "stdafx.h"

#define INIFILE_INITIALNUMBEROFLINES      10
#define INIFILE_READ_CHUNK_SIZE           1024

class CIniFileLine {
private:
  TCHAR m_szLine[MAX_PATH];
  TCHAR m_szStrippedLineContents[MAX_PATH];

  void StripOffComments(LPTSTR szString);
  void StripOffEOL(LPTSTR szString);
  void StripOffTrailingWhite(LPTSTR szString);
public:
  CIniFileLine();

  BOOL    CopyLine(LPWSTR szNewLineContents);
  BOOL    CopyLine(LPSTR szNewLineContents);
  LPTSTR  QueryLine();
  LPTSTR  QueryStrippedLine();
};

class CIniFile {
private:
  CIniFileLine  **m_pIniLines;
  DWORD         m_dwNumberofLines;
  DWORD         m_dwLinesAllocated;
  BOOL          m_bUnicodeFile;
  DWORD         m_dwCurrentLine;
  
  BOOL          CreateRoomForMoreLines();
  CIniFileLine  *AddLine( DWORD dwLineNumber );
  BOOL          FindSectionNumber(LPTSTR szSectionName, DWORD *pdwSection);
  BOOL          IsSameSection(LPTSTR szSectionName, LPTSTR szLine);
  BOOL          IsSameItem(LPTSTR szItemName, LPTSTR szLine);
  BOOL          IsSameSetting(LPTSTR szSettingName, LPTSTR szLine);
  CIniFileLine  *GetLine(DWORD dwLineNumber);
  DWORD         GetNumberofLines();
  BOOL          ReadFileContents( HANDLE hFile );
  BOOL          LoadChunk( LPBYTE pData, DWORD *pdwCurrentLocation, BOOL bIsLastChunk);
  BOOL          WriteFileContents( HANDLE hFile );
  void          ClearIni();


  // Iterators
  BOOL          SetStartforSectionIterator( DWORD dwIndex );
  BOOL          FindSection( LPTSTR szSectionName );
  BOOL          FindNextLineInSection( CIniFileLine  **ppCurrentLine );
  DWORD         GetCurrentSectionIteratorLine();

public:
  CIniFile();
  ~CIniFile();

  // Find a section by a specific name
  BOOL DoesSectionExist(LPTSTR szSectionName);

  // Find a stand along Item in a secion by a specific name (ie. PROPFIND)
  BOOL DoesItemInSectionExist(LPTSTR szSectionName, LPTSTR szItem);

    // Find a Setting in a section by the setting name (ie. AllowHighBitCharacters=...)
  BOOL DoesSettingInSectionExist(LPTSTR szSectionName, LPTSTR szSetting);

  // Add a specific section
  BOOL AddSection(LPTSTR szNewSectionName);

  // Add a line to a specific section
  BOOL AddLinesToSection(LPTSTR szSectionName, DWORD dwNumLines, LPTSTR *szLines);

  BOOL LoadFile( LPTSTR szFileName );
  BOOL SaveFile( LPTSTR szFileName );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// updurls2.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
#include "windows.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by updurls2.rc
//
#define IDS_TITLEBAR                    102
#define IDR_DATA1                       103
#define IDS_SUCCESS_UPDATE              107
#define IDS_SUCCESS_EXTRACT             108
#define IDS_USAGE                       109
#define IDS_ERROR_EXTRACT               110
#define IDS_ERROR_NOTINSTALLED          111
#define IDS_ERROR_WEBSERVICE            112
#define IDS_ERROR_ADMIN                 113
#define IDS_ERROR_INIUPDATE             114
#define IDS_ERROR_DLLUPDATE             115
#define IDS_ERROR_RESTARTWEB            116

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\service.h ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        service.h

   Abstract:

        Functions to control the SCM

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/

BOOL StopWebSerivce( BOOL *bWasRunning );
BOOL StartWebSerivce();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\service.cpp ===
/*++

   Copyright    (c)    2002    Microsoft Corporation

   Module  Name :

        service.cpp

   Abstract:

        Functions to control the SCM

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/

#include "stdafx.h"
#include "windows.h"
#include "service.h"

// StopService
//
// Stop a service, given a handle to it
//
BOOL
StopService( SC_HANDLE hService )
{
  SERVICE_STATUS  svcStatus;
  DWORD           dwTimeWaited = 0;

  if ( !ControlService( hService, SERVICE_CONTROL_STOP, &svcStatus ))
  {
    // Could not send stop message
    return FALSE;
  }

  while ( QueryServiceStatus( hService, & svcStatus ) &&
          ( svcStatus.dwCurrentState == SERVICE_STOP_PENDING ) &&
          ( dwTimeWaited < SERVICE_MAXWAIT )
        )
  {
    Sleep( SERVICE_INTERVALCHECK );
    dwTimeWaited += SERVICE_INTERVALCHECK;
  }

  return svcStatus.dwCurrentState == SERVICE_STOPPED;
}

// Stop the webService
//
// Stops the web service, and also tells us if it was running
//
// Paramters:
//   bWasRunning - TRUE == web service was running before it was stopped
//                 FALSE == it was not running, so it did not need to be stopped
//
// Return Values:
//   TRUE - Successfully stopped
//   FALSE - Could not be stopped
//
BOOL 
StopWebSerivce( BOOL *bWasRunning )
{
  SC_HANDLE       hManager = NULL;
  SC_HANDLE       hService = NULL;
  SERVICE_STATUS  svcStatus;
  BOOL            bRunning = FALSE;
  BOOL            bRet = TRUE;

//  ASSERT( bWasRunning );

  hManager = OpenSCManager( NULL, NULL, GENERIC_ALL );

  if ( hManager == NULL )
  {
    // Could not open SCM
    return FALSE;
  }

  hService = ::OpenService( hManager, SERVICE_NAME_WEB, GENERIC_ALL );

  if ( hService == NULL )
  {
    // could not open Service
    CloseServiceHandle( hManager );
    return FALSE;
  }

  if ( QueryServiceStatus( hService, &svcStatus ))
  {
    bRunning = svcStatus.dwCurrentState != SERVICE_STOPPED;

    if ( bRunning )
    {
      // If it is running, try to stop it
      bRet = StopService( hService );
    }
  }
  else
  {
    bRet = FALSE;
  }

  if ( bRet )
  {
    *bWasRunning = bRunning;
  }

  if ( hManager )
  {
    CloseServiceHandle( hManager );
  }

  if ( hService )
  {
    CloseServiceHandle( hService );
  }

  return bRet;
}

// StartWebService
//
// Start the WebSerivce
//
// Return
//   TRUE - Successfuly started
//   FALSE - Unsuccessful, not started
BOOL 
StartWebSerivce()
{
  SC_HANDLE       hManager = NULL;
  SC_HANDLE       hService = NULL;
  BOOL            bRet = FALSE;

  hManager = OpenSCManager( NULL, NULL, GENERIC_ALL );

  if ( hManager == NULL )
  {
    // Could not open SCM
    return FALSE;
  }

  hService = ::OpenService( hManager, SERVICE_NAME_WEB, GENERIC_ALL );

  if ( hService )
  {
    if ( StartService( hService, 0, NULL ) )
    {
      bRet = TRUE;
    }
  }

  if ( hManager )
  {
    CloseServiceHandle( hManager );
  }

  if ( hService )
  {
    CloseServiceHandle( hService );
  }

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <stdio.h>
#include <tchar.h>

// TODO: reference additional headers your program requires here
#include "globals.h"

//#define _WIN32_WINNT 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\updateini.cpp ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        updateini.cpp

   Abstract:

        High level function to update the ini with new values

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/


#include "stdafx.h"
#include "windows.h"
#include "updateini.h"
#include "parseini.h"

sURLScan_Settings g_urlSettings[] = 
  { { L"options",
      L"UseAllowVerbs",
      { L"UseAllowVerbs=1                ; If 1, use [AllowVerbs] section, else use the",
        L"                               ; [DenyVerbs] section.",
        L"",
        NULL }
    }, // UseAllowVerbs
    { L"options",
      L"UseAllowExtensions",
      { L"UseAllowExtensions=0           ; If 1, use [AllowExtensions] section, else use",
        L"                               ; the [DenyExtensions] section.",
        L"",
        NULL }
    }, // UseAllowExtensions
    { L"options",
      L"NormalizeUrlBeforeScan",
      { L"NormalizeUrlBeforeScan=1       ; If 1, canonicalize URL before processing.",
        L"",
        NULL }
    }, // NormalizeUrlBeforeScan
    { L"options",
      L"VerifyNormalization",
      { L"VerifyNormalization=1          ; If 1, canonicalize URL twice and reject request",
        L"                               ; if a change occurs.",
        NULL }
    }, // VerifyNormalization
    { L"options",
      L"AllowHighBitCharacters",
      { L"AllowHighBitCharacters=0       ; If 1, allow high bit (ie. UTF8 or MBCS)",
        L"                               ; characters in URL.",
        L"",
        NULL } 
    }, // AllowHighBitCharacters
    { L"options",
      L"AllowDotInPath",
      { L"AllowDotInPath=0               ; If 1, allow dots that are not file extensions.",
        L"",
        NULL }
    }, // AllowDotInPath
    { L"options",
      L"RemoveServerHeader",
      { L"RemoveServerHeader=0           ; If 1, remove the 'Server' header from response.",
        L"",
        NULL }
    }, // RemoveServerHeader
    { L"options",
      L"EnableLogging",
      { L"EnableLogging=1                ; If 1, log UrlScan activity.",
        L"",
        NULL }
    }, // EnableLogging
    { L"options",
      L"PerProcessLogging",
      { L"PerProcessLogging=0            ; If 1, the UrlScan.log filename will contain a PID",
        L"                               ; (ie. UrlScan.123.log).",
        L"",
        NULL }
    }, // PerProcessLogging
    { L"options",
      L"AllowLateScanning",
      { L"AllowLateScanning=0            ; If 1, then UrlScan will load as a low priority",
        L"                               ; filter.",
        L"",
        NULL }
    }, // AllowLateScanning
    { L"options",
      L"PerDayLogging",
      { L"PerDayLogging=1                ; If 1, UrlScan will produce a new log each day with",
        L"                               ; activity in the form 'UrlScan.010101.log'.",
        L"",
        NULL }
    }, // PerDayLogging
    { L"options",
      L"UseFastPathReject",
      { L"UseFastPathReject=0            ; If 1, then UrlScan will not use the",
        L"                               ; RejectResponseUrl or allow IIS to log the request.",
        L"",
        NULL }
    }, // UseFastPathReject
    { L"options",     // Section Name
      L"LogLongUrls", // Setting Name
      { L"LogLongUrls=0                  ; If 1, then up to 128K per request can be logged.",
        L"                               ; If 0, then only 1k is allowed.",
        L"",
        NULL }
    }, // LogLongURLs
    { L"options",
      L"RejectResponseUrl",
      { L";",
        L"; If UseFastPathReject is 0, then UrlScan will send",
        L"; rejected requests to the URL specified by RejectResponseUrl.",
        L"; If not specified, '/<Rejected-by-UrlScan>' will be used.",
        L";",
        L"",
        L"RejectResponseUrl=",
        L"",
        NULL }
    }, // RejectResponseUrl
    { L"options",
      L"LoggingDirectory",
      { L";",
        L"; LoggingDirectory can be used to specify the directory where the",
        L"; log file will be created.  This value should be the absolute path",
        L"; (ie. c:\\some\\path).  If not specified, then UrlScan will create",
        L"; the log in the same directory where the UrlScan.dll file is located.",
        L";",
        L"",
        L"LoggingDirectory=",
        L"",
        NULL }
    }, // Logging Directory
    { L"options",
      L"AlternateServerName",
      { L";",
        L"; If RemoveServerHeader is 0, then AlternateServerName can be",
        L"; used to specify a replacement for IIS's built in 'Server' header",
        L";",
        L"",
        L"AlternateServerName=",
        L"",
        NULL }
    }, // AlternateServerName
    { L"RequestLimits",
      L"MaxUrl",
      { L"MaxUrl=16384",
        NULL }
    }, // MaxUrl
    { L"RequestLimits",
      L"MaxQueryString",
      {  L"MaxQueryString=4096",
         NULL}
    }, // MaxQueryString
    { L"RequestLimits",
      L"MaxAllowedContentLength",
#ifdef PLEASE_BUILD_LESS_AGRESSIVE_DEFAULTS_VERSION
      { L"MaxAllowedContentLength=2000000000",
#else
      { L"MaxAllowedContentLength=30000000",
#endif
        NULL }
    } // MaxAllowedContentLength
  };

sURLScan_Sections g_urlSections[] = 
  { { L"RequestLimits",   // Section Name
      { L"",
        L";",
        L"; The entries in this section impose limits on the length",
        L"; of allowed parts of requests reaching the server.",
        L";",
        L"; It is possible to impose a limit on the length of the",
        L"; value of a specific request header by prepending \"Max-\" to the",
        L"; name of the header.  For example, the following entry would",
        L"; impose a limit of 100 bytes to the value of the",
        L"; 'Content-Type' header:",
        L";",
        L";   Max-Content-Type=100",
        L";",
        L"; To list a header and not specify a maximum value, use 0",
        L"; (ie. 'Max-User-Agent=0').  Also, any headers not listed",
        L"; in this section will not be checked for length limits.",
        L";",
        L"; There are 3 special case limits:",
        L";",
        L";   - MaxAllowedContentLength specifies the maximum allowed",
        L";     numeric value of the Content-Length request header.  For",
        L";     example, setting this to 1000 would cause any request",
        L";     with a content length that exceeds 1000 to be rejected.",
#ifdef PLEASE_BUILD_LESS_AGRESSIVE_DEFAULTS_VERSION
        L";     The default is 2000000000.",
#else
        L";     The default is 30000000.",
#endif
        L";",
        L";   - MaxUrl specifies the maximum length of the request URL,",
        L";     not including the query string. The default is 260 (which",
        L";     is equivalent to MAX_PATH).",
        L";",
        L";   - MaxQueryString specifies the maximum length of the query",
        L";     string.  The default is 4096.",
        L";",
        L"",
#ifdef PLEASE_BUILD_LESS_AGRESSIVE_DEFAULTS_VERSION
        L"MaxAllowedContentLength=2000000000",
#else
        L"MaxAllowedContentLength=30000000",
#endif
        L"MaxUrl=16384",
        L"MaxQueryString=4096",
        L"",
        NULL }
    }  // end of RequestLimits
  };

sURLScan_Items g_urlItems[] =
  { { L"DenyHeaders",
      L"Transfer-Encoding:",
      { L"Transfer-Encoding:",
        NULL }
    }
  };

// GetListLen
//
// Retrieve the Length of a variable length array of Strings
// This is a special case function that works for our structs
// above, because we leave the last String as NULL
//
DWORD GetListLen(LPWSTR szLines[])
{
  DWORD dwLen = 0;

  while ( szLines[dwLen] != NULL )
  {
    dwLen++;
  }

  return dwLen;
}

// GetIniPath
//
// Given the Path to the Dll, create the path to the ini
//
// Parameters:
//   szDllPath - [in]  The path to the binary for urlscan.dll
//   szIniPath - [out] The path to the ini file
//   dwIniLen  - [in]  The length of the string passed in for szIniPath
//
BOOL GetIniPath( LPTSTR szDllPath, LPTSTR szIniPath, DWORD dwIniLen )
{
  LPTSTR szLastPeriod;

  if ( _tcslen( szDllPath ) >= ( dwIniLen - 3 ) )
  {
    // Error, string is not big enough
    return FALSE;
  }

  _tcscpy( szIniPath, szDllPath);

  szLastPeriod = _tcsrchr( szIniPath, '.' );

  if ( !szLastPeriod )
  {
    // Can not find the extension
    return FALSE;
  }

  _tcscpy( szLastPeriod, URLSCAN_INI_EXTENSION );

  return TRUE;
}

// UpdateIniSections
//
// Update the Sections in the Ini, by merging them with the ones we have
// defined
//
BOOL UpdateIniSections( CIniFile *pURLScanIniFile )
{
  DWORD dwCurrentSection;

  for ( dwCurrentSection = 0;
        dwCurrentSection < ( (DWORD) sizeof( g_urlSections ) / sizeof ( sURLScan_Sections ) );
        dwCurrentSection++)
  {
    if ( !pURLScanIniFile->DoesSectionExist( g_urlSections[ dwCurrentSection].szSection ) )
    {
      // Try to Create Section Then
      if ( !pURLScanIniFile->AddSection( g_urlSections[dwCurrentSection].szSection ) )
      {
        // Failed to Add Section
        return FALSE;
      }

      // Now try to add the correct lines to it
      if ( g_urlSections[dwCurrentSection].szLines &&
           !pURLScanIniFile->AddLinesToSection( g_urlSections[dwCurrentSection].szSection,
                                               GetListLen( g_urlSections[dwCurrentSection].szLines ),
                                               g_urlSections[dwCurrentSection].szLines ) )
      {
        // Failed to Add Lines
        return FALSE;
      }
    }
  }

  return TRUE;
}

// UpdateIniSettings
//
// Update the Ini Settings inside the different sections if they are
// not already set
//
BOOL UpdateIniSettings( CIniFile *pURLScanIniFile )
{
  DWORD dwCurrentSettings;

  for ( dwCurrentSettings = 0;
        dwCurrentSettings < ( (DWORD) sizeof( g_urlSettings ) / sizeof ( sURLScan_Settings ) );
        dwCurrentSettings++)
  {
    if ( !pURLScanIniFile->DoesSectionExist( g_urlSettings[ dwCurrentSettings].szSection ) )
    {
      // Create Section Since it does not exist
      if ( !pURLScanIniFile->AddSection( g_urlSettings[dwCurrentSettings].szSection ) )
      {
        return FALSE;
      }
    } // !pURLScanIniFile->DoesSectionExist

    if ( !pURLScanIniFile->DoesSettingInSectionExist( g_urlSettings[dwCurrentSettings].szSection,
                                                      g_urlSettings[dwCurrentSettings].szSettingName ) )
    {
      // This setting does not exist, so lets add it
      if ( !pURLScanIniFile->AddLinesToSection( g_urlSettings[dwCurrentSettings].szSection,
                                                GetListLen( g_urlSettings[dwCurrentSettings].szLines ),
                                                g_urlSettings[dwCurrentSettings].szLines ) )
      {
        return FALSE;
      }
    } // !pURLScanIniFile->DoesSettingInSectionExist
  }

  return TRUE;
}

// UpdateIniItems
//
// Update the Ini Settings inside the different sections if they are
// not already set
//
BOOL UpdateIniItems( CIniFile *pURLScanIniFile )
{
  DWORD dwCurrentItems;

  for ( dwCurrentItems = 0;
        dwCurrentItems < ( (DWORD) sizeof( g_urlItems ) / sizeof ( sURLScan_Items ) );
        dwCurrentItems++)
  {
    if ( !pURLScanIniFile->DoesSectionExist( g_urlItems[ dwCurrentItems].szSection ) )
    {
      // Create Section Since it does not exist
      if ( !pURLScanIniFile->AddSection( g_urlSettings[dwCurrentItems].szSection ) )
      {
        return FALSE;
      }
    } // !pURLScanIniFile->DoesSectionExist

    if ( !pURLScanIniFile->DoesItemInSectionExist( g_urlItems[dwCurrentItems].szSection,
                                                      g_urlItems[dwCurrentItems].szSettingName ) )
    {
      // This setting does not exist, so lets add it
      if ( !pURLScanIniFile->AddLinesToSection( g_urlItems[dwCurrentItems].szSection,
                                                GetListLen( g_urlItems[dwCurrentItems].szLines ),
                                                g_urlItems[dwCurrentItems].szLines ) )
      {
        return FALSE;
      }
    } // !pURLScanIniFile->DoesItemInSectionExist
  }

  return TRUE;
}

// UpdateIni File
//
// Update the inf file with the new features
//
BOOL UpdateIni( LPTSTR szUrlScanPath )
{
  CIniFile URLScanIniFile;
  TCHAR    szIniLocation[MAX_PATH];
  BOOL     bRet = TRUE;

  if ( !GetIniPath( szUrlScanPath, szIniLocation, MAX_PATH ) ||
       !URLScanIniFile.LoadFile( szIniLocation ) )
  {
    // Either we couldn't determine the location, or we couldn't
    // load the file
    return FALSE;
  }

  if ( bRet )
  {
    // Note: UpdateIniSections must come before UpdateIniSettings
#ifdef PLEASE_BUILD_LESS_AGRESSIVE_DEFAULTS_VERSION
    bRet = UpdateIniSections( &URLScanIniFile ) &&
           UpdateIniSettings( &URLScanIniFile );
#else
    bRet = UpdateIniSections( &URLScanIniFile ) &&
           UpdateIniSettings( &URLScanIniFile ) &&
           UpdateIniItems( &URLScanIniFile );
#endif
  }

  if ( bRet )
  {
    // Everything so far so good, so lets write the new ini
    bRet = URLScanIniFile.SaveFile( szIniLocation );
  }

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\updateini.h ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        updateini.h

   Abstract:

        High level function to update the ini with new values

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/

#define SETTINGS_MAXLINES     10
#define SECTIONS_MAXLINES     40

struct sURLScan_Settings {
  LPWSTR szSection;
  LPWSTR szSettingName;
  LPWSTR szLines[SETTINGS_MAXLINES];
};

struct sURLScan_Items {
  LPWSTR szSection;
  LPWSTR szSettingName;
  LPWSTR szLines[SETTINGS_MAXLINES];
};

struct sURLScan_Sections {
  LPWSTR szSection;
  LPWSTR szLines[SECTIONS_MAXLINES];
};

BOOL UpdateIni( LPTSTR szUrlScanPath );
BOOL GetIniPath( LPTSTR szDllPath, LPTSTR szIniPath, DWORD dwIniLen );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\urlscan.h ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        urlscan.h

   Abstract:

        Replace Dll, and retrieve URLScan Path

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/


BOOL IsUrlScanInstalled( LPTSTR szPath, DWORD dwCharsinBuff );
DWORD InstallURLScanFix( LPTSTR szUrlScanPath );
BOOL ExtractUrlScanFile( LPTSTR szPath );
BOOL MoveOldUrlScan( LPTSTR szPath );
BOOL IsAdministrator();
BOOL UpdateRegistryforAddRemove();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\copyfile\makefile.inc ===
iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

!IF "$(PROCESSOR_ARCHITECTURE)"!="MIPS"
!IF "$(PROCESSOR_ARCHITECTURE)"!="PPC"

CDROOT=$(_NTTREE)\inetsrv\Dump

copyfile:
	#if not exist "$(CDROOT)" mkdir $(CDROOT)
# 	xcopy /d $(iCPU)\*.*           $(CDROOT)
	perl -S xcopy2binplace.pl /d *.exe            $(CDROOT)
!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\urlscan\urlscan.cpp ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        urlscan.cpp

   Abstract:

        Replace Dll, and retrieve URLScan Path

   Author:

        Christopher Achille (cachille)

   Project:

        URLScan Update

   Revision History:
     
       March 2002: Created

--*/

#include "stdafx.h"
#include "windows.h"
#include "urlscan.h"
#include "updateini.h"
#include "service.h"
#include "resource.h"
#include <ole2.h>
#include "initguid.h"
#include <coguid.h>
#include "iadmw.h"
#include "iiscnfg.h"

// GetUrlScanPath
//
// Get the path to URLScan
//
// Parameters:
//   pAdminBase    - [in]  Pointer to AdminBase Class
//   szPath        - [out] Path to urlscan
//   dwCharsinBuff - [in]  Size of buffer
BOOL 
GetUrlScanPath( IMSAdminBase *pAdminBase, LPTSTR szPath, DWORD dwCharsinBuff )
{
  METADATA_RECORD mdrData;
  DWORD           dwRequiredSize;
  BOOL            bRet = TRUE;

  mdrData.dwMDIdentifier  = MD_FILTER_IMAGE_PATH;
  mdrData.dwMDAttributes  = METADATA_NO_ATTRIBUTES;
  mdrData.dwMDUserType    = IIS_MD_UT_SERVER;
  mdrData.dwMDDataType    = STRING_METADATA;
  mdrData.dwMDDataLen     = ( dwCharsinBuff * sizeof( TCHAR ) );
  mdrData.pbMDData        = (UCHAR *) szPath;
  
  if ( FAILED( pAdminBase->GetData( METADATA_MASTER_ROOT_HANDLE, 
                                    METABASE_URLSCANFILT_LOC, 
                                    &mdrData, 
                                    &dwRequiredSize ) ) )
  {
    bRet = FALSE;
  }

  return bRet;
}

// IsURLScanInstalled
//
// Determine if URLScan is installed.
//
// Parameters:
//   szPath - The path to where URLScan is installed
//
// Return:
//   TRUE - Yes, it is installed, and szPath points to it
//   FALSE - It is not installed as a global filter
//
BOOL
IsUrlScanInstalled( LPTSTR szPath, DWORD dwCharsinBuff )
{
  HRESULT   hRes;
  IMSAdminBase  *pAdminBase = NULL;
  IClassFactory *pcsfFactory = NULL;

  if ( FAILED( CoInitializeEx(NULL, COINIT_MULTITHREADED) ) )
  {
    // Could not initialize COM
    return FALSE;
  }

  hRes = CoGetClassObject( GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);

  if ( SUCCEEDED(hRes) ) 
  {
    hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pAdminBase);
    pcsfFactory->Release();
  }

  if ( SUCCEEDED(hRes) )
  {
    if ( !GetUrlScanPath( pAdminBase, szPath, dwCharsinBuff ) )
    {
      hRes = E_FAIL;
    }
  }

  if ( pAdminBase )
  {
    pAdminBase->Release();
  }

  CoUninitialize();

  return ( SUCCEEDED( hRes ) );
}

// InstallURLSCanFix
//
// Install the fix for URLScan
//
DWORD InstallURLScanFix( LPTSTR szUrlScanPath )
{
  BOOL bServiceWasRunning;
  DWORD dwRet = ERROR_SUCCESS;

  // Stop web Service
  if ( !StopWebSerivce( &bServiceWasRunning ) )
  {
    // Error Message about service not stopping
    return IDS_ERROR_WEBSERVICE;
  }

  // Update the Inf
  if ( !UpdateIni( szUrlScanPath ) )
  {
    dwRet = IDS_ERROR_INIUPDATE;
  }

  // Update Executable
  if ( ( dwRet == ERROR_SUCCESS ) &&
       ( !MoveOldUrlScan( szUrlScanPath ) || 
         !ExtractUrlScanFile( szUrlScanPath ) 
       )
     )
  {
    dwRet = IDS_ERROR_DLLUPDATE;
  }

  // Restart web service if it was running before,
  // even if there was a failure along the way
  if ( bServiceWasRunning &&
       !StartWebSerivce()
     )
  {
    // Error Message about not being able to start service
    if ( dwRet == ERROR_SUCCESS )
    {
      dwRet = IDS_ERROR_RESTARTWEB; 
    }
  }

  return dwRet;
}

// ExtractUrlScanFile
//
// Extract the URLScan File to the FileSystem
//
// Parameters:
//   szPath - Path to expand to
//
// Return:
//   TRUE - Success
//   FALSE - Failure
BOOL ExtractUrlScanFile( LPTSTR szPath )
{
  HRSRC   hrDllResource;
  HGLOBAL hDllResource;
  LPVOID  pDllData;
  HANDLE  hFile;
  DWORD   dwBytesWritten;
  DWORD   dwSize;
  BOOL    bRet = FALSE;
  DWORD   dwTryCount = 0;

  if ( ( ( hrDllResource = FindResource( NULL, (LPCWSTR) IDR_DATA1, RT_RCDATA) ) == NULL ) ||
       ( ( dwSize = SizeofResource( NULL, hrDllResource ) ) == 0 ) ||
       ( ( hDllResource = LoadResource( NULL, hrDllResource) ) == NULL ) ||
       ( ( pDllData = LockResource( hDllResource ) ) == NULL )
     )
  {
    // Could not load resource
    return FALSE;
  }

  do {
    hFile = CreateFile( szPath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if ( GetLastError() == ERROR_SHARING_VIOLATION )
    {
      // If we are getting a sharing violation, it is possible that inetinfo.exe
      // has released the handle, but the OS hasn't totally released it yet,
      // so lets wait 5 seconds
      Sleep( URLSCAN_DLL_INSTALL_INTERVAL );
    }

    dwTryCount++;

  } while ( ( hFile == INVALID_HANDLE_VALUE) &&
            ( GetLastError() == ERROR_SHARING_VIOLATION ) &&
            ( dwTryCount < URLSCAN_DLL_INSTALL_MAXTRIES ) );

  if ( hFile != INVALID_HANDLE_VALUE )
  {
    if ( WriteFile( hFile, pDllData, dwSize, &dwBytesWritten, NULL) )
    {
      bRet = TRUE;
    }

    CloseHandle(hFile);

    if ( dwBytesWritten != dwSize )
    {
      bRet = FALSE;
    }
  }

  return bRet;
}

// MoveOldUrlScan
//
// This will backup the old urlscan into a backup file location
//
// Parameters:
//   szCurrentPath - The current path to urlscan
//
BOOL MoveOldUrlScan( LPTSTR szCurrentPath )
{
  TCHAR  szBackupLocation[ MAX_PATH ];
  LPTSTR szCurrentPos;
  DWORD  dwPathLength = (DWORD) _tcslen( szCurrentPath );

  if ( ( dwPathLength >= ( MAX_PATH - _tcslen(URLSCAN_DEFAULT_FILENAME) - _tcslen(URLSCAN_BACKUPKEY) - 1 ) ) ||
       ( dwPathLength == 0 )
     )
  {
    return FALSE;
  }

  // Copy Filelocation over
  _tcscpy( szBackupLocation, szCurrentPath );

  // Find Last '\'
  szCurrentPos = _tcsrchr( szBackupLocation, '\\' );

  // If there is not slash, then reset to begining of string
  if ( szCurrentPos == NULL )
  {
    szCurrentPos = szBackupLocation;
  }

  if ( *szCurrentPos == '\\' )
  {
    // Move forward one character to the first letter
    szCurrentPos++;
  }

  // Append New FileName
  _tcscpy( szCurrentPos, URLSCAN_BACKUPKEY);
  _tcscat( szCurrentPos, URLSCAN_DEFAULT_FILENAME);

  // Ignore Failure, since failure is most likely because we have done this
  // before, and the backup file already exists
  MoveFileEx( szCurrentPath, szBackupLocation, MOVEFILE_COPY_ALLOWED );

  return TRUE;
}

// IsAdministrator
//
// Return whether the user is an administrator or not
//
BOOL IsAdministrator()
{
  SC_HANDLE hSCManager;
  BOOL      bRet;

  hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_CREATE_SERVICE );

  bRet = hSCManager != NULL;

  if ( hSCManager )
  {
    CloseServiceHandle( hSCManager );
  }

  return bRet;
}

// UpdateRegistryforAddRemove
//
// Update the registry to reflect the new name for the uninstall
// program
//
BOOL 
UpdateRegistryforAddRemove()
{
  HKEY    hRegKey;
  BOOL    bRet;
  LPWSTR  szValue = URLSCAN_TOOL_KEY_NEWVALUE;

  if ( RegOpenKey( HKEY_LOCAL_MACHINE,
                   URLSCAN_TOOL_REGPATH,
                   &hRegKey ) != ERROR_SUCCESS )
  {
    // Failure to open registry key
    // We will return success though, since they could of never installed
    // the installer, but only the file by itself manually.
    return TRUE;
  }

  bRet = RegSetValueEx( hRegKey,
                        URLSCAN_TOOL_KEY_NAME,    // Value Name
                        NULL,                     // Reserved
                        REG_SZ,                   // String Value
                        (LPBYTE) szValue,         // Value to set
                        ( ( (DWORD) wcslen(szValue) + 1)  * sizeof(WCHAR) )
                      ) == ERROR_SUCCESS;

  RegCloseKey( hRegKey );

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\flist\main.cpp ===
#include <stdio.h>
#include <fstream.h>
#include <windows.h>
#include <tchar.h>
#include "resource.h"
#include "other.h"

//
//  FList - a file list munger
//  Written by: AaronL
//

//
// prototypes...
//
int  __cdecl wmain(int ,wchar_t *argv[]);
void ShowHelp(void);
BOOL DoStuff(void);
int  ProcessFor_A(void);
int  ProcessFor_B(void);
int  ProcessFor_C(void);
int  ProcessFor_D(void);
int  ProcessFor_E(void);
int  ProcessFor_F(void);
int  MyLoadString(int nID, TCHAR *szResult);

//
// Globals
//
HINSTANCE g_hModuleHandle = NULL;

int   g_Flag_a = FALSE;
int   g_Flag_b = FALSE;
int   g_Flag_c = FALSE;
int   g_Flag_d = FALSE;
int   g_Flag_e = FALSE;
int   g_Flag_f = FALSE;
TCHAR g_Flag_f_Data[_MAX_PATH];

int   g_Flag_g = FALSE;
int   g_Flag_z = FALSE;
TCHAR g_Flag_z_Data[_MAX_PATH];

TCHAR g_szFileList1[_MAX_PATH];
TCHAR g_szFileList2[_MAX_PATH];


//-------------------------------------------------------------------
//  purpose: wmain
//-------------------------------------------------------------------
int __cdecl wmain(int argc,wchar_t *argv[])
{
    LPWSTR pArg = NULL;
    int   argno = 0;
    int   nflags = 0;

    g_hModuleHandle = GetModuleHandle(NULL);

    _tcscpy(g_Flag_z_Data, _T(""));
    _tcscpy(g_szFileList1, _T(""));
    _tcscpy(g_szFileList2, _T(""));

    // process command line arguments
    for (argno=1; argno<argc; argno++) {
        if ( argv[argno][0] == L'-'  || argv[argno][0] == L'/' ) {
            nflags++;
            switch (argv[argno][1]) {
                case L'a': 
                case L'A':
                    g_Flag_a = TRUE;
                    break;
                case L'b': 
                case L'B':
                    g_Flag_b = TRUE;
                    break;
                case L'c': 
                case L'C':
                    g_Flag_c = TRUE;
                    break;
                case L'd': 
                case L'D':
                    g_Flag_d = TRUE;
                    break;
                case L'e': 
                case L'E':
                    g_Flag_e = TRUE;
                    break;
                case L'f':
                case L'F':
                    g_Flag_f = TRUE;
                    // Get the string for this flag
                    pArg = CharNext(argv[argno]);
                    pArg = CharNext(pArg);
                    if (*pArg == L':') {
                        LPWSTR pCmdStart = NULL;

                        pArg = CharNext(pArg);
                        // Check if it's quoted
                        if (*pArg == '\"') {
                            pArg = CharNext(pArg);
                            pCmdStart = pArg;
                            while ((*pArg) && (*pArg != L'\"')) {pArg = CharNext(pArg);}
                        } else {
                            pCmdStart = pArg;
                            // while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNextA(pArg);}
                            while (*pArg) {pArg = CharNext(pArg);}
                        }
                        *pArg = '\0';
                        lstrcpy(g_Flag_f_Data, StripWhitespace(pCmdStart));
                    }
                    break;
                case 'g': 
                case 'G':
                    g_Flag_g = TRUE;
                    break;
                case 'z':
                case 'Z':
                    g_Flag_z = TRUE;
                    // Get the string for this flag
                    pArg = CharNext(argv[argno]);
                    pArg = CharNext(pArg);
                    if (*pArg == ':') {
                        LPWSTR pCmdStart = NULL;

                        pArg = CharNext(pArg);
                        // Check if it's quoted
                        if (*pArg == '\"') {
                            pArg = CharNext(pArg);
                            pCmdStart = pArg;
                            while ((*pArg) && (*pArg != '\"')) {pArg = CharNext(pArg);}
                        } else {
                            pCmdStart = pArg;
                            // while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNextA(pArg);}
                            while (*pArg) {pArg = CharNext(pArg);}
                        }
                        *pArg = '\0';
                        lstrcpy(g_Flag_z_Data, StripWhitespace(pCmdStart));
                    }
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
            } // end of switch
        } // if switch character found
        else {
            if (_tcscmp(g_szFileList1, _T("")) == 0) {
                int iLen = min((_MAX_PATH-1), wcslen(argv[argno]));
                wcsncpy(g_szFileList1, argv[argno], iLen);
            } else {
                if (_tcscmp(g_szFileList2, _T("")) == 0) {
                    lstrcpy(g_szFileList2, argv[argno]);
                }
            }

        } // non-switch char found
    } // for all arguments


    if (_tcscmp(g_Flag_z_Data, _T("")) == 0) {g_Flag_z = FALSE;}

    if (FALSE == DoStuff()) {goto main_exit_with_help;}

    goto main_exit_gracefully;

    main_exit_gracefully:
    exit(0);
    return TRUE;

    main_exit_with_help:
    ShowHelp();
    exit(1);
    return FALSE;
}


void ShowHelp()
{
    TCHAR szModuleName_Full[_MAX_PATH];
    TCHAR szModuleName_Fname[_MAX_FNAME];
    GetModuleFileName(NULL, szModuleName_Full, _MAX_PATH);

    // Trim off the filename only.
    _tsplitpath(szModuleName_Full, NULL, NULL, szModuleName_Fname, NULL);

    TCHAR szMyBigString[255];

    if (MyLoadString(IDS_STRING1, szMyBigString)) {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING2, szMyBigString)) {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING3, szMyBigString)) {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING4, szMyBigString)) {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING5, szMyBigString)) {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING6, szMyBigString)) {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING7, szMyBigString)) {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING8, szMyBigString)) {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING9, szMyBigString)) {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING10, szMyBigString)) {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING11, szMyBigString)) {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING15, szMyBigString)) {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING16, szMyBigString)) {OutputToConsole(szMyBigString);}

    return;
}


//-------------------------------------------------------------------
BOOL DoStuff(void)
{
    BOOL bReturn = FALSE;
    if (TRUE == ProcessFor_A()) {bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_B()) {bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_C()) {bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_D()) {bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_E()) {bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_F()) {bReturn = TRUE; goto DoStuff_Exit;}
    goto DoStuff_Exit;

    DoStuff_Exit:
    return bReturn;
}


void MissingFileListEntry1(TCHAR * szMySwitch)
{
    TCHAR szMyBigString[255];
    if (MyLoadString(IDS_STRING12, szMyBigString)) {OutputToConsole(szMyBigString,szMySwitch);}
    return;
}
void MissingFileListEntry2(TCHAR * szMySwitch)
{
    TCHAR szMyBigString[255];
    if (MyLoadString(IDS_STRING13, szMyBigString)) {OutputToConsole(szMyBigString,szMySwitch);}
    return;
}
void MissingFile(TCHAR * szMissingFileName)
{
    TCHAR szMyBigString[255];
    if (MyLoadString(IDS_STRING14, szMyBigString)) {OutputToConsole(szMyBigString,szMissingFileName);}
    return;
}

//
// Flist -a FileList1.txt FileList2.Txt
//   [Prints out common entries between FileList1.txt and FileList2.txt]
//
int ProcessFor_A(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-a");

    MyFileList FileList1 = {0};
    MyFileList FileList2 = {0};

    if (TRUE != g_Flag_a) {goto ProcessFor_A_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0) {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_A_Exit;
    }
    if (_tcscmp(g_szFileList2, _T("")) == 0) {
        MissingFileListEntry2(szMySwitch);
        goto ProcessFor_A_Exit;
    }

    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1)) {
        MissingFile(g_szFileList1);
        goto ProcessFor_A_Exit;
    }
    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList2)) {
        MissingFile(g_szFileList2);
        goto ProcessFor_A_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    FileList2.next = &FileList2; // make it a sentinel
    FileList2.prev = &FileList2; // make it a sentinel
    ReadFileIntoList(g_szFileList2, &FileList2);

    //DumpOutLinkedFileList(&FileList1);
    //DumpOutLinkedFileList(&FileList2);

    //
    // Do the actual work
    //
    DumpOutCommonEntries(&FileList1, &FileList2);

    FreeLinkedFileList(&FileList1);
    FreeLinkedFileList(&FileList2);

    iReturn = TRUE;

    ProcessFor_A_Exit:
    return iReturn;
}


int ProcessFor_B(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-b");

    MyFileList FileList1 = {0};
    MyFileList FileList2 = {0};

    if (TRUE != g_Flag_b) {goto ProcessFor_B_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0) {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_B_Exit;
    }
    if (_tcscmp(g_szFileList2, _T("")) == 0) {
        MissingFileListEntry2(szMySwitch);
        goto ProcessFor_B_Exit;
    }

    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1)) {
        MissingFile(g_szFileList1);
        goto ProcessFor_B_Exit;
    }
    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList2)) {
        MissingFile(g_szFileList2);
        goto ProcessFor_B_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    FileList2.next = &FileList2; // make it a sentinel
    FileList2.prev = &FileList2; // make it a sentinel
    ReadFileIntoList(g_szFileList2, &FileList2);

    //
    // Do the actual work
    //
    DumpOutDifferences(&FileList1, &FileList2);

    FreeLinkedFileList(&FileList1);
    FreeLinkedFileList(&FileList2);

    iReturn = TRUE;

    ProcessFor_B_Exit:
    return iReturn;
}


int ProcessFor_C(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-c");

    MyFileList FileList1 = {0};

    if (TRUE != g_Flag_c) {goto ProcessFor_C_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0) {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_C_Exit;
    }

    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1)) {
        MissingFile(g_szFileList1);
        goto ProcessFor_C_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    DumpOutLinkedFileList(&FileList1);

    FreeLinkedFileList(&FileList1);

    iReturn = TRUE;

    ProcessFor_C_Exit:
    return iReturn;
}


int ProcessFor_D(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-d");

    MyFileList FileList1 = {0};

    if (TRUE != g_Flag_d) {goto ProcessFor_D_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0) {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_D_Exit;
    }

    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1)) {
        MissingFile(g_szFileList1);
        goto ProcessFor_D_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    DumpOutLinkedFileList(&FileList1);

    FreeLinkedFileList(&FileList1);

    iReturn = TRUE;

    ProcessFor_D_Exit:
    return iReturn;
}

int ProcessFor_E(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-e");

    MyFileList FileList1 = {0};

    if (TRUE != g_Flag_e) {goto ProcessFor_E_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0) {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_E_Exit;
    }

    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1)) {
        MissingFile(g_szFileList1);
        goto ProcessFor_E_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    DumpOutLinkedFileList(&FileList1);

    FreeLinkedFileList(&FileList1);

    iReturn = TRUE;

    ProcessFor_E_Exit:
    return iReturn;
}

int ProcessFor_F(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-f");

    MyFileList FileList1 = {0};

    if (TRUE != g_Flag_f) {goto ProcessFor_F_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0) {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_F_Exit;
    }

    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1)) {
        MissingFile(g_szFileList1);
        goto ProcessFor_F_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    DumpOutLinkedFileList(&FileList1);

    FreeLinkedFileList(&FileList1);

    iReturn = TRUE;

    ProcessFor_F_Exit:
    return iReturn;
}

#define BUFFER_MAX 1024
int MyLoadString(int nID, TCHAR *szResult)
{
    TCHAR buf[BUFFER_MAX];
    int iReturn = FALSE;

    if (g_hModuleHandle == NULL) {return iReturn;}

    if (LoadString(g_hModuleHandle, nID, buf, BUFFER_MAX)) {
        iReturn = TRUE;
        _tcscpy(szResult, buf);
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\flist\other.cpp ===
#include <stdio.h>
#include <fstream.h>
#include <windows.h>
#include <tchar.h>
#include "other.h"

extern int g_Flag_a;
extern int g_Flag_b;
extern int g_Flag_c;
extern int g_Flag_d;
extern int g_Flag_e;
extern int g_Flag_f;
extern TCHAR * g_Flag_f_Data;
extern int g_Flag_g;
extern int g_Flag_z;
extern TCHAR * g_Flag_z_Data;


void OutputToConsole(TCHAR *szInsertionStringFormat, TCHAR *szInsertionString)
{
    TCHAR BigString[1000];
    _stprintf(BigString,szInsertionStringFormat,szInsertionString);
    _tprintf(BigString);
    return;
}


void OutputToConsole(TCHAR *szInsertionStringFormat, int iTheInteger)
{
    TCHAR BigString[1000];
    _stprintf(BigString,szInsertionStringFormat,iTheInteger);
    _tprintf(BigString);
    return;
}


void OutputToConsole(TCHAR *szString)
{
    _tprintf(szString);
    return;
}


void DumpOutCommonEntries(MyFileList *pTheMasterFileList1, MyFileList *pTheMasterFileList2)
{
    MyFileList *t = NULL;
    MyFileList *t2 = NULL;
    t = pTheMasterFileList1->next;
    while (t != pTheMasterFileList1)
    {
        //
        // Loop thru all of list 2 looking for this entry
        //
        t2 = pTheMasterFileList2->next;
        while (t2 != pTheMasterFileList2)
        {
            if (0 == _tcsicmp(t->szFileNameEntry, t2->szFileNameEntry))
            {
                //OutputToConsole(_T("%s\r\n"),t->szFileNameEntry);
                OutputToConsole(_T("%s\n"),t->szFileNameEntry);
            }
            t2 = t2->next;
        }

        // Get the next entry from list 2
        t = t->next;
    }
    return;
}


void DumpOutLinkedFileList(MyFileList *pTheMasterFileList)
{
    MyFileList *t = NULL;
    t = pTheMasterFileList->next;
    while (t != pTheMasterFileList)
    {
        //OutputToConsole(_T("%s\r\n"),t->szFileNameEntry);
        OutputToConsole(_T("%s\n"),t->szFileNameEntry);
        t = t->next;
    }
    return;
}


void DumpOutDifferences(MyFileList *pTheMasterFileList1, MyFileList *pTheMasterFileList2)
{
    int iFound = FALSE;

    MyFileList *t = NULL;
    MyFileList *t2 = NULL;

    // Loop thru list #1
    t = pTheMasterFileList1->next;
    while (t != pTheMasterFileList1)
    {
        //
        // Loop thru all of list 2 looking for this entry
        //
        iFound = FALSE;
        t2 = pTheMasterFileList2->next;
        while (t2 != pTheMasterFileList2 && iFound != TRUE)
        {
            if (0 == _tcsicmp(t->szFileNameEntry, t2->szFileNameEntry))
                {iFound = TRUE;}
            t2 = t2->next;
        }
        if (FALSE == iFound)
        {
            //OutputToConsole(_T("%s\r\n"),t->szFileNameEntry);
            OutputToConsole(_T("%s\n"),t->szFileNameEntry);
        }

        // Get the next entry from list 2
        t = t->next;
    }

    // Loop thru list #2
    t2 = pTheMasterFileList2->next;
    while (t2 != pTheMasterFileList2)
    {
        //
        // Loop thru all of list 2 looking for this entry
        //
        iFound = FALSE;
        t = pTheMasterFileList1->next;
        while (t != pTheMasterFileList1 && iFound != TRUE)
        {
            if (0 == _tcsicmp(t2->szFileNameEntry, t->szFileNameEntry))
                {iFound = TRUE;}
            t = t->next;
        }
        if (FALSE == iFound)
        {
            //OutputToConsole(_T("%s\r\n"),t2->szFileNameEntry);
            OutputToConsole(_T("%s\n"),t2->szFileNameEntry);
        }

        // Get the next entry from list 2
        t2 = t2->next;
    }

    return;
}


void ReadFileIntoList(LPTSTR szTheFileNameToOpen,MyFileList *pListToFill)
{
    ifstream inputfile;
    char fileinputbuffer[_MAX_PATH];
    TCHAR UnicodeFileBuf[_MAX_PATH];
    TCHAR UnicodeFileBuf_Real[_MAX_PATH];

    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szFilename_only[_MAX_FNAME];
    TCHAR szFilename_ext_only[_MAX_EXT];

    char szAnsiFileName[_MAX_PATH];
    WideCharToMultiByte( CP_ACP, 0, (TCHAR*)szTheFileNameToOpen, -1, szAnsiFileName, _MAX_PATH, NULL, NULL );

    // Read flat file and put into huge array
    inputfile.open(szAnsiFileName, ios::in);
    inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer));
    do
    {
        if (*fileinputbuffer)
        {
            // convert to unicode.
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)fileinputbuffer, -1, (LPTSTR) UnicodeFileBuf, _MAX_PATH);

            _tcscpy(UnicodeFileBuf_Real, UnicodeFileBuf);
            if (TRUE == g_Flag_c)
            {
                //  take out the path and only store the filename.
                _tsplitpath(UnicodeFileBuf, NULL, NULL, szFilename_only, szFilename_ext_only);

                _tcscpy(UnicodeFileBuf_Real, szFilename_only);
                _tcscat(UnicodeFileBuf_Real, szFilename_ext_only);
                _tcscat(UnicodeFileBuf_Real, _T("\0\0"));
            }
            else if (TRUE == g_Flag_d)
                {
                    //  take out the path and only store the filename.
                    _tsplitpath(UnicodeFileBuf, szDrive_only, szPath_only, NULL, NULL);

                    _tcscpy(UnicodeFileBuf_Real, szDrive_only);
                    _tcscat(UnicodeFileBuf_Real, szPath_only);
                    _tcscat(UnicodeFileBuf_Real, _T("\0\0"));
                }

            //
            // trim spaces or tabs from either side
            //
            if (TRUE == g_Flag_e)
            {
                TCHAR *p;
                p = UnicodeFileBuf_Real;
                _tcscpy(UnicodeFileBuf_Real,StripWhitespace(p));
            }

            //
            // remove everything after the "=" character
            //
#ifndef _WIN64
            if (TRUE == g_Flag_f)
            {
                TCHAR *p = NULL;
                TCHAR *pDest = NULL;
                TCHAR MyDelim = _T('=');
                p = UnicodeFileBuf_Real;

                // check if there is a defined delimiter.
                if( _tcsicmp((const wchar_t *) &g_Flag_f_Data, _T("") ) != 0)
                {
                    MyDelim = (TCHAR) &g_Flag_f_Data[0];
                }

                pDest = _tcsrchr(p, MyDelim);
                if (pDest){*pDest = _T('\0');}
            }
#endif

            //
            // Trim any /r/n characters from the end.
            //
            TCHAR *p;
            p = UnicodeFileBuf_Real;
            _tcscpy(UnicodeFileBuf_Real,StripLineFeedReturns(p));

            MyFileList *pNew = NULL;
            pNew = (MyFileList *)calloc(1, sizeof(MyFileList));
            if (pNew)
            {
                //OutputToConsole(_T("Entry=%s"),UnicodeFileBuf_Real);
                _tcscpy(pNew->szFileNameEntry, UnicodeFileBuf_Real);
                pNew->prev = NULL;
                pNew->next = NULL;
            }

            // Add it in there.
            AddToLinkedListFileList(pListToFill, pNew);
        }
    } while (inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer)));
	inputfile.close();

    return;
}


void AddToLinkedListFileList(MyFileList *pMasterList,MyFileList *pEntryToadd)
{
    MyFileList *pTempMasterList;
    int i;
    int bFound = FALSE;
    BOOL fReplace = TRUE;
    if (!pEntryToadd) {return;}

    pTempMasterList = pMasterList->next;
    while (pTempMasterList != pMasterList) 
    {
        i = _tcsicmp(pTempMasterList->szFileNameEntry, pEntryToadd->szFileNameEntry);

        // if the next entry in the list is less than what we have.
        // then
        if (i < 0) 
        {
            pTempMasterList = pTempMasterList->next;
            // continue
        }

        if (i == 0) 
        {
            if (fReplace)
            {
                // replace pTempMasterList
                pEntryToadd->next = pTempMasterList->next;
                pEntryToadd->prev = pTempMasterList->prev;
                (pTempMasterList->prev)->next = pEntryToadd;
                (pTempMasterList->next)->prev = pEntryToadd;
                free(pTempMasterList);
            }
            else 
            {
                // don't replace pTempMasterList
                free(pEntryToadd);
            }
            return;
        }

        if (i > 0) 
        {
            // location found: insert before pTempMasterList
            break;
        }
    }

    // insert before pTempMasterList
    pEntryToadd->next = pTempMasterList;
    pEntryToadd->prev = pTempMasterList->prev;
    (pTempMasterList->prev)->next = pEntryToadd;
    pTempMasterList->prev = pEntryToadd;
    return;
}


void FreeLinkedFileList(MyFileList *pList)
{
    if (!pList) {return;}

    MyFileList *t = NULL, *p = NULL;

    t = pList->next;
    while (t != pList) 
    {
        p = t->next;
        free(t);
        t = p;
    }

    t->prev = t;
    t->next = t;
    return;
}


BOOL IsFileExist(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
        _tcscpy(szValue,szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, _MAX_PATH))
            {_tcscpy(szValue,szFile);}

        return (GetFileAttributes(szValue) != 0xFFFFFFFF);
    }
    else
    {
        return (GetFileAttributes(szFile) != 0xFFFFFFFF);
    }
}


//***************************************************************************
//* NAME:       StripWhitespace                                             *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//***************************************************************************
LPSTR StripWhitespaceA( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}

//***************************************************************************
//* NAME:       StripWhitespace                                             *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//***************************************************************************
LPTSTR StripWhitespace(LPTSTR pszString )
{
    LPTSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == _T(' ') || *pszString == _T('\t') ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == _T('\0') ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenW(pszString) - 1;

    while ( *pszString == _T(' ') || *pszString == _T('\t') ) {
        *pszString = _T('\0');
        pszString -= 1;
    }

    return pszTemp;
}


//***************************************************************************
//* NAME:       StripLineFeedReturns                                        *
//* SYNOPSIS:   Strips linefeeds and returns from both sides of given string*
//***************************************************************************
LPTSTR StripLineFeedReturns(LPTSTR pszString )
{
    LPTSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == _T('\n') || *pszString == _T('\r') ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == _T('\0') ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenW(pszString) - 1;

    while ( *pszString == _T('\n') || *pszString == _T('\r') ) {
        *pszString = _T('\0');
        pszString -= 1;
    }

    return pszTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\flist\other.h ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tchar.h>

LPSTR  StripWhitespaceA(LPSTR pszString);
LPTSTR StripWhitespace(LPTSTR pszString);
LPTSTR StripLineFeedReturns(LPTSTR pszString );
BOOL   IsFileExist(LPCTSTR szFile);

void OutputToConsole(TCHAR *szInsertionStringFormat, TCHAR *szInsertionString);
void OutputToConsole(TCHAR *szInsertionStringFormat, int iTheInteger);
void OutputToConsole(TCHAR *szString);

typedef struct _MyFileList
{
    TCHAR szFileNameEntry[_MAX_PATH];
    struct _MyFileList *prev, *next;
} MyFileList;

void ReadFileIntoList(LPTSTR szTheFileNameToOpen,MyFileList *pListToFill);
void AddToLinkedListFileList(MyFileList *pMasterList,MyFileList *pEntryToadd);
void DumpOutLinkedFileList(MyFileList *pTheMasterFileList);
void FreeLinkedFileList(MyFileList *pList);
void DumpOutCommonEntries(MyFileList *pTheMasterFileList1, MyFileList *pTheMasterFileList2);
void DumpOutDifferences(MyFileList *pTheMasterFileList1, MyFileList *pTheMasterFileList2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\macros.h ===
// Common macro definitions

#ifdef _DEBUG
#define VERIFY( t )		_ASSERT( (t) )
#else
#define VERIFY( t )		(t)
#endif


#define ARRAY_SIZE( t )	( sizeof( t ) / sizeof( t[ 0 ] ) )


// COM Macros
#define DECLARE_HR_SUCCESS		HRESULT hr = S_OK;
#define IF_SUCCEEDED( t )		if ( SUCCEEDED( hr ) ){ hr = (t); }
#define	HR_CHECK( t )			if ( SUCCEEDED( hr ) && !(t) ) hr = E_FAIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IISMon.rc
//
#define IDS_STRING1                     1
#define IDD_WPAGE_LICENSE               101
#define IDD_WPAGE_SETUP                 103
#define IDR_LICENSE                     106
#define IDD_WPAGE_FINISH                109
#define IDD_WPAGE_INSTALL               109
#define IDD_WPAGE_WELCOME               110
#define IDB_SIDE                        111
#define IDI_SETUP                       114
#define IDR_INFO                        115
#define IDI_INFO                        116
#define IDI_WARN                        117
#define IDD_WPAGE_POLICY                118
#define IDR_POLICY                      119
#define IDD_WPAGE_RESULT                120
#define IDD_FAT_WARNING                 121
#define IDD_PROGRESS                    122
#define IDR_FATDETAILS                  123
#define IDC_POLICY                      1000
#define IDC_LICENSE                     1000
#define IDC_ACCEPT                      1001
#define IDC_ENABLE_TRAIL                1002
#define IDC_KEEPFILES                   1003
#define IDC_TITLE                       1004
#define IDC_INFO                        1006
#define IDC_TIP                         1007
#define IDC_WARNING                     1008
#define IDC_RESULT                      1010
#define IDC_TOGGLE                      1011
#define IDC_DETAILS                     1012
#define IDC_FRAME                       1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        124
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\flist\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3
#define IDS_STRING4                     4
#define IDS_STRING5                     5
#define IDS_STRING6                     6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10
#define IDS_STRING11                    11
#define IDS_STRING12                    12
#define IDS_STRING13                    13
#define IDS_STRING14                    14
#define IDS_STRING15                    15
#define IDS_STRING16                    16

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\iismon.cpp ===
/*
****************************************************************************
|    Copyright (C) 2001  Microsoft Corporation
|
|   Module Name:
|
|       IISMon.cpp
|
|   Abstract:
|		This is the code that installs the IIS6 Monitor tool on Servers Beta
|
|   Author:
|        Ivo Jeglov (ivelinj)
|
|   Revision History:
|        November 2001
|
****************************************************************************
*/


#include "stdafx.h"
#include "Utils.h"
#include "UI.h"



int APIENTRY WinMain(	HINSTANCE hInstance,
						HINSTANCE hPrevInstance,
						LPSTR     lpCmdLine,
						int       nCmdShow )
{
	BOOL bComInitialized = SUCCEEDED( ::CoInitialize( NULL ) );

	if ( !bComInitialized )
	{
		::MessageBox( NULL, _T("Cannot initialize COM. The Setup will now exit"), _T("Error"), MB_OK | MB_ICONSTOP );
		return 1;
	}

	// There are two switches:
	// 1) -inst - installs the tool
	if ( ::strcmp( lpCmdLine, "-inst" ) == 0 )
	{
		DoInstallUI( hInstance );
	}
	// 2) -uninst - uninstalls the tool ( silent )
	else if ( ::strcmp( lpCmdLine, "-uninst" ) == 0 )
	{
		Uninstall( FALSE );
	}
	// 3) -uninstinter - uninstalls the tool ( interactive )
	else if ( ::strcmp( lpCmdLine, "-uninstinter" ) == 0 )
	{
		// Only admins can uninstall the Monitor
		if ( !IsAdmin() )
		{
			::MessageBox(	NULL, 
							_T("Only members of the Administrator group can uninstall IIS 6.0 Monitor. Please add yourself to the Administrator group, and then run IIS 6.0 Monitor uninstall again. If you cannot add yourself to the Administrator group, contact your network administrator."),
							_T("IIS 6.0 Monitor"),
							MB_OK | MB_ICONSTOP );
			return 2;
		}

		if ( ::MessageBox(	NULL, 
							_T("Are you sure you want to uninstall IIS 6.0 Monitor?"), 
							_T("IIS 6.0 Monitor Uninstall"),
							MB_YESNO | MB_ICONQUESTION ) == IDYES )
		{
			BOOL bRemoveTrail = ( ::MessageBox(	NULL, 
												_T("Would you like to delete the IIS 6.0 Monitor audit files?"),
												_T("Audit files"),
												MB_YESNO | MB_ICONQUESTION ) == IDYES );
			Uninstall( bRemoveTrail );

			::MessageBox(	NULL, 
							_T("IIS 6.0 Monitor uninstalled successfully. Some files will be removed at next reboot."),
							_T("IIS 6.0 Monitor Uninstall"),
							MB_OK | MB_ICONINFORMATION );

		}
	}
	// 4) -unattend - unatended install
	else if ( ::strcmp( lpCmdLine, "-unattend" ) == 0 )
	{
		if ( CanInstall() == NULL )
		{
			Install( hInstance, TRUE, 7 ); 
		}
	}


	if ( bComInitialized )
	{
		::CoUninitialize();
	}

	return 0;
}



// Local function declarations
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	IISMon Setup.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\ui.cpp ===
/*
****************************************************************************
|    Copyright (C) 2001  Microsoft Corporation
|
|   Module Name:
|
|       UI.cpp
|
|   Abstract:
|		This is the UI code for the IIS6 Monitor tool
|
|   Author:
|        Ivo Jeglov (ivelinj)
|
|   Revision History:
|        November 2001
|
****************************************************************************
*/

#include "stdafx.h"
#include "resource.h"
#include <windowsx.h>
#include "UI.h"
#include "Utils.h"


// Property pages DLG procs
INT_PTR CALLBACK WelcomeDlgProc		( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam );
INT_PTR CALLBACK LicenseDlgProc		( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam );
INT_PTR CALLBACK PolicyDlgProc		( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam );
INT_PTR CALLBACK SettingsDlgProc	( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam );
INT_PTR CALLBACK InstallDlgProc		( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam );
INT_PTR CALLBACK ResultDlgProc		( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam );

// Other DLG procs
INT_PTR CALLBACK FatDlgProc			( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam );
INT_PTR CALLBACK ProgressDlgProc	( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam );

// Helpers
BOOL CheckForFAT				( HINSTANCE hInst, HWND hwndParent );


// Shared data for all the wizard pages
struct _FontData
{
	HFONT	hTitle;
	HFONT	hTips;
};

// Settings data
struct _Settings
{
	BOOL	bEnableTrail;
	DWORD	dwKeepFilesPeriod;
};


struct _SharedData
{
	_FontData	Fonts;
	_Settings	Settings;
	LPCTSTR		szError;
	HINSTANCE	hInst;
};


// Helpers
void LoadTextInCtrl				( UINT nResID, HWND hCtrl );
void AjustLicenseWizBtn			( HWND hwndPage );
void InitFonts					( _FontData& FontData );
void SetWndFontFromLPARAM		( HWND hwndCtrl, LPARAM lParam, BOOL bTitle );



void DoInstallUI( HINSTANCE hInstance )
{
	const BYTE PAGE_COUNT = 6;

	PROPSHEETPAGEW		psp					= { 0 }; // Defines the property sheet pages
    HPROPSHEETPAGE		ahPsp[ PAGE_COUNT ] = { 0 }; // An array to hold the page's HPROPSHEETPAGE handles
    PROPSHEETHEADERW	psh					= { 0 }; // Defines the property sheet
    _SharedData			WizData				= { 0 }; // The settings data structure
	
	// Create the fonts
	InitFonts( /*r*/WizData.Fonts );
	WizData.hInst = hInstance;

	// Create the Wizard pages
    ///////////////////////////////////////////////////////////////////
	
	// Welcome page
	psp.dwSize			= sizeof( psp );
    psp.dwFlags			= PSP_DEFAULT | PSP_HIDEHEADER | PSP_USETITLE;
	psp.hInstance		= hInstance;
	psp.lParam			= reinterpret_cast<LPARAM>( &WizData );
    psp.pfnDlgProc		= WelcomeDlgProc;
    psp.pszTemplate		= MAKEINTRESOURCEW( IDD_WPAGE_WELCOME );
	psp.pszTitle		= MAIN_TITLE;

    ahPsp[ 0 ]			= ::CreatePropertySheetPageW( &psp );

    // License page
    psp.pfnDlgProc		= LicenseDlgProc;
    psp.pszTemplate		= MAKEINTRESOURCEW( IDD_WPAGE_LICENSE );

    ahPsp[ 1 ]			= ::CreatePropertySheetPageW( &psp );

	// Policy page
    psp.pfnDlgProc		= PolicyDlgProc;
    psp.pszTemplate		= MAKEINTRESOURCEW( IDD_WPAGE_POLICY );

    ahPsp[ 2 ]			= ::CreatePropertySheetPageW( &psp );

    // Settings Page
	psp.pszTemplate		= MAKEINTRESOURCEW( IDD_WPAGE_SETUP );
    psp.pfnDlgProc		= SettingsDlgProc;

    ahPsp[ 3 ]			= ::CreatePropertySheetPageW( &psp );

	// Install Page
	psp.pszTemplate		= MAKEINTRESOURCEW( IDD_WPAGE_INSTALL );
    psp.pfnDlgProc		= InstallDlgProc;

    ahPsp[ 4 ]			= ::CreatePropertySheetPageW( &psp );

	// Result page
	psp.pszTemplate		= MAKEINTRESOURCEW( IDD_WPAGE_RESULT );
    psp.pfnDlgProc		= ResultDlgProc;

    ahPsp[ 5 ]			= ::CreatePropertySheetPageW( &psp );

	// Create the property sheet
    psh.dwSize			= sizeof( psh );
    psh.hInstance		= hInstance;
    psh.hwndParent		= NULL;
    psh.phpage			= ahPsp;
    psh.dwFlags			= PSH_DEFAULT | PSH_NOCONTEXTHELP | PSH_WIZARD97 | PSH_USEICONID;
	psh.pszIcon			= MAKEINTRESOURCEW( IDI_SETUP );
    psh.nStartPage		= 0;
    psh.nPages			= PAGE_COUNT;
		
	// Show the wizard. 
	VERIFY(  ::PropertySheetW( &psh ) != -1 );
	
	::DeleteObject( WizData.Fonts.hTips );
	::DeleteObject( WizData.Fonts.hTitle );
}



INT_PTR CALLBACK WelcomeDlgProc( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam )
{
	static _SharedData* pData = NULL;

	switch( uMsg )
	{
	case WM_INITDIALOG:
		// Set the title font
		SetWndFontFromLPARAM( ::GetDlgItem( hwndDlg, IDC_TITLE ), lParam,  TRUE );
		SetWndFontFromLPARAM( ::GetDlgItem( hwndDlg, IDC_TIP ), lParam, FALSE );
		
		// Load the info text
		LoadTextInCtrl( IDR_INFO, ::GetDlgItem( hwndDlg, IDC_INFO ) );

		// Init the shared data here
		_ASSERT( NULL == pData );
		pData = reinterpret_cast<_SharedData*>( reinterpret_cast<PROPSHEETPAGE*>( lParam )->lParam );
		break;

	case WM_NOTIFY:
		switch ( reinterpret_cast<NMHDR*>( lParam )->code )
		{
		case PSN_SETACTIVE:
			PropSheet_SetWizButtons( ::GetParent( hwndDlg ), PSWIZB_NEXT );
			break;

		case PSN_WIZNEXT:
			// Here is the place to test the requirements
			_ASSERT( pData != NULL );
			pData->szError = CanInstall();

			// If no error - check if on FAT
			if ( ( NULL == pData->szError ) && !CheckForFAT( pData->hInst, hwndDlg ) )
			{
				// If we are here - the user don't want to install IISMon on FAT
				pData->szError = _T("Installation canceled by the user");
			}
			
			if ( pData->szError != NULL )
			{
				// Error - Go to the result page
				PropSheet_SetCurSel( ::GetParent( hwndDlg ), NULL, 5 );
			}

			break;
		};
		break;

	case WM_CTLCOLORDLG:
	case WM_CTLCOLORSTATIC:
		// Change the dlg background to white
		return reinterpret_cast<INT_PTR>( ::GetStockObject( WHITE_BRUSH ) );
		break;
	};

	return 0;
}



INT_PTR CALLBACK LicenseDlgProc( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam )
{
	switch( uMsg )
	{
	case WM_INITDIALOG:
		// Load the License text into the edit control
		LoadTextInCtrl( IDR_LICENSE, ::GetDlgItem( hwndDlg, IDC_LICENSE ) );
		break;

	case WM_COMMAND:
		// Will handle only the state changes of the check box button
		if ( HIWORD( wParam ) == BN_CLICKED )
		{
			AjustLicenseWizBtn( hwndDlg );
		}
		break;

	case WM_NOTIFY:
		LPNMHDR pNM = reinterpret_cast<NMHDR*>( lParam );

		switch( pNM->code )
		{
		case PSN_SETACTIVE:
			AjustLicenseWizBtn( hwndDlg );
			break;
		}
		break;
	};

	return 0;
}



INT_PTR CALLBACK PolicyDlgProc( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam )
{
	switch( uMsg )
	{
	case WM_INITDIALOG:
		// Load the License text into the edit control
		LoadTextInCtrl( IDR_POLICY, ::GetDlgItem( hwndDlg, IDC_POLICY ) );
		break;

	};

	return 0;
}



INT_PTR CALLBACK SettingsDlgProc( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam )
{
	int i = 0;

	static LPCTSTR aszEntries[] = {	_T("One week"),
									_T("Two weeks"),
									_T("One month" ),
									_T("Two months" ),
									_T("Never" ) };

	// How many days represent each of the combo box options above
	static UINT anAuditFilesTime[] = { 7, 14, 30, 60, 0 };
	_ASSERT( ARRAY_SIZE( anAuditFilesTime ) == ARRAY_SIZE( aszEntries ) );

	static _SharedData* pData = NULL;
	
	switch( uMsg )
	{
	case WM_INITDIALOG:
		// Fill the combo box
		for ( i = 0; i < ARRAY_SIZE( aszEntries ); ++i )
		{
			VERIFY( ::SendMessage( ::GetDlgItem(	hwndDlg, IDC_KEEPFILES ), 
													CB_ADDSTRING,
													0,
													reinterpret_cast<LPARAM>( aszEntries[ i ] ) ) != CB_ERR );
		}
		// Set the default selection to the first one
		VERIFY( ::SendMessage( ::GetDlgItem(	hwndDlg, IDC_KEEPFILES ), 
												CB_SETCURSEL,
												0,
												0 ) != CB_ERR );
		SetWndFontFromLPARAM( ::GetDlgItem( hwndDlg, IDC_WARNING ), lParam, FALSE );

		// Enable the audit trail
		::SendMessage(	::GetDlgItem( hwndDlg, IDC_ENABLE_TRAIL ),
						BM_SETCHECK,
						BST_CHECKED,
						0 );

		// Init the shared data here
		_ASSERT( NULL == pData );
		pData = reinterpret_cast<_SharedData*>( reinterpret_cast<PROPSHEETPAGE*>( lParam )->lParam );
		break;

	case WM_COMMAND:
		if ( HIWORD( wParam ) == BN_CLICKED )
		{
			// Enable/ Disable the combo box depending on the 'Enable trail' state
			BOOL bChecked = ( ::IsDlgButtonChecked( hwndDlg, IDC_ENABLE_TRAIL ) == BST_CHECKED );
			::EnableWindow( ::GetDlgItem( hwndDlg, IDC_KEEPFILES ), bChecked );
		}
		break;

	case WM_NOTIFY:
		LPNMHDR pNM = reinterpret_cast<NMHDR*>( lParam );

		switch( pNM->code )
		{
		case PSN_SETACTIVE:
			// For this dialog both Next and Back are enabled
			PropSheet_SetWizButtons( ::GetParent( hwndDlg ), PSWIZB_NEXT | PSWIZB_BACK );
			break;

		case PSN_WIZNEXT:
			// Store the settings in the shared data struct
			_ASSERT( pData != NULL );
			pData->Settings.bEnableTrail = ( ::IsDlgButtonChecked( hwndDlg, IDC_ENABLE_TRAIL ) == BST_CHECKED );

			if ( pData->Settings.bEnableTrail )
			{
				LRESULT nSel = ::SendMessage(	::GetDlgItem( hwndDlg, IDC_KEEPFILES ),
												CB_GETCURSEL,
												0,
												0 );
				_ASSERT( nSel != CB_ERR );
				_ASSERT( nSel < ARRAY_SIZE( anAuditFilesTime ) );

				pData->Settings.dwKeepFilesPeriod = anAuditFilesTime[ nSel ];
			}
			else
			{
				pData->Settings.dwKeepFilesPeriod = 0;
			}
			break;

		}
		break;
	};

	return 0;
}



INT_PTR CALLBACK InstallDlgProc( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam )
{
	static LPCWSTR _WARNING = 
L"The World Wide Web Publishing Service (W3SVC) is either stopped or disabled on your server. W3SVC provides \
Web conectivity and administration through IIS. If you do not plan to run W3SVC, you should not install IIS 6.0 \
Monitor. To cancel installation, click Cancel.\n\nTo complete the installation of the IIS 6.0 Monitor, \
click Next.\n\nIf you would like to modify your audit trail settings, click Back.";

	// If W3SVC is not running or if it is disabled - add a warning
	if ( ( WM_INITDIALOG == uMsg ) && !IsW3SVCEnabled() )
	{
		RECT rc;
		VERIFY( ::GetWindowRect( ::GetDlgItem( hwndDlg, IDC_FRAME ), &rc ) );

		VERIFY( ::SetWindowTextW( ::GetDlgItem( hwndDlg, IDC_INFO ), _WARNING ) );
		VERIFY( ::SetWindowPos( ::GetDlgItem( hwndDlg, IDC_FRAME ),
								NULL, 
								0, 
								0, 
								rc.right - rc.left, 
								rc.bottom - rc.top + 60, 
								SWP_NOMOVE | SWP_NOZORDER ) );
	}

	return 0;
}



INT_PTR CALLBACK ResultDlgProc( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam )
{
	_SharedData* pData = NULL;

	switch( uMsg )
	{
	case WM_INITDIALOG:
		// Init the shared data here
		_ASSERT( NULL == pData );
		pData = reinterpret_cast<_SharedData*>( reinterpret_cast<PROPSHEETPAGE*>( lParam )->lParam );

		// Set the title font
		SetWndFontFromLPARAM( ::GetDlgItem( hwndDlg, IDC_RESULT ), lParam,  TRUE );

		// If a previous error - set it. Else - try to install
		if ( NULL == pData->szError )
		{
			// Show the status window
			HWND hwndStatus = ::CreateDialog( pData->hInst, MAKEINTRESOURCE( IDD_PROGRESS ), hwndDlg, ProgressDlgProc );
			::ShowWindow( hwndStatus, SW_SHOW );
			::RedrawWindow( hwndStatus, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW );
			_ASSERT( hwndStatus != NULL );

			pData->szError = Install( pData->hInst, pData->Settings.bEnableTrail, pData->Settings.dwKeepFilesPeriod );

			// Hide the status window
			::DestroyWindow( hwndStatus );
		}

		if ( pData->szError != NULL )
		{
			TCHAR szBuffer[ 2048 ];
			::_stprintf(	szBuffer, 
							_T("IIS 6.0 Monitor installation failed because of the following error:\n\n%s"),
							pData->szError );

			VERIFY( ::SetWindowText( ::GetDlgItem( hwndDlg, IDC_RESULT ), _T("Installation Unsuccessful!") ) );
			VERIFY( ::SetWindowText( ::GetDlgItem( hwndDlg, IDC_INFO ), szBuffer ) );
		}
		break;

	case WM_NOTIFY:
		if ( PSN_SETACTIVE == reinterpret_cast<NMHDR*>( lParam )->code )
		{
			// Change the Next button to Finish. Back is not enabled - this is a result screen
			PropSheet_SetWizButtons( ::GetParent( hwndDlg ), PSWIZB_FINISH );
		}
		break;

	case WM_CTLCOLORDLG:
	case WM_CTLCOLORSTATIC:
		// Change the dlg background to white
		return reinterpret_cast<INT_PTR>( ::GetStockObject( WHITE_BRUSH ) );
	};

	return 0;
}



INT_PTR CALLBACK FatDlgProc( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam )
{
	RECT rc;

	const UINT nNoDetailsHeight		= 170;
	const UINT nWithDetailsHeight	= 310;

	VERIFY( ::GetWindowRect( hwndDlg, &rc ) );

	switch( uMsg )
	{
	case WM_INITDIALOG:
		LoadTextInCtrl( IDR_FATDETAILS, ::GetDlgItem( hwndDlg, IDC_DETAILS ) );
		::SetWindowPos( hwndDlg, NULL, 0, 0, rc.right - rc.left, nNoDetailsHeight, SWP_NOMOVE | SWP_NOZORDER );
		break;

	case WM_COMMAND:
		switch( LOWORD( wParam ) )
		{
		case IDOK:
		case IDCANCEL:
			::EndDialog( hwndDlg, LOWORD( wParam ) );
			break;

		case IDC_TOGGLE:
			// Alter current state ( current state is obtained using the window height )
			bool bDetailsVisible = !( ( rc.bottom - rc.top ) > nNoDetailsHeight );
			VERIFY( ::SetWindowText(	::GetDlgItem( hwndDlg, IDC_TOGGLE ), 
					bDetailsVisible ? _T("Details <<") : _T("Details >>" ) ) );
			::SetWindowPos(	hwndDlg, 
							NULL, 
							0, 
							0, 
							rc.right - rc.left, 
							bDetailsVisible ? nWithDetailsHeight : nNoDetailsHeight, 
							SWP_NOMOVE | SWP_NOZORDER );
			break;
		}
		break;
	};

	return FALSE;
}



INT_PTR CALLBACK ProgressDlgProc( IN HWND hwndDlg, IN UINT uMsg, IN WPARAM   wParam, IN LPARAM   lParam )
{
	// Nothing to do here
	return FALSE;
}



BOOL CheckForFAT( HINSTANCE hInst, HWND hwndParent )
{
	BOOL bRes = TRUE;

	// If the file system is FAT - warn the user
	if ( !IsNTFS() )
	{
		INT_PTR nDlgRes = ::DialogBox( hInst, MAKEINTRESOURCE( IDD_FAT_WARNING ), hwndParent, FatDlgProc );
		
		bRes = ( IDOK == nDlgRes );
	}

	return bRes;	
}


void LoadTextInCtrl( UINT nResID, HWND hwndCtrl )
{
	_ASSERT( hwndCtrl != NULL );

	HRSRC hRes = ::FindResource( NULL, MAKEINTRESOURCE( nResID ), RT_RCDATA );
	_ASSERT( hRes != NULL );

	// Get the resource data
	HGLOBAL hData = ::LoadResource( NULL, hRes );
	_ASSERT( hData != NULL );

	LPVOID pvData = ::LockResource( hData );
	_ASSERT( pvData != NULL );

	// The text is ANSI!
	VERIFY( ::SetWindowTextA( hwndCtrl, reinterpret_cast<LPCSTR>( pvData ) ) );
}



void AjustLicenseWizBtn( HWND hwndPage )
{
	// Enable / Disable the next button depending ot check box state
	bool bChecked = ( ::IsDlgButtonChecked( hwndPage, IDC_ACCEPT ) == BST_CHECKED );
	PropSheet_SetWizButtons( ::GetParent( hwndPage ), bChecked ? PSWIZB_NEXT | PSWIZB_BACK : PSWIZB_BACK );
}



void InitFonts( _FontData& FontData )
{
	// Create the font for the wizard title texts and for the text of tipd
	NONCLIENTMETRICS ncm	= { 0 };
    ncm.cbSize				= sizeof( ncm );
    ::SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );


    LOGFONT TitleLogFont	= ncm.lfMessageFont;
    TitleLogFont.lfWeight	= FW_BOLD;
    lstrcpy( TitleLogFont.lfFaceName, _T("Verdana Bold") );

	// Create the tips font
	FontData.hTips			= ::CreateFontIndirect( &TitleLogFont );

	// Create the intro/end title font
    HDC hdc					= ::GetDC(NULL); // Gets the screen DC
    INT FontSize			= 12;
    TitleLogFont.lfHeight	= 0 - GetDeviceCaps( hdc, LOGPIXELSY ) * FontSize / 72;
    FontData.hTitle			= ::CreateFontIndirect( &TitleLogFont );

    ::ReleaseDC( NULL, hdc );
}



void SetWndFontFromLPARAM( HWND hwndCtrl, LPARAM lParam, BOOL bTitle )
{
	PROPSHEETPAGE*	pPage	= reinterpret_cast<PROPSHEETPAGE*>( lParam );
	_FontData		Fonts	= reinterpret_cast<_SharedData*>( pPage->lParam )->Fonts;

	SetWindowFont( hwndCtrl, bTitle ? Fonts.hTitle : Fonts.hTips, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\stdafx.h ===
#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#define _WIN32_WINNT 0x0500

#include <crtdbg.h>
#include <windows.h>
#include <wchar.h>
#include <tchar.h>
#include <initguid.h>
#include <comdef.h>
#include <setupapi.h>			// Setup API
#include <mstask.h>				// ITaskScheduler definitions
#include <lm.h>		
#include <prsht.h>
#include <iadmw.h>				// IMSAdminBase*
#include <stdio.h>
#include <Shlwapi.h>
#include <shellapi.h>
#include <sddl.h>
#include <aclapi.h>


// Libraries in use
#pragma comment( lib, "setupapi.lib" )
#pragma comment( lib, "netapi32.lib" )
#pragma comment( lib, "comctl32.lib" )
#pragma comment( lib, "Shlwapi.lib" )

#include "Macros.h"

// Smart pointers
_COM_SMARTPTR_TYPEDEF( ITaskScheduler, IID_ITaskScheduler );
_COM_SMARTPTR_TYPEDEF( IScheduledWorkItem, IID_IScheduledWorkItem );
_COM_SMARTPTR_TYPEDEF( ITask, IID_ITask );
_COM_SMARTPTR_TYPEDEF( ITaskTrigger, IID_ITaskTrigger );



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\ui.h ===
#if !defined(AFX_UI_H__1E4C9C7F_0EC4_446B_855C_675AA212C3AD__INCLUDED_)
#define AFX_UI_H__1E4C9C7F_0EC4_446B_855C_675AA212C3AD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


void DoInstallUI( HINSTANCE hInstance );


#endif // !defined(AFX_UI_H__1E4C9C7F_0EC4_446B_855C_675AA212C3AD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\utils.h ===
// Utils.h: interface for the Utils class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UTILS_H__E86DC0AD_243D_4610_80A8_81C8A14D464C__INCLUDED_)
#define AFX_UTILS_H__E86DC0AD_243D_4610_80A8_81C8A14D464C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// This is the title for all wizard pages as well as the string that is shown in Add/Remove programs
extern LPCWSTR	MAIN_TITLE;


BOOL	IsMonInstalled	(	void );
BOOL	IsAdmin			(	void );
BOOL	IsIISInstalled	(	void );
BOOL	IsWhistlerSrv	(	void );
BOOL	IsIA64			(	void );
BOOL	IsNTFS			(	void );
BOOL	IsMonInstalled	(	void );
BOOL	IsTaskSchRunning(	void );
BOOL	IsW3SVCEnabled	(	void );

LPCTSTR	CanInstall		(	void );


// Task related
HRESULT SetupTasks		(	void );
void	DeleteTasks		(	void );
HRESULT	AddTask			(	const ITaskSchedulerPtr& spTaskSch, 
							LPCWSTR wszSubname, 
							LPCWSTR wszFileName, 
							LPCWSTR wszComment,
							DWORD dwTimeout,
							TASK_TRIGGER& Trigger );
void	InitTrigger		(	TASK_TRIGGER& Trigger );

// Registry related
HRESULT	SetupRegistry	(	BOOL bEnableTrail, DWORD dwDaysToKeep );
HRESULT	SetIISMonRegData(	LPCWSTR wszSubkey, LPCWSTR wszName, DWORD dwType, const BYTE* pbtData, DWORD dwSize );
void	DelIISMonKey	(	void );

// Directory and file related
void	GetIISMonPath	(	LPWSTR wszPath );
HRESULT SetupDirStruct	(	void );
HRESULT	SetupACLs		(	void );
void	DeleteDirStruct	(	BOOL bRemoveTrail );
void	DelDirWithFiles	(	LPCWSTR wszDir );

// INF related
HRESULT	InstallFromINF	(	void );
UINT	CALLBACK INFInstallCallback( PVOID pvCtx, UINT nNotif, UINT_PTR nP1, UINT_PTR nP2 );



LPCTSTR	Install			(	HINSTANCE hInstance, BOOL bAuditTrailEnabled, DWORD dwDaysToKeep );
void	Uninstall		(	BOOL bRemoveTrail );


#endif // !defined(AFX_UTILS_H__E86DC0AD_243D_4610_80A8_81C8A14D464C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iismon\utils.cpp ===
/*
****************************************************************************
|    Copyright (C) 2001  Microsoft Corporation
|
|   Module Name:
|
|       Utils.cpp
|
|   Abstract:
|		This is the core code for the IIS6 Monitor tool
|
|   Author:
|        Ivo Jeglov (ivelinj)
|
|   Revision History:
|        November 2001
|
****************************************************************************
*/


#include "stdafx.h"
#include "Utils.h"


// This is the title for all wizard pages as well as the string that is shown in Add/Remove programs
LPCWSTR	MAIN_TITLE = L"IIS 6.0 Monitor v1.2";


static LPCWSTR MON_REGKEY			= L"Software\\Microsoft\\IISMon";

static LPCTSTR MSG_ALREADYINSTALLED	= _T("IIS 6.0 Monitor is already installed. If you would like to re-install IIS 6.0 Monitor, please remove your current version using the 'Add or Remove Programs' interface in the Control Panel.");
static LPCTSTR MSG_NOTADMIN			= _T("Only members of the Administrator group can install IIS 6.0 Monitor. Please add yourself to the Administrators group, and then run IIS 6.0 Monitor installation again. If you cannot add yourself to the Administrators group, contact your network administrator.");
static LPCTSTR MSG_NOTASERVER		= _T("IIS 6.0 Monitor can be installed only on pre-release versions of the Windows Server 2003 family of products.");
static LPCTSTR MSG_NOIIS			= _T("Internet Information Services ( IIS ) is not installed. Please install IIS from Add/Remove Windows Components in Control Panel.");
static LPCTSTR MSG_IA64NOTSUPPORTED	= _T("IIS 6.0 Monitor cannot be installed on IA64 platforms.");
static LPCTSTR MSG_SCHEDULERSTOPPED	= _T("IIS 6.0 Monitor depends on Task Scheduler service to function properly. You need to enable Task Scheduler on this server by clicking Start, pointing to All Programs, then Administrative Tools, and clicking Services. From the list of services, right-click Task Scheduler, and click Start.");

static LPCTSTR ERR_COPYFAILED		= _T("IIS 6.0 Monitor installation has failed to copy the necessary files to your file system.");
static LPCTSTR ERR_REGERROR			= _T("The registry contains Windows configuration information. IIS 6.0 Monitor installation has failed to create a set of entries in the registry that are required to ensure IIS 6.0 Monitor functions properly.");
static LPCTSTR ERR_TASKERROR		= _T("IIS 6.0 Monitor installation failed while trying to use the Task Scheduler service on your server to schedule the necessary IIS 6.0 Monitor scripts to run on a periodic basis.");
static LPCTSTR ERR_DIRERROR			= _T("IIS 6.0 Monitor requires a specific set of directories to be created for proper functionality. IIS 6.0 Monitor installation has failed to create the necessary directories.");
static LPCTSTR ERR_SETACLAILED		= _T("IIS 6.0 Monitor installation has failed to setup the access rights of the required directories.");

static LPCWSTR TSK_DYN				= L"This scheduled task runs a JScript that is part of the IIS 6.0 Monitor tool.  This script is scheduled to run every two minutes to sample performance counter information, and then to generate an XML file that contains both aggregated performance counter information and entries from the Event Viewer.";
static LPCWSTR TSK_STAT				= L"This scheduled task runs a JScript that is part of the IIS 6.0 Monitor tool.  This script is scheduled to run once a week to collect system hardware information and registry settings, and then to generate an XML file containing this information.";
static LPCWSTR TSK_META				= L"This scheduled task runs a JScript that is part of the IIS 6.0 Monitor tool. This script is scheduled to run once a week to copy your XML metabase file, and then parses the copied metabase to remove sensitive information.";
static LPCWSTR TSK_UPLOAD			= L"This scheduled task runs a JScript that is part of the IIS 6.0 Monitor tool. This script uploads the XML files generated by the the following IIS 6.0 Monitor scripts to Microsoft: iismDyn.js, iismStat.js, and iismMeta.js. These scripts are located in %Systemroot%\\System32\\Inetsrv\\IISMon directory.  Files that are successfully uploaded to Microsoft will be copied to the %Systemdrive%\\IISMon directory if you have enabled the audit trail option.";



BOOL IsMonInstalled()
{
	// Check if the reg key exists. If so - the Monitor is installed
	HKEY	hKey	= NULL;
	BOOL	bRes	= FALSE;

	if ( ::RegOpenKeyExW( HKEY_LOCAL_MACHINE, MON_REGKEY, 0, KEY_READ, &hKey ) == ERROR_SUCCESS )
	{
		bRes = TRUE;
	}

	if ( hKey != NULL )
	{
		VERIFY( ::RegCloseKey( hKey ) == ERROR_SUCCESS );
	}

	return bRes;
}


// IsAdmin() - tests to see if the current user is an admin  	  
BOOL IsAdmin()
{
	// Try an Admin Privilaged API - if it works return TRUE - else FALSE
	SC_HANDLE hSC = ::OpenSCManager( NULL, NULL, GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

	BOOL bAdmin = hSC != NULL;

	if ( hSC != NULL )
	{
		VERIFY( ::CloseServiceHandle( hSC ) );
	}    

	return bAdmin;
}



BOOL IsIISInstalled( void )
{
	LPCWSTR	SERVICE_NAME = L"W3SVC";

	BOOL bRes = FALSE;

	// Open the SCM on the local machine
    SC_HANDLE   schSCManager = ::OpenSCManagerW( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	_ASSERT( schSCManager != NULL );	// We alredy checked that we are Admins
     
    SC_HANDLE   schService = ::OpenServiceW( schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS );
    
    if ( schService != NULL )
	{
		bRes = TRUE;
		VERIFY( ::CloseServiceHandle( schService ) );
	}

    VERIFY( ::CloseServiceHandle( schSCManager ) );
    
	return bRes;
}



BOOL IsWhistlerSrv()
{
    OSVERSIONINFOEXW osVersion = { 0 };
    osVersion.dwOSVersionInfoSize = sizeof( osVersion );

    VERIFY( ::GetVersionExW( reinterpret_cast<OSVERSIONINFOW*>( &osVersion ) ) );

    if (    ( osVersion.dwMajorVersion == 5 ) &&
            ( osVersion.dwMinorVersion == 2 ) &&
            ( ( osVersion.wProductType == VER_NT_SERVER ) || ( osVersion.wProductType == VER_NT_DOMAIN_CONTROLLER ) ) )
    {
        return TRUE;
    }

	return FALSE;
}



BOOL IsIA64()
{
	SYSTEM_INFO	Info;

	::GetSystemInfo( &Info );

	return (	( Info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ) ||
				( Info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 ) ||
				( Info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ) );
}



BOOL IsNTFS()
{
	const UINT BUFF_LEN = 32;	// Should be large enough to hold the volume and the file system type

	WCHAR wszBuffer[ BUFF_LEN ];

	// Get the system drive letter
	VERIFY( ::ExpandEnvironmentStringsW( L"%SystemDrive%", wszBuffer, BUFF_LEN ) != 0 );

	// wszBuffer containts the drive only - add the slash to make the volume string
	::wcscat( wszBuffer, L"\\" );

	DWORD dwMaxComponentLength	= 0;
	DWORD dwSystemFlags			= 0;

	WCHAR wszFileSystem[ BUFF_LEN ];
	
	VERIFY( ::GetVolumeInformationW(	wszBuffer,
										NULL,
										0,
										NULL,
										&dwMaxComponentLength,
										&dwSystemFlags,
										wszFileSystem,
										BUFF_LEN ) );

	return ::wcscmp( wszFileSystem, L"NTFS" ) == 0;
}



BOOL IsTaskSchRunning()
{
	LPCWSTR	SERVICE_NAME = L"Schedule";

	BOOL bRunning = FALSE;

	// Open the SCM on the local machine
    SC_HANDLE   schSCManager = ::OpenSCManagerW( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	_ASSERT( schSCManager != NULL );	// We alredy checked that we are Admins
     
    SC_HANDLE   schService = ::OpenServiceW( schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS );
    _ASSERT( schService != NULL );	// This service is part of the OS and must exist
      
	SERVICE_STATUS ssStatus;

	VERIFY( ::QueryServiceStatus( schService, &ssStatus ) );
    
	bRunning = ( ssStatus.dwCurrentState == SERVICE_RUNNING );
    
	VERIFY( ::CloseServiceHandle( schService ) );
    VERIFY( ::CloseServiceHandle( schSCManager ) );
    
	return bRunning;
}



BOOL IsW3SVCEnabled()
{
	LPCWSTR	SERVICE_NAME = L"W3SVC";

	BOOL bSvcOK = FALSE;

	// Open the SCM on the local machine
    SC_HANDLE   schSCManager = ::OpenSCManagerW( NULL, NULL, SC_MANAGER_ALL_ACCESS );
	_ASSERT( schSCManager != NULL );	// We alredy checked that we are Admins
     
    SC_HANDLE   schService = ::OpenServiceW( schSCManager, SERVICE_NAME, SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );
    _ASSERT( schService != NULL );	// We already checked that this service exist ( IsIISInstalled(...) )
      
	SERVICE_STATUS			ssStatus;
	LPQUERY_SERVICE_CONFIGW	pSvcConfig = reinterpret_cast<LPQUERY_SERVICE_CONFIGW>( ::malloc( 4096 ) );

	// Do not let an out of mem condition to ruin the Setup process at this step - pretend the service is OK
	if ( NULL == pSvcConfig )
	{
		return TRUE;
	}
	
	DWORD dwNeeded = 0;

	VERIFY( ::QueryServiceStatus( schService, &ssStatus ) );
	VERIFY( ::QueryServiceConfigW( schService, pSvcConfig, 4096, &dwNeeded ) );
	_ASSERT( dwNeeded <= 4096 );
    
	bSvcOK = ( SERVICE_RUNNING == ssStatus.dwCurrentState ) && ( SERVICE_DISABLED != pSvcConfig->dwStartType );
    
	VERIFY( ::CloseServiceHandle( schService ) );
    VERIFY( ::CloseServiceHandle( schSCManager ) );
	::free( pSvcConfig );
    
	return bSvcOK;
}



LPCTSTR CanInstall()
{
	LPCTSTR szError = NULL;

	// Check all install requirements:\
	
	if ( IsMonInstalled() )
	{
		szError = MSG_ALREADYINSTALLED;
	}
	else if ( !IsAdmin() )
	{
		szError = MSG_NOTADMIN;
	}
	else if ( !IsWhistlerSrv() )
	{
		szError = MSG_NOTASERVER;
	}
	else if ( !IsIISInstalled() )
	{
		szError = MSG_NOIIS;
	}
	else if ( IsIA64() )
	{
		szError = MSG_IA64NOTSUPPORTED;
	}
	else if ( !IsTaskSchRunning() )
	{
		szError = MSG_SCHEDULERSTOPPED;
	}
		
	return szError;
}



HRESULT SetupTasks()
{
	DECLARE_HR_SUCCESS;

	ITaskSchedulerPtr		spTaskScheduler;
	TASK_TRIGGER			Trigger;

	// Get an interface to the Task Scheduler
	IF_SUCCEEDED( spTaskScheduler.CreateInstance( CLSID_CTaskScheduler ) );

	// iismDyn.js - will run every 2 minutes. Timeout 2min
	//////////////////////////////////////////////////////////////////
	::InitTrigger( /*r*/Trigger );
	Trigger.TriggerType						= TASK_TIME_TRIGGER_DAILY;
	Trigger.Type.Daily.DaysInterval			= 1;			// Every Day
	Trigger.MinutesDuration					= 24 * 60;		// The task have to be active all the day long
	Trigger.MinutesInterval					= 2;			// Run every 2 minutes
	IF_SUCCEEDED( ::AddTask( spTaskScheduler, L"DynData", L"iismDyn.js", TSK_DYN, 2 * 60 * 1000, Trigger ) );


	// iismUpload.js - will run every 2 minutes. Timeout: 12min
	//////////////////////////////////////////////////////////////////
	::InitTrigger( /*r*/Trigger );
	Trigger.TriggerType						= TASK_TIME_TRIGGER_DAILY;
	Trigger.Type.Daily.DaysInterval			= 1;			// Every Day
	Trigger.MinutesDuration					= 24 * 60;		// The task have to be active all the day long
	Trigger.MinutesInterval					= 120;			// Run every 2 hours
	IF_SUCCEEDED( ::AddTask( spTaskScheduler, L"Upload", L"iismUpld.js", TSK_UPLOAD, 12 * 60 * 1000, Trigger ) );


	// iismStat.js - will run once every week on Sunday, 3:00AM. Timeout: 2min
	//////////////////////////////////////////////////////////////////
	::InitTrigger( /*r*/Trigger );
	Trigger.TriggerType						= TASK_TIME_TRIGGER_WEEKLY;
	Trigger.Type.Weekly.WeeksInterval		= 1;	// Every week
	Trigger.Type.Weekly.rgfDaysOfTheWeek	= TASK_SUNDAY;
	Trigger.wStartHour						= 3;
	Trigger.wStartMinute					= 00;
	IF_SUCCEEDED( ::AddTask( spTaskScheduler, L"StatData", L"iismStat.js", TSK_STAT, 2 * 60 * 1000, Trigger ) );


	// iismMeta.js - will run once every week on Sunday, 3:15AM. Timeout: 5min
	//////////////////////////////////////////////////////////////////
	::InitTrigger( /*r*/Trigger );
	Trigger.TriggerType						= TASK_TIME_TRIGGER_WEEKLY;
	Trigger.Type.Weekly.WeeksInterval		= 1;	// Every week
	Trigger.Type.Weekly.rgfDaysOfTheWeek	= TASK_SUNDAY;
	Trigger.wStartHour						= 3;
	Trigger.wStartMinute					= 15;
	IF_SUCCEEDED( ::AddTask( spTaskScheduler, L"MetaData", L"iismMeta.js", TSK_META, 5 * 60 * 1000,  Trigger ) );

	return hr;
}



void DeleteTasks()
{
	ITaskSchedulerPtr		spTaskScheduler;
	
	// Get an interface to the Task Scheduler
	if ( SUCCEEDED( spTaskScheduler.CreateInstance( CLSID_CTaskScheduler ) ) )
	{
		// Try to delete the tasks. The result is for information purposes only
		VERIFY( SUCCEEDED( spTaskScheduler->Delete( L"IIS Monitor ( DynData )" ) ) );
		VERIFY( SUCCEEDED( spTaskScheduler->Delete( L"IIS Monitor ( Upload )" ) ) );
		VERIFY( SUCCEEDED( spTaskScheduler->Delete( L"IIS Monitor ( StatData )" ) ) );
		VERIFY( SUCCEEDED( spTaskScheduler->Delete( L"IIS Monitor ( MetaData )" ) ) );
	}
}



HRESULT	AddTask(	const ITaskSchedulerPtr& spTaskScheduler, 
					LPCWSTR wszSubname, 
					LPCWSTR wszFileName, 
					LPCWSTR wszComment,
					DWORD dwTimeout,
					TASK_TRIGGER& Trigger )
{
	DECLARE_HR_SUCCESS;

	static LPCWSTR TASK_NAME_FMT	= L"IIS Monitor ( %s )";
	static LPCWSTR TASK_COMMENT		= L"This task is used to collect IIS statistic info and send it back to Microsoft.";
	
	WCHAR					wszPath[ MAX_PATH + 1 ];
	WCHAR					wszName[ 512 ];
	ITaskPtr				spTask;
	IPersistFilePtr			spPersistFile;

	// Create the task name
	::swprintf( wszName, TASK_NAME_FMT, wszSubname );

	// Get the path ( for the working dir and for the executable )
	GetIISMonPath( wszPath );

	// Add the new task
	IF_SUCCEEDED( spTaskScheduler->NewWorkItem(	wszName, 
												CLSID_CTask, 
												IID_ITask, 
												reinterpret_cast<IUnknown**>( &spTask ) ) );

	// If the taks alredy exists - use it and modify it
	if ( HRESULT_FROM_WIN32( ERROR_FILE_EXISTS ) == hr )
	{
		hr = spTaskScheduler->Activate( wszName, IID_ITask, reinterpret_cast<IUnknown**>( &spTask ) );
	}

	// Setup the task
	IF_SUCCEEDED( spTask->SetWorkingDirectory( wszPath ) );	
	IF_SUCCEEDED( spTask->SetComment( wszComment ) );
	IF_SUCCEEDED( spTask->SetPriority( NORMAL_PRIORITY_CLASS ) );
	IF_SUCCEEDED( spTask->SetMaxRunTime( dwTimeout ) );	
	IF_SUCCEEDED( spTask->SetAccountInformation( L"", NULL ) );	// Use Local System account

	// Set task command line
	VERIFY( ::PathAppendW( wszPath, wszFileName ) );
	IF_SUCCEEDED( spTask->SetApplicationName( L"cscript.exe" ) );
	IF_SUCCEEDED( spTask->SetParameters( wszPath ) );

	// Set the trigger
	IScheduledWorkItemPtr	spItem;
	ITaskTriggerPtr			spTrigger;
	WORD					wUnused = 0;

	IF_SUCCEEDED( spTask.QueryInterface( IID_IScheduledWorkItem, &spItem ) );
	IF_SUCCEEDED( spItem->CreateTrigger( &wUnused, &spTrigger ) );
	IF_SUCCEEDED( spTrigger->SetTrigger( &Trigger ) );

	// Store the changes
	IF_SUCCEEDED( spTask.QueryInterface( IID_IPersistFile, &spPersistFile ) );
	IF_SUCCEEDED( spPersistFile->Save( NULL, TRUE ) );

	// Cleanup
	if ( FAILED( hr ) )
	{
		// Remove the task
		if ( spTaskScheduler != NULL )
		{
			spTaskScheduler->Delete( wszName );
		}
	}	

	return hr;
}



void InitTrigger( TASK_TRIGGER& rTrigger )
{
	::ZeroMemory( &rTrigger, sizeof( TASK_TRIGGER ) );

	rTrigger.cbTriggerSize = sizeof( TASK_TRIGGER );

	// Set the start time for something in the pas. We don't use this feature
	rTrigger.wBeginYear		= 2000;
	rTrigger.wBeginMonth	= 1;
	rTrigger.wBeginDay		= 1;
}



HRESULT	SetupRegistry( BOOL bEnableTrail, DWORD dwDaysToKeep )
{
	DECLARE_HR_SUCCESS;

	// Generete the GUID for this machine
	GUID	guid;
	DWORD	dwTrail = bEnableTrail ? 1 : 0;
	IF_SUCCEEDED( ::CoCreateGuid( &guid ) );

	// Create the unsintall string
	WCHAR	wszUninstall[ MAX_PATH + 1 ];
	GetIISMonPath( wszUninstall );
	VERIFY( ::PathAppendW( wszUninstall, L"iismoni.exe -uninstinter" ) );

	// Convert it to string
	WCHAR wszBuffer[ 64 ];	// SHould be large enough to hold a string GUID
	VERIFY( ::StringFromGUID2( guid, wszBuffer, 64 ) != 0 );

	// Store GUID
	IF_SUCCEEDED( SetIISMonRegData(	MON_REGKEY, 
									L"ServerGUID", 
									REG_SZ, 
									reinterpret_cast<BYTE*>( wszBuffer ), 
									::wcslen( wszBuffer ) * sizeof( WCHAR ) ) );

	// Store the audit trail value
	IF_SUCCEEDED( SetIISMonRegData(	MON_REGKEY, 
									L"AuditTrailEnabled", 
									REG_DWORD, 
									reinterpret_cast<BYTE*>( &dwTrail ), 
									sizeof( DWORD ) ) );

	// Set the DaysToKeep Value
	IF_SUCCEEDED( SetIISMonRegData(	MON_REGKEY, 
									L"AuditTrailTimeLimit", 
									REG_DWORD, 
									reinterpret_cast<BYTE*>( &dwDaysToKeep ), 
									sizeof( DWORD ) ) );

	// Set the uninstall string
	IF_SUCCEEDED( SetIISMonRegData(	L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\IISMon", 
									L"UninstallString",
									REG_SZ, 
									reinterpret_cast<BYTE*>( wszUninstall ), 
									::wcslen( wszUninstall ) * sizeof( WCHAR ) ) );

	// Set the uninstall display name
	IF_SUCCEEDED( SetIISMonRegData(	L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\IISMon", 
									L"DisplayName",
									REG_SZ, 
									( BYTE* )( MAIN_TITLE ), 
									::wcslen( MAIN_TITLE ) * sizeof( WCHAR ) ) );
	
	return hr;
}



HRESULT	SetIISMonRegData( LPCWSTR wszSubkey, LPCWSTR wszName, DWORD dwType, const BYTE* pbtData, DWORD dwSize )
{
	DECLARE_HR_SUCCESS;

	_ASSERT( wszName != NULL );
	_ASSERT( dwSize > 0 );
	_ASSERT( pbtData != NULL );
	_ASSERT( wszSubkey != NULL );

	HKEY	hKey = NULL;

	// If the key does not exists - create it
	if ( ::RegCreateKeyExW(	HKEY_LOCAL_MACHINE, 
							wszSubkey, 
							0, 
							NULL, 
							REG_OPTION_NON_VOLATILE, 
							KEY_SET_VALUE,
							NULL,
							&hKey,
							NULL ) != ERROR_SUCCESS )
	{
		hr = E_FAIL;
	}
	
	if ( SUCCEEDED( hr ) )
	{
		if ( ::RegSetValueExW( hKey, wszName, 0, dwType, pbtData, dwSize ) != ERROR_SUCCESS )
		{
			hr = E_FAIL;
		}
	}

	if ( hKey != NULL )
	{
		::RegCloseKey( hKey );
	}

	return hr;
}



void DelIISMonKey()
{
	VERIFY( ::SHDeleteKeyW( HKEY_LOCAL_MACHINE, MON_REGKEY ) == ERROR_SUCCESS );
	VERIFY( ::SHDeleteKeyW( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\IISMon" ) == ERROR_SUCCESS );
}



void GetIISMonPath(	LPWSTR wszPath )
{
	// wszPath should be a buffer with MAX_PATH + 1 length
	VERIFY( ::GetSystemDirectoryW( wszPath, MAX_PATH + 1 ) != 0 );
	VERIFY( ::PathAppendW( wszPath, L"Inetsrv\\IISMon" ) );
}



HRESULT SetupDirStruct()
{
	BOOL	bRes = TRUE;
	WCHAR	wszRoot[ MAX_PATH + 1 ];
	
	// Create the Log and Upload folders
	// Do not fail if they already exist
	if ( bRes )
	{
		GetIISMonPath( wszRoot );
		VERIFY( ::PathAppendW( wszRoot, L"Upload" ) );

		bRes = ::CreateDirectoryW( wszRoot, NULL );

		if ( !bRes && ( ::GetLastError() == ERROR_ALREADY_EXISTS ) )
		{
			bRes = TRUE;
		}
	}

	if ( bRes )
	{
		GetIISMonPath( wszRoot );
		VERIFY( ::PathAppendW( wszRoot, L"Log" ) );

		bRes = ::CreateDirectoryW( wszRoot, NULL );

		if ( !bRes && ( ::GetLastError() == ERROR_ALREADY_EXISTS ) )
		{
			bRes = TRUE;
		}
	}

	return bRes ? S_OK : E_FAIL;
}



HRESULT	SetupACLs( void )
{
	// ACLs are set so that only Administrators have access to IISMon folders
	// The ACLs are not inherited from parent dirs
	SECURITY_DESCRIPTOR*	pSD		= NULL;
	ACL*					pDACL	= NULL;	
	SECURITY_INFORMATION	si		= ( DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION );

	BOOL bHaveDACL	= FALSE;
	BOOL bDefaulted	= FALSE;
	
	// This is the ACL that we will set. String ACL is used for simplicity
	// See ACE strings documentation in the MSDN ( Search for "SDDL" )
	VERIFY( ::ConvertStringSecurityDescriptorToSecurityDescriptorW(	L"D:P(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)",
																	SDDL_REVISION_1,
																	reinterpret_cast<void**>( &pSD ),
																	NULL ) );

	VERIFY( ::GetSecurityDescriptorDacl( pSD, &bHaveDACL, &pDACL, &bDefaulted ) );

	// Set theDACL to all the folders
	LPCWSTR awszDirs[] = {	L"%systemdrive%\\IISMon",
							L"%systemroot%\\system32\\inetsrv\\IISMon" 
						};

	for ( int i = 0; i < ARRAY_SIZE( awszDirs ); ++i )
	{
		WCHAR wszPath[ MAX_PATH + 1 ];
		::wcscpy( wszPath, awszDirs[ i ] );
		VERIFY( LOWORD( ::DoEnvironmentSubstW( wszPath, MAX_PATH + 1 ) ) );

		if ( ::SetNamedSecurityInfoW(	wszPath, 
										SE_FILE_OBJECT,
										si,
										NULL,
										NULL,
										pDACL,
										NULL ) != ERROR_SUCCESS )
		{
			return E_FAIL;
		}
	}

	return S_OK;
}


void DeleteDirStruct( BOOL bRemoveTrail )
{
	WCHAR	wszRoot[ MAX_PATH + 1 ];

	::GetIISMonPath( wszRoot );
	VERIFY( ::PathAppendW( wszRoot, L"Upload\\Incomplete" ) );
	DelDirWithFiles( wszRoot );

	::GetIISMonPath( wszRoot );
	VERIFY( ::PathAppendW( wszRoot, L"Upload" ) );
	DelDirWithFiles( wszRoot );

	::GetIISMonPath( wszRoot );
	VERIFY( ::PathAppendW( wszRoot, L"Log" ) );
	DelDirWithFiles( wszRoot );

	::GetIISMonPath( wszRoot );
	VERIFY( ::PathAppendW( wszRoot, L"1033" ) );
	DelDirWithFiles( wszRoot );

	::GetIISMonPath( wszRoot );
	DelDirWithFiles( wszRoot );

	if ( bRemoveTrail )
	{
		VERIFY( ::ExpandEnvironmentStringsW( L"%SystemDrive%", wszRoot, MAX_PATH + 1 ) != 0 );
		VERIFY( ::PathAppendW( wszRoot, L"IISMon" ) );
		DelDirWithFiles( wszRoot );
	}
}



void DelDirWithFiles( LPCWSTR wszDir )
{
	WIN32_FIND_DATAW	fd;
	WCHAR				wszPath[ MAX_PATH + 1 ];

	::wcscpy( wszPath, wszDir );
	VERIFY( ::PathAppendW( wszPath, L"*.*" ) );

	HANDLE				hSearch = ::FindFirstFileW( wszPath, &fd );

	// this is not a normal case. 
	if ( INVALID_HANDLE_VALUE == hSearch ) return;

	do
	{
		::wcscpy( wszPath, wszDir );

		// Skip directories. Delete only files
		if ( 0 == ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
		{
			VERIFY( ::PathAppendW( wszPath,fd.cFileName ) );

			// If we can't delete the file right now - may be it is locked. Schedule it for deletion at next boot
			if ( !::DeleteFileW( wszPath ) )
			{
				VERIFY( ::MoveFileExW( wszPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) );
			}

		}
	}while( ::FindNextFileW( hSearch, &fd ) );

	VERIFY( ::FindClose( hSearch ) );

	// Remove the directory ( should be empty now )
	// Again - if it cannot be deleted right now - schedule it for next boot
	if ( !::RemoveDirectoryW( wszDir ) )
	{
		VERIFY( ::MoveFileExW( wszDir, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) );
	}
}



// Installs a section
HRESULT	InstallFromINF()
{
	DECLARE_HR_SUCCESS;

	// The INF file must be in the same dir as this EXE.Build the path to ther INF file
	WCHAR	wszPath[ _MAX_PATH + 1 ];
	WCHAR	wszDrive[ _MAX_DRIVE + 1 ];
	WCHAR	wszFolder[ _MAX_DIR + 1 ];

	VERIFY( ::GetModuleFileNameW( NULL, wszPath, MAX_PATH ) != 0 );
	
	::_wsplitpath( wszPath, wszDrive, wszFolder, NULL, NULL );

	::_wmakepath( wszPath, wszDrive, wszFolder, L"IISMon", L"inf" );

	HINF		hInf	= ::SetupOpenInfFileW( wszPath, NULL, INF_STYLE_WIN4, 0 );

	// The file MUST exist - it is installed by the IExpress tool
	_ASSERT( hInf != INVALID_HANDLE_VALUE );

	BOOL bRes = ::SetupInstallFromInfSectionW(	NULL,
												hInf,
												L"DefaultInstall",
												SPINST_FILES | SPINST_REGISTRY,
												NULL,
												NULL,
												SP_COPY_NEWER_OR_SAME,
												INFInstallCallback,
												NULL,
												NULL,
												NULL );

	::SetupCloseInfFile( hInf );

	return bRes ? S_OK : E_FAIL;
}



UINT CALLBACK INFInstallCallback( PVOID pvCtx, UINT nNotif, UINT_PTR nP1, UINT_PTR nP2 )
{
	// Abort the installation for all errors
	if (	( SPFILENOTIFY_COPYERROR == nNotif ) ||
			( SPFILENOTIFY_RENAMEERROR == nNotif ) )
	{
		return FILEOP_ABORT;
	}

	// Allow the operation to execute
	return FILEOP_DOIT;
}



LPCTSTR Install( HINSTANCE hInstance, BOOL bAuditTrailEnabled, DWORD dwDaysToKeep )
{
	DECLARE_HR_SUCCESS;

	LPCTSTR szLocalError = NULL;
	WCHAR wszPath[ MAX_PATH + 1 ];
	::swprintf( wszPath, L"wmiadap.exe /F" );

	STARTUPINFOW		si = { 0 };
	PROCESS_INFORMATION	pi = { 0 };
	si.cb = sizeof( si );

	// Execute wmiadap.exe /f to refresh perf counters on this machine
	VERIFY( ::CreateProcessW( NULL, wszPath, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi ) );
	::CloseHandle( pi.hProcess );
	::CloseHandle( pi.hThread );

	if ( SUCCEEDED( hr ) )
	{
		szLocalError = ERR_COPYFAILED;
		hr = InstallFromINF();
	}	

	// Setup ACLs
	if ( SUCCEEDED( hr ) )
	{
		szLocalError = ERR_SETACLAILED;
		hr = SetupACLs();
	}

	// Register the iismon.wsc component
	if ( SUCCEEDED( hr ) )
	{
		::swprintf( wszPath, L"regsvr32 /s \"%%systemroot%%\\system32\\inetsrv\\iismon\\iismon.wsc\"" );
		VERIFY( LOWORD( ::DoEnvironmentSubstW( wszPath, MAX_PATH + 1 ) ) );
		::ZeroMemory( &pi, sizeof( pi ) );

		if ( !::CreateProcessW( NULL, wszPath , NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi ) )
		{
			hr = E_FAIL;
		}
		else
		{
			::CloseHandle( pi.hProcess );
			::CloseHandle( pi.hThread );
		}
	}

	// Setup the registry
	if ( SUCCEEDED( hr ) )
	{
		hr = SetupRegistry( bAuditTrailEnabled, dwDaysToKeep );
		szLocalError = ERR_REGERROR;
	}

	// Use local system account for now
 	if ( SUCCEEDED( hr ) )
	{
		hr = SetupTasks();
		szLocalError = ERR_TASKERROR;
	}
	
	// Setup dir structure
	if ( SUCCEEDED( hr ) )
	{
		hr = SetupDirStruct();
		szLocalError = ERR_DIRERROR;
	}	

	// Error handling
	if ( FAILED( hr ) )
	{
		// Try to not leave side effects
		Uninstall( FALSE );
	}

	return SUCCEEDED( hr ) ? NULL : szLocalError;
}


void Uninstall( BOOL bRemoveTrail )
{
	// Unregister iismon.wsc
	WCHAR				wszPath[ MAX_PATH + 1 ];
	STARTUPINFOW		si = { 0 };
	PROCESS_INFORMATION	pi = { 0 };
	si.cb = sizeof( si );

	::swprintf( wszPath, L"regsvr32 /s /u \"%%systemroot%%\\system32\\inetsrv\\iismon\\iismon.wsc\"" );
	VERIFY( LOWORD( ::DoEnvironmentSubstW( wszPath, MAX_PATH + 1 ) ) );
	VERIFY( ::CreateProcessW( NULL, wszPath, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi ) );
	::CloseHandle( pi.hProcess );
	::CloseHandle( pi.hThread );

	// Remove the tasks
	DeleteTasks();

	// Remove the files
	DeleteDirStruct( bRemoveTrail );

	// Remove the reg key
	DelIISMonKey();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iiswinsamp\main.cpp ===
#include <stdio.h>
#include <tchar.h>

#define INITGUID // must be before iadmw.h
#include <iadmw.h>      // Interface header

// for adsi objects
#include <Iads.h>
#include <Adshlp.h>

// for the IID_IISWebService object
#include "iiisext.h"
#include "iisext_i.c"

#define WEBSVCEXT_RESTRICTION_LIST_ADSI_LOCATION  L"IIS://LOCALHOST/W3SVC"

HRESULT AddWebSvcExtention(LPWSTR lpwszFileName,VARIANT_BOOL bEnabled,LPWSTR lpwszGroupID,VARIANT_BOOL bDeletableThruUI,LPWSTR lpwszGroupDescription);
HRESULT RemoveWebSvcExtention(LPWSTR lpwszFileName);
HRESULT AddApplicationDependencyUponGroup(LPWSTR lpwszAppName,LPWSTR lpwszGroupID);
HRESULT RemoveApplicationDependencyUponGroup(LPWSTR lpwszAppName,LPWSTR lpwszGroupID);

int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)
{
	BOOL bComInitialized = SUCCEEDED( ::CoInitialize( NULL ) );

    // Add MyFile.dll to the restrictionlist, make sure it's enabled, 
    // and that the user is able to remove the entry thru the UI if they wanted to
    AddWebSvcExtention(L"c:\\windows\\system32\\inetsrv\\MyFile.dll",VARIANT_TRUE,L"MyGroup",VARIANT_TRUE,L"My Description");

    // The Commerce Server group would make this entry, to say that
    // They're app is dependent upon MyGroup (like dependent upon ASP or soemthing)
    //
    // This way, if the user installed disabled all of the extensions
    // and then discovered "Commerce Server" wasn't working right, they could
    // just go to the iis ui and enable all extensions that are used by "Commerce Server" -- 
    // so that "Commerce Server" would work.
    AddApplicationDependencyUponGroup(L"Commerce Server",L"MyGroup");
    AddApplicationDependencyUponGroup(L"Commerce Server",L"ASP60");
    AddApplicationDependencyUponGroup(L"Commerce Server",L"INDEX2002");

    //RemoveWebSvcExtention(L"c:\\windows\\system32\\inetsrv\\MyFile.dll");

    //RemoveApplicationDependencyUponGroup(L"Commerce Server",L"MyGroup");
    //RemoveApplicationDependencyUponGroup(L"Commerce Server",L"ASP60");
    //RemoveApplicationDependencyUponGroup(L"Commerce Server",L"INDEX2002");

	if ( bComInitialized )
	{
		::CoUninitialize();
	}
	return 0;
}

/*
IID_IISWebService has:
o.EnableApplication(myapp);
o.RemoveApplication(myapp);
o.ListApplications(foo);   // must declare foo first  returned as a VB array
o.AddDependency(myapp, mygroup);
o.RemoveDependency(myapp, mygroup);
o.EnableWebServiceExtension(mygroup);
o.DisableWebServiceExtension(mygroup);
o.ListWebServiceExtensions(foo);  // see foo note above
o.EnableExtensionFile(myfile);
o.DisableExtensionFile(myfile);
o.AddExtensionFile(myfile, boolEnabled, mygroup, boolCanDelete, my description sucks);  // boolEnabled = t/f, boolCanDelete = t/f
o.DeleteExtensionFileRecord(myfile);
o.ListExtensionFiles(foo);  // see foo note above
*/

HRESULT AddWebSvcExtention(LPWSTR lpwszFileName,VARIANT_BOOL bEnabled,LPWSTR lpwszGroupID,VARIANT_BOOL bDeletableThruUI,LPWSTR lpwszGroupDescription)
{
    HRESULT hrRet = S_FALSE;
    WCHAR* wszRootWeb6 = WEBSVCEXT_RESTRICTION_LIST_ADSI_LOCATION;

    IISWebService * pWeb = NULL;
    HRESULT hr = ADsGetObject(wszRootWeb6, IID_IISWebService, (void**)&pWeb);
    if (SUCCEEDED(hr) && NULL != pWeb)
    {
        VARIANT var1,var2;
        VariantInit(&var1);
        VariantInit(&var2);

        var1.vt = VT_BOOL;
        var1.boolVal = bEnabled;

        var2.vt = VT_BOOL;
        var2.boolVal = bDeletableThruUI;

        hr = pWeb->AddExtensionFile(lpwszFileName,var1,lpwszGroupID,var2,lpwszGroupDescription);
        if (SUCCEEDED(hr))
        {
            hrRet = S_OK;
        }
        else
        {
            OutputDebugString(_T("failed,probably already exists\r\n"));
        }
        VariantClear(&var1);
        VariantClear(&var2);
        pWeb->Release();
    }

    return hrRet;
}

HRESULT RemoveWebSvcExtention(LPWSTR lpwszFileName)
{
    HRESULT hrRet = S_FALSE;
    WCHAR* wszRootWeb6 = WEBSVCEXT_RESTRICTION_LIST_ADSI_LOCATION;

    IISWebService * pWeb = NULL;
    HRESULT hr = ADsGetObject(wszRootWeb6, IID_IISWebService, (void**)&pWeb);
    if (SUCCEEDED(hr) && NULL != pWeb)
    {
        hr = pWeb->DeleteExtensionFileRecord(lpwszFileName);
        if (SUCCEEDED(hr))
        {
            hrRet = S_OK;
        }
        else
        {
            OutputDebugString(_T("failed,probably already gone\r\n"));
        }
        pWeb->Release();
    }

    return hrRet;
}

HRESULT AddApplicationDependencyUponGroup(LPWSTR lpwszAppName,LPWSTR lpwszGroupID)
{
    HRESULT hrRet = S_FALSE;
    WCHAR* wszRootWeb6 = WEBSVCEXT_RESTRICTION_LIST_ADSI_LOCATION;

    IISWebService * pWeb = NULL;
    HRESULT hr = ADsGetObject(wszRootWeb6, IID_IISWebService, (void**)&pWeb);
    if (SUCCEEDED(hr) && NULL != pWeb)
    {
        hr = pWeb->AddDependency(lpwszAppName,lpwszGroupID);
        if (SUCCEEDED(hr))
        {
            hrRet = S_OK;
        }
        else
        {
            OutputDebugString(_T("failed,probably already exists\r\n"));
        }
        pWeb->Release();
    }

    return hrRet;
}

HRESULT RemoveApplicationDependencyUponGroup(LPWSTR lpwszAppName,LPWSTR lpwszGroupID)
{
    HRESULT hrRet = S_FALSE;
    WCHAR* wszRootWeb6 = WEBSVCEXT_RESTRICTION_LIST_ADSI_LOCATION;

    IISWebService * pWeb = NULL;
    HRESULT hr = ADsGetObject(wszRootWeb6, IID_IISWebService, (void**)&pWeb);
    if (SUCCEEDED(hr) && NULL != pWeb)
    {
        hr = pWeb->RemoveDependency(lpwszAppName,lpwszGroupID);
        if (SUCCEEDED(hr))
        {
            hrRet = S_OK;
        }
        else
        {
            OutputDebugString(_T("failed,probably already gone\r\n"));
        }
        pWeb->Release();
    }

    return hrRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\infutil2\filefind.h ===
typedef struct  _finddata_t SysFindData;
struct MyFindDataStruct 
{
    unsigned        attrib;   // File attribute
    time_t          time_create; //   Time of file creation ( 1L for FAT file systems)
    time_t          time_access; //   Time of last file access (1L for FAT file systems)
    time_t          time_write; //   Time of last write to file
    unsigned long size; //   Length of file in bytes
    char *          name; //   Null-terminated name of matched file/directory, without the path
    char *          ShortName;
};
typedef struct MyFindDataStruct finddata;


#define ALL_FILES		0xff
#define STRING_TABLE_SIZE   100000

int  InitStringTable(long size);
void EndStringTable();
void AddString(char * s, finddata * f);
long GetStringTableSize();
void ResetStringTable();
int  FindFirst(char * ss, unsigned attr, intptr_t * hFile, finddata * s);
int  FindNext(int attr, intptr_t hFile, finddata * s);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\infutil2\filefind.cpp ===
/********************************************************************************
* Description:
*	 Functions that do what _dos_findfirst and _dos_findnext SHOULD do
*******************************************************************************/
#include <io.h>
#include <string.h>
#include <malloc.h>
#include "filefind.h"

static char * StringTable;
static long offset = 0 ;
static long MaxOffset;


int InitStringTable(long size)
{
	StringTable=(char *) malloc(size);
    ResetStringTable();
	return StringTable != 0;
}

void EndStringTable()
{
	if (StringTable)
		free (StringTable);

}

void AddString (char * StringToAdd, finddata * s)
{
	int len;

	len=strlen(StringToAdd);
	
   	strcpy(StringTable+offset, StringToAdd);
	s->name=StringTable+offset;
	offset+=len+1;
	if (len>12) {
		strcpy(StringTable+offset, StringToAdd);
		StringTable[offset+11]='~';
		StringTable[offset+12]='\0';
		s->ShortName=StringTable+offset;
		offset+=13;
	}
	else
		s->ShortName=s->name;
	
	MaxOffset= (offset > MaxOffset) ? offset : MaxOffset;
	
}

long GetStringTableSize()
{
	return MaxOffset;
}

void ResetStringTable()
{
	offset=0;
}

int
FindFirst(char * ss, unsigned attr, intptr_t * hFile, finddata * s)
{
	int         found;
	SysFindData s2;
	
	*hFile=_findfirst(ss, &s2);
        found = (*hFile != -1);
	if (found) {
		if ( attr == ALL_FILES ) {
			while(found && s2.name[0] == '.')
				found=(_findnext(*hFile, &s2) == 0);
		}
		else if ( attr & _A_SUBDIR )  {
			while(found && (((s2.attrib & _A_SUBDIR) == 0) || s2.name[0] == '.'))
				found=(_findnext(*hFile, &s2) == 0);
		}
		else  {
			while(found && (s2.attrib & _A_SUBDIR))
				found=(_findnext(*hFile, &s2) == 0);
		}
		if (!found)
			_findclose(*hFile);
		else {
			memcpy(s, &s2, sizeof(finddata));
			AddString(s2.name, s);
		}
    }
	return(found);
} /* FindFirst() */






int
FindNext(int attr, intptr_t hFile, finddata * s)
{
	int      found;
	SysFindData s2;

	
	found=(_findnext(hFile, &s2) == 0);
	if (found  &&  attr != ALL_FILES) {
		if ( attr & _A_SUBDIR )	{
			while(found && (((s2.attrib & _A_SUBDIR) == 0) || s2.name[0] == '.'))
				found=(_findnext(hFile, &s2) == 0);
		}
		else {
			while(found && (s2.attrib & _A_SUBDIR))
				found=(_findnext(hFile, &s2) == 0);
		}
    }
	if (!found)
		_findclose(hFile);
	else {
		memcpy(s, &s2, sizeof(finddata));
		AddString(s2.name, s);
	}
	return(found);
} /* FindNext() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\iisvdir\main.cpp ===
#include <stdio.h>
#define INITGUID // must be before iadmw.h
#include <iadmw.h>      // Interface header
//#include <iiscnfg.h>    // MD_ & IIS_MD_ defines
#include <iiscnfgp.h>    // MD_ & IIS_MD_ defines

#define REASONABLE_TIMEOUT 1000

#define MD_ISAPI_RESTRICTION_LIST        (IIS_MD_HTTP_BASE+163)
#define MD_CGI_RESTRICTION_LIST          (IIS_MD_HTTP_BASE+164)
#define MD_RESTRICTION_LIST_CUSTOM_DESC  (IIS_MD_HTTP_BASE+165)

void  ShowHelp(void);
LPSTR StripWhitespace(LPSTR pszString);
BOOL  OpenMetabaseAndDoStuff(WCHAR * wszVDir, WCHAR * wszDir, int iTrans);
BOOL  GetVdirPhysicalPath(IMSAdminBase *pIMSAdminBase,WCHAR * wszVDir,WCHAR *wszStringPathToFill);
BOOL  AddVirtualDir(IMSAdminBase *pIMSAdminBase, WCHAR * wszVDir, WCHAR * wszDir);
BOOL  RemoveVirtualDir(IMSAdminBase *pIMSAdminBase, WCHAR * wszVDir);
HRESULT LoadAllData(IMSAdminBase * pmb, METADATA_HANDLE hMetabase,WCHAR *subdir, BYTE **buf, DWORD *size,DWORD *count);
HRESULT AddVirtualServer(UINT iServerNum, UINT iServerPort, WCHAR * wszDefaultVDirDir);
HRESULT DelVirtualServer(UINT iServerNum);
HRESULT AddRemoveIISRestrictionListEntry(WCHAR * wszFilePath,BOOL bBinaryIsISAPI,BOOL bEnableThisBinary);
HRESULT AddRemoveIISCustomDescriptionEntry(WCHAR * wszFilePathInput,WCHAR * wszDescription,BOOL bCannotBeRemovedByUser, BOOL bAddToList);
BOOL    OpenMetabaseAndDoExport(void);
BOOL    OpenMetabaseAndDoImport(void);
BOOL    OpenMetabaseAndGetVersion(void);
HRESULT RemoteOpenMetabaseAndCallExport(
    const WCHAR *pcszMachineName,
    const WCHAR *pcszUserName,
    const WCHAR *pcszDomain,
    const WCHAR *pcszPassword
    );


inline HRESULT SetBlanket(LPUNKNOWN pIUnk)
{
  return CoSetProxyBlanket( pIUnk,
                            RPC_C_AUTHN_WINNT,    // NTLM authentication service
                            RPC_C_AUTHZ_NONE,     // default authorization service...
                            NULL,                 // no mutual authentication
                            RPC_C_AUTHN_LEVEL_CONNECT,      // authentication level
                            RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
                            NULL,                 // use current token
                            EOAC_NONE );          // no special capabilities
}


#define TRANS_ADD                0
#define TRANS_DEL                1
#define TRANS_PRINT_PATH         2
#define TRANS_ADD_VIRTUAL_SERVER 4
#define TRANS_DEL_VIRTUAL_SERVER 8
#define TRANS_ADD_ISAPI_RESTRICT 16
#define TRANS_DEL_ISAPI_RESTRICT 32
#define TRANS_ADD_CGI_RESTRICT   64
#define TRANS_DEL_CGI_RESTRICT   128
#define TRANS_ADD_CUSTOM_DESCRIPTION 256
#define TRANS_DEL_CUSTOM_DESCRIPTION 512
#define TRANS_EXPORT_CONFIG      1024
#define TRANS_GET_VERSION        2048

int __cdecl main(int argc,char *argv[])
{
    BOOL fRet = FALSE;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    WCHAR wszPrintString[MAX_PATH];
    char szTempString[MAX_PATH];

    int iGotParamC = FALSE;
    int iGotParamI = FALSE;
    int iGotParamS = FALSE;
    int iGotParamL = FALSE;
    int iGotParamM = FALSE;
    int iGotParamN = FALSE;
    int iGotParamP = FALSE;
    int iGotParamV = FALSE;

    int iDoDelete  = FALSE;
    int iDoWebPath = FALSE;
    int iDoExport = FALSE;
    int iDoImport = FALSE;
    int iDoVersion = FALSE;

    int iTrans = 0;

    WCHAR wszDirPath[MAX_PATH];
    WCHAR wszVDirName[MAX_PATH];
    WCHAR wszTempString_C[MAX_PATH];
    WCHAR wszTempString_I[MAX_PATH];
    WCHAR wszTempString_S[MAX_PATH];
    WCHAR wszTempString_L[MAX_PATH];
    WCHAR wszTempString_M[MAX_PATH];
    WCHAR wszTempString_N[MAX_PATH];

    WCHAR wszTempString_P[MAX_PATH];

    wszDirPath[0] = '\0';
    wszVDirName[0] = '\0';
    wszTempString_C[0] = '\0';
    wszTempString_I[0] = '\0';
    wszTempString_S[0] = '\0';
    wszTempString_L[0] = '\0';
    wszTempString_M[0] = '\0';
    wszTempString_N[0] = '\0';
    wszTempString_P[0] = '\0';

    for(argno=1; argno<argc; argno++)
    {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
        {
            switch (argv[argno][1])
            {
                case 'd':
                case 'D':
                    iDoDelete = TRUE;
                    break;
                case 'o':
                case 'O':
                    iDoWebPath = TRUE;
                    break;
                case 'x':
                case 'X':
                    iDoExport = TRUE;
                    break;
                case 'y':
                case 'Y':
                    iDoImport = TRUE;
                    break;
                case 'z':
                case 'Z':
                    iDoVersion = TRUE;
                    break;
                case 'c':
                case 'C':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
                    {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_C, 50);

                        iGotParamC = TRUE;
					}
                    break;
                case 'i':
                case 'I':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
                    {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_I, 50);

                        iGotParamI = TRUE;
					}
                    break;
                case 's':
                case 'S':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
                    {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_S, 50);

                        iGotParamS = TRUE;
					}
                    break;
                case 'm':
                case 'M':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
                    {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_M, _MAX_PATH);

                        iGotParamM = TRUE;
					}
                    break;
                case 'n':
                case 'N':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
                    {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_N, 50);

                        iGotParamN = TRUE;
					}
                    break;
                case 'l':
                case 'L':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
                    {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
                        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_L, 50);

                        iGotParamL = TRUE;
					}
                    break;
                case 'p':
                case 'P':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
                    {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_P, 50);

                        iGotParamP = TRUE;
					}
                    break;
                case 'v':
				case 'V':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
                    {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszVDirName, 50);

                        iGotParamV = TRUE;
					}
					break;
                case '?':
                    goto main_exit_with_help;
                    break;
            } //switch
        } // if
        else
        {
            if ( *wszDirPath == '\0' )
            {
                // if no arguments, then get the filename portion
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPWSTR) wszDirPath, MAX_PATH);
            }
        }
    }

    if (iDoExport)
    {
        OpenMetabaseAndDoExport();

        /*
        RemoteOpenMetabaseAndCallExport(
            L"\\\\remotemachine", // pcszMachineName
            L"administrator", //pcszUserName
            L"domain1", //pcszDomain
            L"thepasword"  //pcszPassword
            );
        */

        goto main_exit_gracefully;
    }

    if (iDoImport)
    {
        OpenMetabaseAndDoImport();
    }

    if (iDoVersion)
    {
        OpenMetabaseAndGetVersion();
    }


    // Check for custom description list being set.
    if (iGotParamN)
    {
        // we need the filename too
        if (*wszDirPath == '\0')
        {
            // sorry, we need parameter
            goto main_exit_with_help;
        }

        if (*wszTempString_N == '\0')
        {
            // sorry, we need parameter
            goto main_exit_with_help;
        }

        iTrans = TRANS_ADD_CUSTOM_DESCRIPTION;
        if (_wcsicmp(wszTempString_N, L"del") == 0)
        {
            iTrans = TRANS_DEL_CUSTOM_DESCRIPTION;
        }
        else if (_wcsicmp(wszTempString_N, L"add") == 0)
        {
            iTrans = TRANS_ADD_CUSTOM_DESCRIPTION;

            if (!iGotParamM)
            {
                // sorry, we need parameter
                goto main_exit_with_help;
            }

            // make sure we've got one of these entries
            if (*wszTempString_M == '\0')
            {
                // sorry, we need parameter
                goto main_exit_with_help;
            }

            if (!iGotParamL)
            {
                // sorry, we need parameter
                goto main_exit_with_help;
            }
            // make sure we've got one of these entries
            if (*wszTempString_L == '\0')
            {
                // sorry, we need parameter
                goto main_exit_with_help;
            }
        }
        else
        {
            goto main_exit_with_help;
        }

        if (TRANS_ADD_CUSTOM_DESCRIPTION == iTrans)
        {
            BOOL bCannotBeRemovedByUser = FALSE;
            if (_wcsicmp(wszTempString_L, L"1") == 0)
            {
                bCannotBeRemovedByUser = TRUE;
            }
            AddRemoveIISCustomDescriptionEntry(wszDirPath,wszTempString_M,bCannotBeRemovedByUser,TRUE);
        }
        else
        {
            AddRemoveIISCustomDescriptionEntry(wszDirPath,NULL,TRUE,FALSE);
        }

        goto main_exit_gracefully;
    }

    // Check for cgi restriction list being set.
    if (iGotParamC)
    {
        // we need the filename too
        if (*wszDirPath == '\0')
        {
            // sorry, we need parameter
            goto main_exit_with_help;
        }

        if (*wszTempString_C == '\0')
        {
            // sorry, we need parameter
            goto main_exit_with_help;
        }

        iTrans = TRANS_ADD_CGI_RESTRICT;
        if (_wcsicmp(wszTempString_C, L"del") == 0)
        {
            iTrans = TRANS_DEL_CGI_RESTRICT;
        }
        else if (_wcsicmp(wszTempString_C, L"add") == 0)
        {
            iTrans = TRANS_ADD_CGI_RESTRICT;
        }
        else
        {
            goto main_exit_with_help;
        }

        if (TRANS_ADD_CGI_RESTRICT == iTrans)
        {
            AddRemoveIISRestrictionListEntry(wszDirPath,FALSE,TRUE);
        }
        else
        {
            AddRemoveIISRestrictionListEntry(wszDirPath,FALSE,FALSE);
        }

        goto main_exit_gracefully;
    }

    // Check for isapi restriction list being set.
    if (iGotParamI)
    {
        // we need the filename too
        if (*wszDirPath == '\0')
        {
            // sorry, we need parameter
            goto main_exit_with_help;
        }

        if (*wszTempString_I == '\0')
        {
            // sorry, we need parameter
            goto main_exit_with_help;
        }

        iTrans = TRANS_ADD_ISAPI_RESTRICT;
        if (_wcsicmp(wszTempString_I, L"del") == 0)
        {
            iTrans = TRANS_DEL_ISAPI_RESTRICT;
        }
        else if (_wcsicmp(wszTempString_I, L"add") == 0)
        {
            iTrans = TRANS_ADD_ISAPI_RESTRICT;
        }
        else
        {
            goto main_exit_with_help;
        }

        if (TRANS_ADD_ISAPI_RESTRICT == iTrans)
        {
            AddRemoveIISRestrictionListEntry(wszDirPath,TRUE,TRUE);
        }
        else
        {
            AddRemoveIISRestrictionListEntry(wszDirPath,TRUE,FALSE);
        }

        goto main_exit_gracefully;
    }

    iTrans = TRANS_ADD_VIRTUAL_SERVER;
    if (TRUE == iGotParamS)
    {
        HRESULT hr;
        UINT iServerNum = 100;

        if (iDoDelete)
        {
            iTrans = TRANS_DEL_VIRTUAL_SERVER;

            if (*wszTempString_S == '\0')
            {
                // sorry, we need something in here
                goto main_exit_with_help;
            }

            iServerNum = _wtoi(wszTempString_S);

            hr = DelVirtualServer(iServerNum);
            if (FAILED(hr))
            {
                wsprintf(wszPrintString,L"FAILED to remove virtual server: W3SVC/%d\n", iServerNum);
                wprintf(wszPrintString);
                fRet = TRUE;
            }
            else
            {
                wsprintf(wszPrintString,L"SUCCESS:removed virtual server: W3SVC/%d\n", iServerNum);
                wprintf(wszPrintString);
                fRet = FALSE;
            }
            goto main_exit_gracefully;
        }
        else
        {
            if (TRUE == iGotParamP)
            {
                UINT iServerPort = 81;

                // we need the filename too
                if (*wszDirPath == '\0')
                {
                    // sorry, we need all 3 parameters
                    goto main_exit_with_help;
                }
                if (*wszTempString_S == '\0')
                {
                    // sorry, we need all 3 parameters
                    goto main_exit_with_help;
                }
                if (*wszTempString_P == '\0')
                {
                    // sorry, we need all 3 parameters
                    goto main_exit_with_help;
                }

                iServerNum = _wtoi(wszTempString_S);
                iServerPort = _wtoi(wszTempString_P);

                hr = AddVirtualServer(iServerNum, iServerPort, wszDirPath);
                if (FAILED(hr))
                {
                    wsprintf(wszPrintString,L"FAILED to create virtual server: W3SVC/%d=%s, port=%d. err=0x%x\n", iServerNum, wszDirPath, iServerPort,hr);
                    wprintf(wszPrintString);
                    fRet = TRUE;
                }
                else
                {
                    wsprintf(wszPrintString,L"SUCCESS:created virtual server: W3SVC/%d=%s, port=%d\n", iServerNum, wszDirPath, iServerPort);
                    wprintf(wszPrintString);
                    fRet = FALSE;
                }
                goto main_exit_gracefully;
            }
        }
    }

    iTrans = TRANS_ADD;
    if (iDoWebPath)
    {
        iTrans = TRANS_PRINT_PATH;
    }
    else
    {
        if (iDoDelete)
        {
            iTrans = TRANS_DEL;
            if (FALSE == iGotParamV)
            {
                // sorry, we need at parameter -v
                goto main_exit_with_help;
            }
        }
        else if (FALSE == iGotParamV || *wszDirPath == '\0')
        {
            // sorry, we need both parameters
            goto main_exit_with_help;
        }
    }

    fRet = OpenMetabaseAndDoStuff(wszVDirName, wszDirPath, iTrans);


main_exit_gracefully:
    exit(fRet);

main_exit_with_help:
    ShowHelp();
    exit(fRet);
}


void
ShowHelp()
{
    wprintf(L"Creates/Removes an IIS virtual directory to default web site\n\n");
    wprintf(L"IISVDIR [FullPath] [-v:VDirName] [-d] [-o] [-c:add or del] [-i:add or del] [-m:description] [-n:add or del] [-l:1 or 0] [-x]\n\n");
    wprintf(L"Instructions for add\\delete virtual directory:\n");
    wprintf(L"   FullPath     DOS path where vdir will point to (required for add)\n");
    wprintf(L"   -v:vdirname  The virtual dir name (required for both add\\delete)\n");
    wprintf(L"   -d           If set will delete vdir. if not set will add\n");
    wprintf(L"   -o           If set will printout web root path\n\n");
    wprintf(L"Instructions for add\\delete virtual server:\n");
    wprintf(L"   FullPath     DOS path where default vdir will point to in the virtual server (required for add)\n");
    wprintf(L"   -s:sitenum   For adding virtual server: The virtual server site number (required for both add\\delete)\n");
    wprintf(L"   -p:portnum   For adding virtual server: The virtual server port number (required for add)\n");
    wprintf(L"   -d           If set will delete virtual server. if not set will add\n");
    wprintf(L"Instructions for add\\delete entry from isapi/cgi restriction list:\n");
    wprintf(L"   FullPath     Full and filename path to binary which will be either add or deleted from isapi/cgi restrict list\n");
    wprintf(L"   -c:add       Ensures that the Fullpath will be enabled in the CGI restriction list\n");
    wprintf(L"   -c:del       Ensures that the Fullpath will be disabled in the CGI restriction list\n");
    wprintf(L"   -i:add       Ensures that the Fullpath will be enabled in the ISAPI restriction list\n");
    wprintf(L"   -i:del       Ensures that the Fullpath will be disabled in the ISAPI restriction list\n");
    wprintf(L"Instructions for add\\delete entry from custom description list (for isapi/cgi restriction list):\n");
    wprintf(L"   FullPath       Full and filename path to binary which will be either add or deleted from custom description list\n");
    wprintf(L"   -m:Description Friendly description of FullPath\n");
    wprintf(L"   -n:add         Ensures that the Fullpath will be in the custom description list with the specified desciption\n");
    wprintf(L"   -n:del         Ensures that the Fullpath will not be in the custom description list\n");
    wprintf(L"   -l:1 or 0      Specifies weather this entry can be removed by the user\n");
    wprintf(L"Instructions for exporting metabase config to a file:\n");
    wprintf(L"   -x:          Ensures export will happen\n");
    wprintf(L"\n");
    wprintf(L"Add Example: IISVDIR c:\\MyGroup\\MyStuff -v:Stuff\n");
    wprintf(L"Del Example: IISVDIR -v:Stuff -d\n");
    wprintf(L"Get Example: IISVDIR -o\n");
    wprintf(L"Add Virtual Server Example: IISVDIR c:\\MyGroup\\MyStuff -s:200 -p:81\n");
    wprintf(L"Del Virtual Server Example: IISVDIR -s:200 -d\n");
    wprintf(L"Add ISAPI restriction list Example: IISVDIR c:\\MyGroup\\MyStuff\\myisapi.dll -i:add\n");
    wprintf(L"Del ISAPI restriction list Example: IISVDIR c:\\MyGroup\\MyStuff\\myisapi.dll -i:del\n");
    wprintf(L"Add CGI restriction list Example: IISVDIR c:\\MyGroup\\MyStuff\\myCgi.exe -c:add\n");
    wprintf(L"Del CGI restriction list Example: IISVDIR c:\\MyGroup\\MyStuff\\myCgi.exe -c:del\n");
    wprintf(L"Add Custom Description list Example: IISVDIR c:\\MyGroup\\MyStuff\\myisapi.dll -m:MyDescription -n:add -l:0\n");
    wprintf(L"Del Custom Description list Example: IISVDIR c:\\MyGroup\\MyStuff\\myisapi.dll -n:del\n");
    wprintf(L"Export Example: IISVDIR -x\n");
    return;
}


LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL )
    {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' )
    {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' )
    {
        return pszString;
    }

    pszTemp = pszString;
    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' )
    {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}


// Calculate the size of a Multi-String in WCHAR, including the ending 2 '\0's.
int GetMultiStrSize(LPWSTR p)
{
    int c = 0;

    while (1)
    {
        if (*p)
        {
            p++;
            c++;
        }
        else
        {
            c++;
            if (*(p+1))
            {
                p++;
            }
            else
            {
                c++;
                break;
            }
        }
    }
    return c;
}


// This walks the multi-sz and returns a pointer between
// the last string of a multi-sz and the second terminating NULL
LPCWSTR GetEndOfMultiSz(LPCWSTR szMultiSz)
{
	LPCWSTR lpTemp = szMultiSz;

	do
	{
		lpTemp += wcslen(lpTemp);
		lpTemp++;

	} while (*lpTemp != L'\0');

	return(lpTemp);
}


void DumpWstrInMultiStr(LPWSTR pMultiStr)
{
    LPWSTR pTempMultiStr = pMultiStr;

    while (1)
    {
        if (pTempMultiStr)
        {
            // display value
            wprintf(L"    %s\r\n",pTempMultiStr);

            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
            }
        }
    }
    return;
}


BOOL OpenMetabaseAndDoStuff(WCHAR * wszVDir,WCHAR * wszDir,int iTrans)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    WCHAR wszPrintString[MAX_PATH + MAX_PATH];

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMSAdminBase)))
    {
        return FALSE;
    }

    switch (iTrans)
    {
        case TRANS_DEL:
            if( RemoveVirtualDir( pIMSAdminBase, wszVDir))
            {
                hr = pIMSAdminBase->SaveData();
                if( SUCCEEDED( hr ))
                {
                     fRet = TRUE;
                }
            }
            if (TRUE == fRet)
            {
                wsprintf(wszPrintString,L"SUCCESS:removed vdir=%s\n", wszVDir);
                wprintf(wszPrintString);
            }
            else
            {
                wsprintf(wszPrintString,L"FAILED to remove vdir=%s, err=0x%x\n", wszVDir, hr);
                wprintf(wszPrintString);
            }
            break;

        case TRANS_ADD:
            if( AddVirtualDir( pIMSAdminBase, wszVDir, wszDir))
            {
                hr = pIMSAdminBase->SaveData();
                if( SUCCEEDED( hr ))
                {
                    fRet = TRUE;
                }
            }

            if (TRUE == fRet)
            {
                wsprintf(wszPrintString,L"SUCCESS: %s=%s", wszVDir, wszDir);
                wprintf(wszPrintString);
            }
            else
            {
                wsprintf(wszPrintString,L"FAILED to set: %s=%s, err=0x%x", wszVDir, wszDir, hr);
                wprintf(wszPrintString);
            }
            break;

        default:
            WCHAR wszRootPath[MAX_PATH];
            if (TRUE == GetVdirPhysicalPath(pIMSAdminBase,wszVDir,(WCHAR *) wszRootPath))
            {
                fRet = TRUE;
                if (_wcsicmp(wszVDir, L"") == 0)
                {
                    wsprintf(wszPrintString,L"/=%s", wszRootPath);
                }
                else
                {
                    wsprintf(wszPrintString,L"%s=%s", wszVDir, wszRootPath);
                }
                wprintf(wszPrintString);
            }
            else
            {
                wprintf(L"FAILED to get root path");
            }
            break;
    }

    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return fRet;
}


BOOL GetVdirPhysicalPath(IMSAdminBase *pIMSAdminBase,WCHAR * wszVDir,WCHAR *wszStringPathToFill)
{
    HRESULT hr;
    BOOL fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;   // handle to metabase
    METADATA_RECORD mr;
    WCHAR  szTmpData[MAX_PATH];
    DWORD  dwMDRequiredDataLen;

    // open key to ROOT on website #1 (default)
    hr = pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3SVC/1",
                         METADATA_PERMISSION_READ,
                         REASONABLE_TIMEOUT,
                         &hMetabase);
    if( FAILED( hr ))
    {
        return FALSE;
    }

    // Get the physical path for the WWWROOT
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szTmpData );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szTmpData);

    // if nothing specified get the root.
    if (_wcsicmp(wszVDir, L"") == 0)
    {
        WCHAR wszTempDir[MAX_PATH];
        wsprintf(wszTempDir,L"/ROOT/%s", wszVDir);
        hr = pIMSAdminBase->GetData( hMetabase, wszTempDir, &mr, &dwMDRequiredDataLen );
    }
    else
    {
        hr = pIMSAdminBase->GetData( hMetabase, L"/ROOT", &mr, &dwMDRequiredDataLen );
    }
    pIMSAdminBase->CloseKey( hMetabase );

    if( SUCCEEDED( hr ))
    {
        wcscpy(wszStringPathToFill,szTmpData);
        fRet = TRUE;
    }

    pIMSAdminBase->CloseKey( hMetabase );
    return fRet;
}


BOOL AddVirtualDir(IMSAdminBase *pIMSAdminBase,WCHAR * wszVDir,WCHAR * wszDir)
{
    HRESULT hr;
    BOOL    fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    WCHAR   wszTempPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen = 0;
    DWORD   dwAccessPerm = 0;
    METADATA_RECORD mr;

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3SVC/1/ROOT",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    // Create the key if it does not exist.
    if( FAILED( hr ))
    {
        return FALSE;
    }

    fRet = TRUE;

    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( wszTempPath );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszTempPath);

    // see if MD_VR_PATH exists.
    hr = pIMSAdminBase->GetData( hMetabase, wszVDir, &mr, &dwMDRequiredDataLen );

    if( FAILED( hr ))
    {
        fRet = FALSE;
        if( hr == MD_ERROR_DATA_NOT_FOUND ||
            HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND )
        {
            // Write both the key and the values if GetData() failed with any of the two errors.
            pIMSAdminBase->AddKey( hMetabase, wszVDir );

            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = METADATA_INHERIT;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = (wcslen(wszDir) + 1) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(wszDir);

            // Write MD_VR_PATH value
            hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
            fRet = SUCCEEDED( hr );

            // Set the default authentication method
            if( fRet )
            {
                DWORD dwAuthorization = MD_AUTH_NT;     // NTLM only.

                mr.dwMDIdentifier = MD_AUTHORIZATION;
                mr.dwMDAttributes = METADATA_INHERIT;   // need to inherit so that all subdirs are also protected.
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = DWORD_METADATA;
                mr.dwMDDataLen    = sizeof(DWORD);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAuthorization);

                // Write MD_AUTHORIZATION value
                hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
                fRet = SUCCEEDED( hr );
            }
        }
    }

    // In the following, do the stuff that we always want to do to the virtual dir, regardless of Admin's setting.

    if( fRet )
    {
        dwAccessPerm = MD_ACCESS_READ | MD_ACCESS_SCRIPT;

        mr.dwMDIdentifier = MD_ACCESS_PERM;
        mr.dwMDAttributes = METADATA_INHERIT;    // Make it inheritable so all subdirectories will have the same rights.
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = DWORD_METADATA;
        mr.dwMDDataLen    = sizeof(DWORD);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);

        // Write MD_ACCESS_PERM value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }

    if( fRet )
    {
        PWCHAR  szDefLoadFile = L"Default.htm,Default.asp";

        mr.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szDefLoadFile) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szDefLoadFile);

        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }

    if( fRet )
    {
        PWCHAR  wszKeyType = IIS_CLASS_WEB_VDIR_W;

        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_SERVER;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(wszKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(wszKeyType);

        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }

    pIMSAdminBase->CloseKey( hMetabase );

    return fRet;
}


BOOL RemoveVirtualDir(IMSAdminBase *pIMSAdminBase,WCHAR * wszVDir)
{
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    HRESULT hr;

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3SVC/1/ROOT",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    if( FAILED( hr ))
    {
        return FALSE;
    }

    // We don't check the return value since the key may already
    // not exist and we could get an error for that reason.
    pIMSAdminBase->DeleteKey( hMetabase, wszVDir );

    pIMSAdminBase->CloseKey( hMetabase );

    return TRUE;
}


HRESULT LoadAllData(IMSAdminBase * pmb,
                       METADATA_HANDLE hMetabase,
					   WCHAR *subdir,
					   BYTE **buf,
					   DWORD *size,
					   DWORD *count) {
	DWORD dataSet;
	DWORD neededSize;
	HRESULT hr;
	//
	// Try to get the property names.
	//
	hr = pmb->GetAllData(hMetabase,
					subdir,
					METADATA_NO_ATTRIBUTES,
					ALL_METADATA,
					ALL_METADATA,
					count,
					&dataSet,
					*size,
					*buf,
					&neededSize);
	if (!SUCCEEDED(hr))
    {
        DWORD code = ERROR_INSUFFICIENT_BUFFER;

        if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
        {
            delete *buf;
            *buf = 0;
            *size = neededSize;
            *buf = new BYTE[neededSize];

            hr = pmb->GetAllData(hMetabase,
							subdir,
							METADATA_NO_ATTRIBUTES,
							ALL_METADATA,
							ALL_METADATA,
							count,
							&dataSet,
	 						*size,
							*buf,
							&neededSize);

		}
	}
	return hr;
}

const DWORD getAllBufSize = 4096*2;
HRESULT OpenMetabaseAndGetAllData(void)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    WCHAR wszPrintString[MAX_PATH + MAX_PATH];
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    DWORD bufSize = getAllBufSize;
    BYTE *buf = new BYTE[bufSize];
    DWORD count=0;
    DWORD linesize =0;

    BYTE *pBuf1=NULL;
    BYTE *pBuf2=NULL;

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMSAdminBase)))
    {
        wprintf(L"CoCreateInstance. FAILED. code=0x%x\n",hr);
        return hr;
    }

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         L"/Schema/Properties",
                         METADATA_PERMISSION_READ,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    if( FAILED( hr ))
    {
        wprintf(L"pIMSAdminBase->OpenKey. FAILED. code=0x%x\n",hr);
       goto OpenMetabaseAndGetAllData_Exit;
    }
	hr = LoadAllData(pIMSAdminBase, hMetabase, L"Names", &buf, &bufSize, &count);
    if( FAILED( hr ))
    {
        wprintf(L"LoadAllData: FAILED. code=0x%x\n",hr);
       goto OpenMetabaseAndGetAllData_Exit;
    }

    wprintf(L"LoadAllData: Succeeded. bufSize=0x%x, count=0x%x, buf=%p, end of buf=%p\n",bufSize,count,buf,buf+bufSize);
    wprintf(L"Here is the last 1000 bytes, that the client received.\n");

    linesize = 0;
    pBuf1 = buf+bufSize - 1000;
    for (int i=0;pBuf1<buf+bufSize;pBuf1++,i++)
    {
        if (NULL == *pBuf1)
        {
            wprintf(L".");
        }
        else
        {
            wprintf(L"%c",*pBuf1);
        }
        linesize++;

        if (linesize >= 16)
        {
            linesize=0;
            wprintf(L"\n");
        }
    }

    wprintf(L"\n");

    hr = S_OK;

OpenMetabaseAndGetAllData_Exit:
    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return hr;
}


HRESULT DelVirtualServer(UINT iServerNum)
{
    HRESULT hr = E_FAIL;
    return hr;
}


// iServerNum       the virtual server number
// iServerPort      the virtual server port (port 80 is the default site's port,so you can't use this and you can't use one that is already in use)
// wszDir           the physical directory where the default site is located
HRESULT AddVirtualServer(UINT iServerNum, UINT iServerPort, WCHAR * wszDefaultVDirDir)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    METADATA_RECORD mr;

    WCHAR wszMetabasePath[_MAX_PATH];
    WCHAR wszMetabasePathRoot[10];
    WCHAR wszData[_MAX_PATH];
    DWORD dwData = 0;

    METADATA_HANDLE hKeyBase = METADATA_MASTER_ROOT_HANDLE;

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMSAdminBase)))
    {
        wprintf(L"CoCreateInstance. FAILED. code=0x%x\n",hr);
        return hr;
    }

    // Create the new node
    wsprintf(wszMetabasePath,L"LM/W3SVC/%i",iServerNum);

    // try to open the specified metabase node, it might already exist
    hr = pIMSAdminBase->OpenKey(hKeyBase,
                         wszMetabasePath,
                         METADATA_PERMISSION_READ,
                         REASONABLE_TIMEOUT,
                         &hMetabase);
    if (hr == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))
    {
        hr = pIMSAdminBase->CloseKey(hMetabase);

        // open the metabase root handle
        hr = pIMSAdminBase->OpenKey(hKeyBase,
                            L"",
                            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                            REASONABLE_TIMEOUT,&hMetabase);
        if( FAILED( hr ))
        {
            // if we can't even open the root handle, then we're pretty hosed
            wprintf(L"1OpenKey. FAILED. code=0x%x\n",hr);
            goto AddVirtualServer_Exit;
        }

        // and add our node
        hr = pIMSAdminBase->AddKey(hMetabase, wszMetabasePath);
        if (FAILED(hr))
        {
            wprintf(L"AddKey. FAILED. code=0x%x\n",hr);
            pIMSAdminBase->CloseKey(hMetabase);
            goto AddVirtualServer_Exit;
        }
        else
        {
            hr = pIMSAdminBase->CloseKey(hMetabase);
            if (FAILED(hr))
            {
                goto AddVirtualServer_Exit;
            }
            else
            {
                // open it again
                hr = pIMSAdminBase->OpenKey(hKeyBase,
                    wszMetabasePath,
                    METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                    REASONABLE_TIMEOUT,
                    &hMetabase);
                if (FAILED(hr))
                {
                    wprintf(L"2OpenKey. FAILED. code=0x%x\n",hr);
                    pIMSAdminBase->CloseKey(hMetabase);
                    goto AddVirtualServer_Exit;
                }
            }
        }
    }
    else
    {
        if (FAILED(hr))
        {
            wprintf(L"3OpenKey. FAILED. code=0x%x\n",hr);
            goto AddVirtualServer_Exit;
        }
        else
        {
            // we were able to open the path, so it must already exist!
            hr = ERROR_ALREADY_EXISTS;
            pIMSAdminBase->CloseKey(hMetabase);
            goto AddVirtualServer_Exit;
        }
    }


    // We should have a brand new Key now...

    //
    // Create stuff in the node of this path!
    //

    //
    // /LM/W3SVC/1/KeyType
    //
    memset( (PVOID)wszData, 0, sizeof(wszData));
    wcscpy(wszData,IIS_CLASS_WEB_SERVER_W);

    mr.dwMDIdentifier = MD_KEY_TYPE;
    mr.dwMDAttributes = 0;   // no need for inheritence
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = (wcslen(wszData) + 1) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszData);
    hr = pIMSAdminBase->SetData( hMetabase, L"", &mr );
    if (FAILED(hr))
    {
        wprintf(L"SetData[MD_KEY_TYPE]. FAILED. code=0x%x\n",hr);
    }

    //
    // /W3SVC/1/ServerBindings
    //
    memset( (PVOID)wszData, 0, sizeof(wszData));
    wsprintf(wszData, L":%d:", iServerPort);

    mr.dwMDIdentifier = MD_SERVER_BINDINGS;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiStrSize(wszData) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszData);

    hr = pIMSAdminBase->SetData( hMetabase, L"", &mr );
    if (FAILED(hr))
    {
        wprintf(L"SetData[MD_SERVER_BINDINGS]. FAILED. code=0x%x\n",hr);
    }

    //
    // /W3SVC/1/SecureBindings
    //
    memset( (PVOID)wszData, 0, sizeof(wszData));
    wcscpy(wszData, L" ");

    mr.dwMDIdentifier = MD_SECURE_BINDINGS;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiStrSize(wszData) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszData);

    hr = pIMSAdminBase->SetData( hMetabase, L"", &mr );
    if (FAILED(hr))
    {
        wprintf(L"SetData[MD_SECURE_BINDINGS]. FAILED. code=0x%x\n",hr);
    }

    //
    // Create stuff in the /Root node of this path!
    //
    wcscpy(wszMetabasePathRoot, L"/Root");
    wcscpy(wszData,IIS_CLASS_WEB_VDIR_W);

    // W3SVC/3/Root/KeyType
    mr.dwMDIdentifier = MD_KEY_TYPE;
    mr.dwMDAttributes = 0;   // no need for inheritence
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = (wcslen(wszData) + 1) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr))
    {
        wprintf(L"SetData[MD_KEY_TYPE]. FAILED. code=0x%x\n",hr);
    }

    // W3SVC/3/Root/VrPath
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = (wcslen(wszDefaultVDirDir) + 1) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszDefaultVDirDir);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr))
    {
        wprintf(L"SetData[MD_VR_PATH]. FAILED. code=0x%x\n",hr);
    }

    // W3SVC/3/Root/Authorizaton
    dwData = MD_AUTH_ANONYMOUS | MD_AUTH_NT;
    mr.dwMDIdentifier = MD_AUTHORIZATION;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(DWORD);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr))
    {
        wprintf(L"SetData[MD_AUTHORIZATION]. FAILED. code=0x%x\n",hr);
    }

    // W3SVC/3/Root/AccessPerm
    dwData = MD_ACCESS_SCRIPT | MD_ACCESS_READ;
    mr.dwMDIdentifier = MD_ACCESS_PERM;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(DWORD);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr))
    {
        wprintf(L"SetData[MD_ACCESS_PERM]. FAILED. code=0x%x\n",hr);
    }

    // W3SVC/3/Root/DirectoryBrowsing
    dwData = MD_DIRBROW_SHOW_DATE
        | MD_DIRBROW_SHOW_TIME
        | MD_DIRBROW_SHOW_SIZE
        | MD_DIRBROW_SHOW_EXTENSION
        | MD_DIRBROW_LONG_DATE
        | MD_DIRBROW_LOADDEFAULT;
        // | MD_DIRBROW_ENABLED;

    mr.dwMDIdentifier = MD_DIRECTORY_BROWSING;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(DWORD);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr))
    {
        wprintf(L"SetData[MD_DIRECTORY_BROWSING]. FAILED. code=0x%x\n",hr);
    }

    /*
    dwData = 0;
    mr.dwMDIdentifier = MD_SERVER_AUTOSTART;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(DWORD);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_SERVER_AUTOSTART]. FAILED. code=0x%x\n",hr);
    }
    */

    pIMSAdminBase->CloseKey(hMetabase);

AddVirtualServer_Exit:
    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return hr;
}


// returns 0 if not found
// returns 1 if StrToFind is found but StrToFind2 is not found
// returns 2 if StrToFind is found and StrToFind2 is found
INT FindWstrInMultiStrSpecial(LPWSTR pMultiStr, LPWSTR StrToFind, LPWSTR StrToFind2)
{
    INT iReturn = 0;
    LPWSTR pTempMultiStr = pMultiStr;
    DWORD dwCharCount = 0;

    while (1)
    {
        if (pTempMultiStr)
        {
            // The 1st entry should be
            // the type.  so it will be either 1 or a number.

            // so let's skip till the next null.
            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // compare this value to the imput value
            if (0 == _wcsicmp((const wchar_t *) pTempMultiStr,StrToFind))
            {
                iReturn = 1;
            }

            // so let's skip till the next null.
            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // check for an exact match.
            if (0 != iReturn)
            {
                // compare this value to the imput value
                if (StrToFind2 != NULL)
                {
                    if (0 == _wcsicmp((const wchar_t *) pTempMultiStr,StrToFind2))
                    {
                        iReturn = 2;
                        break;
                    }
                }
                break;
            }

            // so let's skip till the next null.
            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // Check if we screwed up somehow and are in an infinite loop.
            // could happen if we don't find an ending \0\0
            if (dwCharCount > 32000)
            {
                break;
            }
        }
    }

    return iReturn;
}


BOOL FindWstrInMultiStr(LPWSTR pMultiStr, LPWSTR StrToFind)
{
    BOOL bFound = FALSE;
    LPWSTR pTempMultiStr = pMultiStr;
    DWORD dwCharCount = 0;

    while (1)
    {
        if (pTempMultiStr)
        {
            // compare this value to the imput value
            if (0 == _wcsicmp((const wchar_t *) pTempMultiStr,StrToFind))
            {
                bFound = TRUE;
                break;
            }

            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // Check if we screwed up somehow and are in an infinite loop.
            // could happen if we don't find an ending \0\0
            if (dwCharCount > 32000)
            {
                break;
            }
        }
    }
    return bFound;
}


BOOL RemoveWstrInMultiStr(LPWSTR pMultiStr, LPWSTR StrToFind)
{
    BOOL bFound = FALSE;
    LPWSTR pTempMultiStr = pMultiStr;
    DWORD dwCharCount = 0;

    while (1)
    {
        if (pTempMultiStr)
        {
            // compare this value to the imput value
            if (0 == _wcsicmp((const wchar_t *) pTempMultiStr,StrToFind))
            {
                LPWSTR pLastDoubleNull = NULL;
                LPWSTR pBeginPath = pTempMultiStr;
                bFound = TRUE;

                // then increment until we hit another null.
                while (*pTempMultiStr)
                {
                    pTempMultiStr++;
                }
                pTempMultiStr++;

                // Find the last double null.
                pLastDoubleNull = pTempMultiStr;
                if (*pLastDoubleNull)
                {
                    while (1)
                    {
                        if (NULL == *pLastDoubleNull && NULL == *(pLastDoubleNull+1))
                        {
                            break;
                        }
                        pLastDoubleNull++;
                    }
                    pLastDoubleNull++;
                }

                // check if we are the last entry.
                if (pLastDoubleNull == pTempMultiStr)
                {
                    // set everything to nulls
                    memset(pBeginPath,0,(pLastDoubleNull-pBeginPath) * sizeof(WCHAR));
                }
                else
                {
                    // move everything behind it to where we are.
                    memmove(pBeginPath,pTempMultiStr, (pLastDoubleNull - pTempMultiStr) * sizeof(WCHAR));
                    // and set everything behind that to nulls
                    memset(pBeginPath + (pLastDoubleNull - pTempMultiStr),0,(pTempMultiStr-pBeginPath) * sizeof(WCHAR));
                }
                break;
            }

            // then increment until we hit another null.
            while (*pTempMultiStr)
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // check for the ending \0\0
            if ( *(pTempMultiStr+1) == NULL)
            {
                break;
            }
            else
            {
                pTempMultiStr++;
                dwCharCount++;
            }

            // Check if we screwed up somehow and are in an infinite loop.
            // could happen if we don't find an ending \0\0
            if (dwCharCount > 32000)
            {
                break;
            }
        }
    }
    return bFound;
}


BOOL IsAllowAllByDefault(LPWSTR pMultiStr)
{
    BOOL bFound = FALSE;
    if (pMultiStr)
    {
        if (0 == _wcsicmp((const wchar_t *) pMultiStr,L"1"))
        {
            bFound = TRUE;
        }
    }
    return bFound;
}


// returns TRUE if we need to write to metabase
//   returns bAddToList = true if we need to add to the list
//   returns bAddToList = false if we need to remove from the list
// returns FALSE if we don't need to write to metabase
//
BOOL IsAddRemoveOrDoNothing(LPWSTR pMultiStr,LPWSTR wszFilePath,BOOL bEnableThisBinary,BOOL * bAddToList)
{
    BOOL bReturn = FALSE;
    BOOL bAllowAllByDefault = FALSE;
    BOOL bFound = FALSE;

    if (!bAddToList || !pMultiStr || !wszFilePath)
    {
        return FALSE;
    }

    // set flag to see if we are in deny all by default
    // or if we are in enable all by default..
    if (TRUE == IsAllowAllByDefault((WCHAR *) pMultiStr))
    {
        bAllowAllByDefault = TRUE;
    }

    // Loop thru the data to see if we are already present...
    //
    // data looks like this:
    //   0 or 1\0
    //   fileentry1\0
    //   filenetry2\0
    //   last fileentry\0\0
    //
    bFound = FindWstrInMultiStr((WCHAR *) pMultiStr,wszFilePath);

    // Make some decisions
    if (bEnableThisBinary)
    {
        if (bFound)
        {
            if (bAllowAllByDefault)
            {
                // trying to enable
                // the list is allow by default
                // it's in the list, so that means it's currently not enabled..
                // We need to remove it from the list!
                *bAddToList = FALSE;
                bReturn = TRUE;
                goto IsAddRemoveOrDoNothing_Exit;
            }
            else
            {
                // trying to enable
                // the list is deny by default
                // it's in the list. so that means it's currently already enabled!
                // do nothing! get out, things are groovy.
                bReturn = FALSE;
                goto IsAddRemoveOrDoNothing_Exit;
            }
        }
        else
        {
            if (bAllowAllByDefault)
            {
                // trying to enable
                // the list is allow by default
                // it's not in the list
                // so that means it's currently already enabled!
                // do nothing! get out.  things are groovy.
                bReturn = FALSE;
                goto IsAddRemoveOrDoNothing_Exit;
            }
            else
            {
                // trying to enable
                // the list is deny by default
                // it's not in the list
                // so that means we need to add it to the list
                *bAddToList = TRUE;
                bReturn = TRUE;
                goto IsAddRemoveOrDoNothing_Exit;
            }
        }
    }
    else
    {
        if (bFound)
        {
            if (bAllowAllByDefault)
            {
                // trying to disable
                // the list is allow by default
                // it's in the list, so that means it's currently disabled already
                // do nothing! get out.  things are groovy.
                bReturn = FALSE;
                goto IsAddRemoveOrDoNothing_Exit;
            }
            else
            {
                // trying to disable
                // the list is deny by default
                // it's in the list. so that means currently it is enabled, so
                // we want to make sure to remove it from the list
                // so that it will be denied.
                *bAddToList = FALSE;
                bReturn = TRUE;
                goto IsAddRemoveOrDoNothing_Exit;
            }
        }
        else
        {
            if (bAllowAllByDefault)
            {
                // trying to disable
                // the list is allow by default
                // it's not in the list
                // so that means it's currently being allowed
                // we need to add it to the list so that it will be denied
                *bAddToList = TRUE;
                bReturn = TRUE;
                goto IsAddRemoveOrDoNothing_Exit;
            }
            else
            {
                // trying to disable
                // the list is deny by default
                // it's in the list, so that means it's currently disabled already
                // do nothing! get out.  things are groovy.
                bReturn = FALSE;
                goto IsAddRemoveOrDoNothing_Exit;
            }
        }
    }

IsAddRemoveOrDoNothing_Exit:
    return bReturn;
}


// wszFilePath = is the fully qualified path to the binary which will be enabled or disabled
// bBinaryIsISAPI = is the flag which determines which metabase setting to set
//                  when set to TRUE it will perform action on the ISAPI restriction list
//                  when set to FALSE it will perform action on the CGI restriction list
// bEnableThisBinary = is the flag which determines weather the binary should be allowed to run or not.
//                  when set to TRUE it will ensure that the specified binary will be allowed to run
//                  when set to FALSE it will ensure that the specified binary will not be allowed to run
//                  will figure out what is the right thing to do from what current metabase settings is
HRESULT AddRemoveIISRestrictionListEntry(WCHAR * wszFilePathInput,BOOL bBinaryIsISAPI,BOOL bEnableThisBinary)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    METADATA_HANDLE hMetabase = NULL;    // handle to metabase
    METADATA_RECORD mr;
    BYTE  * pbDataOld = NULL;
    BYTE  * pbDataNew = NULL;
    DWORD dwMDRequiredDataLen = 0;
    DWORD dwNewEntryLength = 0;
    DWORD dwNewTotalLength = 0;
    DWORD dwOldByteLength = 0;
    BOOL bAddToList = FALSE;
    WCHAR * wszFilePath = NULL;

    // Convert any env vars to hard coded paths
    LPWSTR pch = wcschr( (LPWSTR) wszFilePathInput, L'%');
    if (pch)
    {
       // determine the length of the expanded string
       DWORD len = ::ExpandEnvironmentStrings(wszFilePathInput, 0, 0);
       if (!len)
       {
          return hr;
       }

       wszFilePath = (WCHAR *) GlobalAlloc(GPTR, (len + 1) * sizeof(WCHAR));
       DWORD len1 = ExpandEnvironmentStrings((LPWSTR) wszFilePathInput,const_cast<wchar_t*>(wszFilePath),len);
       if (len1 != len)
       {
           if (wszFilePath)
           {
               GlobalFree(wszFilePath);wszFilePath = NULL;
           }
           return hr;
       }
    }
    else
    {
        wszFilePath = wszFilePathInput;
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (hr == RPC_E_CHANGED_MODE)
    {
        // fine.  try again
        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    hr = CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **)&pIMSAdminBase);
    if (FAILED(hr))
    {
        goto AddRemoveIISRestrictionListEntry_Exit;
    }

    // open the specified metabase node
    hr = pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"LM/W3SVC",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase);
    if (FAILED(hr))
    {
        hMetabase = NULL;
        goto AddRemoveIISRestrictionListEntry_Exit;
    }

    if (bBinaryIsISAPI)
    {
        mr.dwMDIdentifier = MD_ISAPI_RESTRICTION_LIST;
    }
    else
    {
        mr.dwMDIdentifier = MD_CGI_RESTRICTION_LIST;
    }
    mr.dwMDAttributes = 0;   // no need for inheritence
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = 0;
    mr.pbMDData       = reinterpret_cast<unsigned char *>(pbDataOld);

    // first we need to figure out how much space we need
    hr = pIMSAdminBase->GetData(hMetabase, L"", &mr, &dwMDRequiredDataLen);
    if(FAILED(hr))
    {
        // if there isn't a value there that we need to update
        // then create one
        if( hr == MD_ERROR_DATA_NOT_FOUND || HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND )
        {
            WCHAR wszDefaultData[4];

            // set to "allow all by default"
            memset( (PVOID)wszDefaultData, 0, sizeof(wszDefaultData));
            wcscpy(wszDefaultData, L"1");

            if (bBinaryIsISAPI)
            {
                mr.dwMDIdentifier = MD_ISAPI_RESTRICTION_LIST;
            }
            else
            {
                mr.dwMDIdentifier = MD_CGI_RESTRICTION_LIST;
            }
            mr.dwMDAttributes = 0;   // no need for inheritence
            mr.dwMDUserType   = IIS_MD_UT_SERVER;
            mr.dwMDDataType   = MULTISZ_METADATA;
            mr.dwMDDataLen    = GetMultiStrSize(wszDefaultData) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(wszDefaultData);

            // Write value
            hr = pIMSAdminBase->SetData(hMetabase, L"", &mr);

            // find out how much space we need.
            mr.dwMDDataLen    = 0;
            mr.pbMDData       = reinterpret_cast<unsigned char *>(pbDataOld);

            hr = pIMSAdminBase->GetData(hMetabase, L"", &mr, &dwMDRequiredDataLen);
            if(FAILED(hr))
            {
                goto AddRemoveIISRestrictionListEntry_Exit;
            }
        }
        else
        {
            goto AddRemoveIISRestrictionListEntry_Exit;
        }
    }

    pbDataOld = (BYTE *) GlobalAlloc(GPTR, dwMDRequiredDataLen);
    if (!pbDataOld)
    {
        hr = E_OUTOFMEMORY;
        goto AddRemoveIISRestrictionListEntry_Exit;
    }

    // do the real call to get the data from the metabase
    mr.dwMDDataLen    = dwMDRequiredDataLen;
    mr.pbMDData       = reinterpret_cast<unsigned char *>(pbDataOld);
    hr = pIMSAdminBase->GetData(hMetabase, L"", &mr, &dwMDRequiredDataLen);
    if (FAILED(hr))
    {
        goto AddRemoveIISRestrictionListEntry_Exit;
    }

    if (FALSE == IsAddRemoveOrDoNothing((WCHAR *) pbDataOld, wszFilePath, bEnableThisBinary, &bAddToList))
    {
        hr = S_OK;
        goto AddRemoveIISRestrictionListEntry_Exit;
    }

    if (bAddToList)
    {
        // Recalc the amount of space we'll need to add this entry into the list
        dwOldByteLength = GetMultiStrSize( (WCHAR*) pbDataOld) * sizeof(WCHAR);
        dwNewEntryLength = wcslen(wszFilePath) * sizeof(WCHAR);
        dwNewTotalLength = dwOldByteLength + dwNewEntryLength + 2;

        // Alloc enough space for the old data and the new data.
        // Don't use realloc here, because for somereason it would fail in
        // certain test runs.
        pbDataNew = (BYTE *) GlobalAlloc(GPTR, dwNewTotalLength);
        if (!pbDataNew)
        {
            hr = E_OUTOFMEMORY;
            goto AddRemoveIISRestrictionListEntry_Exit;
        }

        // copy the old data...
        memcpy(pbDataNew,pbDataOld,dwOldByteLength);
        // append on the new data
        memcpy((pbDataNew + dwOldByteLength) - 2,wszFilePath,dwNewEntryLength);
        memset((pbDataNew + dwOldByteLength + dwNewEntryLength) - 2,0,4);

        // free the old data
        if (pbDataOld)
        {
            GlobalFree(pbDataOld);
            pbDataOld = NULL;
        }
    }
    else
    {
        dwOldByteLength = GetMultiStrSize( (WCHAR*) pbDataOld) * sizeof(WCHAR);

        // Don't use realloc here, because for somereason it would fail in
        // certain test runs.
        pbDataNew = (BYTE *) GlobalAlloc(GPTR, dwOldByteLength);
        if (!pbDataNew)
        {
            hr = E_OUTOFMEMORY;
            goto AddRemoveIISRestrictionListEntry_Exit;
        }
        // copy the old data...
        memcpy(pbDataNew,pbDataOld,dwOldByteLength);
        // free the old data
        if (pbDataOld)
        {
            GlobalFree(pbDataOld);
            pbDataOld = NULL;
        }
        // remove an entry from the list
        if (FALSE == RemoveWstrInMultiStr((WCHAR *) pbDataNew,wszFilePath))
        {
            // we were not able to find the value in the string
            hr = S_OK;
            goto AddRemoveIISRestrictionListEntry_Exit;
        }
        else
        {
            // keep removing till it's all gone
            BOOL bRet = TRUE;
            do
            {
                bRet = RemoveWstrInMultiStr((WCHAR *) pbDataNew,wszFilePath);
            } while (bRet);
        }

        // other wise pbDataOld is updated with the new data
        // proceed to write the new data out
    }

    // Write the new data out
    if (bBinaryIsISAPI)
    {
        mr.dwMDIdentifier = MD_ISAPI_RESTRICTION_LIST;
    }
    else
    {
        mr.dwMDIdentifier = MD_CGI_RESTRICTION_LIST;
    }
    mr.dwMDAttributes = 0;   // no need for inheritence
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiStrSize((WCHAR*)pbDataNew) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *> (pbDataNew);

    //DumpWstrInMultiStr((WCHAR *) pbDataNew);

    hr = pIMSAdminBase->SetData(hMetabase, L"", &mr);

AddRemoveIISRestrictionListEntry_Exit:
    if (FAILED(hr))
    {
        wprintf(L"Failed to %s '%s' to/from %s\r\n",
            bEnableThisBinary ? L"Enable" : L"Disable",
            wszFilePath,
            bBinaryIsISAPI ? L"MD_ISAPI_RESTRICTION_LIST" : L"MD_CGI_RESTRICTION_LIST"
            );
    }
    else
    {
        wprintf(L"Succeeded to %s '%s' to/from %s\r\n",
            bEnableThisBinary ? L"Enable" : L"Disable",
            wszFilePath,
            bBinaryIsISAPI ? L"MD_ISAPI_RESTRICTION_LIST" : L"MD_CGI_RESTRICTION_LIST"
            );
    }
    if (hMetabase)
    {
        pIMSAdminBase->CloseKey(hMetabase);
        hMetabase = NULL;
    }
    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
    if (pbDataOld)
    {
        GlobalFree(pbDataOld);
        pbDataOld = NULL;
    }
    if (pbDataNew)
    {
        GlobalFree(pbDataNew);
        pbDataNew = NULL;
    }
    CoUninitialize();
    return hr;
}

BOOL
DeleteEntryFromMultiSZ3Pair(
    LPCWSTR ptstrMultiSZ,
    LPCWSTR ptstrKey
    )

/*++

Routine Description:

    Search for the specified key in MultiSZ key-value 3 string pairs
    looks like:
    1,c:\mydir\myfilename.dll,mydescription
    1,c:\mydir\myfilename.dll,mydescription
    1,c:\mydir\myfilename.dll,mydescription

Arguments:
    ptstrMultiSZ - Points to the data to be searched
    ptstrKey - Specifies the key string

Return Value:
    Pointer to the value string corresponding to the specified
    key string; NULL if the specified key string is not found
--*/
{
    LPWSTR pPointer1 = NULL;
    LPWSTR pPointer2 = NULL;
    LPWSTR pPointer3 = NULL;
    LPWSTR pPointer4 = NULL;
    LPCWSTR pPointerEnd = NULL;

    pPointerEnd = GetEndOfMultiSz((LPCWSTR) ptstrMultiSZ);

	// Advanced past beginning nulls if any.
	while (*ptstrMultiSZ == NULL)
	{
		ptstrMultiSZ++;
	}

	// make sure 1st entry is at least a single digit
	// if not, then let's skip until we find one
	while (*ptstrMultiSZ != NULL)
	{
		if (wcslen(ptstrMultiSZ) < 2)
		{
			break;
		}
		ptstrMultiSZ += wcslen(ptstrMultiSZ) + 1;
	}

    while (*ptstrMultiSZ != NULL)
    {
        // Assign pointer to the 1st entry
        pPointer1 = (LPWSTR) ptstrMultiSZ;

        // Advance to the first key...
        ptstrMultiSZ += wcslen(ptstrMultiSZ) + 1;
        pPointer2 = (LPWSTR) ptstrMultiSZ;
        if (ptstrMultiSZ && *ptstrMultiSZ)
        {
          ptstrMultiSZ += wcslen(ptstrMultiSZ) + 1;
          pPointer3 = (LPWSTR) ptstrMultiSZ;

          //
          // If the current string matches the specified key string,
          // then return the corresponding value string
          //
          if (_wcsicmp(pPointer2, ptstrKey) == 0)
          {
            // we found our entry, delete it and get out
            // Get the beginning of the next entry..
            ptstrMultiSZ += wcslen(ptstrMultiSZ) + 1;

            if (*ptstrMultiSZ != NULL)
            {
				ULONG_PTR dwTotalSizeOfDeletion = dwTotalSizeOfDeletion = (ULONG_PTR) ptstrMultiSZ - (ULONG_PTR)pPointer1;

				// erase this memory
				memset(pPointer1, 0, dwTotalSizeOfDeletion);

				// move trailing memory over erased memory (overwritting it)
				memmove(pPointer1, ptstrMultiSZ, ((ULONG_PTR) pPointerEnd - (ULONG_PTR) ptstrMultiSZ));

				// erase stuff behind it.
				memset((void*) ((ULONG_PTR) pPointerEnd - (ULONG_PTR) dwTotalSizeOfDeletion), 0, dwTotalSizeOfDeletion);
            }
            else
            {
              *pPointer1 = NULL;
              *pPointer1++ = NULL;
            }
            return TRUE;
          }

          //
          // Otherwise, advance to the next 3 string pair
          //
          ptstrMultiSZ += wcslen(ptstrMultiSZ) + 1;
        }
    }

    return FALSE;
}

// wszFilePath    =
// wszDescription =
HRESULT AddRemoveIISCustomDescriptionEntry(WCHAR * wszFilePathInput,WCHAR * wszDescription,BOOL bCannotBeRemovedByUser,BOOL bAddToList)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    METADATA_HANDLE hMetabase = NULL;    // handle to metabase
    METADATA_RECORD mr;
    BYTE  * pbDataOld = NULL;
    BYTE  * pbDataNew = NULL;
    DWORD dwMDRequiredDataLen = 0;
    DWORD dwNewEntryLength = 0;
    DWORD dwNewTotalLength = 0;
    DWORD dwOldByteLength = 0;
    WCHAR * wszFilePath = NULL;
    INT iFound = 0;

    // Convert any env vars to hard coded paths
    LPWSTR pch = wcschr( (LPWSTR) wszFilePathInput, L'%');
    if (pch)
    {
       // determine the length of the expanded string
       DWORD len = ::ExpandEnvironmentStrings(wszFilePathInput, 0, 0);
       if (!len)
       {
          return hr;
       }

       wszFilePath = (WCHAR *) GlobalAlloc(GPTR, (len + 1) * sizeof(WCHAR));
       DWORD len1 = ExpandEnvironmentStrings((LPWSTR) wszFilePathInput,const_cast<wchar_t*>(wszFilePath),len);
       if (len1 != len)
       {
           if (wszFilePath)
           {
               GlobalFree(wszFilePath);wszFilePath = NULL;
           }
           return hr;
       }
    }
    else
    {
        wszFilePath = wszFilePathInput;
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (hr == RPC_E_CHANGED_MODE)
    {
        // fine.  try again
        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    hr = CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **)&pIMSAdminBase);
    if (FAILED(hr))
    {
        goto AddRemoveIISCustomDescriptionEntry_Exit;
    }

    // open the specified metabase node
    hr = pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"LM/W3SVC",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase);
    if (FAILED(hr))
    {
        hMetabase = NULL;
        goto AddRemoveIISCustomDescriptionEntry_Exit;
    }

    mr.dwMDIdentifier = MD_RESTRICTION_LIST_CUSTOM_DESC;
    mr.dwMDAttributes = 0;   // no need for inheritence
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = 0;
    mr.pbMDData       = reinterpret_cast<unsigned char *>(pbDataOld);

    // first we need to figure out how much space we need
    hr = pIMSAdminBase->GetData(hMetabase, L"", &mr, &dwMDRequiredDataLen);
    if(FAILED(hr))
    {
        // if there isn't a value there that we need to update
        // then create one
        if( hr == MD_ERROR_DATA_NOT_FOUND || HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND )
        {
            if (bAddToList)
            {
                // make enough room for the new entry...
                dwNewTotalLength = 2 * sizeof(WCHAR); // char + 1null
                dwNewTotalLength = dwNewTotalLength + ((wcslen(wszFilePathInput) + 1) * sizeof(WCHAR)); // string + 1 null
                dwNewTotalLength = dwNewTotalLength + ((wcslen(wszDescription) + 2) * sizeof(WCHAR)); // string + 1 null and 1 ending null

                pbDataNew = (BYTE *) GlobalAlloc(GPTR, dwNewTotalLength);
                if (!pbDataNew)
                {
                    hr = E_OUTOFMEMORY;
                    goto AddRemoveIISCustomDescriptionEntry_Exit;
                }

                // set to empty
                memset(pbDataNew, 0, dwNewTotalLength);

                // create the entry
                if (bCannotBeRemovedByUser)
                {
                    memcpy(pbDataNew,L"1",sizeof(WCHAR));
                }
                else
                {
                    memcpy(pbDataNew,L"0",sizeof(WCHAR));
                }

                // append on the new data
                dwNewEntryLength = ((wcslen(wszFilePathInput) + 1) * sizeof(WCHAR));

                memcpy((pbDataNew + (sizeof(WCHAR) * 2)),wszFilePath, dwNewEntryLength);
                memcpy((pbDataNew + (sizeof(WCHAR) * 2) + dwNewEntryLength),wszDescription,((wcslen(wszDescription) + 1) * sizeof(WCHAR)));
                memset((pbDataNew + (sizeof(WCHAR) * 2) + dwNewEntryLength + ((wcslen(wszDescription) + 1) * sizeof(WCHAR))),0,2);

                mr.dwMDIdentifier = MD_RESTRICTION_LIST_CUSTOM_DESC;
                mr.dwMDAttributes = 0;   // no need for inheritence
                mr.dwMDUserType   = IIS_MD_UT_SERVER;
                mr.dwMDDataType   = MULTISZ_METADATA;
                mr.dwMDDataLen    = GetMultiStrSize((WCHAR*) pbDataNew) * sizeof(WCHAR);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(pbDataNew);

                // Write value
                hr = pIMSAdminBase->SetData(hMetabase, L"", &mr);
                goto AddRemoveIISCustomDescriptionEntry_Exit;
            }
            else
            {
                // we don't need to do anything else
                // there are no entries, so there is nothing to remove
                hr = S_OK;
                goto AddRemoveIISCustomDescriptionEntry_Exit;
            }
        }
        else
        {
            goto AddRemoveIISCustomDescriptionEntry_Exit;
        }
    }

    pbDataOld = (BYTE *) GlobalAlloc(GPTR, dwMDRequiredDataLen);
    if (!pbDataOld)
    {
        hr = E_OUTOFMEMORY;
        goto AddRemoveIISCustomDescriptionEntry_Exit;
    }

    // do the real call to get the data from the metabase
    mr.dwMDDataLen    = dwMDRequiredDataLen;
    mr.pbMDData       = reinterpret_cast<unsigned char *>(pbDataOld);
    hr = pIMSAdminBase->GetData(hMetabase, L"", &mr, &dwMDRequiredDataLen);
    if (FAILED(hr))
    {
        goto AddRemoveIISCustomDescriptionEntry_Exit;
    }

    iFound = FindWstrInMultiStrSpecial((WCHAR *) pbDataOld,wszFilePath,NULL);
    if (0 == iFound)
    {
        if (!bAddToList)
        {
            // the entry doesn't exist
            // so we don't have to remove it
            hr = S_OK;
            //wprintf(L"found = 0, skip remove!!\r\n");
            goto AddRemoveIISCustomDescriptionEntry_Exit;
        }

        // otherwise, proceed to add the entry....
    }
    else if (2 == iFound)
    {
        if (bAddToList)
        {
            // there already is an entry there
            // so we can exit and don't have to do anything
            //wprintf(L"found = 2, skip adding!!\r\n");
            hr = S_OK;
            goto AddRemoveIISCustomDescriptionEntry_Exit;
        }
        // otherwise, proceed to remove the entry....
    }
    else
    {
        // we must have a 1
        // which means we found the filename but the description is different...
        //wprintf(L"%s found only filename!!! pbDataOld=%p\n",wszFilePath,pbDataOld);

        // proceed to update the entry
        // Write some code to update the description...
    }

    if (bAddToList)
    {
        //wprintf(L"doing add!\r\n");
        DWORD dwTempLen = 0;
        // Recalc the amount of space we'll need to add this entry into the list
        dwOldByteLength = GetMultiStrSize( (WCHAR*) pbDataOld) * sizeof(WCHAR);
        dwNewEntryLength = (
                            (sizeof(WCHAR) * 2) +
                            ((wcslen(wszFilePath) + 1) * sizeof(WCHAR)) +
                            ((wcslen(wszDescription) + 1) * sizeof(WCHAR))
                            );
        dwNewTotalLength = dwOldByteLength + dwNewEntryLength + (sizeof(WCHAR)); // string + 1 null and 1 ending null

        // Alloc enough space for the old data and the new data.
        // Don't use realloc here, because for somereason it would fail in
        // certain test runs.
        pbDataNew = (BYTE *) GlobalAlloc(GPTR, dwNewTotalLength);
        if (!pbDataNew)
        {
            hr = E_OUTOFMEMORY;
            goto AddRemoveIISCustomDescriptionEntry_Exit;
        }

        // set to empty
        memset(pbDataNew, 0, dwNewTotalLength);

        // copy the old data...
        memcpy(pbDataNew,pbDataOld,dwOldByteLength);

        // append entry #1 on to the new data -- backup over the double nulls
        dwTempLen = dwOldByteLength - 2;
        if (bCannotBeRemovedByUser)
            {memcpy((pbDataNew + dwTempLen),L"1",sizeof(WCHAR));}
        else
            {memcpy((pbDataNew + dwTempLen),L"0",sizeof(WCHAR));}
        memset((pbDataNew + dwTempLen + sizeof(WCHAR)),0,2);
        dwTempLen = dwTempLen + sizeof(WCHAR) + sizeof(WCHAR);

        // append entry #2
        dwNewEntryLength = ((wcslen(wszFilePath) + 1) * sizeof(WCHAR));
        memcpy((pbDataNew + dwTempLen),wszFilePath,dwNewEntryLength);
        dwTempLen = dwTempLen + dwNewEntryLength;

        // append entry #3
        dwNewEntryLength = ((wcslen(wszDescription) + 1) * sizeof(WCHAR));
        memcpy((pbDataNew + dwTempLen),wszDescription,dwNewEntryLength);
        dwTempLen = dwTempLen + dwNewEntryLength;

        // make sure it ends with double nulls
        memset((pbDataNew + dwTempLen),0,4);

        // free the old data
        if (pbDataOld)
        {
            GlobalFree(pbDataOld);
            pbDataOld = NULL;
        }
    }
    else
    {
        dwOldByteLength = GetMultiStrSize( (WCHAR*) pbDataOld) * sizeof(WCHAR);

        // Don't use realloc here, because for somereason it would fail in
        // certain test runs.
        pbDataNew = (BYTE *) GlobalAlloc(GPTR, dwOldByteLength);
        if (!pbDataNew)
        {
            hr = E_OUTOFMEMORY;
            goto AddRemoveIISCustomDescriptionEntry_Exit;
        }
        // copy the old data...
        memcpy(pbDataNew,pbDataOld,dwOldByteLength);
        // free the old data
        if (pbDataOld)
        {
            GlobalFree(pbDataOld);
            pbDataOld = NULL;
        }

        BOOL bDeletedSomething = FALSE;
        do
        {
          bDeletedSomething = DeleteEntryFromMultiSZ3Pair((LPCWSTR) pbDataNew,wszFilePath);
        } while (bDeletedSomething);

        // other wise pbDataOld is updated with the new data
        // proceed to write the new data out
    }

    // Write the new data out
    mr.dwMDIdentifier = MD_RESTRICTION_LIST_CUSTOM_DESC;
    mr.dwMDAttributes = 0;   // no need for inheritence
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiStrSize((WCHAR*)pbDataNew) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *> (pbDataNew);

    DumpWstrInMultiStr((WCHAR *) pbDataNew);

    hr = pIMSAdminBase->SetData(hMetabase, L"", &mr);

AddRemoveIISCustomDescriptionEntry_Exit:
    if (FAILED(hr))
    {
        wprintf(L"Failed to %s '%s'\r\n",
            bAddToList ? L"Add" : L"Remove",
            wszFilePath
            );
    }
    else
    {
        wprintf(L"Succeeded to %s '%s'\r\n",
            bAddToList ? L"Add" : L"Remove",
            wszFilePath
            );
    }
    if (hMetabase)
    {
        pIMSAdminBase->CloseKey(hMetabase);
        hMetabase = NULL;
    }
    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
    if (pbDataOld)
    {
        GlobalFree(pbDataOld);
        pbDataOld = NULL;
    }
    if (pbDataNew)
    {
        GlobalFree(pbDataNew);
        pbDataNew = NULL;
    }
    CoUninitialize();
    return hr;
}


BOOL OpenMetabaseAndDoExport(void)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    IMSAdminBase2 *pIMSAdminBase2 = NULL;  // Metabase interface pointer

    WCHAR wszExportPassword[_MAX_PATH];
    WCHAR wszExportFileName[_MAX_PATH];
    WCHAR wszMetabaseNodeToExport[_MAX_PATH];
    wcscpy(wszExportFileName,L"c:\\TestExport.xml");
    wcscpy(wszExportPassword,L"TestPassword");
    wcscpy(wszMetabaseNodeToExport,L"/LM/W3SVC/1");

    if (FAILED (hr = CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
        if (FAILED (hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED )))
        {
            return FALSE;
        }
    }
     if (FAILED (hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **)&pIMSAdminBase)))
     {
         goto OpenMetabaseAndDoExport_Exit;
     }

	if (SUCCEEDED(hr = pIMSAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pIMSAdminBase2)))
	{
        SetBlanket(pIMSAdminBase2);
        hr = pIMSAdminBase2->Export(wszExportPassword,wszExportFileName,wszMetabaseNodeToExport,MD_EXPORT_INHERITED);
        pIMSAdminBase2->Release();
        pIMSAdminBase2 = NULL;
	}

    if (FAILED(hr))
    {
        wprintf(L"Failed to Export to file:%s,err=0x%x\r\n",wszExportFileName,hr);
    }
	else
    {
        wprintf(L"Succeeded to Export to file:%s\r\n",wszExportFileName);
        fRet = TRUE;
    }

OpenMetabaseAndDoExport_Exit:
    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return fRet;
}


BOOL OpenMetabaseAndDoImport(void)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    IMSAdminBase2 *pIMSAdminBase2 = NULL;  // Metabase interface pointer

    WCHAR wszExportPassword[_MAX_PATH];
    WCHAR wszImportFileName[_MAX_PATH];
    WCHAR wszMetabaseNode1[_MAX_PATH];
    WCHAR wszMetabaseNode2[_MAX_PATH];
    wcscpy(wszImportFileName,L"c:\\TestExport.xml");
    wcscpy(wszExportPassword,L"TestPassword");
    wcscpy(wszMetabaseNode1,L"/LM/W3SVC/1");
    wcscpy(wszMetabaseNode2,L"/LM/W3SVC/100");

    if (FAILED (hr = CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
        if (FAILED (hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED )))
        {
            return FALSE;
        }
    }
     if (FAILED (hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **)&pIMSAdminBase)))
     {
         goto OpenMetabaseAndDoExport_Exit;
     }

	if (SUCCEEDED(hr = pIMSAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pIMSAdminBase2)))
	{
        SetBlanket(pIMSAdminBase2);
        hr = pIMSAdminBase2->Import(wszExportPassword,wszImportFileName,wszMetabaseNode1,wszMetabaseNode2,MD_IMPORT_NODE_ONLY);
        pIMSAdminBase2->Release();
        pIMSAdminBase2 = NULL;
	}

    if (FAILED(hr))
    {
        wprintf(L"Failed to Export to file:%s,err=0x%x\r\n",wszImportFileName,hr);
    }
	else
    {
        wprintf(L"Succeeded to Export to file:%s\r\n",wszImportFileName);
        fRet = TRUE;
    }

OpenMetabaseAndDoExport_Exit:
    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return fRet;
}

BOOL GetIISVersion_Internal_iiscnfgp(IMSAdminBase *pIMSAdminBase,DWORD * dwReturnedMajorVersion,DWORD * dwReturnedMinorVersion)
{
    HRESULT hr;
    BOOL fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;   // handle to metabase
    METADATA_RECORD mr;
    WCHAR  szTmpData[MAX_PATH];
    DWORD  dwMDRequiredDataLen;

    // open key
    hr = pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3SVC/Info",
                         METADATA_PERMISSION_READ,
                         REASONABLE_TIMEOUT,
                         &hMetabase);
    if( FAILED( hr ))
    {
        return FALSE;
    }

    //#define MD_SERVER_VERSION_MAJOR         (IIS_MD_SERVER_BASE+101 )
    //#define MD_SERVER_VERSION_MINOR         (IIS_MD_SERVER_BASE+102 )

    DWORD pdwValue = 0;
    mr.dwMDIdentifier = MD_SERVER_VERSION_MAJOR;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(pdwValue);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&pdwValue);

    pdwValue = 0;
    dwMDRequiredDataLen = 0;
    *dwReturnedMajorVersion = 0;
    hr = pIMSAdminBase->GetData( hMetabase, L"", &mr, &dwMDRequiredDataLen );
    if( SUCCEEDED( hr ))
    {
        *dwReturnedMajorVersion = pdwValue;
    }

    mr.dwMDIdentifier = MD_SERVER_VERSION_MINOR;
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&pdwValue);

    pdwValue = 0;
    dwMDRequiredDataLen = 0;
    *dwReturnedMinorVersion = 0;
    hr = pIMSAdminBase->GetData( hMetabase, L"", &mr, &dwMDRequiredDataLen );
    if( SUCCEEDED( hr ))
    {
        *dwReturnedMinorVersion = pdwValue;
    }

    WCHAR wszPrintString[MAX_PATH];
    wsprintf(wszPrintString,L"MajorVer=%d,MinorVer=%d\n", *dwReturnedMajorVersion, *dwReturnedMinorVersion);
    wprintf(wszPrintString);

    pIMSAdminBase->CloseKey( hMetabase );
    if( SUCCEEDED( hr ))
    {
        fRet = TRUE;
    }

    pIMSAdminBase->CloseKey( hMetabase );
    return fRet;
}


BOOL OpenMetabaseAndGetVersion()
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMSAdminBase)))
    {
        return FALSE;
    }

    DWORD dwMajorVersion,dwMinorVersion=0;
    GetIISVersion_Internal_iiscnfgp(pIMSAdminBase,&dwMajorVersion,&dwMinorVersion);

    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return fRet;
}


HRESULT RemoteOpenMetabaseAndCallExport(
    const WCHAR *pcszMachineName,
    const WCHAR *pcszUserName,
    const WCHAR *pcszDomain,
    const WCHAR *pcszPassword
    )
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;
    IMSAdminBase2 *pIMSAdminBase2 = NULL;

    COSERVERINFO svrInfo;
    COAUTHINFO AuthInfo;
    COAUTHIDENTITY AuthId;

    ZeroMemory(&svrInfo, sizeof(COSERVERINFO));
    ZeroMemory(&AuthInfo, sizeof(COAUTHINFO));
    ZeroMemory(&AuthId, sizeof(COAUTHIDENTITY));

    AuthId.User = (USHORT*) pcszUserName;
    AuthId.UserLength = wcslen (pcszUserName);
    AuthId.Domain = (USHORT*)pcszDomain;
    AuthId.DomainLength = wcslen (pcszDomain);
    AuthId.Password = (USHORT*)pcszPassword;
    AuthId.PasswordLength = wcslen (pcszPassword);
    AuthId.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    AuthInfo.dwAuthnSvc           = RPC_C_AUTHN_WINNT;
    AuthInfo.dwAuthzSvc           = RPC_C_AUTHZ_NONE;
    AuthInfo.pwszServerPrincName  = NULL;

    // RPC_C_AUTHN_LEVEL_DEFAULT       0
    // RPC_C_AUTHN_LEVEL_NONE          1
    // RPC_C_AUTHN_LEVEL_CONNECT       2
    // RPC_C_AUTHN_LEVEL_CALL          3
    // RPC_C_AUTHN_LEVEL_PKT           4
    // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
    // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6

    //AuthInfo.dwAuthnLevel         = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    AuthInfo.dwAuthnLevel         = RPC_C_AUTHN_LEVEL_DEFAULT;
    AuthInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    AuthInfo.pAuthIdentityData    = &AuthId;
    AuthInfo.dwCapabilities       = EOAC_NONE;

    svrInfo.dwReserved1 = 0;
    svrInfo.dwReserved2 = 0;
    svrInfo.pwszName = (LPWSTR) pcszMachineName;
    svrInfo.pAuthInfo   = &AuthInfo;

    if(FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        if(FAILED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
        {
            wprintf(L"CoInitializeEx failed:hr=0x%x\r\n",hr);
            return hr;
        }
    }

    MULTI_QI res[1] =
    {
        {&IID_IMSAdminBase, NULL, 0}
    };

    // CLSCTX_INPROC_SERVER = 1,
    // CLSCTX_INPROC_HANDLER = 2,
    // CLSCTX_LOCAL_SERVER = 4
    // CLSCTX_REMOTE_SERVER = 16
    // CLSCTX_NO_CODE_DOWNLOAD = 400
    // CLSCTX_NO_FAILURE_LOG = 4000
    // #define CLSCTX_SERVER (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)
    // #define CLSCTX_ALL (CLSCTX_INPROC_HANDLER | CLSCTX_SERVER)

    if (FAILED(hr = CoCreateInstanceEx(CLSID_MSAdminBase,NULL,CLSCTX_ALL,&svrInfo,1,res)))
    {
        wprintf(L"CoCreateInstanceEx failed:hr=0x%x\r\n",hr);
        goto RemoteOpenMetabaseAndCallExport_Exit;
    }

    pIMSAdminBase = (IMSAdminBase *)res[0].pItf;

    {
        hr =  ::CoSetProxyBlanket(
            pIMSAdminBase,
            AuthInfo.dwAuthnSvc,
            AuthInfo.dwAuthzSvc,
            AuthInfo.pwszServerPrincName,
            AuthInfo.dwAuthnLevel,
            AuthInfo.dwImpersonationLevel,
            AuthInfo.pAuthIdentityData,
            AuthInfo.dwCapabilities
            );

        if (FAILED(hr))
        {
            wprintf(L"CoSetProxyBlanket failed:hr=0x%x\r\n",hr);
            goto RemoteOpenMetabaseAndCallExport_Exit;
        }

        // There is a remote IUnknown interface that lurks behind IUnknown.
        // If that is not set, then the Release call can return access denied.
        IUnknown * pUnk = NULL;
        hr = pIMSAdminBase->QueryInterface(IID_IUnknown, (void **)&pUnk);
        if(FAILED(hr))
        {
            wprintf(L"QueryInterface failed:hr=0x%x\r\n",hr);
            return hr;
        }
        hr =  ::CoSetProxyBlanket(
            pUnk,
            AuthInfo.dwAuthnSvc,
            AuthInfo.dwAuthzSvc,
            AuthInfo.pwszServerPrincName,
            AuthInfo.dwAuthnLevel,
            AuthInfo.dwImpersonationLevel,
            AuthInfo.pAuthIdentityData,
            AuthInfo.dwCapabilities
            );

        if (FAILED(hr))
        {
            wprintf(L"CoSetProxyBlanket2 failed:hr=0x%x\r\n",hr);
            goto RemoteOpenMetabaseAndCallExport_Exit;
        }
        pUnk->Release();pUnk = NULL;
    }

     if (FAILED(hr = pIMSAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pIMSAdminBase2)))
    {
        wprintf(L"QueryInterface2 failed:hr=0x%x\r\n",hr);
        goto RemoteOpenMetabaseAndCallExport_Exit;
    }

    hr =  ::CoSetProxyBlanket(
        pIMSAdminBase2,
        AuthInfo.dwAuthnSvc,
        AuthInfo.dwAuthzSvc,
        AuthInfo.pwszServerPrincName,
        AuthInfo.dwAuthnLevel,
        AuthInfo.dwImpersonationLevel,
        AuthInfo.pAuthIdentityData,
        AuthInfo.dwCapabilities
        );

    if (FAILED(hr))
    {
        wprintf(L"CoSetProxyBlanket3 failed:hr=0x%x\r\n",hr);
        goto RemoteOpenMetabaseAndCallExport_Exit;
    }

    hr = pIMSAdminBase2->Export(L"testing",L"c:\\testing.xml333",L"LM/W3SVC/1",0);
    if (FAILED(hr))
    {
        wprintf(L"pIMSAdminBase2->Export failed:ret=0x%x\r\n",hr);
    }


RemoteOpenMetabaseAndCallExport_Exit:
    if (SUCCEEDED(hr))
    {
        wprintf(L"RemoteOpenMetabaseAndCallExport:SUCCEEDED!!!! :hr=0x%x\r\n",hr);
    }

    if (pIMSAdminBase2)
    {
        pIMSAdminBase2->Release();
        pIMSAdminBase2 = NULL;
    }
    if (pIMSAdminBase)
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
    CoUninitialize();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\infutil2\main.cpp ===
//****************************************************************************
//* Author:   Aaron Lee
//* Purpose:  Create .DDF and .INF files for specified files
//******************************************************************************/
/*
; ------------------------------------------------------------------------------------
; Format for this file
;
; position 1 = nts_x86 flag
; position 2 = ntw_x86 flag
; position 3 = win95 flag
; position 4 = win98 flag
; position 5 = nts_alpha flag
; position 6 = ntw_alpha flag
; position 7 = other_os flag
;
; position 8 = cabfilename
; position 9 = inf section
; position 10 = filename (wildcards okay)
;
; position 11= .INF rename to
; position 12= .DDF exclude from cab flag
; position 13=  Do Not Produce Error if Empty
; position 14=  Do Not include this file if the cab is empty!
; position 15=  Slipstream file -- don't reference the 0 cab, reference the # specified in global Variable - g_iSlipStreamDiskID
; ------------------------------------------------------------------------------------
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,setupapi.dll,,1
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,cfgmgr32.dll
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,ocmanage.dll
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,sysocmgr.exe
1,1,1,1,0,0,0,basic.cab,iis_core_files_sys,inetsrv\mdutil.exe
1,1,1,1,0,0,0,basic.cab,iis_core_files_sys,inetsrv\iismap.dll
1,1,1,1,0,0,0,basic.cab,iis_core_files_inetsrv,inetsrv\iscomlog.dll

;nts_x86,
ntw_x86,
win95,
win98,
nts_alpha,
ntw_alpha,
other_os,

cab filename,
inf section,
filename (wildcards okay),
.INF rename to,
.DDF exclude from cab,
1=don't show error if file not exist,
1=Do Not include this file if the cab is empty!,
Owner
*/
#include <direct.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <windows.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <iostream.h>
#include <fstream.h>
#include <winbase.h>
#include "filefind.h"
#include <iis64.h>

// Defines
#define delimiters      ",\t\n"
#define MAX_STRING      512
#define MAX_ARRAY_SIZE  10000
#define MAX_ARRAY_SMALL 1000
#define ALL_FILES       0xff

#define NTS_X86         "nts_x86"
#define NTW_X86         "ntw_x86"
#define WIN95           "win95"
#define WIN98           "win98"
#define NTS_ALPHA       "nts_alpha"
#define NTW_ALPHA       "ntw_alpha"
#define OTHER_OS        "other_os"

// Globals
int   g_iSlipStreamDiskID = 99;  // default if none specified as input parameter
int   g_iGlobalReturnCode = TRUE;

int   g_bOutputFileDate = FALSE;
int   g_bOutputFileTime = FALSE;
int   g_bOutputFileDateTime = FALSE;
int   g_bDoFileCompare = FALSE;
char  g_szDoFileCompareData[_MAX_PATH];
int   g_bVersionCheck = FALSE;
int   g_bShowFileFormat = FALSE;
int   g_bIgnorePrefix = FALSE;
int   g_bOutputDetails = TRUE;
int   g_bChangeListOnly = FALSE;
int   g_bChangeListOnly2 = FALSE;
int   g_bCabbing_Flag = TRUE;
int   g_bDisplayToScreen = FALSE;
char  g_szModuleFilename[_MAX_FNAME];
char  g_szDDFOutput[_MAX_PATH];
char  g_szINFOutput[_MAX_PATH];
char  g_szLSTOutput[_MAX_PATH];
char  g_szCATOutput[_MAX_PATH];
char  g_szCNGOutput[_MAX_PATH];
char  g_szLOCOutput[_MAX_PATH];
char  g_szNOTExistOutput[_MAX_PATH];

char  g_szinput_filename_full[_MAX_PATH];
char  g_szinput_platform[10];
char  g_szCurrentDir[_MAX_PATH];

char  g_szFilenameTag[_MAX_FNAME] = "CAB_";

#define USENEW


struct FileReadLine
{
    int  NTS_x86_flag;
    int  NTW_x86_flag;
    int  Win95_flag;
	int  Win98_flag;
    int  NTS_alpha_flag;
    int  NTW_alpha_flag;
	int  Other_os_flag;
    char CabFileName[50];
    char INF_Sections[100];
    char Filename_Full[_MAX_PATH];
    char Filename_Name[_MAX_FNAME];
    char Filename_Path[_MAX_PATH];
    char DDF_Renamed[_MAX_PATH];
    char INF_Rename_To[_MAX_FNAME];
    int  DDF_Exclude_From_Cab_Flag;
    int  Do_Not_Show_Error_Flag;
    int  Do_Not_Include_file_if_cabEmpty_Flag;
	// invisible stuff
	long FileName_Size;
	int  FileWasNotActuallyFoundToExist;
	int  GetFromSlipStreamDisk;
} Flat_GlobalArray_Main[MAX_ARRAY_SIZE];


struct CabSizeInfoStruct
{
	char CabFileName[50];
	int  TotalFiles;
	long TotalFileSize;
} Flat_GlobalArray_CabSizes[30];

char Flat_GlobalArray_Err[MAX_ARRAY_SIZE][255];

struct arrayrow
{
    long total;
    long nextuse;
} Flat_GlobalArrayIndex_Main, Flat_GlobalArrayIndex_Err, Flat_GlobalArrayIndex_CabSizes;


char Flat_GlobalUniqueDirList[300][_MAX_PATH];
int Flat_GlobalUniqueDirList_nextuse;
int Flat_GlobalUniqueDirList_total;

// used for files which should not be included in the cab.
FileReadLine g_non_cablist_temp[MAX_ARRAY_SMALL];
int g_non_cablist_temp_nextuse;
int g_non_cablist_temp_total;


// prototypes
int   __cdecl main(int ,char *argv[]);
void  ShowHelp(void);
void  ShowFormat(void);
void  MakeDirIfNeedTo(char []);
int   strltrim(LPSTR & thestring);
int   RemoveAllSpaces(LPSTR & thetempstring);
int   IsThisStringInHere(LPTSTR, char[]);
void  GetPath(char *input_filespec, char *path, char *fs);
int   DoesFileExist(char *input_filespec);
void  GetThisModuleName(void);
char* __cdecl strtok2(char *,const char *);

void  Flat_ProcessFile(void);
void  Flat_GlobalArray_Fill(char[]);
void  Flat_GlobalArray_ChkDups(void);
void  Flat_GlobalArray_Prepend_UniqueString(void);

void  Flat_GlobalArray_Sort_Cols1(void);
void  Flat_GlobalArray_Sort_Cols1a(BOOL bDescendFlag);
void  Flat_GlobalArray_Sort_Cols2(BOOL bDescendFlag);

int   Flat_GlobalArray_Add(FileReadLine);
void  Flat_GlobalArray_Add_Err(char[]);
int   Flat_GlobalArray_EntryExists(FileReadLine);
void  Flat_GlobalArray_Print(void);
void  Flat_GlobalArray_Print_Err(void);
int   Flat_IsFileNameDup(int);
void  Flat_Create_Output_DDF(void);
void  Flat_Create_Output_INF(void);
int   Flat_Create_Output_ERR(void);
int   Flat_DoWeIncludeThisFileCheck(int processeduptill);


void Global_TotalCabFileSize_Compute(void);
void Global_TotalCabFileSize_Print(void);

int ReturnDirLevelCount(char *DirectoryTree);
void FillGlobalUniqueDirList();
int GlobalUniqueDirChkIfAlreadyThere(char *TheStringToCheck);
int GlobalUniqueDirReturnMyIndexMatch(char *TheStringToCheck);

void PrintFileDateTime(char *Full_Filename);
LPSTR  StripWhitespaceA(LPSTR pszString);
int iCompareTime(SYSTEMTIME *SystemTime1,SYSTEMTIME *SystemTime2);
int CompareFiles(LPSTR lpFileName1,LPSTR lpFileName2);
BOOL GetFileDate(LPTSTR lpFileName1,SYSTEMTIME *SystemTime1);



//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
	LPSTR pArg = NULL;
    int  argno = 0;
    int  nflags=0;
    char ini_filename_dir[_MAX_PATH];
    char ini_filename_only[_MAX_FNAME];
    char ini_filename_ext[_MAX_EXT];

    ini_filename_only[0]='\0';
    g_szinput_platform[0]='\0';

    GetThisModuleName();

    // Get current directory
    GetCurrentDirectory( _MAX_PATH, g_szCurrentDir);

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
            nflags++;
            switch (argv[argno][1])
                {
                case '1':
					g_bOutputFileDate = TRUE;
                    break;
				case '2':
					g_bOutputFileTime = TRUE;
                    break;
                case '3':
					g_bOutputFileDateTime = TRUE;
                    break;
                case '4':
					g_bDoFileCompare = TRUE;
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
					{
                        char szTempString[MAX_PATH];
                        LPSTR pCmdStart = NULL;

						pArg = CharNextA(pArg);
						// Check if it's quoted
						if (*pArg == '\"')
						{
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
						}
						else
						{
							pCmdStart = pArg;
							// while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNextA(pArg);}
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
                        lstrcpyA(g_szDoFileCompareData, StripWhitespaceA(pCmdStart));
					}

                    break;
                case 'a':
				case 'A':
					g_bChangeListOnly = TRUE;
                    break;
                case 'b':
				case 'B':
					g_bChangeListOnly2 = TRUE;
                    break;
                case 'd':
				case 'D':
					g_bOutputDetails = FALSE;
                    break;
                case 'f':
				case 'F':
					g_bShowFileFormat = TRUE;
                    break;
                case 'i':
				case 'I':
					g_bIgnorePrefix = TRUE;
                    break;
                    case 'n':
                case 'N':
					g_bCabbing_Flag = FALSE;
                    break;
				case 'x':
                case 'X':
					g_bDisplayToScreen = TRUE;
                    break;
                case 's':
					g_iSlipStreamDiskID = atoi(&argv[argno][2]);
                    break;
                case 't':
                case 'T':
                    lstrcpyn (g_szFilenameTag, &argv[argno][2], sizeof(g_szFilenameTag)-1);
                    strcat (g_szFilenameTag, "_");
                    break;
                case 'v':
                case 'V':
                    g_bVersionCheck = TRUE;
                    break;
                case '?':
                    goto exit_with_help;
                    break;
                }
            } // if switch character found
        else
            {
            if ( *ini_filename_only == '\0' )
                {
                // if no arguments, then
                // get the ini_filename_dir and put it into
                strcpy(g_szinput_filename_full, argv[argno]);
                ini_filename_dir[0] = '\0';
                // split up this path
                _splitpath( g_szinput_filename_full, NULL, ini_filename_dir, ini_filename_only, ini_filename_ext);

                strcat(ini_filename_only, ini_filename_ext);
                // if we're missing dir, then get it.
                if (*ini_filename_dir == '\0')
                    {
                    // stick current dir into our variable
                    strcpy(ini_filename_dir, g_szCurrentDir);
                    strcpy(g_szinput_filename_full, g_szCurrentDir);
                    strcat(g_szinput_filename_full, "\\");
                    strcat(g_szinput_filename_full, ini_filename_only);
                    }
                }
            else
                {
                // Additional filenames (or arguments without a "-" or "/" preceding)
                //goto exit_with_help;
                // should be the section to execute.
                strcpy(g_szinput_platform, argv[argno]);
                }
            } // non-switch char found
        } // for all arguments

    if (g_bIgnorePrefix)
    {
        g_szFilenameTag[0]='\0';
    }

    if (g_bShowFileFormat)
    {
        ShowFormat();
        goto exit_no_printf;
    }

    if (g_bVersionCheck)
    {
        printf("3\n\n");
        exit(3);
        return TRUE;
    }
    
    // check if filename was specified
    // check if section name was specified
    if ( *ini_filename_only == '\0')
        {
        printf("Too few arguments, argc=%d\n\n",argc);
        goto exit_with_help;
        }

    // Check if the file exists!
    if (FALSE == DoesFileExist(g_szinput_filename_full))
        {
        printf("INI file %s, does not exist!.\n", g_szinput_filename_full);
        goto exit_gracefully;
        }

    // check if all they want is to compare a file with another list of files
    // and check if the 2nd list of files has a date/time stamp which is more recent than file#1
    if (g_bDoFileCompare)
    {
        // check if filename was specified
        if (strcmp(g_szDoFileCompareData,"") == 0)
            {
            printf("-4 option  missing file parameter!\n\n");
            goto exit_with_help;
            }

        // compare file#s date with the list of files in #2
        if (TRUE == CompareFiles(g_szinput_filename_full,g_szDoFileCompareData))
        {
            printf("1\n\n");
            goto exit_no_printf_1;
        }
        else
        {
            printf("0\n\n");
            goto exit_no_printf;
        }
    }

    // check if all they want is the date,time or date and time!!!
    if (g_bOutputFileDate || g_bOutputFileTime || g_bOutputFileDateTime)
    {
        // get the file's julian date and echo it out!
        PrintFileDateTime(g_szinput_filename_full);
        goto exit_no_printf;
    }

    // check if filename was specified
    // check if section name was specified
    if ( *ini_filename_only == '\0' || *g_szinput_platform == '\0')
        {
        printf("Too few arguments, argc=%d\n\n",argc);
        goto exit_with_help;
        }

    // Check if g_szinput_platform is one of the available options
    strcpy(g_szinput_platform, g_szinput_platform);

    if ( (_stricmp(g_szinput_platform, NTS_X86) != 0) &&
         (_stricmp(g_szinput_platform, NTW_X86) != 0) &&
         (_stricmp(g_szinput_platform, WIN95) != 0) &&
         (_stricmp(g_szinput_platform, WIN98) != 0) &&
         (_stricmp(g_szinput_platform, NTS_ALPHA) != 0) &&
         (_stricmp(g_szinput_platform, NTW_ALPHA) != 0) &&
         (_stricmp(g_szinput_platform, OTHER_OS) != 0))
        {
        printf("2nd parameter must be one of %s,%s,%s,%s,%s,%s or %s.\n", NTS_X86, NTW_X86, WIN95, WIN98, NTS_ALPHA, NTW_ALPHA, OTHER_OS);
        goto exit_gracefully;
        }

    // Fine, process the ini file.
    char    stempstring[100];
    sprintf(stempstring, "Start %s.\n", g_szModuleFilename);
    printf(stempstring);
    printf("---------------------------------------------------\n");

    // We have at least g_szinput_platform and g_szinput_filename_full defined

    // run the function to do everything
    Flat_ProcessFile();

exit_gracefully:
    printf("---------------------------------------------------\n");
    printf("Done.\n");
    if (g_iGlobalReturnCode == TRUE)
        {exit(0);}
    else
        {exit(1);}
    return g_iGlobalReturnCode;

exit_with_help:
    ShowHelp();
    return FALSE;

exit_no_printf:
    exit(0);
    return FALSE;

exit_no_printf_1:
    exit(1);
    return TRUE;

}


int CompareFiles(LPSTR lpFileName1,LPSTR lpFileName2)
{
    int iReturn = FALSE;
    int   attr = 0;
    intptr_t  hFile = 0;
    finddata datareturn;
    SYSTEMTIME SystemTime1;
    SYSTEMTIME SystemTime2;
    char filename_dir[_MAX_PATH];
    char filename_only[_MAX_FNAME];
    char TempString[_MAX_PATH];
    char *pDest = NULL;

    // file#1 should be a regular file
    // file#2 could be 1 file or a list of files.

    // regardless, take file#1's date and compare it with the dates of the files in list#2
    // if anyone of the files in list#2 is newer than file#1, return true!

    InitStringTable(STRING_TABLE_SIZE);

    // Get the date\time for file #1
    if (FALSE == GetFileDate(lpFileName1, &SystemTime1))
    {
        printf("CompareFiles: Failure to GetFileDate on %s\n",lpFileName1);
        goto CompareFiles_Exit;
    }

    pDest = lpFileName2;

    // Find end of the string
    while (*pDest){pDest = _tcsinc(pDest);}

	// If no trailing backslash then kool, copy on the *.*
    if (*(_tcsdec(lpFileName2, pDest)) == _T('\\'))
    {
        strcat(lpFileName2, "*.*");
        attr=ALL_FILES;
    }

    // get the path
    _splitpath(lpFileName2, NULL, filename_dir, filename_only, NULL);
    attr= 0;
    if (_stricmp(filename_only, "*") == 0)
        {attr=ALL_FILES;}
    if (_stricmp(filename_only, "*.*") == 0)
        {attr=ALL_FILES;}
    if (FindFirst(lpFileName2, attr, &hFile, &datareturn))
    {
        // check if it's a sub dir
        if (!(datareturn.attrib & _A_SUBDIR))
        {
            // Get the filename portion
            strcpy(TempString, filename_dir);
            strcat(TempString, datareturn.name);
            // compare the date with file#1's date
            if (FALSE == GetFileDate(TempString, &SystemTime2))
            {
                printf("CompareFiles: Failure to GetFileDate on %s\n",TempString);
            }
            else
            {

                // check if the filedate is bigger than file#1's date
                if (TRUE == iCompareTime(&SystemTime1,&SystemTime2))
                {
                    iReturn = TRUE;
                    goto CompareFiles_Exit;
                }
             }
        }

        while(FindNext(attr, hFile, &datareturn))
        {
            //printf("FindNext:%s\n",datareturn.name);
            // check if it's a sub dir
            if (!(datareturn.attrib & _A_SUBDIR))
            {
                // Get the filename portion
                strcpy(TempString, filename_dir);
                strcat(TempString, datareturn.name);
                // compare the date with file#1's date
                if (FALSE == GetFileDate(TempString, &SystemTime2))
                {
                    printf("CompareFiles: Failure to GetFileDate on %s\n",TempString);
                }
                else
                {
                    // check if the filedate is bigger than file#1's date
                    if (TRUE == iCompareTime(&SystemTime1,&SystemTime2))
                    {
                        iReturn = TRUE;
                        goto CompareFiles_Exit;
                    }
                 }

            }
        }
    }

CompareFiles_Exit:
    EndStringTable();
    return iReturn;
}

// if systemtime2 is larger than systemtime1 then return true!
int iCompareTime(SYSTEMTIME *SystemTime1,SYSTEMTIME *SystemTime2)
{
    int iReturn = FALSE;

    if (SystemTime2->wYear > SystemTime1->wYear){goto iCompareTime_Larger;}
    if (SystemTime2->wYear < SystemTime1->wYear){goto iCompareTime_Smaller;}
    if (SystemTime2->wMonth > SystemTime1->wMonth){goto iCompareTime_Larger;}
    if (SystemTime2->wMonth < SystemTime1->wMonth){goto iCompareTime_Smaller;}

    if (SystemTime2->wDay > SystemTime1->wDay){goto iCompareTime_Larger;}
    if (SystemTime2->wDay < SystemTime1->wDay){goto iCompareTime_Smaller;}

    if (SystemTime2->wHour > SystemTime1->wHour){goto iCompareTime_Larger;}
    if (SystemTime2->wHour < SystemTime1->wHour){goto iCompareTime_Smaller;}

    if (SystemTime2->wMinute > SystemTime1->wMinute){goto iCompareTime_Larger;}
    if (SystemTime2->wMinute < SystemTime1->wMinute){goto iCompareTime_Smaller;}

    if (SystemTime2->wSecond > SystemTime1->wSecond){goto iCompareTime_Larger;}
    if (SystemTime2->wSecond < SystemTime1->wSecond){goto iCompareTime_Smaller;}

    if (SystemTime2->wMilliseconds > SystemTime1->wMilliseconds){goto iCompareTime_Larger;}
    if (SystemTime2->wMilliseconds < SystemTime1->wMilliseconds){goto iCompareTime_Smaller;}

    // they are exactly the same

    iReturn = FALSE;
    return iReturn;

iCompareTime_Larger:
    iReturn = TRUE;
    return iReturn;

iCompareTime_Smaller:
    iReturn = FALSE;
    return iReturn;

}
                 


BOOL GetFileDate(LPTSTR lpFileName1,SYSTEMTIME *SystemTime1)
{
    HANDLE hFile1 = NULL;
    FILETIME fCreate,fAccess,fWrite;

    FILETIME LocalFileTime;
    

    if (!(hFile1=CreateFile(lpFileName1,GENERIC_READ,FILE_SHARE_READ, NULL,OPEN_EXISTING,0,0)))
    {
			return FALSE;
    }
	if (!GetFileTime(hFile1,&fCreate,&fAccess,&fWrite))
    {
			CloseHandle(hFile1);
			return FALSE;
    }
	if (!FileTimeToLocalFileTime(&fWrite,&LocalFileTime))
	{
		CloseHandle(hFile1);
		return FALSE;
	}
    if (!FileTimeToSystemTime(&LocalFileTime,SystemTime1))
	{
		CloseHandle(hFile1);
		return FALSE;
	}
	CloseHandle(hFile1);
    return TRUE;
}


void PrintFileDateTime(char *Full_Filename)
{
    SYSTEMTIME SystemTime;
    char szDateandtime[50];
    // get the file's time stamp 17:31.
    // make it look like: 1731
    //
    // get the file's date 12/30/1999
    // make it look like 19991230

    // make it all look like 199912301731
    if (TRUE == GetFileDate(Full_Filename, &SystemTime))
    {
        //sprintf(szDateandtime,"[%02d/%02d/%02d %02d:%02d:%02d]\n",SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
        //printf(szDateandtime);

        if (g_bOutputFileDate)
        {
            sprintf(szDateandtime,"%02d%02d%02d\n",SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay);
            printf(szDateandtime);
        }
        
        if (g_bOutputFileTime)
        {
            sprintf(szDateandtime,"%02d%02d%02d\n",SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
            printf(szDateandtime);
        }

        if (g_bOutputFileDateTime)
        {
            sprintf(szDateandtime,"%02d%02d%02d%02d%02d%02d\n",
                SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, 
                SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
            printf(szDateandtime);
        }
    }
   
    return;
}

//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_ProcessFile()
{
    ifstream inputfile;
    char fileinputbuffer[1000];

    char    stempstring[100];
    char *  ptemp = NULL;

    Flat_GlobalArrayIndex_Main.total=0;  Flat_GlobalArrayIndex_Main.nextuse=0;
    Flat_GlobalArrayIndex_Err.total=0;   Flat_GlobalArrayIndex_Err.nextuse=0;

    // Get output file names
    strcpy(g_szDDFOutput, g_szModuleFilename);
    strcat(g_szDDFOutput, ".DDF");
    strcpy(g_szINFOutput, g_szModuleFilename);
    strcat(g_szINFOutput, ".INF");

    strcpy(g_szLSTOutput, g_szModuleFilename);
    strcat(g_szLSTOutput, ".LST");

    strcpy(g_szCATOutput, g_szModuleFilename);
    strcat(g_szCATOutput, ".CAT");

    strcpy(g_szCNGOutput, g_szModuleFilename);
    strcat(g_szCNGOutput, ".CNG");

    strcpy(g_szNOTExistOutput, g_szModuleFilename);
    strcat(g_szNOTExistOutput, ".NOT");

    strcpy(g_szLOCOutput, g_szModuleFilename);
    strcat(g_szLOCOutput, ".LOC");
   

    // don't delete these files if we're only doing the changelist file
    if (!g_bChangeListOnly)
    {
	    DeleteFile(g_szCATOutput);
        DeleteFile(g_szNOTExistOutput);
    }
    // always delete this file
    DeleteFile(g_szCNGOutput);
    DeleteFile(g_szLOCOutput);

    // Read flat file and put into huge array
    inputfile.open(g_szinput_filename_full, ios::in);
    inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer));
    do
    {
        // check for any comments, don't add these to the array.
        if (strchr(fileinputbuffer, ';') != NULL) 
        {
        ptemp = strrchr(fileinputbuffer, ';');
        if (ptemp){*ptemp = '\0';}
        }
        if (*fileinputbuffer)
        {
            // Remove spaces
            char *p;
            p = fileinputbuffer;
            RemoveAllSpaces(p);

            // Take line, parse it and put it into our global file structure.
            // Do only for our platform!!!!
            Flat_GlobalArray_Fill(fileinputbuffer);
        }
    } while (inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer)));

	inputfile.close();

    // OK, all entries should be in the global_main array
    // and all the "extra" entries should be in there too..

	// add a "IIS" to the font of any filename
	Flat_GlobalArray_Prepend_UniqueString();

    // 1. loop thru the global array and mark any filenames for duplicates..
    Flat_GlobalArray_Sort_Cols2(TRUE);
    Flat_GlobalArray_ChkDups();

    // 2. sort on #1 cab file, then on #2 section
    Flat_GlobalArray_Sort_Cols2(FALSE);
	if (g_bOutputDetails == TRUE) {Flat_GlobalArray_Print();}

    if (!g_bChangeListOnly)
    {
        //printf("\n\n sorted by cab and section...\n");

        // 3. loop thru the list and create .DDF file
        sprintf(stempstring, "Creating DDF file...%s\n",g_szDDFOutput);
        printf(stempstring);
	    if (g_bCabbing_Flag) {Flat_Create_Output_DDF();}
    }
	
    // Sort on sections
    Flat_GlobalArray_Sort_Cols1a(FALSE);
    //printf("\n\n sorted by section...\n");
	if (g_bDisplayToScreen) Flat_GlobalArray_Print();

    // 4. loop thru the list and create .INF file
    if (g_bChangeListOnly)
    {
        sprintf(stempstring, "Creating CNG file only...%s\n",g_szINFOutput);
        printf(stempstring);
    }
    else
    {
        sprintf(stempstring, "Creating INF file...%s\n",g_szINFOutput);
        printf(stempstring);
    }

	Flat_Create_Output_INF();

	printf("\nTotals:\n");
	Global_TotalCabFileSize_Compute();
	Global_TotalCabFileSize_Print();

    printf("\nErrors/Warnings:\n");
    Flat_GlobalArray_Print_Err();

    Flat_Create_Output_ERR();

    return;
}

// function: SafeCopy
//
// - Copy a string from one to another.
// - This function takes the length of the destination to make sure we don't
//   copy too much.
// - This will always make sure that it is null terminated
//
// Return
//   A pointer to the destination string
//
inline
LPSTR
SafeCopy( LPSTR szDestination, LPSTR szSource, DWORD dwSize)
{
  LPTSTR szRet;

  szRet = strncpy( szDestination, szSource, dwSize); // Copy string
  szDestination[dwSize - 1] = '\0';           // NULL Terminate

  return szRet;
}

// function: SafeCat
//
// - Concatinate one string onto another
// - This function takes the length of the destination to make sure we don't
//   copy too much.
// - This will always make sure that it is null terminated
//
// Return
//   A pointer to the destination string
//
inline
LPSTR
SafeCat( LPSTR szDestination, LPSTR szSource, DWORD dwSize)
{
  LPTSTR szRet;

  szRet = strncat( szDestination, szSource, dwSize); // Copy string
  szDestination[dwSize - 1] = '\0';           // NULL Terminate

  return szRet;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Fill(char fileinputbuffer[])
{
    char *token;
    int  token_count;
    char thetempstring[MAX_STRING];
    char tempstring[255];
    char temperrorwords[255] = "";
    FileReadLine tempentry = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0,0};
    FileReadLine theentry = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0,0};

    strcpy(thetempstring, fileinputbuffer);

    // get the first token
    token = strtok2( thetempstring, delimiters );
    token_count = 0;

    // Add entry to Global Array, convert to all lowercase

    // parse out platforms
    if (token == NULL) {goto Exit_Flat_FillGlobalArray_Main;}
    strcpy(temperrorwords, "x86_NTS_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTS_x86_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}
    strcpy(temperrorwords, "x86_NTW_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTW_x86_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}

    strcpy(temperrorwords, "Win95_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Win95_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}

    strcpy(temperrorwords, "Win98_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Win98_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}

    strcpy(temperrorwords, "NTS_alpha_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTS_alpha_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}
    strcpy(temperrorwords, "NTW_alpha_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTW_alpha_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}

    strcpy(temperrorwords, "Other_os_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Other_os_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}


    // do only for our specified platform!
    if ( (tempentry.NTS_x86_flag==0) && (_stricmp(g_szinput_platform,NTS_X86) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.NTW_x86_flag==0) && (_stricmp(g_szinput_platform,NTW_X86) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}

    if ( (tempentry.Win95_flag==0) && (_stricmp(g_szinput_platform,WIN95) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.Win98_flag==0) && (_stricmp(g_szinput_platform,WIN98) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}


    if ( (tempentry.NTS_alpha_flag==0) && (_stricmp(g_szinput_platform,NTS_ALPHA) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.NTW_alpha_flag==0) && (_stricmp(g_szinput_platform,NTW_ALPHA) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}

    if ( (tempentry.Other_os_flag==0) && (_stricmp(g_szinput_platform,OTHER_OS) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
	
    strcpy(temperrorwords, "Cabfilename");
    strcpy(tempentry.CabFileName, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}
    strcpy(temperrorwords, "INF_Sections");
    strcpy(tempentry.INF_Sections, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}
    strcpy(temperrorwords, "Filename_Full");
    strcpy(tempentry.Filename_Full, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
    strcpy(temperrorwords, "INF_Rename_To");
    strcpy(tempentry.INF_Rename_To, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
    strcpy(temperrorwords, "DDF_Exclude_From_Cab_Flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.DDF_Exclude_From_Cab_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}

    strcpy(temperrorwords, "Do_Not_Show_Error_Flag");
	if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Do_Not_Show_Error_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}

    strcpy(temperrorwords, "Do_Not_Include_file_if_cabEmpty_Flag");
	if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Do_Not_Include_file_if_cabEmpty_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}

    strcpy(temperrorwords, "GetFromSlipStreamDisk");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.GetFromSlipStreamDisk = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
	

    
MoveToGlobals:
    if (!(tempentry.Filename_Full)) {goto Exit_Flat_FillGlobalArray_Main;}
    // Check for wildcards in position array in filename position #2
    int   attr;
    char filename_dir[_MAX_PATH];
    char filename_only[_MAX_FNAME];

    // Get the filename portion
    _splitpath( tempentry.Filename_Full, NULL, filename_dir, filename_only, NULL);
    attr= 0;
    if (_stricmp(filename_only, "*.*") == 0)
        {attr=ALL_FILES;}

    // list thru the files
    intptr_t  hFile;
    finddata datareturn;

    InitStringTable(STRING_TABLE_SIZE);
    if ( FindFirst(tempentry.Filename_Full, attr, &hFile, &datareturn) )
        {
        // check if it's a sub dir
        if (!( datareturn.attrib & _A_SUBDIR))
            {
                // ok we found one.
                // let's add it to our list of stuff to add
                theentry = tempentry;

                char tempstring1[255];
                SafeCopy(tempstring1, filename_dir, sizeof(tempstring1) );
                SafeCat(tempstring1, datareturn.name, sizeof(tempstring1) );
                SafeCopy(theentry.Filename_Full, tempstring1, _MAX_PATH );

                SafeCopy(tempstring1, datareturn.name, sizeof(tempstring1) );
                SafeCopy(theentry.Filename_Name, tempstring1, _MAX_PATH );

                SafeCopy(tempstring1, filename_dir, sizeof(tempstring1) );
                SafeCopy(theentry.Filename_Path, tempstring1, _MAX_PATH );

                SafeCopy(tempstring1, datareturn.name, sizeof(tempstring1) );
                SafeCopy(theentry.DDF_Renamed, tempstring1, _MAX_PATH );

				theentry.FileName_Size = datareturn.size;

                // now take this entry and try to add it to the global array!!!
                Flat_GlobalArray_Add(theentry);
            }

        while(FindNext(attr, hFile, &datareturn))
            {
            // check if it's a sub dir
            if (!(datareturn.attrib & _A_SUBDIR))
                {
                // ok we found one.
                // let's add it to our list of stuff to add
                theentry = tempentry;

                char tempstring1[255];
                SafeCopy(tempstring1, filename_dir, sizeof(tempstring1) );
                SafeCat(tempstring1, datareturn.name, sizeof(tempstring1) );
                SafeCopy(theentry.Filename_Full, tempstring1, _MAX_PATH );

                SafeCopy(tempstring1, datareturn.name, sizeof(tempstring1) );
                SafeCopy(theentry.Filename_Name, tempstring1, _MAX_PATH );

                SafeCopy(tempstring1, filename_dir, sizeof(tempstring1) );
                SafeCopy(theentry.Filename_Path, tempstring1, _MAX_PATH );

                SafeCopy(tempstring1, datareturn.name, sizeof(tempstring1) );
                SafeCopy(theentry.DDF_Renamed, tempstring1, _MAX_PATH );

				theentry.FileName_Size = datareturn.size;

                // now take this entry and try to add it to the global array!!!
                Flat_GlobalArray_Add(theentry);
                }
            }

        }
    else
        // we didn't find the specified file.
        {
			// If this is a file which doesn't get into a cab, then
		    // let's add it to the .inf file section [SourceDisksFiles] later.
		    if (tempentry.DDF_Exclude_From_Cab_Flag)
			{
				    fstream f4;
					f4.open(g_szNOTExistOutput, ios::out | ios::app);

					char fullpath[_MAX_PATH];
					char * pmyfilename;
					char myPath[_MAX_PATH];
					pmyfilename = fullpath;

					// Resolve relative path to real path
					if (0 != GetFullPathName(tempentry.Filename_Full, _MAX_PATH, myPath, &pmyfilename))
					{
						// Take only the filename...

						// achg.htr=1,,1902
						strcpy(tempstring,pmyfilename);
						f4.write(tempstring, strlen(tempstring));
                                                if (tempentry.GetFromSlipStreamDisk == 0)
                                                {
						  strcpy(tempstring,"=0,,50000");
                                                }
                                                else
                                                {
                                                  sprintf(tempstring,"=%d,,50000",g_iSlipStreamDiskID);
                                                }

						f4.write(tempstring, strlen(tempstring));
						f4.write("\n", 1);

						// let's add it to our list of stuff to add
						theentry = tempentry;

						strcpy(theentry.Filename_Full, tempentry.Filename_Full);
						strcpy(theentry.Filename_Name, pmyfilename);

						_splitpath( tempentry.Filename_Full, NULL, theentry.Filename_Path, NULL, NULL);
						//strcpy(theentry.Filename_Path, myPath);
						strcpy(theentry.DDF_Renamed, pmyfilename);
						theentry.FileName_Size = 50000;

						printf(tempentry.Filename_Full);
						printf(".  FileWasNotActuallyFoundToExist1.\n");
						theentry.FileWasNotActuallyFoundToExist = TRUE;

						// now take this entry and try to add it to the global array!!!
						Flat_GlobalArray_Add(theentry);

					}
					f4.close();
			}
			else
			{
				// check if we're not supposed to show errors!
				if (tempentry.Do_Not_Show_Error_Flag == 0)
				{
					// add it to the error list.
					sprintf(tempstring, "ERROR: file not found--> %s --> %s", tempentry.Filename_Full, fileinputbuffer);
					Flat_GlobalArray_Add_Err(tempstring);
				}
			}
        }


    EndStringTable();


Exit_Flat_FillGlobalArray_Main:
        return;

InputParseError:
    sprintf(tempstring, "INFUTIL ERROR: %s should be numeric and is not--> %s", temperrorwords, fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;
InputParseError1:
    sprintf(tempstring, "INFUTIL ERROR: missing platform info--> %s", fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;
InputParseError2:
    sprintf(tempstring, "INFUTIL ERROR: missing %s--> %s", temperrorwords, fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;

}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_GlobalArray_Add(FileReadLine entrytoadd)
{
    FileReadLine Temp = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0,0};

    // check if this value already exists in the globalarary
    if (Flat_GlobalArray_EntryExists(entrytoadd)) return FALSE;
    
    // blankout the array values if any.
    Flat_GlobalArray_Main[Flat_GlobalArrayIndex_Main.nextuse] = Temp;

    // move info into global array
    Flat_GlobalArray_Main[Flat_GlobalArrayIndex_Main.nextuse] = entrytoadd;

    // increment counter to array
    // increment next use space
    ++Flat_GlobalArrayIndex_Main.total;
    ++Flat_GlobalArrayIndex_Main.nextuse;
    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_GlobalArray_EntryExists(FileReadLine theentry)
{
    int matchcount;

    // loop thru the whole list
    for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
    {
        // check if entries are the same.
        matchcount=0;
        if (_strnicmp(Flat_GlobalArray_Main[i0].CabFileName, theentry.CabFileName, lstrlen(theentry.CabFileName) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].INF_Sections, theentry.INF_Sections, lstrlen(theentry.INF_Sections) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].Filename_Full, theentry.Filename_Full, lstrlen(theentry.Filename_Full) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].Filename_Name, theentry.Filename_Name, lstrlen(theentry.Filename_Name) + 1) == 0 )
            {++matchcount;}
        if (matchcount == 4)
        {
            // we found a match!!! "WARNING: file already included"
            return TRUE;
        }
    }
    //. no matches... return FALSE.
    return FALSE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int IsThisStringInHere(LPTSTR  lpTemp, char szStringToCheck[])
{
    int     bFlag               = FALSE;

    // Lookup sections to see if they exists in ini file.
    if (*lpTemp != '\0')
        {
        // loop thru and process results
        bFlag = FALSE;
        while (*lpTemp)
            {
            // check if our section name is in there.
            if (_strnicmp(szStringToCheck, lpTemp, lstrlen(lpTemp) + 1) == 0 )
                {bFlag = TRUE;}
            lpTemp += (lstrlen(lpTemp) + 1);
            }

        // Check if our section was in there
        if (bFlag != TRUE)
            {return FALSE;}

        }

    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_DDFDoesThisFileCabAlreadyExists(int processeduptill)
{
    int i0;

    char CompareTo_cab[100];
    char CompareTo_fullfilename[100];

    SafeCopy(CompareTo_cab, Flat_GlobalArray_Main[processeduptill].CabFileName, sizeof(CompareTo_cab) );
    SafeCopy(CompareTo_fullfilename, Flat_GlobalArray_Main[processeduptill].Filename_Full, sizeof(CompareTo_fullfilename) );

    for(i0=0;i0<processeduptill;i0++)
        {
        // check if global value has already been processed.
        // check if the cab is the same
        // check if the dir is the same
        // check if the filename is the same
        if (_stricmp(Flat_GlobalArray_Main[i0].CabFileName, CompareTo_cab) == 0)
            {
            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Full,CompareTo_fullfilename) == 0)
                {
                // if they both match, then shoot that means that we already printed this out.
                return TRUE;
                }
            }
        }

    return FALSE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void ShowHelp()
{
    printf("InfUtil2 - prints out file date/time,\n");
    printf("           or print out watch list from <input file> list,\n");
    printf("           or creates .ddf and .inf files from <input file> list\n");
    printf("----------------------------------------------------------------\n");
    printf("  Usage:\n");
    printf("       infutil2 /? /F [/1 /2 /3] [/4:<filename>] [/A /B] /D /N /S? /T??? /X <input file> <section name>\n\n");
	printf("  Params:\n");
    printf("       /? show this stuff\n");
    printf("       /F show <input file> format help\n");
    printf("      Flags for Date/Time use:\n");
    printf("       /1 print out <input file>'s date as number\n");
    printf("       /2 print out <input file>'s time as number\n");
    printf("       /3 print out <input file>'s date and time as big number\n");
    printf("      Flags for compare file list timestamp use:\n");
    printf("       /4: compare dir in <filename> with <input file>'s timestamp.  if dir has newer files, then set ERRORLEVEL=1\n");
    printf("      Flags for change list use:\n");
    printf("       /A produce a list of files to watch for changes (if files in list change then re-build cabs) from <input file> list\n");
    printf("       /B produce a list of files to watch for changes (includes files which aren't in cabs) from <input file> list\n");
    printf("      Flags for .ddf .inf use:\n");
    printf("       /D don't show details\n");
    printf("       /I ignore /T tag (there'll be no prefix)\n");
    printf("       /SslipstreamSourceDisksNames file id -- used for SP1 slipstream to point loose files to file specified in /S\n");
    printf("         used in sync with <input file> change.  look in .ddf file.\n");
    printf("       /Ttag Appends tag_ to the beginning of all filenames\n");
    printf("       /N Produce INF File which will not require .ddf file (meaning no cabs).(untested) \n");
    printf("       /X Display output for debug\n");
    printf("       <input file> is a file name.\n");
    printf("       <section name> is either %s,%s,%s,%s,%s,%s,%s.\n", NTS_X86, NTW_X86, WIN95, WIN98, NTS_ALPHA, NTW_ALPHA, OTHER_OS);
    printf("\n");
    printf("Example:\n");
    printf("       infutil2.exe /3 myfile.txt\n");
    printf("           Will print out myfile.txt's date/time as yymmddhhmmss.\n");
    printf("       infutil2.exe /Tcore inifile.ini %s\n", NTS_X86);
    printf("           Will produce a infutil2.ddf,inf,cng files. the .ddf and .inf files will create cabs with files beginning with 'core_'\n");
    printf("       infutil2.exe /C inifile.ini %s\n", NTS_X86);
    printf("           Will only produce a infutil2.cng file with a list of files to watch for changes in.\n");
    return;
}

void ShowFormat(void)
{
    printf("Format for <input file>:\n");
    printf("       position 1 = nts_x86 flag\n");
    printf("                2 = ntw_x86 flag\n");
    printf("                3 = win95 flag\n");
    printf("                4 = win98 flag\n");
    printf("                5 = nts_alpha flag\n");
    printf("                6 = ntw_alpha flag\n");
    printf("                7 = other_os flag\n");
    printf("                8 = cabfilename\n");
    printf("                9 = inf section\n");
    printf("               10 = filename (wildcards okay)\n");
    printf("               11 = .INF rename to\n");
    printf("               12 = .DDF exclude from cab flag\n");
    printf("               13 = Do Not Produce Error if Empty\n");
    printf("               14 = Do Not include this file if the cab is empty!\n");
    printf("\n");
    printf("Example of format for <input file>:\n");
    printf("       1,1,1,1,0,0,0,core.cab,core_files_sys,x86\\SysFile1.dll,,1,,\n");
    printf("       1,1,1,1,0,0,0,core.cab,core_files_sys,x86\\SysFile2.dll,,1,,\n");
    printf("       0,0,0,0,1,1,0,core.cab,core_files_sys,Alpha\\SysFile1.dll,,1,,\n");
    printf("       0,0,0,0,1,1,0,core.cab,core_files_sys,Alpha\\SysFile2.dll,,1,,\n");
    printf("       1,0,0,0,0,0,0,core.cab,product_files,x86\\ProdSrv.dll,,1,,\n");
    printf("       0,1,0,0,0,0,0,core.cab,product_files,x86\\ProdWks.dll,,1,,\n");
    printf("       0,0,1,1,0,0,0,core.cab,product_files,x86\\Prod95.dll,,1,,\n");
    printf("       0,0,0,0,1,0,0,core.cab,product_files,Alpha\\ProdSrvA.dll,,1,,\n");
    printf("       0,0,0,0,0,1,0,core.cab,product_files,Alpha\\ProdWksA.dll,,1,,\n");
    printf("       1,1,1,1,0,0,0,core.cab,product_files,x86\\Prodx86.dll,,1,,\n");
    printf("       0,0,0,0,1,1,0,core.cab,product_files,Alpha\\ProdAlph.dll,,1,,\n");
    printf("       1,1,1,1,0,0,0,core.cab,product_files2,x86\\Ext\\*.*,,,,\n");
    printf("       0,0,0,0,1,1,0,core.cab,product_files2,Alpha\\Ext\\*.*,,,,\n");
    printf("       1,1,1,1,1,1,0,core.cab,product_files2,16bit\\*.*,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir1,content\\index.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir1,content\\readme.txt,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir1,content\\default.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir2,content\\content1.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir2,content\\content2.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir2,content\\content3.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir2,content\\content4.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,docs.cab,help_files_dir1,help\\*.*,,,,\n");
    printf("       1,1,1,1,1,1,0,docs.cab,help_files_dir2,help\\other\\*.*,,,,\n");
    printf("       1,1,1,1,1,1,0,docs.cab,help_files_dir3,help\\support\\*.txt,,,,\n");
    printf("       1,1,1,1,1,1,0,docs.cab,help_files_dir4,help\\other\\*.xls,,,,\n");
    printf("\n");
    printf("Example of use:\n");
    printf("       infutil2.exe -Tcore -D abovefile.csv %s\n", NTS_X86);
    printf("       Will produce .ddf,inf,err,cat,not and infutil2.cng files. Figure it out.\n");
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int DoesFileExist(char *input_filespec)
{
    if (GetFileAttributes(input_filespec) == -1)
    {
        return(FALSE);
    }
    return (TRUE);
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void GetPath(char * input_filespec, char * path, char * fs)
{
    char filespec[100];
    char * p;
    struct _stat s;

    strcpy(filespec, input_filespec);

        /* if filespec is a directory, interpret it to mean dir\*.* */
    if (_stat(filespec, &s) == 0 && s.st_mode & S_IFDIR)
        {
            /* root is special case */
        if ( (*filespec == '\\' && *(filespec+1) == '\0') ||
                 (*(filespec+1) == ':' && *(filespec+2) == '\\' && *(filespec+3)=='\0'))
            strcat(filespec, "*.*");
        else
            strcat(filespec, "\\*.*");
        }

        /* search string from end to beginning for back slash */
    p=filespec+strlen(filespec)-1;
    for(; p>filespec && *p != '\\' && *p != ':'; p--);
        /* is it a drive or path */
    if ( *p=='\\' || *p==':')
        {
        strncpy(path, filespec, DIFF(p-filespec)+1);
        path[p-filespec+1]='\0';
        strcpy(fs, p+1);
        }
    else /* no drive, path */
        {
            /* yep, no path */
        path[0]='\0';
        strcpy(fs, filespec);
        }

} /* GetPath */


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int strltrim(LPSTR & thestring)
{
    char * p = NULL;

    p = thestring;

    // check for spaces to the right
    if (*p ==' ')
        {
        while (*p == ' ')
            {p += (lstrlen((char*) *p) + 1);}

        thestring = p;
        printf("%s testing..", p);
        return TRUE;
        }
    return FALSE;
}



//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void MakeDirIfNeedTo(char thestring[])
{
    char *p = NULL;
    char tempstring[255];
    // Check the string to see if there are any "\"'s in the string
    // if there are then let's remove the filename and make the directory
    if (strchr(thestring, '\\') != NULL)
        {
        strcpy(tempstring, thestring);
        // remove the filename
        p = strrchr(tempstring, '\\');
        if(p){*p = '\0';}

        // ok now we have the path
        // let's create the directory
        _mkdir(tempstring);

        }
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void GetThisModuleName(void)
{
    char    szfilename_only[_MAX_FNAME];
    char    szPath[_MAX_PATH];
    // Get the path
    if (GetModuleFileName(NULL, szPath, _MAX_PATH))
    {
      // split up this path and take filename only
      _splitpath( szPath, NULL, NULL, szfilename_only, NULL);

      // set global variable with it
      strcpy(g_szModuleFilename, szfilename_only);
    }
    return;
}

void Flat_GlobalArray_Prepend_UniqueString(void)
{
    //char Filename_Full[_MAX_PATH];
    //char Filename_Name[_MAX_FNAME];
    //char Filename_Path[_MAX_PATH];
    //char DDF_Renamed[_MAX_PATH];
    //char INF_Rename_To[_MAX_FNAME];

    char filename_only[_MAX_FNAME];
    char filename_ext[_MAX_EXT];
	char NewFilename[_MAX_FNAME];

	int i0 =0;
	for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
	{
		if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 0)
		{
			// Tack on the IIS Tag.
			_splitpath( Flat_GlobalArray_Main[i0].Filename_Full, NULL, NULL, filename_only, filename_ext);
			if (filename_ext)
                {sprintf(NewFilename, "%s%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s%s", g_szFilenameTag, filename_only);}

			// re-create the full name
			//sprintf(Flat_GlobalArray_Main[i0].Filename_Full, "%s%s", Flat_GlobalArray_Main[i0].Filename_Path, NewFilename);
			// re-create the filename only
			//strcpy(Flat_GlobalArray_Main[i0].Filename_Name, NewFilename);

			_splitpath( Flat_GlobalArray_Main[i0].DDF_Renamed, NULL, NULL, filename_only, filename_ext);
			if (filename_ext)
				{sprintf(NewFilename, "%s%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s%s", g_szFilenameTag, filename_only);}

			// re-create the filename
			strcpy(Flat_GlobalArray_Main[i0].DDF_Renamed, NewFilename);

			/*
			_splitpath( Flat_GlobalArray_Main[i0].INF_Rename_To, NULL, NULL, filename_only, filename_ext);
			if (filename_only)
			{
			if (filename_ext)
				{sprintf(NewFilename, "%s%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s%s", g_szFilenameTag, filename_only);}
			// re-create the filename
			strcpy(Flat_GlobalArray_Main[i0].INF_Rename_To, NewFilename);
			}
			*/
		}
	}
}


//-------------------------------------------------------------------
//  purpose: check for duplicate filenames
//-------------------------------------------------------------------
void Flat_GlobalArray_ChkDups(void)
{
    int i0 =0;
    int i1 =0;
    int i3 = 0;
    char filetemp[255];
    char filetempwhole[255];
    int theflag = FALSE;
    char checkagainst[255];
    int foundtheflag2 = FALSE;
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        if (Flat_IsFileNameDup(i0))
            {
            printf (".");
            i1 = 0;
            // if the file exists outside a cab, then do not rename.
            // only rename files which exist in the cab.
            if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 0)
            {
                do
                {
                    theflag = FALSE;
                    // Give it a new name.
                    // then check if the name already exists.
                    i1++;
if (g_bCabbing_Flag != TRUE)
{
#ifdef USENEW
					if (i1 == 1)
					{
						// Count how many directory levels in There.
						int iDirLevelCount = 0;
						int z1 = 0;
						iDirLevelCount = ReturnDirLevelCount(Flat_GlobalArray_Main[i0].Filename_Full);

						SafeCopy(filetemp, Flat_GlobalArray_Main[i0].Filename_Path, sizeof(filetemp) );
						if (iDirLevelCount >=1)
						{
							for( z1 = 0; z1 < iDirLevelCount;z1++)
								{SafeCat(filetemp, "..\\", sizeof(filetemp) );}
						}
						
						/*

						strcpy(filetemp, "");
						if (iDirLevelCount >=1)
						{
							for( z1 = 0; z1 < iDirLevelCount;z1++)
								{strcat(filetemp, "..\\");}
						}
						strcat(filetemp, Flat_GlobalArray_Main[i0].Filename_Path);						
						*/

						// add the filename
						SafeCat(filetemp, Flat_GlobalArray_Main[i0].Filename_Name, sizeof(filetemp) );
						
						SafeCopy(filetempwhole,filetemp, sizeof(filetempwhole) );
					}
					else
					{
						sprintf(filetemp, "%s%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Full, i1);
						SafeCopy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path, sizeof(filetempwhole) );
						SafeCat(filetempwhole, filetemp, sizeof(filetempwhole) );
					}
#else
                    sprintf(filetemp, "%s%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Name, i1);
                    SafeCopy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path, sizeof(filetempwhole) );
                    SafeCat(filetempwhole, filetemp, sizeof(filetempwhole) );
#endif
}
else
{
                    sprintf(filetemp, "%s%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Name, i1);
                    SafeCopy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path, sizeof(filetempwhole) );
                    SafeCat(filetempwhole, filetemp, sizeof(filetempwhole) );
}
                
                    // check if the file exists..

                    // check if it already exists in our list...
                    SafeCopy(checkagainst, filetempwhole, sizeof(checkagainst));
                    foundtheflag2= FALSE;

                    for (i3=0;i3<Flat_GlobalArrayIndex_Main.total;i3++)
                        {
                        if (i3 != i0)
                            {
                            if (_stricmp(Flat_GlobalArray_Main[i3].Filename_Name, filetemp) == 0)
                                {foundtheflag2= TRUE;}
                            else
                                {
                                if (_stricmp(Flat_GlobalArray_Main[i3].DDF_Renamed, filetemp) == 0)
                                    {foundtheflag2= TRUE;}
                                }
                            }
                        }

                    if (foundtheflag2 == FALSE)
                    {

                    // check if it already exists in the filesystem...
                    int   attr = 0;
                    intptr_t  hFile = 0;
                    finddata datareturn;
                    InitStringTable(STRING_TABLE_SIZE);
                    if ( FindFirst(filetempwhole, attr, &hFile, &datareturn) )
                        {
                        // shoot that blows, it already exists
                        // do it again.
                        theflag = FALSE;
                        }
                    else
                        {
                            theflag = TRUE;
                        }

                    }

                } while (theflag == FALSE);
            // Add to the ddf renamedfile place
            SafeCopy(Flat_GlobalArray_Main[i0].DDF_Renamed, filetemp, _MAX_PATH);
            }
            
            }
        }
    printf ("\n");
    return;
}


//-------------------------------------------------------------------
//  purpose: check for duplicate filenames in filename column
//-------------------------------------------------------------------
int Flat_IsFileNameDup(int indextocheck)
{
	int iReturn = FALSE;
    int i0;
    char checkagainst[255];
    char checkagainst2[255];

    // check for exact duplicate.
    // if it is then we can't have any of these
    // Return false, because we will remove this entry later
    // it should return false, because the files are identical and do not need to be renamed.
    SafeCopy(checkagainst, Flat_GlobalArray_Main[indextocheck].Filename_Full, sizeof(checkagainst) );
    SafeCopy(checkagainst2, Flat_GlobalArray_Main[indextocheck].Filename_Name, sizeof(checkagainst2) );
    for (i0=0;i0<Flat_GlobalArrayIndex_Main.total;i0++)
    //for (i0=0;i0<indextocheck;i0++)
        {
		iReturn = FALSE;
        if (i0 != indextocheck)
            {
			/*
			if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst2) == 0)
			{
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, "global.asa") == 0)
				{
				printf(":");
				printf(Flat_GlobalArray_Main[i0].Filename_Full);
				printf("(");printf(Flat_GlobalArray_Main[i0].Filename_Name);printf(")");
				printf("[");printf(Flat_GlobalArray_Main[i0].DDF_Renamed);printf("]");

				printf(":");
				printf(Flat_GlobalArray_Main[indextocheck].Filename_Full);
				printf("(");printf(Flat_GlobalArray_Main[indextocheck].Filename_Name);printf(")");
				printf("[");printf(Flat_GlobalArray_Main[indextocheck].DDF_Renamed);printf("]");
				printf("\n");
				}
			}
			*/

            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Full, checkagainst) == 0)
                {
				// We have a duplicate which we will ignore!
				//printf(Flat_GlobalArray_Main[i0].Filename_Full);
				//printf(".  Duplicate.1.!!!!\n");
				_stricmp(Flat_GlobalArray_Main[indextocheck].DDF_Renamed, Flat_GlobalArray_Main[i0].DDF_Renamed);
				iReturn = FALSE;
				goto Flat_IsFileNameDup_Exit;
				}
            else
                {
                if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst2) == 0)
                    {
						// We have  a duplicate, check if this one has already been renamed though.
						if (_stricmp(Flat_GlobalArray_Main[i0].DDF_Renamed, checkagainst2) == 0)
						{
							//printf(".  Duplicate.2.!!!!\n");
							iReturn = TRUE;
							goto Flat_IsFileNameDup_Exit;
						}
						else
						{
							// check if what we are renaming indextocheck to, is the same as DDF_Renamed...
							if (_stricmp(Flat_GlobalArray_Main[i0].DDF_Renamed, Flat_GlobalArray_Main[indextocheck].DDF_Renamed) == 0)
							{
								//(".  Duplicate.3.!!!!\n");
								iReturn = TRUE;
								goto Flat_IsFileNameDup_Exit;
							}
						}

                    }

                }
            }

		// go on to the next one....
        }

    /*
    // Check for filename duplicate only
    strcpy(checkagainst, Flat_GlobalArray_Main[indextocheck].Filename_Name);
    for (i0=0;i0<Flat_GlobalArrayIndex_Main.total;i0++)
        {
        if (i0 != indextocheck)
            {
            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst) == 0)
                {return TRUE;}
            }
        }
        */
Flat_IsFileNameDup_Exit:
    return iReturn;
}


//-------------------------------------------------------------------
//  purpose: sort on CabFileName, then on Filename_Path
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols2(BOOL bDescendFlag)
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    int swapflag;

    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {
            swapflag = FALSE;
            result = _stricmp(Flat_GlobalArray_Main[i].CabFileName, Flat_GlobalArray_Main[j].CabFileName);

            if (bDescendFlag)
            {
                if (result < 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Path, Flat_GlobalArray_Main[j].Filename_Path);
                            if (result < 0)
								{swapflag = TRUE;}
							else
							{
								if (result ==0)
								result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
								if (result < 0)
									{swapflag = TRUE;}
							}
                        }
                    }
            }
            else
            {
                // check if larger
                if (result > 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Path, Flat_GlobalArray_Main[j].Filename_Path);
                            // check if larger
                            if (result > 0)
								{swapflag = TRUE;}
							else
							{
								if (result ==0)
								result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
								if (result > 0)
									{swapflag = TRUE;}
							}
                        }
                    }
            }


            if (swapflag == TRUE)
                {
                inorder = FALSE;

                // do the swap
                // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;
                }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}

//-------------------------------------------------------------------
//  purpose: sort on INF_Sections only
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols1()
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {

            result = _stricmp(Flat_GlobalArray_Main[i].INF_Sections, Flat_GlobalArray_Main[j].INF_Sections);
            if (result > 0)
            {
                inorder = FALSE;

                // do the swap
                 // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;

            }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}


//-------------------------------------------------------------------
//  purpose: sort on INF_Sections then on filename
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols1a(BOOL bDescendFlag)
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    int swapflag;

    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {
            swapflag = FALSE;
            result = _stricmp(Flat_GlobalArray_Main[i].INF_Sections, Flat_GlobalArray_Main[j].INF_Sections);

            if (bDescendFlag)
            {
                if (result < 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
                            if (result < 0){swapflag = TRUE;}
                        }
                    }
            }
            else
            {
                // check if larger
                if (result > 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
                            // check if larger
                            if (result > 0){swapflag = TRUE;}
                        }
                    }
            }


            if (swapflag == TRUE)
                {
                inorder = FALSE;

                // do the swap
                // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;
                }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}



//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Print(void)
{
    int  i0;
    int  total;
    char bigtemp[20];

    total = Flat_GlobalArrayIndex_Main.total;

    for( i0 = 0; i0 < total;i0++)
        {
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTS_x86_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTW_x86_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Win95_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Win98_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTS_alpha_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTW_alpha_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Other_os_flag);
        printf (bigtemp); printf(",");

        printf(Flat_GlobalArray_Main[i0].CabFileName);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].INF_Sections);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Full);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Name);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Path);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].DDF_Renamed);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].INF_Rename_To);
        printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag);
        printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Do_Not_Show_Error_Flag);
		printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Do_Not_Include_file_if_cabEmpty_Flag);
		printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].GetFromSlipStreamDisk);
		printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].FileName_Size);
		printf (bigtemp);
		printf ("\n");
        }

    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_Create_Output_INF(void)
{
    int i0;
    fstream f;
	fstream f2;
    fstream f3;
    fstream f4;
    fstream f5;
    char last_section[255];
    char this_section[255];
    char tempstring[255];
    char fullpath[_MAX_PATH];
    int Changed_f4 = FALSE;
    int Changed_f5 = FALSE;

    if (!g_bChangeListOnly)
    {
	    f.open(g_szINFOutput, ios::out);
        f3.open(g_szCATOutput, ios::out);
    }

    f4.open(g_szCNGOutput, ios::out);
    f5.open(g_szLOCOutput, ios::out);


if (g_bCabbing_Flag == TRUE)
{
	// Produce .inf file for use with .ddf file
	// for generating cabs!!!
	// ----------------------------------------
	
	// Produce the top half -- the sections
	// bottom half -- producted by diamond using.ddf file
	// ------------------------------------
    strcpy(last_section, " ");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        Changed_f4 = FALSE;
        Changed_f5 = FALSE;
        strcpy(this_section, Flat_GlobalArray_Main[i0].INF_Sections);

        // For each new section change.
        if (_stricmp(this_section, last_section) != 0)
        {
            if (!g_bChangeListOnly)
            {
                // print out new section stuff
                f.write("\n", 1);
                sprintf(tempstring, "[%s]\n", this_section);
                f.write (tempstring, strlen(tempstring));
            }

            strcpy(last_section, this_section);
        }

		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{
            // write it out to the .cat file
//            strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
//            // take out trailing spaces.
//            f3.write(tempstring, strlen(tempstring));

            TCHAR * pmyfilename;
            pmyfilename = fullpath;
            TCHAR myPath[_MAX_PATH];
            // Resolve relative path to real path
            if (0 != GetFullPathName(Flat_GlobalArray_Main[i0].Filename_Full, _MAX_PATH, myPath, &pmyfilename))
            {
                if (!g_bChangeListOnly)
                {
                    // should look like this
                    // <HASH>d:\mydir\myfile=d:\mydir\myfile
                    SafeCopy(tempstring,"<HASH>",sizeof(tempstring));
                    f3.write(tempstring, strlen(tempstring));

                    SafeCopy(tempstring,myPath,sizeof(tempstring));
                    f3.write(tempstring, strlen(tempstring));

                    SafeCopy(tempstring,"=",sizeof(tempstring));
                    f3.write(tempstring, strlen(tempstring));

                    SafeCopy(tempstring,myPath,sizeof(tempstring));
                    f3.write(tempstring, strlen(tempstring));
                }

                if (g_bChangeListOnly2)
                {
                    // write out entry for change list.
                    SafeCopy(tempstring,myPath,sizeof(tempstring));
                    f4.write(tempstring, strlen(tempstring));
                    Changed_f4 = TRUE;
                }
                else if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 0)
                {
                    // write out entry for change list
                    SafeCopy(tempstring,myPath,sizeof(tempstring));
                    f4.write(tempstring, strlen(tempstring));
                    Changed_f4 = TRUE;
                }

                if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 1)
                {
                    // write out entry for localization (list of files in binaries dir outside of cab)
                    SafeCopy(tempstring,pmyfilename,sizeof(tempstring));
                    f5.write(tempstring, strlen(tempstring));
                    Changed_f5 = TRUE;
                }

            }

			// Check if this file has the rename stuff set and additional info there,
			// don't write the \n until past this part..
			if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				{
				// write out the filename!
				// print out the filename
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					{
					    SafeCopy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name,sizeof(tempstring));
                        if (!g_bChangeListOnly)
                        {
					        f.write (tempstring, strlen(tempstring));
                        }
                        // append on overwrite all the time
                        // notice the two commas!
                        //f.write (",,4",3);
					}
				else
					{
					    // rename to:
					    SafeCopy(tempstring, Flat_GlobalArray_Main[i0].Filename_Name,sizeof(tempstring));
                        if (!g_bChangeListOnly)
                        {
					        f.write (tempstring, strlen(tempstring));
                        }
					    // rename from:
					    SafeCopy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed,sizeof(tempstring));
                        if (!g_bChangeListOnly)
                        {
					        f.write (",",1);
					        f.write (tempstring, strlen(tempstring));
                            // append on overwrite all the time
                            //f.write (",4",2);
                        }
					}
				}
			else
				{
				    // the rename flag was set and the filename is in there.
				    // format:  rename to, rename from
                    if (!g_bChangeListOnly)
                    {

				        // rename to:
				        SafeCopy(tempstring, Flat_GlobalArray_Main[i0].INF_Rename_To,sizeof(tempstring));
				        f.write (tempstring, strlen(tempstring));

				        // rename from:
				        SafeCopy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed,sizeof(tempstring));
				        f.write (",",1);
				        f.write (tempstring, strlen(tempstring));

                        // append on overwrite all the time
                        //f.write (",4",2);
                    }
				}
		}

        // ok, now it's kool to write this part.
        f.write("\n", 1);
        f3.write("\n", 1);
            if (Changed_f4)
            {
                f4.write("\n", 1);
            }
            if (Changed_f5)
            {
                f5.write("\n", 1);
            }
        }

        if (!g_bChangeListOnly)
        {
	        f.close();
            f3.close();
        }
        f4.close();
        f5.close();
}
else
{
	// Produce .inf file for use without anything else!!!
	// no need corresponding .ddf file for these!!!
	// ----------------------------------------

	// Produce the top half -- the sections
	// ------------------------------------
    strcpy(last_section, " ");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        strcpy(this_section, Flat_GlobalArray_Main[i0].INF_Sections);

        // For each new section change.
        if (_stricmp(this_section, last_section) != 0)
            {
            if (!g_bChangeListOnly)
            {
                // print out new section stuff
                f.write("\n", 1);
                sprintf(tempstring, "[%s]\n", this_section);
                f.write (tempstring, strlen(tempstring));
            }

            strcpy(last_section, this_section);
            }

#ifdef USENEW
		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{
			// Check if this file has the rename stuff set and additional info there,
			// don't write the \n until past this part..
			if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				{
				// write out the filename!
				// print out the filename
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					{
                        if (!g_bChangeListOnly)
                        {
					        SafeCopy(tempstring, Flat_GlobalArray_Main[i0].Filename_Name, sizeof(tempstring)/sizeof(tempstring[0]) );
					        f.write (tempstring, strlen(tempstring));
                        // append on overwrite all the time
                        // notice the two commas!
                        //f.write (",,4",3);
                        }

					}
				else
					{
                        if (!g_bChangeListOnly)
                        {
					        // rename to:
					        SafeCopy(tempstring, Flat_GlobalArray_Main[i0].Filename_Name, sizeof(tempstring)/sizeof(tempstring[0]) );
					        f.write (tempstring, strlen(tempstring));

					        // rename from:
					        SafeCopy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed, sizeof(tempstring)/sizeof(tempstring[0]) );
					        f.write (",",1);
					        f.write (tempstring, strlen(tempstring));
                            // append on overwrite all the time
                            //f.write (",4",2);
                        }
					}
				}
			else
				{
                    if (!g_bChangeListOnly)
                    {
                        // the rename flag was set and the filename is in there.
				        // format:  rename to, rename from

				        // rename to:
				        SafeCopy(tempstring, Flat_GlobalArray_Main[i0].INF_Rename_To, sizeof(tempstring)/sizeof(tempstring[0]) );
				        f.write (tempstring, strlen(tempstring));

				        // rename from:
				        SafeCopy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed, sizeof(tempstring)/sizeof(tempstring[0]) );
				        f.write (",",1);
				        f.write (tempstring, strlen(tempstring));
                        // append on overwrite all the time
                        //f.write (",4",2);
                    }
				}
		}
#else
            if (!g_bChangeListOnly)
            {
			    // write out the filename!
			    // like this: filename.txt, inetsrv\test\test\filename.txt
			    SafeCopy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name, sizeof(tempstring)/sizeof(tempstring[0]) );
			    f.write (tempstring, strlen(tempstring));
			    SafeCopy(tempstring, ",", sizeof(tempstring)/sizeof(tempstring[0]) );
			    f.write(tempstring, strlen(tempstring));
                strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Full, sizeof(tempstring)/sizeof(tempstring[0]) );
                f.write (tempstring, strlen(tempstring));
            }
#endif

            if (!g_bChangeListOnly)
            {
		    f.write("\n", 1);
            }
        }

	// Produce the bottom half -- the sections
	// ------------------------------------
	// use f2 for some other batch processing.
    if (!g_bChangeListOnly)
    {
 	    f2.open(g_szLSTOutput, ios::out);

	    //[SourceDisksNames]
	    //; file names and associated disks
	    //; diskid = description,tagfile,unused,subdir
	    //0="Setup Files","",0
	    f.write("\n\n", 2);
	    SafeCopy(tempstring, "[SourceDisksNames]\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, ";Filenames and asociated disks\n", sizeof(tempstring)/sizeof(tempstring[0]) );
	    f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, ";diskid = description,tagfile,unused,subdir\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	    FillGlobalUniqueDirList();
	    //0="Setup Files","",inetsrv
	    //1="Setup Files","",inetsrv\help
	    //2="Setup Files","",inetsrv\help\testing
int i9;
	    for( i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	    {
		    // REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		    char tempdir[_MAX_PATH];
		    char *temppointer = NULL;
		    SafeCopy(tempdir, Flat_GlobalUniqueDirList[i9], sizeof(tempstring)/sizeof(tempstring[0]) );
		    temppointer = strrchr(tempdir, '\\');
		    if (temppointer) { (*temppointer) = '\0';}

		    sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		    f.write(tempstring, strlen(tempstring));
	    }
#else
	    SafeCopy(tempstring, "0 = \"Setup Files\", \"\",0, \"\"\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, "\n\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
#endif

	    //[SourceDisksNames.x86]
	    //; file names and associated disks
	    //; diskid = description,tagfile,unused,subdir
	    //0="Setup Files","",0
	    f.write("\n\n", 2);
	    SafeCopy(tempstring, "[SourceDisksNames.x86]\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, ";Filenames and asociated disks\n", sizeof(tempstring)/sizeof(tempstring[0]) );
	    f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, ";diskid = description,tagfile,unused,subdir\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	    FillGlobalUniqueDirList();
	    //0="Setup Files","",inetsrv
	    //1="Setup Files","",inetsrv\help
	    //2="Setup Files","",inetsrv\help\testing
	    for(i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	    {
		    // REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		    char tempdir[_MAX_PATH];
		    char *temppointer = NULL;
		    SafeCopy(tempdir, Flat_GlobalUniqueDirList[i9], sizeof(tempstring)/sizeof(tempstring[0]) );
		    temppointer = strrchr(tempdir, '\\');
		    if (temppointer) { (*temppointer) = '\0';}

		    sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		    f.write(tempstring, strlen(tempstring));
	    }
#else
	    SafeCopy(tempstring, "0 = \"Setup Files\", \"\",0, \"\",\i386\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, "\n\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
#endif

	    //[SourceDisksNames.Alpha]
	    //; file names and associated disks
	    //; diskid = description,tagfile,unused,subdir
	    //0="Setup Files","",0
	    f.write("\n\n", 2);
	    SafeCopy(tempstring, "[SourceDisksNames.Alpha]\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, ";Filenames and asociated disks\n", sizeof(tempstring)/sizeof(tempstring[0]) );
	    f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, ";diskid = description,tagfile,unused,subdir\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	    FillGlobalUniqueDirList();
	    //0="Setup Files","",inetsrv
	    //1="Setup Files","",inetsrv\help
	    //2="Setup Files","",inetsrv\help\testing
	    for(i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	    {
		    // REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		    char tempdir[_MAX_PATH];
		    char *temppointer = NULL;
		    SafeCopy(tempdir, Flat_GlobalUniqueDirList[i9], sizeof(tempstring)/sizeof(tempstring[0]) );
		    temppointer = strrchr(tempdir, '\\');
		    if (temppointer) { (*temppointer) = '\0';}

		    sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		    f.write(tempstring, strlen(tempstring));
	    }
#else
	    SafeCopy(tempstring, "0 = \"Setup Files\", \"\",0, \"\",\Alpha\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, "\n\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
#endif

	    //; filename_on_source = diskid,subdir,size,checksum,spare,spare
	    //[SourceDisksFiles]
	    //_default.pif = 1,,1024,,,,,1,3
	    SafeCopy(tempstring, "; filename_on_source = diskid,subdir,size,checksum,spare,spare\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));
	    SafeCopy(tempstring, "[SourceDisksFiles]\n", sizeof(tempstring)/sizeof(tempstring[0]) );
        f.write(tempstring, strlen(tempstring));

        for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
            {
		    // filename and directory
		    // filename.txt = 0,subdirectory
		    //sprintf(tempstring, "%s = 0\n", Flat_GlobalArray_Main[i0].Filename_Full);
#ifdef USENEW
		    if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		    {
			    // Check if this file has the rename stuff set and additional info there,
			    // don't write the \n until past this part..
			    if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				    {
				    // write out the filename!
				    // print out the filename

//[SourceDisksFiles]
//..\test1\cfw.pdb=2,,2
				    if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					    {
					    int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
					    sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].Filename_Name, indexmatch);
					    f.write (tempstring, strlen(tempstring));
					    }
				    else
					    {
					    // rename from:
					    int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
					    sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].DDF_Renamed,indexmatch);
					    f.write (tempstring, strlen(tempstring));
					    }
				    }
			    else
				    {
				    // the rename flag was set and the filename is in there.
				    // rename from:
				    int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
				    sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].DDF_Renamed,indexmatch);
				    f.write (tempstring, strlen(tempstring));
				    }
		    }
		    f.write("\n", 1);
#else
		    sprintf(tempstring, "%s\n", Flat_GlobalArray_Main[i0].Filename_Full);
		    f.write(tempstring, strlen(tempstring));
#endif
    //if (strcmp(Flat_GlobalArray_Main[i0].Filename_Path, "") == 0)
    //  {sprintf(tempstring, "%s;.\n", Flat_GlobalArray_Main[i0].Filename_Full);}
    //else
    //  {sprintf(tempstring, "%s;%s\n", Flat_GlobalArray_Main[i0].Filename_Full, Flat_GlobalArray_Main[i0].Filename_Path);}

		    //sprintf(tempstring, "%s\\%s;%s\n", g_szCurrentDir,Flat_GlobalArray_Main[i0].Filename_Full,Flat_GlobalArray_Main[i0].Filename_Full);
		    sprintf(tempstring, "%s\\%s\n", g_szCurrentDir,Flat_GlobalArray_Main[i0].Filename_Full);
		    f2.write(tempstring, strlen(tempstring));
            }
	    f2.close();
    }
    f.close();
    }
    return;
}


//-------------------------------------------------------------------
//  purpose: ok, loop thru the array and create the ddf details...
//-------------------------------------------------------------------
void Flat_Create_Output_DDF(void)
{
    fstream f;
    char thefilename[255];
    int i0;
    int i1;
    int i2;
    int i3;

    char last_cab[50];
    char last_sourcedir[255];
    char this_cab[50];
    char this_sourcedir[255];

    char tempstring[255];

    // used for list of all cab's
    char tempcablist[20][255];
    int tempcablist_nextuse;
    int tempcablist_total;
    int found;
    char temp_cab[50];

    // loop thru all globalarray stuff and get all the cab filenames and stick into the tempcablist.
    tempcablist_nextuse = 0;
    tempcablist_total = 0;
    for(i1=0;i1<Flat_GlobalArrayIndex_Main.total;i1++)
    {
        found=FALSE;
		if (Flat_DoWeIncludeThisFileCheck(i1) == TRUE)
		{
			strcpy(temp_cab, Flat_GlobalArray_Main[i1].CabFileName);
			// loop thru array to see if it's already there.
			for(i2=0;i2<tempcablist_total;i2++)
				{
				if (_stricmp(tempcablist[i2], temp_cab) == 0)
					{found=TRUE;}
				}
			if (found==FALSE)
				{
				// add it
				strcpy(tempcablist[tempcablist_nextuse],temp_cab);
				tempcablist_nextuse++;
				tempcablist_total++;
				}
		}
    }


    // ok, create our little output file...
    f.open(g_szDDFOutput, ios::out);
    strcpy(last_cab, "0");
    strcpy(last_sourcedir, "-");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        strcpy(this_cab, Flat_GlobalArray_Main[i0].CabFileName);
        strcpy(this_sourcedir, Flat_GlobalArray_Main[i0].INF_Sections);
        _splitpath( Flat_GlobalArray_Main[i0].Filename_Full, NULL, this_sourcedir, NULL, NULL);
        
		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{

        // For each Cab Type...
        if (_stricmp(this_cab, last_cab) != 0)
            {

            // Check if it is the first time!
            if (_stricmp(last_cab, "0") == 0)
                {
                strcpy(tempstring, "\n;***** LAYOUT SECTION (Generated) ***** \n");
                f.write (tempstring, strlen(tempstring));
                // print out all the cabinet names
                // loop thru the list of cabinet names and print them out.
                for(i2=0;i2<tempcablist_total;i2++)
                    {
                    sprintf(tempstring, "  .Set CabinetName%d=%s\n", i2+1, tempcablist[i2]);
                    f.write (tempstring, strlen(tempstring));
                    }
                f.write("\n", 1);

                // Set Generate INF=on!!!!
                strcpy(tempstring, ".Set GenerateInf=On\n");
                f.write (tempstring, strlen(tempstring));
                f.write("\n", 1);

                // Do files which don't get included into the cab files..
                strcpy(tempstring, ";*** Files not to include in Cab.\n");
                f.write (tempstring, strlen(tempstring));
                // Set source
                // list files.

                char last_filepath[255];
                char this_filepath[255];

				strcpy(g_non_cablist_temp[0].Filename_Name, "");
                g_non_cablist_temp_nextuse = 0;
                g_non_cablist_temp_total = 0;
                int itexists;

                for(i3=0;i3<Flat_GlobalArrayIndex_Main.total;i3++)
                    {
                    // check if this entry has the ddf_excludefromcab flag set.
                    if (Flat_GlobalArray_Main[i3].DDF_Exclude_From_Cab_Flag)
                        {
                        // add only if not already there...
                        itexists = FALSE;
                        for (int i6=0;i6<g_non_cablist_temp_total;i6++)
                            {
                            if (_stricmp(g_non_cablist_temp[i6].Filename_Name,Flat_GlobalArray_Main[i3].Filename_Name)==0)
                                {itexists = TRUE;}
                            }

                        if (itexists == FALSE)
                        {
                        // Add to our temporary array...
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTS_x86_flag = Flat_GlobalArray_Main[i3].NTS_x86_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTW_x86_flag = Flat_GlobalArray_Main[i3].NTW_x86_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].Win95_flag = Flat_GlobalArray_Main[i3].Win95_flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Win98_flag = Flat_GlobalArray_Main[i3].Win98_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTS_alpha_flag = Flat_GlobalArray_Main[i3].NTS_alpha_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTW_alpha_flag = Flat_GlobalArray_Main[i3].NTW_alpha_flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Other_os_flag = Flat_GlobalArray_Main[i3].Other_os_flag;
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].CabFileName,Flat_GlobalArray_Main[i3].CabFileName);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].INF_Sections,Flat_GlobalArray_Main[i3].INF_Sections);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Full,Flat_GlobalArray_Main[i3].Filename_Full);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Name,Flat_GlobalArray_Main[i3].Filename_Name);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Path,Flat_GlobalArray_Main[i3].Filename_Path);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].DDF_Renamed,Flat_GlobalArray_Main[i3].DDF_Renamed);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].INF_Rename_To,Flat_GlobalArray_Main[i3].INF_Rename_To);
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].DDF_Exclude_From_Cab_Flag = Flat_GlobalArray_Main[i3].DDF_Exclude_From_Cab_Flag;

                        g_non_cablist_temp[g_non_cablist_temp_nextuse].Do_Not_Show_Error_Flag = Flat_GlobalArray_Main[i3].Do_Not_Show_Error_Flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Do_Not_Include_file_if_cabEmpty_Flag = Flat_GlobalArray_Main[i3].Do_Not_Include_file_if_cabEmpty_Flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].FileName_Size = Flat_GlobalArray_Main[i3].FileName_Size;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].FileWasNotActuallyFoundToExist = Flat_GlobalArray_Main[i3].FileWasNotActuallyFoundToExist;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].GetFromSlipStreamDisk = Flat_GlobalArray_Main[i3].GetFromSlipStreamDisk;

						/*
						if (Flat_GlobalArray_Main[i3].FileWasNotActuallyFoundToExist)
						{
						printf(Flat_GlobalArray_Main[i3].Filename_Full);
						printf(".  HEY..\n");
						}
						*/


                            g_non_cablist_temp_nextuse++;
                            g_non_cablist_temp_total++;
                            }
                        }
                    }


                // sort the array
                int offset, inorder, isort, jsort, niterate, resultsort; //, i0sort;
                //FileReadLine tempentrysort[MAX_ARRAY_SMALL];
				FileReadLine tempentrysort;
                niterate = g_non_cablist_temp_total;
                offset=niterate;
                do{
                    offset = (8 * offset) /11;
                    offset = (offset == 0) ? 1 : offset;
                    inorder = TRUE;
                    for (isort=0,jsort=offset;isort < (niterate - offset);isort++,jsort++)
                    {
                        resultsort = _stricmp(g_non_cablist_temp[isort].Filename_Path, g_non_cablist_temp[jsort].Filename_Path);
                        if (resultsort > 0)
                        {
                            inorder = FALSE;

                // do the swap
                // move into temp
                tempentrysort = g_non_cablist_temp[isort];

                // move into original
                g_non_cablist_temp[isort] = g_non_cablist_temp[jsort];

                // move temp into other
                g_non_cablist_temp[jsort] = tempentrysort;

				/* weird to stuff..
                            // do the swap
                             // move into temp
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
                                tempentrysort[i0sort] = g_non_cablist_temp[isort];
                                //strcpy(tempentrysort[i0sort].thestring,(g_non_cablist_temp[isort].thecol[i0sort].thestring));
                                }
                            // move into original
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
								// move into original
                                Flat_GlobalArray_Main[isort] = g_non_cablist_temp[jsort];
                                //strcpy( Flat_GlobalArray_Main[isort].thecol[i0sort].thestring, g_non_cablist_temp[jsort].thecol[i0sort].thestring);
                                }
                            // move temp into other
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
                                g_non_cablist_temp[jsort] = tempentrysort[i0sort];
                                //strcpy(g_non_cablist_temp[jsort].thecol[i0sort].thestring, tempentrysort[i0sort].thestring);
                                }
								*/
                        }
                    }
                } while (!(offset == 1 && inorder == TRUE));


                SafeCopy(tempstring, ".Set Compress=OFF\n",sizeof(tempstring));
                f.write (tempstring, strlen(tempstring));
                SafeCopy(tempstring, ".Set Cabinet=OFF\n",sizeof(tempstring));
                f.write (tempstring, strlen(tempstring));


                // loop thru our new array, and output stuff
                strcpy(last_filepath,"0");
                for (int i5=0;i5<g_non_cablist_temp_total;i5++)
                    {
                    SafeCopy(this_filepath, g_non_cablist_temp[i5].Filename_Path,sizeof(this_filepath));

                    if (_stricmp(last_filepath, this_filepath) != 0)
                        {
                        // take the dir and write it out
                        f.write("\n", 1);
                        sprintf(tempstring, ".Set SourceDir=%s\n", this_filepath);
                        f.write (tempstring, strlen(tempstring));
                        SafeCopy(last_filepath, this_filepath,sizeof(last_filepath));
                        }

					if (g_non_cablist_temp[i5].FileWasNotActuallyFoundToExist)
					{
						printf(g_non_cablist_temp[i5].Filename_Full);
						printf(".  FileWasNotActuallyFoundToExist.skip write to ddf..\n");
                        g_iGlobalReturnCode = FALSE;
					}
					else
					{
						// print out the filename
						if (_stricmp(g_non_cablist_temp[i5].Filename_Name, g_non_cablist_temp[i5].DDF_Renamed) == 0)
							{SafeCopy(tempstring,g_non_cablist_temp[i5].Filename_Name,sizeof(tempstring));}
						else
							{
							SafeCopy(tempstring,g_non_cablist_temp[i5].Filename_Name,sizeof(tempstring));
							SafeCat(tempstring," ",sizeof(tempstring));
							SafeCat(tempstring,g_non_cablist_temp[i5].DDF_Renamed,sizeof(tempstring));
							}
						f.write (tempstring, strlen(tempstring));

						// files which are outside of the cab should have the unique flag set.
						// of cource, because they are all in the same place!!

                                                // check if this is one of those "special" files which
                                                // come from a service pack.
                                                if (g_non_cablist_temp[i5].GetFromSlipStreamDisk == 0)
                                                {
                                                 strcpy(tempstring, "\t/unique=yes");
                                                }
                                                else
                                                {
                                                 sprintf(tempstring,"\t/unique=yes /cab#=%d", g_iSlipStreamDiskID);
                                                }
						f.write (tempstring, strlen(tempstring));
						f.write("\n", 1);
					}
                    }



                f.write("\n", 1);

                // Files which do get included in the Cab
                SafeCopy(tempstring, ";*** Files to include in Cabs.\n",sizeof(tempstring));
                f.write (tempstring, strlen(tempstring));

                f.write(";\n", 2);
                sprintf(tempstring, ";  Cab File = %s\n", this_cab);
                f.write (tempstring, strlen(tempstring));
                f.write(";\n", 2);

                // Set cabinet on and compress on.
                SafeCopy(tempstring, ".Set Cabinet=on\n",sizeof(tempstring));
                f.write (tempstring, strlen(tempstring));
                SafeCopy(tempstring, ".Set Compress=on\n",sizeof(tempstring));
                f.write (tempstring, strlen(tempstring));

                }
            else
                {
                f.write("\n;\n", 3);
                sprintf(tempstring, ";  Cab File = %s\n", this_cab);
                f.write (tempstring, strlen(tempstring));
                f.write(";\n", 2);
                // Write new stuff for every new cabinet
                SafeCopy(tempstring, ".Set Cabinet=off\n",sizeof(tempstring));
                f.write (tempstring, strlen(tempstring));
                SafeCopy(tempstring, ".Set Cabinet=on\n",sizeof(tempstring));
                f.write (tempstring, strlen(tempstring));
                SafeCopy(tempstring, ".New Cabinet\n",sizeof(tempstring));
                f.write (tempstring, strlen(tempstring));
                }

            SafeCopy(last_cab, this_cab,sizeof(last_cab));
            }

        // Copy over the filename
        // don't copy over if the file should not be
        // included in the the cab file.
        //if (_stricmp(Flat_GlobalArray_Main[i0].thecol[COL_DDF_EXCLUDEFROMCAB].thestring,"true") != 0)
        if (!(Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag))
            {
            // don't copy over if the same file, in the same directory for the same cab file
            // exists already.  this could happen if they want the same file in different
            // sections....
            if (Flat_DDFDoesThisFileCabAlreadyExists(i0) == FALSE)
                {
				//if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE) {

					// For each new directory change
					if (_stricmp(this_sourcedir, last_sourcedir) != 0)
						{
						// print out new section stuff
						f.write("\n", 1);
						sprintf(tempstring, ".Set SourceDir=%s\n", this_sourcedir);
						f.write (tempstring, strlen(tempstring));

						SafeCopy(last_sourcedir, this_sourcedir,sizeof(last_sourcedir));
						}

					// write out the filename!
					SafeCopy(thefilename, Flat_GlobalArray_Main[i0].Filename_Name,sizeof(thefilename));

					if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
						{
						// Check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].Filename_Name, ' ') != NULL)
							{
							SafeCopy(thefilename, "\"",sizeof(thefilename));
							SafeCat(thefilename,Flat_GlobalArray_Main[i0].Filename_Name,sizeof(thefilename));
							SafeCat(thefilename, "\"",sizeof(thefilename));
							}
						else
							{SafeCopy(thefilename,Flat_GlobalArray_Main[i0].Filename_Name,sizeof(thefilename));}
						}
					else
						{
						// Check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].Filename_Name, ' ') != NULL)
							{
							SafeCopy(thefilename, "\"",sizeof(thefilename));
							SafeCat(thefilename,Flat_GlobalArray_Main[i0].Filename_Name,sizeof(thefilename));
							SafeCat(thefilename, "\"",sizeof(thefilename));
							}
						else
							{
							SafeCopy(thefilename,Flat_GlobalArray_Main[i0].Filename_Name,sizeof(thefilename));
							}
						SafeCat(thefilename," ",sizeof(thefilename));

						// check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].DDF_Renamed, ' ') != NULL)
							{
							SafeCopy(thefilename, "\"",sizeof(thefilename));
							SafeCat(thefilename,Flat_GlobalArray_Main[i0].DDF_Renamed,sizeof(thefilename));
							SafeCat(thefilename, "\"",sizeof(thefilename));
							}
						else
							{
							SafeCat(thefilename,Flat_GlobalArray_Main[i0].DDF_Renamed,sizeof(thefilename));
							}
                    
						}

					f.write (thefilename, strlen(thefilename));

					// Check if this file has the unique flag set.
					// don't write the \n until past this part..
					/*if (_stricmp(Flat_GlobalArray_Main[i0].thecol[COL_DDF_UNIQUE].thestring,"true")) == 0)
						{
							strcpy(tempstring, "\t/unique=yes");
							f.write (tempstring, strlen(tempstring));
						}
						*/
					// ok, now it's kool to write this part.
					f.write ("\n", 1);
					//}
				}
            }
		}
	}
    f.close();
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_Create_Output_ERR(void)
{
    int i0;
    fstream f;
    char filename_only[255];
    char szPath[_MAX_PATH];
    char tempstring[MAX_STRING];

    // Get the path
    GetModuleFileName(NULL, szPath, _MAX_PATH);
    // split up this path
    _splitpath( szPath, NULL, NULL, filename_only, NULL);

    strcat(filename_only, ".ERR");

    // if there are any errors to report...
    if (Flat_GlobalArrayIndex_Err.total <= 0)
        {return FALSE;}

    // open the file
    f.open(filename_only, ios::out);

    // loop thru the errors and print out the errors
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Err.total;i0++)
        {
        strcpy(tempstring, (char*)Flat_GlobalArray_Err[i0]);
        f.write (tempstring, strlen(tempstring));
        f.write("\n", 1);
        }
        
    f.close();
    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Add_Err(char theentry[])
{
    g_iGlobalReturnCode = FALSE;

    // lets add it
    strcpy(Flat_GlobalArray_Err[Flat_GlobalArrayIndex_Err.nextuse], theentry);

    // increment counter to array
    // increment next use space
    ++Flat_GlobalArrayIndex_Err.total;
    ++Flat_GlobalArrayIndex_Err.nextuse;
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Print_Err(void)
{
    int  i0;
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Err.total;i0++)
        {
        printf (Flat_GlobalArray_Err[i0]);
        printf ("\n");
        }
    return;
}


//-------------------------------------------------------------------
// purpose:
//  the problem with regular strtok2 is that it will
//  skip stuff like ",,," and ignore all the blanks in
//  between to get to the next token.  this strtok2 function
//  was written to over come that.  so that strtok2 works like
//  you think it would.
//-------------------------------------------------------------------
char * __cdecl strtok2 (char * string,const char * control)
{
        //unsigned char *str;
        //const unsigned char *ctrl = control;
        //unsigned char map[32];
        char *str;
        const char *ctrl = control;
        char map[32];
        int count;

        static char *nextoken;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
            {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
            } while (*ctrl++);

        /* Initialize str. If string is NULL, set str to the saved
         * pointer (i.e., continue breaking tokens out of the string
         * from the last strtok2 call) */
        if (string)
                str = string;
        else
                str = nextoken;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets str to point to the terminal
         * null (*str == '\0') */
        /*
        while (
                (map[*str >> 3] & (1 << (*str & 7) ) )    && *str
                )
                str++;
                */

        string = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */
        nextoken = str;

        /* Determine if a token has been found. */
        if ( string == str )
                return NULL;
        else
                return string;
}





int RemoveAllSpaces(LPSTR & thetempstring)
{
	int iReturn = FALSE;
	int j = 0;
    char thevalue[1024];
    char tempstring2[1024];

    strcpy(tempstring2, thetempstring);
//	strset(thevalue, '\0');
    strcpy(thevalue, "");

	for (int i=0;i < (int) strlen(tempstring2);i++)
	{
		
		if (tempstring2[i] == ' ')
		{
			iReturn = TRUE;
		}
		else
		{
			thevalue[j] = tempstring2[i];
			thevalue[j+1] = '\0';
			j++;
		}
	}
	if (iReturn == TRUE)  {strcpy(thetempstring, thevalue);}

    return iReturn;
}


int Flat_DoWeIncludeThisFileCheck(int processeduptill)
{
	//return TRUE;
	int iReturn = FALSE;
    int i0 = 0;
	int TheCount = 0;

    char CompareTo_cab[100];

	if (Flat_GlobalArray_Main[processeduptill].Do_Not_Include_file_if_cabEmpty_Flag != 1) {return TRUE;}

	// Grab the cabfilename
	strcpy(CompareTo_cab, Flat_GlobalArray_Main[processeduptill].CabFileName);
	for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
		if (i0 != processeduptill)
			{
			if (Flat_GlobalArray_Main[i0].Do_Not_Include_file_if_cabEmpty_Flag != 1)
				{
				if (_stricmp(Flat_GlobalArray_Main[i0].CabFileName, CompareTo_cab) == 0)
					{
					++TheCount;
					break;
					}
				}
			}
        }

	if (TheCount > 0){iReturn = TRUE;}

    return iReturn;
}


void Global_TotalCabFileSize_Compute(void)
{
	char szTheCabFileName[50] = "";
	int MyFileSize = 0;
	int TheNextUse = 0;
	int iTheFlag = FALSE;
	int iIndexToUse = 0;

	// Go thru the whole list and add everything up
	for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
		{
			if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
			{
				if (!(Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag))
				{

					iIndexToUse = Flat_GlobalArrayIndex_CabSizes.nextuse;

					TheNextUse = 0;
					// lets add it if not already there.
					while (TheNextUse < Flat_GlobalArrayIndex_CabSizes.total)
					{
						if (_stricmp(Flat_GlobalArray_CabSizes[TheNextUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName) == 0)
						{
							iIndexToUse = TheNextUse;
							iTheFlag = TRUE;
							break;
						}
						TheNextUse++;
					}

					if (iTheFlag == TRUE)
					{
						// copy over the filename
						strcpy(Flat_GlobalArray_CabSizes[iIndexToUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName);

						// Get the size
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize = Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize + Flat_GlobalArray_Main[i0].FileName_Size;
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFiles++;
					}
					else
					{
						iIndexToUse = Flat_GlobalArrayIndex_CabSizes.nextuse;

						// copy over the filename
						strcpy(Flat_GlobalArray_CabSizes[iIndexToUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName);

						// Get the size
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize = Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize + Flat_GlobalArray_Main[i0].FileName_Size;
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFiles++;

						++Flat_GlobalArrayIndex_CabSizes.total;
						++Flat_GlobalArrayIndex_CabSizes.nextuse;
					}
				}
			}
		}
}


void Global_TotalCabFileSize_Print(void)
{
    int  i0;
	char stempstring[100];

    for( i0 = 0; i0 < Flat_GlobalArrayIndex_CabSizes.total;i0++)
        {
		sprintf(stempstring, "%s: Filecount=%d, Size=%d\n",Flat_GlobalArray_CabSizes[i0].CabFileName, Flat_GlobalArray_CabSizes[i0].TotalFiles, Flat_GlobalArray_CabSizes[i0].TotalFileSize);
        printf(stempstring);
        }
	printf("\n");
    return;
}


// Returns the count of the "\" characters in the string
//
int ReturnDirLevelCount(char *DirectoryTree)
{
	int TheCount = 0;
	char szTemp[_MAX_PATH];
	_tcscpy(szTemp, DirectoryTree);
	char *p = szTemp;
	while (*p) 
	{
		if (*p == '\\') 
			{TheCount++;}
		
		p = _tcsinc(p);
	}

	return TheCount;
}




void FillGlobalUniqueDirList()
{
    // used to keep a list of unique directory names.
	// loop thru the whole structure and pull out all the unique directory names.
    for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
    {
        // check if entries are the same.
		if (FALSE == GlobalUniqueDirChkIfAlreadyThere(Flat_GlobalArray_Main[i0].Filename_Path))
		{
			// Not there yet.  so let's add it
			strcpy(Flat_GlobalUniqueDirList[Flat_GlobalUniqueDirList_nextuse], Flat_GlobalArray_Main[i0].Filename_Path);

			// increment counter to array
			// increment next use space
			++Flat_GlobalUniqueDirList_total;
			++Flat_GlobalUniqueDirList_nextuse;
		}
    }
	return;
}


int GlobalUniqueDirChkIfAlreadyThere(char *TheStringToCheck)
{
	int iReturn = FALSE;

	for( int i0 = 0; i0 < Flat_GlobalUniqueDirList_total;i0++)
	{
		if (_stricmp(Flat_GlobalUniqueDirList[i0], TheStringToCheck) == 0)
		{
			iReturn = TRUE;
			goto isItAlreadyThere_Exit;
		}
	}

isItAlreadyThere_Exit:
	return iReturn;
}


int GlobalUniqueDirReturnMyIndexMatch(char *TheStringToCheck)
{
	int iReturn = 0;

	for( int i0 = 0; i0 < Flat_GlobalUniqueDirList_total;i0++)
	{
		if (_stricmp(Flat_GlobalUniqueDirList[i0], TheStringToCheck) == 0)
		{
			iReturn = i0;
			goto GlobalUniqueDirReturnMyIndexMatch_Exit;
		}
	}

GlobalUniqueDirReturnMyIndexMatch_Exit:
	return iReturn;
}

//***************************************************************************
//* NAME:       StripWhitespace                                             *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//***************************************************************************
LPSTR StripWhitespaceA( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\guid.h ===
#ifndef _MYGUID_H_
#define _MYGUID_H_
    int AppDeleteRecoverable_Wrap(LPCTSTR lpszPath);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

#include <objbase.h>
#include <initguid.h>

#define INITGUID
#include "iwamreg.h"
#include "guid.h"

int AppDeleteRecoverable_Wrap(LPCTSTR lpszPath)
{
    int iReturn = FALSE;
    int iCoInitCalled = FALSE;

    TCHAR lpszKeyPath[_MAX_PATH];
    WCHAR wchKeyPath[_MAX_PATH];
    HRESULT         hr = NOERROR;
    IWamAdmin*        pIWamAdmin = NULL;

    if (lpszPath[0] == _T('/'))
    {
        _tcscpy(lpszKeyPath, lpszPath);
    }
    else
    {
        lpszKeyPath[0] = _T('/');
        _tcscpy(_tcsinc(lpszKeyPath), lpszPath);
    }

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wchKeyPath, lpszKeyPath);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpszKeyPath, -1, (LPWSTR)wchKeyPath, _MAX_PATH);
#endif

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        iisDebugOut((_T("AppDeleteRecoverable_Wrap: CoInitializeEx() failed, hr=%x\n"), hr));
        goto AppDeleteRecoverable_Wrap_Exit;
    }
    // Set the flag to say that we need to call co-uninit
    iCoInitCalled = TRUE;

    hr = CoCreateInstance(CLSID_WamAdmin,NULL,CLSCTX_SERVER,IID_IWamAdmin,(void **)&pIWamAdmin);
    if (FAILED(hr))
    {
        iisDebugOut((_T("AppDeleteRecoverable_Wrap:CoCreateInstance() failed. err=%x.\n"), hr));
        goto AppDeleteRecoverable_Wrap_Exit;
    }

    hr = pIWamAdmin->AppDeleteRecoverable(wchKeyPath, TRUE);
    pIWamAdmin->Release();
    if (FAILED(hr))
    {
        iisDebugOut((_T("AppDeleteRecoverable_Wrap() on path %s failed, err=%x.\n"), lpszKeyPath, hr));
        goto AppDeleteRecoverable_Wrap_Exit;
    }

    // We got this far, everything must be okay.
    iReturn = TRUE;

AppDeleteRecoverable_Wrap_Exit:
    if (iCoInitCalled == TRUE) {CoUninitialize();}
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\helper.cpp ===
#include "stdafx.h"
#include "guid.h"
#include "iadm.h"
#include "mdkey.h"

extern HANDLE g_MyModuleHandle;
extern int g_iPWS40OrBetterInstalled;
extern int g_iPWS10Installed;
extern int g_iVermeerPWS10Installed;

extern CHAR g_FullFileNamePathToSettingsFile[_MAX_PATH];
extern CHAR g_PWS10_Migration_Section_Name_AddReg[];
extern CHAR g_PWS40_Migration_Section_Name_AddReg[];
extern CHAR g_Migration_Section_Name_AddReg[];

extern CHAR g_PWS10_Migration_Section_Name_CopyFiles[];
extern CHAR g_PWS40_Migration_Section_Name_CopyFiles[];
extern char g_Migration_Section_Name_CopyFiles[];

extern MyLogFile g_MyLogFile;

int  g_SectionCount = 0;

#define METABASE_BIN_FILENAME "Metabase.bin"
#define METABASE_BIN_BEFORE_CHANGE "kjhgfdsa.001"
#define METABASE_BIN_AFTER_CHANGE "kjhgfdsa.002"

#define REG_NETWORK_MSWEBSVR "Enum\\Network\\MSWEBSVR"
#define REG_HKLM_NETWORK_MSWEBSVR "HKLM\\Enum\\Network\\MSWEBSVR"

#define REG_PWS_40_UNINSTALL_KEY "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\MSIIS"
#define REG_HKLM_PWS_40_UNINSTALL_KEY "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\MSIIS"

// used to check if pws 4.0 is installed
#define REG_INETSTP    "Software\\Microsoft\\INetStp"
#define REG_INETSTP_MAJORVERSION_STRINGVALUE  "MajorVersion"
#define REG_INETSTP_INSTALLPATH_STRINGVALUE   "InstallPath"
// used to check if pws 1.0 is installed
#define REG_WWWPARAMETERS       "System\\CurrentControlSet\\Services\\W3Svc\\Parameters"
#define REG_WWWPARAMETERS_MAJORVERSION_STRINGVALUE "MajorVersion"

// used to check if vermeer pws 1.0 is installed
#define FILENAME_FRONTPG_INI          "frontpg.ini"
#define FILENAME_FRONTPG_INI_SECTION  "FrontPage 1.1"
#define FILENAME_FRONTPG_INI_KEY      "PWSRoot"

// used for parsing the values in the .rc file
#define g_LoadString_token_delimiters   ",;\t\n\r"

// regkey value for the metabase flag for doing unsecuredread
#define METABASEUNSECUREDREAD_VALUENAME "MetabaseUnSecuredRead"

// unattend answer file stuff for UNATTEND_TXT_PWS_SECTION section
#define UNATTEND_TXT_PWS_SECTION          "InternetServer"
#define UNATTEND_TXT_PWS_METABASE_NEW     "Win95MigrateDllMetabaseNew"
#define UNATTEND_TXT_PWS_METABASE_ORGINAL "Win95MigrateDllMetabaseOrg"

#define UNATTEND_TXT_FILES_TO_DELETE_SECTION "Win95MigrateDll_DeleteFilesOrDirs_IIS"

// Special key to say "hey, we need to do some special metabase stuff
// like: doing an AppDeleteRecoverable() on the metabase.
// we don't have to do AppDeleteRecoverable if MTS is migrated automagically.
//#define SPECIAL_METABASE_STUFF

int MyMessageBox(char [], char []);
int MySettingsFile_Write_PWS10(HANDLE);
int MySettingsFile_Write_PWS40(HANDLE);
int InstallInfSection(char szINFFilename[],char szSectionName[]);

void RecursivelyMoveRegFormatToInfFormat_Wrap1(HKEY hRootKeyType, CHAR szRootKey[], HANDLE fAppendToFile);
int RecursivelyMoveRegFormatToInfFormat(HKEY hRootKeyType, CHAR szRootKey[], HANDLE fAppendToFile);
int SetMetabaseToDoUnEncryptedRead(int iOnFlag);


typedef struct _QUEUECONTEXT {
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;



int ReturnTrueIfPWS40_Installed(void)
{
	iisDebugOut(_T("ReturnTrueIfPWS40_Installed.  Start."));
	int iReturn = FALSE;

	// Check if pws 4.0 or better is installed.
	DWORD rc = 0;
	HKEY hKey = NULL;

	DWORD dwType, cbData;
	BYTE   bData[1000];
	cbData = 1000;

	rc = RegOpenKey(HKEY_LOCAL_MACHINE, REG_INETSTP, &hKey);
    if (rc == ERROR_SUCCESS) 
	{
        // try open a particular value...

	    // Check if we can read the Major Version Value.
	    // try to query the value
	    rc = RegQueryValueEx(hKey,REG_INETSTP_MAJORVERSION_STRINGVALUE,NULL,&dwType,bData,&cbData);
	    if ( ERROR_SUCCESS == rc) 
	        {iReturn = TRUE;} 
    }
	else
	{
        SetLastError(rc);
    }

	if (hKey){RegCloseKey(hKey);}
	iisDebugOut(_T("ReturnTrueIfPWS40_Installed.  Return=%d.  End."), iReturn);
	return iReturn;
}

int ReturnTrueIfVermeerPWS10_Installed(void)
{
	iisDebugOut(_T("ReturnTrueIfVermeerPWS10_Installed.  Start."));
	int iReturn = FALSE;

	char szFrontpgIniFile[_MAX_PATH];
	strcpy(szFrontpgIniFile, "");
	if (0 == GetSystemDirectory(szFrontpgIniFile, sizeof(szFrontpgIniFile)))
	{
		// Error so write it out
		SetupLogError_Wrap(LogSevError, "Call to GetSystemDirectory() Failed. GetLastError=%x.", GetLastError());
		goto ReturnTrueIfVermeerPWS10_Installed_Exit;
	}
	else
	{
		AddPath(szFrontpgIniFile, FILENAME_FRONTPG_INI);
	}

	if (CheckIfFileExists(szFrontpgIniFile) == TRUE) 
	{
		iisDebugOut(_T("ReturnTrueIfVermeerPWS10_Installed.  Found %s file. Check FrontPage 1.1/PWSRoot Section."), szFrontpgIniFile);
		char buf[_MAX_PATH];
		GetPrivateProfileString(FILENAME_FRONTPG_INI_SECTION, FILENAME_FRONTPG_INI_KEY, _T(""), buf, _MAX_PATH, szFrontpgIniFile);
		if (*buf && CheckIfFileExists(buf)) 
			{
			// yes, vermeer frontpage's personal web server is installed
			iReturn = TRUE;
			}
		else
		{
			iisDebugOut(_T("ReturnTrueIfVermeerPWS10_Installed.  Check FrontPage 1.1/PWSRoot Section references file %s.  but it's not found so, Vermeer pws1.0 not installed."), buf);
		}
	}

ReturnTrueIfVermeerPWS10_Installed_Exit:
	iisDebugOut(_T("ReturnTrueIfVermeerPWS10_Installed.  Return=%d.  End."), iReturn);
	return iReturn;
}



int ReturnTrueIfPWS10_Installed(void)
{
	iisDebugOut(_T("ReturnTrueIfPWS10_Installed.  Start."));
	int iReturn = FALSE;

	// For old win95 pws 1.0 check
	// Check if we can get the w3svc\parameters key.
	HKEY hKey = NULL;
	DWORD rc = 0;

	DWORD dwType, cbData;
	BYTE   bData[1000];
	cbData = 1000;

	rc = RegOpenKey(HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, &hKey);
	if ( ERROR_SUCCESS != rc) 
	{
		SetLastError (rc);
		// if the key Does not exists pws 1.0a is not installed
		goto ReturnTrueIfPWS10_Installed_Exit;
	} 

	// Check if we can read the Major Version Value.  Should be set to '\0' if pws 1.0
	// try to query the value
	rc = RegQueryValueEx(hKey,REG_WWWPARAMETERS_MAJORVERSION_STRINGVALUE,NULL,&dwType,bData,&cbData);
	if ( ERROR_SUCCESS != rc) 
	{
		// SetLastError (rc);
		// if the key Does not exists pws 1.0a is not installed
		//SetupLogError_Wrap(LogSevError, "Failed to Read Registry Value '%s' in Key '%s'.  GetLastError()=%x",REG_WWWPARAMETERS_MAJORVERSION_STRINGVALUE, REG_WWWPARAMETERS, GetLastError());
        //iisDebugOut(_T("Failed to Read Registry Value '%s' in Key '%s'. pws1.0a is not installed."),REG_WWWPARAMETERS_MAJORVERSION_STRINGVALUE,REG_WWWPARAMETERS);
		goto ReturnTrueIfPWS10_Installed_Exit;
	} 

	// Check if we can read the MajorVersion value should be set to '\0' if pws 1.0
	if (bData[0] == '\0') {iReturn = TRUE;}
	
ReturnTrueIfPWS10_Installed_Exit:
	if (hKey){RegCloseKey(hKey);}
	iisDebugOut(_T("ReturnTrueIfPWS10_Installed.  Return=%d.  End."), iReturn);
	return iReturn;
}

int CheckIfPWS95Exists(void)
{
	iisDebugOut(_T("CheckIfPWS95Exists.  Start."));
	int iReturn = FALSE;

	// Check if this is pws 4.0 or better
	if (ReturnTrueIfPWS40_Installed() == TRUE)
	{
		g_iPWS40OrBetterInstalled = TRUE;
		iReturn = TRUE;
		goto CheckIfPWS95Exists_Exit;
	}

	// Check if this is pws 1.0a
	if (ReturnTrueIfPWS10_Installed() == TRUE)
	{
		iReturn = TRUE;
		g_iPWS10Installed = TRUE;
		goto CheckIfPWS95Exists_Exit;
	}

	// Check if this is Vermeer pws 1.0
	if (ReturnTrueIfVermeerPWS10_Installed() == TRUE)
	{
		iReturn = TRUE;
		g_iVermeerPWS10Installed = TRUE;
		goto CheckIfPWS95Exists_Exit;
	}

CheckIfPWS95Exists_Exit:
	iisDebugOut(_T("CheckIfPWS95Exists.  Return=%d.  End."), iReturn);
	return iReturn;
}


void iisDebugOut( TCHAR *pszfmt, ...)
{
	TCHAR acsString[1000];
	TCHAR acsString2[1000];

	va_list va;
	va_start(va, pszfmt);
	_vstprintf(acsString, pszfmt, va);
	va_end(va);

#if DBG == 1 || DEBUG == 1 || _DEBUG == 1
	_stprintf(acsString2, _T("%s"), acsString);
	OutputDebugString(acsString2);
	g_MyLogFile.LogFileWrite(acsString2);
#else  // DBG == 0
	_stprintf(acsString2, _T("%s"), acsString);
	// no outputdebug string for fre builds
	g_MyLogFile.LogFileWrite(acsString2);
#endif // DBG

    return;
}


//***************************************************************************
//*                                                                         
//* purpose: TRUE if the file is opened, FALSE if the file does not exists.
//* 
//***************************************************************************
int CheckIfFileExists(LPCTSTR szFile)
{ 
	return (GetFileAttributes(szFile) != 0xFFFFFFFF);
}

BOOL isDirEmpty(LPCTSTR szDirName)
{
    TCHAR szSearchString[MAX_PATH+1];
    HANDLE hFileSearch;
    WIN32_FIND_DATA wfdFindData;
    BOOL bMoreFiles = TRUE;
    
    //
    //  Now search for files
    //
    sprintf(szSearchString, _T("%s\\*.*"), szDirName);
    
    hFileSearch = FindFirstFile(szSearchString, &wfdFindData);
    while ((INVALID_HANDLE_VALUE != hFileSearch) && bMoreFiles)
    {
        if ((0 != lstrcmpi(wfdFindData.cFileName, _T("."))) &&
            (0 != lstrcmpi(wfdFindData.cFileName, _T(".."))))
        {
            FindClose(hFileSearch);
            return FALSE;
        }
        
        bMoreFiles = FindNextFile(hFileSearch, &wfdFindData);
    }

    if (INVALID_HANDLE_VALUE != hFileSearch)
    {
        FindClose(hFileSearch);
    }
    
    return TRUE;
}

BOOL RemoveAllDirsIfEmpty(LPCTSTR szTheDir)
{
    TCHAR szDirCopy[_MAX_PATH];
    DWORD retCode = GetFileAttributes(szTheDir);
    _tcscpy(szDirCopy,szTheDir);
    if (retCode == 0xFFFFFFFF)
    {
        return FALSE;
    }

    if ((retCode & FILE_ATTRIBUTE_DIRECTORY)) 
    {
        if (TRUE == isDirEmpty(szDirCopy))
        {
            iisDebugOut(_T("RemoveDirectory:%s"),szDirCopy);
            RemoveDirectory(szDirCopy);
            // Get the next dir in...
            // and see if it's empty

            // strip off the filename
            TCHAR * pTemp = strrchr(szDirCopy, '\\');
            if (pTemp){*pTemp = '\0';}
            RemoveAllDirsIfEmpty(szDirCopy);
            
            // strip off the filename
            pTemp = strrchr(szDirCopy, '\\');
            if (pTemp){*pTemp = '\0';}
            RemoveAllDirsIfEmpty(szDirCopy);
        }
    }
    return TRUE;
}

BOOL InetDeleteFile(LPCTSTR szFileName)
{
    // if file exists but DeleteFile() fails
    if ( CheckIfFileExists(szFileName) && !(DeleteFile(szFileName)) ) 
    {
        // failed to delete it
        return FALSE;
    }
    else
    {
        iisDebugOut(_T("InetDeleteFile:%s"),szFileName);

	    TCHAR szDrive_only[_MAX_DRIVE];
	    TCHAR szPath_only[_MAX_PATH];
        TCHAR szTheDir[_MAX_PATH];
        _tsplitpath(szFileName,szDrive_only,szPath_only,NULL,NULL);

		_tcscpy(szTheDir, szDrive_only);
		_tcscat(szTheDir, szPath_only);

        // see if the directory is empty...
        // if it is.. then remove it...
        RemoveAllDirsIfEmpty(szTheDir);
    }
    return TRUE;
}


BOOL RecRemoveDir(LPCTSTR szName)
{
    BOOL iRet = FALSE;
    DWORD retCode;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szSubDir[_MAX_PATH] = _T("");
    TCHAR szDirName[_MAX_PATH] = _T("");

    retCode = GetFileAttributes(szName);

    if (retCode == 0xFFFFFFFF)
        return FALSE;

    if (!(retCode & FILE_ATTRIBUTE_DIRECTORY)) {
        InetDeleteFile(szName);
        return TRUE;
    }

    _stprintf(szDirName, _T("%s\\*"), szName);
    hFile = FindFirstFile(szDirName, &FindFileData);

    if (hFile != INVALID_HANDLE_VALUE) {
        do {
            if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
                 _tcsicmp(FindFileData.cFileName, _T("..")) != 0 ) {
                _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                RecRemoveDir(szSubDir);
            }

            if ( !FindNextFile(hFile, &FindFileData) ) {
                FindClose(hFile);
                break;
            }
        } while (TRUE);
    }

    iRet = RemoveAllDirsIfEmpty(szName);
    return iRet;
}

void MyDeleteLinkWildcard(TCHAR *szDir, TCHAR *szFileName)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFileToBeDeleted[_MAX_PATH];

    _stprintf(szFileToBeDeleted, _T("%s\\%s"), szDir, szFileName);

    hFile = FindFirstFile(szFileToBeDeleted, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, so let's Delete it.
                        TCHAR szTempFileName[_MAX_PATH];
                        _stprintf(szTempFileName, _T("%s\\%s"), szDir, FindFileData.cFileName);
                        // set to normal attributes, so we can delete it
                        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
                        // delete it, hopefully
                        InetDeleteFile(szTempFileName);
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return;
}

//***************************************************************************
//*                                                                         
//* purpose: Write out our "settings" file which is just a setupapi .inf file
//*          which will get installed on the WinNT side
//* 
//***************************************************************************
int MySettingsFile_Write(void)
{
	int iReturn = FALSE;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	iisDebugOut(_T("MySettingsFile_Write.  Start."));

	// Get From the registry
	// if pws 4.0 installed then get all that information
	// and save it in the Settings file.
	if (g_iPWS40OrBetterInstalled == TRUE)
		{
		strcpy(g_Migration_Section_Name_AddReg, g_PWS40_Migration_Section_Name_AddReg);
		strcpy(g_Migration_Section_Name_CopyFiles, g_PWS40_Migration_Section_Name_CopyFiles);
		}
	else if (g_iPWS10Installed == TRUE)
		{
		strcpy(g_Migration_Section_Name_AddReg, g_PWS10_Migration_Section_Name_AddReg);
		strcpy(g_Migration_Section_Name_CopyFiles, g_PWS10_Migration_Section_Name_CopyFiles);
		}

	if (g_iPWS40OrBetterInstalled || g_iPWS10Installed)
	{
		// Open existing file or create a new one.
		if (g_FullFileNamePathToSettingsFile)
		{
			iisDebugOut(_T("MySettingsFile_Write.  CreatingFile '%s'."), g_FullFileNamePathToSettingsFile);
			hFile = CreateFile(g_FullFileNamePathToSettingsFile,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				if (g_iPWS40OrBetterInstalled == TRUE)
				{
					// Get all the pws4.0 registry stuff and save it in the settings file.
					iReturn = MySettingsFile_Write_PWS40(hFile);
					if (iReturn != TRUE) {SetupLogError_Wrap(LogSevError, "Failed to Write PWS40 Registry values to file '%s'.",g_FullFileNamePathToSettingsFile);}

					// On PWS 4.0, We need to make sure to 
					// 1. Not copy over files/dirs in the inetsrv directory from pws 4.0
					// 2. copy over all other files in the inetsrv directory for the user 
					// might have some controls and such that they created and want to keep.

					// add deleted files
				}
				else if (g_iPWS10Installed == TRUE)
				{
					// if pws 1.0 installed then get all that information and save it in the Settings file.
					iReturn = MySettingsFile_Write_PWS10(hFile);
					if (iReturn != TRUE) {SetupLogError_Wrap(LogSevError, "Failed to Write PWS10 Registry values to file '%s'.",g_FullFileNamePathToSettingsFile);}
				}
			}
			else
			{
				SetupLogError_Wrap(LogSevError, "Failed to Create to file '%s'.",g_FullFileNamePathToSettingsFile);
			}
		}
		else
		{
			SetupLogError_Wrap(LogSevError, "File handle Does not exist '%s'.",g_FullFileNamePathToSettingsFile);
		}
	}
	else
	{
		iisDebugOut(_T("MySettingsFile_Write.  Neither PWS 1.0 or 4.0 is currently installed, no upgraded required."));
	}

    if (hFile && hFile != INVALID_HANDLE_VALUE) {CloseHandle(hFile);hFile=NULL;}
	iisDebugOut(_T("MySettingsFile_Write.  End.  Return = %d"), iReturn);
	return iReturn;
}

int AnswerFile_AppendDeletion(TCHAR * szFileNameOrPathToDelete,LPCSTR AnswerFile)
{
	int iReturn = FALSE;
    CHAR szTempString[30];
    CHAR szQuotedPath[_MAX_PATH];

    if (!szFileNameOrPathToDelete)
    {
        goto AnswerFile_AppendDeletion_Exit;
    }
	// Open existing file or create a new one.
	if (!AnswerFile)
	{
        SetupLogError_Wrap(LogSevError, "File handle Does not exist '%s'.",AnswerFile);
        goto AnswerFile_AppendDeletion_Exit;
	}

    if (CheckIfFileExists(AnswerFile) != TRUE)
    {
        iisDebugOut(_T("AnswerFile_AppendDeletion:file not exist...\n"));
        goto AnswerFile_AppendDeletion_Exit;
    }

    sprintf(szTempString,"%d",g_SectionCount);
    iisDebugOut(_T("AnswerFile_AppendDeletion:%s=%s\n"), szTempString,szFileNameOrPathToDelete);
    sprintf(szQuotedPath, "\"%s\"",szFileNameOrPathToDelete);
    if (0 == WritePrivateProfileString(UNATTEND_TXT_FILES_TO_DELETE_SECTION, szTempString, szQuotedPath, AnswerFile))
    {
	    SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", UNATTEND_TXT_FILES_TO_DELETE_SECTION, AnswerFile, GetLastError());
        iisDebugOut(_T("Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x."), UNATTEND_TXT_FILES_TO_DELETE_SECTION, AnswerFile, GetLastError());
        goto AnswerFile_AppendDeletion_Exit;
    }
    g_SectionCount++;

    iReturn = TRUE;

AnswerFile_AppendDeletion_Exit:
    iisDebugOut(_T("AnswerFile_AppendDeletion:end.ret=%d,%s\n"),iReturn,szFileNameOrPathToDelete);
	return iReturn;
}

int AnswerFile_ReadSectionAndDoDelete(IN HINF AnswerFileHandle)
{
	int iReturn = FALSE;
    BOOL bFlag = FALSE;
    INFCONTEXT Context;
    DWORD dwRequiredSize = 0;
    LPTSTR szLine = NULL;
    DWORD retCode = 0;

    iisDebugOut(_T("MySettingsFile_ReadSectionAndDoDelete:start\n"));
    
    // go to the beginning of the section in the INF file
    bFlag = SetupFindFirstLine(AnswerFileHandle,UNATTEND_TXT_FILES_TO_DELETE_SECTION, NULL, &Context);
    if (!bFlag)
    {
        goto MySettingsFile_ReadSectionAndDoDelete_Exit;
    }

    // loop through the items in the section.
    while (bFlag) 
    {
        // get the size of the memory we need for this
        bFlag = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            iisDebugOut(_T("err:Out of Memory"));
            goto MySettingsFile_ReadSectionAndDoDelete_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            iisDebugOut(_T("SetupGetLineText failed"));
            goto MySettingsFile_ReadSectionAndDoDelete_Exit;
            }

        // For each of these entries do something
        // Delete the file...

        retCode = GetFileAttributes(szLine);
        if (retCode != 0xFFFFFFFF)
        {
            iReturn = TRUE;
            if (retCode & FILE_ATTRIBUTE_DIRECTORY)
            {
                // it's a directory...recusively delete it
                iisDebugOut(_T("RecRemoveDir:%s\n"),szLine);
                RecRemoveDir(szLine);
            }
            else
            {
                iisDebugOut(_T("InetDeleteFile:%s\n"),szLine);
                InetDeleteFile(szLine);
            }
        }
        else
        {
            iisDebugOut(_T("not found:%s, skipping delete\n"),szLine);
        }

        // find the next line in the section. If there is no next line it should return false
        bFlag = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        if (szLine) {GlobalFree(szLine);szLine=NULL;}
        iReturn = TRUE;
    }

MySettingsFile_ReadSectionAndDoDelete_Exit:
    if (szLine) {GlobalFree(szLine);szLine=NULL;}
    iisDebugOut(_T("MySettingsFile_ReadSectionAndDoDelete:end\n"));
	return iReturn;
}

int MySettingsFile_Install(void)
{
	int iReturn = 0;
	iReturn = InstallInfSection(g_FullFileNamePathToSettingsFile, "DefaultInstall");
	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    if (!psz)
        return NULL;

    // compute the length
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}


//***************************************************************************
//*                                                                         
//* purpose:
//* 
//***************************************************************************
void MakePath(LPTSTR lpPath)
{
   LPTSTR  lpTmp;
   lpTmp = CharPrev( lpPath, lpPath + _tcslen(lpPath));

   // chop filename off
   while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( lpPath, lpTmp );

   if ( *CharPrev( lpPath, lpTmp ) != ':' )
       *lpTmp = '\0';
   else
       *CharNext(lpTmp) = '\0';
   return;
}


//***************************************************************************
//*                                                                         
//* purpose: add's filename onto path
//* 
//***************************************************************************
void AddPath(LPTSTR szPath, LPCTSTR szName )
{
	LPTSTR p = szPath;

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    if (*(_tcsdec(szPath, p)) != _T('\\'))
		{_tcscat(szPath, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

	// Add new name to existing path string
	_tcscat(szPath, szName);
}



//  Prepare to read a value by finding the value's size.
LONG RegPrepareValue(HKEY hKey, LPCTSTR pchValueName, DWORD * pdwType,DWORD * pcbSize,BYTE ** ppbData )
{
    LONG err = 0 ;
    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueEx( hKey, (TCHAR *) pchValueName, 0, pdwType, chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( err == 0 ) 
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( err != ERROR_MORE_DATA ) 
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL ) 
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //  Now that have a buffer, re-fetch the value.

        err = ::RegQueryValueEx( hKey, (TCHAR *) pchValueName, 0, pdwType, *ppbData, pcbSize ) ;

    } while ( FALSE ) ;

    if ( err )  {delete [] *ppbData ;}

    return err ;
}



int AddRegToInfIfExist_Dword(HKEY hRootKeyType,CHAR szRootKey[],CHAR szRootName[],HANDLE fAppendToFile)
{
    int iReturn = FALSE;
    HKEY  hOpen = NULL;
    DWORD dwType;
    DWORD cbData = 500;
    BYTE  bData[500];

	CHAR szTheStringToWrite[2000];
	DWORD dwBytesWritten = 0;

	// Create the HKLM string for the output string
    CHAR szThisKeyType[5];
	strcpy(szThisKeyType, "HKLM");
	if (hRootKeyType == HKEY_LOCAL_MACHINE) {strcpy(szThisKeyType, "HKLM");}
	if (hRootKeyType == HKEY_CLASSES_ROOT) {strcpy(szThisKeyType, "HKCR");}
	if (hRootKeyType == HKEY_CURRENT_USER) {strcpy(szThisKeyType, "HKCU");}
	if (hRootKeyType == HKEY_USERS) {strcpy(szThisKeyType, "HKU");}

    // try to open the key
    if (ERROR_SUCCESS == RegOpenKey(hRootKeyType, szRootKey, &hOpen))
        {
        // try to query the value
        DWORD dwData = 0;
        DWORD dwDataSize = 0;
        dwDataSize = sizeof (DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hOpen,szRootName,NULL,&dwType,(LPBYTE) &dwData,&dwDataSize))
            {
            DWORD dwTheValue = 0;
            dwTheValue = dwData;

            // We got the value.  so now let's write the darn thing out to the file.
            //HKLM,"System\CurrentControlSet\Services\W3Svc\Parameters","MajorVersion",0x00010001,4
            sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00010001,%ld\r\n",szThisKeyType,szRootKey,szRootName,dwTheValue);

            iisDebugOut(_T("AddRegToInfIfExist_Dword:%s."),szTheStringToWrite);

            // write it to the file
            if (fAppendToFile) {WriteFile(fAppendToFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);}
			else {printf(szTheStringToWrite);}

            iReturn = TRUE;
            }
        }

    if (hOpen) {RegCloseKey(hOpen);}
    return iReturn;
}



/*
This function can be used to recursively grab a whole key out
of the registry and write it to a setupapi style .inf file.

[version]
signature="$CHICAGO$"
advancedinf=2.0

[PWS10_Migrate_install]
AddReg=PWS10_Migrate_Reg

[PWS10_Migrate_Reg]   (Creates this section)
HKLM,"System\CurrentControlSet\Services\InetInfo",,,""
HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters",,,""
HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","MaxPoolThreads",0x00000001,05
HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","MaxConcurrency",0x00000001,01
HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","ThreadTimeout",0x00000001,00,2
...
...

Here are the flags as defined in the setupapi.h file:
#define FLG_ADDREG_BINVALUETYPE     ( 0x00000001 ) 
#define FLG_ADDREG_NOCLOBBER        ( 0x00000002 ) 
#define FLG_ADDREG_DELVAL           ( 0x00000004 ) 
#define FLG_ADDREG_APPEND           ( 0x00000008 ) // Currently supported only for REG_MULTI_SZ values. 
#define FLG_ADDREG_KEYONLY          ( 0x00000010 ) // Just create the key, ignore value 
#define FLG_ADDREG_OVERWRITEONLY    ( 0x00000020 ) // Set only if value already exists 
#define FLG_ADDREG_TYPE_SZ          ( 0x00000000 ) 
#define FLG_ADDREG_TYPE_MULTI_SZ    ( 0x00010000 ) 
#define FLG_ADDREG_TYPE_EXPAND_SZ   ( 0x00020000 ) 
#define FLG_ADDREG_TYPE_BINARY      ( 0x00000000 | FLG_ADDREG_BINVALUETYPE ) 
#define FLG_ADDREG_TYPE_DWORD       ( 0x00010000 | FLG_ADDREG_BINVALUETYPE ) 
#define FLG_ADDREG_TYPE_NONE        ( 0x00020000 | FLG_ADDREG_BINVALUETYPE ) 
#define FLG_ADDREG_TYPE_MASK        ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
*/
int RecursivelyMoveRegFormatToInfFormat(HKEY hRootKeyType, CHAR szRootKey[], HANDLE fAppendToFile)
{
	int iReturn = FALSE;
	int iGotDefaultValue = FALSE;

	// Stuff for getting values in our node
	HKEY  hKey = NULL;
	DWORD rc = 0;
	DWORD dwIndex =0, dwType, cbValueName, cbValue, nStrSize;
	CHAR  lpTemp[20], lpValueName[32], msg[512];
	CHAR  *strResult = NULL;
	unsigned int i = 0;
	union vEntry
	{
		DWORD dw;		// REG_DWORD, REG_DWORD_LITTLE_ENDIAN
		CHAR sz[256];	// REG_SZ
		CHAR esz[256];	// REG_EXPAND_SZ
		CHAR bin[1024]; // REG_BINARY
		CHAR dwbig[4];  // REG_DWORD_BIG_ENDIAN
		CHAR msz[2048]; // REG_MULTI_SZ
	} vEntry1;
	
	// Stuff for looping thru keys that we can see
	HANDLE hHeap = NULL;
	DWORD dwBufSize, nSubkeys, nSubkeyNameLen;
	LPTSTR lpBuffer = NULL;

	CHAR szThisKeyType[5];
	CHAR szCompoundFromRootKey[1000];
	CHAR szTheStringToWrite[2000];
	DWORD dwBytesWritten = 0;
	
	// Create the HKLM string for the output string
	strcpy(szThisKeyType, "HKLM");
	if (hRootKeyType == HKEY_LOCAL_MACHINE) {strcpy(szThisKeyType, "HKLM");}
	if (hRootKeyType == HKEY_CLASSES_ROOT) {strcpy(szThisKeyType, "HKCR");}
	if (hRootKeyType == HKEY_CURRENT_USER) {strcpy(szThisKeyType, "HKCU");}
	if (hRootKeyType == HKEY_USERS) {strcpy(szThisKeyType, "HKU");}

	// Get the szRootKey and work from there
	rc = RegOpenKey(hRootKeyType, szRootKey, &hKey);
	if (rc != ERROR_SUCCESS) 
    {
        goto RecursivelyMoveRegFormatToInfFormat_Exit;
    }

	// Grab the "Default" Entry if there is one.
	cbValue = sizeof(vEntry1);
	rc = RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE) &vEntry1, &cbValue) ;
	if ( ERROR_SUCCESS == rc) 
	{
		if (vEntry1.sz)
		{
			iGotDefaultValue = TRUE;
			strResult = (TCHAR *) vEntry1.sz;
			// This can only be a string!
			// from: System\\CurrentControlSet\\Services\\InetInfo
			//       Value = Something
			//   to: HKLM,"Software\Microsoft\InetSrv",,,"Something"
			// ---------------------------------------------------
			sprintf(szTheStringToWrite, "%s,\"%s\",,,\"%s\"\r\n",szThisKeyType, szRootKey, strResult);
			if (fAppendToFile) 
				{WriteFile(fAppendToFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);}
			else 
				{printf(szTheStringToWrite);}
		}
	}
	// if there was no default entry, then just write the key without a default entry.
	if (!iGotDefaultValue)
	{
		//   to: HKLM,"Software\Microsoft\InetSrv",,0x00000010,"Something"
		sprintf(szTheStringToWrite, "%s,\"%s\",,0x00000010,\"%s\"\r\n",szThisKeyType, szRootKey, strResult);
		if (fAppendToFile) {WriteFile(fAppendToFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);}
		else {printf(szTheStringToWrite);}
	}

	// Now Enum all ValueNames under this
	dwIndex = 0;
	while (rc == ERROR_SUCCESS)
	{
		memset(msg, 0, sizeof(msg));
		cbValueName = 32;
		cbValue = sizeof(vEntry1);
		rc = RegEnumValue( hKey, dwIndex++, lpValueName, &cbValueName, NULL, &dwType, (LPBYTE) &vEntry1, &cbValue );
		if ( ERROR_SUCCESS == rc) 
		{
			strcpy(szTheStringToWrite, "");
			switch (dwType)
			{
				case REG_SZ:
					// to: HKLM,"Software\Microsoft\InetSrv","SomethingName",0x00000000,"SomethingData"
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00000000,\"%s\"\r\n",szThisKeyType,szRootKey, lpValueName, vEntry1.sz);
					break;
				case REG_EXPAND_SZ:
					// to: HKLM,"Software\Microsoft\InetSrv","SomethingName",0x00020000,"%windir%\SomethingData"
					nStrSize = ExpandEnvironmentStrings(vEntry1.esz, msg, 512);
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00020000,\"%s\"\r\n",szThisKeyType,szRootKey, lpValueName, vEntry1.sz);
					break;
				case REG_MULTI_SZ:
					// to: HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","ThreadTimeout",0x00000001,00,20
					strcpy(msg, "");
					for (i=0;i < cbValue; i++)
					{
						if (i==0){sprintf(lpTemp, "%02X", (BYTE) vEntry1.bin[i]);}
						else{sprintf(lpTemp, ",%02X", (BYTE) vEntry1.bin[i]);}
						strcat(msg, lpTemp);
					}
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00000001,%s\r\n",szThisKeyType,szRootKey, lpValueName, msg);
					break;
				case REG_DWORD:
					// to: HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","StartupServices",0x00010001,1
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00010001,%ld\r\n",szThisKeyType,szRootKey, lpValueName, vEntry1.dw);
					break;
				case REG_DWORD_BIG_ENDIAN:
				case REG_BINARY:
					// to: HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","MaxPoolThreads",0x00000001,05
					strcpy(msg, "");
					for (i=0;i < cbValue; i++)
					{
						if (i==0){sprintf(lpTemp, "%02X", (BYTE) vEntry1.bin[i]);}
						else{sprintf(lpTemp, ",%02X", (BYTE) vEntry1.bin[i]);}
						strcat(msg, lpTemp);
					}
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00000001,%s\r\n",szThisKeyType,szRootKey, lpValueName, msg);
					break;
				default:
					sprintf(szTheStringToWrite, "; Unknown data value for Key '%s', Value '%s'", szRootKey, lpValueName);
					SetupLogError_Wrap(LogSevError, "Error Reading Registry Key '%s', Unknown data value for key '%s'.",szRootKey, lpValueName);
			}
			if (fAppendToFile) {WriteFile(fAppendToFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);}
			else {printf(szTheStringToWrite);}
		}
	}
	
	//
	// Now Recursively go thru the Sub keys
	//
	RegQueryInfoKey(hKey, NULL, NULL, NULL, &nSubkeys, &nSubkeyNameLen, NULL, NULL, NULL, NULL, NULL, NULL);
	// Allocate memory
	hHeap = GetProcessHeap();
	lpBuffer = (CHAR *) HeapAlloc(hHeap, 0, ++nSubkeyNameLen);
    if (lpBuffer)
    {
	    // Enum thru the keys
	    for (dwIndex = 0; dwIndex < nSubkeys; dwIndex++)
	    {
		    dwBufSize = nSubkeyNameLen;
		    rc = RegEnumKeyEx(hKey, dwIndex, lpBuffer, &dwBufSize, NULL, NULL, NULL, NULL);
		    if ( ERROR_SUCCESS == rc) 
		    {
			    strcpy(szCompoundFromRootKey, szRootKey);
			    strcat(szCompoundFromRootKey, "\\");
			    strcat(szCompoundFromRootKey, lpBuffer);
			    // Call this function again, but with the newly created key.
			    // and they'll tell they're friends, who will tell they're friends... it's amway!
			    RecursivelyMoveRegFormatToInfFormat(hRootKeyType, szCompoundFromRootKey, fAppendToFile);
		    }
	    }
    }
	
	// Set the flag to say, yes we did some work
	iReturn = TRUE;

RecursivelyMoveRegFormatToInfFormat_Exit:
	if (hKey){RegCloseKey(hKey);}
	if (hHeap && lpBuffer){HeapFree(hHeap, 0, lpBuffer);}
	return iReturn;
}



//-------------------------------------------------------------------
//  purpose: install an section in an .inf file
//-------------------------------------------------------------------
int InstallInfSection(char szINFFilename_Full[],char szSectionName[])
{

    HWND	Window			= NULL;
    PTSTR	SourcePath		= NULL;
    HINF	InfHandle		= INVALID_HANDLE_VALUE;
    HSPFILEQ FileQueue		= INVALID_HANDLE_VALUE;
    PQUEUECONTEXT	QueueContext	= NULL;
    BOOL	bReturn			= FALSE;
    BOOL	bError			= TRUE; // assume failure.
    TCHAR	ActualSection[1000];
    DWORD	ActualSectionLength;
    TCHAR * pTemp = NULL;
    iisDebugOut(_T("InstallInfSection(%s, [%s]).  Start."),szINFFilename_Full,szSectionName);

//__try {

	// Get the path to setup.exe and strip off filename so we only have the path
	char szPath[_MAX_PATH]; 

	// get the path only
	strcpy(szPath,g_FullFileNamePathToSettingsFile);

	// strip off the filename
        pTemp = strrchr(szPath, '\\');
        if (pTemp){*pTemp = '\0';}

	// set it to the pointer
	SourcePath = szPath;
        pTemp = NULL;
        pTemp = strrchr(SourcePath, '\\');
        if (pTemp) {*pTemp = '\0';}

	// Check if the file exists
	if (CheckIfFileExists(szINFFilename_Full) == FALSE) 
		{
		SetupLogError_Wrap(LogSevError, "InstallInfSection() Error: Cannot Find the file '%s'.  FAILURE.", szINFFilename_Full);
		goto c0;
		}

	//
    // Load the inf file and get the handle
	//
    InfHandle = SetupOpenInfFile(szINFFilename_Full, NULL, INF_STYLE_WIN4, NULL);
    if(InfHandle == INVALID_HANDLE_VALUE) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupOpenInfFile(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

    //
    // See if there is an nt-specific section
    //
    SetupDiGetActualSectionToInstall(InfHandle,szSectionName,ActualSection,sizeof(ActualSection),&ActualSectionLength,NULL);

    //
    // Create a setup file queue and initialize the default queue callback.
	//
    FileQueue = SetupOpenFileQueue();
    if(FileQueue == INVALID_HANDLE_VALUE) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupOpenFileQueue(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

    //QueueContext = SetupInitDefaultQueueCallback(Window);
    //if(!QueueContext) {goto c1;}
    QueueContext = (PQUEUECONTEXT) SetupInitDefaultQueueCallbackEx(Window,NULL,0,0,0);
    if(!QueueContext) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupInitDefaultQueueCallbackEx(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}
    QueueContext->PendingUiType = IDF_CHECKFIRST;

    //
    // Enqueue file operations for the section passed on the cmd line.
    //
	//SourcePath = NULL;
    bReturn = SetupInstallFilesFromInfSection(InfHandle,NULL,FileQueue,ActualSection,SourcePath,SP_COPY_NEWER);
	if(!bReturn) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupInstallFilesFromInfSection(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

    //
    // Commit file queue.
    //
    if(!SetupCommitFileQueue(Window, FileQueue, SetupDefaultQueueCallback, QueueContext)) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupCommitFileQueue(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

    //
    // Perform non-file operations for the section passed on the cmd line.
    //
    bReturn = SetupInstallFromInfSection(Window,InfHandle,ActualSection,SPINST_ALL ^ SPINST_FILES,NULL,NULL,0,NULL,NULL,NULL,NULL);
    if(!bReturn) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupInstallFromInfSection(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

	//
    // Refresh the desktop.
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

    //
    // If we get to here, then this routine has been successful.
    //
    bError = FALSE;

c1:
    //
    // If the bError was because the user cancelled, then we don't want to consider
    // that as an bError (i.e., we don't want to give an bError popup later).
    //
    if(bError && (GetLastError() == ERROR_CANCELLED)) {bError = FALSE;}
	if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);QueueContext = NULL;}
	if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);FileQueue = INVALID_HANDLE_VALUE;}
	if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}

c0: ;

//    } __except(EXCEPTION_EXECUTE_HANDLER) 
//		{
//        if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);}
//        if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);}
//        if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);}
//		}

    //
    // If the bError was because the user cancelled, then we don't want to consider
    // that as an bError (i.e., we don't want to give an bError popup later).
    //
    if(bError && (GetLastError() == ERROR_CANCELLED)) {bError = FALSE;}

	// Display installation failed message
    if(bError) 
	{
		SetupLogError_Wrap(LogSevError, "InstallInfSection(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);
	}
	else
	{
		iisDebugOut(_T("InstallInfSection(%s, [%s]).  End."),szINFFilename_Full,szSectionName);
	}
	
    return bError;
}

int MySettingsFile_Write_PWS40(HANDLE hFile)
{
	int iReturn = FALSE;
	int iEverythingIsKool = TRUE;
	CHAR szTheStringToWrite[2000];
	DWORD dwBytesWritten = 0;
	TCHAR szMetabaseFullPath[_MAX_PATH];

	// Registry variables
	HKEY hKey = NULL;
	DWORD dwType, cbData=1000,rc=0;
	BYTE   bData[1000];

	char *token = NULL;
	
	iisDebugOut(_T("MySettingsFile_Write_PWS40.  Start."));

	if (hFile)
	{
		// ----------------------------
		// Write the header information
		// ----------------------------
		strcpy(szTheStringToWrite, "[version]\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}
		
		strcpy(szTheStringToWrite, "signature=\"$CHICAGO$\"\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		strcpy(szTheStringToWrite, "advancedinf=2.0\r\n\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		// Create a [DefaultInstall] section which will get run
		// ----------------------------
		strcpy(szTheStringToWrite, "[DefaultInstall]\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "AddReg=%s\r\n", g_Migration_Section_Name_AddReg);
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

//		sprintf(szTheStringToWrite, "CopyFiles=%s\r\n\r\n", g_Migration_Section_Name_CopyFiles);
//		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
//		if (!iReturn) {iEverythingIsKool = FALSE;}
		
		// inetstp setup information
		// AddReg information
		// ----------------------------
		iisDebugOut(_T("MySettingsFile_Write_PWS40.  Adding AddReg Section."));
		sprintf(szTheStringToWrite, "[%s]\r\n", g_Migration_Section_Name_AddReg);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		// Now, Get the ";" delimited list of HKLM registry values to read and write to our file.
		char szSemiColonDelimitedList[1024];
		strcpy(szSemiColonDelimitedList,"");
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_PWS40_HKLM_REG_TO_MIGRATE, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
			{
			iisDebugOut(_T("MySettingsFile_Write_PWS40.  Err or LoadString retieval of IDS_PWS40_HKLM_REG_TO_MIGRATE, Defaulting with english registry values to copy over."));
			strcpy(szSemiColonDelimitedList,"Software\\Microsoft\\InetStp;System\\CurrentControlSet\\Services\\InetInfo;System\\CurrentControlSet\\Services\\W3Svc;System\\CurrentControlSet\\Services\\ASP");
			}

		//LOOP THRU THE LIST
		token = NULL;
		token = strtok( szSemiColonDelimitedList, g_LoadString_token_delimiters);
		while( token != NULL )
			{
			// we really should remove pre/post trailing spaces

			// Grab this certain value("Software\\Microsoft\\INetStp")
			// and recursively write it to our "settings" file
			RecursivelyMoveRegFormatToInfFormat_Wrap1(HKEY_LOCAL_MACHINE,token,hFile);

			// Get next token
			token = strtok( NULL, g_LoadString_token_delimiters);
			}

        // Lookup these key,string value pairs and
        // if they exist, add them to the inf file.
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_common",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_www",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_pwmgr",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_doc_common",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_doc_pwmcore",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_doc_asp",hFile);

/*
		// CopyFiles information
		// ----------------------------
		// Lookup the inetstp key to get the location of inetsrv directory.
		iisDebugOut(_T("MySettingsFile_Write_PWS40.  CopyFiles Section. lookup registry inetstp."));
		rc = RegOpenKey(HKEY_LOCAL_MACHINE, REG_INETSTP, &hKey);
		if ( ERROR_SUCCESS != rc) 
		{
			SetLastError (rc);
			SetupLogError_Wrap(LogSevError, "Failed to open registry key %s GetLastError()=%x", REG_INETSTP, GetLastError());
			// if the key does not exist, then hey, we won't be able to find
			// the metabase, much less upgrade it!
			// so let's bag out of here!
			iEverythingIsKool = FALSE;
			goto MySettingsFile_Write_PWS40_Exit;
		} 

		// try to query the value
		rc = RegQueryValueEx(hKey,REG_INETSTP_INSTALLPATH_STRINGVALUE,NULL,&dwType,bData,&cbData);
		if ( ERROR_SUCCESS != rc) 
		{
			SetLastError (rc);
			SetupLogError_Wrap(LogSevError, "Failed to Read Registry key %s Value in Key '%s'.  GetLastError()=%x", REG_INETSTP_INSTALLPATH_STRINGVALUE, REG_INETSTP, GetLastError());
			iEverythingIsKool = FALSE;
			goto MySettingsFile_Write_PWS40_Exit;
		}
		// We have the value, copy it to our string
		// Should look something like this "c:\\windows\system\inetsrv"
		_tcscpy(szMetabaseFullPath, (const char *) bData);
		// Now add on the metadata.dll part
		AddPath(szMetabaseFullPath, METADATA_DLL_FILENAME);

		// Check if it exists.
		if (CheckIfFileExists(szMetabaseFullPath) != TRUE) 
		{
			SetupLogError_Wrap(LogSevError, "File not found FAILURE. '%s'.", szMetabaseFullPath);
			iEverythingIsKool = FALSE;
			goto MySettingsFile_Write_PWS40_Exit;
		}
		iisDebugOut(_T("MySettingsFile_Write_PWS40.  CopyFiles Section. Check if file exist %s = TRUE", szMetabaseFullPath));

		// Now we need to copy this file from
		// the system dir to the system32 directory.
		// So... let's create an entry in our "settings" file
		// to do it upon installation.
		//[Section1]
		//Metabase.Dll
		iisDebugOut(_T("MySettingsFile_Write_PWS40.  Adding CopyFiles supporting Sections."));
		sprintf(szTheStringToWrite, "\r\n[%s]\r\n", g_Migration_Section_Name_CopyFiles);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "%s\r\n\r\n", METADATA_DLL_FILENAME);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		//[DestinationDirs]
		//Section1=11
		sprintf(szTheStringToWrite, "[DestinationDirs]\r\n");
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "%s=11  ;System on win95, System32 on WinNT\r\n\r\n", g_Migration_Section_Name_CopyFiles);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		//[SourceDisksNames]
		//1="Setup Files",,,system
		sprintf(szTheStringToWrite, "[SourceDisksNames]\r\n");
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "1= \"Files copied from win95\\system dir\",,,System\r\n\r\n");
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		//[SourceDisksFiles]
		//Metabase.Dll=1
		sprintf(szTheStringToWrite, "[SourceDisksFiles]\r\n");
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "%s=1\r\n\r\n", METADATA_DLL_FILENAME);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}
*/

		iReturn = iEverythingIsKool;
	}


//MySettingsFile_Write_PWS40_Exit:
	iisDebugOut(_T("MySettingsFile_Write_PWS40.  End.  Return=%d"), iReturn);
	if (hKey){RegCloseKey(hKey);}
	return iReturn;
}


int MySettingsFile_Write_PWS10(HANDLE hFile)
{
	int iReturn = FALSE;
	int iEverythingIsKool = TRUE;
	CHAR szTheStringToWrite[2000];
	DWORD dwBytesWritten;
	char *token = NULL;

	iisDebugOut(_T("MySettingsFile_Write_PWS10.  Start."));
	if (hFile)
	{
		strcpy(szTheStringToWrite, "[version]\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}
		
		strcpy(szTheStringToWrite, "signature=\"$CHICAGO$\"\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		strcpy(szTheStringToWrite, "advancedinf=2.0\r\n\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		// Create a [DefaultInstall] section which will get run
		strcpy(szTheStringToWrite, "[DefaultInstall]\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "AddReg=%s\r\n\r\n", g_Migration_Section_Name_AddReg);
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "[%s]\r\n", g_Migration_Section_Name_AddReg);
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		// Now, Get the ";" delimited list of HKLM registry values to read and write to our file.
		char szSemiColonDelimitedList[1024];
		strcpy(szSemiColonDelimitedList,"");
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_PWS10_HKLM_REG_TO_MIGRATE, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
			{
			iisDebugOut(_T("MySettingsFile_Write_PWS10.  Err or LoadString retieval of IDS_PWS10_HKLM_REG_TO_MIGRATE, Defaulting with english registry values to copy over."));
			strcpy(szSemiColonDelimitedList, "Software\\Microsoft\\INetStp;System\\CurrentControlSet\\Services\\InetInfo;System\\CurrentControlSet\\Services\\MsFtpSvc;System\\CurrentControlSet\\Services\\W3Svc");
			}

		//LOOP THRU THE LIST
		token = NULL;
		token = strtok( szSemiColonDelimitedList, g_LoadString_token_delimiters);
		while( token != NULL )
			{
			// we really should remove pre/post trailing spaces

			// Grab this certain value("Software\\Microsoft\\INetStp")
			// and recursively write it to our "settings" file
			RecursivelyMoveRegFormatToInfFormat_Wrap1(HKEY_LOCAL_MACHINE,token,hFile);

			// Get next token
			token = strtok( NULL, g_LoadString_token_delimiters);
			}

		// set the return value to 
		iReturn = iEverythingIsKool;
	}
	iisDebugOut(_T("MySettingsFile_Write_PWS10.  End.  Return=%d"), iReturn);
	return iReturn;
}


int MyMessageBox(char szMsg[], char szFileName[])
{
	char szTempErrString[200];
	sprintf(szTempErrString, szMsg, szFileName);
	return MessageBox(NULL, szTempErrString, "PWS Migration Dll Failure", MB_OK);
}

// handle the [HKEY_LOCAL_MACHINE\Enum\Network\MSWEBSVR] reg key
void HandleSpecialRegKey(void)
{
	int iReturn = FALSE;
	
	HKEY hKey = NULL;
	if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_NETWORK_MSWEBSVR, &hKey))
        {iReturn = TRUE;}
    if (hKey){RegCloseKey(hKey);}

	if (iReturn == TRUE)
	{
		// Write to the Migrate.inf file that we are "Handling" this registry settings.
		iisDebugOut(_T("HandleSpecialRegKey. Write Entry to Migrate.inf file."));
		iReturn = MigInf_AddHandledRegistry(REG_HKLM_NETWORK_MSWEBSVR, NULL);
		if (iReturn != TRUE) {SetupLogError_Wrap(LogSevWarning, "Warning: MigInf_AddHandledRegistry() FAILED.");}

		//
		// Important: Write memory version of migrate.inf to disk
		//
		if (!MigInf_WriteInfToDisk()) 
		{
            iReturn = GetLastError();
			SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.err=0x%x",iReturn);
		}
	}

	if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_PWS_40_UNINSTALL_KEY, &hKey))
        {iReturn = TRUE;}
    if (hKey){RegCloseKey(hKey);}

	if (iReturn == TRUE)
	{
		// Write to the Migrate.inf file that we are "Handling" this registry settings.
		iisDebugOut(_T("HandleSpecialRegKey. Write Entry2 to Migrate.inf file."));
		iReturn = MigInf_AddHandledRegistry(REG_HKLM_PWS_40_UNINSTALL_KEY, NULL);
		if (iReturn != TRUE) {SetupLogError_Wrap(LogSevWarning, "Warning: MigInf_AddHandledRegistry2() FAILED.");}

		//
		// Important: Write memory version of migrate.inf to disk
		//
		if (!MigInf_WriteInfToDisk()) 
		{
            iReturn = GetLastError();
			SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk2() FAILED.err=0x%x",iReturn);
		}
	}
}

void RecursivelyMoveRegFormatToInfFormat_Wrap1(HKEY hRootKeyType, CHAR szRootKey[], HANDLE fAppendToFile)
{
	int iReturn = FALSE;
	char szTheFullKey[512];
	char szTheMask[50];

	// use this stuff for the migrate.inf file
	strcpy(szTheMask, "HKLM\\%s");
	if (hRootKeyType == HKEY_LOCAL_MACHINE) {strcpy(szTheMask, "HKLM\\%s");}
	if (hRootKeyType == HKEY_CLASSES_ROOT) {strcpy(szTheMask, "HKCR\\%s");}
	if (hRootKeyType == HKEY_CURRENT_USER) {strcpy(szTheMask, "HKCU\\%s");}
	if (hRootKeyType == HKEY_USERS) {strcpy(szTheMask, "HKU\\%s");}
	sprintf(szTheFullKey, szTheMask, szRootKey);
	iisDebugOut(_T("RecursivelyMoveRegFormatToInfFormat_Wrap1. %s"), szTheFullKey);

	// Call the real recursive function
	iReturn = RecursivelyMoveRegFormatToInfFormat(hRootKeyType, szRootKey, fAppendToFile);

    //
    // Write handled for every setting we are processing.  Because this
    // DLL supports only some of the values in the Desktop key, we must
    // be very specific as to which values are actually handled.  If
    // your DLL handles all registry values AND subkeys of a registry
    // key, you can specify NULL in the second parameter of 
    // MigInf_AddHandledRegistry.
    //
	if (iReturn == TRUE)
	{
		// Write to the Migrate.inf file that we are "Handling" this registry settings.
		iisDebugOut(_T("RecursivelyMoveRegFormatToInfFormat_Wrap1. Write Entry to Migrate.inf file."));
		iReturn = MigInf_AddHandledRegistry(szTheFullKey, NULL);
		if (iReturn != TRUE) {SetupLogError_Wrap(LogSevWarning, "Warning: MigInf_AddHandledRegistry() FAILED.");}

		//
		// Important: Write memory version of migrate.inf to disk
		//
		if (!MigInf_WriteInfToDisk()) 
		{
            iReturn = GetLastError();
			SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.err=0x%x",iReturn);
		}
	}

	return;
}



int ReturnImportantDirs(void)
{
	int iReturn = FALSE;
	if (g_iPWS40OrBetterInstalled == TRUE)
		{
		// do something
		}
	else if (g_iPWS10Installed == TRUE)
		{
		// do something else
		}
	return iReturn;
}


void SetupLogError_Wrap(IN LogSeverity TheSeverityErr, TCHAR *MessageString, ...)
{
	TCHAR acsString[1000];
	TCHAR acsString2[1000];

	va_list va;
	va_start(va, MessageString);
    _vstprintf(acsString, MessageString, va);
	va_end(va);

	// Append on Our modules information.
	_stprintf(acsString2, _T("SetupLogError: %s"), acsString);
	iisDebugOut(acsString2);

	_stprintf(acsString2, _T("[PWS Migration DLL]:%s%s"), g_MyLogFile.m_szLogPreLineInfo, acsString);
	SetupLogError(acsString2, TheSeverityErr);

	return;
}


int SetMetabaseToDoUnEncryptedRead(int iOnFlag)
{
	int iReturn = FALSE;

	DWORD rc = 0;
	HKEY hKey = NULL;
	DWORD dwResult = 0;
	DWORD DontCare;
    rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REG_INETSTP, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &hKey, &DontCare);
    if (rc != ERROR_SUCCESS) 
	{
		SetLastError(rc);
		goto SetMetabaseToDoUnEncryptedRead_Exit;
	}
		
	dwResult = 1;
	rc = RegSetValueEx(hKey, METABASEUNSECUREDREAD_VALUENAME, 0, REG_DWORD, (const BYTE *) &dwResult, sizeof dwResult);
    if (rc != ERROR_SUCCESS) 
	{
		SetLastError(rc);
		goto SetMetabaseToDoUnEncryptedRead_Exit;
	}

	iReturn = TRUE;

SetMetabaseToDoUnEncryptedRead_Exit:
	if (hKey){RegCloseKey(hKey);}
	return iReturn;
}


void DeleteMetabaseSchemaNode(void)
{
    CMDKey cmdKey;
    cmdKey.OpenNode(_T("/"));
    if ( (METADATA_HANDLE) cmdKey ) 
    {
        iisDebugOut(_T("MyUpgradeTasks.DeleteNode /Schema.Start."));
        cmdKey.DeleteNode(_T("Schema"));
        cmdKey.Close();
        iisDebugOut(_T("MyUpgradeTasks.DeleteNode /Schema.End."));
    }
    return;
}

BOOL MyDeleteLink(LPTSTR lpszShortcut)
{
    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory(szFile, sizeof(szFile));
    _tcscpy(szFile, lpszShortcut);

	iisDebugOut(_T("MyDeleteLink(): %s.\n"), szFile);

    if (CheckIfFileExists(szFile))
    {
        ZeroMemory(&fos, sizeof(fos));
        fos.hwnd = NULL;
        fos.wFunc = FO_DELETE;
        fos.pFrom = szFile;
        fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        if (SHFileOperation(&fos) != 0)
        {
            iisDebugOut(_T("MyDeleteLink(): SHFileOperation FAILED\n"));
        }
    }
    else
    {
        //iisDebugOutSafeParams((_T("MyDeleteLink(): CheckIfFileExists(%1!s!) = FALSE FAILURE\n"), szFile));
    }

    return TRUE;
}

void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));

    MyDeleteLink(szPath);

    // try to remove items added by AddURLShortcutItem()
    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".url"));

    MyDeleteLink(szPath);

    if (MyIsGroupEmpty(szGroupName)) {MyDeleteGroup(szGroupName);}
}

void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath)
{
    int            nLen = 0;
    LPITEMIDLIST   pidlPrograms;

    if (SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlPrograms) != NOERROR)
    {
        if (SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &pidlPrograms) != NOERROR)
            {iisDebugOut(_T("MyGetGroupPath() SHGetSpecialFolderLocation FAILED\n"));}
    }

    if (SHGetPathFromIDList(pidlPrograms, szPath) != TRUE)
        {iisDebugOut(_T("MyGetGroupPath() SHGetPathFromIDList FAILED\n"));}

    nLen = _tcslen(szPath);
    if (szGroupName)
    {
        if (szPath[nLen-1] != _T('\\')){_tcscat(szPath, _T("\\"));}
        _tcscat(szPath, szGroupName);
    }

    //iisDebugOut(_T("MyGetGroupPath(%s). Returns %s.\n"), szGroupName, szPath);
    return;
}


BOOL MyIsGroupEmpty(LPCTSTR szGroupName)
{
    TCHAR             szPath[MAX_PATH];
    TCHAR             szFile[MAX_PATH];
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
    BOOL              fReturn = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    _tcscpy(szFile, szPath);
    _tcscat(szFile, _T("\\*.*"));

    hFind = FindFirstFile(szFile, &FindData);
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
           fReturn = FALSE;
           break;
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }
    FindClose(hFind);

    return fReturn;
}


BOOL MyDeleteGroup(LPCTSTR szGroupName)
{
    BOOL fResult;
    TCHAR             szPath[MAX_PATH];
    TCHAR             szFile[MAX_PATH];
    SHFILEOPSTRUCT    fos;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    //we can't remove a directory that is not empty, so we need to empty this one

    _tcscpy(szFile, szPath);
    _tcscat(szFile, _T("\\*.*"));

    ZeroMemory(&fos, sizeof(fos));
    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

    hFind = FindFirstFile(szFile, &FindData);
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
          //copy the path and file name to our temp buffer
          memset( (PVOID)szFile, 0, sizeof(szFile));
          _tcscpy(szFile, szPath);
          _tcscat(szFile, _T("\\"));
          _tcscat(szFile, FindData.cFileName);
          //add a second NULL because SHFileOperation is looking for this
          _tcscat(szFile, _T("\0"));

          //delete the file
          fos.pFrom = szFile;
          if (SHFileOperation(&fos) != 0)
            {iisDebugOut(_T("MyDeleteGroup(): SHFileOperation FAILED\n"));}
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }
    FindClose(hFind);

    fResult = RemoveDirectory(szPath);
    if (fResult) {SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szPath, 0);}
    return(fResult);
}


#define PWS_SHUTDOWN_EVENT "Inet_shutdown"
BOOL W95ShutdownW3SVC(void)
{
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(PWS_SHUTDOWN_EVENT));
    if ( hEvent == NULL ) 
	    {return(TRUE);}

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) 
	    {SetEvent( hEvent );}

    CloseHandle(hEvent);
    return(TRUE);
}


typedef void (*pFunctionIISDLL)(CHAR *szSectionName);

int Call_IIS_DLL_INF_Section(CHAR *szSectionName)
{
    int iReturn = FALSE;
    HINSTANCE hDll = NULL;
    pFunctionIISDLL pMyFunctionPointer = NULL;

    TCHAR szSystemDir[_MAX_PATH];
    TCHAR szFullPath[_MAX_PATH];

    // get the c:\winnt\system32 dir
    if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
        {
        iisDebugOut(_T("Call_IIS_DLL_INF_Section(%s).GetSystemDirectory FAILED."),szSectionName);
        goto Call_IIS_DLL_INF_Section_Exit;
        }

    // Tack on the setup\iis.dll subdir and filename
    sprintf(szFullPath, "%s\\setup\\iis.dll",szSystemDir);
  
	// Check if the file exists
    if (TRUE != CheckIfFileExists(szFullPath))
        {
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.CheckIfFileExists(%s) FAILED."),szFullPath);
        goto Call_IIS_DLL_INF_Section_Exit;
        }

    // Try to load the module,dll,ocx.
    hDll = LoadLibraryEx(szFullPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
	if (!hDll)
	    {
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.LoadLibraryEx(%s) FAILED."),szFullPath);
        goto Call_IIS_DLL_INF_Section_Exit;
        }

    // get the function
    pMyFunctionPointer = (pFunctionIISDLL) GetProcAddress( hDll, "ProcessInfSection");
    if (pMyFunctionPointer)
    {
        // we have the function.. let's call it.
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.Calling function [ProcessInfSection] Now...start"));
        (*pMyFunctionPointer)(szSectionName);
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.Calling function [ProcessInfSection] Now...end"));
        iReturn = TRUE;
    }
    else
    {
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.GetProcAddress(ProcessInfSection) FAILED."));
    }

Call_IIS_DLL_INF_Section_Exit:
    if (hDll){FreeLibrary(hDll);}
    return iReturn;
}


int GetInetSrvDir(CHAR *szOutputThisFullPath)
{
	int iEverythingIsKool = TRUE;
	TCHAR szMetabaseFullPath[_MAX_PATH];

	// Registry variables
	HKEY  hKey = NULL;
	DWORD dwType, cbData=1000,rc=0;
	BYTE  bData[1000];

	// CopyFiles information
	// ----------------------------
	// Lookup the inetstp key to get the location of inetsrv directory.
	iisDebugOut(_T("GetInetSrvDir.  lookup registry inetstp."));
	rc = RegOpenKey(HKEY_LOCAL_MACHINE, REG_INETSTP, &hKey);
	if ( ERROR_SUCCESS != rc) 
	{
		SetLastError (rc);
		SetupLogError_Wrap(LogSevError, "Failed to open registry key %s GetLastError()=%x", REG_INETSTP, GetLastError());
		// if the key does not exist, then hey, we won't be able to find
		// the metabase, much less upgrade it!
		// so let's bag out of here!
		iEverythingIsKool = FALSE;
		goto GetInetSrvDir_Exit;
	} 

	// try to query the value
	rc = RegQueryValueEx(hKey,REG_INETSTP_INSTALLPATH_STRINGVALUE,NULL,&dwType,bData,&cbData);
	if ( ERROR_SUCCESS != rc) 
	{
		SetLastError (rc);
		SetupLogError_Wrap(LogSevError, "Failed to Read Registry key %s Value in Key '%s'.  GetLastError()=%x", REG_INETSTP_INSTALLPATH_STRINGVALUE, REG_INETSTP, GetLastError());
		iEverythingIsKool = FALSE;
		goto GetInetSrvDir_Exit;
	}
	// We have the value, copy it to our string
	// Should look something like this "c:\\windows\system\inetsrv"
	_tcsncpy(szMetabaseFullPath, (const char *) bData, _MAX_PATH);
  szMetabaseFullPath[_MAX_PATH - 1] = '\0';

    // we only want the path part, so copy that to the output string
    _tcscpy(szOutputThisFullPath, szMetabaseFullPath);


    iEverythingIsKool = TRUE;
	iisDebugOut(_T("GetInetSrvDir.  Check if file exist %s = TRUE"), szMetabaseFullPath);

GetInetSrvDir_Exit:
    if (hKey){RegCloseKey(hKey);}
    return iEverythingIsKool;
}


int MyUpgradeTasks(LPCSTR AnswerFile)
{
	int    iReturn = FALSE;
	HANDLE hFile;
    TCHAR  szQuotedPath[_MAX_PATH];
    TCHAR  szMyInetsrvDir[_MAX_PATH];
    TCHAR  szFullMetadataPath[_MAX_PATH];
    TCHAR  szNewFileName[_MAX_PATH];
    int    iDoTheSwap = FALSE;
	iisDebugOut(_T("MyUpgradeTasks.  Start."));

	// if this is pws 1.0, then hey, we don't need to do anything
	// other than copy over the registry, so just get out of here.
	if (g_iPWS10Installed == TRUE) {goto MyUpgradeTasks_Exit;}

	// if this is pws 4.0 then we
	// need to take the iis 4.0 metabase and do certain things to it:
	// 1. Call DeleteApp
	if (g_iPWS40OrBetterInstalled == TRUE)
	{
		// Facts:
		// 1. win95 doesn't have security, so the encrypted stuff in metabase on win95
		//    is not encrypted.
		// 2. NT does have security, so the encrypted stuff in the metabase is read/write
		//    as encrypted automatically, within the metabase code.
		//
		// problem:
		// 1. If we are migrating the metabase from pws 4.0 on win95, then there is
		//    a bunch of encrypted keys in the metabase which aren't encrypted and
		//    we need a way to tell the metabase that it needs to read the data
		//    as "not encrypted" data.  it's okay to write it out as encrypted, but
		//    it's not cool to read the "not encrypted" data as encrypted.
		//
		// Solution:
		// 1. Set the registry stuff:
		// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\INetStp
		//    MetabaseUnSecuredRead= (DWORD) 1  or   0
		//    1= Yes, metabase, please read your stuff our of the metabase as unsecured.
		//    2= No, Metabase, read your stuff out of the metabase like you normally do.
		// The noexistance of the key is equal to MetabaseUnSecuredRead=0

		// Create a special key in the registry.
		if (SetMetabaseToDoUnEncryptedRead(TRUE) != TRUE)
		{
			SetupLogError_Wrap(LogSevError, "Unable to set Metabase (MetabaseUnSecuredRead flag) on.  PWS 4.0 metabase will not be Migrated.  FAILER.");
			goto MyUpgradeTasks_Exit;
		}
			
		// try to call the AppDeleteRecoverable() function in the metabase.
		// Which will tell the metabase to prepare to disconnect itself from
		// Transaction Server and save all it's data to it's dat file.
        /*
#ifdef SPECIAL_METABASE_STUFF
		if (TRUE != AppDeleteRecoverable_Wrap("LM/W3SVC"))
		{
			// Set to true anyway, because the user could be re-running this.
			iReturn = TRUE;
			SetupLogError_Wrap(LogSevError, "Call to AppDeleteRecoverable_Wrap() FAILED.");
			goto MyUpgradeTasks_Exit;
		}
#endif
        */

        // Before changing the metabase.bin file
        // let's save it somewhere.

        // 1. Get the %windir%\system\inetsrv directory where metabase.bin lives.
        // 2. copy that metabase.bin file to "anothername".
        _tcscpy(szMyInetsrvDir, _T(""));
        if (TRUE == GetInetSrvDir(szMyInetsrvDir))
        {
            _tcscpy(szFullMetadataPath, szMyInetsrvDir);
	        AddPath(szFullMetadataPath, METABASE_BIN_FILENAME);
	        // Check if it exists.
	        if (CheckIfFileExists(szFullMetadataPath) == TRUE)
	            {iDoTheSwap = TRUE;}
            if (TRUE == iDoTheSwap)
            {
                _tcscpy(szNewFileName, szMyInetsrvDir);
                AddPath(szNewFileName, METABASE_BIN_BEFORE_CHANGE);

                // Delete any that already exists.
                if (CheckIfFileExists(szNewFileName) == TRUE){DeleteFile(szNewFileName);}

	            iisDebugOut(_T("Calling WritePrivateProfileString.%s."), AnswerFile);
                sprintf(szQuotedPath, "\"%s\"",szFullMetadataPath);
	            if (0 == WritePrivateProfileString(UNATTEND_TXT_PWS_SECTION, UNATTEND_TXT_PWS_METABASE_ORGINAL, szQuotedPath, AnswerFile))
	            {
		            SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", UNATTEND_TXT_PWS_METABASE_ORGINAL, AnswerFile, GetLastError());
	            }
                
                // Copy Metadata.bin to anothername
		        if (0 == CopyFile(szFullMetadataPath, szNewFileName, FALSE))
		        {
			        SetupLogError_Wrap(LogSevError, "Call to CopyFile() Failed. from=s%,to=%s. GetLastError=%x.", szFullMetadataPath, szNewFileName, GetLastError());
                    iDoTheSwap = FALSE;
		        }
            }
        }
        // 3. change the metabase.bin
        //  Delete the "Schema" node
        DeleteMetabaseSchemaNode();

        // 4. stop the web server
        // 5. rename metabase.bin to "asdfghjk.002"
        // 6. rename "asdfghjk.001" to metabase.bin
        // 7. this way if setup is cancelled, then they will still have a win95/98 web server that works!
        if (TRUE == iDoTheSwap)
        {
            // Stop the web server...
            W95ShutdownW3SVC();
            W95ShutdownIISADMIN();

            _tcscpy(szFullMetadataPath, szMyInetsrvDir);
            AddPath(szFullMetadataPath, METABASE_BIN_FILENAME);
            // Check if it exists.
	        if (CheckIfFileExists(szFullMetadataPath) == TRUE)
            {
                // rename metadata.bin to somethingelsenew
                _tcscpy(szNewFileName, szMyInetsrvDir);
                AddPath(szNewFileName, METABASE_BIN_AFTER_CHANGE);
                // Delete any that already exists.
                if (CheckIfFileExists(szNewFileName) == TRUE){DeleteFile(szNewFileName);}
                // Copy Metadata.bin to anothername
		        if (0 == CopyFile(szFullMetadataPath, szNewFileName, FALSE))
		        {
                    SetupLogError_Wrap(LogSevError, "Call to CopyFile() Failed. from=s%,to=%s. GetLastError=%x.", szFullMetadataPath, szNewFileName, GetLastError());
		        }
                else
                {
	                iisDebugOut(_T("Calling WritePrivateProfileString.%s."), AnswerFile);
                    sprintf(szQuotedPath, "\"%s\"",szNewFileName);
	                if (0 == WritePrivateProfileString(UNATTEND_TXT_PWS_SECTION, UNATTEND_TXT_PWS_METABASE_NEW, szQuotedPath, AnswerFile))
	                {
		                SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", UNATTEND_TXT_PWS_METABASE_NEW, AnswerFile, GetLastError());
	                }

                    // rename old backedupname to metadata.bin
                    _tcscpy(szNewFileName, szMyInetsrvDir);
                    AddPath(szNewFileName, METABASE_BIN_BEFORE_CHANGE);

                    // Delete any that already exists.
                    if (CheckIfFileExists(szFullMetadataPath) == TRUE){DeleteFile(szFullMetadataPath);}
                
                    // Copy anothername to Metadata.bin
		            if (0 == CopyFile(szNewFileName, szFullMetadataPath, FALSE))
		            {
                        SetupLogError_Wrap(LogSevError, "Call to CopyFile() Failed. from=s%,to=%s. GetLastError=%x.", szNewFileName, szFullMetadataPath, GetLastError());
		            }
                    else
                    {
                        // Delete the anothername old file
                        DeleteFile(szNewFileName);
                    }
                }
            }
        }
        
		// we've gotten this far, things must be good.
		iReturn = TRUE;
	}

MyUpgradeTasks_Exit:
	iisDebugOut(_T("MyUpgradeTasks.  End.  Return = %d"), iReturn);
	return iReturn;
}


#define IISADMIN_SHUTDOWN_EVENT "Internet_infosvc_as_exe"
BOOL W95ShutdownIISADMIN(void)
{
    DWORD i;
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(IISADMIN_SHUTDOWN_EVENT));
    if ( hEvent == NULL ) {
        return(TRUE);
    }
    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }
    CloseHandle(hEvent);
    for (i=0; i < 20; i++) 
    {
        hEvent = CreateEvent(NULL, TRUE, FALSE, _T(IISADMIN_SHUTDOWN_EVENT));
        if ( hEvent != NULL ) {
            DWORD err = GetLastError();
            CloseHandle(hEvent);

            if ( err == ERROR_ALREADY_EXISTS ) {
                Sleep(500);
                continue;
            }
        }

        break;
    }

    return(TRUE);
}


int CheckFrontPageINI(void)
{
    int iReturn = FALSE;
    char szWindowsDir[_MAX_PATH];
    char szFullPathedFilename[_MAX_PATH];
    char szFrontPageINIFilename[] = "frontpg.ini\0";

	strcpy(szWindowsDir, "");
	if (0 == GetWindowsDirectory(szWindowsDir, sizeof(szWindowsDir)))
	{
		// Error so write it out
		SetupLogError_Wrap(LogSevError, "Call to GetWindowsDirectory() Failed. GetLastError=%x.", GetLastError());
		goto CheckFrontPageINI_Exit;
	}

	// copy our settings file to this directory.
	strcpy(szFullPathedFilename, szWindowsDir);
	AddPath(szFullPathedFilename, szFrontPageINIFilename);
    iReturn = CheckIfFileExists(szFullPathedFilename);

CheckFrontPageINI_Exit:
    return iReturn;
}


void MoveFrontPageINI(void)
{
    // since the frontpage guys didn't write a migrate.dll
    // we'll have to handle one file for them during the win95/98 upgrade.
    //
    // if we find the c:\windows\frontpg.ini file
    // then we'll have to rename it to frontpage.txt
    // then during they're install they will rename it back to frontpg.ini
    int iSomethingToDo = FALSE;
    int iFileExists = FALSE;
    int iFileExists_new = FALSE;
    char szWindowsDir[_MAX_PATH];
	char szFullPathedFilename[_MAX_PATH];
    char szFullPathedFilename_new[_MAX_PATH];
    char szFrontPageINIFilename[] = "frontpg.ini\0";
    char szFrontPageINIFilename_new[] = "frontpg.txt\0";

	strcpy(szWindowsDir, "");
	if (0 == GetWindowsDirectory(szWindowsDir, sizeof(szWindowsDir)))
	{
		// Error so write it out
		SetupLogError_Wrap(LogSevError, "Call to GetWindowsDirectory() Failed. GetLastError=%x.", GetLastError());
		goto MoveFrontPageINI_Exit;
	}

	// copy our settings file to this directory.
	strcpy(szFullPathedFilename, szWindowsDir);
	AddPath(szFullPathedFilename, szFrontPageINIFilename);
    iFileExists = CheckIfFileExists(szFullPathedFilename);

	strcpy(szFullPathedFilename_new, szWindowsDir);
	AddPath(szFullPathedFilename_new, szFrontPageINIFilename_new);
    iFileExists_new = CheckIfFileExists(szFullPathedFilename_new);

    if (FALSE == iFileExists && FALSE == iFileExists_new)
    {
        // Neither files exists, we don't have to do jack
        goto MoveFrontPageINI_Exit;
    }

    if (TRUE == iFileExists)
    {
        if (TRUE == iFileExists_new)
            {DeleteFile(szFullPathedFilename_new);}

		if (0 == CopyFile(szFullPathedFilename, szFullPathedFilename_new, FALSE))
		{
			SetupLogError_Wrap(LogSevError, "Call to CopyFile() Failed. GetLastError=%x.", GetLastError());
			goto MoveFrontPageINI_Exit;
		}
		else
		{
            iisDebugOut(_T("MoveFrontPageINI. %s renamed to %s"),szFullPathedFilename,szFrontPageINIFilename_new);
            // don't delete the old .ini file since the user could actually cancel the upgrade.
            //DeleteFile(szFullPathedFilename);
            iSomethingToDo = TRUE;
		}
    }
    else
    {
        // if we're here then that means that
        // file1 doesn't exists and file2 does exist.
        // that means that we probably already copied file1 to file2 and deleted file1.
        iSomethingToDo = TRUE;
    }

    if (iSomethingToDo)
    {
	    // Tell the upgrade module that we are going to 'handle' this newly created file.
	    // We really don't care if this get's added to the file or not, 
	    // so let's not check the return code.
	    MigInf_AddHandledFile(szFullPathedFilename_new);
	    // Important: Write memory version of migrate.inf to disk
	    if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");}
    }
    else
    {
        iisDebugOut(_T("MoveFrontPageINI. %s not exist. no action."),szFullPathedFilename);
    }

MoveFrontPageINI_Exit:
    return;
}




HRESULT GetLNKProgramRunInfo(LPCTSTR lpszLink, LPTSTR lpszProgram)
{
    HRESULT hres;
    int iDoUninit = FALSE;
    IShellLink* pShellLink = NULL;
    WIN32_FIND_DATA wfd;

    if (SUCCEEDED(CoInitialize(NULL)))
        {iDoUninit = TRUE;}

    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile = NULL;
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

          // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          MultiByteToWideChar( CP_ACP, 0, lpszLink, -1, wsz, _MAX_PATH);
#endif
          hres = pPersistFile->Load(wsz, STGM_READ);
          if (SUCCEEDED(hres))
          {
              hres = pShellLink->Resolve(NULL, SLR_ANY_MATCH | SLR_NO_UI);
              if (SUCCEEDED(hres))
              {
                   pShellLink->GetPath(lpszProgram, _MAX_PATH, (WIN32_FIND_DATA *)&wfd, SLGP_SHORTPATH);
              }
          }
          if (pPersistFile)
            {pPersistFile->Release();pPersistFile = NULL;}
       }
       if (pShellLink)
        {pShellLink->Release();pShellLink = NULL;}
    }

    if (TRUE == iDoUninit)
        {CoUninitialize();}
    return hres;
}


int LNKSearchAndReturn(LPTSTR szDirToLookThru, LPTSTR szExeNameWithoutPath, LPTSTR szFileNameReturned)
{
    int iReturn = FALSE;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFilePath[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];
    
    _tcscpy(szFileNameReturned, _T(""));
    _tcscpy(szFilePath, szDirToLookThru);
    AddPath(szFilePath, _T("*.lnk"));

    hFile = FindFirstFile(szFilePath, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // check if this file is a .lnk file
                        // if it is then let's open it and 
                        // see if it points to our .exe we're looking for...
                        
                        // get only the filename's extention
                        _tsplitpath( FindFileData.cFileName, NULL, NULL, NULL, szFilename_ext_only);

                        // check for .lnk
                        if (0 == _tcsicmp(szFilename_ext_only, _T(".lnk")))
                        {
                            TCHAR szFilename_only[_MAX_FNAME];
                            TCHAR szFullPathAndFilename[_MAX_PATH];
                            TCHAR szTemporaryString[_MAX_PATH];

                            // this is a .lnk,
                            // open it and check the .exe..
                            _tcscpy(szFullPathAndFilename,szDirToLookThru);
                            AddPath(szFullPathAndFilename,FindFileData.cFileName);
                            _tcscpy(szTemporaryString,_T(""));

                            if (SUCCEEDED(GetLNKProgramRunInfo(szFullPathAndFilename, szTemporaryString)))
                            {
                                _tsplitpath( szTemporaryString, NULL, NULL, szFilename_only, szFilename_ext_only);
                                _tcscpy(szTemporaryString, szFilename_only);
                                _tcscat(szTemporaryString, szFilename_ext_only);

                                // check if it matches our .exe name.
                                if (0 == _tcsicmp(szTemporaryString,szExeNameWithoutPath))
                                {
                                    _tcscpy(szFileNameReturned,FindFileData.cFileName);
                                    iReturn = TRUE;
                                    FindClose(hFile);
                                    break;
                                }
                            }
                        }
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return iReturn;
}

int MyGetSendToPath(LPTSTR szPath)
{
    LPITEMIDLIST   pidlSendTo;
    HRESULT hRes = NOERROR;
    int iTemp;
    int iReturn = FALSE;

    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_SENDTO, &pidlSendTo);
    if (hRes != NOERROR)
        {
        iReturn = FALSE;
        }

    iTemp = SHGetPathFromIDList(pidlSendTo, szPath);
    if (iTemp != TRUE)
        {
        iReturn = FALSE;
        goto MyGetSendToPath_Exit;
        }

    iReturn = TRUE;

MyGetSendToPath_Exit:
    return iReturn;
}


int MyGetDesktopPath(LPTSTR szPath)
{
    LPITEMIDLIST   pidlSendTo;
    HRESULT hRes = NOERROR;
    int iTemp;
    int iReturn = FALSE;

    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &pidlSendTo);
    if (hRes != NOERROR)
        {
        iReturn = FALSE;
        }

    iTemp = SHGetPathFromIDList(pidlSendTo, szPath);
    if (iTemp != TRUE)
        {
        iReturn = FALSE;
        goto MyGetDesktopPath_Exit;
        }

    iReturn = TRUE;

MyGetDesktopPath_Exit:
    return iReturn;
}

void MyDeleteSendToItem(LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];
    TCHAR szPath2[_MAX_PATH];

    MyGetSendToPath(szPath);
    _tcscpy(szPath2, szAppName);
    //_tcscat(szPath2, _T(".lnk")); // already in the resource, so let's not tack it on again.

    MyDeleteLinkWildcard(szPath, szPath2);
}

BOOL IsFileNameInDelimitedList(LPTSTR szCommaDelimList,LPTSTR szExeNameWithoutPath)
{
    BOOL bReturn = FALSE;
    char *token = NULL;
    TCHAR szCopyOfDataBecauseStrTokIsLame[_MAX_PATH];
    _tcscpy(szCopyOfDataBecauseStrTokIsLame,szCommaDelimList);

    // breakup the szCommaDelimList into strings and see if it contains the szExeNameWithoutPath string
    token = strtok(szCopyOfDataBecauseStrTokIsLame, g_LoadString_token_delimiters);
    while(token != NULL)
	{
        // check if it matches our .exe name.
        if (0 == _tcsicmp(token,szExeNameWithoutPath))
        {
            return TRUE;
        }
	    // Get next token
	    token = strtok(NULL, g_LoadString_token_delimiters);
    }

    return FALSE;
}


int LNKSearchAndDestroyRecursive(LPTSTR szDirToLookThru, LPTSTR szSemiColonDelmitedListOfExeNames, BOOL bDeleteItsDirToo, LPCSTR AnswerFile)
{
    int iReturn = FALSE;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFilePath[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    DWORD retCode = GetFileAttributes(szDirToLookThru);

    if (retCode == 0xFFFFFFFF || !(retCode & FILE_ATTRIBUTE_DIRECTORY))
    {
            return FALSE;
    }
   
    _tcscpy(szFilePath, szDirToLookThru);
    AddPath(szFilePath, _T("*.*"));

    hFile = FindFirstFile(szFilePath, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        TCHAR szFullNewDirToLookInto[_MAX_EXT];
                        _tcscpy(szFullNewDirToLookInto, szDirToLookThru);
                        AddPath(szFullNewDirToLookInto,FindFileData.cFileName);

                        // this is a directory, so let's go into this
                        // directory recursively
                        LNKSearchAndDestroyRecursive(szFullNewDirToLookInto,szSemiColonDelmitedListOfExeNames,bDeleteItsDirToo,AnswerFile);
                    }
                    else
                    {
                        // check if this file is a .lnk file
                        // if it is then let's open it and 
                        // see if it points to our .exe we're looking for...
                        
                        // get only the filename's extention
                        _tsplitpath( FindFileData.cFileName, NULL, NULL, NULL, szFilename_ext_only);

                        // check for .lnk
                        if (0 == _tcsicmp(szFilename_ext_only, _T(".lnk")))
                        {
                            TCHAR szFilename_only[_MAX_FNAME];
                            TCHAR szFullPathAndFilename[_MAX_PATH];
                            TCHAR szTemporaryString[_MAX_PATH];

                            // this is a .lnk,
                            // open it and check the .exe..
                            _tcscpy(szFullPathAndFilename,szDirToLookThru);
                            AddPath(szFullPathAndFilename,FindFileData.cFileName);
                            _tcscpy(szTemporaryString,_T(""));

                            if (SUCCEEDED(GetLNKProgramRunInfo(szFullPathAndFilename, szTemporaryString)))
                            {
                                _tsplitpath( szTemporaryString, NULL, NULL, szFilename_only, szFilename_ext_only);
                                _tcscpy(szTemporaryString, szFilename_only);
                                _tcscat(szTemporaryString, szFilename_ext_only);

                                //_tprintf(TEXT("open:%s,%s\n"),szFullPathAndFilename,szTemporaryString);

                                // see if it is on our list of comma delimited names...
                                if (TRUE == IsFileNameInDelimitedList(szSemiColonDelmitedListOfExeNames,szTemporaryString))
                                {
                                    // DELETE the file that references this .exe
                                    MigInf_AddMovedFile(szFullPathAndFilename, "");
                                    AnswerFile_AppendDeletion(szFullPathAndFilename,AnswerFile);

                                    if (bDeleteItsDirToo)
                                    {
                                        // Get it's dirname and delete that too...
                                        MigInf_AddMovedDirectory(szDirToLookThru, "");
                                        AnswerFile_AppendDeletion(szDirToLookThru,AnswerFile);
                                    }

                                    iReturn = TRUE;
                                }
                             }
                        }
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return iReturn;
}

// We need to tell migration setup that we are going to handle certain files...
// particularly the c:\windows\SendTo\Personal Web Server.lnk file
// since it doesn't seem to be accessible during win2000/20001 guimode setup
void HandleSendToItems(LPCSTR AnswerFile)
{
    char szPath[_MAX_PATH];
    char szSemiColonDelimitedList[255];

    // Now, Get the ";" delimited list of things to act upon
    strcpy(szSemiColonDelimitedList,"");
    if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_DEL_LNK_TO_THESE_EXE_FILENAMES, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
	{
	    iisDebugOut(_T("LoopThruStartMenuDeletions.Err LoadString IDS_DEL_LNK_TO_THESE_EXE_FILENAMES\n"));
        return;
    }

    if (TRUE == MyGetSendToPath(szPath))
    {
        LNKSearchAndDestroyRecursive(szPath,szSemiColonDelimitedList,FALSE,AnswerFile);
    }
    
    return;
}

void HandleDesktopItems(LPCSTR AnswerFile)
{
    char szPath[_MAX_PATH];
    char szSemiColonDelimitedList[255];

    // Now, Get the ";" delimited list of things to act upon
    strcpy(szSemiColonDelimitedList,"");
    if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_DEL_LNK_TO_THESE_EXE_FILENAMES, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
	{
	    iisDebugOut(_T("LoopThruStartMenuDeletions.Err LoadString IDS_DEL_LNK_TO_THESE_EXE_FILENAMES\n"));
        return;
    }

    if (TRUE == MyGetDesktopPath(szPath))
    {
        LNKSearchAndDestroyRecursive(szPath,szSemiColonDelimitedList,FALSE,AnswerFile);
    }
    
    return;
}

void HandleStartMenuItems(LPCSTR AnswerFile)
{
    TCHAR szPath[_MAX_PATH];
    char szSemiColonDelimitedList[255];

    // Now, Get the ";" delimited list of things to act upon
    strcpy(szSemiColonDelimitedList,"");
    if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_DEL_LNK_TO_THESE_EXE_FILENAMES, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
	{
	    iisDebugOut(_T("LoopThruStartMenuDeletions.Err LoadString IDS_DEL_LNK_TO_THESE_EXE_FILENAMES\n"));
        return;
    }

    MyGetGroupPath(_T(""), szPath);

    // search thru all the start menu items looking for
    // anything that links to our know programs...
    LNKSearchAndDestroyRecursive(szPath,szSemiColonDelimitedList,TRUE,AnswerFile);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\log.h ===
#ifndef _MYLOGFILE_H_
#define _MYLOGFILE_H_

class MyLogFile
{
protected:
	// for our log file
	TCHAR		m_szLogFileName[MAX_PATH];
	TCHAR		m_szLogFileName_Full[MAX_PATH];
	BOOL        m_bDisplayTimeStamp;
	BOOL        m_bDisplayPreLineInfo;

	// logfile2
	HANDLE  m_hFile;

public:
    MyLogFile();
    ~MyLogFile();

	TCHAR		m_szLogPreLineInfo[100];
	TCHAR		m_szLogPreLineInfo2[100];
	
	int  LogFileCreate(TCHAR * lpLogFileName);
	int  LogFileClose();

	void LogFileTimeStamp();
	void LogFileWrite(TCHAR * pszFormatString, ...);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\makefile.inc ===
#
# Supplemental rules for generating message file.
#

$(O)\vendinfo.h $(O)\vendinfo.rc $(O)\msg00001.bin: $(BASE_INC_PATH)\vendinfo.mc
    mc -A -v -h .\$(O) -r .\$(O) $(BASE_INC_PATH)\vendinfo.mc

$(O)\migrate.res: $(O)\vendinfo.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\log.cpp ===
#include "stdafx.h"
#include <pudebug.h>


// critical section needed to safely write to the logfile
CRITICAL_SECTION        critical_section;

//***************************************************************************
//*                                                                         
//* purpose: constructor
//*
//***************************************************************************
MyLogFile::MyLogFile(void)
{
	_tcscpy(m_szLogFileName, _T(""));
	_tcscpy(m_szLogFileName_Full, _T(""));
	_tcscpy(m_szLogPreLineInfo, _T(""));
	_tcscpy(m_szLogPreLineInfo2, _T(""));
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;

	m_hFile = NULL;

	// initialize the critical section
	INITIALIZE_CRITICAL_SECTION( &critical_section );
}

//***************************************************************************
//*                                                                         
//* purpose: destructor
//*
//***************************************************************************
MyLogFile::~MyLogFile(void)
{
	DeleteCriticalSection( &critical_section );
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileCreate(TCHAR *lpLogFileName )
{
	int iReturn = FALSE;
	TCHAR szDrive_only[_MAX_DRIVE];
	TCHAR szPath_only[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];
	TCHAR szFilename_bak[_MAX_PATH];
	LPWSTR  pwsz = NULL;

	// because of the global flags and such, we'll make this critical
	EnterCriticalSection( &critical_section );

	if (lpLogFileName == NULL)
	{
		TCHAR szModuleFileName[_MAX_PATH];

		// if a logfilename was not specified then use the module name.
		if (GetModuleFileName(NULL, szModuleFileName, _MAX_PATH))
                {
                  // get only the filename
                  _tsplitpath( szModuleFileName, NULL, NULL, szFilename_only, NULL);
                  _tcscat(szFilename_only, _T(".LOG"));
                  _tcscpy(m_szLogFileName, szFilename_only);
                }
                else
                {
                  goto LogFileCreate_Exit;
                }
	}
	else
	{
		_tcscpy(m_szLogFileName, lpLogFileName);
	}

	if (GetWindowsDirectory(m_szLogFileName_Full, sizeof(m_szLogFileName_Full)))
    {
        AddPath(m_szLogFileName_Full, m_szLogFileName);
        if (GetFileAttributes(m_szLogFileName_Full) != 0xFFFFFFFF)
        {
            // Make a backup of the current log file
			_tsplitpath( m_szLogFileName_Full, szDrive_only, szPath_only, szFilename_only, NULL);

			_tcscpy(szFilename_bak, szDrive_only);
			_tcscat(szFilename_bak, szPath_only);
			_tcscat(szFilename_bak, szFilename_only);
            _tcscat(szFilename_bak, _T(".BAK"));

            SetFileAttributes(szFilename_bak, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szFilename_bak);
            if (MoveFile(m_szLogFileName_Full, szFilename_bak) == 0)
			{
				// This failed
				//::MessageBox(NULL, _T("LogFile MoveFile Failed"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
			}
        }

#if defined(UNICODE) || defined(_UNICODE)
	pwsz = m_szLogFileName_Full;
#else
	pwsz = MakeWideStrFromAnsi( m_szLogFileName_Full);
#endif

   
		// Open existing file or create a new one.
		m_hFile = CreateFile(m_szLogFileName_Full,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
		if (m_hFile == INVALID_HANDLE_VALUE)
		{
			m_hFile = NULL;
			//::MessageBox(NULL, _T("Unable to create log file log file"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
		}
		else 
		{
			iReturn = TRUE;
		}
		//LogFileTimeStamp();
		LogFileWrite(_T("LogFile Open.\r\n"));
	}


LogFileCreate_Exit:
	// safe to leave the critical section
	LeaveCriticalSection( &critical_section );

	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileClose(void)
{

	if (m_hFile)
	{
		LogFileWrite(_T("LogFile Close.\r\n"));
		CloseHandle(m_hFile);
		return TRUE;
	}
	return FALSE;
}


//***************************************************************************
//*                                                                         
//* purpose: add stuff to logfile
//*
//***************************************************************************
void MyLogFile::LogFileTimeStamp()
{
    SYSTEMTIME  SystemTime;
    GetLocalTime(&SystemTime);
	m_bDisplayTimeStamp = FALSE;
	m_bDisplayPreLineInfo = FALSE;
    LogFileWrite(_T("[%d/%d/%d %d:%d:%d]\r\n"),SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;
}


//***************************************************************************
//*                                                                         
//* purpose: 
//* 
//***************************************************************************
void MyLogFile::LogFileWrite(TCHAR *pszFormatString, ...)
{

    if (m_hFile)
    {
		// because of the global flags and such, we'll make this critical
		EnterCriticalSection( &critical_section );

		va_list args;
		TCHAR pszFullErrMsg[1000];
		char   pszFullErrMsgA[1000];
		strcpy(pszFullErrMsgA, "");

		DWORD dwBytesWritten = 0;

        va_start(args, pszFormatString);
		_vstprintf(pszFullErrMsg, pszFormatString, args); 
		va_end(args);

        if (pszFullErrMsg)
        {
#if defined(UNICODE) || defined(_UNICODE)
	// convert to ascii then write to stream
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)pszFullErrMsg, -1, pszFullErrMsgA, 2048, NULL, NULL );
#else
	// the is already ascii so just copy the pointer
	strcpy(pszFullErrMsgA,pszFullErrMsg);
#endif

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayTimeStamp == TRUE)
			{
				// Get timestamp
				SYSTEMTIME  SystemTime;
				GetLocalTime(&SystemTime);
				char szDateandtime[50];
				sprintf(szDateandtime,"[%d/%d/%d %d:%d:%d] ",SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
				// Write time to stream
				if (m_hFile) {WriteFile(m_hFile,szDateandtime,strlen(szDateandtime),&dwBytesWritten,NULL);}
			}

			char szPrelineWriteString[100];
			char szPrelineWriteString2[100];

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayPreLineInfo == TRUE)
			{
				if (_tcscmp(m_szLogPreLineInfo,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo, -1, szPrelineWriteString, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString, m_szLogPreLineInfo);
#endif
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString,strlen(szPrelineWriteString),&dwBytesWritten,NULL);}
				}

				if (_tcscmp(m_szLogPreLineInfo2,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo2, -1, szPrelineWriteString2, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString2, m_szLogPreLineInfo2);
#endif
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString2,strlen(szPrelineWriteString2),&dwBytesWritten,NULL);}
				}
			}

			// if it does not end if '\r\n' then make one.
			int nLen = strlen(pszFullErrMsgA);

			if (pszFullErrMsgA[nLen-1] != '\n')
				{strcat(pszFullErrMsgA, "\r\n");}
			else
			{
				if (pszFullErrMsgA[nLen-2] != '\r') 
					{
					char * pPointer = NULL;
					pPointer = pszFullErrMsgA + (nLen-1);
					strcpy(pPointer, "\r\n");
					}
			}


			// Write Regular data to stream
			if (m_hFile) {WriteFile(m_hFile,pszFullErrMsgA,strlen(pszFullErrMsgA),&dwBytesWritten,NULL);}
        }

		// safe to leave the critical section
		LeaveCriticalSection( &critical_section );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\mdkey.h ===
#ifndef _MDKEY_H_
#define _MDKEY_H_

//class CMDKey : public CObject
class CMDKey
{
protected:
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    LPTSTR pszFailedAPI;

public:
    CMDKey();
    ~CMDKey();

    // allow CMDKey to be used where type METADATA_HANDLE is required
    operator METADATA_HANDLE () {return m_hKey;}
    METADATA_HANDLE GetMDKeyHandle() {return m_hKey;}
    IMSAdminBase *GetMDKeyICOM() {return m_pcCom;}

    // open an existing MD key
    HRESULT OpenNode(LPCTSTR pchSubKeyPath);
    // close node opened/created by OpenNode() or CreateNode()
    HRESULT Close();
    // Delete a node
    HRESULT DeleteNode(LPCTSTR pchSubKeyPath);

private:
    HRESULT DoCoInitEx();
    void DoCoUnInit();
    // a count of the calls to coinit
    INT m_cCoInits;
};

#endif // _MDKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\mdkey.cpp ===
// MdKey.cpp
#include "stdafx.h"

// Do stuff to define the iadm guid
#include <objbase.h>
#include <initguid.h>
#define INITGUID
#include "iadm.h"

#include "mdkey.h"

#define TIMEOUT_VALUE 5000

CMDKey::CMDKey():
    m_cCoInits(0)
{
    m_pcCom = NULL;
    m_hKey = NULL;
}

CMDKey::~CMDKey()
{
    this->Close();

    // while there are outstanding coinits, close them
    while ( m_cCoInits > 0 && !(m_cCoInits < 0) )
        DoCoUnInit();
}

HRESULT CMDKey::DoCoInitEx()
{
    //HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	HRESULT hRes = CoInitialize(NULL);

    // track our calls to coinit
    if ( SUCCEEDED(hRes) )
    {
        m_cCoInits++;
    }

    return hRes;
}

void CMDKey::DoCoUnInit()
{
    HRESULT hRes = NOERROR;

    // if there are outstanding coinits, uninit one
    if ( m_cCoInits > 0 )
    {
        CoUninitialize();
        m_cCoInits--;
    }

    // we shouldn't ever have a negative count. But just in case...
    assert( m_cCoInits >= 0 );
    if ( m_cCoInits < 0 )
    {
        // something is seriously wrong here. Prevent looping
        // by going straight to zero, and write an error to the log.
        m_cCoInits = 0;
        iisDebugOut(_T("WARNING: CoInits in mdkey have gone negative"));
    }
}

HRESULT CMDKey::OpenNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];

    pszFailedAPI = NULL;

    iisDebugOut(_T("CMDKey::OpenNode(%s).\n"), pchSubKeyPath);

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) 
    {
        *szSubKeyPath = L'\0';
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        iisDebugOut(_T("CoInitializeEx() failed, hRes=%x\n"), hRes);
    }

    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hRes)) 
    {
        //SetErrorFlag(__FILE__, __LINE__);
        //MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            //SetErrorFlag(__FILE__, __LINE__);
            //MyMessageBox(NULL, _T("CoCreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
        }
        else 
        {
            hRes = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
            if (FAILED(hRes)) 
            {
                if (hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) 
                {
                    //SetErrorFlag(__FILE__, __LINE__);
                    //MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                }
            }
            else 
            {
                b = TRUE;
            }
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    if (!b) {this->Close();}
    return hRes;
}

HRESULT CMDKey::Close()
{
    HRESULT hRes = ERROR_SUCCESS;
    if (m_pcCom) 
    {
        if (m_hKey){hRes = m_pcCom->CloseKey(m_hKey);}
        hRes = m_pcCom->Release();
    }
    DoCoUnInit();
    m_pcCom = NULL;
    m_hKey = NULL;
    return hRes;
}

HRESULT CMDKey::DeleteNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    WCHAR szSubKeyPath[_MAX_PATH];

    if ( pchSubKeyPath && (*pchSubKeyPath) ) 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH );
#endif
        hRes = m_pcCom->DeleteKey(m_hKey, szSubKeyPath);
    }

    return hRes;
}


#if !defined(UNICODE) && !defined(_UNICODE)
void MyMultiByteToWideChar( char *sData, WCHAR *wData, int cbBufSize, BOOL fMultiSZ)
{
    MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
    while (fMultiSZ) 
    {
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        while (*wData++);
        if (*sData)
        {
            MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
        }
        else 
        {
            *wData = L'\0';
            break;
        }
    }
    return;
}
void MyWideCharToMultiByte( WCHAR *wData, char *sData, int cbBufSize, BOOL fMultiSZ)
{
    WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
    while (fMultiSZ) 
    {
        while (*wData++);
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        if (*wData)
        {
            WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
        }
        else 
        {
            *sData = '\0';
            break;
        }
    }
    return;
}
#endif      // not unicode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\helper.h ===
#ifndef _HELPER_H_
#define _HELPER_H_


/*
#if DBG == 1
    #define iisDebugOut( x ) iisInlineDebugOut x
#else  // DBG == 0
    #define iisDebugOut( x )
#endif // DBG
	*/

//#define iisDebugOut(x) MyDebugOut x
//void MyDebugOut( TCHAR *pszfmt, ...);

void iisDebugOut( TCHAR *pszfmt, ...);

LPWSTR	MakeWideStrFromAnsi(LPSTR psz);
void	MakePath(LPTSTR lpPath);
void	AddPath(LPTSTR szPath, LPCTSTR szName );

int CheckIfFileExists(LPCTSTR szFile);

int CheckIfPWS95Exists(void);
int ReturnTrueIfPWS40_Installed(void);
int ReturnTrueIfPWS10_Installed(void);
int ReturnTrueIfVermeerPWS10_Installed(void);

int MySettingsFile_Write(void);
int MySettingsFile_Write_PWS10(void);
int MySettingsFile_Write_PWS40(void);
int MySettingsFile_Install(void);
int ReturnImportantDirs(void);

void SetupLogError_Wrap(IN LogSeverity TheSeverityErr, IN TCHAR * MessageString, ...);
int MyUpgradeTasks(LPCSTR);
int AddRegToInfIfExist_Dword(HKEY hRootKeyType,CHAR szRootKey[],CHAR szRootName[],HANDLE fAppendToFile);
void DeleteMetabaseSchemaNode(void);

BOOL MyIsGroupEmpty(LPCTSTR szGroupName);
void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath);
void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName);
BOOL MyDeleteLink(LPTSTR lpszShortcut);
BOOL MyDeleteGroup(LPCTSTR szGroupName);
BOOL W95ShutdownW3SVC(void);
BOOL W95ShutdownIISADMIN(void);
int  Call_IIS_DLL_INF_Section(CHAR *szSectionName);
int  GetInetSrvDir(CHAR *szOutputThisFullPath);

int  CheckFrontPageINI(void);
void MoveFrontPageINI(void);

void HandleSpecialRegKey(void);
void MyDeleteSendToItem(LPCTSTR szAppName);
int  MyGetSendToPath(LPTSTR szPath);
int  MyGetDesktopPath(LPTSTR szPath);
void HandleStartMenuItems(LPCSTR AnswerFile);
void HandleSendToItems(LPCSTR AnswerFile);
void HandleDesktopItems(LPCSTR AnswerFile);
int  AnswerFile_ReadSectionAndDoDelete(IN HINF AnswerFileHandle);

#endif // _HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\miginf.h ===
#ifndef MIGINF_H
#define MIGINF_H


#define SECTION_MIGRATIONPATHS  "Migration Paths"
#define SECTION_EXCLUDEDPATHS   "Excluded Paths"
#define SECTION_HANDLED         "Handled"
#define SECTION_MOVED           "Moved"
#define SECTION_INCOMPATIBLE    "Incompatible Messages"


typedef enum {

    MIG_FIRSTTYPE,
    MIG_FILE,
    MIG_PATH,
    MIG_REGKEY,
    MIG_MESSAGE,
    MIG_LASTTYPE

} MIGTYPE, *PMIGTYPE;

typedef struct tagMIGINFSECTIONENUM {

    PCSTR        Key;
    PCSTR        Value;
    PVOID        EnumKey;            // Internal.

} MIGINFSECTIONENUM, * PMIGINFSECTIONENUM;


BOOL IsUpgradeTargetSupportIIS(LPCSTR szMyAnswerFile);

BOOL WINAPI MigInf_Initialize (VOID);
VOID WINAPI MigInf_CleanUp (VOID);
BOOL WINAPI MigInf_PathIsExcluded (IN PCSTR Path);
BOOL WINAPI MigInf_FirstInSection(IN PCSTR SectionName, OUT PMIGINFSECTIONENUM Enum);
BOOL WINAPI MigInf_NextInSection(IN OUT PMIGINFSECTIONENUM Enum);
BOOL WINAPI MigInf_AddObject (IN MIGTYPE ObjectType,IN PCSTR SectionString,IN PCSTR ParamOne,IN PCSTR ParamTwo);
BOOL WINAPI MigInf_WriteInfToDisk (VOID);
PCSTR WINAPI MigInf_GetNewSectionName (VOID);



//
// Macros for common miginf actions.
//

//
// Adding Objects.
//
#define MigInf_AddHandledFile(file)                      MigInf_AddObject(MIG_FILE,SECTION_HANDLED,(file),NULL)
#define MigInf_AddHandledDirectory(directory)            MigInf_AddObject(MIG_PATH,SECTION_HANDLED,(directory),NULL)
#define MigInf_AddHandledRegistry(key,value)             MigInf_AddObject(MIG_REGKEY,SECTION_HANDLED,(key),(value))

#define MigInf_AddMovedFile(from,to)                     MigInf_AddObject(MIG_FILE,SECTION_MOVED,(from),(to))
#define MigInf_AddMovedDirectory(from,to)                MigInf_AddObject(MIG_PATH,SECTION_MOVED,(from),(to))

#define MigInf_AddMessage(msgSection,msg)                MigInf_AddObject(MIG_MESSAGE,SECTION_INCOMPATIBLE,(msgSection),(msg))

#define MigInf_AddMessageFile(msgSection,file)           MigInf_AddObject(MIG_FILE,(msgSection),(file),NULL)
#define MigInf_AddMessageDirectory(msgSection,directory) MigInf_AddObject(MIG_PATH,(msgSection,(directory),NULL)
#define MigInf_AddMessageRegistry(msgSection,key,value)  MigInf_AddObject(MIG_REGKEY,(msgSection),(key),(value))

//
// Enumerating Sections
//
#define MigInf_GetFirstMigrationPath(Enum)               MigInf_FirstInSection(SECTION_MIGRATIONPATHS,(Enum))
#define MigInf_GetFirstExcludedPath(Enum)                MigInf_FirstInSection(SECTION_EXCLUDEDPATHS,(Enum))



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\miginf.cpp ===
#include "stdafx.h"

#define MIGRATEINF              ".\\migrate.inf"
#define INITIALBUFFERSIZE       1024
#define MIGINF_NOCREATE         FALSE
#define MIGINF_CREATE           TRUE


typedef struct tagMIGOBJECT MIGOBJECT, *PMIGOBJECT;
struct tagMIGOBJECT {

    PSTR        Key;
    PSTR        Value;
    
    PMIGOBJECT  Next;
};

typedef struct tagMIGSECTION MIGSECTION, * PMIGSECTION;
struct tagMIGSECTION {

    PSTR        Name;
    PMIGOBJECT  Items;

    PMIGSECTION Next;
};

PMIGSECTION g_MigrationInf;
POOLHANDLE  g_Pool = NULL;


static
PCSTR
pGetTypeAsString (
    IN MIGTYPE Type
    )
{
    //
    // Note: Strings must be in the same order as the 
    // corresponding types in the MIGTYPE enumeration above.
    //
    static PCHAR typeStrings[] = {
            "FIRST - Invalid",
            "File",
            "Path",
            "Registry",
            "Message - Invalid",
            "LAST - Invalid"
        };

    assert(Type > MIG_FIRSTTYPE && Type < MIG_LASTTYPE);

    return typeStrings[Type];
}

static
PMIGSECTION 
pFindSection (
    IN PCSTR SectionString,
    IN BOOL  CreateIfNotExist
    )
{
    PMIGSECTION rSection;

    //
    // We assume that SectionString is not null.
    //
    assert(SectionString);

    rSection = g_MigrationInf;

    while (rSection && (_mbsicmp((const unsigned char *) rSection -> Name,(const unsigned char *) SectionString) != 0)) {

        //
        // Continue looking.
        //
        rSection = rSection -> Next;
    }
        
    if (!rSection && CreateIfNotExist) {
        //
        // No section was found matching this name. Make a new section and add it 
        // to the list.
        //
        rSection = (PMIGSECTION) PoolMemGetMemory(g_Pool,sizeof(MIGSECTION));
        if (rSection) {

            ZeroMemory(rSection,sizeof(MIGSECTION));
            rSection -> Name  = PoolMemDuplicateStringA(g_Pool,SectionString);
            rSection -> Next  = g_MigrationInf;
            g_MigrationInf    = rSection;

            if (!rSection -> Name) {
                //
                // Something went wrong when we tried to duplicate the SectionString.
                // NULL out the rSection so that the caller doesn't get back a 
                // malformed section object.
                //
                rSection = NULL;
            }
        }
    }

    return rSection;
}

static
BOOL
pPathIsInPath(
    IN PCSTR    SubPath,
    IN PCSTR    ParentPath
    )
{
    DWORD parentLength;
    BOOL  rInPath;

    //
    // This function assumes both parameters are non-NULL.
    //
    assert(SubPath);
    assert(ParentPath);
    
    parentLength = _mbslen((const unsigned char *) ParentPath);

    //
    // A path is considered "in" another path if the path is in the ParentPath
    // or a subdirectory of it.
    //
    rInPath = !_mbsnicmp((const unsigned char *) SubPath,(const unsigned char *) ParentPath,parentLength);

    if (rInPath) {
        rInPath = SubPath[parentLength] == 0 || SubPath[parentLength] == '\\';
    }

    return rInPath;

}

static
DWORD
pGetMbsSize (
    IN  LPCSTR  String
    )
{
    DWORD rLength;
    
    //rLength = (DWORD) _mbschr((const unsigned char *) String,0) - (DWORD) String + 1;
    rLength = strlen(String + 1);

    return rLength;

}


static
LPSTR 
pEscapeString (
    IN  MIGTYPE Type,
    OUT LPSTR   EscapedString, 
    IN  LPCSTR  String
    )

{
    LPSTR   stringStart;
    static  CHAR exclusions[] = "[]~,;%\"";
    INT     currentChar;

    //
    // We assume that all parameters are valid.
    //
    assert(EscapedString && String);

    stringStart = EscapedString;

    while (*String)  {
        currentChar = _mbsnextc ((const unsigned char *) String);
        
        if (Type == MIG_REGKEY) {
            
            //
            // Registry keys require more complex escaping than do normal INF strings.
            //
            if (!_ismbcprint (currentChar) || _mbschr ((const unsigned char *) exclusions, currentChar)) {
                
                //
                // Escape unprintable or excluded character
                //
                wsprintfA (EscapedString, "~%X~", currentChar);
                EscapedString = (LPSTR) _mbschr ((const unsigned char *) EscapedString, 0);
                String = (LPCSTR) _mbsinc((const unsigned char *) String);
            }
            else {
                //
                // Copy multibyte character
                //
                if (isleadbyte (*String)) {
                    *EscapedString = *String;
                    EscapedString++;
                    String++;
                }
                
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
        }
        else {

            //
            // Escaping is pretty simple for non-registry keys. All we do is double up
            // quotes and percents.
            //
            if (*String == '\"' || *String == '%') {

                *EscapedString = *String;
                EscapedString++;
            }
            
            //
            // Copy multibyte character
            //
            if (isleadbyte (*String)) {
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
            
            *EscapedString = *String;
            EscapedString++;
            String++;
        }
    }

    //
    // Ensure that returned string is NULL terminated.
    //
    *EscapedString = 0;

    return stringStart;
}


static
PSTR
pGetValueString (
    IN MIGTYPE    ObjectType,
    IN LPCSTR     StringOne,
    IN LPCSTR     StringTwo
    )
{
    static PSTR     buffer;
    static DWORD    bufferSize;
    DWORD           maxLength;
    PSTR            bufferEnd;
    
    //
    // This function assumes that StringOne exists.
    //
    assert(StringOne);

    if (ObjectType == MIG_REGKEY) {
        //
        // Size: size of both strings, plus the size of the quotes, plus the size of the brackets 
        // for the value, * 6. This is the maximum size one of these could grow to, if every 
        // character had to be escaped out.
        //
        maxLength = (pGetMbsSize(StringOne) + (StringTwo ? pGetMbsSize(StringTwo) + 2 : 0)) * 6 + 2;
    }
    else {
        //
        // Size: size of the string * 2 (The max size if every char was a '%' or '"' plus the quotes.
        //
        maxLength = pGetMbsSize(StringOne) * 2 + 2;
    }

    if (maxLength > bufferSize) {

        //
        // Initialize our buffer, or create a larger one.
        //
        bufferSize = (maxLength > INITIALBUFFERSIZE) ? maxLength : INITIALBUFFERSIZE;
        buffer = PoolMemCreateStringA(g_Pool,bufferSize);
    }

    if (buffer != NULL) {
        
        //
        // Insert initial quote.
        //
        *buffer = '"';
 
        //
        // Massage the string to ensure it is a valid INF file string.
        //
        pEscapeString(ObjectType,(char *) _mbsinc((const unsigned char *) buffer),StringOne);

        //
        // If this is a REGISTRY entry, then we also need to add the value part of the string, 
        // if one was specified (In StringTwo)
        //

        if (ObjectType == MIG_REGKEY && StringTwo) {

            //
            // Add the opening bracket.
            //
            bufferEnd = (PSTR) _mbschr((const unsigned char *) buffer,0);
            if (bufferEnd)
            {
                *bufferEnd = '[';
            
                //
                // Add the value string in, again making sure the string is valid for an INF file.
                //
                pEscapeString(ObjectType,(char *) _mbsinc((const unsigned char *) bufferEnd),StringTwo);

                //
                // Now, add the closing braket.
                //
                bufferEnd = (PSTR) _mbschr((const unsigned char *) buffer,0);
                if (bufferEnd)
                {
                    *bufferEnd = ']';
                    //
                    // Terminate the string.
                    //
                    bufferEnd = (PSTR) _mbsinc((const unsigned char *) bufferEnd);
                    if (bufferEnd) {*bufferEnd = 0;}
                 }
            }
        }

        //
        // Add the final quote.
        //
        bufferEnd = (PSTR) _mbschr((const unsigned char *) buffer,0);
        if (bufferEnd) {*bufferEnd = '"';}
        bufferEnd = (PSTR) _mbsinc((const unsigned char *) bufferEnd);
        if (bufferEnd) {*bufferEnd = 0;}
    }
    
    return buffer;
}

static
BOOL
pCreateMigObject (
    IN MIGTYPE          ObjectType,
    IN PCSTR            ParamOne,
    IN PCSTR            ParamTwo,
    IN PMIGSECTION      Section
    )
{
    BOOL            rSuccess = FALSE;
    PMIGOBJECT      newObject = NULL;
    PSTR pTemp = NULL;

    //
    // pCreateMigObject uses a set of hueristics to correctly assemble an object. 
    // These hueristics are based on the ObjectType and the contents of ParamTwo.
    // 
    // ObjectType       ParamTwo      Key                   Value
    // -------------------------------------------------------------------------
    // MIG_REGKEY       <any>         ParamOne[ParamTwo]    Registry
    // <other>          NULL          ParamOne              <ObjectType As String>
    // <other>          non-NULL      ParamOne              ParamTwo
    //
    //

    if (Section) {

        //
        // First, create an object...
        //
        newObject = (PMIGOBJECT) PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));

        if (newObject) {

            if (ObjectType == MIG_REGKEY) {

                pTemp = pGetValueString(ObjectType,ParamOne,ParamTwo);
                if (pTemp)
                   {newObject -> Key = PoolMemDuplicateStringA(g_Pool,pTemp);}
                else 
                    {
                    // out of memory
                    goto pCreateMigObject_Exit;
                    }

                newObject -> Value = PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
            }
            else {
                
                pTemp = pGetValueString(ObjectType,ParamOne,NULL);
                if (pTemp)
                   {newObject -> Key = PoolMemDuplicateStringA(g_Pool,pTemp);}
                else
                    {
                    // out of memory
                    goto pCreateMigObject_Exit;
                    }

                if (ParamTwo) {
                    pTemp = pGetValueString(ObjectType,ParamTwo,NULL);
                    if (pTemp) 
                       {newObject -> Value = PoolMemDuplicateStringA(g_Pool,pTemp);}
                    else
                        {
                        // out of memory
                        goto pCreateMigObject_Exit;
                        }

                }
                else {
                     newObject -> Value = PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
                }
            }
        }
    }


    if (newObject)
    {
        if (newObject -> Key && newObject -> Value) {
            //
            // The object has been successfully created. Link it into the section.
            //
            newObject -> Next = Section -> Items;
            Section -> Items = newObject;
            rSuccess = TRUE;
        }
        else {
            rSuccess = FALSE;
        }
    }
    else {
        rSuccess = FALSE;
    }

pCreateMigObject_Exit:
    return rSuccess;
}


static
BOOL
pWriteInfSectionToDisk (
    IN PMIGSECTION Section
    )
{
    PMIGOBJECT curObject;
    BOOL       rSuccess = TRUE;

    if (Section) {

        curObject = Section -> Items;

        while (curObject && rSuccess) {

            if (Section -> Name && curObject -> Key && curObject -> Value) {
            
                rSuccess = WritePrivateProfileString(
                    Section   -> Name,
                    curObject -> Key, 
                    curObject -> Value,
                    MIGRATEINF
                    );
            }

            curObject = curObject -> Next;
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


static
BOOL
pBuildListFromSection (
    IN PCSTR    SectionString
    )
{
    HINF            infHandle;
    PMIGSECTION     section;
    PMIGOBJECT      currentObject;
    INFCONTEXT      ic;
    DWORD           size;
    BOOL            rSuccess = TRUE;

    //
    // This function assumes that Section is non-NULL.
    //
    assert(SectionString);

    currentObject = NULL;
    
    //
    // First find the section specified.
    //
    section = pFindSection(SectionString,MIGINF_CREATE);

    if (section) {
        
        infHandle = SetupOpenInfFileA(MIGRATEINF,NULL,INF_STYLE_WIN4,NULL);
        
        if (infHandle != INVALID_HANDLE_VALUE) {
            
            if (SetupFindFirstLine(infHandle,SectionString,NULL,&ic)) {
                
                do {

                    //
                    // Create the object.
                    //
                    currentObject = (PMIGOBJECT) PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));
                    
                    if (!currentObject) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the size of the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,NULL,0,&size)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Create a string large enough.
                    //
                    currentObject -> Key = PoolMemCreateStringA(g_Pool,size);
                    
                    if (!currentObject -> Key) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,currentObject -> Key,size,NULL)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Successfully retrieved the line.
                    //
                    currentObject -> Value  = (PSTR) pGetTypeAsString(MIG_FILE);
                    currentObject -> Next   = section -> Items;
                    section -> Items        = currentObject;
                    
                } while(SetupFindNextLine(&ic,&ic));
                
            }
            
            SetupCloseInfFile(infHandle);
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


BOOL
WINAPI
MigInf_Initialize(
    VOID
    )
{

    //
    // First, initialize our pool and Zero out the structure.
    //
    g_Pool = PoolMemInitPool();


    if (g_Pool) {
        
        //
        // Now, read in the migration paths and excluded paths sections.
        //
        if (!pBuildListFromSection(SECTION_MIGRATIONPATHS) ||
            !pBuildListFromSection(SECTION_EXCLUDEDPATHS)) {
            //
            // Something went wrong (i.e. out of memory. Destroy and NULL our pool.
            //
            PoolMemDestroyPool(g_Pool);
            g_Pool = NULL;
        }
    }

    //
    // If our memory pool initialized successfully, return TRUE.
    //
    return (g_Pool != NULL);

}


VOID
WINAPI
MigInf_CleanUp (
    VOID
    )
{
    //
    // Only thing we need to do is clean out pool mem. We'll NULL out the list header to make
    // sure it isn't usable.
    //
    if (g_Pool) {
        PoolMemDestroyPool(g_Pool);
        g_Pool = NULL;
    }
    
    g_MigrationInf = NULL;

}


BOOL
WINAPI
MigInf_AddObject (
    IN MIGTYPE  ObjectType,
    IN PCSTR    SectionString,
    IN PCSTR    ParamOne,
    IN PCSTR    ParamTwo
    )
{

    return pCreateMigObject(
        ObjectType,
        ParamOne,
        ParamTwo,
        pFindSection(SectionString,MIGINF_CREATE)
        );
}

BOOL 
WINAPI 
MigInf_FirstInSection(
    IN PCSTR SectionName, 
    OUT PMIGINFSECTIONENUM Enum
    )
{
    PMIGSECTION section;

    //
    // We assume that Enum is valid.
    //
    assert(Enum);

    section = pFindSection(SectionName,MIGINF_NOCREATE);

    if (section) {
        Enum -> EnumKey = (PVOID) section -> Items;
    }

    return MigInf_NextInSection(Enum);
}

BOOL 
WINAPI 
MigInf_NextInSection(
    IN OUT PMIGINFSECTIONENUM Enum
    )
{


    BOOL            rSuccess = FALSE;

    //
    // We assume that the Enum is valid.
    //
    assert(Enum);

    if (Enum -> EnumKey) {

        Enum -> Key     = ((PMIGOBJECT) (Enum -> EnumKey)) -> Key;
        Enum -> Value   = ((PMIGOBJECT) (Enum -> EnumKey)) -> Value;
        Enum -> EnumKey = ((PVOID) ((PMIGOBJECT) (Enum -> EnumKey)) -> Next);
        rSuccess = TRUE;
    }

    return rSuccess;
}


BOOL
WINAPI
MigInf_WriteInfToDisk (
    VOID
    )
{

    BOOL        rSuccess = TRUE;
    PMIGSECTION curSection;
    
    //
    // Simply loop through all of the sections, writing each of them to disk.
    // As long as WriteSectionToDisk works, we work.
    //
    curSection = g_MigrationInf;

    while (curSection && rSuccess) {

        //
        // We skip the [Excluded Paths] and [Migration Paths] sections.
        //
        if (_mbsicmp((const unsigned char *) curSection -> Name,(const unsigned char *) SECTION_EXCLUDEDPATHS) &&
            _mbsicmp((const unsigned char *) curSection -> Name,(const unsigned char *) SECTION_MIGRATIONPATHS)) {
            
            rSuccess = pWriteInfSectionToDisk(curSection);
        } 

        curSection = curSection -> Next;
        
    }

    return rSuccess;
}

BOOL
WINAPI
MigInf_PathIsExcluded (
    IN PCSTR    Path
    )
{
    PMIGOBJECT  curExcluded;
    PMIGSECTION section;
    BOOL        rIsExcluded = FALSE;

    //
    // We assume Path is valid.
    //
    assert(Path);
    
    section = pFindSection(SECTION_EXCLUDEDPATHS,MIGINF_NOCREATE);

    if (section) {

        curExcluded = section -> Items;
        
        while (curExcluded && !rIsExcluded) {
            
            rIsExcluded = pPathIsInPath(Path,curExcluded -> Key);
            curExcluded = curExcluded -> Next;
        }
    }
    
    return rIsExcluded;
}



PCSTR
WINAPI
MigInf_GetNewSectionName (
    VOID
    )
{

    static CHAR     sectionName[20];
    static DWORD    seedNum=0;


    sprintf(sectionName,"msg%0.7u",seedNum++);

    return sectionName;
}


BOOL IsUpgradeTargetSupportIIS(LPCSTR szMyAnswerFile)
{
    BOOL bReturn = TRUE;
    char szPlatformString[_MAX_PATH];

	if (GetPrivateProfileString("Version", "SetupSKU", _T(""), szPlatformString, _MAX_PATH, szMyAnswerFile))
    {
	    if (*szPlatformString)
        {
            iisDebugOut(_T("[%s] [Version] SetupSKU=%s"), szMyAnswerFile,szPlatformString);

            if (0 == _mbsicmp((const unsigned char *) szPlatformString,(const unsigned char *) "Personal"))
            {
                bReturn = FALSE;
            }
	    }
    }

    if (TRUE == bReturn)
    {
        // check a different key
	    if (GetPrivateProfileString("Version", "SetupPlatform", _T(""), szPlatformString, _MAX_PATH, szMyAnswerFile))
        {
	        if (*szPlatformString)
            {
                iisDebugOut(_T("[%s] [Version] SetupPlatform=%s"), szMyAnswerFile,szPlatformString);

                if (0 == _mbsicmp((const unsigned char *) szPlatformString,(const unsigned char *) "Personal"))
                {
                    bReturn = FALSE;
                }
	        }
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\poolmem.cpp ===
#include "stdafx.h"
 
// Tree Memory Allocation structure.


typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK;

struct _POOLMEMORYBLOCK {
    DWORD_PTR             Index;
    DWORD_PTR             Size;
    PPOOLMEMORYBLOCK      NextBlock;
    PPOOLMEMORYBLOCK      PrevBlock;
    PBYTE                 RawMemory;  
};

typedef struct _POOLHEADER {
    PPOOLMEMORYBLOCK PoolHead;
    HANDLE           Heap;
} POOLHEADER, *PPOOLHEADER;


BOOL
PoolMemAddMemory (
    IN  POOLHANDLE  Handle,
    IN  DWORD_PTR     Size
    )
{
    PBYTE               allocedMemory;
    PPOOLMEMORYBLOCK    newBlock;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;
    DWORD_PTR           sizeNeeded;

    assert(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(POOLMEMORYBLOCK) > POOLMEMORYBLOCKSIZE) {
        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK);
    }
    else {
        sizeNeeded = POOLMEMORYBLOCKSIZE;
    }

    allocedMemory = (unsigned char *) HeapAlloc(poolHeader -> Heap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory;
        newBlock -> Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK);
        newBlock -> RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK);
        newBlock -> Index       = 0;
    
        //
        // Link the block into the list.
        //
        if (poolHeader -> PoolHead) {
            poolHeader -> PoolHead -> PrevBlock = newBlock;
        }
        newBlock   -> NextBlock   = poolHeader -> PoolHead;
        newBlock   -> PrevBlock   = NULL;
        poolHeader -> PoolHead    = newBlock;


    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;
}


POOLHANDLE
WINAPI
PoolMemInitPool (
    )
{
    BOOL        ableToAddMemory;
    PPOOLHEADER header = NULL;
    HANDLE      procHeap;


    procHeap = GetProcessHeap();
    //
    // Allocate the header of this pool.
    //
    header = (PPOOLHEADER) HeapAlloc(procHeap,0,sizeof(POOLHEADER));

    if (header) {

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header -> PoolHead = NULL;
        header -> Heap = procHeap;

        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = PoolMemAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            HeapFree(header -> Heap,0,header);
            header = NULL;
        }

    }
    return (POOLHANDLE) header;
}


VOID
WINAPI
PoolMemDestroyPool (
    POOLHANDLE Handle
    )
{
    PPOOLMEMORYBLOCK nextBlock;
    PPOOLMEMORYBLOCK blockToFree; 
    PPOOLHEADER      poolHeader;

    assert(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader ->  PoolHead;

    while (blockToFree != NULL) {
    
        nextBlock = blockToFree->NextBlock;
        HeapFree(poolHeader -> Heap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    HeapFree(poolHeader -> Heap,0,poolHeader);

}

PVOID
WINAPI
PoolMemGetAlignedMemory (
    IN POOLHANDLE Handle,
    IN DWORD_PTR      Size,
    IN DWORD_PTR      AlignSize
    )

{
    BOOL                haveEnoughMemory = TRUE;
    PVOID               rMemory          = NULL;
    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle;
    PPOOLMEMORYBLOCK    currentBlock;
    DWORD_PTR           sizeNeeded;
    DWORD_PTR           padLength;

    assert(poolHeader != NULL);

    currentBlock = poolHeader -> PoolHead;

    // Determine if more memory is needed, attempt to add if needed.
    sizeNeeded = Size;

    if (currentBlock -> Size - currentBlock -> Index < sizeNeeded + AlignSize) {

        haveEnoughMemory = PoolMemAddMemory(poolHeader,sizeNeeded + AlignSize);
        currentBlock = poolHeader -> PoolHead;
    }

    // If there is enough memory available, return it.
    if (haveEnoughMemory) {
        if (AlignSize) {

            padLength = (DWORD_PTR) currentBlock + sizeof(POOLMEMORYBLOCK) 
                + currentBlock -> Index;
            currentBlock -> Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

        }
      
         
        //Now, get the address of the memory to return.
        rMemory = (PVOID) 
            &(currentBlock->RawMemory[currentBlock -> Index]);
 
        currentBlock->Index += sizeNeeded;
    }

    return rMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by migrate.rc
//
#define IDS_PRODUCT_STRING              1
#define IDS_PRODUCT_ID                  1
#define IDS_VERMEER_PWS_1_NOT_SUPPORTED 2
#define IDS_MIGRATION_LOG_FILENAME      4
#define IDS_PWS10_HKLM_REG_TO_MIGRATE   5
#define IDS_PWS40_HKLM_REG_TO_MIGRATE   6
#define IDS_NT5_BETA2_NOT_SUPPORTED     7
#define IDS_TARGET_OS_DOES_NOT_SUPPORT_UPGRADE 8
#define IDS_DEL_LNK_TO_THESE_EXE_FILENAMES 9

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\poolmem.h ===
#ifndef POOLMEM_H
#define POOLMEM_H

typedef LPVOID POOLHANDLE;


#define POOLMEMORYBLOCKSIZE 8192


POOLHANDLE WINAPI PoolMemInitPool ();
VOID       WINAPI PoolMemDestroyPool (IN POOLHANDLE Handle);
LPVOID     WINAPI PoolMemGetAlignedMemory(IN POOLHANDLE Handle, IN DWORD_PTR Size, IN DWORD_PTR AlignSize);


#define PoolMemCreateString(h,x)        ((LPTSTR) PoolMemGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PoolMemCreateDword(h)           ((PDWORD) PoolMemGetMemory((h),sizeof(DWORD)))


__inline
LPVOID 
PoolMemGetMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{

    return PoolMemGetAlignedMemory(Handle,Size,0);

}

__inline
LPTSTR 
PoolMemCreateStringA ( 
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(CHAR),sizeof(CHAR));
}

__inline
LPWSTR 
PoolMemCreateStringW (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPWSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(WCHAR),sizeof(WCHAR));
}


__inline
PTSTR 
PoolMemDuplicateStringA (
    IN POOLHANDLE    Handle,
    IN LPCSTR       StringToCopy
    )

{
    DWORD_PTR  stringLength;
    PSTR    rString;
    assert(StringToCopy);

    stringLength = strlen(StringToCopy)+1;
    rString      = (PSTR) PoolMemGetAlignedMemory(Handle,
        stringLength,
        sizeof(CHAR));

    if (rString) {
        _mbscpy((unsigned char *) rString, (const unsigned char *) StringToCopy);
    }

    return rString;
}


__inline
PWSTR 
PoolMemDuplicateStringW (
    IN POOLHANDLE    Handle,
    IN LPCWSTR       StringToCopy
    )

{

    
    DWORD    stringLength;
    PWSTR    rString;

    assert(StringToCopy);

    stringLength = ((wcslen(StringToCopy)+1)*sizeof(WCHAR));
    rString      = (PWSTR) PoolMemGetAlignedMemory(Handle,stringLength,sizeof(WCHAR));

    if (rString) {

        wcscpy(rString,StringToCopy);
    }

    return rString;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\migrate.cpp ===
#include "stdafx.h"
#pragma hdrstop

//
// Constants
//
#define CP_USASCII          1252
#define END_OF_CODEPAGES    -1

// vendor info struct used in QueryVersion
typedef struct {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

VENDORINFO g_VendorInfo;

//
// Code page array
//
INT g_CodePageArray[] = {CP_USASCII,END_OF_CODEPAGES};

//
// Multi-sz (i.e., double-nul terminated) list of files to find
//
CHAR g_ExeNamesBuf[] = "MetaData.bin\0";
CHAR g_MyProductId[100];
//#define UNATTEND_TXT_PWS_SECTION "PWS_W9x_Migrate_To_NT"
//#define UNATTEND_TXT_PWS_KEY1    "MigrateFile"
#define UNATTEND_TXT_PWS_SECTION "InternetServer"
#define UNATTEND_TXT_PWS_KEY1    "Win95MigrateDll"
#define PRODUCTID_IFRESOURCEFAILS "Microsoft Personal Web Server"
#define LOGFILENAME_IFRESOURCEFAILS "iis_w95.log"

CHAR g_MyDataFileName[] = "iis_w95.dat\0";
CHAR g_MyLogFileName[_MAX_FNAME];
CHAR g_PWS10_Migration_Section_Name_AddReg[] = "PWS10_MIGRATE_TO_NT5_REG\0";
CHAR g_PWS40_Migration_Section_Name_AddReg[] = "PWS40_MIGRATE_TO_NT5_REG\0";
char g_Migration_Section_Name_AddReg[50];
CHAR g_PWS10_Migration_Section_Name_CopyFiles[] = "PWS10_MIGRATE_TO_NT5_COPYFILES\0";
CHAR g_PWS40_Migration_Section_Name_CopyFiles[] = "PWS40_MIGRATE_TO_NT5_COPYFILES\0";
char g_Migration_Section_Name_CopyFiles[50];

CHAR g_WorkingDirectory[_MAX_PATH];
CHAR g_SourceDirectories[_MAX_PATH];
CHAR g_FullFileNamePathToSettingsFile[_MAX_PATH];

int g_iPWS40OrBetterInstalled = FALSE;
int g_iPWS10Installed = FALSE;
int g_iVermeerPWS10Installed = FALSE;

HANDLE g_MyModuleHandle = NULL;
MyLogFile g_MyLogFile;


int TurnOnPrivateLogFile(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft"), &hkey);
    if (err != ERROR_SUCCESS) {return 0;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("SetupDebugLog"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

    //return 1;
    return (int) rc;
}

void My_MigInf_AddMessage(char *szProductId, char *szLoadedString)
{
	iisDebugOut(_T("MigInf_AddMessage:%s,%s"), g_MyProductId,szLoadedString);

	// 1. get the path to our pws migrate.inf
	// 2. stick this information in this section.
	//    [Incompatible Messages]
	//    Microsoft Personal Web Server = "szLoadedString"
	char szMyWorkingDirInfFile[_MAX_PATH];
	strcpy(szMyWorkingDirInfFile, g_WorkingDirectory);
	AddPath(szMyWorkingDirInfFile, "Migrate.inf");

	// the nt supplied api
	// this will write out the stuff below.
	//    [Incompatible Messages]
	//    Microsoft Personal Web Server = "szLoadedString"
	MigInf_AddMessage(g_MyProductId, szLoadedString);

	// Set the other required section.
	// This has to be written, otherwise the user will never get the message.
	// we have to set something, so let's just set the below, that way we know that this will showup.
	// HKLM\Software\Microsoft=Registry
	//
	// [Microsoft Personal Web Server]
	//  something=File
	//  something=Directory
	//  something=Registry
	// 
	if (FALSE == WritePrivateProfileString(szProductId, "\"HKLM\\Software\\Microsoft\"", "Registry", szMyWorkingDirInfFile))
		{iisDebugOut(_T("MigInf_AddMessage:WritePrivateProfileString(2) FAILED"));}

	return;
}


//
// Standard Win32 DLL Entry point
//
BOOL WINAPI DllMain(IN HANDLE DllHandle,IN DWORD  Reason,IN LPVOID Reserved)
{
    BOOL bReturn;
    bReturn = TRUE;

    switch(Reason) 
	{
		case DLL_PROCESS_ATTACH:
			g_MyModuleHandle = DllHandle;

			//
			// We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
			//
			DisableThreadLibraryCalls ((HINSTANCE) DllHandle);

			// open Our log file.
			if (TurnOnPrivateLogFile() != 0)
			{
				if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_MIGRATION_LOG_FILENAME, g_MyLogFileName, sizeof(g_MyLogFileName))) {strcpy(g_MyLogFileName, LOGFILENAME_IFRESOURCEFAILS);}
				strcpy(g_MyLogFile.m_szLogPreLineInfo, "DllMain, DLL_PROCESS_ATTACH:");
				g_MyLogFile.LogFileCreate(g_MyLogFileName);
			}
			
			// SetupAPI error log levels
			// -------------------------
			// LogSevInformation,
			// LogSevWarning,
			// LogSevError,
			// LogSevFatalError, (Reserved for use by windows nt setup)
			// LogSevMaximum

			// Open Setupapi log; FALSE means do not delete existing log
			SetupOpenLog(FALSE);

			LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));
			iisDebugOut(_T("ProductID=%s"), g_MyProductId);

            // if we can't initialize the migration writeback routines
			// then hey we can't do anything
			if (!MigInf_Initialize()) 
			{
				SetupLogError_Wrap(LogSevError, "MigInf_Initialize() FAILED.");
				return FALSE;
			}

            

			// Fall through to process first thread
		case DLL_THREAD_ATTACH:
			bReturn = TRUE;
			break;

		case DLL_PROCESS_DETACH:
			strcpy(g_MyLogFile.m_szLogPreLineInfo, "DllMain, DLL_PROCESS_DETACH:");
			//  clean up migration inf stuff
			MigInf_CleanUp();

			// Close our log file
			g_MyLogFile.LogFileClose();

			// Close setupapi log file
			SetupCloseLog();
			break;

		case DLL_THREAD_DETACH:
			break;
    }

    return(bReturn);
}


//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS: if your migration DLL found one or more installed components for its target application. This guarantees that Setup will call your migration DLL for later processing. 
//		ERROR_NOT_INSTALLED: if your migration DLL initializes properly but did not find any of its components installed on the active Windows 9x installation. Note that Setup will not call your DLL again if it returns ERROR_NOT_INSTALLED. 
//
//		Your migration DLL must also return ERROR_SUCCESS if it does not attempt to detect installed components in QueryVersion. 
//
//		All other return values (Win32 error values) are considered initialization errors. Setup will report the error to the user, clean up your migration DLL's files, and ask the user to continue or cancel the Windows NT installation process. 
//-----------------------------------------------------------------------
LONG
CALLBACK
QueryVersion (
    OUT     LPCSTR *ProductID,
	OUT     LPUINT DllVersion,
	OUT     LPINT *CodePageArray,	    OPTIONAL
	OUT     LPCSTR *ExeNamesBuf,	    OPTIONAL
    OUT     PVENDORINFO *MyVendorInfo
    )
{
	long lReturn = ERROR_NOT_INSTALLED;
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "QueryVersion:");
	iisDebugOut(_T("Start.  DllVersion=%d."), DllVersion);

    //
    // First, we do some preliminary investigation to see if 
    // our components are installed.  
    //
    if (TRUE != CheckIfPWS95Exists()) 
	{
        //
        // We didn't detect any components, so we return 
        // ERROR_NOT_INSTALLED and the DLL will stop being called.
        // Use this method as much as possible, because user enumeration
        // for MigrateUser9x is relatively slow.  However, don't spend too
        // much time here because QueryVersion is expected to run quickly.
        //

        // Check if frontpage.ini is there!
        if (TRUE != CheckFrontPageINI())
        {
		    goto QueryVersion_Exit;
        }
    }

    //
    // Screen saver is enabled, so tell Setup who we are.  ProductID is used
    // for display, so it must be localized.  The ProductID string is 
    // converted to UNICODE for use on Windows NT via the MultiByteToWideChar
    // Win32 API.  The first element of CodePageArray is used to specify
    // the code page of ProductID, and if no elements are returned in
    // CodePageArray, Setup assumes CP_ACP.
    //
	if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId))) 
		{strcpy(g_MyProductId, PRODUCTID_IFRESOURCEFAILS);}

	// return back this product id
	// warning: somehow they set this back to null or something, so
	// make sure to load g_MyProductId from the resource again.
    *ProductID = g_MyProductId;

    //
    // Report our version.  Zero is reserved for use by DLLs that
    // ship with Windows NT.
    //
    *DllVersion = 1;

    // 
    // Because we have English messages, we return an array that has
    // the English language ID.  The sublanguage is neutral because
    // we do not have currency, time, or other geographic-specific 
    // information in our messages.
    //
    // Tip: If it makes more sense for your DLL to use locales,
    // return ERROR_NOT_INSTALLED if the DLL detects that an appropriate 
    // locale is not installed on the machine.
    //

    // comment this line out so that it works on all languages...
    //*CodePageArray = g_CodePageArray;
    *CodePageArray = NULL;

    //
    // ExeNamesBuf - we pass a list of file names (the long versions)
    // and let Setup find them for us.  Keep this list short because
    // every instance of the file on every hard drive will be reported
    // in migrate.inf.
    //
    // Most applications don't need this behavior, because the registry
    // usually contains full paths to installed components.  We need it,
    // though, because there are no registry settings that give us the
    // paths of the screen saver DLLs.
    //

	// Check which directories we need to make sure are copied over.
	// for pws 1.0
	//   1. msftpsvc values for "Virtual Roots"
	//   2. w3svc values for "Script Map"
	//   3. w3svc values for "Virtual Roots"
	// for pws 4.0
	//   everything is in the metabase
    // do a function here which makes sure that our stuff in these above
	// directories gets copied over or that a warning gets put out to the
	// user that these directories will not be copied...etc,
	ReturnImportantDirs();

    *ExeNamesBuf = g_ExeNamesBuf;

    ZeroMemory(&g_VendorInfo, sizeof(g_VendorInfo));

    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
        g_MyModuleHandle,
        MSG_VI_COMPANY_NAME,MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
        (LPTSTR) g_VendorInfo.CompanyName,
        sizeof(g_VendorInfo.CompanyName),
        NULL) <= 0) 
    {
        strcpy(g_VendorInfo.CompanyName, "Microsoft Corporation.");
    }

    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
        g_MyModuleHandle,
        MSG_VI_SUPPORT_NUMBER,
        MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
        (LPTSTR) g_VendorInfo.SupportNumber,
        sizeof(g_VendorInfo.SupportNumber),
        NULL) <= 0) 
    {
        strcpy(g_VendorInfo.SupportNumber, "1-800-555-1212 (USA Only).");
    }

    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
        g_MyModuleHandle,
        MSG_VI_SUPPORT_URL,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) g_VendorInfo.SupportUrl,
        sizeof(g_VendorInfo.SupportUrl),
        NULL) <= 0) 
    {
        strcpy(g_VendorInfo.SupportUrl, "http://www.microsoft.com/support.");
    }

    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
        g_MyModuleHandle,
        MSG_VI_INSTRUCTIONS,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) g_VendorInfo.InstructionsToUser,
        sizeof(g_VendorInfo.InstructionsToUser),
        NULL) <= 0) 
    {
        strcpy(g_VendorInfo.InstructionsToUser, "Please contact Microsoft Technical Support for assistance with this problem..");
    }

    *MyVendorInfo = &g_VendorInfo;

    iisDebugOut(_T("CompanyName=%s"), g_VendorInfo.CompanyName);
    iisDebugOut(_T("SupportNumber=%s"), g_VendorInfo.SupportNumber);
    iisDebugOut(_T("SupportUrl=%s"), g_VendorInfo.SupportUrl);
    iisDebugOut(_T("InstructionsToUser=%s"), g_VendorInfo.InstructionsToUser);

	// We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

QueryVersion_Exit:
	iisDebugOut(_T("  End.  Return=%d"), lReturn);
	return lReturn;
}


//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//	ERROR_SUCCESS: if your migration DLL found one or more installed components for the target application. If your DLL does not attempt to detect installed components in Initialize9x, it must also return ERROR_SUCCESS 
//	ERROR_NOT_INSTALLED: if the migration DLL initializes properly but does not find any of its components installed on the active Windows 9x installation. Note that Setup will not call your DLL again if it returns ERROR_NOT_INSTALLED.
//-----------------------------------------------------------------------
LONG CALLBACK Initialize9x ( IN LPCSTR WorkingDirectory, IN LPCSTR SourceDirectories, LPVOID Reserved )
{
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "Initialize9x:");
	long lReturn = ERROR_NOT_INSTALLED;
	iisDebugOut(_T("Start.  WorkingDir=%s, SourceDir=%s."), WorkingDirectory, SourceDirectories);

	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

    //
    // Because we returned ERROR_SUCCESS in QueryVersion, we are being
    // called for initialization.  Therefore, we know we are
    // enabled on the machine at this point.
    // 

    //
    // Make global copies of WorkingDirectory and SourceDirectories --
    // we will not get this information again, and we shouldn't
    // count on Setup keeping the pointer valid for the life of our
    // DLL.
    //
	// Save the working directories
	strcpy(g_WorkingDirectory, WorkingDirectory);
	strcpy(g_SourceDirectories, SourceDirectories);

	// name the settings file
	strcpy(g_FullFileNamePathToSettingsFile, g_WorkingDirectory);
	AddPath(g_FullFileNamePathToSettingsFile, g_MyDataFileName);

    //
    // First, we do some preliminary investigation to see if 
    // our components are installed.  
    //
    if (TRUE != CheckIfPWS95Exists()) 
    {
        // Check if frontpage.ini is there!
        if (TRUE != CheckFrontPageINI())
        {
		    goto Initialize9x_Exit;
        }
    }

    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

Initialize9x_Exit:
	iisDebugOut(_T("  End.  Return=%d. g_WorkingDir=%s, g_SourceDir=%s, g_SettingsFile=%s."), lReturn, g_WorkingDirectory, g_SourceDirectories, g_FullFileNamePathToSettingsFile);
    return lReturn;
}

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// we totally don't care about this part
// Return Values:
//		ERROR_SUCCESS if the target application is installed for the specified user. Also return ERROR_SUCCESS if your migration DLL needs further processing during the Windows NT phase. 
//		ERROR_NOT_INSTALLED if your target application is not installed for the specified user account and that user's registry does not require any processing. However, Setup will continue to call MigrateUser9x for the rest of the users, and MigrateSystem9x if this function returns ERROR_NOT_INSTALLED. 
//		ERROR_CANCELLED if the user wants to exit Setup. You should specify this return value only if ParentWnd is not set to NULL. 
//-----------------------------------------------------------------------
LONG
CALLBACK 
MigrateUser9x (
        IN HWND ParentWnd, 
        IN LPCSTR AnswerFile,
        IN HKEY UserRegKey, 
        IN LPCSTR UserName, 
        LPVOID Reserved
        )
    {
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "MigrateUser9x:");
	long lReturn = ERROR_NOT_INSTALLED;

	// Return not installed since we don't do any user specific stuff.
	lReturn = ERROR_NOT_INSTALLED;

    return ERROR_NOT_INSTALLED;
    }


void HandleFrontPageUpgrade(LPCSTR AnswerFile)
{
    //[HKEY_LOCAL_MACHINE\Software\Microsoft\FrontPage\3.0]
    //"PWSInstalled"="1"
	iisDebugOut(_T("HandleFrontPageUpgrade.  Start."));

	// Check if pws 4.0 or better is installed.
	DWORD rc = 0;
	HKEY hKey = NULL;
	DWORD dwType, cbData;
	BYTE  bData[1000];
	cbData = 1000;
    int iTempFlag = FALSE;

    rc = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\FrontPage", &hKey);
    if (rc != ERROR_SUCCESS) {goto HandleFrontPageUpgrade_Exit;}
	
	// Check if we can read a Value.
	//rc = RegQueryValueEx(hKey,REG_INETSTP_MAJORVERSION_STRINGVALUE,NULL,&dwType,bData,&cbData);
	//if (ERROR_SUCCESS != rc) {goto HandleFrontPageUpgrade_Exit;}

    // kool the key exists
    // let's tell Win2000 setup to make sure to upgrade the FrontPageServer Extensions
	if (0 == WritePrivateProfileString("Components", "fp_extensions", "ON", AnswerFile))
	{
		SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", "fp_extensions", AnswerFile, GetLastError());
	}
    else
    {
        iisDebugOut(_T("HandleFrontPageUpgrade.  Set 'fp_extensions=ON'"));
    }
    
HandleFrontPageUpgrade_Exit:
	if (hKey){RegCloseKey(hKey);}
	iisDebugOut(_T("HandleFrontPageUpgrade.  End."));
    return;
}

// function: HandleInetsrvDir
//
// This function marks all of the inetsrv files as handled.  This causes
// NT to correctly back them up, and reinstall if we remove Whistler, and
// go back to Win9x.
//
// Return Values
//   FALSE - It failed
//   TRUE - It succeeded
DWORD
HandleInetsrvDir()
{
  TCHAR             szSystemDir[_MAX_PATH];
  TCHAR             szWindowsSearch[_MAX_PATH];
  TCHAR             szFilePath[_MAX_PATH];
  WIN32_FIND_DATA   fd;
  HANDLE            hFile;

  // Create Path
  if ( GetWindowsDirectory(szSystemDir, sizeof(szSystemDir) / sizeof(TCHAR) ) == 0)
  {
    return FALSE;
  }
  AddPath(szSystemDir,_T("system\\inetsrv\\"));
  strcpy(szWindowsSearch,szSystemDir);
  AddPath(szWindowsSearch,_T("*.*"));

  iisDebugOut(_T("HandleInetsrvDir:Path=%s\r\n"),szWindowsSearch);

  // Find First File
  hFile = FindFirstFile(szWindowsSearch, &fd);
  if ( hFile == INVALID_HANDLE_VALUE )
  {
    // Could not find file
    return FALSE;
  }

  do {

    if ( !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
      // It is not a directory, so lets add it
      strcpy(szFilePath,szSystemDir);
      AddPath(szFilePath,fd.cFileName);
      iisDebugOut(_T("HandleInetsrvDir:delete=%s\r\n"),szFilePath);
      MigInf_AddHandledFile( szFilePath );
    }
    else
    {
        strcpy(szFilePath,fd.cFileName);
        iisDebugOut(_T("HandleInetsrvDir:skip del=%s\r\n"),szFilePath);
    }

  } while ( FindNextFile(hFile, &fd) ); 

  FindClose(hFile);

  return TRUE;
}

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS if your target application is installed on the system. Also returns ERROR_SUCCESS if system-wide changes need to be made for the target application during the Windows NT phase of the upgrade. 
//		ERROR_NOT_INSTALLED if your migration DLL detects no application components common to the entire system or if your DLL requires no further processing. Note that Setup will continue to call MigrateUser9x for the rest of the users, and MigrateSystem9x if this function returns ERROR_NOT_INSTALLED. 
//		ERROR_CANCELLED if the user elects to exit the Setup program. Use this return value only if ParentWnd is not NULL. 
//-----------------------------------------------------------------------
LONG 
CALLBACK 
MigrateSystem9x (
        IN HWND ParentWnd, 
        IN LPCSTR AnswerFile,
        LPVOID Reserved
        )
{
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "MigrateSystem9x:");
	long lReturn = ERROR_NOT_INSTALLED;
	iisDebugOut(_T("Start.  AnswerFile=%s."), AnswerFile);
	char szMyWorkingDirInfFile[_MAX_PATH];
	strcpy(szMyWorkingDirInfFile, g_WorkingDirectory);
	AddPath(szMyWorkingDirInfFile, "Migrate.inf");

	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

    // do some special stuff for frontpage's .ini file
    MoveFrontPageINI();

    //
    // First, maybe iis isn't even installed, check first.
    // but do this after doing the frontpage stuff
    //
    if (TRUE != CheckIfPWS95Exists())
    {
	    lReturn = ERROR_SUCCESS;
        goto MigrateSystem9x_Exit;
    }


	// If the user has Vermeer pws 1.0 installed then we have to put up a
	// Message saying "sorry we can't upgrade this."
	if (g_iVermeerPWS10Installed == TRUE)
	{
		// get from resource
		char szLoadedString[512];
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_VERMEER_PWS_1_NOT_SUPPORTED, szLoadedString, sizeof(szLoadedString))) 
			{strcpy(szLoadedString, "Warning: Vermeer Frontpage Personal Web Server 1.0 detected and will not be upgraded to IIS 5.0.");}
		// Write the string out to our answer file so that nt5 setup will show it to  the user
		My_MigInf_AddMessage(g_MyProductId, szLoadedString);
		// Important: Write memory version of migrate.inf to disk
		if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}
		goto MigrateSystem9x_Exit;
	}
	//
	// Upgrade from win95 to NT5/iis5 is not supported.
	// IDS_NT5_BETA2_NOT_SUPPORTED
	//
	/*
	8/19/98 commented this stuff for RTM
	if (TRUE == CheckIfPWS95Exists())
	{
		// get from resource
		char szLoadedString[512];
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_NT5_BETA2_NOT_SUPPORTED, szLoadedString, sizeof(szLoadedString))) 
			{strcpy(szLoadedString, "Win2000 Beta will not support upgrades of Personal Web Server from Windows 95, or Windows 98.  Please remove Personal Web Server from your Windows machine, and then add IIS after Win2000 setup has completed.  Setup will continue without installing IIS 5.0.");}
		// Write the string out to our answer file so that nt5 setup will show it to  the user
		My_MigInf_AddMessage(g_MyProductId, szLoadedString);
		// Important: Write memory version of migrate.inf to disk
		if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}
		goto MigrateSystem9x_Exit;
	}
	*/

    // remove all old stuff from the win95 pws10/40 installation.
    // this has to be done regardless if the target os support iis...

    // We need to tell migration setup that we are going to handle certain files...
    // particularly the c:\windows\SendTo\Personal Web Server.lnk file
    // since it doesn't seem to be accessible during win2000/20001 guimode setup
    iisDebugOut(_T("Start.  Calling HandleSendToItems."));
    HandleSendToItems(AnswerFile);
    iisDebugOut(_T("Start.  Calling HandleDesktopItems."));
    HandleDesktopItems(AnswerFile);
    iisDebugOut(_T("Start.  Calling HandleStartMenuItems."));
    HandleStartMenuItems(AnswerFile);
    iisDebugOut(_T("Start.  Calling HandleSpecialRegKey."));
    HandleSpecialRegKey();
    // Handle the inetsrv dir
    iisDebugOut(_T("Start.  Calling HandleInetsrvDir."));
    HandleInetsrvDir();

    if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}

    //MessageBox(NULL, "check out the file now", AnswerFile, MB_OK);

    // check if the target OS (that we want to upgrade to) supports iis on it
    if (FALSE == IsUpgradeTargetSupportIIS(szMyWorkingDirInfFile))
    {
        iisDebugOut(_T("Target OS does not support IIS. put up msg."));
		// get from resource
		char szLoadedString[512];
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_TARGET_OS_DOES_NOT_SUPPORT_UPGRADE, szLoadedString, sizeof(szLoadedString))) 
			{strcpy(szLoadedString, "Warning, the target OS does not support IIS.  IIS will be removed upon upgrade.");}
		// Write the string out to our answer file so that nt setup will show it to  the user
		My_MigInf_AddMessage(g_MyProductId, szLoadedString);
		// Important: Write memory version of migrate.inf to disk
		if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}
        lReturn = ERROR_SUCCESS;
		goto MigrateSystem9x_Exit;
    }
   
	// 1. do any setup upgrade type of work to ensure
	// that we get all the settings stuff over to NT5 land.
	// -------------------------------
	iisDebugOut(_T("Start.  Calling MyUpgradeTasks."));
    MyUpgradeTasks(AnswerFile);

    // If FrontPage is installed, then do some funky hack since
    // the frontpage guys can't fix they upgrade setup bug.
    // HandleFrontPageUpgrade(AnswerFile);

	// 2. move over the registry stuff
	// -------------------------------
	// Lookup the registry settings and save into our "settings" file.
	iisDebugOut(_T("Start.  Calling MySettingsFile_Write."));
    MySettingsFile_Write();

	// We need to tell NT5 gui mode setup (where iis/pws will actually get upgraded).
	// Where to find the upgrade file.  
	// during upgrade it should just install the DefaultInstall section of the pwsmigt.dat file
	// We will tell iis/pws nt5 setup where the pwsmigt.dat in the answer file.
	// Answer file should be located in the c:\windows\setup\unattend.tmp file on the win95 side.
	// On the WinNT5 side, it should be at...
	assert(AnswerFile);
	iisDebugOut(_T("Start.  Calling WritePrivateProfileString.%s."), AnswerFile);
	if (0 == WritePrivateProfileString(UNATTEND_TXT_PWS_SECTION, UNATTEND_TXT_PWS_KEY1, g_FullFileNamePathToSettingsFile, AnswerFile))
	{
		SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", UNATTEND_TXT_PWS_SECTION, AnswerFile, GetLastError());
		goto MigrateSystem9x_Exit;
	}

/*
    Example: For Generating messages to the user during Win95 time
	MigInf_AddMessage(g_MyProductId, "We were unable to upgrade the pws 1.0 installation because of failure.");
	// Important: Write memory version of migrate.inf to disk
	if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}
*/
			
    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

MigrateSystem9x_Exit:
    W95ShutdownW3SVC();
	iisDebugOut(_T("  End.  Return=%d."), lReturn);
    return lReturn;
}

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS if your migration DLL initializes properly within the Windows NT environment. 
//		All other return values (Win32 error values) are considered critical errors. Setup reports the error to the user and then cancels processing your migration DLL. However, Setup will not continue the upgrade. Any errors or logs generated will include the ProductID string specified in QueryVersion to identify your DLL. 
//-----------------------------------------------------------------------
LONG CALLBACK InitializeNT ( IN LPCWSTR WorkingDirectory, IN LPCWSTR SourceDirectories, LPVOID Reserved )
{
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "InitializeNT:");
	iisDebugOut(_T("Start."));
	long lReturn = ERROR_NOT_INSTALLED;
	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

	// change the Wide characters to ansi
    WideCharToMultiByte (CP_ACP, 0, WorkingDirectory, -1,g_WorkingDirectory,_MAX_PATH,NULL,NULL);
	WideCharToMultiByte (CP_ACP, 0, SourceDirectories, -1,g_SourceDirectories,_MAX_PATH,NULL,NULL);
	// name the settings file
	strcpy(g_FullFileNamePathToSettingsFile, g_WorkingDirectory);
	AddPath(g_FullFileNamePathToSettingsFile, g_MyDataFileName);
	
    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

	iisDebugOut(_T("  End.  Return=%d, g_WorkingDir=%s, g_SourceDir=%s, g_SettingsFile=%s."), lReturn, g_WorkingDirectory, g_SourceDirectories, g_FullFileNamePathToSettingsFile);
    return lReturn;
}

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS if the migration of user-specific settings is successful.
//		Other error codes will terminate the processing of your migration DLL. However, Windows NT Setup will proceed. Ideally, only critical problems (such as a hardware failure) should generate terminating error codes. 
//-----------------------------------------------------------------------
LONG CALLBACK MigrateUserNT (  IN HINF AnswerFileHandle, IN HKEY UserRegKey, IN LPCWSTR UserName,  LPVOID Reserved )
    {
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "MigrateUserNT:");
	iisDebugOut(_T("Start."));
	long lReturn = ERROR_NOT_INSTALLED;
	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;
	iisDebugOut(_T("  End.  Return=%d."), lReturn);
    return lReturn;
    }

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS if the migration of system-wide settings is successful.
//		Other error codes will terminate the processing of your migration DLL. However, Windows NT Setup will proceed. Ideally, only critical problems (such as a hardware failure) should generate terminating error codes
//-----------------------------------------------------------------------
LONG CALLBACK MigrateSystemNT (  IN HINF AnswerFileHandle, LPVOID Reserved )
{
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "MigrateSystemNT:");
	long lReturn = ERROR_NOT_INSTALLED;
	iisDebugOut(_T("Start."));
	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

    // Delete the Win95 migrated StartMenu/Desktop Items!
    iisDebugOut(_T("Calling iis.dll section: %s. Start."),_T("OC_CLEANUP_WIN95_MIGRATE"));
    Call_IIS_DLL_INF_Section("OC_CLEANUP_WIN95_MIGRATE");
    iisDebugOut(_T("Calling iis.dll section: %s. End."), _T("OC_CLEANUP_WIN95_MIGRATE"));

	// ------------------------------------------
	// We don't need to do anything in this part:
	// Because:
	//  1. this migration stuff (MigrateSystemNT) Gets called in NT5 setup
	//     after all the ocmanage stuff is completed.  By then our IIS5/PWS5 setup 
	//     would have already upgrade the internet server.
	//     We just have to make sure that the iis/pws 5.0 setup finds our
	//     "Settings" file and installs the default section within it.
	//  2. based on #1 if we install the "settings" file, we will hose
	//     the registry settings which were created during the ocmanage nt5 gui mode setup.
	// ------------------------------------------

	// Execute an .inf section from our "settings" file
	//if (MySettingsFile_Install() != TRUE) {goto MigrateSystemNT_Exit;}
    AnswerFile_ReadSectionAndDoDelete(AnswerFileHandle);

    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

//MigrateSystemNT_Exit:
	iisDebugOut(_T("  End.  Return=%d."), lReturn);
    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\uniutil\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

void   ShowHelp(void);
LPSTR  StripWhitespace(LPSTR pszString);
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz);
int    Ansi2Unicode(TCHAR * szAnsiFile_input,TCHAR * szUnicodeFile_output,UINT iCodePage);
int    IsFileUnicode(TCHAR * szFile_input);
int    StripControlZfromUnicodeFile(TCHAR * szFilePath1,TCHAR * szFilePath2);

//***************************************************************************
//*                                                                         
//* purpose: main
//*
//***************************************************************************
int __cdecl  main(int argc,char *argv[])
{
    int iRet = 0;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    TCHAR szFilePath1[_MAX_PATH];
    TCHAR szFilePath2[_MAX_PATH];
    TCHAR szParamString_C[_MAX_PATH];
    TCHAR szParamString_H[50];
    TCHAR szParamString_M[_MAX_PATH];

    int iDoAnsi2Unicode         = FALSE;
    int iDoIsUnicodeCheck       = FALSE;
    int iDoUnicodeStripControlZ = FALSE;
    int iDoVersion = FALSE;
    int iGotParamC = FALSE;
    int iGotParamH = FALSE;
    int iGotParamM = FALSE;

    *szFilePath1 = '\0';
    *szFilePath2 = '\0';
    *szParamString_C = '\0';
    *szParamString_H = '\0';
    *szParamString_M = '\0';
    _tcscpy(szFilePath1,_T(""));
    _tcscpy(szFilePath2,_T(""));
    _tcscpy(szParamString_C,_T(""));
    _tcscpy(szParamString_H,_T(""));
    _tcscpy(szParamString_M,_T(""));
        
    for(argno=1; argno<argc; argno++) 
    {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' ) 
        {
            switch (argv[argno][1]) 
            {
                case 'a':
                case 'A':
                    iDoAnsi2Unicode = TRUE;
                    break;
                case 'i':
                case 'I':
                    iDoIsUnicodeCheck = TRUE;
                    break;
                case 'z':
                case 'Z':
                    iDoUnicodeStripControlZ = TRUE;
                    break;
                case 'v':
                case 'V':
                    iDoVersion = TRUE;
                    break;
                case 'c':
                case 'C':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_C, _MAX_PATH);
#else
                        _tcscpy(szParamString_C,szTempString);
#endif

                        iGotParamC = TRUE;
					}
                    break;
                case 'h':
                case 'H':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_H, _MAX_PATH);
#else
                        _tcsncpy(szParamString_H,szTempString,sizeof(szParamString_H)/sizeof(TCHAR));
                        szParamString_H[sizeof(szParamString_H)/sizeof(TCHAR) - 1] = '\0';
#endif
                        iGotParamH = TRUE;
					}
                    break;
                case 'm':
                case 'M':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_M, _MAX_PATH);
#else
                        _tcscpy(szParamString_M,szTempString);
#endif
                        iGotParamM = TRUE;
					}
                    break;

                case '?':
                    goto main_exit_with_help;
                    break;
            }
        }
        else 
        {
            if (_tcsicmp(szFilePath1, _T("")) == 0)
            {
                // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath1, _MAX_PATH);
#else
                _tcscpy(szFilePath1,argv[argno]);
#endif
            }
            else
            {
                if (_tcsicmp(szFilePath2, _T("")) == 0)
                {
                    // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                    MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath2, _MAX_PATH);
#else
                    _tcscpy(szFilePath2,argv[argno]);
#endif
                }
            }
        }
    }

    //
    // Check what were supposed to do
    //
    if (TRUE == iDoAnsi2Unicode)
    {
        UINT iCodePage = 1252;

        // check for required parameters
        if (_tcsicmp(szFilePath1, _T("")) == 0)
        {
            _tprintf(_T("[-a] parameter missing filename1 parameter\n"));
            goto main_exit_with_help;
        }

        if (_tcsicmp(szFilePath2, _T("")) == 0)
        {
            _tprintf(_T("[-a] parameter missing filename2 parameter\n"));
            goto main_exit_with_help;
        }

        // check for optional parameter
        if (TRUE == iGotParamC)
        {
            if (_tcsicmp(szParamString_C, _T("")) == 0)
            {
                // convert it to a number.
                iCodePage = _ttoi(szParamString_C);
            }
        }

        // call the function
        Ansi2Unicode(szFilePath1,szFilePath2,iCodePage);
        
        iRet = 0;
    }
    else
    {
        if (TRUE == iDoUnicodeStripControlZ)
        {
            // check for required parameters
            if (_tcsicmp(szFilePath1, _T("")) == 0)
            {
                _tprintf(_T("[-z] parameter missing filename1 parameter\n"));
                goto main_exit_with_help;
            }

            if (_tcsicmp(szFilePath2, _T("")) == 0)
            {
                _tprintf(_T("[-z] parameter missing filename2 parameter\n"));
                goto main_exit_with_help;
            }

            // call the function.
            iRet = StripControlZfromUnicodeFile(szFilePath1,szFilePath2);
            if (1 == iRet)
            {
                _tprintf(_T("control-z removed and saved to new file\n"));
            }
        
            iRet = 0;
        }
    }

    if (TRUE == iDoIsUnicodeCheck)
    {
        iRet = 0;

        // check for required parameters
        if (_tcsicmp(szFilePath1, _T("")) == 0)
        {
            _tprintf(_T("[-i] parameter missing filename1 parameter\n"));
            goto main_exit_with_help;
        }

        // call the function.
        // return 2 if the file is unicode
        // return 1 if the file is not unicode
        iRet = IsFileUnicode(szFilePath1);
        if (2 == iRet)
        {
            _tprintf(_T("%s is unicode\n"),szFilePath1);
        }
        else if (1 == iRet)
        {
            _tprintf(_T("%s is not unicode\n"),szFilePath1);
        }
        else
        {
            _tprintf(_T("error with file %s\n"),szFilePath1);
        }
    }

    if (TRUE == iDoVersion)
    {
        // output the version
        _tprintf(_T("1\n\n"));

        iRet = 10;
        goto main_exit_gracefully;
    }


    if (TRUE == iGotParamH)
    {
        // Output hex number
        if (_tcsicmp(szParamString_H, _T("")) != 0)
        {
            DWORD dwMyDecimal = _ttoi(szParamString_H);

            if (iGotParamM && (_tcsicmp(szParamString_M, _T("")) != 0))
            {
                _tprintf(szParamString_M,dwMyDecimal);
            }
            else
            {
                // convert it to a hex number
                _tprintf(_T("%x\n"),dwMyDecimal);
            }
            goto main_exit_gracefully;
        }
    }

    if (_tcsicmp(szFilePath1, _T("")) == 0)
    {
        goto main_exit_with_help;
    }

    goto main_exit_gracefully;
  
main_exit_gracefully:
    exit(iRet);

main_exit_with_help:
    ShowHelp();
    exit(iRet);
}


//***************************************************************************
//*                                                                         
//* purpose: ?
//*
//***************************************************************************
void ShowHelp(void)
{
	TCHAR szModuleName[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];

    // get the modules full pathed filename
	if (0 != GetModuleFileName(NULL,(LPTSTR) szModuleName,_MAX_PATH))
    {
	    // Trim off the filename only.
	    _tsplitpath(szModuleName, NULL, NULL, szFilename_only, NULL);
   
        _tprintf(_T("Unicode File Utility\n\n"));
        _tprintf(_T("%s [-a] [-i] [-v] [-z] [-c:codepage] [-h:number] [-m:printf format] [drive:][path]filename1 [drive:][path]filename2\n\n"),szFilename_only);
        _tprintf(_T("[-a] paramter -- converting ansi to unicode file:\n"));
        _tprintf(_T("   -a           required parameter for this functionality\n"));
        _tprintf(_T("   -c:codepage  specifies the codepage to use (optional,defaults to 1252 (usa ascii))\n"));
        _tprintf(_T("   filename1    ansi filename that should be converted\n"));
        _tprintf(_T("   filename2    unicode filename that result will be saved to\n\n"));
        _tprintf(_T("[-i] parameter -- is specified file unicode:\n"));
        _tprintf(_T("   -i           required paramter for this functionality\n"));
        _tprintf(_T("   filename1    filename to check if unicode.  if unicode ERRORLEVEL=2, if not unicode ERRORLEVEL=1.\n"));
        _tprintf(_T("[-z] parameter -- removing trailing control-z from end of unicode file:\n"));
        _tprintf(_T("   -z           required paramter for this functionality\n"));
        _tprintf(_T("   filename1    unicode filename that should have control-z removed from\n"));
        _tprintf(_T("   filename2    unicode filename that result will be saved to\n\n"));

        _tprintf(_T("[-h] parameter -- displaying version:\n"));
        _tprintf(_T("   -h:decimalnum required paramter for this functionality, input decimal number, get hex back.\n"));
        _tprintf(_T("[-m] parameter -- printf format for -h function:\n"));
        _tprintf(_T("   -m:%%x required paramter for this functionality.. eg:%%x,0x%%x,x%%08lx,x8%%07lx\n"));

        _tprintf(_T("[-v] parameter -- displaying version:\n"));
        _tprintf(_T("   -v           required paramter for this functionality, sets ERRORLEVEL=version num of this binary.\n"));
        _tprintf(_T("\n"));
        _tprintf(_T("Examples:\n"));
        _tprintf(_T("%s -a -c:1252 c:\\MyGroup\\MyFileAnsi.txt c:\\MyGroup\\MyFileUnicode.txt\n"),szFilename_only);
        _tprintf(_T("%s -i c:\\MyGroup\\MyFileUnicode.txt\n"),szFilename_only);
        _tprintf(_T("%s -z c:\\MyGroup\\MyFileUnicode.txt c:\\MyGroup\\MyFileUnicode.txt\n"),szFilename_only);
    }
    return;
}


//***************************************************************************
//*                                                                         
//* purpose: 
//*
//***************************************************************************
LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) 
    {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) 
    {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}


//***************************************************************************
//*                                                                         
//* purpose: return back a Alocated wide string from a ansi string
//*          caller must free the returned back pointer with GlobalFree()
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // make sure they gave us something
    if (!psz)
    {
        return NULL;
    }

    // compute the length
    i =  MultiByteToWideChar(uiCodePage, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate memory in that length
    pwsz = (LPWSTR) GlobalAlloc(GPTR,i * sizeof(WCHAR));
    if (!pwsz) return NULL;

    // clear out memory
    memset(pwsz, 0, wcslen(pwsz) * sizeof(WCHAR));

    // convert the ansi string into unicode
    i =  MultiByteToWideChar(uiCodePage, 0, (LPSTR) psz, -1, pwsz, i);
    if (i <= 0) 
        {
        GlobalFree(pwsz);
        pwsz = NULL;
        return NULL;
        }

    // make sure ends with null
    pwsz[i - 1] = 0;

    // return the pointer
    return pwsz;
}


//***************************************************************************
//*                                                                         
//* purpose: converts the ansi file to a unicode file
//*
//***************************************************************************
int Ansi2Unicode(TCHAR * szAnsiFile_input,TCHAR * szUnicodeFile_output,UINT iCodePage)
{
    int iReturn = FALSE;
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    DWORD dwFileSize    = 0;
    unsigned char *pInputFileBuf = NULL;
    WCHAR * pwOutputFileBuf = NULL;
    DWORD dwBytesReadIn  = 0;
    DWORD dwBytesWritten = 0;
    BYTE bOneByte = 0;

    //
    // READ INPUT FILE
    //
    // open the input file with read access
    //
    hFile = CreateFile((LPCTSTR) szAnsiFile_input, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("Unable to open input file:%s,err=0x%x\n"),szAnsiFile_input,GetLastError());
        goto Ansi2Unicode_Exit;
    }
	    
    // getfile size so we know how much memory we should allocate
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == 0)
    {
        _tprintf(_T("input file:%s is empty\n"),szAnsiFile_input);
        goto Ansi2Unicode_Exit;
    }
	
    // allocate the memory the size of the file
    if ( ( pInputFileBuf = (unsigned char *) malloc( (size_t) dwFileSize + 1 ) ) == NULL )
    {	
        _tprintf(_T("Out of memory\n"));
        goto Ansi2Unicode_Exit;
    }
    
    // clear buffer we just created
    memset(pInputFileBuf, 0, dwFileSize + 1);

    // Read all the data from the file into the buffer
    if ( ReadFile( hFile, pInputFileBuf, dwFileSize, &dwBytesReadIn, NULL ) == FALSE )
    {
        _tprintf(_T("Readfile:%s, error=%s\n"),szAnsiFile_input,strerror(errno));
        goto Ansi2Unicode_Exit;
    }

    // if the amount of data that we read in is different than
    // what the file size is then get out... we didn't read all of the data into the buffer.
    if (dwFileSize != dwBytesReadIn)
    {
        _tprintf(_T("Readfile:%s, error file too big to read into memory\n"),szAnsiFile_input);
        goto Ansi2Unicode_Exit;
    }

    // check if the input file is already unicode!
    // if it is then just copy the file to the new filename!
    if (0xFF == pInputFileBuf[0] && 0xFE == pInputFileBuf[1])
    {
        // file is already unicode!
        if (FALSE == CopyFile((LPCTSTR)szAnsiFile_input,(LPCTSTR)szUnicodeFile_output, FALSE))
        {
            _tprintf(_T("Failed to copy file %s to %s\n"),szAnsiFile_input,szUnicodeFile_output);
        }
        
        // we copied the file to the new filename
        // we're done
        goto Ansi2Unicode_Exit;
    }
        
    // close handle to file#1
    CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;


    //
    // CREATE OUTPUT FILE
    //
    // Take the ansi string and convert it to unicode
    pwOutputFileBuf = (LPWSTR) MakeWideStrFromAnsi(iCodePage,(LPSTR) pInputFileBuf);
    if(NULL == pwOutputFileBuf)
    {
        _tprintf(_T("Out of memory\n"));
        goto Ansi2Unicode_Exit;
    } 

    // Create a new unicode file
    hFile = CreateFile((LPCTSTR) szUnicodeFile_output, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("CreateFile:%s,error=0x%x\n"),szUnicodeFile_output,GetLastError());
        goto Ansi2Unicode_Exit;
    }

    // Write the BOF header to say that this is infact a unicode file
    bOneByte = 0xFF;
    WriteFile(hFile,(LPCVOID) &bOneByte, 1, &dwBytesWritten, NULL);
    bOneByte = 0xFE;
    WriteFile(hFile,(LPCVOID) &bOneByte, 1, &dwBytesWritten, NULL);

    // Append our data to the file
    if ( WriteFile( hFile, pwOutputFileBuf, wcslen(pwOutputFileBuf) * sizeof(WCHAR), &dwBytesWritten, NULL ) == FALSE )
    {
        _tprintf(_T("WriteFile:%s,error=%s\n"),szUnicodeFile_output,strerror(errno));
        goto Ansi2Unicode_Exit;
    }

    // SUCCESS
    iReturn = TRUE;

Ansi2Unicode_Exit:
    if (INVALID_HANDLE_VALUE != hFile)
        {CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;}
    if (pInputFileBuf)
        {free(pInputFileBuf);pInputFileBuf=NULL;}
    if (pwOutputFileBuf)
        {GlobalFree(pwOutputFileBuf);pwOutputFileBuf=NULL;}
    return iReturn;
}


// returns 2 if the file is unicode
// returns 1 if the file is not unicode
// returns 0 on error
int IsFileUnicode(TCHAR * szFile_input)
{
    int iReturn = 0;
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    DWORD dwBytesToRead = 2;
    unsigned char *pInputFileBuf = NULL;
    DWORD dwBytesReadIn  = 0;

    //
    // READ INPUT FILE
    //
    // open the input file with read access
    //
    hFile = CreateFile((LPCTSTR) szFile_input, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("Unable to open input file:%s,err=0x%x\n"),szFile_input,GetLastError());
        goto IsFileUnicode_Exit;
    }
	    
    // allocate the memory the size of the file
    if ( ( pInputFileBuf = (unsigned char *) malloc( (size_t) dwBytesToRead) ) == NULL )
    {	
        _tprintf(_T("Out of memory\n"));
        goto IsFileUnicode_Exit;
    }
    
    // clear buffer we just created
    memset(pInputFileBuf, 0, dwBytesToRead);

    // Read all the data from the file into the buffer
    if ( ReadFile( hFile, pInputFileBuf, dwBytesToRead, &dwBytesReadIn, NULL ) == FALSE )
    {
        _tprintf(_T("Readfile:%s, error=%s\n"),szFile_input,strerror(errno));
        goto IsFileUnicode_Exit;
    }

    // if the amount of data that we read in is different than
    // what the file size is then get out... we didn't read all of the data into the buffer.
    if (dwBytesToRead != dwBytesReadIn)
    {
        _tprintf(_T("Readfile:%s, error file too big to read into memory\n"),szFile_input);
        goto IsFileUnicode_Exit;
    }

    // check if the input file is unicode
    iReturn = 1;
    if (0xFF == pInputFileBuf[0] && 0xFE == pInputFileBuf[1])
    {
        iReturn = 2;
    }
        
IsFileUnicode_Exit:
    if (INVALID_HANDLE_VALUE != hFile)
        {CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;}
    if (pInputFileBuf)
        {free(pInputFileBuf);pInputFileBuf=NULL;}
    return iReturn;
}


int StripControlZfromUnicodeFile(TCHAR * szFile_input,TCHAR * szFile_output)
{
    // open the input file
    // if it's unicode, then see if it ends with a control Z
    int iReturn = 0;
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    DWORD dwFileSize = 0;
    unsigned char *pInputFileBuf = NULL;
    DWORD dwBytesReadIn  = 0;
    int iFileIsUnicode = FALSE;
    int iWeNeedMakeChange = FALSE;

    //
    // READ INPUT FILE
    //
    // open the input file with read access
    //
    hFile = CreateFile((LPCTSTR) szFile_input, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("Unable to open input file:%s,err=0x%x\n"),szFile_input,GetLastError());
        goto StripControlZfromUnicodeFile_Exit;
    }

    // getfile size so we know how much memory we should allocate
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == 0)
    {
        _tprintf(_T("input file:%s is empty\n"),szFile_input);
        goto StripControlZfromUnicodeFile_Exit;
    }

    // allocate the memory the size of the file
    if ( ( pInputFileBuf = (unsigned char *) malloc( (size_t) dwFileSize + 1 ) ) == NULL )
    {	
        _tprintf(_T("Out of memory\n"));
        goto StripControlZfromUnicodeFile_Exit;
    }
    
    // clear buffer we just created
    memset(pInputFileBuf, 0, dwFileSize + 1);

    // Read all the data from the file into the buffer
    if ( ReadFile( hFile, pInputFileBuf, dwFileSize, &dwBytesReadIn, NULL ) == FALSE )
    {
        _tprintf(_T("Readfile:%s, error=%s\n"),szFile_input,strerror(errno));
        goto StripControlZfromUnicodeFile_Exit;
    }

    // if the amount of data that we read in is different than
    // what the file size is then get out... we didn't read all of the data into the buffer.
    if (dwFileSize != dwBytesReadIn)
    {
        _tprintf(_T("Readfile:%s, error file too big to read into memory\n"),szFile_input);
        goto StripControlZfromUnicodeFile_Exit;
    }

    // check if the input file is unicode
    if (0xFF == pInputFileBuf[0] && 0xFE == pInputFileBuf[1])
    {
        iFileIsUnicode = TRUE;
    }

    // close the file we opened
    CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;

    // open file #2

    if (TRUE == iFileIsUnicode)
    {
        // Check if it has a control-z at the end
        if (0x1A == pInputFileBuf[dwFileSize])
        {
            pInputFileBuf[dwFileSize] = 0x0;
            iWeNeedMakeChange = TRUE;
        }
        if (0x1A == pInputFileBuf[dwFileSize-1])
        {
            pInputFileBuf[dwFileSize-1] = 0x0;
            iWeNeedMakeChange = TRUE;
        }
    }

    if (TRUE == iWeNeedMakeChange)
    {
        DWORD dwBytesWritten = 0;

        // Create a new unicode file
        hFile = CreateFile((LPCTSTR) szFile_output, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if( hFile == INVALID_HANDLE_VALUE)
        {
            _tprintf(_T("CreateFile:%s,error=0x%x\n"),szFile_output,GetLastError());
            goto StripControlZfromUnicodeFile_Exit;
        }
        // write the file out that we fixed
        //
        // we have to minus out one byte here
        //
        // before:
        // 00 0D 00 0A 00 1A
        //
        // after
        // 00 0D 00 0A 00
        //
        if ( WriteFile( hFile, pInputFileBuf, dwBytesReadIn-1, &dwBytesWritten, NULL ) == FALSE )
        {
            _tprintf(_T("WriteFile:%s,error=%s\n"),szFile_output,strerror(errno));
            goto StripControlZfromUnicodeFile_Exit;
        }

        // return 1 to say that we had to strip of the control-z
        // from the end of the file
        iReturn = 1;
    }
    else
    {
        // just open the file over to the new filename
        if (FALSE == CopyFile((LPCTSTR)szFile_input,(LPCTSTR)szFile_output, FALSE))
        {
            _tprintf(_T("Failed to copy file %s to %s\n"),szFile_input,szFile_output);
        }
    }

    
StripControlZfromUnicodeFile_Exit:
    if (INVALID_HANDLE_VALUE != hFile)
        {CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;}
    if (pInputFileBuf)
        {free(pInputFileBuf);pInputFileBuf=NULL;}

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\setup\util\migrate\stdafx.h ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include <objbase.h>
#include <shellapi.h>

// included for setupapi stuff
#include <setupapi.h>
#include <shlobj.h>
#include <advpub.h>

// for our metabase stuff
#include "iiscnfg.h"

// this module specific
#include "helper.h"
#include "log.h"

// migrate modules
#include <mbstring.h>
#include <tchar.h>
#include <assert.h>
#include "poolmem.h"
#include "miginf.h"

#include "resource.h"
#include "vendinfo.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\staxinc\baset